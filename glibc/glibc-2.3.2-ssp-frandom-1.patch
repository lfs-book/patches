Submitted By: Robert Connolly <robert at linuxfromscratch dot org> (ashes)
Date: 2004-04-18
Initial Package Version: 2.3.2
Origin: http://emu.gentoo.org/~pappy/gentoo-x86/sys-libs/glibc/ \
        glibc-2.3.2-propolice-guard-functions.patch
        http://www.openbsd.org/cgi-bin/cvsweb/src/lib/libc/sys/stack_protector.c
Description: Smashing Stack Protector - This patch adds guard functions to libc.
This patch depends on erandom sysctl from http://frandom.sourceforge.net/
http://www.research.ibm.com/trl/projects/security/ssp/
http://www.linuxfromscratch.org/hlfs/
http://www.gentoo.org/proj/en/hardened/
http://www.linuxfromscratch.org/hints/downloads/files/ssp.txt
http://www.linuxfromscratch.org/hints/downloads/files/entropy.txt

diff -Naur glibc-2.3.2.orig/sysdeps/generic/libc-start.c glibc-2.3.2.ssp-frandom/sysdeps/generic/libc-start.c
--- glibc-2.3.2.orig/sysdeps/generic/libc-start.c	2003-02-14 22:59:15.000000000 +0000
+++ glibc-2.3.2.ssp-frandom/sysdeps/generic/libc-start.c	2004-04-19 01:34:52.000000000 +0000
@@ -149,6 +149,9 @@
     {
       /* XXX This is where the try/finally handling must be used.  */
 
+	  /* call the __guard_setup to set up the random __guard value */
+	  __guard_setup ();	/* pappy@gentoo.org */
+
       result = main (argc, argv, __environ);
     }
 #ifdef HAVE_CANCELBUF
diff -Naur glibc-2.3.2.orig/sysdeps/unix/sysv/linux/Dist glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/Dist
--- glibc-2.3.2.orig/sysdeps/unix/sysv/linux/Dist	2003-02-21 06:30:10.000000000 +0000
+++ glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/Dist	2004-04-19 01:34:52.000000000 +0000
@@ -1,3 +1,4 @@
+ssp.c
 bits/initspin.h
 cmsg_nxthdr.c
 dl-brk.c
diff -Naur glibc-2.3.2.orig/sysdeps/unix/sysv/linux/Makefile glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/Makefile
--- glibc-2.3.2.orig/sysdeps/unix/sysv/linux/Makefile	2002-12-16 23:36:52.000000000 +0000
+++ glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/Makefile	2004-04-19 01:34:52.000000000 +0000
@@ -1,5 +1,5 @@
 ifeq ($(subdir),csu)
-sysdep_routines += errno-loc
+sysdep_routines += errno-loc ssp
 endif
 
 ifeq ($(subdir),db2)
diff -Naur glibc-2.3.2.orig/sysdeps/unix/sysv/linux/Versions glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/Versions
--- glibc-2.3.2.orig/sysdeps/unix/sysv/linux/Versions	2002-12-16 23:28:17.000000000 +0000
+++ glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/Versions	2004-04-19 01:34:52.000000000 +0000
@@ -108,6 +108,8 @@
   GLIBC_2.3.2 {
     # New kernel interfaces.
     epoll_create; epoll_ctl; epoll_wait;
+	# global objects and functions for the propolice patch in gcc - moved from libgcc by pappy@gentoo.org
+	__guard; __guard_setup; __stack_smash_handler;
   }
   GLIBC_PRIVATE {
     # needed by libpthread.
diff -Naur glibc-2.3.2.orig/sysdeps/unix/sysv/linux/ssp.c glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/ssp.c
--- glibc-2.3.2.orig/sysdeps/unix/sysv/linux/ssp.c	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.2.ssp-frandom/sysdeps/unix/sysv/linux/ssp.c	2004-04-19 01:31:37.000000000 +0000
@@ -0,0 +1,119 @@
+/*	$hlfs: ssp.c,v 1.0 2004/04/18 00:00:00 robert Exp $	*/
+
+/*
+ * Copyright (c) 2002 Hiroaki Etoh, Federico G. Schwindt, and Miodrag Vallat.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/sysctl.h>
+
+#include <signal.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <sys/syslog.h>
+#ifndef _PATH_LOG
+#define _PATH_LOG "/dev/log"
+#endif
+
+extern int __sysctl(int *, u_int, void *, size_t *, void *, size_t);
+long __guard[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+
+void __guard_setup (void)
+{
+	int i, mib[3];
+	size_t len;
+
+	if (__guard[0] != 0)
+		return;
+
+	/* Random is another depth in Linux, hence an array of 3. */
+	mib[0] = CTL_KERN;
+	mib[1] = KERN_RANDOM;
+	mib[2] = RANDOM_ERANDOM;
+
+	len = 4;
+	for (i = 0; i < sizeof(__guard) / 4; i++) {
+		if (__sysctl(mib, 3, (char *)&((int *)__guard)[i],
+		    &len, NULL, 0) == -1)
+			break;
+	}
+
+	if (i < sizeof(__guard) / 4) {
+		/* If sysctl was unsuccessful, use the "terminator canary". */
+		((char *)__guard)[0] = 0; ((char*)__guard)[1] = 0;
+		((char *)__guard)[2] = '\n'; ((char *)__guard)[3] = 255;
+	}
+}
+
+void __stack_smash_handler (char func[], int damaged)
+{
+  extern char * __progname;
+  const char message[] = ": stack smashing attack in function ";
+  int bufsz = 512, len;
+  char buf[bufsz];
+  int LogFile;
+  struct sockaddr_un SyslogAddr;  /* AF_UNIX address of local logger */
+    sigset_t mask;
+    sigfillset(&mask);
+    sigdelset(&mask, SIGABRT);  /* Block all signal handlers */
+    sigprocmask(SIG_BLOCK, &mask, NULL); /* except SIGABRT */
+
+  strcpy(buf, "<2>"); len=3;    /* send LOG_CRIT */
+  strncat(buf, __progname, bufsz-len-1); len = strlen(buf);
+  if (bufsz>len) {strncat(buf, message, bufsz-len-1); len = strlen(buf);}
+  if (bufsz>len) {strncat(buf, func, bufsz-len-1); len = strlen(buf);}
+  /* print error message */
+  write (STDERR_FILENO, buf+3, len-3);
+  if ((LogFile = socket(AF_UNIX, SOCK_DGRAM, 0)) != -1) {
+    /* 
+     * Send "found" message to the "/dev/log" path
+     */
+    SyslogAddr.sun_family = AF_UNIX;
+    (void)strncpy(SyslogAddr.sun_path, _PATH_LOG,
+          sizeof(SyslogAddr.sun_path) - 1);
+    SyslogAddr.sun_path[sizeof(SyslogAddr.sun_path) - 1] = '\0';
+    sendto(LogFile, buf, len, 0, (struct sockaddr *)&SyslogAddr,
+       sizeof(SyslogAddr));
+  }
+
+    /* Make sure the default handler is associated with SIGABRT */
+    struct sigaction sa;
+
+    memset(&sa, 0, sizeof(struct sigaction));
+    sigfillset(&sa.sa_mask);    /* Block all signals */
+    sa.sa_flags = 0;
+    sa.sa_handler = SIG_DFL;
+    sigaction(SIGABRT, &sa, NULL);
+    (void)kill(getpid(), SIGABRT);
+  _exit(127);
+}
+
