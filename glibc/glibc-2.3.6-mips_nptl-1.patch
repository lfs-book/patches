Submitted By: Jim Gifford (patches at jg555 dot com)
Date: 2005-11-03
Initial Package Version: 2.3.6
Origin: Glibc CVS
Upstream Status: Unknown
Description: Adds NPTL support for MIPS processors
 
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/Makefile glibc-2.3.6/nptl/sysdeps/mips/Makefile
--- glibc-2.3.6.orig/nptl/sysdeps/mips/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/Makefile	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,25 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
+
+ifeq ($(subdir),nptl)
+libpthread-sysdep_routines += nptl-sysdep
+endif
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/jmpbuf-unwind.h glibc-2.3.6/nptl/sysdeps/mips/jmpbuf-unwind.h
--- glibc-2.3.6.orig/nptl/sysdeps/mips/jmpbuf-unwind.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/jmpbuf-unwind.h	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,30 @@
+/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < (uintptr_t) (_jmpbuf)[0].__sp - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/nptl-sysdep.S glibc-2.3.6/nptl/sysdeps/mips/nptl-sysdep.S
--- glibc-2.3.6.orig/nptl/sysdeps/mips/nptl-sysdep.S	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/nptl-sysdep.S	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,2 @@
+/* Pull in __syscall_error.  */
+#include <sysdep.S>
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/pthread_spin_lock.S glibc-2.3.6/nptl/sysdeps/mips/pthread_spin_lock.S
--- glibc-2.3.6.orig/nptl/sysdeps/mips/pthread_spin_lock.S	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/pthread_spin_lock.S	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#include <sgidefs.h>
+
+ENTRY (pthread_spin_lock)
+	.set	push
+#if _MIPS_SIM == _ABIO32
+	.set	mips2
+#endif
+1:	ll	a2, 0(a0)
+	li	a1, 1
+	bnez	a2, 1b
+	sc	a1, 0(a0)
+	beqz	a1, 1b
+	MIPS_SYNC
+	.set	pop
+	li	v0, 0
+	ret
+PSEUDO_END (pthread_spin_lock)
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/pthread_spin_trylock.S glibc-2.3.6/nptl/sysdeps/mips/pthread_spin_trylock.S
--- glibc-2.3.6.orig/nptl/sysdeps/mips/pthread_spin_trylock.S	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/pthread_spin_trylock.S	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,41 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define _ERRNO_H 1
+#include <bits/errno.h>
+#include <sgidefs.h>
+
+ENTRY (pthread_spin_trylock)
+	.set	push
+#if _MIPS_SIM == _ABIO32
+	.set	mips2
+#endif
+	ll	a2, 0(a0)
+	li	a1, 1
+	bnez	a2, 1f
+	sc	a1, 0(a0)
+	beqz	a1, 1f
+	MIPS_SYNC
+	.set	pop
+	li	v0, 0
+	ret
+1:	li	v0, EBUSY
+	ret
+PSEUDO_END (pthread_spin_trylock)
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/pthreaddef.h glibc-2.3.6/nptl/sysdeps/mips/pthreaddef.h
--- glibc-2.3.6.orig/nptl/sysdeps/mips/pthreaddef.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/pthreaddef.h	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/tcb-offsets.sym glibc-2.3.6/nptl/sysdeps/mips/tcb-offsets.sym
--- glibc-2.3.6.orig/nptl/sysdeps/mips/tcb-offsets.sym	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/tcb-offsets.sym	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/mips/tls.h glibc-2.3.6/nptl/sysdeps/mips/tls.h
--- glibc-2.3.6.orig/nptl/sysdeps/mips/tls.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/mips/tls.h	2005-03-28 09:19:38.000000000 +0000
@@ -0,0 +1,161 @@
+/* Definition for thread-local data handling.  NPTL/MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+/* Note: rd must be $v1 to be ABI-conformant.  */
+# define READ_THREAD_POINTER() \
+    ({ void *__result;							      \
+       asm volatile (".set\tpush\n\t.set\tmips32r2\n\t"			      \
+		     "rdhwr\t%0, $29\n\t.set\tpop" : "=v" (__result));	      \
+       __result; })
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+
+# define READ_THREAD_POINTER(rd) \
+	.set	push;							      \
+	.set	mips32r2;						      \
+	rdhwr	rd, $29;						      \
+	.set	pop
+#endif /* __ASSEMBLER__ */
+
+
+/* We require TLS support in the tools.  */
+#ifndef HAVE_TLS_SUPPORT
+# error "TLS support is required."
+#endif
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_INIT_TCB_SIZE	0
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
+
+/* This is the size of the TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_TCB_SIZE		0
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
+
+/* This is the size we need before TCB - actually, it includes the TCB.  */
+# define TLS_PRE_TCB_SIZE \
+  (sizeof (struct pthread)						      \
+   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
+
+/* The thread pointer (in hardware register $29) points to the end of
+   the TCB + 0x7000, as for PowerPC.  The pthread_descr structure is
+   immediately in front of the TCB.  */
+# define TLS_TCB_OFFSET	0x7000
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({ INTERNAL_SYSCALL_DECL (err);					\
+     long result_var;							\
+     result_var = INTERNAL_SYSCALL (set_thread_area, err, 1,		\
+				    (char *) (tcbp) + TLS_TCB_OFFSET);	\
+     INTERNAL_SYSCALL_ERROR_P (result_var, err)				\
+       ? "unknown error" : NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *) (READ_THREAD_POINTER ()			     \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Access to data in the thread descriptor is easy.  */
+# define THREAD_GETMEM(descr, member) \
+  descr->member
+# define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* l_tls_offset == 0 is perfectly valid on MIPS, so we have to use some
+   different value to mean unset l_tls_offset.  */
+# define NO_TLS_OFFSET		-1
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/CVS/Entries glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/CVS/Entries
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/CVS/Entries	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/CVS/Entries	2005-10-24 08:03:54.000000000 +0000
@@ -0,0 +1,9 @@
+/clone.S/1.1/Mon Mar 28 09:21:52 2005//
+/createthread.c/1.1/Mon Mar 28 09:21:52 2005//
+/fork.c/1.1/Mon Mar 28 09:21:52 2005//
+/lowlevellock.h/1.1/Mon Mar 28 09:21:52 2005//
+/pt-vfork.S/1.1/Mon Mar 28 09:21:52 2005//
+/pthread_once.c/1.1/Mon Mar 28 09:21:52 2005//
+/sysdep-cancel.h/1.1/Mon Mar 28 09:21:52 2005//
+/vfork.S/1.1/Mon Mar 28 09:21:52 2005//
+D/bits////
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/CVS/Repository glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/CVS/Repository
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/CVS/Repository	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/CVS/Repository	2005-10-24 08:03:54.000000000 +0000
@@ -0,0 +1 @@
+libc/nptl/sysdeps/unix/sysv/linux/mips
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/CVS/Root glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/CVS/Root
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/CVS/Root	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/CVS/Root	2005-10-24 08:04:04.000000000 +0000
@@ -0,0 +1 @@
+:pserver:anoncvs@sources.redhat.com:/cvs/glibc
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Entries glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Entries
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Entries	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Entries	2005-10-24 08:03:54.000000000 +0000
@@ -0,0 +1,3 @@
+/pthreadtypes.h/1.1/Tue Mar 29 19:56:26 2005//
+/semaphore.h/1.1/Mon Mar 28 09:21:52 2005//
+D
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Repository glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Repository
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Repository	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Repository	2005-10-24 08:03:54.000000000 +0000
@@ -0,0 +1 @@
+libc/nptl/sysdeps/unix/sysv/linux/mips/bits
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Root glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Root
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Root	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/CVS/Root	2005-10-24 08:04:04.000000000 +0000
@@ -0,0 +1 @@
+:pserver:anoncvs@sources.redhat.com:/cvs/glibc
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/pthreadtypes.h glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/pthreadtypes.h
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/pthreadtypes.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/pthreadtypes.h	2005-03-29 19:56:26.000000000 +0000
@@ -0,0 +1,193 @@
+/* Machine-specific pthread type layouts.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#if _MIPS_SIM == _ABI64
+# define __SIZEOF_PTHREAD_ATTR_T 56
+# define __SIZEOF_PTHREAD_MUTEX_T 40
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 56
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 32
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
+
+
+/* Thread identifiers.  The structure of the attribute type is
+   deliberately not exposed.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+#if _MIPS_SIM == _ABI64
+    unsigned int __nusers;
+#endif
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+#if _MIPS_SIM != _ABI64
+    unsigned int __nusers;
+#endif
+    int __spins;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is deliberately not exposed.  */
+typedef union
+{
+# if _MIPS_SIM == _ABI64
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __pad1;
+    unsigned long int __pad2;
+    unsigned long int __pad3;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+# else
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+    int __writer;
+  } __data;
+# endif
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/semaphore.h glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/semaphore.h
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/bits/semaphore.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/bits/semaphore.h	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#if _MIPS_SIM == _ABI64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   (2147483647)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/clone.S glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/clone.S
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/clone.S	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/clone.S	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,2 @@
+#define RESET_PID
+#include <sysdeps/unix/sysv/linux/mips/clone.S>
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/createthread.c glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/createthread.c
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/createthread.c	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/createthread.c	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,24 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE ((void *) (pd) \
+		   + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Get the real implementation.	 */
+#include <nptl/sysdeps/pthread/createthread.c>
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/fork.c glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/fork.c
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/fork.c	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/fork.c	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1 @@
+#include "../i386/fork.c"
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/lowlevellock.h glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/lowlevellock.h
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/lowlevellock.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/lowlevellock.h	2005-11-04 06:20:05.000000000 +0000
@@ -0,0 +1,230 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+
+/* Initializer for compatibility lock.	*/
+#define LLL_MUTEX_LOCK_INITIALIZER (0)
+
+#define lll_futex_wait(futexp, val) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (long) (futexp), FUTEX_WAIT, (val), 0);	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_timed_wait(futexp, val, timespec) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (long) (futexp), FUTEX_WAIT, (val), (timespec));\
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_wake(futexp, nr) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (long) (futexp), FUTEX_WAKE, (nr), 0);	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6,				      \
+			      (long) (futexp), FUTEX_CMP_REQUEUE, (nr_wake),  \
+			      (nr_move), (mutex), (val));		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+									      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6,				      \
+			      (futexp), FUTEX_WAKE_OP, (nr_wake),	      \
+			      (nr_wake2), (futexp2),			      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+static inline int __attribute__((always_inline))
+__lll_mutex_trylock(int *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 1, 0) != 0;
+}
+#define lll_mutex_trylock(lock)	__lll_mutex_trylock (&(lock))
+
+
+static inline int __attribute__((always_inline))
+__lll_mutex_cond_trylock(int *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 2, 0) != 0;
+}
+#define lll_mutex_cond_trylock(lock)	__lll_mutex_cond_trylock (&(lock))
+
+
+extern void __lll_lock_wait (int *futex) attribute_hidden;
+
+static inline void __attribute__((always_inline))
+__lll_mutex_lock(int *futex)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    __lll_lock_wait (futex);
+}
+#define lll_mutex_lock(futex) __lll_mutex_lock (&(futex))
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_cond_lock (int *futex)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0)
+    __lll_lock_wait (futex);
+}
+#define lll_mutex_cond_lock(futex) __lll_mutex_cond_lock (&(futex))
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *)
+	attribute_hidden;
+
+static inline int __attribute__ ((always_inline))
+__lll_mutex_timedlock (int *futex, const struct timespec *abstime)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    result = __lll_timedlock_wait (futex, abstime);
+  return result;
+}
+#define lll_mutex_timedlock(futex, abstime) \
+  __lll_mutex_timedlock (&(futex), abstime)
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_unlock (int *futex)
+{
+  int val = atomic_exchange_rel (futex, 0);
+  if (__builtin_expect (val > 1, 0))
+    lll_futex_wake (futex, 1);
+}
+#define lll_mutex_unlock(futex) __lll_mutex_unlock(&(futex))
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_unlock_force (int *futex)
+{
+  (void) atomic_exchange_rel (futex, 0);
+  lll_futex_wake (futex, 1);
+}
+#define lll_mutex_unlock_force(futex) __lll_mutex_unlock_force(&(futex))
+
+
+#define lll_mutex_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Type for lock object.  */
+typedef int lll_lock_t;
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+extern int lll_unlock_wake_cb (int *__futex) attribute_hidden;
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+#define lll_trylock(lock)	lll_mutex_trylock (lock)
+#define lll_lock(lock)		lll_mutex_lock (lock)
+#define lll_unlock(lock)	lll_mutex_unlock (lock)
+#define lll_islocked(lock)	lll_mutex_islocked (lock)
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != 0)	\
+      lll_futex_wait (&(tid), __tid);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+
+/* Conditional variable handling.  */
+
+extern void __lll_cond_wait (pthread_cond_t *cond)
+     attribute_hidden;
+extern int __lll_cond_timedwait (pthread_cond_t *cond,
+				 const struct timespec *abstime)
+     attribute_hidden;
+extern void __lll_cond_wake (pthread_cond_t *cond)
+     attribute_hidden;
+extern void __lll_cond_broadcast (pthread_cond_t *cond)
+     attribute_hidden;
+
+#define lll_cond_wait(cond) \
+  __lll_cond_wait (cond)
+#define lll_cond_timedwait(cond, abstime) \
+  __lll_cond_timedwait (cond, abstime)
+#define lll_cond_wake(cond) \
+  __lll_cond_wake (cond)
+#define lll_cond_broadcast(cond) \
+  __lll_cond_broadcast (cond)
+
+#endif	/* lowlevellock.h */
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h	2005-11-04 06:20:05.000000000 +0000
@@ -0,0 +1,183 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+#include <sys/asm.h>
+
+/* Gas will put the initial save of $gp into the CIE, because it appears to
+   happen before any instructions.  So we use cfi_same_value instead of
+   cfi_restore.  */
+
+#ifdef HAVE_ASM_CFI_DIRECTIVES
+# define cfi_same_value .cfi_same_value
+#else
+# define cfi_same_value
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+#ifdef __PIC__
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+      .align 2;								      \
+  L(pseudo_start):							      \
+      cfi_startproc;							      \
+      cfi_adjust_cfa_offset (STKSPACE);					      \
+      cfi_rel_offset (gp, STKOFF_GP);					      \
+  99: PTR_LA t9,__syscall_error;					      \
+      /* manual cpreturn */						      \
+      REG_L gp, STKOFF_GP(sp);						      \
+      cfi_same_value (gp);						      \
+      RESTORESTK;							      \
+      jr t9;								      \
+  .type __##syscall_name##_nocancel, @function;				      \
+  .globl __##syscall_name##_nocancel;					      \
+  __##syscall_name##_nocancel:						      \
+    SAVESTK;								      \
+    .cpsetup t9, STKOFF_GP, name;					      \
+    cfi_rel_offset (gp, STKOFF_GP);					      \
+    li v0, SYS_ify(syscall_name);					      \
+    syscall;								      \
+    bne a3, zero, SYSCALL_ERROR_LABEL;			       		      \
+    /* manual cpreturn */						      \
+    REG_L gp, STKOFF_GP(sp);						      \
+    cfi_same_value (gp);						      \
+    RESTORESTK;								      \
+    ret;								      \
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	      \
+  ENTRY (name)								      \
+    SAVESTK;								      \
+    .cpsetup t9, STKOFF_GP, name;					      \
+    cfi_rel_offset (gp, STKOFF_GP);					      \
+    SINGLE_THREAD_P(v1);						      \
+    bne zero, v1, L(pseudo_cancel);					      \
+    .set noreorder;							      \
+    li v0, SYS_ify(syscall_name);					      \
+    syscall;								      \
+    .set reorder;							      \
+    bne a3, zero, SYSCALL_ERROR_LABEL;			       		      \
+    /* manual cpreturn */						      \
+    REG_L gp, STKOFF_GP(sp);						      \
+    cfi_same_value (gp);						      \
+    RESTORESTK;								      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    cfi_adjust_cfa_offset (STKSPACE);					      \
+    cfi_rel_offset (gp, STKOFF_GP);					      \
+    REG_S ra, STKOFF_RA(sp);						      \
+    cfi_rel_offset (ra, STKOFF_RA);					      \
+    PUSHARGS_##args;			/* save syscall args */	      	      \
+    CENABLE;								      \
+    REG_S v0, STKOFF_SVMSK(sp);		/* save mask */			      \
+    POPARGS_##args;			/* restore syscall args */	      \
+    .set noreorder;							      \
+    li v0, SYS_ify (syscall_name);				      	      \
+    syscall;								      \
+    .set reorder;							      \
+    REG_S v0, STKOFF_SC_V0(sp);		/* save syscall result */             \
+    REG_S a3, STKOFF_SC_ERR(sp);	/* save syscall error flag */	      \
+    REG_L a0, STKOFF_SVMSK(sp);		/* pass mask as arg1 */		      \
+    CDISABLE;								      \
+    REG_L a3, STKOFF_SC_ERR(sp);	/* restore syscall error flag */      \
+    REG_L ra, STKOFF_RA(sp);		/* restore return address */	      \
+    REG_L v0, STKOFF_SC_V0(sp);		/* restore syscall result */          \
+    bne a3, zero, SYSCALL_ERROR_LABEL;					      \
+    /* manual cpreturn */						      \
+    REG_L gp, STKOFF_GP(sp);						      \
+    cfi_same_value (gp);						      \
+    RESTORESTK;								      \
+  L(pseudo_end):
+
+
+# undef PSEUDO_END
+# define PSEUDO_END(sym) cfi_endproc; .end sym; .size sym,.-sym
+
+#endif
+
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 REG_S a0, STKOFF_A0(sp); cfi_rel_offset (a0, STKOFF_A0);
+# define PUSHARGS_2	PUSHARGS_1 REG_S a1, STKOFF_A1(sp); cfi_rel_offset (a1, STKOFF_A1);
+# define PUSHARGS_3	PUSHARGS_2 REG_S a2, STKOFF_A2(sp); cfi_rel_offset (a2, STKOFF_A2);
+# define PUSHARGS_4	PUSHARGS_3 REG_S a3, STKOFF_A3(sp); cfi_rel_offset (a3, STKOFF_A3);
+# define PUSHARGS_5	PUSHARGS_4 REG_S a4, STKOFF_A4(sp); cfi_rel_offset (a3, STKOFF_A4);
+# define PUSHARGS_6	PUSHARGS_5 REG_S a5, STKOFF_A5(sp); cfi_rel_offset (a3, STKOFF_A5);
+
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 REG_L a0, STKOFF_A0(sp);
+# define POPARGS_2	POPARGS_1 REG_L a1, STKOFF_A1(sp);
+# define POPARGS_3	POPARGS_2 REG_L a2, STKOFF_A2(sp);
+# define POPARGS_4	POPARGS_3 REG_L a3, STKOFF_A3(sp);
+# define POPARGS_5	POPARGS_4 REG_L a4, STKOFF_A4(sp);
+# define POPARGS_6	POPARGS_5 REG_L a5, STKOFF_A5(sp);
+
+/* Save an even number of slots.  Should be 0 if an even number of slots
+   are used below, or SZREG if an odd number are used.  */
+# define STK_PAD	SZREG
+
+/* Place values that we are more likely to use later in this sequence, i.e.
+   closer to the SP at function entry.  If you do that, the are more
+   likely to already be in your d-cache.  */
+# define STKOFF_A5	(STK_PAD)
+# define STKOFF_A4	(STKOFF_A5 + SZREG)
+# define STKOFF_A3	(STKOFF_A4 + SZREG)
+# define STKOFF_A2	(STKOFF_A3 + SZREG)	/* MT and more args.  */
+# define STKOFF_A1	(STKOFF_A2 + SZREG)	/* MT and 2 args.  */
+# define STKOFF_A0	(STKOFF_A1 + SZREG)	/* MT and 1 arg.  */
+# define STKOFF_RA	(STKOFF_A0 + SZREG)	/* Used if MT.  */
+# define STKOFF_SC_V0	(STKOFF_RA + SZREG)	/* Used if MT.  */
+# define STKOFF_SC_ERR	(STKOFF_SC_V0 + SZREG)	/* Used if MT.  */
+# define STKOFF_SVMSK	(STKOFF_SC_ERR + SZREG)	/* Used if MT.  */
+# define STKOFF_GP	(STKOFF_SVMSK + SZREG)	/* Always used.  */
+
+# define STKSPACE	(STKOFF_GP + SZREG)
+# define SAVESTK 	PTR_SUBU sp, STKSPACE; cfi_adjust_cfa_offset(STKSPACE)
+# define RESTORESTK 	PTR_ADDU sp, STKSPACE; cfi_adjust_cfa_offset(-STKSPACE)
+
+# ifdef IS_IN_libpthread
+#  define CENABLE	PTR_LA t9, __pthread_enable_asynccancel; jalr t9
+#  define CDISABLE	PTR_LA t9, __pthread_disable_asynccancel; jalr t9
+# elif defined IS_IN_librt
+#  define CENABLE	PTR_LA t9, __librt_enable_asynccancel; jalr t9
+#  define CDISABLE	PTR_LA t9, __librt_disable_asynccancel; jalr t9
+# else
+#  define CENABLE	PTR_LA t9, __libc_enable_asynccancel; jalr t9
+#  define CDISABLE	PTR_LA t9, __libc_disable_asynccancel; jalr t9
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P						\
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF,			\
+					 header.multiple_threads)	\
+			  == 0, 1)
+# else
+#  define SINGLE_THREAD_P(reg)						\
+	READ_THREAD_POINTER(reg);					\
+	lw reg, MULTIPLE_THREADS_OFFSET(reg)
+#endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/pt-vfork.S glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/pt-vfork.S
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/pt-vfork.S	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/pt-vfork.S	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	READ_THREAD_POINTER(v1);	/* Get the thread pointer.  */	\
+	lw	a2, PID_OFFSET(v1);	/* Load the saved PID.  */	\
+	subu	a2, $0, a2;		/* Negate it.  */		\
+	sw	a2, PID_OFFSET(v1);	/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;			/* If we are the parent... */	\
+	READ_THREAD_POINTER(v1);	/* Get the thread pointer.  */	\
+	lw	a2, PID_OFFSET(v1);	/* Load the saved PID.  */	\
+	subu	a2, $0, a2;		/* Re-negate it.  */		\
+	sw	a2, PID_OFFSET(v1);	/* Restore the PID.  */		\
+1:
+
+#include <../sysdeps/unix/sysv/linux/mips/vfork.S>
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/pthread_once.c glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/pthread_once.c
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/pthread_once.c	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/pthread_once.c	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,94 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+unsigned long int __fork_generation attribute_hidden;
+
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX);
+}
+
+
+int
+__pthread_once (once_control, init_routine)
+     pthread_once_t *once_control;
+     void (*init_routine) (void);
+{
+  while (1)
+    {
+      int oldval, val, newval;
+
+      val = *once_control;
+      do
+	{
+	  /* Check if the initialized has already been done.  */
+	  if ((val & 2) != 0)
+	    return 0;
+
+	  oldval = val;
+	  newval = (oldval & 3) | __fork_generation | 1;
+	  val = atomic_compare_and_exchange_val_acq (once_control, newval,
+						     oldval);
+	}
+      while (__builtin_expect (val != oldval, 0));
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) != 0)
+	{
+	  /* Check whether the initializer execution was interrupted
+	     by a fork.	 */
+	  if (((oldval ^ newval) & -4) == 0)
+	    {
+	      /* Same generation, some other thread was faster. Wait.  */
+	      lll_futex_wait (once_control, newval);
+	      continue;
+	    }
+	}
+
+      /* This thread is the first here.  Do the initialization.
+	 Register a cleanup handler so that in case the thread gets
+	 interrupted the initialization can be restarted.  */
+      pthread_cleanup_push (clear_once_control, once_control);
+
+      init_routine ();
+
+      pthread_cleanup_pop (0);
+
+
+      /* Add one to *once_control.  */
+      atomic_increment (once_control);
+
+      /* Wake up all other threads.  */
+      lll_futex_wake (once_control, INT_MAX);
+      break;
+    }
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+strong_alias (__pthread_once, __pthread_once_internal)
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,170 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+#ifdef __PIC__
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+      .align 2;								      \
+  L(pseudo_start):							      \
+      cfi_startproc;							      \
+  99: la t9,__syscall_error;						      \
+      jr t9;								      \
+  .type __##syscall_name##_nocancel, @function;				      \
+  .globl __##syscall_name##_nocancel;					      \
+  __##syscall_name##_nocancel:						      \
+    .set noreorder;							      \
+    .cpload t9;								      \
+    li v0, SYS_ify(syscall_name);					      \
+    syscall;								      \
+    .set reorder;							      \
+    bne a3, zero, SYSCALL_ERROR_LABEL;			       		      \
+    ret;								      \
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	      \
+  ENTRY (name)								      \
+    .set noreorder;							      \
+    .cpload t9;								      \
+    .set reorder;							      \
+    SINGLE_THREAD_P(v1);						      \
+    bne zero, v1, L(pseudo_cancel);					      \
+    .set noreorder;							      \
+    li v0, SYS_ify(syscall_name);					      \
+    syscall;								      \
+    .set reorder;							      \
+    bne a3, zero, SYSCALL_ERROR_LABEL;			       		      \
+    ret;								      \
+  L(pseudo_cancel):							      \
+    SAVESTK_##args;						              \
+    sw ra, 28(sp);							      \
+    cfi_rel_offset (ra, 28);						      \
+    sw gp, 32(sp);							      \
+    cfi_rel_offset (gp, 32);						      \
+    PUSHARGS_##args;			/* save syscall args */	      	      \
+    CENABLE;								      \
+    lw gp, 32(sp);							      \
+    sw v0, 44(sp);			/* save mask */			      \
+    POPARGS_##args;			/* restore syscall args */	      \
+    .set noreorder;							      \
+    li v0, SYS_ify (syscall_name);				      	      \
+    syscall;								      \
+    .set reorder;							      \
+    sw v0, 36(sp);			/* save syscall result */             \
+    sw a3, 40(sp);			/* save syscall error flag */	      \
+    lw a0, 44(sp);			/* pass mask as arg1 */		      \
+    CDISABLE;								      \
+    lw gp, 32(sp);							      \
+    lw v0, 36(sp);			/* restore syscall result */          \
+    lw a3, 40(sp);			/* restore syscall error flag */      \
+    lw ra, 28(sp);			/* restore return address */	      \
+    .set noreorder;							      \
+    bne a3, zero, SYSCALL_ERROR_LABEL;					      \
+     RESTORESTK;						              \
+  L(pseudo_end):							      \
+    .set reorder;
+
+# undef PSEUDO_END
+# define PSEUDO_END(sym) cfi_endproc; .end sym; .size sym,.-sym
+
+#endif
+
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 sw a0, 0(sp); cfi_rel_offset (a0, 0);
+# define PUSHARGS_2	PUSHARGS_1 sw a1, 4(sp); cfi_rel_offset (a1, 4);
+# define PUSHARGS_3	PUSHARGS_2 sw a2, 8(sp); cfi_rel_offset (a2, 8);
+# define PUSHARGS_4	PUSHARGS_3 sw a3, 12(sp); cfi_rel_offset (a3, 12);
+# define PUSHARGS_5	PUSHARGS_4 /* handled by SAVESTK_## */
+# define PUSHARGS_6	PUSHARGS_5
+# define PUSHARGS_7	PUSHARGS_6
+
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 lw a0, 0(sp);
+# define POPARGS_2	POPARGS_1 lw a1, 4(sp);
+# define POPARGS_3	POPARGS_2 lw a2, 8(sp);
+# define POPARGS_4	POPARGS_3 lw a3, 12(sp);
+# define POPARGS_5	POPARGS_4 /* args already in new stackframe */
+# define POPARGS_6	POPARGS_5
+# define POPARGS_7	POPARGS_6
+
+
+# define STKSPACE	48
+# define SAVESTK_0 	subu sp, STKSPACE; cfi_adjust_cfa_offset(STKSPACE)
+# define SAVESTK_1      SAVESTK_0
+# define SAVESTK_2      SAVESTK_1
+# define SAVESTK_3      SAVESTK_2
+# define SAVESTK_4      SAVESTK_3
+# define SAVESTK_5      lw t0, 16(sp);		\
+			SAVESTK_0;		\
+			sw t0, 16(sp)
+
+# define SAVESTK_6      lw t0, 16(sp);		\
+			lw t1, 20(sp);		\
+			SAVESTK_0;		\
+			sw t0, 16(sp);		\
+			sw t1, 20(sp)
+
+# define SAVESTK_7      lw t0, 16(sp);		\
+			lw t1, 20(sp);		\
+			lw t2, 24(sp);		\
+			SAVESTK_0;		\
+			sw t0, 16(sp);		\
+			sw t1, 20(sp);		\
+			sw t2, 24(sp)
+
+# define RESTORESTK 	addu sp, STKSPACE; cfi_adjust_cfa_offset(-STKSPACE)
+
+
+/* We use jalr rather than jal.  This means that the assembler will not
+   automatically restore $gp (in case libc has multiple GOTs) so we must
+   do it manually - which we have to do anyway since we don't use .cprestore.
+   It also shuts up the assembler warning about not using .cprestore.  */
+# ifdef IS_IN_libpthread
+#  define CENABLE	la t9, __pthread_enable_asynccancel; jalr t9;
+#  define CDISABLE	la t9, __pthread_disable_asynccancel; jalr t9;
+# elif defined IS_IN_librt
+#  define CENABLE	la t9, __librt_enable_asynccancel; jalr t9;
+#  define CDISABLE	la t9, __librt_disable_asynccancel; jalr t9;
+# else
+#  define CENABLE	la t9, __libc_enable_asynccancel; jalr t9;
+#  define CDISABLE	la t9, __libc_disable_asynccancel; jalr t9;
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P						\
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF,			\
+					 header.multiple_threads)	\
+			  == 0, 1)
+# else
+#  define SINGLE_THREAD_P(reg)						\
+	READ_THREAD_POINTER(reg);					\
+	lw reg, MULTIPLE_THREADS_OFFSET(reg)
+#endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
diff -Naur glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/vfork.S glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/vfork.S
--- glibc-2.3.6.orig/nptl/sysdeps/unix/sysv/linux/mips/vfork.S	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/nptl/sysdeps/unix/sysv/linux/mips/vfork.S	2005-03-28 09:21:52.000000000 +0000
@@ -0,0 +1,42 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	READ_THREAD_POINTER(v1);	/* Get the thread pointer.  */	\
+	lw	a2, PID_OFFSET(v1);	/* Load the saved PID.  */	\
+	subu	a2, $0, a2;		/* Negate it.  */		\
+	bnez	a2, 1f;			/* If it was zero... */		\
+	lui	a2, 0x8000;		/* use 0x80000000 instead.  */	\
+1:	sw	a2, PID_OFFSET(v1);	/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	v0, 1f;			/* If we are the parent... */	\
+	READ_THREAD_POINTER(v1);	/* Get the thread pointer.  */	\
+	lw	a2, PID_OFFSET(v1);	/* Load the saved PID.  */	\
+	subu	a2, $0, a2;		/* Re-negate it.  */		\
+	lui	a0, 0x8000;		/* Load 0x80000000... */	\
+	bne	a2, a0, 2f;		/* ... compare against it... */	\
+	li	a2, 0;			/* ... use 0 instead.  */	\
+2:	sw	a2, PID_OFFSET(v1);	/* Restore the PID.  */		\
+1:
+
+#include <../sysdeps/unix/sysv/linux/mips/vfork.S>
diff -Naur glibc-2.3.6.orig/sysdeps/mips/dl-machine.h glibc-2.3.6/sysdeps/mips/dl-machine.h
--- glibc-2.3.6.orig/sysdeps/mips/dl-machine.h	2004-11-24 04:36:09.000000000 +0000
+++ glibc-2.3.6/sysdeps/mips/dl-machine.h	2005-11-04 06:39:56.000000000 +0000
@@ -1,5 +1,6 @@
 /* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
-   Copyright (C) 1996-2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
 
@@ -34,6 +35,7 @@
 
 #include <sgidefs.h>
 #include <sys/asm.h>
+#include <dl-tls.h>
 
 /* The offset of gp from GOT might be system-dependent.  It's set by
    ld.  The same value is also */
@@ -188,248 +190,6 @@
 } while(0)
 
 
-/* Get link map for callers object containing STUB_PC.  */
-static inline struct link_map *
-elf_machine_runtime_link_map (ElfW(Addr) gpreg, ElfW(Addr) stub_pc)
-{
-  extern int _dl_mips_gnu_objects;
-
-  /* got[1] is reserved to keep its link map address for the shared
-     object generated by the gnu linker.  If all are such objects, we
-     can find the link map from current GPREG simply.  If not so, get
-     the link map for caller's object containing STUB_PC.  */
-
-  if (_dl_mips_gnu_objects)
-    {
-      ElfW(Addr) *got = elf_mips_got_from_gpreg (gpreg);
-      ElfW(Word) g1;
-
-      g1 = ((ElfW(Word) *) got)[1];
-
-      if ((g1 & ELF_MIPS_GNU_GOT1_MASK) != 0)
-	{
-	  struct link_map *l =
-	    (struct link_map *) (g1 & ~ELF_MIPS_GNU_GOT1_MASK);
-	  ElfW(Addr) base, limit;
-	  const ElfW(Phdr) *p = l->l_phdr;
-	  ElfW(Half) this, nent = l->l_phnum;
-
-	  /* For the common case of a stub being called from the containing
-	     object, STUB_PC will point to somewhere within the object that
-	     is described by the link map fetched via got[1].  Otherwise we
-	     have to scan all maps.  */
-	  for (this = 0; this < nent; this++)
-	    {
-	      if (p[this].p_type == PT_LOAD)
-		{
-		  base = p[this].p_vaddr + l->l_addr;
-		  limit = base + p[this].p_memsz;
-		  if (stub_pc >= base && stub_pc < limit)
-		    return l;
-		}
-	    }
-	}
-    }
-
-    struct link_map *l;
-    Lmid_t nsid;
-
-    for (nsid = 0; nsid < DL_NNS; ++nsid)
-      for (l = GL(dl_ns)[nsid]._ns_loaded; l != NULL; l = l->l_next)
-	{
-	  ElfW(Addr) base, limit;
-	  const ElfW(Phdr) *p = l->l_phdr;
-	  ElfW(Half) this, nent = l->l_phnum;
-
-	  for (this = 0; this < nent; ++this)
-	    {
-	      if (p[this].p_type == PT_LOAD)
-		{
-		  base = p[this].p_vaddr + l->l_addr;
-		  limit = base + p[this].p_memsz;
-		  if (stub_pc >= base && stub_pc < limit)
-		    return l;
-		}
-	    }
-	}
-
-  _dl_signal_error (0, NULL, NULL, "cannot find runtime link map");
-  return NULL;
-}
-
-#if _MIPS_SIM == _ABIO32
-#define ELF_DL_FRAME_SIZE 40
-
-#define ELF_DL_SAVE_ARG_REGS "\
-	sw	$15, 36($29)\n						      \
-	sw	$4, 16($29)\n						      \
-	sw	$5, 20($29)\n						      \
-	sw	$6, 24($29)\n						      \
-	sw	$7, 28($29)\n						      \
-"
-
-#define ELF_DL_RESTORE_ARG_REGS "\
-	lw	$31, 36($29)\n						      \
-	lw	$4, 16($29)\n						      \
-	lw	$5, 20($29)\n						      \
-	lw	$6, 24($29)\n						      \
-	lw	$7, 28($29)\n						      \
-"
-
-#define IFABIO32(X) X
-
-#else /* _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64 */
-
-#define ELF_DL_FRAME_SIZE 80
-
-#define ELF_DL_SAVE_ARG_REGS "\
-	sd	$15, 72($29)\n						      \
-	sd	$4, 8($29)\n						      \
-	sd	$5, 16($29)\n						      \
-	sd	$6, 24($29)\n						      \
-	sd	$7, 32($29)\n						      \
-	sd	$8, 40($29)\n						      \
-	sd	$9, 48($29)\n						      \
-	sd	$10, 56($29)\n						      \
-	sd	$11, 64($29)\n						      \
-"
-
-#define ELF_DL_RESTORE_ARG_REGS "\
-	ld	$31, 72($29)\n						      \
-	ld	$4, 8($29)\n						      \
-	ld	$5, 16($29)\n						      \
-	ld	$6, 24($29)\n						      \
-	ld	$7, 32($29)\n						      \
-	ld	$8, 40($29)\n						      \
-	ld	$9, 48($29)\n						      \
-	ld	$10, 56($29)\n						      \
-	ld	$11, 64($29)\n						      \
-"
-
-#define IFABIO32(X)
-
-#endif
-
-/* Define mips specific runtime resolver. The function __dl_runtime_resolve
-   is called from assembler function _dl_runtime_resolve which converts
-   special argument registers t7 ($15) and t8 ($24):
-     t7  address to return to the caller of the function
-     t8  index for this function symbol in .dynsym
-   to usual c arguments.
-
-   Other architectures call fixup from dl-runtime.c in
-   _dl_runtime_resolve.  MIPS instead calls __dl_runtime_resolve.  We
-   have to use our own version because of the way the got section is
-   treated on MIPS (we've also got ELF_MACHINE_PLT defined).  */
-
-#define ELF_MACHINE_RUNTIME_TRAMPOLINE					      \
-/* The flag _dl_mips_gnu_objects is set if all dynamic objects are	      \
-   generated by the gnu linker. */					      \
-int _dl_mips_gnu_objects = 1;						      \
-									      \
-/* This is called from assembly stubs below which the compiler can't see.  */ \
-static ElfW(Addr)							      \
-__dl_runtime_resolve (ElfW(Word), ElfW(Word), ElfW(Addr), ElfW(Addr))	      \
-		  __attribute_used__;					      \
-									      \
-static ElfW(Addr)							      \
-__dl_runtime_resolve (ElfW(Word) sym_index,				      \
-		      ElfW(Word) return_address,			      \
-		      ElfW(Addr) old_gpreg,				      \
-		      ElfW(Addr) stub_pc)				      \
-{									      \
-  struct link_map *l = elf_machine_runtime_link_map (old_gpreg, stub_pc);     \
-  const ElfW(Sym) *const symtab						      \
-    = (const ElfW(Sym) *) D_PTR (l, l_info[DT_SYMTAB]);			      \
-  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);	      \
-  ElfW(Addr) *got							      \
-    = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);			      \
-  const ElfW(Word) local_gotno						      \
-    = (const ElfW(Word)) l->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;	      \
-  const ElfW(Word) gotsym						      \
-    = (const ElfW(Word)) l->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;	      \
-  const ElfW(Sym) *sym = &symtab[sym_index];				      \
-  ElfW(Addr) value;							      \
-									      \
-  /* FIXME: The symbol versioning stuff is not tested yet.  */		      \
-  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)	      \
-    {									      \
-      switch (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)			      \
-	{								      \
-	default:							      \
-	  {								      \
-	    const ElfW(Half) *vernum =					      \
-	      (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);	      \
-	    ElfW(Half) ndx = vernum[sym_index] & 0x7fff;		      \
-	    const struct r_found_version *version = &l->l_versions[ndx];      \
-									      \
-	    if (version->hash != 0)					      \
-	      {								      \
-		value = _dl_lookup_symbol_x (strtab + sym->st_name, l, 	      \
-					     &sym, l->l_scope, version,	      \
-					     ELF_RTYPE_CLASS_PLT, 0, 0);      \
-		break;							      \
-	      }								      \
-	    /* Fall through.  */					      \
-	  }								      \
-	case 0:								      \
-	  value = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym,	      \
-				       l->l_scope, 0, ELF_RTYPE_CLASS_PLT,    \
-				       DL_LOOKUP_ADD_DEPENDENCY, 0);	      \
-	}								      \
-									      \
-      /* Currently value contains the base load address of the object	      \
-	 that defines sym.  Now add in the symbol offset.  */		      \
-      value = (sym ? value + sym->st_value : 0);			      \
-    }									      \
-  else									      \
-    /* We already found the symbol.  The module (and therefore its load	      \
-       address) is also known.  */					      \
-    value = l->l_addr + sym->st_value;					      \
-									      \
-  /* Apply the relocation with that value.  */				      \
-  *(got + local_gotno + sym_index - gotsym) = value;			      \
-									      \
-  return value;								      \
-}									      \
-									      \
-asm ("\n								      \
-	.text\n								      \
-	.align	2\n							      \
-	.globl	_dl_runtime_resolve\n					      \
-	.type	_dl_runtime_resolve,@function\n				      \
-	.ent	_dl_runtime_resolve\n					      \
-_dl_runtime_resolve:\n							      \
-	.frame	$29, " STRINGXP(ELF_DL_FRAME_SIZE) ", $31\n		      \
-	.set noreorder\n						      \
-	# Save GP.\n							      \
-	move	$3, $28\n						      \
-	# Save arguments and sp value in stack.\n			      \
-	" STRINGXP(PTR_SUBIU) "  $29, " STRINGXP(ELF_DL_FRAME_SIZE) "\n	      \
-	# Modify t9 ($25) so as to point .cpload instruction.\n		      \
-	" IFABIO32(STRINGXP(PTR_ADDIU) "	$25, 12\n") "		      \
-	# Compute GP.\n							      \
-	" STRINGXP(SETUP_GP) "\n					      \
-	" STRINGXV(SETUP_GP64 (0, _dl_runtime_resolve)) "\n		      \
-	.set reorder\n							      \
-	# Save slot call pc.\n						      \
-	move	$2, $31\n						      \
-	" IFABIO32(STRINGXP(CPRESTORE(32))) "\n				      \
-	" ELF_DL_SAVE_ARG_REGS "					      \
-	move	$4, $24\n						      \
-	move	$5, $15\n						      \
-	move	$6, $3\n						      \
-	move	$7, $2\n						      \
-	jal	__dl_runtime_resolve\n					      \
-	" ELF_DL_RESTORE_ARG_REGS "					      \
-	" STRINGXP(RESTORE_GP64) "\n					      \
-	" STRINGXP(PTR_ADDIU) "	$29, " STRINGXP(ELF_DL_FRAME_SIZE) "\n	      \
-	move	$25, $2\n						      \
-	jr	$25\n							      \
-	.end	_dl_runtime_resolve\n					      \
-	.previous\n							      \
-");
-
 /* Mask identifying addresses reserved for the user program,
    where the dynamic linker should not map anything.  */
 #define ELF_MACHINE_USER_ADDRESS_MASK	0x80000000UL
@@ -451,8 +211,8 @@
       and not just plain _start.  */
 
 #define RTLD_START asm (\
-	".text\n"\
-	_RTLD_PROLOGUE(ENTRY_POINT) "\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
 	" STRINGXV(SETUP_GPX($25)) "\n\
 	" STRINGXV(SETUP_GPX64($18,$25)) "\n\
 	# i386 ABI book says that the first entry of GOT holds\n\
@@ -475,10 +235,10 @@
 	" STRINGXP(PTR_ADDIU) " $29, 16\n\
 	# Get the value of label '_dl_start_user' in t9 ($25).\n\
 	" STRINGXP(PTR_LA) " $25, _dl_start_user\n\
-	.globl _dl_start_user\n\
-	.type _dl_start_user,@function\n\
-	.aent _dl_start_user\n\
-_dl_start_user:\n\
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	\n\
+	\n\
+	" _RTLD_PROLOGUE(_dl_start_user) "\
 	" STRINGXP(SETUP_GP) "\n\
 	" STRINGXV(SETUP_GP64($18,_dl_start_user)) "\n\
 	move $16, $28\n\
@@ -504,34 +264,48 @@
 	sll $7, $5, " STRINGXP (PTRLOG) "\n\
 	" STRINGXP(PTR_ADDU) " $7, $7, $6\n\
 	" STRINGXP(PTR_ADDU) " $7, $7, " STRINGXP (PTRSIZE) " \n\
-	" STRINGXP(PTR_SUBIU) " $29, 32\n\
+	# Make sure the stack pointer is aligned for _dl_init_internal.\n\
+	and $2, $29, -2 * " STRINGXP(SZREG) "\n\
+	" STRINGXP(PTR_S) " $29, -4($2)\n\
+	" STRINGXP(PTR_SUBIU) " $29, $2, 32\n\
 	" STRINGXP(SAVE_GP(16)) "\n\
 	# Call the function to run the initializers.\n\
 	jal _dl_init_internal\n\
-	" STRINGXP(PTR_ADDIU)  " $29, 32\n\
+	# Restore the stack pointer for _start.\n\
+	" STRINGXP(PTR_L)  " $29, 28($29)\n\
 	# Pass our finalizer function to the user in $2 as per ELF ABI.\n\
 	" STRINGXP(PTR_LA) " $2, _dl_fini\n\
 	# Jump to the user entry point.\n\
 	move $25, $17\n\
 	jr $25\n\t"\
-	_RTLD_EPILOGUE(ENTRY_POINT)\
+	_RTLD_EPILOGUE(_dl_start_user)\
 	".previous"\
 );
 
 /* The MIPS never uses Elfxx_Rela relocations.  */
 #define ELF_MACHINE_NO_RELA 1
 
+/* Names of the architecture-specific auditing callback functions.  */
+# if _MIPS_SIM == _ABIO32
+#  define ARCH_LA_PLTENTER mips_o32_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_o32_gnu_pltexit
+# elif _MIPS_SIM == _ABIN32
+#  define ARCH_LA_PLTENTER mips_n32_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n32_gnu_pltexit
+# else
+#  define ARCH_LA_PLTENTER mips_n64_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n64_gnu_pltexit
+# endif
+
 #endif /* !dl_machine_h */
 
-#ifdef RESOLVE
+#ifdef RESOLVE_MAP
 
 /* Perform the relocation specified by RELOC and SYM (which is fully resolved).
    MAP is the object containing the reloc.  */
 
-static inline void
-#ifdef RTLD_BOOTSTRAP
-  __attribute__ ((always_inline))
-#endif
+auto inline void
+__attribute__ ((always_inline))
 elf_machine_rel (struct link_map *map, const ElfW(Rel) *reloc,
 		 const ElfW(Sym) *sym, const struct r_found_version *version,
 		 void *const reloc_addr)
@@ -550,6 +324,47 @@
 
   switch (r_type)
     {
+#if defined (USE_TLS) && !defined (RTLD_BOOTSTRAP)
+# if _MIPS_SIM == _ABI64
+    case R_MIPS_TLS_DTPMOD64:
+    case R_MIPS_TLS_DTPREL64:
+    case R_MIPS_TLS_TPREL64:
+# else
+    case R_MIPS_TLS_DTPMOD32:
+    case R_MIPS_TLS_DTPREL32:
+    case R_MIPS_TLS_TPREL32:
+# endif
+      {
+	struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+	Elf32_Addr value = sym == NULL ? 0 : sym_map->l_addr + sym->st_value;
+
+	if (sym)
+	  value += sym->st_value;
+
+	switch (r_type)
+	  {
+	  case R_MIPS_TLS_DTPMOD64:
+	  case R_MIPS_TLS_DTPMOD32:
+	    if (sym_map)
+	      *(ElfW(Word) *)reloc_addr = sym_map->l_tls_modid;
+	    break;
+
+	  case R_MIPS_TLS_DTPREL64:
+	  case R_MIPS_TLS_DTPREL32:
+	    *(ElfW(Word) *)reloc_addr += TLS_DTPREL_VALUE (sym);
+	    break;
+
+	  case R_MIPS_TLS_TPREL32:
+	  case R_MIPS_TLS_TPREL64:
+	    CHECK_STATIC_TLS (map, sym_map);
+	    *(ElfW(Word) *)reloc_addr += TLS_TPREL_VALUE (sym_map, sym);
+	    break;
+	  }
+
+	break;
+      }
+#endif
+
 #if _MIPS_SIM == _ABI64
     case (R_MIPS_64 << 8) | R_MIPS_REL32:
 #else
@@ -635,23 +450,41 @@
     }
 }
 
-static inline void
+auto inline void
+__attribute__((always_inline))
 elf_machine_rel_relative (ElfW(Addr) l_addr, const ElfW(Rel) *reloc,
 			  void *const reloc_addr)
 {
   /* XXX Nothing to do.  There is no relative relocation, right?  */
 }
 
-static inline void
+auto inline void
+__attribute__((always_inline))
 elf_machine_lazy_rel (struct link_map *map,
 		      ElfW(Addr) l_addr, const ElfW(Rel) *reloc)
 {
   /* Do nothing.  */
 }
 
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
+		  const ElfW(Sym) *sym, const struct r_found_version *version,
+		 void *const reloc_addr)
+{
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
+			   void *const reloc_addr)
+{
+}
+
 #ifndef RTLD_BOOTSTRAP
 /* Relocate GOT. */
-static inline void
+auto inline void
+__attribute__((always_inline))
 elf_machine_got_rel (struct link_map *map, int lazy)
 {
   ElfW(Addr) *got;
@@ -664,9 +497,9 @@
       const ElfW(Sym) *ref = sym;					  \
       const struct r_found_version *version				  \
         = vernum ? &map->l_versions[vernum[sym_index] & 0x7fff] : NULL;	  \
-      ElfW(Addr) value;							  \
-      value = RESOLVE (&ref, version, R_MIPS_REL32);			  \
-      (ref)? value + ref->st_value: 0;					  \
+      struct link_map *sym_map;						  \
+      sym_map = RESOLVE_MAP (&ref, version, R_MIPS_REL32);		  \
+      ref ? sym_map->l_addr + ref->st_value : 0;			  \
     })
 
   if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
@@ -738,7 +571,8 @@
 /* Set up the loaded object described by L so its stub function
    will jump to the on-demand fixup code __dl_runtime_resolve.  */
 
-static inline int
+auto inline int
+__attribute__((always_inline))
 elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 {
 # ifndef RTLD_BOOTSTRAP
@@ -774,4 +608,4 @@
   return lazy;
 }
 
-#endif /* RESOLVE */
+#endif /* RESOLVE_MAP */
diff -Naur glibc-2.3.6.orig/sysdeps/mips/dl-machine.h~ glibc-2.3.6/sysdeps/mips/dl-machine.h~
--- glibc-2.3.6.orig/sysdeps/mips/dl-machine.h~	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/sysdeps/mips/dl-machine.h~	2004-11-24 04:36:09.000000000 +0000
@@ -0,0 +1,777 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  FIXME: Profiling of shared libraries is not implemented yet.  */
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "MIPS"
+
+#define ELF_MACHINE_NO_PLT
+
+#include <entry.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for MIPS.
+#endif
+
+#include <sgidefs.h>
+#include <sys/asm.h>
+
+/* The offset of gp from GOT might be system-dependent.  It's set by
+   ld.  The same value is also */
+#define OFFSET_GP_GOT 0x7ff0
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)						\
+	".globl\t" __STRING(entry) "\n\t"				\
+	".ent\t" __STRING(entry) "\n\t"					\
+	".type\t" __STRING(entry) ", @function\n"			\
+	__STRING(entry) ":\n\t"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)						\
+	".end\t" __STRING(entry) "\n\t"					\
+	".size\t" __STRING(entry) ", . - " __STRING(entry) "\n\t"
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.
+   This makes no sense on MIPS but we have to define this to R_MIPS_REL32
+   to avoid the asserts in dl-lookup.c from blowing.  */
+#define ELF_MACHINE_JMP_SLOT			R_MIPS_REL32
+#define elf_machine_type_class(type)		ELF_RTYPE_CLASS_PLT
+
+/* Translate a processor specific dynamic tag to the index
+   in l_info array.  */
+#define DT_MIPS(x) (DT_MIPS_##x - DT_LOPROC + DT_NUM)
+
+/* If there is a DT_MIPS_RLD_MAP entry in the dynamic section, fill it in
+   with the run-time address of the r_debug structure  */
+#define ELF_MACHINE_DEBUG_SETUP(l,r) \
+do { if ((l)->l_info[DT_MIPS (RLD_MAP)]) \
+       *(ElfW(Addr) *)((l)->l_info[DT_MIPS (RLD_MAP)]->d_un.d_ptr) = \
+       (ElfW(Addr)) (r); \
+   } while (0)
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+#if _MIPS_SIM == _ABIO32 || _MIPS_SIM == _ABIN32
+  /* Don't link o32 and n32 together.  */
+  if (((ehdr->e_flags & EF_MIPS_ABI2) != 0) != (_MIPS_SIM == _ABIN32))
+    return 0;
+#endif
+
+  switch (ehdr->e_machine)
+    {
+    case EM_MIPS:
+    case EM_MIPS_RS3_LE:
+      return 1;
+    default:
+      return 0;
+    }
+}
+
+static inline ElfW(Addr) *
+elf_mips_got_from_gpreg (ElfW(Addr) gpreg)
+{
+  /* FIXME: the offset of gp from GOT may be system-dependent. */
+  return (ElfW(Addr) *) (gpreg - OFFSET_GP_GOT);
+}
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  We assume its $gp points to the primary GOT.  */
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  register ElfW(Addr) gp __asm__ ("$28");
+  return *elf_mips_got_from_gpreg (gp);
+}
+
+#define STRINGXP(X) __STRING(X)
+#define STRINGXV(X) STRINGV_(X)
+#define STRINGV_(...) # __VA_ARGS__
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  ElfW(Addr) addr;
+  asm ("	.set noreorder\n"
+       "	" STRINGXP (PTR_LA) " %0, 0f\n"
+       "	bltzal $0, 0f\n"
+       "	nop\n"
+       "0:	" STRINGXP (PTR_SUBU) " %0, $31, %0\n"
+       "	.set reorder\n"
+       :	"=r" (addr)
+       :	/* No inputs */
+       :	"$31");
+  return addr;
+}
+
+/* The MSB of got[1] of a gnu object is set to identify gnu objects.  */
+#if _MIPS_SIM == _ABI64
+# define ELF_MIPS_GNU_GOT1_MASK	0x8000000000000000L
+#else
+# define ELF_MIPS_GNU_GOT1_MASK	0x80000000L
+#endif
+
+/* We can't rely on elf_machine_got_rel because _dl_object_relocation_scope
+   fiddles with global data.  */
+#define ELF_MACHINE_BEFORE_RTLD_RELOC(dynamic_info)			\
+do {									\
+  struct link_map *map = &bootstrap_map;				\
+  ElfW(Sym) *sym;							\
+  ElfW(Addr) *got;							\
+  int i, n;								\
+									\
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);			\
+									\
+  if (__builtin_expect (map->l_addr == 0, 1))				\
+    break;								\
+									\
+  /* got[0] is reserved. got[1] is also reserved for the dynamic object	\
+     generated by gnu ld. Skip these reserved entries from		\
+     relocation.  */							\
+  i = (got[1] & ELF_MIPS_GNU_GOT1_MASK)? 2 : 1;				\
+  n = map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;			\
+									\
+  /* Add the run-time displacement to all local got entries. */		\
+  while (i < n)								\
+    got[i++] += map->l_addr;						\
+									\
+  /* Handle global got entries. */					\
+  got += n;								\
+  sym = (ElfW(Sym) *) D_PTR(map, l_info[DT_SYMTAB])			\
+       + map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;			\
+  i = (map->l_info[DT_MIPS (SYMTABNO)]->d_un.d_val			\
+       - map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val);			\
+									\
+  while (i--)								\
+    {									\
+      if (sym->st_shndx == SHN_UNDEF || sym->st_shndx == SHN_COMMON)	\
+	*got = map->l_addr + sym->st_value;				\
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC			\
+	       && *got != sym->st_value)				\
+	*got += map->l_addr;						\
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)		\
+	{								\
+	  if (sym->st_other == 0)					\
+	    *got += map->l_addr;					\
+	}								\
+      else								\
+	*got = map->l_addr + sym->st_value;				\
+									\
+      got++;								\
+      sym++;								\
+    }									\
+} while(0)
+
+
+/* Get link map for callers object containing STUB_PC.  */
+static inline struct link_map *
+elf_machine_runtime_link_map (ElfW(Addr) gpreg, ElfW(Addr) stub_pc)
+{
+  extern int _dl_mips_gnu_objects;
+
+  /* got[1] is reserved to keep its link map address for the shared
+     object generated by the gnu linker.  If all are such objects, we
+     can find the link map from current GPREG simply.  If not so, get
+     the link map for caller's object containing STUB_PC.  */
+
+  if (_dl_mips_gnu_objects)
+    {
+      ElfW(Addr) *got = elf_mips_got_from_gpreg (gpreg);
+      ElfW(Word) g1;
+
+      g1 = ((ElfW(Word) *) got)[1];
+
+      if ((g1 & ELF_MIPS_GNU_GOT1_MASK) != 0)
+	{
+	  struct link_map *l =
+	    (struct link_map *) (g1 & ~ELF_MIPS_GNU_GOT1_MASK);
+	  ElfW(Addr) base, limit;
+	  const ElfW(Phdr) *p = l->l_phdr;
+	  ElfW(Half) this, nent = l->l_phnum;
+
+	  /* For the common case of a stub being called from the containing
+	     object, STUB_PC will point to somewhere within the object that
+	     is described by the link map fetched via got[1].  Otherwise we
+	     have to scan all maps.  */
+	  for (this = 0; this < nent; this++)
+	    {
+	      if (p[this].p_type == PT_LOAD)
+		{
+		  base = p[this].p_vaddr + l->l_addr;
+		  limit = base + p[this].p_memsz;
+		  if (stub_pc >= base && stub_pc < limit)
+		    return l;
+		}
+	    }
+	}
+    }
+
+    struct link_map *l;
+    Lmid_t nsid;
+
+    for (nsid = 0; nsid < DL_NNS; ++nsid)
+      for (l = GL(dl_ns)[nsid]._ns_loaded; l != NULL; l = l->l_next)
+	{
+	  ElfW(Addr) base, limit;
+	  const ElfW(Phdr) *p = l->l_phdr;
+	  ElfW(Half) this, nent = l->l_phnum;
+
+	  for (this = 0; this < nent; ++this)
+	    {
+	      if (p[this].p_type == PT_LOAD)
+		{
+		  base = p[this].p_vaddr + l->l_addr;
+		  limit = base + p[this].p_memsz;
+		  if (stub_pc >= base && stub_pc < limit)
+		    return l;
+		}
+	    }
+	}
+
+  _dl_signal_error (0, NULL, NULL, "cannot find runtime link map");
+  return NULL;
+}
+
+#if _MIPS_SIM == _ABIO32
+#define ELF_DL_FRAME_SIZE 40
+
+#define ELF_DL_SAVE_ARG_REGS "\
+	sw	$15, 36($29)\n						      \
+	sw	$4, 16($29)\n						      \
+	sw	$5, 20($29)\n						      \
+	sw	$6, 24($29)\n						      \
+	sw	$7, 28($29)\n						      \
+"
+
+#define ELF_DL_RESTORE_ARG_REGS "\
+	lw	$31, 36($29)\n						      \
+	lw	$4, 16($29)\n						      \
+	lw	$5, 20($29)\n						      \
+	lw	$6, 24($29)\n						      \
+	lw	$7, 28($29)\n						      \
+"
+
+#define IFABIO32(X) X
+
+#else /* _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64 */
+
+#define ELF_DL_FRAME_SIZE 80
+
+#define ELF_DL_SAVE_ARG_REGS "\
+	sd	$15, 72($29)\n						      \
+	sd	$4, 8($29)\n						      \
+	sd	$5, 16($29)\n						      \
+	sd	$6, 24($29)\n						      \
+	sd	$7, 32($29)\n						      \
+	sd	$8, 40($29)\n						      \
+	sd	$9, 48($29)\n						      \
+	sd	$10, 56($29)\n						      \
+	sd	$11, 64($29)\n						      \
+"
+
+#define ELF_DL_RESTORE_ARG_REGS "\
+	ld	$31, 72($29)\n						      \
+	ld	$4, 8($29)\n						      \
+	ld	$5, 16($29)\n						      \
+	ld	$6, 24($29)\n						      \
+	ld	$7, 32($29)\n						      \
+	ld	$8, 40($29)\n						      \
+	ld	$9, 48($29)\n						      \
+	ld	$10, 56($29)\n						      \
+	ld	$11, 64($29)\n						      \
+"
+
+#define IFABIO32(X)
+
+#endif
+
+/* Define mips specific runtime resolver. The function __dl_runtime_resolve
+   is called from assembler function _dl_runtime_resolve which converts
+   special argument registers t7 ($15) and t8 ($24):
+     t7  address to return to the caller of the function
+     t8  index for this function symbol in .dynsym
+   to usual c arguments.
+
+   Other architectures call fixup from dl-runtime.c in
+   _dl_runtime_resolve.  MIPS instead calls __dl_runtime_resolve.  We
+   have to use our own version because of the way the got section is
+   treated on MIPS (we've also got ELF_MACHINE_PLT defined).  */
+
+#define ELF_MACHINE_RUNTIME_TRAMPOLINE					      \
+/* The flag _dl_mips_gnu_objects is set if all dynamic objects are	      \
+   generated by the gnu linker. */					      \
+int _dl_mips_gnu_objects = 1;						      \
+									      \
+/* This is called from assembly stubs below which the compiler can't see.  */ \
+static ElfW(Addr)							      \
+__dl_runtime_resolve (ElfW(Word), ElfW(Word), ElfW(Addr), ElfW(Addr))	      \
+		  __attribute_used__;					      \
+									      \
+static ElfW(Addr)							      \
+__dl_runtime_resolve (ElfW(Word) sym_index,				      \
+		      ElfW(Word) return_address,			      \
+		      ElfW(Addr) old_gpreg,				      \
+		      ElfW(Addr) stub_pc)				      \
+{									      \
+  struct link_map *l = elf_machine_runtime_link_map (old_gpreg, stub_pc);     \
+  const ElfW(Sym) *const symtab						      \
+    = (const ElfW(Sym) *) D_PTR (l, l_info[DT_SYMTAB]);			      \
+  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);	      \
+  ElfW(Addr) *got							      \
+    = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);			      \
+  const ElfW(Word) local_gotno						      \
+    = (const ElfW(Word)) l->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;	      \
+  const ElfW(Word) gotsym						      \
+    = (const ElfW(Word)) l->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;	      \
+  const ElfW(Sym) *sym = &symtab[sym_index];				      \
+  ElfW(Addr) value;							      \
+									      \
+  /* FIXME: The symbol versioning stuff is not tested yet.  */		      \
+  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)	      \
+    {									      \
+      switch (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)			      \
+	{								      \
+	default:							      \
+	  {								      \
+	    const ElfW(Half) *vernum =					      \
+	      (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);	      \
+	    ElfW(Half) ndx = vernum[sym_index] & 0x7fff;		      \
+	    const struct r_found_version *version = &l->l_versions[ndx];      \
+									      \
+	    if (version->hash != 0)					      \
+	      {								      \
+		value = _dl_lookup_symbol_x (strtab + sym->st_name, l, 	      \
+					     &sym, l->l_scope, version,	      \
+					     ELF_RTYPE_CLASS_PLT, 0, 0);      \
+		break;							      \
+	      }								      \
+	    /* Fall through.  */					      \
+	  }								      \
+	case 0:								      \
+	  value = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym,	      \
+				       l->l_scope, 0, ELF_RTYPE_CLASS_PLT,    \
+				       DL_LOOKUP_ADD_DEPENDENCY, 0);	      \
+	}								      \
+									      \
+      /* Currently value contains the base load address of the object	      \
+	 that defines sym.  Now add in the symbol offset.  */		      \
+      value = (sym ? value + sym->st_value : 0);			      \
+    }									      \
+  else									      \
+    /* We already found the symbol.  The module (and therefore its load	      \
+       address) is also known.  */					      \
+    value = l->l_addr + sym->st_value;					      \
+									      \
+  /* Apply the relocation with that value.  */				      \
+  *(got + local_gotno + sym_index - gotsym) = value;			      \
+									      \
+  return value;								      \
+}									      \
+									      \
+asm ("\n								      \
+	.text\n								      \
+	.align	2\n							      \
+	.globl	_dl_runtime_resolve\n					      \
+	.type	_dl_runtime_resolve,@function\n				      \
+	.ent	_dl_runtime_resolve\n					      \
+_dl_runtime_resolve:\n							      \
+	.frame	$29, " STRINGXP(ELF_DL_FRAME_SIZE) ", $31\n		      \
+	.set noreorder\n						      \
+	# Save GP.\n							      \
+	move	$3, $28\n						      \
+	# Save arguments and sp value in stack.\n			      \
+	" STRINGXP(PTR_SUBIU) "  $29, " STRINGXP(ELF_DL_FRAME_SIZE) "\n	      \
+	# Modify t9 ($25) so as to point .cpload instruction.\n		      \
+	" IFABIO32(STRINGXP(PTR_ADDIU) "	$25, 12\n") "		      \
+	# Compute GP.\n							      \
+	" STRINGXP(SETUP_GP) "\n					      \
+	" STRINGXV(SETUP_GP64 (0, _dl_runtime_resolve)) "\n		      \
+	.set reorder\n							      \
+	# Save slot call pc.\n						      \
+	move	$2, $31\n						      \
+	" IFABIO32(STRINGXP(CPRESTORE(32))) "\n				      \
+	" ELF_DL_SAVE_ARG_REGS "					      \
+	move	$4, $24\n						      \
+	move	$5, $15\n						      \
+	move	$6, $3\n						      \
+	move	$7, $2\n						      \
+	jal	__dl_runtime_resolve\n					      \
+	" ELF_DL_RESTORE_ARG_REGS "					      \
+	" STRINGXP(RESTORE_GP64) "\n					      \
+	" STRINGXP(PTR_ADDIU) "	$29, " STRINGXP(ELF_DL_FRAME_SIZE) "\n	      \
+	move	$25, $2\n						      \
+	jr	$25\n							      \
+	.end	_dl_runtime_resolve\n					      \
+	.previous\n							      \
+");
+
+/* Mask identifying addresses reserved for the user program,
+   where the dynamic linker should not map anything.  */
+#define ELF_MACHINE_USER_ADDRESS_MASK	0x80000000UL
+
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.
+   Note how we have to be careful about two things:
+
+   1) That we allocate a minimal stack of 24 bytes for
+      every function call, the MIPS ABI states that even
+      if all arguments are passed in registers the procedure
+      called can use the 16 byte area pointed to by $sp
+      when it is called to store away the arguments passed
+      to it.
+
+   2) That under Linux the entry is named __start
+      and not just plain _start.  */
+
+#define RTLD_START asm (\
+	".text\n"\
+	_RTLD_PROLOGUE(ENTRY_POINT) "\
+	" STRINGXV(SETUP_GPX($25)) "\n\
+	" STRINGXV(SETUP_GPX64($18,$25)) "\n\
+	# i386 ABI book says that the first entry of GOT holds\n\
+	# the address of the dynamic structure. Though MIPS ABI\n\
+	# doesn't say nothing about this, I emulate this here.\n\
+	" STRINGXP(PTR_LA) " $4, _DYNAMIC\n\
+	# Subtract OFFSET_GP_GOT\n\
+	" STRINGXP(PTR_S) " $4, -0x7ff0($28)\n\
+	move $4, $29\n\
+	" STRINGXP(PTR_SUBIU) " $29, 16\n\
+	\n\
+	" STRINGXP(PTR_LA) " $8, .Lcoff\n\
+	bltzal $8, .Lcoff\n\
+.Lcoff:	" STRINGXP(PTR_SUBU) " $8, $31, $8\n\
+	\n\
+	" STRINGXP(PTR_LA) " $25, _dl_start\n\
+	" STRINGXP(PTR_ADDU) " $25, $8\n\
+	jalr $25\n\
+	\n\
+	" STRINGXP(PTR_ADDIU) " $29, 16\n\
+	# Get the value of label '_dl_start_user' in t9 ($25).\n\
+	" STRINGXP(PTR_LA) " $25, _dl_start_user\n\
+	.globl _dl_start_user\n\
+	.type _dl_start_user,@function\n\
+	.aent _dl_start_user\n\
+_dl_start_user:\n\
+	" STRINGXP(SETUP_GP) "\n\
+	" STRINGXV(SETUP_GP64($18,_dl_start_user)) "\n\
+	move $16, $28\n\
+	# Save the user entry point address in a saved register.\n\
+	move $17, $2\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	lw $2, _dl_skip_args\n\
+	beq $2, $0, 1f\n\
+	# Load the original argument count.\n\
+	" STRINGXP(PTR_L) " $4, 0($29)\n\
+	# Subtract _dl_skip_args from it.\n\
+	subu $4, $2\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll $2, " STRINGXP (PTRLOG) "\n\
+	" STRINGXP(PTR_ADDU) " $29, $2\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(PTR_S) " $4, 0($29)\n\
+1:	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXP(PTR_L) " $4, _rtld_local\n\
+	" STRINGXP(PTR_L) /* or lw???  fixme */ " $5, 0($29)\n\
+	" STRINGXP(PTR_LA) " $6, " STRINGXP (PTRSIZE) "($29)\n\
+	sll $7, $5, " STRINGXP (PTRLOG) "\n\
+	" STRINGXP(PTR_ADDU) " $7, $7, $6\n\
+	" STRINGXP(PTR_ADDU) " $7, $7, " STRINGXP (PTRSIZE) " \n\
+	" STRINGXP(PTR_SUBIU) " $29, 32\n\
+	" STRINGXP(SAVE_GP(16)) "\n\
+	# Call the function to run the initializers.\n\
+	jal _dl_init_internal\n\
+	" STRINGXP(PTR_ADDIU)  " $29, 32\n\
+	# Pass our finalizer function to the user in $2 as per ELF ABI.\n\
+	" STRINGXP(PTR_LA) " $2, _dl_fini\n\
+	# Jump to the user entry point.\n\
+	move $25, $17\n\
+	jr $25\n\t"\
+	_RTLD_EPILOGUE(ENTRY_POINT)\
+	".previous"\
+);
+
+/* The MIPS never uses Elfxx_Rela relocations.  */
+#define ELF_MACHINE_NO_RELA 1
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE
+
+/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
+   MAP is the object containing the reloc.  */
+
+static inline void
+#ifdef RTLD_BOOTSTRAP
+  __attribute__ ((always_inline))
+#endif
+elf_machine_rel (struct link_map *map, const ElfW(Rel) *reloc,
+		 const ElfW(Sym) *sym, const struct r_found_version *version,
+		 void *const reloc_addr)
+{
+  const unsigned long int r_type = ELFW(R_TYPE) (reloc->r_info);
+
+#if !defined RTLD_BOOTSTRAP && !defined SHARED
+  /* This is defined in rtld.c, but nowhere in the static libc.a;
+     make the reference weak so static programs can still link.  This
+     declaration cannot be done when compiling rtld.c (i.e.  #ifdef
+     RTLD_BOOTSTRAP) because rtld.c contains the common defn for
+     _dl_rtld_map, which is incompatible with a weak decl in the same
+     file.  */
+  weak_extern (GL(dl_rtld_map));
+#endif
+
+  switch (r_type)
+    {
+#if _MIPS_SIM == _ABI64
+    case (R_MIPS_64 << 8) | R_MIPS_REL32:
+#else
+    case R_MIPS_REL32:
+#endif
+      {
+	int symidx = ELFW(R_SYM) (reloc->r_info);
+	ElfW(Addr) reloc_value;
+
+	/* Support relocations on mis-aligned offsets.  Should we ever
+	   implement RELA, this should be replaced with an assignment
+	   from reloc->r_addend.  */
+	__builtin_memcpy (&reloc_value, reloc_addr, sizeof (reloc_value));
+
+	if (symidx)
+	  {
+	    const ElfW(Word) gotsym
+	      = (const ElfW(Word)) map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
+
+	    if ((ElfW(Word))symidx < gotsym)
+	      {
+		/* This wouldn't work for a symbol imported from other
+		   libraries for which there's no GOT entry, but MIPS
+		   requires every symbol referenced in a dynamic
+		   relocation to have a GOT entry in the primary GOT,
+		   so we only get here for locally-defined symbols.
+		   For section symbols, we should *NOT* be adding
+		   sym->st_value (per the definition of the meaning of
+		   S in reloc expressions in the ELF64 MIPS ABI),
+		   since it should have already been added to
+		   reloc_value by the linker, but older versions of
+		   GNU ld didn't add it, and newer versions don't emit
+		   useless relocations to section symbols any more, so
+		   it is safe to keep on adding sym->st_value, even
+		   though it's not ABI compliant.  Some day we should
+		   bite the bullet and stop doing this.  */
+#ifndef RTLD_BOOTSTRAP
+		if (map != &GL(dl_rtld_map))
+#endif
+		  reloc_value += sym->st_value + map->l_addr;
+	      }
+	    else
+	      {
+#ifndef RTLD_BOOTSTRAP
+		const ElfW(Addr) *got
+		  = (const ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+		const ElfW(Word) local_gotno
+		  = (const ElfW(Word))
+		    map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;
+
+		reloc_value += got[symidx + local_gotno - gotsym];
+#endif
+	      }
+	  }
+	else
+#ifndef RTLD_BOOTSTRAP
+	  if (map != &GL(dl_rtld_map))
+#endif
+	    reloc_value += map->l_addr;
+
+	__builtin_memcpy (reloc_addr, &reloc_value, sizeof (reloc_value));
+      }
+      break;
+    case R_MIPS_NONE:		/* Alright, Wilbur.  */
+      break;
+#if _MIPS_SIM == _ABI64
+    case R_MIPS_64:
+      /* For full compliance with the ELF64 ABI, one must precede the
+	 _REL32/_64 pair of relocations with a _64 relocation, such
+	 that the in-place addend is read as a 64-bit value.  IRIX
+	 didn't pick up on this requirement, so we treat the
+	 _REL32/_64 relocation as a 64-bit relocation even if it's by
+	 itself.  For ABI compliance, we ignore such _64 dummy
+	 relocations.  For RELA, this may be simply removed, since
+	 it's totally unnecessary.  */
+      if (ELFW(R_SYM) (reloc->r_info) == 0)
+	break;
+      /* Fall through.  */
+#endif
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+static inline void
+elf_machine_rel_relative (ElfW(Addr) l_addr, const ElfW(Rel) *reloc,
+			  void *const reloc_addr)
+{
+  /* XXX Nothing to do.  There is no relative relocation, right?  */
+}
+
+static inline void
+elf_machine_lazy_rel (struct link_map *map,
+		      ElfW(Addr) l_addr, const ElfW(Rel) *reloc)
+{
+  /* Do nothing.  */
+}
+
+#ifndef RTLD_BOOTSTRAP
+/* Relocate GOT. */
+static inline void
+elf_machine_got_rel (struct link_map *map, int lazy)
+{
+  ElfW(Addr) *got;
+  ElfW(Sym) *sym;
+  const ElfW(Half) *vernum;
+  int i, n, symidx;
+
+#define RESOLVE_GOTSYM(sym,vernum,sym_index)				  \
+    ({									  \
+      const ElfW(Sym) *ref = sym;					  \
+      const struct r_found_version *version				  \
+        = vernum ? &map->l_versions[vernum[sym_index] & 0x7fff] : NULL;	  \
+      ElfW(Addr) value;							  \
+      value = RESOLVE (&ref, version, R_MIPS_REL32);			  \
+      (ref)? value + ref->st_value: 0;					  \
+    })
+
+  if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+    vernum = (const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
+  else
+    vernum = NULL;
+
+  got = (ElfW(Addr) *) D_PTR (map, l_info[DT_PLTGOT]);
+
+  n = map->l_info[DT_MIPS (LOCAL_GOTNO)]->d_un.d_val;
+  /* The dynamic linker's local got entries have already been relocated.  */
+  if (map != &GL(dl_rtld_map))
+    {
+      /* got[0] is reserved. got[1] is also reserved for the dynamic object
+	 generated by gnu ld. Skip these reserved entries from relocation.  */
+      i = (got[1] & ELF_MIPS_GNU_GOT1_MASK)? 2 : 1;
+
+      /* Add the run-time displacement to all local got entries if
+         needed.  */
+      if (__builtin_expect (map->l_addr != 0, 0))
+	{
+	  while (i < n)
+	    got[i++] += map->l_addr;
+	}
+    }
+
+  /* Handle global got entries. */
+  got += n;
+  /* Keep track of the symbol index.  */
+  symidx = map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val;
+  sym = (ElfW(Sym) *) D_PTR (map, l_info[DT_SYMTAB]) + symidx;
+  i = (map->l_info[DT_MIPS (SYMTABNO)]->d_un.d_val
+       - map->l_info[DT_MIPS (GOTSYM)]->d_un.d_val);
+
+  /* This loop doesn't handle Quickstart.  */
+  while (i--)
+    {
+      if (sym->st_shndx == SHN_UNDEF)
+	{
+	  if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC
+	      && sym->st_value && lazy)
+	    *got = sym->st_value + map->l_addr;
+	  else
+	    *got = RESOLVE_GOTSYM (sym, vernum, symidx);
+	}
+      else if (sym->st_shndx == SHN_COMMON)
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx);
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_FUNC
+	       && *got != sym->st_value
+	       && lazy)
+	*got += map->l_addr;
+      else if (ELFW(ST_TYPE) (sym->st_info) == STT_SECTION)
+	{
+	  if (sym->st_other == 0)
+	    *got += map->l_addr;
+	}
+      else
+	*got = RESOLVE_GOTSYM (sym, vernum, symidx);
+
+      ++got;
+      ++sym;
+      ++symidx;
+    }
+
+#undef RESOLVE_GOTSYM
+}
+#endif
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+static inline int
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+# ifndef RTLD_BOOTSTRAP
+  ElfW(Addr) *got;
+  extern void _dl_runtime_resolve (ElfW(Word));
+  extern int _dl_mips_gnu_objects;
+
+  if (lazy)
+    {
+      /* The GOT entries for functions have not yet been filled in.
+	 Their initial contents will arrange when called to put an
+	 offset into the .dynsym section in t8, the return address
+	 in t7 and then jump to _GLOBAL_OFFSET_TABLE[0].  */
+      got = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+
+      /* This function will get called to fix up the GOT entry indicated by
+	 the register t8, and then jump to the resolved address.  */
+      got[0] = (ElfW(Addr)) &_dl_runtime_resolve;
+
+      /* Store l to _GLOBAL_OFFSET_TABLE[1] for gnu object. The MSB
+	 of got[1] of a gnu object is set to identify gnu objects.
+	 Where we can store l for non gnu objects? XXX  */
+      if ((got[1] & ELF_MIPS_GNU_GOT1_MASK) != 0)
+	got[1] = ((ElfW(Addr)) l | ELF_MIPS_GNU_GOT1_MASK);
+      else
+	_dl_mips_gnu_objects = 0;
+    }
+
+  /* Relocate global offset table.  */
+  elf_machine_got_rel (l, lazy);
+
+# endif
+  return lazy;
+}
+
+#endif /* RESOLVE */
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/bits/socket.h glibc-2.3.6/sysdeps/unix/sysv/linux/mips/bits/socket.h
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/bits/socket.h	2004-12-15 01:00:55.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/bits/socket.h	2005-11-04 06:20:05.000000000 +0000
@@ -219,10 +219,10 @@
     socklen_t msg_namelen;	/* Length of address data.  */
 
     struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
-    int msg_iovlen;		/* Number of elements in the vector.  */
+    size_t msg_iovlen;		/* Number of elements in the vector.  */
 
     void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
-    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+    size_t msg_controllen;	/* Ancillary data buffer length.  */
 
     int msg_flags;		/* Flags on received message.  */
   };
@@ -270,8 +270,8 @@
 
   __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
 			       + CMSG_ALIGN (__cmsg->cmsg_len));
-  if ((unsigned char *) (__cmsg + 1) >= ((unsigned char *) __mhdr->msg_control
-					 + __mhdr->msg_controllen)
+  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
+					+ __mhdr->msg_controllen)
       || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
 	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
     /* No more entries.  */
@@ -284,13 +284,12 @@
    <linux/socket.h>.  */
 enum
   {
-    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
+    SCM_RIGHTS = 0x01		/* Transfer file descriptors.  */
 #define SCM_RIGHTS SCM_RIGHTS
 #ifdef __USE_BSD
-    SCM_CREDENTIALS = 0x02,     /* Credentials passing.  */
+    , SCM_CREDENTIALS = 0x02	/* Credentials passing.  */
 # define SCM_CREDENTIALS SCM_CREDENTIALS
 #endif
-    __SCM_CONNECT = 0x03	/* Data array is `struct scm_connect'.  */
   };
 
 /* User visible structure for SCM_CREDENTIALS message */
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/Makefile glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/Makefile
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/Makefile	2005-11-04 06:20:05.000000000 +0000
@@ -0,0 +1,9 @@
+ifeq ($(subdir),socket)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h	2005-10-23 00:42:56.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/n32/sysdep.h	2005-11-04 06:20:05.000000000 +0000
@@ -66,22 +66,28 @@
 #define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
 
 #undef INTERNAL_SYSCALL
-#define INTERNAL_SYSCALL(name, err, nr, args...) internal_syscall##nr(name, err, args)
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	internal_syscall##nr (, "li\t$2, %2\t\t\t# " #name "\n\t",	\
+			      "i" (SYS_ify (name)), err, args)
 
-#define internal_syscall0(name, err, dummy...) 				\
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...) \
+	internal_syscall##nr (= number, , "r" (__v0), err, args)
+
+#define internal_syscall0(ncs_init, cs_init, input, err, dummy...)	\
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
-	register long __a3 asm("$7"); 					\
+	register long long __v0 asm("$2") ncs_init;			\
+	register long long __a3 asm("$7");				\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %2\t\t\t# " #name "\n\t"				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set reorder" 							\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "i" (SYS_ify(name))						\
+	: input								\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -89,21 +95,21 @@
 	_sys_result;							\
 })
 
-#define internal_syscall1(name, err, arg1) 				\
+#define internal_syscall1(ncs_init, cs_init, input, err, arg1)		\
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long long __v0 asm("$2"); 				\
+	register long long __v0 asm("$2") ncs_init;			\
 	register long long __a0 asm("$4") = (long long) arg1; 		\
 	register long long __a3 asm("$7"); 				\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %3\t\t\t# " #name "\n\t"				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set reorder" 							\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "r" (__a0), "i" (SYS_ify(name)) 				\
+	: input, "r" (__a0)		 				\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -111,22 +117,22 @@
 	_sys_result;							\
 })
 
-#define internal_syscall2(name, err, arg1, arg2) 			\
+#define internal_syscall2(ncs_init, cs_init, input, err, arg1, arg2)	\
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long long __v0 asm("$2"); 				\
+	register long long __v0 asm("$2") ncs_init;			\
 	register long long __a0 asm("$4") = (long long) arg1; 		\
 	register long long __a1 asm("$5") = (long long) arg2; 		\
 	register long long __a3 asm("$7"); 				\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %4\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "i" (SYS_ify(name))			\
+	: input, "r" (__a0), "r" (__a1)					\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -134,23 +140,23 @@
 	_sys_result;							\
 })
 
-#define internal_syscall3(name, err, arg1, arg2, arg3) 			\
+#define internal_syscall3(ncs_init, cs_init, input, err, arg1, arg2, arg3) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long long __v0 asm("$2"); 				\
+	register long long __v0 asm("$2") ncs_init;			\
 	register long long __a0 asm("$4") = (long long) arg1; 		\
 	register long long __a1 asm("$5") = (long long) arg2; 		\
 	register long long __a2 asm("$6") = (long long) arg3; 		\
 	register long long __a3 asm("$7"); 				\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2)			\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -158,23 +164,23 @@
 	_sys_result;							\
 })
 
-#define internal_syscall4(name, err, arg1, arg2, arg3, arg4) 		\
+#define internal_syscall4(ncs_init, cs_init, input, err, arg1, arg2, arg3, arg4) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long long __v0 asm("$2"); 				\
+	register long long __v0 asm("$2") ncs_init;			\
 	register long long __a0 asm("$4") = (long long) arg1; 		\
 	register long long __a1 asm("$5") = (long long) arg2; 		\
 	register long long __a2 asm("$6") = (long long) arg3; 		\
 	register long long __a3 asm("$7") = (long long) arg4; 		\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "+r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2)		 	\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -182,12 +188,12 @@
 	_sys_result;							\
 })
 
-#define internal_syscall5(name, err, arg1, arg2, arg3, arg4, arg5) 	\
+#define internal_syscall5(ncs_init, cs_init, input, err, arg1, arg2, arg3, arg4, arg5) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long long __v0 asm("$2"); 				\
+	register long long __v0 asm("$2") ncs_init;			\
 	register long long __a0 asm("$4") = (long long) arg1; 		\
 	register long long __a1 asm("$5") = (long long) arg2; 		\
 	register long long __a2 asm("$6") = (long long) arg3; 		\
@@ -195,12 +201,11 @@
 	register long long __a4 asm("$8") = (long long) arg5; 		\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "+r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
-	  "r" (__a4) 							\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2), "r" (__a4)		\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -208,12 +213,12 @@
 	_sys_result;							\
 })
 
-#define internal_syscall6(name, err, arg1, arg2, arg3, arg4, arg5, arg6)\
+#define internal_syscall6(ncs_init, cs_init, input, err, arg1, arg2, arg3, arg4, arg5, arg6) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long long __v0 asm("$2"); 				\
+	register long long __v0 asm("$2") ncs_init;			\
 	register long long __a0 asm("$4") = (long long) arg1; 		\
 	register long long __a1 asm("$5") = (long long) arg2; 		\
 	register long long __a2 asm("$6") = (long long) arg3; 		\
@@ -222,12 +227,12 @@
 	register long long __a5 asm("$9") = (long long) arg6; 		\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "+r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
-	  "r" (__a4), "r" (__a5)					\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2), "r" (__a4),	\
+	  "r" (__a5)							\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h	2005-10-23 00:42:56.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/n64/sysdep.h	2005-11-04 06:20:05.000000000 +0000
@@ -66,22 +66,28 @@
 #define INTERNAL_SYSCALL_ERRNO(val, err)     (val)
 
 #undef INTERNAL_SYSCALL
-#define INTERNAL_SYSCALL(name, err, nr, args...) internal_syscall##nr(name, err, args)
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	internal_syscall##nr (, "li\t$2, %2\t\t\t# " #name "\n\t",	\
+			      "i" (SYS_ify (name)), err, args)
 
-#define internal_syscall0(name, err, dummy...) 				\
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...) \
+	internal_syscall##nr (= number, , "r" (__v0), err, args)
+
+#define internal_syscall0(ncs_init, cs_init, input, err, dummy...)	\
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
-	register long __a3 asm("$7"); 					\
+	register long __v0 asm("$2") ncs_init;				\
+	register long __a3 asm("$7");					\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %2\t\t\t# " #name "\n\t"				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set reorder" 							\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "i" (SYS_ify(name))						\
+	: input								\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -89,21 +95,21 @@
 	_sys_result;							\
 })
 
-#define internal_syscall1(name, err, arg1) 				\
+#define internal_syscall1(ncs_init, cs_init, input, err, arg1)		\
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
+	register long __v0 asm("$2") ncs_init;				\
 	register long __a0 asm("$4") = (long) arg1; 			\
 	register long __a3 asm("$7"); 					\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %3\t\t\t# " #name "\n\t"				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set reorder" 							\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "r" (__a0), "i" (SYS_ify(name)) 				\
+	: input, "r" (__a0)		 				\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -111,22 +117,22 @@
 	_sys_result;							\
 })
 
-#define internal_syscall2(name, err, arg1, arg2) 			\
+#define internal_syscall2(ncs_init, cs_init, input, err, arg1, arg2)	\
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
+	register long __v0 asm("$2") ncs_init;				\
 	register long __a0 asm("$4") = (long) arg1; 			\
 	register long __a1 asm("$5") = (long) arg2; 			\
 	register long __a3 asm("$7"); 					\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %4\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "i" (SYS_ify(name))			\
+	: input, "r" (__a0), "r" (__a1)					\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -134,23 +140,23 @@
 	_sys_result;							\
 })
 
-#define internal_syscall3(name, err, arg1, arg2, arg3) 			\
+#define internal_syscall3(ncs_init, cs_init, input, err, arg1, arg2, arg3) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
+	register long __v0 asm("$2") ncs_init;				\
 	register long __a0 asm("$4") = (long) arg1; 			\
 	register long __a1 asm("$5") = (long) arg2; 			\
 	register long __a2 asm("$6") = (long) arg3; 			\
 	register long __a3 asm("$7"); 					\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "=r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2)			\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -158,23 +164,23 @@
 	_sys_result;							\
 })
 
-#define internal_syscall4(name, err, arg1, arg2, arg3, arg4) 		\
+#define internal_syscall4(ncs_init, cs_init, input, err, arg1, arg2, arg3, arg4) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
+	register long __v0 asm("$2") ncs_init;				\
 	register long __a0 asm("$4") = (long) arg1; 			\
 	register long __a1 asm("$5") = (long) arg2; 			\
 	register long __a2 asm("$6") = (long) arg3; 			\
 	register long __a3 asm("$7") = (long) arg4; 			\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "+r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)) 	\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2)		 	\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -182,12 +188,12 @@
 	_sys_result;							\
 })
 
-#define internal_syscall5(name, err, arg1, arg2, arg3, arg4, arg5) 	\
+#define internal_syscall5(ncs_init, cs_init, input, err, arg1, arg2, arg3, arg4, arg5) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
+	register long __v0 asm("$2") ncs_init;				\
 	register long __a0 asm("$4") = (long) arg1; 			\
 	register long __a1 asm("$5") = (long) arg2; 			\
 	register long __a2 asm("$6") = (long) arg3; 			\
@@ -195,12 +201,11 @@
 	register long __a4 asm("$8") = (long) arg5; 			\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "+r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
-	  "r" (__a4) 							\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2), "r" (__a4)		\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
@@ -208,12 +213,12 @@
 	_sys_result;							\
 })
 
-#define internal_syscall6(name, err, arg1, arg2, arg3, arg4, arg5, arg6)\
+#define internal_syscall6(ncs_init, cs_init, input, err, arg1, arg2, arg3, arg4, arg5, arg6) \
 ({ 									\
 	long _sys_result;						\
 									\
 	{								\
-	register long __v0 asm("$2"); 					\
+	register long __v0 asm("$2") ncs_init;				\
 	register long __a0 asm("$4") = (long) arg1; 			\
 	register long __a1 asm("$5") = (long) arg2; 			\
 	register long __a2 asm("$6") = (long) arg3; 			\
@@ -222,12 +227,12 @@
 	register long __a5 asm("$9") = (long) arg6; 			\
 	__asm__ volatile ( 						\
 	".set\tnoreorder\n\t" 						\
-	"li\t$2, %5\t\t\t# " #name "\n\t" 				\
+	cs_init								\
 	"syscall\n\t" 							\
 	".set\treorder" 						\
 	: "=r" (__v0), "+r" (__a3) 					\
-	: "r" (__a0), "r" (__a1), "r" (__a2), "i" (SYS_ify(name)), 	\
-	  "r" (__a4), "r" (__a5)					\
+	: input, "r" (__a0), "r" (__a1), "r" (__a2), "r" (__a4),	\
+	  "r" (__a5)							\
 	: __SYSCALL_CLOBBERS); 						\
 	err = __a3;							\
 	_sys_result = __v0;						\
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/syscalls.list glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/syscalls.list
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/mips64/syscalls.list	2004-07-21 06:13:15.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/mips64/syscalls.list	2005-11-04 06:20:05.000000000 +0000
@@ -1,16 +1,12 @@
 # File name	Caller	Syscall name	Args	Strong name	Weak names
 
-lseek		-	lseek		i:iii	__libc_lseek	__lseek lseek __llseek llseek __libc_lseek64 __lseek64 lseek64
-
-# proper socket implementations:
-recvfrom	-	recvfrom	i:ibniBN __libc_recvfrom __recvfrom recvfrom
-sendto		-	sendto		i:ibnibn __libc_sendto	__sendto sendto
+lseek		-	lseek		Ci:iii	__libc_lseek	__lseek lseek __llseek llseek __libc_lseek64 __lseek64 lseek64
 
 # semaphore and shm system calls
 msgctl		-	msgctl		i:iip	__msgctl	msgctl
 msgget		-	msgget		i:ii	__msgget	msgget
-msgrcv		-	msgrcv		i:ibnii	__msgrcv	msgrcv
-msgsnd		-	msgsnd		i:ibni	__msgsnd	msgsnd
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
 shmat		-	shmat		i:ipi	__shmat		shmat
 shmctl		-	shmctl		i:iip	__shmctl	shmctl
 shmdt		-	shmdt		i:s	__shmdt		shmdt
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/ptrace.c glibc-2.3.6/sysdeps/unix/sysv/linux/mips/ptrace.c
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/ptrace.c	2004-11-24 04:36:11.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/ptrace.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,111 +0,0 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
-	Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <errno.h>
-#include <sgidefs.h>
-#include <sys/types.h>
-#include <sys/ptrace.h>
-#include <sys/user.h>
-#include <stdarg.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-#include <bp-checks.h>
-#include <sgidefs.h>
-
-#if _MIPS_SIM == _ABIN32
-__extension__ typedef long long int reg_type;
-#else
-typedef long int reg_type;
-#endif
-
-reg_type
-ptrace (enum __ptrace_request request, ...)
-{
-  reg_type res, ret;
-  va_list ap;
-  pid_t pid;
-  void *addr;
-  reg_type data;
-
-  va_start (ap, request);
-  pid = va_arg (ap, pid_t);
-  addr = va_arg (ap, void *);
-  data = va_arg (ap, reg_type);
-  va_end (ap);
-
-  if (request > 0 && request < 4)
-    data = &ret;
-
-#if __BOUNDED_POINTERS__
-  switch (request)
-    {
-    case PTRACE_PEEKTEXT:
-    case PTRACE_PEEKDATA:
-    case PTRACE_PEEKUSER:
-    case PTRACE_POKETEXT:
-    case PTRACE_POKEDATA:
-    case PTRACE_POKEUSER:
-      (void) CHECK_1 ((int *) addr);
-      (void) CHECK_1 ((int *) data);
-      break;
-
-    case PTRACE_GETREGS:
-    case PTRACE_SETREGS:
-      /* We don't know the size of data, so the best we can do is ensure
-	 that `data' is valid for at least one word.  */
-      (void) CHECK_1 ((int *) data);
-      break;
-
-    case PTRACE_GETFPREGS:
-    case PTRACE_SETFPREGS:
-      /* We don't know the size of data, so the best we can do is ensure
-	 that `data' is valid for at least one word.  */
-      (void) CHECK_1 ((int *) data);
-      break;
-
-    case PTRACE_GETFPXREGS:
-    case PTRACE_SETFPXREGS:
-      /* We don't know the size of data, so the best we can do is ensure
-	 that `data' is valid for at least one word.  */
-      (void) CHECK_1 ((int *) data);
-      break;
-
-    case PTRACE_TRACEME:
-    case PTRACE_CONT:
-    case PTRACE_KILL:
-    case PTRACE_SINGLESTEP:
-    case PTRACE_ATTACH:
-    case PTRACE_DETACH:
-    case PTRACE_SYSCALL:
-      /* Neither `data' nor `addr' needs any checks.  */
-      break;
-    };
-#endif
-
-  res = INLINE_SYSCALL (ptrace, 4, request, pid,
-			__ptrvalue (addr), __ptrvalue (data));
-  if (res >= 0 && request > 0 && request < 4)
-    {
-      __set_errno (0);
-      return ret;
-    }
-
-  return res;
-}
diff -Naur glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/sys/ptrace.h glibc-2.3.6/sysdeps/unix/sysv/linux/mips/sys/ptrace.h
--- glibc-2.3.6.orig/sysdeps/unix/sysv/linux/mips/sys/ptrace.h	2004-11-24 04:37:35.000000000 +0000
+++ glibc-2.3.6/sysdeps/unix/sysv/linux/mips/sys/ptrace.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,136 +0,0 @@
-/* `ptrace' debugger support interface.  Linux version.
-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004
-	Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_PTRACE_H
-#define _SYS_PTRACE_H	1
-
-#include <features.h>
-#include <sgidefs.h>
-
-__BEGIN_DECLS
-
-/* Type of the REQUEST argument to `ptrace.'  */
-enum __ptrace_request
-{
-  /* Indicate that the process making this request should be traced.
-     All signals received by this process can be intercepted by its
-     parent, and its parent can use the other `ptrace' requests.  */
-  PTRACE_TRACEME = 0,
-#define PT_TRACE_ME PTRACE_TRACEME
-
-  /* Return the word in the process's text space at address ADDR.  */
-  PTRACE_PEEKTEXT = 1,
-#define PT_READ_I PTRACE_PEEKTEXT
-
-  /* Return the word in the process's data space at address ADDR.  */
-  PTRACE_PEEKDATA = 2,
-#define PT_READ_D PTRACE_PEEKDATA
-
-  /* Return the word in the process's user area at offset ADDR.  */
-  PTRACE_PEEKUSER = 3,
-#define PT_READ_U PTRACE_PEEKUSER
-
-  /* Write the word DATA into the process's text space at address ADDR.  */
-  PTRACE_POKETEXT = 4,
-#define PT_WRITE_I PTRACE_POKETEXT
-
-  /* Write the word DATA into the process's data space at address ADDR.  */
-  PTRACE_POKEDATA = 5,
-#define PT_WRITE_D PTRACE_POKEDATA
-
-  /* Write the word DATA into the process's user area at offset ADDR.  */
-  PTRACE_POKEUSER = 6,
-#define PT_WRITE_U PTRACE_POKEUSER
-
-  /* Continue the process.  */
-  PTRACE_CONT = 7,
-#define PT_CONTINUE PTRACE_CONT
-
-  /* Kill the process.  */
-  PTRACE_KILL = 8,
-#define PT_KILL PTRACE_KILL
-
-  /* Single step the process.
-     This is not supported on all machines.  */
-  PTRACE_SINGLESTEP = 9,
-#define PT_STEP PTRACE_SINGLESTEP
-
-  /* Get all general purpose registers used by a processes.
-     This is not supported on all machines.  */
-   PTRACE_GETREGS = 12,
-#define PT_GETREGS PTRACE_GETREGS
-
-  /* Set all general purpose registers used by a processes.
-     This is not supported on all machines.  */
-   PTRACE_SETREGS = 13,
-#define PT_SETREGS PTRACE_SETREGS
-
-  /* Get all floating point registers used by a processes.
-     This is not supported on all machines.  */
-   PTRACE_GETFPREGS = 14,
-#define PT_GETFPREGS PTRACE_GETFPREGS
-
-  /* Set all floating point registers used by a processes.
-     This is not supported on all machines.  */
-   PTRACE_SETFPREGS = 15,
-#define PT_SETFPREGS PTRACE_SETFPREGS
-
-  /* Attach to a process that is already running. */
-  PTRACE_ATTACH = 16,
-#define PT_ATTACH PTRACE_ATTACH
-
-  /* Detach from a process attached to with PTRACE_ATTACH.  */
-  PTRACE_DETACH = 17,
-#define PT_DETACH PTRACE_DETACH
-
-  /* Get all extended floating point registers used by a processes.
-     This is not supported on all machines.  */
-   PTRACE_GETFPXREGS = 18,
-#define PT_GETFPXREGS PTRACE_GETFPXREGS
-
-  /* Set all extended floating point registers used by a processes.
-     This is not supported on all machines.  */
-   PTRACE_SETFPXREGS = 19,
-#define PT_SETFPXREGS PTRACE_SETFPXREGS
-
-  /* Continue and stop at the next (return from) syscall.  */
-  PTRACE_SYSCALL = 24
-#define PT_SYSCALL PTRACE_SYSCALL
-};
-
-/* Perform process tracing functions.  REQUEST is one of the values
-   above, and determines the action to be taken.
-   For all requests except PTRACE_TRACEME, PID specifies the process to be
-   traced.
-
-   PID and the other arguments described above for the various requests should
-   appear (those that are used for the particular request) as:
-     pid_t PID, void *ADDR, int DATA, void *ADDR2
-   after REQUEST.  */
-#if _MIPS_SIM == _ABIN32
-__extension__ extern long long int ptrace
-  (enum __ptrace_request __request, ...) __THROW;
-#else
-extern long int ptrace (enum __ptrace_request __request, ...) __THROW;
-#endif
-
-__END_DECLS
-
-#endif /* _SYS_PTRACE_H */
