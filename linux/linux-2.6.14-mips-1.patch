Submitted By: Jim Gifford (patches at jg555 dot com)
Date: 2005-11-17
Initial Package Version: 2.6.14
Origin: Linux-MIPS
Upstream Status: N/A
Description: Merges changes from the Linux-MIPS.org linux tree

diff -Naur linux-2.6.14/arch/mips/arc/identify.c linux-mips-2.6.14.orig/arch/mips/arc/identify.c
--- linux-2.6.14/arch/mips/arc/identify.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/arc/identify.c	2005-11-17 11:42:18.000000000 -0800
@@ -44,6 +44,11 @@
 		MACH_GROUP_SGI,
 		MACH_SGI_IP28,
 		PROM_FLAG_ARCS
+	}, {	"SGI-IP30",
+		"SGI Octane",
+		MACH_GROUP_SGI,
+		MACH_SGI_IP30,
+		PROM_FLAG_ARCS
 	}, {	"SGI-IP32",
 		"SGI O2",
 		MACH_GROUP_SGI,
diff -Naur linux-2.6.14/arch/mips/arc/Makefile linux-mips-2.6.14.orig/arch/mips/arc/Makefile
--- linux-2.6.14/arch/mips/arc/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/arc/Makefile	2005-11-17 11:42:18.000000000 -0800
@@ -3,7 +3,7 @@
 #
 
 lib-y				+= cmdline.o env.o file.o identify.o init.o \
-				   misc.o time.o tree.o
+				   misc.o salone.o time.o tree.o
 
 lib-$(CONFIG_ARC_MEMORY)	+= memory.o
 lib-$(CONFIG_ARC_CONSOLE)	+= arc_con.o
diff -Naur linux-2.6.14/arch/mips/au1000/common/au1xxx_irqmap.c linux-mips-2.6.14.orig/arch/mips/au1000/common/au1xxx_irqmap.c
--- linux-2.6.14/arch/mips/au1000/common/au1xxx_irqmap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/au1xxx_irqmap.c	2005-11-17 11:42:18.000000000 -0800
@@ -173,14 +173,14 @@
 	{ AU1550_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1550_PSC2_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1550_PSC3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
-	{ AU1550_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1550_NAND_INT, INTC_INT_RISE_EDGE, 0},
 	{ AU1550_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1550_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
@@ -201,14 +201,14 @@
 	{ AU1200_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1200_AES_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1200_CAMERA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
-	{ AU1200_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1200_NAND_INT, INTC_INT_RISE_EDGE, 0},
 	{ AU1200_USB_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1200_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
diff -Naur linux-2.6.14/arch/mips/au1000/common/cputable.c linux-mips-2.6.14.orig/arch/mips/au1000/common/cputable.c
--- linux-2.6.14/arch/mips/au1000/common/cputable.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/cputable.c	2005-11-17 11:42:18.000000000 -0800
@@ -37,7 +37,8 @@
     { 0xffffffff, 0x02030203, "Au1100 BD", 0, 1 },
     { 0xffffffff, 0x02030204, "Au1100 BE", 0, 1 },
     { 0xffffffff, 0x03030200, "Au1550 AA", 0, 1 },
-    { 0xffffffff, 0x04030200, "Au1200 AA", 0, 1 },
+    { 0xffffffff, 0x04030200, "Au1200 AB", 0, 0 },
+    { 0xffffffff, 0x04030201, "Au1200 AC", 0, 1 },
     { 0x00000000, 0x00000000, "Unknown Au1xxx", 1, 0 },
 };
 
diff -Naur linux-2.6.14/arch/mips/au1000/common/dbdma.c linux-mips-2.6.14.orig/arch/mips/au1000/common/dbdma.c
--- linux-2.6.14/arch/mips/au1000/common/dbdma.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/dbdma.c	2005-11-17 11:42:18.000000000 -0800
@@ -29,6 +29,7 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
+
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -38,10 +39,12 @@
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/module.h>
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-au1x00/au1xxx_dbdma.h>
 #include <asm/system.h>
 
+
 #if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
 
 /*
@@ -61,37 +64,10 @@
 */
 #define ALIGN_ADDR(x, a)	((((u32)(x)) + (a-1)) & ~(a-1))
 
-static volatile dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
-static int dbdma_initialized;
+static dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
+static int dbdma_initialized=0;
 static void au1xxx_dbdma_init(void);
 
-typedef struct dbdma_device_table {
-	u32		dev_id;
-	u32		dev_flags;
-	u32		dev_tsize;
-	u32		dev_devwidth;
-	u32		dev_physaddr;		/* If FIFO */
-	u32		dev_intlevel;
-	u32		dev_intpolarity;
-} dbdev_tab_t;
-
-typedef struct dbdma_chan_config {
-	u32			chan_flags;
-	u32			chan_index;
-	dbdev_tab_t		*chan_src;
-	dbdev_tab_t		*chan_dest;
-	au1x_dma_chan_t		*chan_ptr;
-	au1x_ddma_desc_t	*chan_desc_base;
-	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
-	void			*chan_callparam;
-	void (*chan_callback)(int, void *, struct pt_regs *);
-} chan_tab_t;
-
-#define	DEV_FLAGS_INUSE		(1 << 0)
-#define	DEV_FLAGS_ANYUSE	(1 << 1)
-#define DEV_FLAGS_OUT		(1 << 2)
-#define DEV_FLAGS_IN		(1 << 3)
-
 static dbdev_tab_t dbdev_tab[] = {
 #ifdef CONFIG_SOC_AU1550
 	/* UARTS */
@@ -157,25 +133,25 @@
 	{ DSCR_CMD0_MAE_BOTH, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_LCD, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 4, 8, 0x10600000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 4, 8, 0x10600004, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 4, 8, 0x10680000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 4, 8, 0x10680004, 0, 0 },
 
-	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN , 4, 32, 0x10300008, 0, 0 },
+	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 4, 32, 0x10300004, 0, 0 },
 
-	{ DSCR_CMD0_PSC0_TX, DEV_FLAGS_OUT, 0, 0, 0x11a0001c, 0, 0 },
-	{ DSCR_CMD0_PSC0_RX, DEV_FLAGS_IN, 0, 0, 0x11a0001c, 0, 0 },
+	{ DSCR_CMD0_PSC0_TX, DEV_FLAGS_OUT, 0, 16, 0x11a0001c, 0, 0 },
+	{ DSCR_CMD0_PSC0_RX, DEV_FLAGS_IN, 0, 16, 0x11a0001c, 0, 0 },
 	{ DSCR_CMD0_PSC0_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_PSC1_TX, DEV_FLAGS_OUT, 0, 0, 0x11b0001c, 0, 0 },
-	{ DSCR_CMD0_PSC1_RX, DEV_FLAGS_IN, 0, 0, 0x11b0001c, 0, 0 },
+	{ DSCR_CMD0_PSC1_TX, DEV_FLAGS_OUT, 0, 16, 0x11b0001c, 0, 0 },
+	{ DSCR_CMD0_PSC1_RX, DEV_FLAGS_IN, 0, 16, 0x11b0001c, 0, 0 },
 	{ DSCR_CMD0_PSC1_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 32, 0x14004020, 0, 0 },
+	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 32, 0x14004040, 0, 0 },
+	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 32, 0x14004060, 0, 0 },
 	{ DSCR_CMD0_CIM_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
 	{ DSCR_CMD0_NAND_FLASH, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
@@ -184,6 +160,24 @@
 
 	{ DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	/* Provide 16 user definable device types */
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 #define DBDEV_TAB_SIZE (sizeof(dbdev_tab) / sizeof(dbdev_tab_t))
@@ -203,6 +197,36 @@
 	return NULL;
 }
 
+void * au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp)
+{
+        return phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+}
+EXPORT_SYMBOL(au1xxx_ddma_get_nextptr_virt);
+
+u32
+au1xxx_ddma_add_device(dbdev_tab_t *dev)
+{
+	u32 ret = 0;
+	dbdev_tab_t *p=NULL;
+	static u16 new_id=0x1000;
+
+	p = find_dbdev_id(0);
+	if ( NULL != p )
+	{
+		memcpy(p, dev, sizeof(dbdev_tab_t));
+ 		p->dev_id = DSCR_DEV2CUSTOM_ID(new_id,dev->dev_id);
+		ret = p->dev_id;
+		new_id++;
+#if 0
+		printk("add_device: id:%x flags:%x padd:%x\n",
+				p->dev_id, p->dev_flags, p->dev_physaddr );
+#endif
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(au1xxx_ddma_add_device);
+
 /* Allocate a channel and return a non-zero descriptor if successful.
 */
 u32
@@ -215,7 +239,7 @@
 	int		i;
 	dbdev_tab_t	*stp, *dtp;
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	/* We do the intialization on the first channel allocation.
 	 * We have to wait because of the interrupt handler initialization
@@ -225,9 +249,6 @@
 		au1xxx_dbdma_init();
 	dbdma_initialized = 1;
 
-	if ((srcid > DSCR_NDEV_IDS) || (destid > DSCR_NDEV_IDS))
-		return 0;
-
 	if ((stp = find_dbdev_id(srcid)) == NULL) return 0;
 	if ((dtp = find_dbdev_id(destid)) == NULL) return 0;
 
@@ -271,7 +292,6 @@
 				 */
 				ctp = kmalloc(sizeof(chan_tab_t), GFP_KERNEL);
 				chan_tab_ptr[i] = ctp;
-				ctp->chan_index = chan = i;
 				break;
 			}
 		}
@@ -279,10 +299,11 @@
 
 		if (ctp != NULL) {
 			memset(ctp, 0, sizeof(chan_tab_t));
+			ctp->chan_index = chan = i;
 			dcp = DDMA_CHANNEL_BASE;
 			dcp += (0x0100 * chan);
 			ctp->chan_ptr = (au1x_dma_chan_t *)dcp;
-			cp = (volatile au1x_dma_chan_t *)dcp;
+			cp = (au1x_dma_chan_t *)dcp;
 			ctp->chan_src = stp;
 			ctp->chan_dest = dtp;
 			ctp->chan_callback = callback;
@@ -299,6 +320,9 @@
 				i |= DDMA_CFG_DED;
 			if (dtp->dev_intpolarity)
 				i |= DDMA_CFG_DP;
+			if ((stp->dev_flags & DEV_FLAGS_SYNC) ||
+				(dtp->dev_flags & DEV_FLAGS_SYNC))
+					i |= DDMA_CFG_SYNC;
 			cp->ddma_cfg = i;
 			au_sync();
 
@@ -309,14 +333,14 @@
 			rv = (u32)(&chan_tab_ptr[chan]);
 		}
 		else {
-			/* Release devices.
-			*/
+			/* Release devices */
 			stp->dev_flags &= ~DEV_FLAGS_INUSE;
 			dtp->dev_flags &= ~DEV_FLAGS_INUSE;
 		}
 	}
 	return rv;
 }
+EXPORT_SYMBOL(au1xxx_dbdma_chan_alloc);
 
 /* Set the device width if source or destination is a FIFO.
  * Should be 8, 16, or 32 bits.
@@ -344,6 +368,7 @@
 
 	return rv;
 }
+EXPORT_SYMBOL(au1xxx_dbdma_set_devwidth);
 
 /* Allocate a descriptor ring, initializing as much as possible.
 */
@@ -370,7 +395,8 @@
 	 * and if we try that first we are likely to not waste larger
 	 * slabs of memory.
 	 */
-	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), GFP_KERNEL);
+	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t),
+			GFP_KERNEL|GFP_DMA);
 	if (desc_base == 0)
 		return 0;
 
@@ -381,7 +407,7 @@
 		kfree((const void *)desc_base);
 		i = entries * sizeof(au1x_ddma_desc_t);
 		i += (sizeof(au1x_ddma_desc_t) - 1);
-		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL)) == 0)
+		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL|GFP_DMA)) == 0)
 			return 0;
 
 		desc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));
@@ -403,7 +429,13 @@
 	cmd0 |= DSCR_CMD0_SID(srcid);
 	cmd0 |= DSCR_CMD0_DID(destid);
 	cmd0 |= DSCR_CMD0_IE | DSCR_CMD0_CV;
-	cmd0 |= DSCR_CMD0_ST(DSCR_CMD0_ST_CURRENT);
+	cmd0 |= DSCR_CMD0_ST(DSCR_CMD0_ST_NOCHANGE);
+
+        /* is it mem to mem transfer? */
+        if(((DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_THROTTLE) || (DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_ALWAYS)) &&
+           ((DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_THROTTLE) || (DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_ALWAYS))) {
+               cmd0 |= DSCR_CMD0_MEM;
+        }
 
 	switch (stp->dev_devwidth) {
 	case 8:
@@ -461,9 +493,14 @@
 	/* If source input is fifo, set static address.
 	*/
 	if (stp->dev_flags & DEV_FLAGS_IN) {
-		src0 = stp->dev_physaddr;
+		if ( stp->dev_flags & DEV_FLAGS_BURSTABLE )
+			src1 |= DSCR_SRC1_SAM(DSCR_xAM_BURST);
+		else
 		src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
+
 	}
+	if (stp->dev_physaddr)
+		src0 = stp->dev_physaddr;
 
 	/* Set up dest1.  For now, assume no stride and increment.
 	 * A channel attribute update can change this later.
@@ -487,10 +524,18 @@
 	/* If destination output is fifo, set static address.
 	*/
 	if (dtp->dev_flags & DEV_FLAGS_OUT) {
-		dest0 = dtp->dev_physaddr;
+		if ( dtp->dev_flags & DEV_FLAGS_BURSTABLE )
+	                dest1 |= DSCR_DEST1_DAM(DSCR_xAM_BURST);
+				else
 		dest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);
 	}
+	if (dtp->dev_physaddr)
+		dest0 = dtp->dev_physaddr;
 
+#if 0
+		printk("did:%x sid:%x cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
+			dtp->dev_id, stp->dev_id, cmd0, cmd1, src0, src1, dest0, dest1 );
+#endif
 	for (i=0; i<entries; i++) {
 		dp->dscr_cmd0 = cmd0;
 		dp->dscr_cmd1 = cmd1;
@@ -499,6 +544,8 @@
 		dp->dscr_dest0 = dest0;
 		dp->dscr_dest1 = dest1;
 		dp->dscr_stat = 0;
+		dp->sw_context = 0;
+		dp->sw_status = 0;
 		dp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(dp + 1));
 		dp++;
 	}
@@ -511,13 +558,14 @@
 
 	return (u32)(ctp->chan_desc_base);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_ring_alloc);
 
 /* Put a source buffer into the DMA ring.
  * This updates the source pointer and byte count.  Normally used
  * for memory to fifo transfers.
  */
 u32
-au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes)
+_au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -544,8 +592,24 @@
 	*/
 	dp->dscr_source0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
-	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
-	ctp->chan_ptr->ddma_dbell = 0xffffffff;	/* Make it go */
+	/* Check flags  */
+	if (flags & DDMA_FLAGS_IE)
+		dp->dscr_cmd0 |= DSCR_CMD0_IE;
+	if (flags & DDMA_FLAGS_NOIE)
+		dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+
+	/*
+	 * There is an errata on the Au1200/Au1550 parts that could result
+	 * in "stale" data being DMA'd. It has to do with the snoop logic on
+	 * the dache eviction buffer.  NONCOHERENT_IO is on by default for
+	 * these parts. If it is fixedin the future, these dma_cache_inv will
+	 * just be nothing more than empty macros. See io.h.
+	 * */
+	dma_cache_wback_inv((unsigned long)buf, nbytes);
+        dp->dscr_cmd0 |= DSCR_CMD0_V;        /* Let it rip */
+	au_sync();
+	dma_cache_wback_inv((unsigned long)dp, sizeof(dp));
+        ctp->chan_ptr->ddma_dbell = 0;
 
 	/* Get next descriptor pointer.
 	*/
@@ -555,13 +619,14 @@
 	*/
 	return nbytes;
 }
+EXPORT_SYMBOL(_au1xxx_dbdma_put_source);
 
 /* Put a destination buffer into the DMA ring.
  * This updates the destination pointer and byte count.  Normally used
  * to place an empty buffer into the ring for fifo to memory transfers.
  */
 u32
-au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes)
+_au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -583,11 +648,33 @@
 	if (dp->dscr_cmd0 & DSCR_CMD0_V)
 		return 0;
 
-	/* Load up buffer address and byte count.
-	*/
+	/* Load up buffer address and byte count */
+
+	/* Check flags  */
+	if (flags & DDMA_FLAGS_IE)
+		dp->dscr_cmd0 |= DSCR_CMD0_IE;
+	if (flags & DDMA_FLAGS_NOIE)
+		dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+
 	dp->dscr_dest0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
+#if 0
+	printk("cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
+			dp->dscr_cmd0, dp->dscr_cmd1, dp->dscr_source0,
+			dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1 );
+#endif
+	/*
+	 * There is an errata on the Au1200/Au1550 parts that could result in
+	 * "stale" data being DMA'd. It has to do with the snoop logic on the
+	 * dache eviction buffer. NONCOHERENT_IO is on by default for these
+	 * parts. If it is fixedin the future, these dma_cache_inv will just
+	 * be nothing more than empty macros. See io.h.
+	 * */
+	dma_cache_inv((unsigned long)buf,nbytes);
 	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
+	au_sync();
+	dma_cache_wback_inv((unsigned long)dp, sizeof(dp));
+        ctp->chan_ptr->ddma_dbell = 0;
 
 	/* Get next descriptor pointer.
 	*/
@@ -597,6 +684,7 @@
 	*/
 	return nbytes;
 }
+EXPORT_SYMBOL(_au1xxx_dbdma_put_dest);
 
 /* Get a destination buffer into the DMA ring.
  * Normally used to get a full buffer from the ring during fifo
@@ -646,7 +734,7 @@
 au1xxx_dbdma_stop(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 	int halt_timeout = 0;
 
 	ctp = *((chan_tab_t **)chanid);
@@ -666,6 +754,7 @@
 	cp->ddma_stat |= (DDMA_STAT_DB | DDMA_STAT_V);
 	au_sync();
 }
+EXPORT_SYMBOL(au1xxx_dbdma_stop);
 
 /* Start using the current descriptor pointer.  If the dbdma encounters
  * a not valid descriptor, it will stop.  In this case, we can just
@@ -675,17 +764,17 @@
 au1xxx_dbdma_start(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	ctp = *((chan_tab_t **)chanid);
-
 	cp = ctp->chan_ptr;
 	cp->ddma_desptr = virt_to_phys(ctp->cur_ptr);
 	cp->ddma_cfg |= DDMA_CFG_EN;	/* Enable channel */
 	au_sync();
-	cp->ddma_dbell = 0xffffffff;	/* Make it go */
+	cp->ddma_dbell = 0;
 	au_sync();
 }
+EXPORT_SYMBOL(au1xxx_dbdma_start);
 
 void
 au1xxx_dbdma_reset(u32 chanid)
@@ -704,15 +793,21 @@
 
 	do {
 		dp->dscr_cmd0 &= ~DSCR_CMD0_V;
+		/* reset our SW status -- this is used to determine
+		 * if a descriptor is in use by upper level SW. Since
+		 * posting can reset 'V' bit.
+		 */
+		dp->sw_status = 0;
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_reset);
 
 u32
 au1xxx_get_dma_residue(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 	u32		rv;
 
 	ctp = *((chan_tab_t **)chanid);
@@ -738,8 +833,7 @@
 
 	au1xxx_dbdma_stop(chanid);
 
-	if (ctp->chan_desc_base != NULL)
-		kfree(ctp->chan_desc_base);
+	kfree((void *)ctp->chan_desc_base);
 
 	stp->dev_flags &= ~DEV_FLAGS_INUSE;
 	dtp->dev_flags &= ~DEV_FLAGS_INUSE;
@@ -747,15 +841,16 @@
 
 	kfree(ctp);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_chan_free);
 
 static irqreturn_t
 dbdma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	u32	intstat;
-	u32	chan_index;
+	u32 intstat;
+	u32 chan_index;
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	intstat = dbdma_gptr->ddma_intstat;
 	au_sync();
@@ -774,19 +869,27 @@
 		(ctp->chan_callback)(irq, ctp->chan_callparam, regs);
 
 	ctp->cur_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
-
-	return IRQ_HANDLED;
+	return IRQ_RETVAL(1);
 }
 
-static void
-au1xxx_dbdma_init(void)
+static void au1xxx_dbdma_init(void)
 {
+	int irq_nr;
+
 	dbdma_gptr->ddma_config = 0;
 	dbdma_gptr->ddma_throttle = 0;
 	dbdma_gptr->ddma_inten = 0xffff;
 	au_sync();
 
-	if (request_irq(AU1550_DDMA_INT, dbdma_interrupt, SA_INTERRUPT,
+#if defined(CONFIG_SOC_AU1550)
+	irq_nr = AU1550_DDMA_INT;
+#elif defined(CONFIG_SOC_AU1200)
+	irq_nr = AU1200_DDMA_INT;
+#else
+	#error Unknown Au1x00 SOC
+#endif
+
+	if (request_irq(irq_nr, dbdma_interrupt, SA_INTERRUPT,
 			"Au1xxx dbdma", (void *)dbdma_gptr))
 		printk("Can't get 1550 dbdma irq");
 }
@@ -797,7 +900,8 @@
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
 	dbdev_tab_t		*stp, *dtp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
+		u32			i = 0;
 
 	ctp = *((chan_tab_t **)chanid);
 	stp = ctp->chan_src;
@@ -822,15 +926,64 @@
 	dp = ctp->chan_desc_base;
 
 	do {
-		printk("dp %08x, cmd0 %08x, cmd1 %08x\n",
-			(u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
-		printk("src0 %08x, src1 %08x, dest0 %08x\n",
-			dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0);
-		printk("dest1 %08x, stat %08x, nxtptr %08x\n",
-			dp->dscr_dest1, dp->dscr_stat, dp->dscr_nxtptr);
+                printk("Dp[%d]= %08x, cmd0 %08x, cmd1 %08x\n",
+                        i++, (u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
+                printk("src0 %08x, src1 %08x, dest0 %08x, dest1 %08x\n",
+                        dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1);
+                printk("stat %08x, nxtptr %08x\n",
+                        dp->dscr_stat, dp->dscr_nxtptr);
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
 
+/* Put a descriptor into the DMA ring.
+ * This updates the source/destination pointers and byte count.
+ */
+u32
+au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr )
+{
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+	u32 nbytes=0;
+
+	/* I guess we could check this to be within the
+	* range of the table......
+	*/
+	ctp = *((chan_tab_t **)chanid);
+
+	/* We should have multiple callers for a particular channel,
+	* an interrupt doesn't affect this pointer nor the descriptor,
+	* so no locking should be needed.
+	*/
+	dp = ctp->put_ptr;
+
+	/* If the descriptor is valid, we are way ahead of the DMA
+	* engine, so just return an error condition.
+	*/
+	if (dp->dscr_cmd0 & DSCR_CMD0_V)
+		return 0;
+
+	/* Load up buffer addresses and byte count.
+	*/
+	dp->dscr_dest0 = dscr->dscr_dest0;
+	dp->dscr_source0 = dscr->dscr_source0;
+	dp->dscr_dest1 = dscr->dscr_dest1;
+	dp->dscr_source1 = dscr->dscr_source1;
+	dp->dscr_cmd1 = dscr->dscr_cmd1;
+	nbytes = dscr->dscr_cmd1;
+	/* Allow the caller to specifiy if an interrupt is generated */
+	dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+	dp->dscr_cmd0 |= dscr->dscr_cmd0 | DSCR_CMD0_V;
+	ctp->chan_ptr->ddma_dbell = 0;
+
+	/* Get next descriptor pointer.
+	*/
+	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+
+	/* return something not zero.
+	*/
+	return nbytes;
+}
+
 #endif /* defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200) */
 
diff -Naur linux-2.6.14/arch/mips/au1000/common/dma.c linux-mips-2.6.14.orig/arch/mips/au1000/common/dma.c
--- linux-2.6.14/arch/mips/au1000/common/dma.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/dma.c	2005-11-17 11:42:18.000000000 -0800
@@ -39,7 +39,6 @@
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#include <linux/module.h>
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-au1x00/au1000_dma.h>
diff -Naur linux-2.6.14/arch/mips/au1000/common/gpio.c linux-mips-2.6.14.orig/arch/mips/au1000/common/gpio.c
--- linux-2.6.14/arch/mips/au1000/common/gpio.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/gpio.c	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,119 @@
+/*
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <au1000.h>
+#include <au1xxx_gpio.h>
+
+#define gpio1 sys
+#if !defined(CONFIG_SOC_AU1000)
+static AU1X00_GPIO2 * const gpio2 = (AU1X00_GPIO2 *)GPIO2_BASE;
+
+#define GPIO2_OUTPUT_ENABLE_MASK 0x00010000
+
+int au1xxx_gpio2_read(int signal)
+{
+	signal -= 200;
+/*	gpio2->dir &= ~(0x01 << signal);						//Set GPIO to input */
+	return ((gpio2->pinstate >> signal) & 0x01);
+}
+
+void au1xxx_gpio2_write(int signal, int value)
+{
+	signal -= 200;
+
+	gpio2->output = (GPIO2_OUTPUT_ENABLE_MASK << signal) |
+		(value << signal);
+}
+
+void au1xxx_gpio2_tristate(int signal)
+{
+	signal -= 200;
+	gpio2->dir &= ~(0x01 << signal); 	/* Set GPIO to input */
+}
+#endif
+
+int au1xxx_gpio1_read(int signal)
+{
+/*	gpio1->trioutclr |= (0x01 << signal); */
+	return ((gpio1->pinstaterd >> signal) & 0x01);
+}
+
+void au1xxx_gpio1_write(int signal, int value)
+{
+	if(value)
+		gpio1->outputset = (0x01 << signal);
+	else
+		gpio1->outputclr = (0x01 << signal);	/* Output a Zero */
+}
+
+void au1xxx_gpio1_tristate(int signal)
+{
+	gpio1->trioutclr = (0x01 << signal);		/* Tristate signal */
+}
+
+
+int au1xxx_gpio_read(int signal)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		return 0;
+#else
+		return au1xxx_gpio2_read(signal);
+#endif
+	else
+		return au1xxx_gpio1_read(signal);
+}
+
+void au1xxx_gpio_write(int signal, int value)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		;
+#else
+		au1xxx_gpio2_write(signal, value);
+#endif
+	else
+		au1xxx_gpio1_write(signal, value);
+}
+
+void au1xxx_gpio_tristate(int signal)
+{
+	if(signal >= 200)
+#if defined(CONFIG_SOC_AU1000)
+		;
+#else
+		au1xxx_gpio2_tristate(signal);
+#endif
+	else
+		au1xxx_gpio1_tristate(signal);
+}
+
+void au1xxx_gpio1_set_inputs(void)
+{
+	gpio1->pininputen = 0;
+}
+
+EXPORT_SYMBOL(au1xxx_gpio1_set_inputs);
+EXPORT_SYMBOL(au1xxx_gpio_tristate);
+EXPORT_SYMBOL(au1xxx_gpio_write);
+EXPORT_SYMBOL(au1xxx_gpio_read);
diff -Naur linux-2.6.14/arch/mips/au1000/common/irq.c linux-mips-2.6.14.orig/arch/mips/au1000/common/irq.c
--- linux-2.6.14/arch/mips/au1000/common/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/irq.c	2005-11-17 11:42:18.000000000 -0800
@@ -83,7 +83,7 @@
 void	(*board_init_irq)(void);
 
 #ifdef CONFIG_PM
-extern void counter0_irq(int irq, void *dev_id, struct pt_regs *regs);
+extern irqreturn_t counter0_irq(int irq, void *dev_id, struct pt_regs *regs);
 #endif
 
 static DEFINE_SPINLOCK(irq_lock);
@@ -253,52 +253,72 @@
 
 
 static struct hw_interrupt_type rise_edge_irq_type = {
-	"Au1000 Rise Edge",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_rise_edge_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Rise Edge",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_rise_edge_irq,
+	.end = end_irq,
 };
 
 static struct hw_interrupt_type fall_edge_irq_type = {
-	"Au1000 Fall Edge",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_fall_edge_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Fall Edge",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_fall_edge_irq,
+	.end = end_irq,
 };
 
 static struct hw_interrupt_type either_edge_irq_type = {
-	"Au1000 Rise or Fall Edge",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_either_edge_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Rise or Fall Edge",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_either_edge_irq,
+	.end = end_irq,
 };
 
 static struct hw_interrupt_type level_irq_type = {
-	"Au1000 Level",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_level_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Level",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_level_irq,
+	.end = end_irq,
 };
 
 #ifdef CONFIG_PM
-void startup_match20_interrupt(void)
+void startup_match20_interrupt(irqreturn_t (*handler)(int, void *, struct pt_regs *))
 {
+	struct irq_desc *desc = &irq_desc[AU1000_TOY_MATCH2_INT];
+
+	static struct irqaction action;
+	memset(&action, 0, sizeof(struct irqaction));
+
+	/* This is a big problem.... since we didn't use request_irq
+	 * when kernel/irq.c calls probe_irq_xxx this interrupt will
+	 * be probed for usage. This will end up disabling the device :(
+	 * Give it a bogus "action" pointer -- this will keep it from
+	 * getting auto-probed!
+	 *
+	 * By setting the status to match that of request_irq() we
+	 * can avoid it.  --cgray
+	*/
+	action.dev_id = handler;
+	action.flags = SA_INTERRUPT;
+	cpus_clear(action.mask);
+	action.name = "Au1xxx TOY";
+	action.handler = handler;
+	action.next = NULL;
+
+	desc->action = &action;
+	desc->status &= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING | IRQ_INPROGRESS);
+
 	local_enable_irq(AU1000_TOY_MATCH2_INT);
 }
 #endif
@@ -426,7 +446,6 @@
 	extern int au1xxx_ic0_nr_irqs;
 
 	cp0_status = read_c0_status();
-	memset(irq_desc, 0, sizeof(irq_desc));
 	set_except_vector(0, au1000_IRQ);
 
 	/* Initialize interrupt controllers to a safe state.
@@ -492,7 +511,7 @@
 	intc0_req0 |= au_readl(IC0_REQ0INT);
 
 	if (!intc0_req0) return;
-
+#ifdef AU1000_USB_DEV_REQ_INT
 	/*
 	 * Because of the tight timing of SETUP token to reply
 	 * transactions, the USB devices-side packet complete
@@ -503,7 +522,7 @@
 		do_IRQ(AU1000_USB_DEV_REQ_INT, regs);
 		return;
 	}
-
+#endif
 	irq = au_ffs(intc0_req0) - 1;
 	intc0_req0 &= ~(1<<irq);
 	do_IRQ(irq, regs);
@@ -521,17 +540,7 @@
 
 	irq = au_ffs(intc0_req1) - 1;
 	intc0_req1 &= ~(1<<irq);
-#ifdef CONFIG_PM
-	if (irq == AU1000_TOY_MATCH2_INT) {
-		mask_and_ack_rise_edge_irq(irq);
-		counter0_irq(irq, NULL, regs);
-		local_enable_irq(irq);
-	}
-	else
-#endif
-	{
-		do_IRQ(irq, regs);
-	}
+	do_IRQ(irq, regs);
 }
 
 
diff -Naur linux-2.6.14/arch/mips/au1000/common/Makefile linux-mips-2.6.14.orig/arch/mips/au1000/common/Makefile
--- linux-2.6.14/arch/mips/au1000/common/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/Makefile	2005-11-17 11:42:18.000000000 -0800
@@ -8,7 +8,7 @@
 
 obj-y += prom.o int-handler.o irq.o puts.o time.o reset.o \
 	au1xxx_irqmap.o clocks.o platform.o power.o setup.o \
-	sleeper.o cputable.o dma.o dbdma.o
+	sleeper.o cputable.o dma.o dbdma.o gpio.o
 
 obj-$(CONFIG_AU1X00_USB_DEVICE)	+= usbdev.o
 obj-$(CONFIG_KGDB)		+= dbg_io.o
diff -Naur linux-2.6.14/arch/mips/au1000/common/platform.c linux-mips-2.6.14.orig/arch/mips/au1000/common/platform.c
--- linux-2.6.14/arch/mips/au1000/common/platform.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/platform.c	2005-11-17 11:42:18.000000000 -0800
@@ -7,13 +7,15 @@
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
+#include <linux/config.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/resource.h>
 
-#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx.h>
 
+/* OHCI (USB full speed host controller) */
 static struct resource au1xxx_usb_ohci_resources[] = {
 	[0] = {
 		.start		= USB_OHCI_BASE,
@@ -41,8 +43,252 @@
 	.resource	= au1xxx_usb_ohci_resources,
 };
 
+/*** AU1100 LCD controller ***/
+
+#ifdef CONFIG_FB_AU1100
+static struct resource au1100_lcd_resources[] = {
+	[0] = {
+		.start          = LCD_PHYS_ADDR,
+		.end            = LCD_PHYS_ADDR + 0x800 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = AU1100_LCD_INT,
+		.end            = AU1100_LCD_INT,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 au1100_lcd_dmamask = ~(u32)0;
+
+static struct platform_device au1100_lcd_device = {
+	.name           = "au1100-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &au1100_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(au1100_lcd_resources),
+	.resource       = au1100_lcd_resources,
+};
+#endif
+
+#ifdef CONFIG_SOC_AU1200
+/* EHCI (USB high speed host controller) */
+static struct resource au1xxx_usb_ehci_resources[] = {
+	[0] = {
+		.start		= USB_EHCI_BASE,
+		.end		= USB_EHCI_BASE + USB_EHCI_LEN - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1000_USB_HOST_INT,
+		.end		= AU1000_USB_HOST_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+
+static struct platform_device au1xxx_usb_ehci_device = {
+	.name		= "au1xxx-ehci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(au1xxx_usb_ehci_resources),
+	.resource	= au1xxx_usb_ehci_resources,
+};
+
+/* Au1200 UDC (USB gadget controller) */
+static struct resource au1xxx_usb_gdt_resources[] = {
+	[0] = {
+		.start		= USB_UDC_BASE,
+		.end		= USB_UDC_BASE + USB_UDC_LEN - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1200_USB_INT,
+		.end		= AU1200_USB_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource au1xxx_mmc_resources[] = {
+	[0] = {
+		.start          = SD0_PHYS_ADDR,
+		.end            = SD0_PHYS_ADDR + 0x40,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= SD1_PHYS_ADDR,
+		.end 		= SD1_PHYS_ADDR + 0x40,
+		.flags		= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start          = AU1200_SD_INT,
+		.end            = AU1200_SD_INT,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device au1xxx_usb_gdt_device = {
+	.name		= "au1xxx-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(au1xxx_usb_gdt_resources),
+	.resource	= au1xxx_usb_gdt_resources,
+};
+
+/* Au1200 UOC (USB OTG controller) */
+static struct resource au1xxx_usb_otg_resources[] = {
+	[0] = {
+		.start		= USB_UOC_BASE,
+		.end		= USB_UOC_BASE + USB_UOC_LEN - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1200_USB_INT,
+		.end		= AU1200_USB_INT,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 uoc_dmamask = ~(u32)0;
+
+static struct platform_device au1xxx_usb_otg_device = {
+	.name		= "au1xxx-uoc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &uoc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(au1xxx_usb_otg_resources),
+	.resource	= au1xxx_usb_otg_resources,
+};
+
+static struct resource au1200_lcd_resources[] = {
+	[0] = {
+		.start          = LCD_PHYS_ADDR,
+		.end            = LCD_PHYS_ADDR + 0x800 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = AU1200_LCD_INT,
+		.end            = AU1200_LCD_INT,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static struct resource au1200_ide0_resources[] = {
+	[0] = {
+		.start		= AU1XXX_ATA_PHYS_ADDR,
+		.end 		= AU1XXX_ATA_PHYS_ADDR + AU1XXX_ATA_PHYS_LEN,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= AU1XXX_ATA_INT,
+		.end		= AU1XXX_ATA_INT,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static u64 au1200_lcd_dmamask = ~(u32)0;
+
+static struct platform_device au1200_lcd_device = {
+	.name           = "au1200-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &au1200_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(au1200_lcd_resources),
+	.resource       = au1200_lcd_resources,
+};
+
+
+static u64 ide0_dmamask = ~(u32)0;
+
+static struct platform_device au1200_ide0_device = {
+	.name		= "au1200-ide",
+	.id		= 0,
+	.dev = {
+		.dma_mask 		= &ide0_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources = ARRAY_SIZE(au1200_ide0_resources),
+	.resource	= au1200_ide0_resources,
+};
+
+static u64 au1xxx_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device au1xxx_mmc_device = {
+	.name = "au1xxx-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &au1xxx_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(au1xxx_mmc_resources),
+	.resource       = au1xxx_mmc_resources,
+};
+#endif /* #ifdef CONFIG_SOC_AU1200 */
+
+static struct platform_device au1x00_pcmcia_device = {
+	.name 		= "au1x00-pcmcia",
+	.id 		= 0,
+};
+
+#ifdef CONFIG_MIPS_DB1200
+
+static struct resource smc91x_resources[] = {
+	[0] = {
+		.name	= "smc91x-regs",
+		.start	= AU1XXX_SMC91111_PHYS_ADDR,
+		.end	= AU1XXX_SMC91111_PHYS_ADDR + 0xfffff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AU1XXX_SMC91111_IRQ,
+		.end	= AU1XXX_SMC91111_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smc91x_device = {
+	.name		= "smc91x",
+ 	.id		= -1,
+	.num_resources	= ARRAY_SIZE(smc91x_resources),
+	.resource	= smc91x_resources,
+};
+
+#endif
+
 static struct platform_device *au1xxx_platform_devices[] __initdata = {
 	&au1xxx_usb_ohci_device,
+	&au1x00_pcmcia_device,
+#ifdef CONFIG_FB_AU1100
+	&au1100_lcd_device,
+#endif
+#ifdef CONFIG_SOC_AU1200
+#if 0	/* fixme */
+	&au1xxx_usb_ehci_device,
+#endif
+	&au1xxx_usb_gdt_device,
+	&au1xxx_usb_otg_device,
+	&au1200_lcd_device,
+	&au1200_ide0_device,
+	&au1xxx_mmc_device,
+#endif
+#ifdef CONFIG_MIPS_DB1200
+ 	&smc91x_device,
+#endif
 };
 
 int au1xxx_platform_init(void)
diff -Naur linux-2.6.14/arch/mips/au1000/common/power.c linux-mips-2.6.14.orig/arch/mips/au1000/common/power.c
--- linux-2.6.14/arch/mips/au1000/common/power.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/power.c	2005-11-17 11:42:18.000000000 -0800
@@ -34,11 +34,13 @@
 #include <linux/pm.h>
 #include <linux/slab.h>
 #include <linux/sysctl.h>
+#include <linux/jiffies.h>
 
 #include <asm/string.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/system.h>
+#include <asm/cacheflush.h>
 #include <asm/mach-au1x00/au1000.h>
 
 #ifdef CONFIG_PM
@@ -50,7 +52,7 @@
 #  define DPRINTK(fmt, args...)
 #endif
 
-static void calibrate_delay(void);
+static void au1000_calibrate_delay(void);
 
 extern void set_au1x00_speed(unsigned int new_freq);
 extern unsigned int get_au1x00_speed(void);
@@ -260,7 +262,7 @@
 }
 
 static int pm_do_sleep(ctl_table * ctl, int write, struct file *file,
-		       void *buffer, size_t * len)
+		       void __user *buffer, size_t * len, loff_t *ppos)
 {
 	int retval = 0;
 #ifdef SLEEP_TEST_TIMEOUT
@@ -294,10 +296,9 @@
 }
 
 static int pm_do_suspend(ctl_table * ctl, int write, struct file *file,
-			 void *buffer, size_t * len)
+			 void __user *buffer, size_t * len, loff_t *ppos)
 {
 	int retval = 0;
-	void	au1k_wait(void);
 
 	if (!write) {
 		*len = 0;
@@ -306,7 +307,7 @@
 		if (retval)
 			return retval;
 		suspend_mode = 1;
-		au1k_wait();
+
 		retval = pm_send_all(PM_RESUME, (void *) 0);
 	}
 	return retval;
@@ -314,7 +315,7 @@
 
 
 static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
-		      void *buffer, size_t * len)
+		      void __user *buffer, size_t * len, loff_t *ppos)
 {
 	int retval = 0, i;
 	unsigned long val, pll;
@@ -409,14 +410,14 @@
 
 
 	/* We don't want _any_ interrupts other than
-	 * match20. Otherwise our calibrate_delay()
+	 * match20. Otherwise our au1000_calibrate_delay()
 	 * calculation will be off, potentially a lot.
 	 */
 	intc0_mask = save_local_and_disable(0);
 	intc1_mask = save_local_and_disable(1);
 	local_enable_irq(AU1000_TOY_MATCH2_INT);
 	spin_unlock_irqrestore(&pm_lock, flags);
-	calibrate_delay();
+	au1000_calibrate_delay();
 	restore_local_and_enable(0, intc0_mask);
 	restore_local_and_enable(1, intc1_mask);
 	return retval;
@@ -456,7 +457,7 @@
    better than 1% */
 #define LPS_PREC 8
 
-static void calibrate_delay(void)
+static void au1000_calibrate_delay(void)
 {
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
diff -Naur linux-2.6.14/arch/mips/au1000/common/prom.c linux-mips-2.6.14.orig/arch/mips/au1000/common/prom.c
--- linux-2.6.14/arch/mips/au1000/common/prom.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/prom.c	2005-11-17 11:42:18.000000000 -0800
@@ -75,7 +75,8 @@
 	}
 	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
 		--cp;
-	*cp = '\0';
+	if (prom_argc > 1)
+		*cp = '\0';
 
 }
 
diff -Naur linux-2.6.14/arch/mips/au1000/common/puts.c linux-mips-2.6.14.orig/arch/mips/au1000/common/puts.c
--- linux-2.6.14/arch/mips/au1000/common/puts.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/puts.c	2005-11-17 11:42:18.000000000 -0800
@@ -39,7 +39,6 @@
 #define TIMEOUT       0xffffff
 #define SLOW_DOWN
 
-static const char digits[16] = "0123456789abcdef";
 static volatile unsigned long * const com1 = (unsigned long *)SERIAL_BASE;
 
 
@@ -54,7 +53,7 @@
 #endif
 
 void
-putch(const unsigned char c)
+prom_putchar(const unsigned char c)
 {
     unsigned char ch;
     int i = 0;
@@ -69,77 +68,3 @@
     } while (0 == (ch & TX_BUSY));
     com1[SER_DATA] = c;
 }
-
-void
-puts(unsigned char *cp)
-{
-    unsigned char ch;
-    int i = 0;
-
-    while (*cp) {
-        do {
-             ch = com1[SER_CMD];
-            slow_down();
-            i++;
-            if (i>TIMEOUT) {
-                break;
-            }
-        } while (0 == (ch & TX_BUSY));
-        com1[SER_DATA] = *cp++;
-    }
-    putch('\r');
-    putch('\n');
-}
-
-void
-fputs(const char *cp)
-{
-    unsigned char ch;
-    int i = 0;
-
-    while (*cp) {
-
-        do {
-             ch = com1[SER_CMD];
-             slow_down();
-            i++;
-            if (i>TIMEOUT) {
-                break;
-            }
-        } while (0 == (ch & TX_BUSY));
-        com1[SER_DATA] = *cp++;
-    }
-}
-
-
-void
-put64(uint64_t ul)
-{
-    int cnt;
-    unsigned ch;
-
-    cnt = 16;            /* 16 nibbles in a 64 bit long */
-    putch('0');
-    putch('x');
-    do {
-        cnt--;
-        ch = (unsigned char)(ul >> cnt * 4) & 0x0F;
-                putch(digits[ch]);
-    } while (cnt > 0);
-}
-
-void
-put32(unsigned u)
-{
-    int cnt;
-    unsigned ch;
-
-    cnt = 8;            /* 8 nibbles in a 32 bit long */
-    putch('0');
-    putch('x');
-    do {
-        cnt--;
-        ch = (unsigned char)(u >> cnt * 4) & 0x0F;
-                putch(digits[ch]);
-    } while (cnt > 0);
-}
diff -Naur linux-2.6.14/arch/mips/au1000/common/setup.c linux-mips-2.6.14.orig/arch/mips/au1000/common/setup.c
--- linux-2.6.14/arch/mips/au1000/common/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/setup.c	2005-11-17 11:42:18.000000000 -0800
@@ -32,6 +32,7 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/module.h>
 
 #include <asm/cpu.h>
 #include <asm/bootinfo.h>
@@ -57,7 +58,7 @@
 extern void au1xxx_timer_setup(struct irqaction *irq);
 extern void set_cpuspec(void);
 
-static int __init au1x00_setup(void)
+void __init plat_setup(void)
 {
 	struct	cpu_spec *sp;
 	char *argptr;
@@ -106,8 +107,6 @@
         /*strcat(argptr, " video=au1100fb:panel:Sharp_320x240_16");*/
 #ifdef CONFIG_MIPS_HYDROGEN3
          strcat(argptr, " video=au1100fb:panel:Hydrogen_3_NEC_panel_320x240,nohwcursor");
-#else
-        strcat(argptr, " video=au1100fb:panel:s10,nohwcursor");
 #endif
     }
 #endif
@@ -153,15 +152,11 @@
 	au_sync();
 	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T0S);
 	au_writel(0, SYS_TOYTRIM);
-
-	return 0;
 }
 
-early_initcall(au1x00_setup);
-
 #if defined(CONFIG_64BIT_PHYS_ADDR)
 /* This routine should be valid for all Au1x based boards */
-phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 {
 	u32 start, end;
 
@@ -192,4 +187,5 @@
 	/* default nop */
 	return phys_addr;
 }
+EXPORT_SYMBOL(__fixup_bigphys_addr);
 #endif
diff -Naur linux-2.6.14/arch/mips/au1000/common/time.c linux-mips-2.6.14.orig/arch/mips/au1000/common/time.c
--- linux-2.6.14/arch/mips/au1000/common/time.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/time.c	2005-11-17 11:42:18.000000000 -0800
@@ -50,7 +50,6 @@
 #include <linux/mc146818rtc.h>
 #include <linux/timex.h>
 
-extern void startup_match20_interrupt(void);
 extern void do_softirq(void);
 extern volatile unsigned long wall_jiffies;
 unsigned long missed_heart_beats = 0;
@@ -58,14 +57,17 @@
 static unsigned long r4k_offset; /* Amount to increment compare reg each time */
 static unsigned long r4k_cur;    /* What counter should be at next timer irq */
 int	no_au1xxx_32khz;
-void	(*au1k_wait_ptr)(void);
+extern int allow_au1k_wait; /* default off for CP0 Counter */
 
 /* Cycle counter value at the previous timer interrupt.. */
 static unsigned int timerhi = 0, timerlo = 0;
 
 #ifdef CONFIG_PM
-#define MATCH20_INC 328
-extern void startup_match20_interrupt(void);
+#if HZ < 100 || HZ > 1000
+#error "unsupported HZ value! Must be in [100,1000]"
+#endif
+#define MATCH20_INC (328*100/HZ) /* magic number 328 is for HZ=100... */
+extern void startup_match20_interrupt(irqreturn_t (*handler)(int, void *, struct pt_regs *));
 static unsigned long last_pc0, last_match20;
 #endif
 
@@ -117,17 +119,16 @@
 }
 
 #ifdef CONFIG_PM
-void counter0_irq(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t counter0_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
 	unsigned long pc0;
 	int time_elapsed;
 	static int jiffie_drift = 0;
 
-	kstat.irqs[0][irq]++;
 	if (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20) {
 		/* should never happen! */
-		printk(KERN_WARNING "counter 0 w status eror\n");
-		return;
+		printk(KERN_WARNING "counter 0 w status error\n");
+		return IRQ_NONE;
 	}
 
 	pc0 = au_readl(SYS_TOYREAD);
@@ -164,6 +165,8 @@
 		update_process_times(user_mode(regs));
 #endif
 	}
+
+	return IRQ_HANDLED;
 }
 
 /* When we wakeup from sleep, we have to "catch up" on all of the
@@ -388,7 +391,6 @@
 {
         unsigned int est_freq;
 	extern unsigned long (*do_gettimeoffset)(void);
-	extern void au1k_wait(void);
 
 	printk("calculating r4koff... ");
 	r4k_offset = cal_r4koff();
@@ -441,18 +443,18 @@
 		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
 
-		/* setup match20 to interrupt once every 10ms */
+		/* setup match20 to interrupt once every HZ */
 		last_pc0 = last_match20 = au_readl(SYS_TOYREAD);
 		au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
 		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
-		startup_match20_interrupt();
+		startup_match20_interrupt(counter0_irq);
 
 		do_gettimeoffset = do_fast_pm_gettimeoffset;
 
 		/* We can use the real 'wait' instruction.
 		*/
-		au1k_wait_ptr = au1k_wait;
+		allow_au1k_wait = 1;
 	}
 
 #else
diff -Naur linux-2.6.14/arch/mips/au1000/common/usbdev.c linux-mips-2.6.14.orig/arch/mips/au1000/common/usbdev.c
--- linux-2.6.14/arch/mips/au1000/common/usbdev.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/common/usbdev.c	2005-11-17 11:42:18.000000000 -0800
@@ -1005,11 +1005,11 @@
 #endif
 		dev->ep0_stage = SETUP_STAGE;
 		break;
-		}
+	}
 
 	spin_unlock(&ep0->lock);
-		// we're done processing the packet, free it
-		kfree(pkt);
+	// we're done processing the packet, free it
+	kfree(pkt);
 }
 
 
@@ -1072,8 +1072,7 @@
 			clear_dma_done1(ep0->indma);
 
 		pkt = send_packet_complete(ep0);
-		if (pkt)
-			kfree(pkt);
+		kfree(pkt);
 	}
 
 	/*
@@ -1302,8 +1301,7 @@
 		endpoint_flush(ep);
 	}
 
-	if (usbdev.full_conf_desc)
-		kfree(usbdev.full_conf_desc);
+	kfree(usbdev.full_conf_desc);
 }
 
 int
diff -Naur linux-2.6.14/arch/mips/au1000/csb250/init.c linux-mips-2.6.14.orig/arch/mips/au1000/csb250/init.c
--- linux-2.6.14/arch/mips/au1000/csb250/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/csb250/init.c	2005-11-17 11:42:18.000000000 -0800
@@ -35,7 +35,6 @@
 #include <asm/bootinfo.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 
 int prom_argc;
 char **prom_argv, **prom_envp;
diff -Naur linux-2.6.14/arch/mips/au1000/db1x00/irqmap.c linux-mips-2.6.14.orig/arch/mips/au1000/db1x00/irqmap.c
--- linux-2.6.14/arch/mips/au1000/db1x00/irqmap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/db1x00/irqmap.c	2005-11-17 11:42:18.000000000 -0800
@@ -48,6 +48,38 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+#ifdef CONFIG_MIPS_DB1500
+char irq_tab_alchemy[][5] __initdata = {
+ [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT371   */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+};
+#endif
+
+#ifdef CONFIG_MIPS_BOSPORUS
+char irq_tab_alchemy[][5] __initdata = {
+ [11] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 11 - miniPCI  */
+ [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - SN1741   */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+};
+#endif
+
+#ifdef CONFIG_MIPS_MIRAGE
+char irq_tab_alchemy[][5] __initdata = {
+ [11] =	{ -1, INTD, INTX, INTX, INTX},   /* IDSEL 11 - SMI VGX */
+ [12] =	{ -1, INTX, INTX, INTC, INTX},   /* IDSEL 12 - PNX1300 */
+ [13] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 13 - miniPCI */
+};
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+char irq_tab_alchemy[][5] __initdata = {
+ [11] =	{ -1, INTC, INTX, INTX, INTX},   /* IDSEL 11 - on-board HPT371    */
+ [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+};
+#endif
+
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 
 #ifndef CONFIG_MIPS_MIRAGE
diff -Naur linux-2.6.14/arch/mips/au1000/db1x00/mirage_ts.c linux-mips-2.6.14.orig/arch/mips/au1000/db1x00/mirage_ts.c
--- linux-2.6.14/arch/mips/au1000/db1x00/mirage_ts.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/db1x00/mirage_ts.c	2005-11-17 11:42:18.000000000 -0800
@@ -102,15 +102,15 @@
 } mirage_ts_cal =
 {
 #if 0
-	xscale:   84,
-	xtrans: -157,
-	yscale:   66,
-	ytrans: -150,
+	.xscale   = 84,
+	.xtrans = -157,
+	.yscale   = 66,
+	.ytrans = -150,
 #else
-	xscale:   84,
-	xtrans: -150,
-	yscale:   66,
-	ytrans: -146,
+	.xscale   = 84,
+	.xtrans = -150,
+	.yscale   = 66,
+	.ytrans = -146,
 #endif
 };
 
diff -Naur linux-2.6.14/arch/mips/au1000/hydrogen3/init.c linux-mips-2.6.14.orig/arch/mips/au1000/hydrogen3/init.c
--- linux-2.6.14/arch/mips/au1000/hydrogen3/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/hydrogen3/init.c	2005-11-17 11:42:18.000000000 -0800
@@ -37,7 +37,6 @@
 #include <linux/config.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 
 int prom_argc;
 char **prom_argv, **prom_envp;
diff -Naur linux-2.6.14/arch/mips/au1000/mtx-1/init.c linux-mips-2.6.14.orig/arch/mips/au1000/mtx-1/init.c
--- linux-2.6.14/arch/mips/au1000/mtx-1/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/mtx-1/init.c	2005-11-17 11:42:18.000000000 -0800
@@ -33,7 +33,6 @@
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/mm.h>
-#include <linux/sched.h>
 #include <linux/bootmem.h>
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
diff -Naur linux-2.6.14/arch/mips/au1000/mtx-1/irqmap.c linux-mips-2.6.14.orig/arch/mips/au1000/mtx-1/irqmap.c
--- linux-2.6.14/arch/mips/au1000/mtx-1/irqmap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/mtx-1/irqmap.c	2005-11-17 11:42:18.000000000 -0800
@@ -47,6 +47,17 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+char irq_tab_alchemy[][5] __initdata = {
+ [0] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 00 - AdapterA-Slot0 (top)    */
+ [1] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 01 - AdapterA-Slot1 (bottom) */
+ [2] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 02 - AdapterB-Slot0 (top)    */
+ [3] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 03 - AdapterB-Slot1 (bottom) */
+ [4] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 04 - AdapterC-Slot0 (top)    */
+ [5] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 05 - AdapterC-Slot1 (bottom) */
+ [6] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 06 - AdapterD-Slot0 (top)    */
+ [7] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 07 - AdapterD-Slot1 (bottom) */
+};
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
        { AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
        { AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
diff -Naur linux-2.6.14/arch/mips/au1000/pb1000/init.c linux-mips-2.6.14.orig/arch/mips/au1000/pb1000/init.c
--- linux-2.6.14/arch/mips/au1000/pb1000/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1000/init.c	2005-11-17 11:42:18.000000000 -0800
@@ -65,5 +65,4 @@
 		memsize = simple_strtol(memsize_str, NULL, 0);
 	}
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
-	return 0;
 }
diff -Naur linux-2.6.14/arch/mips/au1000/pb1200/board_setup.c linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/board_setup.c
--- linux-2.6.14/arch/mips/au1000/pb1200/board_setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/board_setup.c	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,193 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Alchemy Pb1200/Db1200 board setup.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+#include <linux/ide.h>
+#endif
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/mach-pb1x00/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/mach-db1x00/db1200.h>
+#define PB1200_ETH_INT DB1200_ETH_INT
+#define PB1200_IDE_INT DB1200_IDE_INT
+#endif
+
+extern void _board_init_irq(void);
+extern void	(*board_init_irq)(void);
+
+void board_reset (void)
+{
+	bcsr->resets = 0;
+	bcsr->system = 0;
+}
+
+void __init board_setup(void)
+{
+	char *argptr = NULL;
+	u32 pin_func;
+
+#if 0
+	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	 * but it is board specific code, so put it here.
+	 */
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
+	au_writel(pin_func, SYS_PINFUNC);
+
+	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_sync();
+#endif
+
+#if defined(CONFIG_I2C_AU1550)
+	{
+	u32 freq0, clksrc;
+
+	/* Select SMBUS in CPLD */
+	bcsr->resets &= ~(BCSR_RESETS_PCS0MUX);
+
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func &= ~(3<<17 | 1<<4);
+	/* Set GPIOs correctly */
+	pin_func |= 2<<17;
+	au_writel(pin_func, SYS_PINFUNC);
+	au_sync();
+
+	/* The i2c driver depends on 50Mhz clock */
+	freq0 = au_readl(SYS_FREQCTRL0);
+	au_sync();
+	freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
+	freq0 |= (3<<SYS_FC_FRDIV1_BIT);
+	/* 396Mhz / (3+1)*2 == 49.5Mhz */
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+	freq0 |= SYS_FC_FE1;
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+
+	clksrc = au_readl(SYS_CLKSRC);
+	au_sync();
+	clksrc &= ~0x01f00000;
+	/* bit 22 is EXTCLK0 for PSC0 */
+	clksrc |= (0x3 << 22);
+	au_writel(clksrc, SYS_CLKSRC);
+	au_sync();
+	}
+#endif
+
+#ifdef CONFIG_FB_AU1200
+	argptr = prom_getcmdline();
+#ifdef CONFIG_MIPS_PB1200
+	strcat(argptr, " video=au1200fb:panel:bs");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	strcat(argptr, " video=au1200fb:panel:bs");
+#endif
+#endif
+
+	/* The Pb1200 development board uses external MUX for PSC0 to
+	support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
+	*/
+#if defined(CONFIG_AU1XXX_PSC_SPI) && defined(CONFIG_I2C_AU1550)
+	#error I2C and SPI are mutually exclusive. Both are physically connected to PSC0.\
+			Refer to Pb1200/Db1200 documentation.
+#elif defined( CONFIG_AU1XXX_PSC_SPI )
+	bcsr->resets |= BCSR_RESETS_PCS0MUX;
+	/*Hard Coding Value to enable Temp Sensors [bit 14] Value for SOC Au1200. Pls refer documentation*/
+	  bcsr->resets =0x900f;
+#elif defined( CONFIG_I2C_AU1550 )
+	bcsr->resets &= (~BCSR_RESETS_PCS0MUX);
+#endif
+	au_sync();
+
+#ifdef CONFIG_MIPS_PB1200
+	printk("AMD Alchemy Pb1200 Board\n");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	printk("AMD Alchemy Db1200 Board\n");
+#endif
+
+	/* Setup Pb1200 External Interrupt Controller */
+	{
+		extern void (*board_init_irq)(void);
+		extern void _board_init_irq(void);
+		board_init_irq = _board_init_irq;
+	}
+}
+
+int
+board_au1200fb_panel (void)
+{
+	BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	int p;
+
+	p = bcsr->switches;
+	p >>= 8;
+	p &= 0x0F;
+	return p;
+}
+
+int
+board_au1200fb_panel_init (void)
+{
+	/* Apply power */
+    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	bcsr->board |= (BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
+	/*printk("board_au1200fb_panel_init()\n"); */
+	return 0;
+}
+
+int
+board_au1200fb_panel_shutdown (void)
+{
+	/* Remove power */
+    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+	bcsr->board &= ~(BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
+	/*printk("board_au1200fb_panel_shutdown()\n"); */
+	return 0;
+}
+
diff -Naur linux-2.6.14/arch/mips/au1000/pb1200/init.c linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/init.c
--- linux-2.6.14/arch/mips/au1000/pb1200/init.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/init.c	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,69 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	PB1200 board setup
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "Alchemy Pb1200";
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machgroup = MACH_GROUP_ALCHEMY;
+	mips_machtype = MACH_PB1200;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x08000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
diff -Naur linux-2.6.14/arch/mips/au1000/pb1200/irqmap.c linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/irqmap.c
--- linux-2.6.14/arch/mips/au1000/pb1200/irqmap.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/irqmap.c	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,182 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx irq map table
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/mach-au1x00/au1000.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/mach-pb1x00/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/mach-db1x00/db1200.h>
+#define PB1200_INT_BEGIN DB1200_INT_BEGIN
+#define PB1200_INT_END DB1200_INT_END
+#endif
+
+au1xxx_irq_map_t au1xxx_irq_map[] = {
+	{ AU1000_GPIO_7, INTC_INT_LOW_LEVEL, 0 }, // This is exteranl interrupt cascade
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+/*
+ *	Support for External interrupts on the PbAu1200 Development platform.
+ */
+static volatile int pb1200_cascade_en=0;
+
+irqreturn_t pb1200_cascade_handler( int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned short bisr = bcsr->int_status;
+	int extirq_nr = 0;
+
+	/* Clear all the edge interrupts. This has no effect on level */
+	bcsr->int_status = bisr;
+	for( ; bisr; bisr &= (bisr-1) )
+	{
+		extirq_nr = (PB1200_INT_BEGIN-1) + au_ffs(bisr);
+		/* Ack and dispatch IRQ */
+		do_IRQ(extirq_nr,regs);
+	}
+	return IRQ_RETVAL(1);
+}
+
+inline void pb1200_enable_irq(unsigned int irq_nr)
+{
+	bcsr->intset_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intset = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+inline void pb1200_disable_irq(unsigned int irq_nr)
+{
+	bcsr->intclr_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intclr = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+static unsigned int pb1200_startup_irq( unsigned int irq_nr )
+{
+	if (++pb1200_cascade_en == 1)
+	{
+		request_irq(AU1000_GPIO_7, &pb1200_cascade_handler,
+			0, "Pb1200 Cascade", (void *)&pb1200_cascade_handler );
+#ifdef CONFIG_MIPS_PB1200
+    /* We have a problem with CPLD rev3. Enable a workaround */
+	if( ((bcsr->whoami & BCSR_WHOAMI_CPLD)>>4) <= 3)
+	{
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("Pb1200 must be at CPLD rev4. Please have Pb1200\n");
+		printk("updated to latest revision. This software will not\n");
+		printk("work on anything less than CPLD rev4\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		while(1);
+	}
+#endif
+	}
+	pb1200_enable_irq(irq_nr);
+	return 0;
+}
+
+static void pb1200_shutdown_irq( unsigned int irq_nr )
+{
+	pb1200_disable_irq(irq_nr);
+	if (--pb1200_cascade_en == 0)
+	{
+		free_irq(AU1000_GPIO_7,&pb1200_cascade_handler );
+	}
+	return;
+}
+
+static inline void pb1200_mask_and_ack_irq(unsigned int irq_nr)
+{
+	pb1200_disable_irq( irq_nr );
+}
+
+static void pb1200_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		pb1200_enable_irq(irq_nr);
+	}
+}
+
+static struct hw_interrupt_type external_irq_type =
+{
+#ifdef CONFIG_MIPS_PB1200
+	"Pb1200 Ext",
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	"Db1200 Ext",
+#endif
+	pb1200_startup_irq,
+	pb1200_shutdown_irq,
+	pb1200_enable_irq,
+	pb1200_disable_irq,
+	pb1200_mask_and_ack_irq,
+	pb1200_end_irq,
+	NULL
+};
+
+void _board_init_irq(void)
+{
+	int irq_nr;
+
+	for (irq_nr = PB1200_INT_BEGIN; irq_nr <= PB1200_INT_END; irq_nr++)
+	{
+		irq_desc[irq_nr].handler = &external_irq_type;
+		pb1200_disable_irq(irq_nr);
+	}
+
+	/* GPIO_7 can not be hooked here, so it is hooked upon first
+	request of any source attached to the cascade */
+}
+
diff -Naur linux-2.6.14/arch/mips/au1000/pb1200/Makefile linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/Makefile
--- linux-2.6.14/arch/mips/au1000/pb1200/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1200/Makefile	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,5 @@
+#
+# Makefile for the Alchemy Semiconductor PB1200 board.
+#
+
+lib-y := init.o board_setup.o irqmap.o
diff -Naur linux-2.6.14/arch/mips/au1000/pb1500/irqmap.c linux-mips-2.6.14.orig/arch/mips/au1000/pb1500/irqmap.c
--- linux-2.6.14/arch/mips/au1000/pb1500/irqmap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1500/irqmap.c	2005-11-17 11:42:18.000000000 -0800
@@ -47,6 +47,11 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+char irq_tab_alchemy[][5] __initdata = {
+ [12] = { -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT370   */
+ [13] = { -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+};
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
diff -Naur linux-2.6.14/arch/mips/au1000/pb1550/irqmap.c linux-mips-2.6.14.orig/arch/mips/au1000/pb1550/irqmap.c
--- linux-2.6.14/arch/mips/au1000/pb1550/irqmap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/au1000/pb1550/irqmap.c	2005-11-17 11:42:18.000000000 -0800
@@ -47,6 +47,11 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+char irq_tab_alchemy[][5] __initdata = {
+ [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+};
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 },
diff -Naur linux-2.6.14/arch/mips/boot/Makefile linux-mips-2.6.14.orig/arch/mips/boot/Makefile
--- linux-2.6.14/arch/mips/boot/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/boot/Makefile	2005-11-17 11:42:18.000000000 -0800
@@ -33,6 +33,9 @@
 $(obj)/elf2ecoff: $(obj)/elf2ecoff.c
 	$(HOSTCC) -o $@ $^
 
+vmlinux.bin: $(VMLINUX)
+	$(OBJCOPY) -O binary $(strip-flags) $(VMLINUX) $(obj)/vmlinux.bin
+
 vmlinux.srec: $(VMLINUX)
 	$(OBJCOPY) -S -O srec $(strip-flags) $(VMLINUX) $(obj)/vmlinux.srec
 
@@ -45,5 +48,6 @@
 
 clean-files += addinitrd \
 	       elf2ecoff \
+	       vmlinux.bin \
 	       vmlinux.ecoff \
 	       vmlinux.srec
diff -Naur linux-2.6.14/arch/mips/cobalt/int-handler.S linux-mips-2.6.14.orig/arch/mips/cobalt/int-handler.S
--- linux-2.6.14/arch/mips/cobalt/int-handler.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/cobalt/int-handler.S	2005-11-17 11:42:18.000000000 -0800
@@ -18,8 +18,8 @@
 		SAVE_ALL
 		CLI
 
-		la	ra, ret_from_irq
-		move	a1, sp
+		PTR_LA	ra, ret_from_irq
+		move	a0, sp
 		j	cobalt_irq
 
 		END(cobalt_handle_int)
diff -Naur linux-2.6.14/arch/mips/cobalt/irq.c linux-mips-2.6.14.orig/arch/mips/cobalt/irq.c
--- linux-2.6.14/arch/mips/cobalt/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/cobalt/irq.c	2005-11-17 11:42:18.000000000 -0800
@@ -10,6 +10,8 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
 
 #include <asm/i8259.h>
 #include <asm/irq_cpu.h>
@@ -25,8 +27,8 @@
  * the CPU interrupt lines, and ones that come in on the via chip. The CPU
  * mappings are:
  *
- *    16,  - Software interrupt 0 (unused)	IE_SW0
- *    17   - Software interrupt 1 (unused)	IE_SW0
+ *    16   - Software interrupt 0 (unused)	IE_SW0
+ *    17   - Software interrupt 1 (unused)	IE_SW1
  *    18   - Galileo chip (timer)		IE_IRQ0
  *    19   - Tulip 0 + NCR SCSI			IE_IRQ1
  *    20   - Tulip 1				IE_IRQ2
@@ -42,61 +44,94 @@
  *    15  - IDE1
  */
 
-asmlinkage void cobalt_irq(struct pt_regs *regs)
+static inline void galileo_irq(struct pt_regs *regs)
 {
-	unsigned int pending = read_c0_status() & read_c0_cause();
+	unsigned int mask, pending, devfn;
 
-	if (pending & CAUSEF_IP2) {			/* int 18 */
-		unsigned long irq_src = GALILEO_INL(GT_INTRCAUSE_OFS);
+	mask = GALILEO_INL(GT_INTRMASK_OFS);
+	pending = GALILEO_INL(GT_INTRCAUSE_OFS) & mask;
 
-		/* Check for timer irq ... */
-		if (irq_src & GALILEO_T0EXP) {
-			/* Clear the int line */
-			GALILEO_OUTL(0, GT_INTRCAUSE_OFS);
-			do_IRQ(COBALT_TIMER_IRQ, regs);
-		}
-		return;
-	}
+	if (pending & GALILEO_INTR_T0EXP) {
 
-	if (pending & CAUSEF_IP6) {			/* int 22 */
-		int irq = i8259_irq();
+		GALILEO_OUTL(~GALILEO_INTR_T0EXP, GT_INTRCAUSE_OFS);
+		do_IRQ(COBALT_GALILEO_IRQ, regs);
 
-		if (irq >= 0)
-			do_IRQ(irq, regs);
-		return;
-	}
+	} else if (pending & GALILEO_INTR_RETRY_CTR) {
 
-	if (pending & CAUSEF_IP3) {			/* int 19 */
-		do_IRQ(COBALT_ETH0_IRQ, regs);
-		return;
-	}
+		devfn = GALILEO_INL(GT_PCI0_CFGADDR_OFS) >> 8;
+		GALILEO_OUTL(~GALILEO_INTR_RETRY_CTR, GT_INTRCAUSE_OFS);
+		printk(KERN_WARNING "Galileo: PCI retry count exceeded (%02x.%u)\n",
+			PCI_SLOT(devfn), PCI_FUNC(devfn));
 
-	if (pending & CAUSEF_IP4) {			/* int 20 */
-		do_IRQ(COBALT_ETH1_IRQ, regs);
-		return;
-	}
+	} else {
 
-	if (pending & CAUSEF_IP5) {			/* int 21 */
-		do_IRQ(COBALT_SERIAL_IRQ, regs);
-		return;
+		GALILEO_OUTL(mask & ~pending, GT_INTRMASK_OFS);
+		printk(KERN_WARNING "Galileo: masking unexpected interrupt %08x\n", pending);
 	}
+}
 
-	if (pending & CAUSEF_IP7) {			/* int 23 */
-		do_IRQ(COBALT_QUBE_SLOT_IRQ, regs);
-		return;
-	}
+static inline void via_pic_irq(struct pt_regs *regs)
+{
+	int irq;
+
+	irq = i8259_irq();
+	if (irq >= 0)
+		do_IRQ(irq, regs);
 }
 
+asmlinkage void cobalt_irq(struct pt_regs *regs)
+{
+	unsigned pending;
+
+	pending = read_c0_status() & read_c0_cause();
+
+	if (pending & CAUSEF_IP2)			/* COBALT_GALILEO_IRQ (18) */
+
+		galileo_irq(regs);
+
+	else if (pending & CAUSEF_IP6)			/* COBALT_VIA_IRQ (22) */
+
+		via_pic_irq(regs);
+
+	else if (pending & CAUSEF_IP3)			/* COBALT_ETH0_IRQ (19) */
+
+		do_IRQ(COBALT_CPU_IRQ + 3, regs);
+
+	else if (pending & CAUSEF_IP4)			/* COBALT_ETH1_IRQ (20) */
+
+		do_IRQ(COBALT_CPU_IRQ + 4, regs);
+
+	else if (pending & CAUSEF_IP5)			/* COBALT_SERIAL_IRQ (21) */
+
+		do_IRQ(COBALT_CPU_IRQ + 5, regs);
+
+	else if (pending & CAUSEF_IP7)			/* IRQ 23 */
+
+		do_IRQ(COBALT_CPU_IRQ + 7, regs);
+}
+
+static struct irqaction irq_via = {
+	no_action, 0, { { 0, } }, "cascade", NULL, NULL
+};
+
 void __init arch_init_irq(void)
 {
+	/*
+	 * Mask all Galileo interrupts. The Galileo
+	 * handler is set in cobalt_timer_setup()
+	 */
+	GALILEO_OUTL(0, GT_INTRMASK_OFS);
+
 	set_except_vector(0, cobalt_handle_int);
 
 	init_i8259_irqs();				/*  0 ... 15 */
-	mips_cpu_irq_init(16);				/* 16 ... 23 */
+	mips_cpu_irq_init(COBALT_CPU_IRQ);		/* 16 ... 23 */
 
 	/*
 	 * Mask all cpu interrupts
 	 *  (except IE4, we already masked those at VIA level)
 	 */
 	change_c0_status(ST0_IM, IE_IRQ4);
+
+	setup_irq(COBALT_VIA_IRQ, &irq_via);
 }
diff -Naur linux-2.6.14/arch/mips/cobalt/Makefile linux-mips-2.6.14.orig/arch/mips/cobalt/Makefile
--- linux-2.6.14/arch/mips/cobalt/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/cobalt/Makefile	2005-11-17 11:42:18.000000000 -0800
@@ -2,6 +2,6 @@
 # Makefile for the Cobalt micro systems family specific parts of the kernel
 #
 
-obj-y	 := irq.o int-handler.o reset.o setup.o promcon.o
+obj-y	 := irq.o int-handler.o reset.o setup.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -Naur linux-2.6.14/arch/mips/cobalt/promcon.c linux-mips-2.6.14.orig/arch/mips/cobalt/promcon.c
--- linux-2.6.14/arch/mips/cobalt/promcon.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/cobalt/promcon.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,87 +0,0 @@
-/*
- * PROM console for Cobalt Raq2
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1995, 1996, 1997 by Ralf Baechle
- * Copyright (C) 2001 by Liam Davies (ldavies@agile.tv)
- *
- */
-
-#include <linux/init.h>
-#include <linux/console.h>
-#include <linux/kdev_t.h>
-#include <linux/serial_reg.h>
-
-#include <asm/delay.h>
-#include <asm/serial.h>
-#include <asm/io.h>
-
-static unsigned long port = 0xc800000;
-
-static __inline__ void ns16550_cons_put_char(char ch, unsigned long ioaddr)
-{
-	char lsr;
-
-	do {
-		lsr = inb(ioaddr + UART_LSR);
-	} while ((lsr & (UART_LSR_TEMT | UART_LSR_THRE)) != (UART_LSR_TEMT | UART_LSR_THRE));
-	outb(ch, ioaddr + UART_TX);
-}
-
-static __inline__ char ns16550_cons_get_char(unsigned long ioaddr)
-{
-	while ((inb(ioaddr + UART_LSR) & UART_LSR_DR) == 0)
-		udelay(1);
-	return inb(ioaddr + UART_RX);
-}
-
-void ns16550_console_write(struct console *co, const char *s, unsigned count)
-{
-	char lsr, ier;
-	unsigned i;
-
-	ier = inb(port + UART_IER);
-	outb(0x00, port + UART_IER);
-	for (i=0; i < count; i++, s++) {
-
-		if(*s == '\n')
-			ns16550_cons_put_char('\r', port);
-		ns16550_cons_put_char(*s, port);
-	}
-
-	do {
-		lsr = inb(port + UART_LSR);
-   	} while ((lsr & (UART_LSR_TEMT | UART_LSR_THRE)) != (UART_LSR_TEMT | UART_LSR_THRE));
-
-	outb(ier, port + UART_IER);
-}
-
-char getDebugChar(void)
-{
-	return ns16550_cons_get_char(port);
-}
-
-void putDebugChar(char kgdb_char)
-{
-	ns16550_cons_put_char(kgdb_char, port);
-}
-
-static struct console ns16550_console = {
-    .name	= "prom",
-    .setup	= NULL,
-    .write	= ns16550_console_write,
-    .flags	= CON_PRINTBUFFER,
-    .index	= -1,
-};
-
-static int __init ns16550_setup_console(void)
-{
-	register_console(&ns16550_console);
-
-	return 0;
-}
-
-console_initcall(ns16550_setup_console);
diff -Naur linux-2.6.14/arch/mips/cobalt/reset.c linux-mips-2.6.14.orig/arch/mips/cobalt/reset.c
--- linux-2.6.14/arch/mips/cobalt/reset.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/cobalt/reset.c	2005-11-17 11:42:18.000000000 -0800
@@ -16,48 +16,45 @@
 #include <asm/reboot.h>
 #include <asm/system.h>
 #include <asm/mipsregs.h>
+#include <asm/cobalt/cobalt.h>
 
-void cobalt_machine_restart(char *command)
+void cobalt_machine_halt(void)
 {
-	*(volatile char *)0xbc000000 = 0x0f;
+	int state, last, diff;
+	unsigned long mark;
 
 	/*
-	 * Ouch, we're still alive ... This time we take the silver bullet ...
-	 * ... and find that we leave the hardware in a state in which the
-	 * kernel in the flush locks up somewhen during of after the PCI
-	 * detection stuff.
+	 * turn off bar on Qube, flash power off LED on RaQ (0.5Hz)
+	 *
+	 * restart if ENTER and SELECT are pressed
 	 */
-	set_c0_status(ST0_BEV | ST0_ERL);
-	change_c0_config(CONF_CM_CMASK, CONF_CM_UNCACHED);
-	flush_cache_all();
-	write_c0_wired(0);
-	__asm__ __volatile__(
-		"jr\t%0"
-		:
-		: "r" (0xbfc00000));
-}
 
-extern int led_state;
-#define kLED            0xBC000000
-#define LEDSet(x)       (*(volatile unsigned char *) kLED) = (( unsigned char)x)
+	last = COBALT_KEY_PORT;
 
-void cobalt_machine_halt(void)
-{
-	int mark;
+	for (state = 0;;) {
+
+		state ^= COBALT_LED_POWER_OFF;
+		COBALT_LED_PORT = state;
+
+		diff = COBALT_KEY_PORT ^ last;
+		last ^= diff;
 
-	/* Blink our cute? little LED (number 3)... */
-	while (1) {
-		led_state = led_state | ( 1 << 3 );
-		LEDSet(led_state);
-		mark = jiffies;
-		while (jiffies<(mark+HZ));
-		led_state = led_state & ~( 1 << 3 );
-		LEDSet(led_state);
-		mark = jiffies;
-		while (jiffies<(mark+HZ));
+		if((diff & (COBALT_KEY_ENTER | COBALT_KEY_SELECT)) && !(~last & (COBALT_KEY_ENTER | COBALT_KEY_SELECT)))
+			COBALT_LED_PORT = COBALT_LED_RESET;
+
+		for (mark = jiffies; jiffies - mark < HZ;)
+			;
 	}
 }
 
+void cobalt_machine_restart(char *command)
+{
+	COBALT_LED_PORT = COBALT_LED_RESET;
+
+	/* we should never get here */
+	cobalt_machine_halt();
+}
+
 /*
  * This triggers the luser mode device driver for the power switch ;-)
  */
diff -Naur linux-2.6.14/arch/mips/cobalt/setup.c linux-mips-2.6.14.orig/arch/mips/cobalt/setup.c
--- linux-2.6.14/arch/mips/cobalt/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/cobalt/setup.c	2005-11-17 11:42:18.000000000 -0800
@@ -13,6 +13,8 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
 
 #include <asm/bootinfo.h>
 #include <asm/time.h>
@@ -21,6 +23,7 @@
 #include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/gt64120.h>
+#include <asm/serial.h>
 
 #include <asm/cobalt/cobalt.h>
 
@@ -30,45 +33,44 @@
 
 int cobalt_board_id;
 
-static char my_cmdline[CL_SIZE] = {
- "console=ttyS0,115200 "
-#ifdef CONFIG_IP_PNP
- "ip=on "
-#endif
-#ifdef CONFIG_ROOT_NFS
- "root=/dev/nfs "
-#else
- "root=/dev/hda1 "
-#endif
- };
-
 const char *get_system_type(void)
 {
+	switch (cobalt_board_id) {
+		case COBALT_BRD_ID_QUBE1:
+			return "Cobalt Qube";
+		case COBALT_BRD_ID_RAQ1:
+			return "Cobalt RaQ";
+		case COBALT_BRD_ID_QUBE2:
+			return "Cobalt Qube2";
+		case COBALT_BRD_ID_RAQ2:
+			return "Cobalt RaQ2";
+	}
 	return "MIPS Cobalt";
 }
 
 static void __init cobalt_timer_setup(struct irqaction *irq)
 {
-	/* Load timer value for 150 Hz */
-	GALILEO_OUTL(500000, GT_TC0_OFS);
+	/* Load timer value for 1KHz (TCLK is 50MHz) */
+	GALILEO_OUTL(50*1000*1000 / 1000, GT_TC0_OFS);
+
+	/* Enable timer */
+	GALILEO_OUTL(GALILEO_ENTC0 | GALILEO_SELTC0, GT_TC_CONTROL_OFS);
 
-	/* Register our timer interrupt */
-	setup_irq(COBALT_TIMER_IRQ, irq);
+	/* Register interrupt */
+	setup_irq(COBALT_GALILEO_IRQ, irq);
 
-	/* Enable timer ints */
-	GALILEO_OUTL((GALILEO_ENTC0 | GALILEO_SELTC0), GT_TC_CONTROL_OFS);
-	/* Unmask timer int */
-	GALILEO_OUTL(0x100, GT_INTRMASK_OFS);
+	/* Enable interrupt */
+	GALILEO_OUTL(GALILEO_INTR_T0EXP | GALILEO_INL(GT_INTRMASK_OFS), GT_INTRMASK_OFS);
 }
 
 extern struct pci_ops gt64111_pci_ops;
 
 static struct resource cobalt_mem_resource = {
-	"GT64111 PCI MEM", GT64111_IO_BASE, 0xffffffffUL, IORESOURCE_MEM
+	"PCI memory", GT64111_MEM_BASE, GT64111_MEM_END, IORESOURCE_MEM
 };
 
 static struct resource cobalt_io_resource = {
-	"GT64111 IO MEM", 0x00001000UL, 0x0fffffffUL, IORESOURCE_IO
+	"PCI I/O", 0x1000, 0xffff, IORESOURCE_IO
 };
 
 static struct resource cobalt_io_resources[] = {
@@ -86,11 +88,12 @@
 	.mem_resource	= &cobalt_mem_resource,
 	.mem_offset	= 0,
 	.io_resource	= &cobalt_io_resource,
-	.io_offset	= 0x00001000UL - GT64111_IO_BASE
+	.io_offset	= 0 - GT64111_IO_BASE
 };
 
-static void __init cobalt_setup(void)
+void __init plat_setup(void)
 {
+	static struct uart_port uart;
 	unsigned int devfn = PCI_DEVFN(COBALT_PCICONF_VIA, 0);
 	int i;
 
@@ -100,7 +103,10 @@
 
 	board_timer_setup = cobalt_timer_setup;
 
-        set_io_port_base(KSEG1ADDR(GT64111_IO_BASE));
+        set_io_port_base(CKSEG1ADDR(GT64111_IO_BASE));
+
+	/* I/O port resource must include UART and LCD/buttons */
+	ioport_resource.end = 0x0fffffff;
 
 	/*
 	 * This is a prom style console. We just poke at the
@@ -120,27 +126,61 @@
         cobalt_board_id >>= ((VIA_COBALT_BRD_ID_REG & 3) * 8);
         cobalt_board_id = VIA_COBALT_BRD_REG_to_ID(cobalt_board_id);
 
+	printk("Cobalt board ID: %d\n", cobalt_board_id);
+
 #ifdef CONFIG_PCI
 	register_pci_controller(&cobalt_pci_controller);
 #endif
-}
 
-early_initcall(cobalt_setup);
+#ifdef CONFIG_SERIAL_8250
+	if (cobalt_board_id > COBALT_BRD_ID_RAQ1) {
+
+		uart.line	= 0;
+		uart.type	= PORT_UNKNOWN;
+		uart.uartclk	= 18432000;
+		uart.irq	= COBALT_SERIAL_IRQ;
+		uart.flags	= STD_COM_FLAGS;
+		uart.iobase	= 0xc800000;
+		uart.iotype	= UPIO_PORT;
+
+		early_serial_setup(&uart);
+	}
+#endif
+}
 
 /*
  * Prom init. We read our one and only communication with the firmware.
- * Grab the amount of installed memory
+ * Grab the amount of installed memory.
+ * Better boot loaders (CoLo) pass a command line too :-)
  */
 
 void __init prom_init(void)
 {
-	int argc = fw_arg0;
-
-	strcpy(arcs_cmdline, my_cmdline);
+	int narg, indx, posn, nchr;
+	unsigned long memsz;
+	char **argv;
 
 	mips_machgroup = MACH_GROUP_COBALT;
 
-	add_memory_region(0x0, argc & 0x7fffffff, BOOT_MEM_RAM);
+	memsz = fw_arg0 & 0x7fff0000;
+	narg = fw_arg0 & 0x0000ffff;
+
+	if (narg) {
+		arcs_cmdline[0] = '\0';
+		argv = (char **) fw_arg1;
+		posn = 0;
+		for (indx = 1; indx < narg; ++indx) {
+			nchr = strlen(argv[indx]);
+			if (posn + 1 + nchr + 1 > sizeof(arcs_cmdline))
+				break;
+			if (posn)
+				arcs_cmdline[posn++] = ' ';
+			strcpy(arcs_cmdline + posn, argv[indx]);
+			posn += nchr;
+		}
+	}
+
+	add_memory_region(0x0, memsz, BOOT_MEM_RAM);
 }
 
 unsigned long __init prom_free_prom_memory(void)
diff -Naur linux-2.6.14/arch/mips/configs/atlas_defconfig linux-mips-2.6.14.orig/arch/mips/configs/atlas_defconfig
--- linux-2.6.14/arch/mips/configs/atlas_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/atlas_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:00 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:40 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,42 +59,72 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 CONFIG_MIPS_ATLAS=y
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_MSC=y
-# CONFIG_CPU_LITTLE_ENDIAN is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
@@ -101,8 +134,10 @@
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -118,15 +153,46 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_SYS_HAS_CPU_MIPS64_R1=y
+CONFIG_SYS_HAS_CPU_NEVADA=y
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_BOARD_SCACHE=y
+CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -135,7 +201,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -144,10 +209,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -160,199 +221,7 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-CONFIG_BLK_DEV_UMEM=m
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=m
-CONFIG_BLK_DEV_CRYPTOLOOP=m
-CONFIG_BLK_DEV_NBD=m
-# CONFIG_BLK_DEV_SX8 is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-# CONFIG_BLK_DEV_INITRD is not set
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-CONFIG_ATA_OVER_ETH=m
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-CONFIG_BLK_DEV_IDECD=y
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_IDE_GENERIC=y
-# CONFIG_BLK_DEV_IDEPCI is not set
-# CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_BLK_DEV_HD is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI=y
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_ST=m
-CONFIG_CHR_DEV_OSST=m
-CONFIG_BLK_DEV_SR=m
-CONFIG_BLK_DEV_SR_VENDOR=y
-CONFIG_CHR_DEV_SG=m
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_SCSI_CONSTANTS=y
-CONFIG_SCSI_LOGGING=y
-
-#
-# SCSI Transport Attributes
-#
-CONFIG_SCSI_SPI_ATTRS=y
-CONFIG_SCSI_FC_ATTRS=m
-CONFIG_SCSI_ISCSI_ATTRS=m
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-CONFIG_SCSI_SYM53C8XX_2=y
-CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
-CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
-CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
-# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
-# CONFIG_SCSI_QLOGIC_FC is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-CONFIG_SCSI_QLA2XXX=y
-# CONFIG_SCSI_QLA21XX is not set
-# CONFIG_SCSI_QLA22XX is not set
-# CONFIG_SCSI_QLA2300 is not set
-# CONFIG_SCSI_QLA2322 is not set
-# CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-CONFIG_MD=y
-CONFIG_BLK_DEV_MD=m
-CONFIG_MD_LINEAR=m
-CONFIG_MD_RAID0=m
-CONFIG_MD_RAID1=m
-CONFIG_MD_RAID10=m
-CONFIG_MD_RAID5=m
-CONFIG_MD_RAID6=m
-CONFIG_MD_MULTIPATH=m
-CONFIG_MD_FAULTY=m
-CONFIG_BLK_DEV_DM=m
-CONFIG_DM_CRYPT=m
-CONFIG_DM_SNAPSHOT=m
-CONFIG_DM_MIRROR=m
-CONFIG_DM_ZERO=m
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# I2O device support
-#
-# CONFIG_I2O is not set
-
-#
-# Networking support
+# Networking
 #
 CONFIG_NET=y
 
@@ -361,15 +230,20 @@
 #
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
 CONFIG_NET_KEY=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
 CONFIG_IP_MULTIPLE_TABLES=y
 CONFIG_IP_ROUTE_FWMARK=y
 CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
 CONFIG_IP_ROUTE_VERBOSE=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
@@ -387,8 +261,10 @@
 CONFIG_INET_ESP=m
 CONFIG_INET_IPCOMP=m
 CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-CONFIG_IP_TCPDIAG_IPV6=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
 
 #
 # IP: Virtual Server Configuration
@@ -433,6 +309,9 @@
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
 CONFIG_BRIDGE_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
 
 #
 # IP: Netfilter Configuration
@@ -440,11 +319,15 @@
 CONFIG_IP_NF_CONNTRACK=m
 CONFIG_IP_NF_CT_ACCT=y
 CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CONNTRACK_EVENTS=y
+CONFIG_IP_NF_CONNTRACK_NETLINK=m
 CONFIG_IP_NF_CT_PROTO_SCTP=m
 CONFIG_IP_NF_FTP=m
 CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
 CONFIG_IP_NF_TFTP=m
 CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_PPTP=m
 CONFIG_IP_NF_QUEUE=m
 CONFIG_IP_NF_IPTABLES=m
 CONFIG_IP_NF_MATCH_LIMIT=m
@@ -469,14 +352,18 @@
 CONFIG_IP_NF_MATCH_ADDRTYPE=m
 CONFIG_IP_NF_MATCH_REALM=m
 CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_DCCP=m
 CONFIG_IP_NF_MATCH_COMMENT=m
 CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_CONNBYTES=m
 CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_MATCH_STRING=m
 CONFIG_IP_NF_FILTER=m
 CONFIG_IP_NF_TARGET_REJECT=m
 CONFIG_IP_NF_TARGET_LOG=m
 CONFIG_IP_NF_TARGET_ULOG=m
 CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_TARGET_NFQUEUE=m
 CONFIG_IP_NF_NAT=m
 CONFIG_IP_NF_NAT_NEEDED=y
 CONFIG_IP_NF_TARGET_MASQUERADE=m
@@ -488,12 +375,14 @@
 CONFIG_IP_NF_NAT_FTP=m
 CONFIG_IP_NF_NAT_TFTP=m
 CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_PPTP=m
 CONFIG_IP_NF_MANGLE=m
 CONFIG_IP_NF_TARGET_TOS=m
 CONFIG_IP_NF_TARGET_ECN=m
 CONFIG_IP_NF_TARGET_DSCP=m
 CONFIG_IP_NF_TARGET_MARK=m
 CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_TTL=m
 CONFIG_IP_NF_TARGET_CONNMARK=m
 CONFIG_IP_NF_TARGET_CLUSTERIP=m
 CONFIG_IP_NF_RAW=m
@@ -503,7 +392,7 @@
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -523,8 +412,11 @@
 CONFIG_IP6_NF_MATCH_PHYSDEV=m
 CONFIG_IP6_NF_FILTER=m
 CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_NFQUEUE=m
 CONFIG_IP6_NF_MANGLE=m
 CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_TARGET_HL=m
 CONFIG_IP6_NF_RAW=m
 
 #
@@ -550,8 +442,11 @@
 CONFIG_BRIDGE_EBT_SNAT=m
 CONFIG_BRIDGE_EBT_LOG=m
 CONFIG_BRIDGE_EBT_ULOG=m
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
@@ -579,10 +474,6 @@
 CONFIG_NET_DIVERT=y
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
 CONFIG_NET_SCHED=y
 CONFIG_NET_SCH_CLK_JIFFIES=y
 # CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
@@ -602,6 +493,7 @@
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -612,6 +504,7 @@
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -619,17 +512,224 @@
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_LBD is not set
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_RAID6=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
 CONFIG_NETDEVICES=y
 CONFIG_DUMMY=m
 CONFIG_BONDING=m
 CONFIG_EQUALIZER=m
 CONFIG_TUN=m
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -637,12 +737,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -681,13 +797,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -700,6 +820,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -712,6 +834,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -741,19 +865,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -766,6 +877,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -786,6 +908,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -812,6 +935,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -822,10 +950,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -845,7 +983,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -855,13 +992,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -879,10 +1012,15 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -903,12 +1041,14 @@
 # CONFIG_JFS_STATISTICS is not set
 CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
+CONFIG_XFS_EXPORT=y
+CONFIG_XFS_QUOTA=m
 CONFIG_XFS_SECURITY=y
 CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
 CONFIG_MINIX_FS=m
 CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
 CONFIG_QUOTA=y
 # CONFIG_QFMT_V1 is not set
 CONFIG_QFMT_V2=y
@@ -916,6 +1056,7 @@
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -943,12 +1084,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -974,16 +1113,19 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 # CONFIG_NFSD_TCP is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -992,6 +1134,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -1051,7 +1194,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -1073,6 +1218,7 @@
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -1097,9 +1243,12 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
diff -Naur linux-2.6.14/arch/mips/configs/bigsur_defconfig linux-mips-2.6.14.orig/arch/mips/configs/bigsur_defconfig
--- linux-2.6.14/arch/mips/configs/bigsur_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/configs/bigsur_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,882 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:43 2005
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_CPUSETS is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+CONFIG_SIBYTE_BIGSUR=y
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_SIBYTE_BCM1x80=y
+CONFIG_SIBYTE_SB1xxx_SOC=y
+# CONFIG_CPU_SB1_PASS_1 is not set
+# CONFIG_CPU_SB1_PASS_2_1250 is not set
+# CONFIG_CPU_SB1_PASS_2_2 is not set
+# CONFIG_CPU_SB1_PASS_4 is not set
+# CONFIG_CPU_SB1_PASS_2_112x is not set
+# CONFIG_CPU_SB1_PASS_3 is not set
+# CONFIG_SIMULATION is not set
+# CONFIG_CONFIG_SB1_CEX_ALWAYS_FATAL is not set
+# CONFIG_CONFIG_SB1_CERR_STALL is not set
+CONFIG_SIBYTE_CFE=y
+# CONFIG_SIBYTE_CFE_CONSOLE is not set
+# CONFIG_SIBYTE_BUS_WATCHER is not set
+# CONFIG_SIBYTE_SB1250_PROF is not set
+# CONFIG_SIBYTE_TBPROF is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_COHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SWAP_IO_SPACE=y
+CONFIG_BOOT_ELF32=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+CONFIG_CPU_SB1=y
+CONFIG_SYS_HAS_CPU_SB1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_SIBYTE_DMA_PAGEOPS is not set
+# CONFIG_MIPS_MT is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SMP=y
+CONFIG_NR_CPUS=4
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_PREEMPT_BKL is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_DEBUG=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_BUILD_ELF64=y
+CONFIG_MIPS32_COMPAT=y
+CONFIG_COMPAT=y
+CONFIG_MIPS32_O32=y
+# CONFIG_MIPS32_N32 is not set
+CONFIG_BINFMT_ELF32=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDETAPE=y
+CONFIG_BLK_DEV_IDEFLOPPY=y
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_BLK_DEV_IDE_SWARM is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_SB1250_MAC=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_STALDRV is not set
+CONFIG_SIBYTE_SB1250_DUART=y
+CONFIG_SIBYTE_SB1250_DUART_CONSOLE=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+CONFIG_I2C_ALGO_SIBYTE=y
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+CONFIG_I2C_SIBYTE=y
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+CONFIG_SENSORS_DS1337=y
+CONFIG_SENSORS_DS1374=y
+CONFIG_SENSORS_EEPROM=y
+CONFIG_SENSORS_PCF8574=y
+CONFIG_SENSORS_PCA9539=y
+CONFIG_SENSORS_PCF8591=y
+CONFIG_SENSORS_RTC8564=y
+CONFIG_SENSORS_MAX6875=y
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+CONFIG_I2C_DEBUG_CHIP=y
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE=""
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_KGDB is not set
+# CONFIG_SB1XXX_CORELIS is not set
+# CONFIG_RUNTIME_DEBUG is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_TEA=m
+# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/capcella_defconfig linux-mips-2.6.14.orig/arch/mips/configs/capcella_defconfig
--- linux-2.6.14/arch/mips/configs/capcella_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/capcella_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:00 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:47 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,57 +59,86 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-CONFIG_ZAO_CAPCELLA=y
-CONFIG_PCI_VR41XX=y
-CONFIG_VRC4173=y
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB022X is not set
+# CONFIG_VICTOR_MPC30X is not set
+CONFIG_ZAO_CAPCELLA=y
+CONFIG_PCI_VR41XX=y
+# CONFIG_VRC4173 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 CONFIG_CPU_VR41XX=y
@@ -122,12 +154,36 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_VR41XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -136,7 +192,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -145,10 +200,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -161,6 +212,81 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -169,7 +295,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -188,7 +319,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -199,11 +329,8 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -244,6 +371,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -254,6 +382,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -266,79 +395,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -346,12 +409,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -359,7 +438,30 @@
 #
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+CONFIG_8139TOO_PIO=y
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -371,12 +473,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -389,6 +496,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -400,6 +509,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -419,29 +530,13 @@
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_MOUSEDEV is not set
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=m
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -451,6 +546,12 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -461,16 +562,16 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VR41XX=y
+CONFIG_SERIAL_VR41XX_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -483,19 +584,7 @@
 #
 # Watchdog Cards
 #
-CONFIG_WATCHDOG=y
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-
-#
-# Watchdog Device Drivers
-#
-# CONFIG_SOFT_WATCHDOG is not set
-
-#
-# PCI-based Watchdog Cards
-#
-# CONFIG_PCIPCWATCHDOG is not set
-# CONFIG_WDTPCI is not set
+# CONFIG_WATCHDOG is not set
 # CONFIG_RTC is not set
 # CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
@@ -506,9 +595,15 @@
 # Ftape, the floppy tape device driver
 #
 # CONFIG_DRM is not set
+CONFIG_GPIO_VR41XX=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -519,10 +614,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -542,7 +647,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -552,13 +656,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -576,21 +676,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -611,12 +719,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -648,6 +754,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -656,6 +763,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -676,9 +784,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE=""
+CONFIG_CMDLINE="mem=32M console=ttyVR0,38400"
 
 #
 # Security options
@@ -690,7 +800,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -700,7 +834,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/cobalt_defconfig linux-mips-2.6.14.orig/arch/mips/configs/cobalt_defconfig
--- linux-2.6.14/arch/mips/configs/cobalt_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/cobalt_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:00 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:50 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,41 +53,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 CONFIG_MIPS_COBALT=y
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_GT64111=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -92,8 +123,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -109,14 +142,38 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_NEVADA=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -125,7 +182,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -134,10 +190,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -150,6 +202,77 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -161,6 +284,11 @@
 CONFIG_FW_LOADER=y
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -177,7 +305,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -189,7 +316,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -234,6 +360,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -244,6 +371,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -256,75 +384,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -332,12 +398,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -357,12 +439,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -375,6 +461,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -386,6 +474,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -415,19 +505,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -437,6 +514,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -457,6 +545,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -483,6 +572,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -493,10 +587,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -516,7 +620,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -526,13 +629,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -550,12 +649,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 CONFIG_FS_MBCACHE=y
@@ -565,10 +669,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -589,12 +695,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -622,7 +726,7 @@
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -631,6 +735,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -651,7 +756,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -665,7 +772,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -675,7 +806,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/db1000_defconfig linux-mips-2.6.14.orig/arch/mips/configs/db1000_defconfig
--- linux-2.6.14/arch/mips/configs/db1000_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/db1000_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:01 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:54 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,63 +59,79 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+CONFIG_MIPS_DB1000=y
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-CONFIG_SOC_AU1000=y
-# CONFIG_SOC_AU1100 is not set
-# CONFIG_SOC_AU1500 is not set
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-CONFIG_MIPS_DB1000=y
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1000=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -128,15 +147,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -152,11 +195,12 @@
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
 CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 
 #
 # PC-card bridges
 #
-# CONFIG_TCIC is not set
 # CONFIG_PCMCIA_AU1X00 is not set
 
 #
@@ -169,6 +213,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -179,12 +316,86 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -198,14 +409,12 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -228,6 +437,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -238,6 +448,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -248,94 +459,28 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
+# Network device support
 #
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -389,6 +534,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -418,18 +565,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -439,6 +574,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -473,14 +618,14 @@
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 
 #
 # PCMCIA character devices
@@ -489,6 +634,10 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -499,10 +648,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -522,7 +681,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -532,12 +690,9 @@
 #
 # USB support
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -552,7 +707,10 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
@@ -561,6 +719,7 @@
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -579,10 +738,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -603,13 +764,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -621,6 +779,8 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -641,6 +801,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -650,6 +811,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -709,7 +871,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -725,26 +889,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -756,9 +921,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/db1100_defconfig linux-mips-2.6.14.orig/arch/mips/configs/db1100_defconfig
--- linux-2.6.14/arch/mips/configs/db1100_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/db1100_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:01 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:58 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,63 +59,79 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+CONFIG_MIPS_DB1100=y
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-CONFIG_SOC_AU1100=y
-# CONFIG_SOC_AU1500 is not set
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-CONFIG_MIPS_DB1100=y
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1100=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -128,15 +147,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_MIPS_MT is not set
+CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -147,15 +190,7 @@
 #
 # PCCARD (PCMCIA/CardBus) support
 #
-CONFIG_PCCARD=m
-# CONFIG_PCMCIA_DEBUG is not set
-CONFIG_PCMCIA=m
-
-#
-# PC-card bridges
-#
-# CONFIG_TCIC is not set
-# CONFIG_PCMCIA_AU1X00 is not set
+# CONFIG_PCCARD is not set
 
 #
 # PCI Hotplug Support
@@ -167,6 +202,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -180,9 +308,83 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -196,14 +398,12 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -226,6 +426,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -236,6 +437,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -246,101 +448,35 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
+# Network device support
 #
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=m
-# CONFIG_MIPS_AU1X00_ENET is not set
+CONFIG_MIPS_AU1X00_ENET=y
 
 #
 # Ethernet (1000 Mbit)
@@ -360,19 +496,6 @@
 # CONFIG_NET_RADIO is not set
 
 #
-# PCMCIA network device support
-#
-CONFIG_NET_PCMCIA=y
-CONFIG_PCMCIA_3C589=m
-CONFIG_PCMCIA_3C574=m
-CONFIG_PCMCIA_FMVJ18X=m
-CONFIG_PCMCIA_PCNET=m
-CONFIG_PCMCIA_NMCLAN=m
-CONFIG_PCMCIA_SMC91C92=m
-CONFIG_PCMCIA_XIRC2PS=m
-CONFIG_PCMCIA_AXNET=m
-
-#
 # Wan interfaces
 #
 # CONFIG_WAN is not set
@@ -387,6 +510,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -416,18 +541,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=m
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -437,6 +550,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=m
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -454,7 +577,10 @@
 #
 # Non-8250 serial port support
 #
-# CONFIG_SERIAL_AU1X00 is not set
+CONFIG_SERIAL_AU1X00=y
+CONFIG_SERIAL_AU1X00_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -468,20 +594,19 @@
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
 
 #
-# PCMCIA character devices
+# TPM devices
 #
-CONFIG_SYNCLINK_CS=m
-# CONFIG_RAW_DRIVER is not set
 
 #
 # I2C support
@@ -494,10 +619,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -510,13 +645,43 @@
 #
 # Graphics support
 #
-# CONFIG_FB is not set
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_AU1100=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
 # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
@@ -527,12 +692,9 @@
 #
 # USB support
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -547,7 +709,10 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
@@ -556,6 +721,7 @@
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -574,10 +740,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -598,13 +766,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -616,6 +781,8 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -636,6 +803,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -645,6 +813,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -704,7 +873,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -720,26 +891,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -751,9 +923,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/db1200_defconfig linux-mips-2.6.14.orig/arch/mips/configs/db1200_defconfig
--- linux-2.6.14/arch/mips/configs/db1200_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/configs/db1200_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,985 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:02 2005
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+CONFIG_MIPS_DB1200=y
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_COHERENT=y
+CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1200=y
+CONFIG_SOC_AU1X00=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+
+#
+# PC-card bridges
+#
+CONFIG_PCMCIA_AU1X00=m
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_NETLINK is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_AU1550 is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDE_AU1XXX=y
+CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA=y
+# CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA is not set
+# CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON is not set
+CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ=128
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=m
+# CONFIG_MIPS_AU1X00_ENET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_AU1X00_GPIO is not set
+# CONFIG_TS_AU1X00_ADS7846 is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_AU1X00=y
+CONFIG_SERIAL_AU1X00_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_AU1200=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_AU1X=y
+
+#
+# InfiniBand support
+#
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+CONFIG_JFS_FS=y
+# CONFIG_JFS_POSIX_ACL is not set
+# CONFIG_JFS_SECURITY is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_ZISOFS_FS=m
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=m
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=y
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="mem=48M"
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/db1500_defconfig linux-mips-2.6.14.orig/arch/mips/configs/db1500_defconfig
--- linux-2.6.14/arch/mips/configs/db1500_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/db1500_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:01 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:06 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,63 +59,81 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+CONFIG_MIPS_DB1500=y
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-CONFIG_SOC_AU1500=y
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-CONFIG_MIPS_DB1500=y
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1500=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -128,15 +149,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -145,7 +190,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -154,6 +198,8 @@
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
 CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 CONFIG_CARDBUS=y
 
 #
@@ -162,7 +208,6 @@
 # CONFIG_YENTA is not set
 # CONFIG_PD6729 is not set
 # CONFIG_I82092 is not set
-# CONFIG_TCIC is not set
 CONFIG_PCMCIA_AU1X00=m
 
 #
@@ -176,6 +221,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -186,15 +324,20 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -232,16 +375,14 @@
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
 
 #
 # Mapping drivers for chip access
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_DB1X00=y
-CONFIG_MTD_DB1X00_BOOT=y
-CONFIG_MTD_DB1X00_USER=y
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -277,7 +418,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -290,7 +430,6 @@
 # CONFIG_BLK_DEV_UB is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -336,6 +475,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -346,6 +486,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -358,94 +499,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
+# Network device support
 #
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -453,6 +513,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -460,6 +535,7 @@
 CONFIG_MIPS_AU1X00_ENET=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -479,12 +555,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -497,6 +577,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # PCMCIA network device support
@@ -520,6 +602,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -549,19 +633,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -571,6 +642,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -590,6 +672,7 @@
 CONFIG_SERIAL_AU1X00_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -603,7 +686,8 @@
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -620,6 +704,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -630,10 +719,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -647,7 +746,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -680,7 +778,6 @@
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
 # CONFIG_SOUND_VIA82CXXX is not set
-# CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_ALI5455 is not set
 # CONFIG_SOUND_FORTE is not set
 # CONFIG_SOUND_RME96XX is not set
@@ -689,6 +786,8 @@
 #
 # USB support
 #
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_USB=y
 # CONFIG_USB_DEBUG is not set
 
@@ -699,23 +798,23 @@
 # CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
 # USB Host Controller Drivers
 #
 # CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
 CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 # CONFIG_USB_UHCI_HCD is not set
 # CONFIG_USB_SL811_HCD is not set
 
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_AUDIO is not set
+# CONFIG_OBSOLETE_OSS_USB_DRIVER is not set
 # CONFIG_USB_BLUETOOTH_TTY is not set
-# CONFIG_USB_MIDI is not set
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
 
@@ -733,12 +832,17 @@
 # CONFIG_USB_HIDDEV is not set
 # CONFIG_USB_AIPTEK is not set
 # CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
 # CONFIG_USB_KBTAB is not set
 # CONFIG_USB_POWERMATE is not set
 # CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
 # CONFIG_USB_EGALAX is not set
+CONFIG_USB_YEALINK=m
 # CONFIG_USB_XPAD is not set
 # CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
 
 #
 # USB Imaging devices
@@ -762,6 +866,7 @@
 # CONFIG_USB_PEGASUS is not set
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
 
 #
 # USB port drivers
@@ -786,9 +891,10 @@
 # CONFIG_USB_PHIDGETKIT is not set
 # CONFIG_USB_PHIDGETSERVO is not set
 # CONFIG_USB_IDMOUSE is not set
+CONFIG_USB_LD=m
 
 #
-# USB ATM/DSL drivers
+# USB DSL modem support
 #
 
 #
@@ -807,12 +913,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -831,10 +942,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -855,13 +968,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -895,6 +1005,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -904,6 +1015,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -963,7 +1075,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -979,26 +1093,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -1010,9 +1125,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/db1550_defconfig linux-mips-2.6.14.orig/arch/mips/configs/db1550_defconfig
--- linux-2.6.14/arch/mips/configs/db1550_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/db1550_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:02 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:09 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,63 +59,80 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+CONFIG_MIPS_DB1550=y
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-# CONFIG_SOC_AU1500 is not set
-CONFIG_SOC_AU1550=y
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-CONFIG_MIPS_DB1550=y
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1550=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -128,15 +148,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -145,7 +189,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -154,6 +197,8 @@
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
 CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 CONFIG_CARDBUS=y
 
 #
@@ -162,7 +207,6 @@
 # CONFIG_YENTA is not set
 # CONFIG_PD6729 is not set
 # CONFIG_I82092 is not set
-# CONFIG_TCIC is not set
 CONFIG_PCMCIA_AU1X00=m
 
 #
@@ -176,6 +220,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -186,15 +323,20 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -238,9 +380,8 @@
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_DB1550=y
-CONFIG_MTD_DB1550_BOOT=y
-CONFIG_MTD_DB1550_USER=y
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -281,7 +422,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -293,7 +433,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -350,6 +489,7 @@
 # CONFIG_BLK_DEV_HPT366 is not set
 # CONFIG_BLK_DEV_SC1200 is not set
 # CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_PDC202XX_OLD is not set
 # CONFIG_BLK_DEV_PDC202XX_NEW is not set
@@ -367,6 +507,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -377,6 +518,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -389,94 +531,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
+# Network device support
 #
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -484,6 +545,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -491,6 +567,7 @@
 CONFIG_MIPS_AU1X00_ENET=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -510,12 +587,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -528,6 +609,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # PCMCIA network device support
@@ -559,6 +642,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -588,19 +673,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -610,6 +682,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -629,6 +712,7 @@
 CONFIG_SERIAL_AU1X00_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -660,6 +744,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -670,10 +759,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -687,7 +786,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -697,13 +795,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -721,12 +815,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -745,10 +844,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -769,13 +870,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -809,6 +907,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -818,6 +917,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -877,7 +977,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -893,26 +995,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -924,9 +1027,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ddb5476_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ddb5476_defconfig
--- linux-2.6.14/arch/mips/configs/ddb5476_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ddb5476_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:02 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:13 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,41 +53,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 CONFIG_DDB5476=y
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -93,8 +124,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -110,14 +143,38 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5432=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -126,7 +183,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_ISA=y
 CONFIG_MMU=y
 
@@ -136,11 +192,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -153,6 +204,80 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -161,7 +286,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
 
 #
 # Memory Technology Devices (MTD)
@@ -181,8 +311,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_XD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -193,7 +321,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -239,6 +366,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -254,6 +382,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -266,78 +395,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -345,14 +409,29 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_NET_VENDOR_RACAL is not set
 
@@ -365,7 +444,6 @@
 # CONFIG_HP100 is not set
 # CONFIG_NET_ISA is not set
 # CONFIG_NET_PCI is not set
-# CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -377,12 +455,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -395,6 +477,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -406,6 +490,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -435,19 +521,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -457,6 +530,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -477,6 +561,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -503,6 +588,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -513,10 +603,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -530,6 +630,11 @@
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
+# CONFIG_FB_MACMODES is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -537,6 +642,7 @@
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -549,8 +655,11 @@
 # CONFIG_FB_KYRO is not set
 # CONFIG_FB_3DFX is not set
 # CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_SMIVGX is not set
+# CONFIG_FB_CYBLA is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_E1356 is not set
+# CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
 
 #
@@ -575,13 +684,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -599,21 +704,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -634,12 +747,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -668,7 +779,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -677,6 +788,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -697,7 +809,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=any"
 
@@ -711,7 +825,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -721,7 +859,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/ddb5477_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ddb5477_defconfig
--- linux-2.6.14/arch/mips/configs/ddb5477_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ddb5477_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:02 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:16 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,42 +53,70 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 CONFIG_DDB5477=y
-CONFIG_DDB5477_BUS_FREQUENCY=0
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_DDB5477_BUS_FREQUENCY=0
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -93,8 +124,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -110,14 +143,38 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5432=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -126,7 +183,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -135,10 +191,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -151,6 +203,80 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -159,7 +285,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
 
 #
 # Memory Technology Devices (MTD)
@@ -178,7 +309,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -189,7 +319,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -212,6 +341,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -222,6 +352,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -234,78 +365,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
+# Network device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -313,12 +379,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -357,13 +439,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -376,6 +462,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -387,6 +475,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -416,19 +506,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -438,6 +515,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -458,6 +546,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -484,6 +573,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -494,10 +588,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -517,7 +621,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -527,13 +630,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -551,21 +650,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -586,12 +693,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -623,6 +728,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -631,6 +737,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -651,7 +758,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=any"
 
@@ -665,7 +774,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -675,7 +808,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/decstation_defconfig linux-mips-2.6.14.orig/arch/mips/configs/decstation_defconfig
--- linux-2.6.14/arch/mips/configs/decstation_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/decstation_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:20 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,30 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -49,48 +53,76 @@
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_MODULE_FORCE_UNLOAD is not set
 CONFIG_OBSOLETE_MODPARM=y
-CONFIG_MODVERSIONS=y
+# CONFIG_MODVERSIONS is not set
 CONFIG_MODULE_SRCVERSION_ALL=y
 CONFIG_KMOD=y
 
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 CONFIG_MACH_DECSTATION=y
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_EARLY_PRINTK=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=4
@@ -98,8 +130,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 CONFIG_CPU_R3000=y
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -115,12 +149,37 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R3000=y
+CONFIG_SYS_HAS_CPU_R4X00=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_WB=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -135,10 +194,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -150,6 +205,80 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -159,6 +288,12 @@
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
 # CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -177,17 +312,14 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -196,7 +328,7 @@
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
-CONFIG_ATA_OVER_ETH=m
+# CONFIG_ATA_OVER_ETH is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -206,6 +338,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -213,10 +346,12 @@
 # SCSI support type (disk, tape, CD-ROM)
 #
 CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
+CONFIG_CHR_DEV_ST=m
 # CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -228,9 +363,10 @@
 #
 # SCSI Transport Attributes
 #
-# CONFIG_SCSI_SPI_ATTRS is not set
+CONFIG_SCSI_SPI_ATTRS=m
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=m
 
 #
 # SCSI low-level drivers
@@ -248,6 +384,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -258,78 +395,28 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -363,6 +450,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -377,48 +466,22 @@
 #
 # Input device support
 #
-CONFIG_INPUT=y
+# CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
 
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
+# CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_SERIAL_DEC=y
+CONFIG_SERIAL_DEC_CONSOLE=y
+CONFIG_ZS=y
 
 #
 # Serial drivers
@@ -445,18 +508,20 @@
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
+CONFIG_RTC=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -467,10 +532,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -483,13 +558,29 @@
 #
 # Graphics support
 #
-# CONFIG_FB is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_PMAG_AA is not set
+CONFIG_FB_PMAG_BA=y
+CONFIG_FB_PMAGB_B=y
+# CONFIG_FB_MAXINE is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+# CONFIG_LOGO_LINUX_CLUT224 is not set
+CONFIG_LOGO_DEC_CLUT224=y
 # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
@@ -504,10 +595,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -520,7 +607,10 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
@@ -529,6 +619,7 @@
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 CONFIG_FS_MBCACHE=y
@@ -538,10 +629,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -562,12 +655,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
-# CONFIG_TMPFS is not set
+CONFIG_TMPFS=y
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -584,19 +675,31 @@
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
+CONFIG_UFS_FS=y
+CONFIG_UFS_FS_WRITE=y
 
 #
 # Network File Systems
 #
-# CONFIG_NFS_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
-# CONFIG_EXPORTFS is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -631,9 +734,24 @@
 #
 # Kernel hacking
 #
-# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_KGDB is not set
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_MIPS_UNCACHED is not set
 
 #
 # Security options
@@ -645,7 +763,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -655,7 +797,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/e55_defconfig linux-mips-2.6.14.orig/arch/mips/configs/e55_defconfig
--- linux-2.6.14/arch/mips/configs/e55_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/e55_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:23 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,56 +59,84 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-CONFIG_CASIO_E55=y
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-# CONFIG_VRC4171 is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+CONFIG_CASIO_E55=y
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB022X is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 CONFIG_CPU_VR41XX=y
@@ -121,12 +152,36 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_VR41XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -141,11 +196,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 
@@ -157,6 +207,78 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -168,6 +290,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -185,18 +312,13 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_XD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -205,7 +327,7 @@
 CONFIG_IOSCHED_AS=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
-CONFIG_ATA_OVER_ETH=m
+# CONFIG_ATA_OVER_ETH is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -237,6 +359,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -252,6 +375,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -262,76 +386,13 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -339,12 +400,26 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_NET_VENDOR_RACAL is not set
 # CONFIG_AT1700 is not set
@@ -352,7 +427,6 @@
 # CONFIG_HP100 is not set
 # CONFIG_NET_ISA is not set
 # CONFIG_NET_PCI is not set
-# CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -380,6 +454,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -401,26 +477,14 @@
 #
 CONFIG_INPUT_MOUSEDEV=y
 CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=320
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=240
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -430,6 +494,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -440,16 +514,15 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VR41XX=y
+CONFIG_SERIAL_VR41XX_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -484,10 +557,14 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
+CONFIG_GPIO_VR41XX=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -498,10 +575,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -522,7 +609,6 @@
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -536,10 +622,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -552,24 +634,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -590,12 +679,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -617,16 +704,17 @@
 #
 # Network File Systems
 #
-CONFIG_NFS_FS=y
+CONFIG_NFS_FS=m
 # CONFIG_NFS_V3 is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
-CONFIG_NFSD=y
+CONFIG_NFSD=m
 # CONFIG_NFSD_V3 is not set
 # CONFIG_NFSD_TCP is not set
-CONFIG_LOCKD=y
-CONFIG_EXPORTFS=y
-CONFIG_SUNRPC=y
+CONFIG_LOCKD=m
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
 # CONFIG_SMB_FS is not set
@@ -634,6 +722,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -654,9 +743,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE=""
+CONFIG_CMDLINE="console=ttyVR0,19200 mem=8M"
 
 #
 # Security options
@@ -668,7 +759,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -678,7 +793,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ev64120_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ev64120_defconfig
--- linux-2.6.14/arch/mips/configs/ev64120_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ev64120_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:27 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,41 +59,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 CONFIG_MIPS_EV64120=y
-# CONFIG_EVB_PCI1 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_EVB_PCI1 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_MIPS_GT64120=y
 # CONFIG_SYSCLK_75 is not set
 # CONFIG_SYSCLK_83 is not set
@@ -100,8 +131,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -117,15 +150,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -134,7 +191,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -143,10 +199,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -159,6 +211,79 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -167,7 +292,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -186,7 +316,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -197,7 +326,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -220,6 +348,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -230,6 +359,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -242,77 +372,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -320,12 +386,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -345,12 +427,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -363,6 +449,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -381,6 +469,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -410,19 +500,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -432,6 +509,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -452,6 +540,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -478,6 +567,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -488,10 +582,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -511,7 +615,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -521,13 +624,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -545,21 +644,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -580,12 +687,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -614,7 +719,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -623,6 +728,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -643,7 +749,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/nfs rw nfsroot=192.168.1.1:/mnt/disk2/fs.gal ip=192.168.1.211:192.168.1.1:::gt::"
 
@@ -657,7 +765,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -667,7 +799,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=y
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ev96100_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ev96100_defconfig
--- linux-2.6.14/arch/mips/configs/ev96100_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ev96100_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:29 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,40 +59,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 CONFIG_MIPS_EV96100=y
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
@@ -99,8 +130,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -116,6 +149,18 @@
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5000=y
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -123,11 +168,25 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -143,10 +202,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -158,6 +213,79 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -169,6 +297,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -185,13 +318,11 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -214,6 +345,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -224,6 +356,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -234,77 +367,28 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
+# Network device support
 #
-# CONFIG_PACKET is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -338,6 +422,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -367,18 +453,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -388,6 +462,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -429,10 +513,13 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -443,10 +530,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -466,7 +563,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -480,10 +576,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -496,24 +588,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -534,12 +633,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -568,7 +665,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -577,6 +674,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -597,7 +695,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -611,7 +711,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -621,7 +745,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ip22_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ip22_defconfig
--- linux-2.6.14/arch/mips/configs/ip22_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ip22_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:04 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:33 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,25 +11,30 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,41 +60,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 CONFIG_SGI_IP22=y
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_ARC32=y
@@ -103,8 +134,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -120,22 +153,48 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R4X00=y
+CONFIG_SYS_HAS_CPU_R5000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
 CONFIG_IP22_CPU_SCACHE=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
 # CONFIG_PREEMPT is not set
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_EISA=y
 # CONFIG_EISA is not set
 CONFIG_MMU=y
 
@@ -145,10 +204,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -160,115 +215,7 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-CONFIG_ATA_OVER_ETH=m
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI=y
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_ST=y
-# CONFIG_CHR_DEV_OSST is not set
-CONFIG_BLK_DEV_SR=y
-# CONFIG_BLK_DEV_SR_VENDOR is not set
-# CONFIG_CHR_DEV_SG is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_MULTI_LUN is not set
-CONFIG_SCSI_CONSTANTS=y
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI Transport Attributes
-#
-CONFIG_SCSI_SPI_ATTRS=m
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-
-#
-# SCSI low-level drivers
-#
-CONFIG_SGIWD93_SCSI=y
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-
-#
-# IEEE 1394 (FireWire) support
-#
-
-#
-# I2O device support
-#
-
-#
-# Networking support
+# Networking
 #
 CONFIG_NET=y
 
@@ -277,12 +224,14 @@
 #
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
 CONFIG_NET_KEY=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
 # CONFIG_IP_PNP_DHCP is not set
 CONFIG_IP_PNP_BOOTP=y
@@ -296,8 +245,10 @@
 CONFIG_INET_ESP=m
 CONFIG_INET_IPCOMP=m
 CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-CONFIG_IP_TCPDIAG_IPV6=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
 
 #
 # IP: Virtual Server Configuration
@@ -341,6 +292,9 @@
 CONFIG_IPV6_TUNNEL=m
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
 
 #
 # IP: Netfilter Configuration
@@ -348,11 +302,15 @@
 CONFIG_IP_NF_CONNTRACK=m
 CONFIG_IP_NF_CT_ACCT=y
 CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CONNTRACK_EVENTS=y
+CONFIG_IP_NF_CONNTRACK_NETLINK=m
 # CONFIG_IP_NF_CT_PROTO_SCTP is not set
 CONFIG_IP_NF_FTP=m
 CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
 CONFIG_IP_NF_TFTP=m
 CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_PPTP=m
 CONFIG_IP_NF_QUEUE=m
 CONFIG_IP_NF_IPTABLES=m
 CONFIG_IP_NF_MATCH_LIMIT=m
@@ -376,14 +334,18 @@
 CONFIG_IP_NF_MATCH_ADDRTYPE=m
 CONFIG_IP_NF_MATCH_REALM=m
 CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_DCCP=m
 CONFIG_IP_NF_MATCH_COMMENT=m
 CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_CONNBYTES=m
 CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_MATCH_STRING=m
 CONFIG_IP_NF_FILTER=m
 CONFIG_IP_NF_TARGET_REJECT=m
 CONFIG_IP_NF_TARGET_LOG=m
 CONFIG_IP_NF_TARGET_ULOG=m
 CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_TARGET_NFQUEUE=m
 CONFIG_IP_NF_NAT=m
 CONFIG_IP_NF_NAT_NEEDED=y
 CONFIG_IP_NF_TARGET_MASQUERADE=m
@@ -395,12 +357,14 @@
 CONFIG_IP_NF_NAT_FTP=m
 CONFIG_IP_NF_NAT_TFTP=m
 CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_PPTP=m
 CONFIG_IP_NF_MANGLE=m
 CONFIG_IP_NF_TARGET_TOS=m
 CONFIG_IP_NF_TARGET_ECN=m
 CONFIG_IP_NF_TARGET_DSCP=m
 CONFIG_IP_NF_TARGET_MARK=m
 CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_TTL=m
 CONFIG_IP_NF_TARGET_CONNMARK=m
 CONFIG_IP_NF_TARGET_CLUSTERIP=m
 CONFIG_IP_NF_RAW=m
@@ -410,7 +374,7 @@
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -429,11 +393,17 @@
 CONFIG_IP6_NF_MATCH_EUI64=m
 CONFIG_IP6_NF_FILTER=m
 CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_NFQUEUE=m
 CONFIG_IP6_NF_MANGLE=m
 CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_TARGET_HL=m
 CONFIG_IP6_NF_RAW=m
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
@@ -456,10 +426,6 @@
 CONFIG_NET_DIVERT=y
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
 CONFIG_NET_SCHED=y
 # CONFIG_NET_SCH_CLK_JIFFIES is not set
 CONFIG_NET_SCH_CLK_GETTIMEOFDAY=y
@@ -479,6 +445,7 @@
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -489,6 +456,7 @@
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -496,17 +464,153 @@
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_LBD is not set
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=y
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_SCH=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=m
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+
+#
+# SCSI low-level drivers
+#
+CONFIG_SGIWD93_SCSI=y
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
 CONFIG_NETDEVICES=y
 CONFIG_DUMMY=m
 CONFIG_BONDING=m
 CONFIG_EQUALIZER=m
 CONFIG_TUN=m
-CONFIG_ETHERTAP=m
+
+#
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -540,6 +644,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -569,18 +675,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -598,6 +692,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -644,11 +748,14 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 CONFIG_RAW_DRIVER=m
 CONFIG_MAX_RAW_DEVS=256
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -659,10 +766,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -693,7 +810,6 @@
 # CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_LOGO_LINUX_CLUT224 is not set
 CONFIG_LOGO_SGI_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -707,10 +823,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -723,13 +835,17 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=m
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -741,12 +857,14 @@
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
+CONFIG_XFS_EXPORT=y
+CONFIG_XFS_QUOTA=m
 CONFIG_XFS_SECURITY=y
 # CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
 CONFIG_MINIX_FS=m
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 CONFIG_QUOTA=y
 # CONFIG_QFMT_V1 is not set
 CONFIG_QFMT_V2=m
@@ -754,6 +872,7 @@
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -781,12 +900,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -811,15 +928,20 @@
 #
 CONFIG_NFS_FS=m
 CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
 CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
 # CONFIG_NFSD_V4 is not set
 CONFIG_NFSD_TCP=y
 CONFIG_LOCKD=m
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=m
 CONFIG_SUNRPC_GSS=m
 CONFIG_RPCSEC_GSS_KRB5=m
@@ -835,6 +957,7 @@
 CONFIG_CODA_FS=m
 # CONFIG_CODA_FS_OLD_API is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -908,7 +1031,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -931,6 +1056,7 @@
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -942,10 +1068,10 @@
 CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -955,9 +1081,12 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
diff -Naur linux-2.6.14/arch/mips/configs/ip27_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ip27_defconfig
--- linux-2.6.14/arch/mips/configs/ip27_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ip27_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:04 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:37 2005
 #
 CONFIG_MIPS=y
-CONFIG_64BIT=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -13,25 +11,31 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=15
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_CPUSETS=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +45,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,55 +62,85 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
 CONFIG_SGI_IP27=y
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 # CONFIG_SGI_SN0_N_MODE is not set
 CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
 CONFIG_NUMA=y
 # CONFIG_MAPPED_KERNEL is not set
 # CONFIG_REPLICATE_KTEXT is not set
 # CONFIG_REPLICATE_EXHANDLERS is not set
-# CONFIG_SGI_IP32 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
-# CONFIG_SNI_RM200_PCI is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_IP27=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=7
 CONFIG_ARC64=y
 CONFIG_BOOT_ELF64=y
-CONFIG_QL_ISP_A64=y
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -121,17 +156,42 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R10000=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_DISCONTIGMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_NEED_MULTIPLE_NODES=y
+# CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SMP=y
 CONFIG_NR_CPUS=64
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
 # CONFIG_MIPS_INSANE_LARGE is not set
 
 #
@@ -141,7 +201,6 @@
 CONFIG_PCI=y
 CONFIG_PCI_DOMAINS=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -150,10 +209,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -163,7 +218,7 @@
 #
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_BUILD_ELF64 is not set
+CONFIG_BUILD_ELF64=y
 CONFIG_MIPS32_COMPAT=y
 CONFIG_COMPAT=y
 CONFIG_MIPS32_O32=y
@@ -171,6 +226,111 @@
 CONFIG_BINFMT_ELF32=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_NET_SCHED=y
+# CONFIG_NET_SCH_CLK_JIFFIES is not set
+CONFIG_NET_SCH_CLK_GETTIMEOFDAY=y
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -179,7 +339,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -198,7 +363,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -210,7 +374,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
@@ -232,6 +395,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -241,8 +405,10 @@
 CONFIG_BLK_DEV_SD=y
 CONFIG_CHR_DEV_ST=y
 # CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+CONFIG_CHR_DEV_SCH=m
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -256,7 +422,8 @@
 #
 CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
 
 #
 # SCSI low-level drivers
@@ -270,27 +437,26 @@
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_SCSI_QLOGIC_FC is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLOGIC_1280=y
+CONFIG_SCSI_QLOGIC_1280_1040=y
 CONFIG_SCSI_QLA2XXX=y
 # CONFIG_SCSI_QLA21XX is not set
 # CONFIG_SCSI_QLA22XX is not set
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -313,11 +479,16 @@
 CONFIG_DM_SNAPSHOT=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
 
 #
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -330,107 +501,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-CONFIG_NET_SCHED=y
-# CONFIG_NET_SCH_CLK_JIFFIES is not set
-CONFIG_NET_SCH_CLK_GETTIMEOFDAY=y
-# CONFIG_NET_SCH_CLK_CPU is not set
-CONFIG_NET_SCH_CBQ=m
-CONFIG_NET_SCH_HTB=m
-CONFIG_NET_SCH_HFSC=m
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_SFQ=m
-CONFIG_NET_SCH_TEQL=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_SCH_GRED=m
-CONFIG_NET_SCH_DSMARK=m
-CONFIG_NET_SCH_NETEM=m
-CONFIG_NET_SCH_INGRESS=m
-CONFIG_NET_QOS=y
-CONFIG_NET_ESTIMATOR=y
-CONFIG_NET_CLS=y
-CONFIG_NET_CLS_TCINDEX=m
-CONFIG_NET_CLS_ROUTE4=m
-CONFIG_NET_CLS_ROUTE=y
-CONFIG_NET_CLS_FW=m
-CONFIG_NET_CLS_U32=m
-# CONFIG_CLS_U32_PERF is not set
-# CONFIG_NET_CLS_IND is not set
-CONFIG_NET_CLS_RSVP=m
-CONFIG_NET_CLS_RSVP6=m
-# CONFIG_NET_CLS_ACT is not set
-CONFIG_NET_CLS_POLICE=y
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -438,15 +515,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
-CONFIG_SGI_IOC3_ETH=y
-CONFIG_SGI_IOC3_ETH_HW_RX_CSUM=y
-CONFIG_SGI_IOC3_ETH_HW_TX_CSUM=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -466,12 +556,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -484,6 +578,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -496,6 +592,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -513,25 +611,15 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_LIBPS2=m
 CONFIG_SERIO_RAW=m
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -549,7 +637,6 @@
 CONFIG_SERIAL_8250_MANY_PORTS=y
 CONFIG_SERIAL_8250_SHARE_IRQ=y
 # CONFIG_SERIAL_8250_DETECT_IRQ is not set
-# CONFIG_SERIAL_8250_MULTIPORT is not set
 # CONFIG_SERIAL_8250_RSA is not set
 
 #
@@ -557,6 +644,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -584,6 +672,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -594,10 +687,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -611,7 +714,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -621,13 +723,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -645,12 +743,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -662,17 +765,19 @@
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
+CONFIG_XFS_QUOTA=m
 CONFIG_XFS_SECURITY=y
 CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -693,12 +798,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -722,13 +825,14 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 # CONFIG_ROOT_NFS is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 CONFIG_SUNRPC_GSS=y
 CONFIG_RPCSEC_GSS_KRB5=y
@@ -738,6 +842,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -772,7 +877,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=15
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -788,28 +895,29 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
 CONFIG_CRYPTO_MD5=y
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA256=y
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=y
-CONFIG_CRYPTO_BLOWFISH=y
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-CONFIG_CRYPTO_CAST5=y
-CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -819,9 +927,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ip32_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ip32_defconfig
--- linux-2.6.14/arch/mips/configs/ip32_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ip32_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:04 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:40 2005
 #
 CONFIG_MIPS=y
-CONFIG_64BIT=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -13,11 +11,13 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -25,13 +25,16 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,42 +54,71 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 CONFIG_SGI_IP32=y
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_IP32=y
-CONFIG_OWN_DMA=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_OWN_DMA=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -95,8 +128,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -112,6 +147,17 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5000=y
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -119,9 +165,22 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_R5000_CPU_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
+# CONFIG_MIPS_MT is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
 # CONFIG_PREEMPT is not set
 
 #
@@ -130,7 +189,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -139,10 +197,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -160,6 +214,80 @@
 CONFIG_BINFMT_ELF32=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -168,7 +296,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
 
 #
 # Memory Technology Devices (MTD)
@@ -187,7 +320,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -199,7 +331,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
@@ -221,6 +352,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -233,6 +365,7 @@
 CONFIG_BLK_DEV_SR=y
 CONFIG_BLK_DEV_SR_VENDOR=y
 CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -244,9 +377,10 @@
 #
 # SCSI Transport Attributes
 #
-# CONFIG_SCSI_SPI_ATTRS is not set
+CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
 
 #
 # SCSI low-level drivers
@@ -265,19 +399,15 @@
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=y
@@ -286,6 +416,8 @@
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -299,6 +431,9 @@
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -311,78 +446,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -390,6 +460,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -397,6 +482,7 @@
 CONFIG_SGI_O2MACE_ETH=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -416,12 +502,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -434,6 +524,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -446,6 +538,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -475,27 +569,25 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_MACEPS2 is not set
 # CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -518,6 +610,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -544,6 +637,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -554,10 +652,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -577,7 +685,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -587,13 +694,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -611,21 +714,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -646,13 +757,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -676,13 +784,14 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -691,6 +800,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -721,7 +831,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -735,7 +847,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -745,7 +881,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/it8172_defconfig linux-mips-2.6.14.orig/arch/mips/configs/it8172_defconfig
--- linux-2.6.14/arch/mips/configs/it8172_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/it8172_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:05 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:43 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,11 +11,13 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -26,13 +25,16 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,41 +60,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 CONFIG_MIPS_ITE8172=y
-# CONFIG_IT8172_REVC is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_IT8172_REVC is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_ITE_BOARD_GEN=y
 CONFIG_IT8172_CIR=y
 CONFIG_IT8712=y
@@ -100,8 +131,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -117,14 +150,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5432=y
+CONFIG_SYS_HAS_CPU_NEVADA=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -140,10 +198,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -155,6 +209,80 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -166,12 +294,17 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_PARTITIONS is not set
 # CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_PARTITIONS is not set
 
 #
 # User Modules And Translation Layers
@@ -207,7 +340,6 @@
 # CONFIG_MTD_RAM is not set
 # CONFIG_MTD_ROM is not set
 # CONFIG_MTD_ABSENT is not set
-# CONFIG_MTD_XIP is not set
 
 #
 # Mapping drivers for chip access
@@ -217,6 +349,7 @@
 CONFIG_MTD_PHYSMAP_START=0x8000000
 CONFIG_MTD_PHYSMAP_LEN=0x2000000
 CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -251,14 +384,12 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -302,6 +433,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -312,6 +444,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -322,78 +455,28 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
+# Network device support
 #
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# SCTP Configuration (EXPERIMENTAL)
+# PHY device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# QoS and/or fair queueing
+# MII PHY device drivers
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -426,6 +509,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -455,18 +540,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -476,6 +549,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -521,10 +604,13 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -535,10 +621,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -558,7 +654,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -574,15 +669,9 @@
 # Open Sound System
 #
 CONFIG_SOUND_PRIME=y
-# CONFIG_SOUND_BT878 is not set
-# CONFIG_SOUND_FUSION is not set
-# CONFIG_SOUND_CS4281 is not set
-# CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_IT8172=y
-# CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_AD1980 is not set
 
 #
@@ -592,10 +681,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -608,24 +693,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -646,12 +738,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -682,7 +772,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -691,6 +781,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -711,7 +802,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -725,7 +818,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -735,7 +852,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ivr_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ivr_defconfig
--- linux-2.6.14/arch/mips/configs/ivr_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ivr_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:05 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:46 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,11 +11,13 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
@@ -26,13 +25,16 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,40 +60,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 CONFIG_MIPS_IVR=y
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_ITE_BOARD_GEN=y
 CONFIG_IT8172_CIR=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -98,8 +129,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -115,14 +148,38 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_NEVADA=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -131,7 +188,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -140,10 +196,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -156,6 +208,80 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -164,7 +290,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -183,7 +314,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -194,7 +324,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -239,6 +368,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -249,6 +379,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -261,78 +392,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -340,12 +406,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -365,12 +447,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -383,6 +469,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -394,6 +482,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -423,19 +513,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -445,6 +522,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -467,6 +555,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -492,6 +581,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -502,10 +596,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -525,7 +629,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -535,13 +638,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -559,21 +658,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -594,12 +701,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -628,7 +733,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -637,6 +742,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -657,7 +763,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -671,7 +779,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -681,7 +813,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/jaguar-atx_defconfig linux-mips-2.6.14.orig/arch/mips/configs/jaguar-atx_defconfig
--- linux-2.6.14/arch/mips/configs/jaguar-atx_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/jaguar-atx_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:05 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:50 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 # CONFIG_EXPERIMENTAL is not set
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -54,36 +57,70 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+CONFIG_MOMENCO_JAGUAR_ATX=y
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-CONFIG_MOMENCO_JAGUAR_ATX=y
-CONFIG_JAGUAR_DMALOW=y
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_JAGUAR_DMALOW=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_LIMITED_DMA=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_IRQ_MV64340=y
@@ -95,8 +132,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -112,6 +151,17 @@
 # CONFIG_CPU_RM7000 is not set
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_RM9000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -119,13 +169,24 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_HIGHMEM=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_SYS_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
 # CONFIG_SMP is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -134,7 +195,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -143,10 +203,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -158,6 +214,68 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
+# CONFIG_NETFILTER is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -166,7 +284,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -185,7 +308,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -195,7 +317,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -218,6 +339,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -228,6 +350,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -240,58 +363,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
+# Network device support
 #
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -304,12 +377,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -343,9 +432,11 @@
 # CONFIG_NS83820 is not set
 # CONFIG_HAMACHI is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 CONFIG_MV643XX_ETH=y
 CONFIG_MV643XX_ETH_0=y
 CONFIG_MV643XX_ETH_1=y
@@ -354,6 +445,7 @@
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -366,6 +458,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -374,6 +468,8 @@
 # CONFIG_FDDI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -391,20 +487,10 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -425,6 +511,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -451,6 +538,10 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -461,10 +552,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -478,7 +579,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -488,13 +588,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -512,6 +608,10 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -519,13 +619,16 @@
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -546,10 +649,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -570,7 +673,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
@@ -591,7 +694,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -605,7 +710,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -615,7 +744,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=m
+CONFIG_CRC32=m
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/jmr3927_defconfig linux-mips-2.6.14.orig/arch/mips/configs/jmr3927_defconfig
--- linux-2.6.14/arch/mips/configs/jmr3927_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/jmr3927_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:06 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:53 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,40 +53,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-CONFIG_TOSHIBA_JMR3927=y
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+CONFIG_TOSHIBA_JMR3927=y
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_MIPS_TX3927=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -92,8 +123,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 CONFIG_CPU_TX39XX=y
 # CONFIG_CPU_VR41XX is not set
@@ -109,12 +142,34 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_TX39XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 CONFIG_RTC_DS1742=y
 
@@ -124,7 +179,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -133,10 +187,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -149,6 +199,80 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -157,7 +281,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
 
 #
 # Memory Technology Devices (MTD)
@@ -176,7 +305,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -187,7 +315,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -210,6 +337,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -220,6 +348,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -232,78 +361,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -311,12 +375,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -336,12 +416,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -354,6 +438,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -365,6 +451,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -394,19 +482,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -416,6 +491,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -426,11 +512,9 @@
 # CONFIG_ROCKETPORT is not set
 # CONFIG_CYCLADES is not set
 # CONFIG_DIGIEPCA is not set
-# CONFIG_DIGI is not set
 # CONFIG_MOXA_INTELLIO is not set
 # CONFIG_MOXA_SMARTIO is not set
 # CONFIG_ISI is not set
-# CONFIG_SYNCLINK is not set
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
 # CONFIG_RISCOM8 is not set
@@ -438,10 +522,6 @@
 # CONFIG_SX is not set
 # CONFIG_RIO is not set
 # CONFIG_STALDRV is not set
-# CONFIG_SERIAL_TX3912 is not set
-CONFIG_TXX927_SERIAL=y
-CONFIG_TXX927_SERIAL_CONSOLE=y
-# CONFIG_SERIAL_TXX9 is not set
 
 #
 # Serial drivers
@@ -451,6 +531,8 @@
 #
 # Non-8250 serial port support
 #
+CONFIG_HAS_TXX9_SERIAL=y
+# CONFIG_SERIAL_JSM is not set
 # CONFIG_UNIX98_PTYS is not set
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -477,6 +559,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -487,10 +574,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -504,6 +601,11 @@
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
+# CONFIG_FB_MACMODES is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -511,6 +613,7 @@
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -523,8 +626,11 @@
 # CONFIG_FB_KYRO is not set
 # CONFIG_FB_3DFX is not set
 # CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_SMIVGX is not set
+# CONFIG_FB_CYBLA is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_E1356 is not set
+# CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
 
 #
@@ -548,13 +654,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -572,6 +674,10 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -579,13 +685,16 @@
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -606,10 +715,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -638,7 +747,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -647,6 +756,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -667,7 +777,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -681,7 +793,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -691,7 +827,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/lasat200_defconfig linux-mips-2.6.14.orig/arch/mips/configs/lasat200_defconfig
--- linux-2.6.14/arch/mips/configs/lasat200_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/lasat200_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:06 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:54:57 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,53 +59,83 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-CONFIG_LASAT=y
-CONFIG_PICVUE=y
-CONFIG_PICVUE_PROC=y
-CONFIG_DS1603=y
-CONFIG_LASAT_SYSCTL=y
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+CONFIG_LASAT=y
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_PICVUE=y
+CONFIG_PICVUE_PROC=y
+CONFIG_DS1603=y
+CONFIG_LASAT_SYSCTL=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_MIPS_NILE4=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -118,17 +151,41 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R5000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
 CONFIG_R5000_CPU_SCACHE=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -137,7 +194,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-# CONFIG_PCI_NAMES is not set
 CONFIG_MMU=y
 
 #
@@ -146,10 +202,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -162,6 +214,76 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -170,15 +292,20 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -223,6 +350,7 @@
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
 CONFIG_MTD_LASAT=y
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -258,7 +386,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -269,7 +396,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -326,6 +452,7 @@
 # CONFIG_BLK_DEV_HPT366 is not set
 # CONFIG_BLK_DEV_SC1200 is not set
 # CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_PDC202XX_OLD is not set
 # CONFIG_BLK_DEV_PDC202XX_NEW is not set
@@ -343,6 +470,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -353,6 +481,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -365,68 +494,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-# CONFIG_NETLINK_DEV is not set
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
+# Network device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -439,12 +508,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -464,12 +549,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -482,6 +571,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -493,6 +584,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -522,19 +615,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -544,6 +624,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -564,6 +655,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -590,6 +682,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -600,10 +697,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -623,7 +730,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -633,13 +739,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -657,10 +759,15 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -670,13 +777,16 @@
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -697,12 +807,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -728,12 +836,13 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -742,6 +851,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -762,7 +872,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -776,7 +888,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -786,7 +922,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/malta_defconfig linux-mips-2.6.14.orig/arch/mips/configs/malta_defconfig
--- linux-2.6.14/arch/mips/configs/malta_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/malta_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:53:14 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:02 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,44 +59,75 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 CONFIG_MIPS_MALTA=y
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_GENERIC_ISA_DMA=y
 CONFIG_I8259=y
 CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_MSC=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
@@ -104,8 +138,10 @@
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -121,14 +157,48 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_SYS_HAS_CPU_MIPS64_R1=y
+CONFIG_SYS_HAS_CPU_NEVADA=y
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT=y
+# CONFIG_MIPS_MT_SMP is not set
+CONFIG_MIPS_VPE_LOADER=y
+CONFIG_MIPS_VPE_LOADER_TOM=y
+CONFIG_MIPS_VPE_APSP_API=y
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -137,7 +207,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -146,10 +215,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -162,229 +227,7 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-CONFIG_BLK_DEV_FD=m
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-CONFIG_BLK_DEV_UMEM=m
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=m
-CONFIG_BLK_DEV_CRYPTOLOOP=m
-CONFIG_BLK_DEV_NBD=m
-# CONFIG_BLK_DEV_SX8 is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-# CONFIG_BLK_DEV_INITRD is not set
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-CONFIG_ATA_OVER_ETH=m
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-CONFIG_BLK_DEV_IDECD=y
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_IDE_GENERIC=y
-CONFIG_BLK_DEV_IDEPCI=y
-# CONFIG_IDEPCI_SHARE_IRQ is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-CONFIG_BLK_DEV_GENERIC=y
-# CONFIG_BLK_DEV_OPTI621 is not set
-CONFIG_BLK_DEV_IDEDMA_PCI=y
-# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
-CONFIG_IDEDMA_PCI_AUTO=y
-# CONFIG_IDEDMA_ONLYDISK is not set
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_HPT34X is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_SC1200 is not set
-CONFIG_BLK_DEV_PIIX=y
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-# CONFIG_BLK_DEV_SIIMAGE is not set
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-# CONFIG_IDE_ARM is not set
-CONFIG_BLK_DEV_IDEDMA=y
-# CONFIG_IDEDMA_IVB is not set
-CONFIG_IDEDMA_AUTO=y
-# CONFIG_BLK_DEV_HD is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI=m
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=m
-CONFIG_CHR_DEV_ST=m
-CONFIG_CHR_DEV_OSST=m
-CONFIG_BLK_DEV_SR=m
-CONFIG_BLK_DEV_SR_VENDOR=y
-CONFIG_CHR_DEV_SG=m
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_SCSI_CONSTANTS=y
-CONFIG_SCSI_LOGGING=y
-
-#
-# SCSI Transport Attributes
-#
-CONFIG_SCSI_SPI_ATTRS=m
-CONFIG_SCSI_FC_ATTRS=m
-CONFIG_SCSI_ISCSI_ATTRS=m
-
-#
-# SCSI low-level drivers
-#
-CONFIG_BLK_DEV_3W_XXXX_RAID=m
-CONFIG_SCSI_3W_9XXX=m
-CONFIG_SCSI_ACARD=m
-CONFIG_SCSI_AACRAID=m
-CONFIG_SCSI_AIC7XXX=m
-CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
-CONFIG_AIC7XXX_RESET_DELAY_MS=15000
-# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
-CONFIG_AIC7XXX_DEBUG_MASK=0
-CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
-# CONFIG_SCSI_QLOGIC_FC is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-CONFIG_SCSI_QLA2XXX=m
-# CONFIG_SCSI_QLA21XX is not set
-# CONFIG_SCSI_QLA22XX is not set
-# CONFIG_SCSI_QLA2300 is not set
-# CONFIG_SCSI_QLA2322 is not set
-# CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-CONFIG_MD=y
-CONFIG_BLK_DEV_MD=m
-CONFIG_MD_LINEAR=m
-CONFIG_MD_RAID0=m
-CONFIG_MD_RAID1=m
-CONFIG_MD_RAID10=m
-CONFIG_MD_RAID5=m
-CONFIG_MD_RAID6=m
-CONFIG_MD_MULTIPATH=m
-CONFIG_MD_FAULTY=m
-CONFIG_BLK_DEV_DM=m
-CONFIG_DM_CRYPT=m
-CONFIG_DM_SNAPSHOT=m
-CONFIG_DM_MIRROR=m
-CONFIG_DM_ZERO=m
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# I2O device support
-#
-# CONFIG_I2O is not set
-
-#
-# Networking support
+# Networking
 #
 CONFIG_NET=y
 
@@ -393,15 +236,20 @@
 #
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
 CONFIG_NET_KEY=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
 CONFIG_IP_MULTIPLE_TABLES=y
 CONFIG_IP_ROUTE_FWMARK=y
 CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
 CONFIG_IP_ROUTE_VERBOSE=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
@@ -419,8 +267,10 @@
 CONFIG_INET_ESP=m
 CONFIG_INET_IPCOMP=m
 CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-CONFIG_IP_TCPDIAG_IPV6=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
 
 #
 # IP: Virtual Server Configuration
@@ -465,6 +315,9 @@
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
 CONFIG_BRIDGE_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
 
 #
 # IP: Netfilter Configuration
@@ -472,11 +325,15 @@
 CONFIG_IP_NF_CONNTRACK=m
 CONFIG_IP_NF_CT_ACCT=y
 CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CONNTRACK_EVENTS=y
+CONFIG_IP_NF_CONNTRACK_NETLINK=m
 CONFIG_IP_NF_CT_PROTO_SCTP=m
 CONFIG_IP_NF_FTP=m
 CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
 CONFIG_IP_NF_TFTP=m
 CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_PPTP=m
 CONFIG_IP_NF_QUEUE=m
 CONFIG_IP_NF_IPTABLES=m
 CONFIG_IP_NF_MATCH_LIMIT=m
@@ -501,14 +358,18 @@
 CONFIG_IP_NF_MATCH_ADDRTYPE=m
 CONFIG_IP_NF_MATCH_REALM=m
 CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_DCCP=m
 CONFIG_IP_NF_MATCH_COMMENT=m
 CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_CONNBYTES=m
 CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_MATCH_STRING=m
 CONFIG_IP_NF_FILTER=m
 CONFIG_IP_NF_TARGET_REJECT=m
 CONFIG_IP_NF_TARGET_LOG=m
 CONFIG_IP_NF_TARGET_ULOG=m
 CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_TARGET_NFQUEUE=m
 CONFIG_IP_NF_NAT=m
 CONFIG_IP_NF_NAT_NEEDED=y
 CONFIG_IP_NF_TARGET_MASQUERADE=m
@@ -520,12 +381,14 @@
 CONFIG_IP_NF_NAT_FTP=m
 CONFIG_IP_NF_NAT_TFTP=m
 CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_PPTP=m
 CONFIG_IP_NF_MANGLE=m
 CONFIG_IP_NF_TARGET_TOS=m
 CONFIG_IP_NF_TARGET_ECN=m
 CONFIG_IP_NF_TARGET_DSCP=m
 CONFIG_IP_NF_TARGET_MARK=m
 CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_TTL=m
 CONFIG_IP_NF_TARGET_CONNMARK=m
 CONFIG_IP_NF_TARGET_CLUSTERIP=m
 CONFIG_IP_NF_RAW=m
@@ -535,133 +398,376 @@
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_PHYSDEV=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_NFQUEUE=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_RAW=m
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=y
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+CONFIG_NET_DIVERT=y
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_NET_CLS_IND=y
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+CONFIG_BLK_DEV_FD=m
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+CONFIG_BLK_DEV_UMEM=m
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_LBD is not set
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+# CONFIG_IDEPCI_SHARE_IRQ is not set
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
 #
-CONFIG_IP6_NF_QUEUE=m
-CONFIG_IP6_NF_IPTABLES=m
-CONFIG_IP6_NF_MATCH_LIMIT=m
-CONFIG_IP6_NF_MATCH_MAC=m
-CONFIG_IP6_NF_MATCH_RT=m
-CONFIG_IP6_NF_MATCH_OPTS=m
-CONFIG_IP6_NF_MATCH_FRAG=m
-CONFIG_IP6_NF_MATCH_HL=m
-CONFIG_IP6_NF_MATCH_MULTIPORT=m
-CONFIG_IP6_NF_MATCH_OWNER=m
-CONFIG_IP6_NF_MATCH_MARK=m
-CONFIG_IP6_NF_MATCH_IPV6HEADER=m
-CONFIG_IP6_NF_MATCH_AHESP=m
-CONFIG_IP6_NF_MATCH_LENGTH=m
-CONFIG_IP6_NF_MATCH_EUI64=m
-CONFIG_IP6_NF_MATCH_PHYSDEV=m
-CONFIG_IP6_NF_FILTER=m
-CONFIG_IP6_NF_TARGET_LOG=m
-CONFIG_IP6_NF_MANGLE=m
-CONFIG_IP6_NF_TARGET_MARK=m
-CONFIG_IP6_NF_RAW=m
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
 
 #
-# Bridge: Netfilter Configuration
+# SCSI support type (disk, tape, CD-ROM)
 #
-CONFIG_BRIDGE_NF_EBTABLES=m
-CONFIG_BRIDGE_EBT_BROUTE=m
-CONFIG_BRIDGE_EBT_T_FILTER=m
-CONFIG_BRIDGE_EBT_T_NAT=m
-CONFIG_BRIDGE_EBT_802_3=m
-CONFIG_BRIDGE_EBT_AMONG=m
-CONFIG_BRIDGE_EBT_ARP=m
-CONFIG_BRIDGE_EBT_IP=m
-CONFIG_BRIDGE_EBT_LIMIT=m
-CONFIG_BRIDGE_EBT_MARK=m
-CONFIG_BRIDGE_EBT_PKTTYPE=m
-CONFIG_BRIDGE_EBT_STP=m
-CONFIG_BRIDGE_EBT_VLAN=m
-CONFIG_BRIDGE_EBT_ARPREPLY=m
-CONFIG_BRIDGE_EBT_DNAT=m
-CONFIG_BRIDGE_EBT_MARK_T=m
-CONFIG_BRIDGE_EBT_REDIRECT=m
-CONFIG_BRIDGE_EBT_SNAT=m
-CONFIG_BRIDGE_EBT_LOG=m
-CONFIG_BRIDGE_EBT_ULOG=m
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
+CONFIG_BLK_DEV_SD=m
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=m
+# CONFIG_CHR_DEV_SCH is not set
 
 #
-# SCTP Configuration (EXPERIMENTAL)
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-CONFIG_IP_SCTP=m
-# CONFIG_SCTP_DBG_MSG is not set
-# CONFIG_SCTP_DBG_OBJCNT is not set
-# CONFIG_SCTP_HMAC_NONE is not set
-# CONFIG_SCTP_HMAC_SHA1 is not set
-CONFIG_SCTP_HMAC_MD5=y
-# CONFIG_ATM is not set
-CONFIG_BRIDGE=m
-CONFIG_VLAN_8021Q=m
-# CONFIG_DECNET is not set
-CONFIG_LLC=m
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-CONFIG_ATALK=m
-CONFIG_DEV_APPLETALK=y
-CONFIG_IPDDP=m
-CONFIG_IPDDP_ENCAP=y
-CONFIG_IPDDP_DECAP=y
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-CONFIG_NET_DIVERT=y
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
 
 #
-# QoS and/or fair queueing
+# SCSI Transport Attributes
 #
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CLK_JIFFIES=y
-# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
-# CONFIG_NET_SCH_CLK_CPU is not set
-CONFIG_NET_SCH_CBQ=m
-CONFIG_NET_SCH_HTB=m
-CONFIG_NET_SCH_HFSC=m
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_SFQ=m
-CONFIG_NET_SCH_TEQL=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_SCH_GRED=m
-CONFIG_NET_SCH_DSMARK=m
-CONFIG_NET_SCH_NETEM=m
-CONFIG_NET_SCH_INGRESS=m
-CONFIG_NET_QOS=y
-CONFIG_NET_ESTIMATOR=y
-CONFIG_NET_CLS=y
-CONFIG_NET_CLS_TCINDEX=m
-CONFIG_NET_CLS_ROUTE4=m
-CONFIG_NET_CLS_ROUTE=y
-CONFIG_NET_CLS_FW=m
-CONFIG_NET_CLS_U32=m
-# CONFIG_CLS_U32_PERF is not set
-CONFIG_NET_CLS_IND=y
-# CONFIG_CLS_U32_MARK is not set
-CONFIG_NET_CLS_RSVP=m
-CONFIG_NET_CLS_RSVP6=m
-# CONFIG_NET_CLS_ACT is not set
-CONFIG_NET_CLS_POLICE=y
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
 
 #
-# Network testing
+# SCSI low-level drivers
+#
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+CONFIG_SCSI_3W_9XXX=m
+CONFIG_SCSI_ACARD=m
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=m
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID5=m
+CONFIG_MD_RAID6=m
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 CONFIG_DUMMY=m
 CONFIG_BONDING=m
 CONFIG_EQUALIZER=m
 CONFIG_TUN=m
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -669,12 +775,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -713,13 +835,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -732,6 +858,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -744,6 +872,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -773,19 +903,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -795,6 +912,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -815,6 +943,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -840,6 +969,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -850,10 +984,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -873,7 +1017,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -883,13 +1026,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -907,10 +1046,15 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -931,12 +1075,14 @@
 # CONFIG_JFS_STATISTICS is not set
 CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
+CONFIG_XFS_EXPORT=y
+CONFIG_XFS_QUOTA=m
 CONFIG_XFS_SECURITY=y
 CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
 CONFIG_MINIX_FS=m
 CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
 CONFIG_QUOTA=y
 # CONFIG_QFMT_V1 is not set
 CONFIG_QFMT_V2=y
@@ -944,6 +1090,7 @@
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -971,12 +1118,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -1002,16 +1147,19 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 # CONFIG_NFSD_TCP is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -1020,6 +1168,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -1079,7 +1228,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -1101,6 +1252,7 @@
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -1125,9 +1277,12 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
diff -Naur linux-2.6.14/arch/mips/configs/mipssim_defconfig linux-mips-2.6.14.orig/arch/mips/configs/mipssim_defconfig
--- linux-2.6.14/arch/mips/configs/mipssim_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/configs/mipssim_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,775 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:06 2005
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+# CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+CONFIG_MIPS_SIM=y
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_IRQ_CPU=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT=y
+# CONFIG_MIPS_MT_SMP is not set
+CONFIG_MIPS_VPE_LOADER=y
+CONFIG_MIPS_VPE_LOADER_TOM=y
+CONFIG_MIPS_VPE_APSP_API=y
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+CONFIG_NET_DIVERT=y
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+# CONFIG_NET_CLS_POLICE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_MIPS_SIM_NET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB_ARCH_HAS_HCD is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_INOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+# CONFIG_SYSFS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="nfsroot=192.168.192.169:/u1/mipsel,timeo=20 ip=dhcp"
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_KGDB is not set
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_MIPS_UNCACHED is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14/arch/mips/configs/mpc30x_defconfig linux-mips-2.6.14.orig/arch/mips/configs/mpc30x_defconfig
--- linux-2.6.14/arch/mips/configs/mpc30x_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/mpc30x_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:07 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:10 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,57 +59,86 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-CONFIG_VICTOR_MPC30X=y
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_PCI_VR41XX=y
-CONFIG_VRC4173=y
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB022X is not set
+CONFIG_VICTOR_MPC30X=y
+# CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
+CONFIG_VRC4173=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 CONFIG_CPU_VR41XX=y
@@ -122,12 +154,36 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_VR41XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -136,17 +192,25 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
 # PCCARD (PCMCIA/CardBus) support
 #
-# CONFIG_PCCARD is not set
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+# CONFIG_CARDBUS is not set
 
 #
 # PC-card bridges
 #
+# CONFIG_YENTA is not set
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCMCIA_VRC4173=y
 
 #
 # PCI Hotplug Support
@@ -161,6 +225,78 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -169,7 +305,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -188,7 +329,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -197,13 +337,11 @@
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -217,11 +355,35 @@
 #
 # ATA/ATAPI/MFM/RLL support
 #
-# CONFIG_IDE is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
 
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -232,6 +394,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -244,79 +407,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -324,20 +421,14 @@
 # CONFIG_ARCNET is not set
 
 #
-# Ethernet (10 or 100Mbit)
+# PHY device support
 #
-CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
 
 #
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+CONFIG_MII=m
 
 #
 # Ethernet (1000 Mbit)
@@ -349,12 +440,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -366,7 +461,59 @@
 #
 # Wireless LAN (non-hamradio)
 #
-# CONFIG_NET_RADIO is not set
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_PCMCIA_WAVELAN is not set
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+CONFIG_HERMES=m
+# CONFIG_PLX_HERMES is not set
+# CONFIG_TMD_HERMES is not set
+# CONFIG_NORTEL_HERMES is not set
+# CONFIG_PCI_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+CONFIG_PCMCIA_HERMES=m
+# CONFIG_PCMCIA_SPECTRUM is not set
+# CONFIG_AIRO_CS is not set
+# CONFIG_PCMCIA_WL3501 is not set
+
+#
+# Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
+#
+# CONFIG_PRISM54 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_PCMCIA_XIRC2PS=m
+CONFIG_PCMCIA_AXNET=m
 
 #
 # Wan interfaces
@@ -378,6 +525,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -407,19 +556,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -429,6 +565,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -439,16 +586,16 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VR41XX=y
+CONFIG_SERIAL_VR41XX_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -472,9 +619,20 @@
 # Ftape, the floppy tape device driver
 #
 # CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+CONFIG_GPIO_VR41XX=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -485,10 +643,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -508,7 +676,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -518,13 +685,120 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
 
 #
 # NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
 #
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=m
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
 
 #
 # USB Gadget Support
@@ -542,21 +816,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -577,12 +859,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -609,9 +889,8 @@
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -620,6 +899,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -640,9 +920,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE=""
+CONFIG_CMDLINE="mem=32M console=ttyVR0,19200"
 
 #
 # Security options
@@ -656,26 +938,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -687,9 +970,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
+CONFIG_CRC16=m
+CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/ocelot_3_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ocelot_3_defconfig
--- linux-2.6.14/arch/mips/configs/ocelot_3_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ocelot_3_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:07 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:14 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,25 +11,30 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,40 +60,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 CONFIG_MOMENCO_OCELOT_3=y
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_IRQ_MV64340=y
@@ -102,8 +133,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -119,6 +152,17 @@
 # CONFIG_CPU_RM7000 is not set
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_RM9000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -126,13 +170,26 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
-# CONFIG_HIGHMEM is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
 # CONFIG_SMP is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -141,7 +198,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -150,10 +206,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -166,6 +218,109 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -174,7 +329,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -193,7 +353,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -205,7 +364,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
 
@@ -226,6 +384,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 CONFIG_SCSI=m
 CONFIG_SCSI_PROC_FS=y
 
@@ -237,6 +396,7 @@
 # CONFIG_CHR_DEV_OSST is not set
 # CONFIG_BLK_DEV_SR is not set
 # CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -251,6 +411,7 @@
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=m
 
 #
 # SCSI low-level drivers
@@ -265,19 +426,15 @@
 # CONFIG_SCSI_DPT_I2O is not set
 # CONFIG_MEGARAID_NEWGEN is not set
 # CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INITIO is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=m
@@ -286,6 +443,8 @@
 # CONFIG_SCSI_QLA2300 is not set
 # CONFIG_SCSI_QLA2322 is not set
 # CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_NSP32 is not set
@@ -300,6 +459,9 @@
 # Fusion MPT device support
 #
 # CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -312,105 +474,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=m
-CONFIG_IP_TCPDIAG_IPV6=y
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-CONFIG_IPV6=m
-# CONFIG_IPV6_PRIVACY is not set
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
-# CONFIG_INET6_TUNNEL is not set
-# CONFIG_IPV6_TUNNEL is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-# CONFIG_IP_NF_CONNTRACK_MARK is not set
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-
-#
-# IPv6: Netfilter Configuration
-#
-# CONFIG_IP6_NF_QUEUE is not set
-# CONFIG_IP6_NF_IPTABLES is not set
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 CONFIG_TUN=m
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -418,12 +488,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -440,7 +526,6 @@
 # CONFIG_DGRS is not set
 # CONFIG_EEPRO100 is not set
 CONFIG_E100=y
-# CONFIG_E100_NAPI is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
@@ -463,9 +548,12 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 CONFIG_MV643XX_ETH=y
 CONFIG_MV643XX_ETH_0=y
 CONFIG_MV643XX_ETH_1=y
@@ -474,6 +562,7 @@
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -486,6 +575,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -505,6 +596,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -531,19 +624,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -553,6 +633,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -573,6 +664,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -598,6 +690,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -608,10 +705,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -625,6 +732,11 @@
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
+# CONFIG_FB_MACMODES is not set
 CONFIG_FB_MODE_HELPERS=y
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -632,6 +744,7 @@
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -644,8 +757,11 @@
 # CONFIG_FB_KYRO is not set
 # CONFIG_FB_3DFX is not set
 # CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_SMIVGX is not set
+# CONFIG_FB_CYBLA is not set
 # CONFIG_FB_TRIDENT is not set
 # CONFIG_FB_E1356 is not set
+# CONFIG_FB_S1D13XXX is not set
 # CONFIG_FB_VIRTUAL is not set
 
 #
@@ -675,13 +791,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -699,10 +811,15 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=m
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -715,17 +832,21 @@
 # CONFIG_REISERFS_PROC_INFO is not set
 # CONFIG_REISERFS_FS_XATTR is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_QUOTA is not set
 # CONFIG_XFS_SECURITY is not set
 # CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -746,15 +867,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-CONFIG_DEVFS_FS=y
-CONFIG_DEVFS_MOUNT=y
-# CONFIG_DEVFS_DEBUG is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -778,16 +894,19 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 # CONFIG_NFSD_TCP is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -797,6 +916,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -856,7 +976,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=any root=nfs"
 
@@ -869,7 +991,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -879,9 +1025,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
diff -Naur linux-2.6.14/arch/mips/configs/ocelot_c_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ocelot_c_defconfig
--- linux-2.6.14/arch/mips/configs/ocelot_c_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ocelot_c_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:07 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:17 2005
 #
 CONFIG_MIPS=y
-CONFIG_64BIT=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -13,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -40,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -49,39 +53,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-CONFIG_MOMENCO_OCELOT_C=y
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+CONFIG_MOMENCO_OCELOT_C=y
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SGI_IP32 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_MV64340=y
 CONFIG_PCI_MARVELL=y
@@ -91,8 +124,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -108,6 +143,17 @@
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -115,9 +161,23 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -126,7 +186,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -135,10 +194,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -156,6 +211,79 @@
 CONFIG_BINFMT_ELF32=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -164,7 +292,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
 
 #
 # Memory Technology Devices (MTD)
@@ -183,7 +316,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -194,7 +326,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
@@ -216,6 +347,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -226,6 +358,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -238,77 +371,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -316,12 +385,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -341,13 +426,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 # CONFIG_MV643XX_ETH is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -360,6 +449,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -371,6 +462,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -400,19 +493,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -422,6 +502,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -442,6 +533,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -468,6 +560,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -478,10 +575,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -501,7 +608,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -511,13 +617,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -535,21 +637,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -570,12 +680,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -607,6 +715,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -615,6 +724,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -635,7 +745,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -649,7 +761,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -659,7 +795,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/ocelot_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ocelot_defconfig
--- linux-2.6.14/arch/mips/configs/ocelot_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ocelot_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:20 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,40 +53,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 CONFIG_MOMENCO_OCELOT=y
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_MIPS_GT64120=y
@@ -96,8 +127,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -113,6 +146,17 @@
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -120,11 +164,25 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -140,10 +198,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -155,6 +209,79 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -166,6 +293,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -182,13 +314,11 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -211,6 +341,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -221,6 +352,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -231,77 +363,28 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
+# Network device support
 #
-# CONFIG_PACKET is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
 
 #
 # Ethernet (10 or 100Mbit)
@@ -334,6 +417,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -363,18 +448,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -384,6 +457,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -425,10 +508,13 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -439,10 +525,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -462,7 +558,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -476,10 +571,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -492,24 +583,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -530,12 +628,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -567,6 +663,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -575,6 +672,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -595,7 +693,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -609,7 +709,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -619,7 +743,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/ocelot_g_defconfig linux-mips-2.6.14.orig/arch/mips/configs/ocelot_g_defconfig
--- linux-2.6.14/arch/mips/configs/ocelot_g_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/ocelot_g_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:23 2005
 #
 CONFIG_MIPS=y
-CONFIG_64BIT=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -13,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -40,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -49,39 +53,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-CONFIG_MOMENCO_OCELOT_G=y
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+CONFIG_MOMENCO_OCELOT_G=y
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SGI_IP32 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_PCI_MARVELL=y
@@ -94,8 +127,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -111,6 +146,17 @@
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_RM7000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -118,9 +164,23 @@
 CONFIG_BOARD_SCACHE=y
 CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -129,7 +189,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -138,10 +197,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -159,6 +214,79 @@
 CONFIG_BINFMT_ELF32=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
+
+#
 # Device Drivers
 #
 
@@ -167,7 +295,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
 
 #
 # Memory Technology Devices (MTD)
@@ -186,7 +319,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -197,7 +329,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CDROM_PKTCDVD=y
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
@@ -219,6 +350,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -229,6 +361,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -241,77 +374,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-# CONFIG_PACKET is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=y
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=y
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -319,6 +388,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -326,6 +410,7 @@
 CONFIG_GALILEO_64240_ETH=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -345,12 +430,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -363,6 +452,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=y
 
 #
 # Wan interfaces
@@ -374,6 +465,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -403,19 +496,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -425,6 +505,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -445,6 +536,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -471,6 +563,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -481,10 +578,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -504,7 +611,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -514,13 +620,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -538,21 +640,29 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -573,12 +683,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -610,6 +718,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -618,6 +727,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -638,7 +748,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -652,7 +764,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -662,7 +798,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=y
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/pb1100_defconfig linux-mips-2.6.14.orig/arch/mips/configs/pb1100_defconfig
--- linux-2.6.14/arch/mips/configs/pb1100_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/pb1100_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:27 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,56 +59,70 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+CONFIG_MIPS_PB1100=y
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-CONFIG_SOC_AU1100=y
-# CONFIG_SOC_AU1500 is not set
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-CONFIG_MIPS_PB1100=y
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1100=y
+CONFIG_SOC_AU1X00=y
 CONFIG_SWAP_IO_SPACE=y
 # CONFIG_AU1X00_USB_DEVICE is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -113,8 +130,10 @@
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -130,15 +149,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_MIPS_MT is not set
+CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -154,11 +197,12 @@
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
 CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 
 #
 # PC-card bridges
 #
-# CONFIG_TCIC is not set
 # CONFIG_PCMCIA_AU1X00 is not set
 
 #
@@ -171,6 +215,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -181,15 +318,20 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -233,9 +375,8 @@
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_PB1100=y
-CONFIG_MTD_PB1500_BOOT=y
-CONFIG_MTD_PB1500_USER=y
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
 
 #
 # Self-contained MTD device drivers
@@ -270,14 +411,12 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -300,6 +439,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -310,6 +450,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -320,94 +461,28 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
-#
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
+# Network device support
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -453,6 +528,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -482,18 +559,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -503,6 +568,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -534,14 +609,14 @@
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 
 #
 # PCMCIA character devices
@@ -550,6 +625,10 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -560,10 +639,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -583,7 +672,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -593,12 +681,9 @@
 #
 # USB support
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -613,7 +698,10 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
@@ -622,6 +710,7 @@
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -640,10 +729,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -664,13 +755,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -704,6 +792,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -713,6 +802,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -772,7 +862,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -788,26 +880,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -819,9 +912,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/pb1500_defconfig linux-mips-2.6.14.orig/arch/mips/configs/pb1500_defconfig
--- linux-2.6.14/arch/mips/configs/pb1500_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/pb1500_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:09 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:30 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,63 +59,80 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+CONFIG_MIPS_PB1500=y
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-CONFIG_SOC_AU1500=y
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-CONFIG_MIPS_PB1500=y
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1500=y
+CONFIG_SOC_AU1X00=y
 # CONFIG_AU1X00_USB_DEVICE is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -128,15 +148,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -145,7 +189,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -154,6 +197,8 @@
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
 CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 CONFIG_CARDBUS=y
 
 #
@@ -162,7 +207,6 @@
 # CONFIG_YENTA is not set
 CONFIG_PD6729=m
 # CONFIG_I82092 is not set
-# CONFIG_TCIC is not set
 # CONFIG_PCMCIA_AU1X00 is not set
 CONFIG_PCCARD_NONSTATIC=m
 
@@ -177,6 +221,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -187,12 +324,87 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -206,7 +418,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -218,7 +429,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -275,6 +485,7 @@
 CONFIG_BLK_DEV_HPT366=y
 # CONFIG_BLK_DEV_SC1200 is not set
 # CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_PDC202XX_OLD is not set
 # CONFIG_BLK_DEV_PDC202XX_NEW is not set
@@ -292,6 +503,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -302,6 +514,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -314,94 +527,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
+# Network device support
 #
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -409,6 +541,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -416,6 +563,7 @@
 CONFIG_MIPS_AU1X00_ENET=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -435,12 +583,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -453,6 +605,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # PCMCIA network device support
@@ -484,6 +638,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -513,19 +669,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -535,6 +678,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -554,6 +708,7 @@
 CONFIG_SERIAL_AU1X00_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -585,6 +740,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -595,10 +755,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -612,7 +782,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -622,13 +791,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -646,12 +811,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -670,10 +840,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -694,13 +866,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -712,6 +881,8 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -732,6 +903,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -741,6 +913,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -800,7 +973,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -816,27 +991,28 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
-# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
@@ -847,9 +1023,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/pb1550_defconfig linux-mips-2.6.14.orig/arch/mips/configs/pb1550_defconfig
--- linux-2.6.14/arch/mips/configs/pb1550_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/pb1550_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:09 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:34 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,63 +59,80 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+CONFIG_MIPS_PB1550=y
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-# CONFIG_SOC_AU1500 is not set
-CONFIG_SOC_AU1550=y
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-CONFIG_MIPS_PB1550=y
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1550=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -128,15 +148,39 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -145,7 +189,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -154,6 +197,8 @@
 CONFIG_PCCARD=m
 # CONFIG_PCMCIA_DEBUG is not set
 CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 CONFIG_CARDBUS=y
 
 #
@@ -162,7 +207,6 @@
 # CONFIG_YENTA is not set
 CONFIG_PD6729=m
 # CONFIG_I82092 is not set
-# CONFIG_TCIC is not set
 # CONFIG_PCMCIA_AU1X00 is not set
 CONFIG_PCCARD_NONSTATIC=m
 
@@ -177,6 +221,99 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -187,12 +324,87 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -206,7 +418,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -218,7 +429,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -275,6 +485,7 @@
 CONFIG_BLK_DEV_HPT366=y
 # CONFIG_BLK_DEV_SC1200 is not set
 # CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_PDC202XX_OLD is not set
 # CONFIG_BLK_DEV_PDC202XX_NEW is not set
@@ -292,6 +503,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -302,6 +514,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -314,94 +527,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-
-#
-# IP: Netfilter Configuration
+# Network device support
 #
-# CONFIG_IP_NF_CONNTRACK is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-# CONFIG_IP_NF_QUEUE is not set
-# CONFIG_IP_NF_IPTABLES is not set
-# CONFIG_IP_NF_ARPTABLES is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -409,6 +541,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -416,6 +563,7 @@
 CONFIG_MIPS_AU1X00_ENET=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -435,12 +583,16 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -453,6 +605,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # PCMCIA network device support
@@ -476,6 +630,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -505,19 +661,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -527,6 +670,17 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -546,6 +700,7 @@
 CONFIG_SERIAL_AU1X00_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -577,6 +732,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -587,10 +747,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -604,7 +774,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -614,13 +783,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -638,12 +803,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 # CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -662,10 +832,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -686,13 +858,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -704,6 +873,8 @@
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -724,6 +895,7 @@
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -733,6 +905,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -792,7 +965,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -808,26 +983,27 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-CONFIG_CRYPTO_TWOFISH=y
-# CONFIG_CRYPTO_SERPENT is not set
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
@@ -839,9 +1015,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/pnx8550-jbs_defconfig linux-mips-2.6.14.orig/arch/mips/configs/pnx8550-jbs_defconfig
--- linux-2.6.14/arch/mips/configs/pnx8550-jbs_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/configs/pnx8550-jbs_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,1072 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:38 2005
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+CONFIG_PNX8550_JBS=y
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_PNX8550=y
+CONFIG_SOC_PNX8550=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+CONFIG_CPU_R4X00=y
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R4X00=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+# CONFIG_PCI_LEGACY_PROC is not set
+# CONFIG_PCI_DEBUG is not set
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+CONFIG_BLK_DEV_IDESCSI=y
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+CONFIG_BLK_DEV_OFFBOARD=y
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+# CONFIG_IDEDMA_PCI_AUTO is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+CONFIG_BLK_DEV_HPT366=y
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+CONFIG_8139TOO_TUNE_TWISTER=y
+CONFIG_8139TOO_8129=y
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_IP3106 is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_DEBUG_SLAB=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_FS is not set
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE="console=ttyS1,38400n8 kgdb=ttyS0 root=/dev/nfs ip=bootp"
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_KGDB is not set
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_MIPS_UNCACHED is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -Naur linux-2.6.14/arch/mips/configs/pnx8550-v2pci_defconfig linux-mips-2.6.14.orig/arch/mips/configs/pnx8550-v2pci_defconfig
--- linux-2.6.14/arch/mips/configs/pnx8550-v2pci_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/configs/pnx8550-v2pci_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,1253 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:43 2005
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+# CONFIG_HOTPLUG is not set
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+CONFIG_PNX8550_V2PCI=y
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_PNX8550=y
+CONFIG_SOC_PNX8550=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+CONFIG_CPU_R4X00=y
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R4X00=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
+# CONFIG_64BIT_PHYS_ADDR is not set
+CONFIG_CPU_ADVANCED=y
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_NETLINK is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_IEEE80211 is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+CONFIG_BLK_DEV_CMD64X=y
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=m
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+# CONFIG_AIC7XXX_DEBUG_ENABLE is not set
+CONFIG_AIC7XXX_DEBUG_MASK=0
+# CONFIG_AIC7XXX_REG_PRETTY_PRINT is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+CONFIG_NATSEMI=y
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_IP3106 is not set
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=m
+CONFIG_I2C_CHARDEV=m
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=m
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON_OLD is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_SMIVGX is not set
+# CONFIG_FB_CYBLA is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_E1356 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+CONFIG_AUTOFS_FS=y
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_RELAYFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/qemu_defconfig linux-mips-2.6.14.orig/arch/mips/configs/qemu_defconfig
--- linux-2.6.14/arch/mips/configs/qemu_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/qemu_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.13-rc6
-# Mon Aug  8 11:49:54 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:45 2005
 #
 CONFIG_MIPS=y
 
@@ -17,6 +17,7 @@
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 # CONFIG_SWAP is not set
 # CONFIG_SYSVIPC is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
@@ -25,6 +26,7 @@
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
@@ -74,6 +76,7 @@
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
@@ -91,6 +94,7 @@
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
 # CONFIG_SIBYTE_SWARM is not set
 # CONFIG_SIBYTE_SENTOSA is not set
 # CONFIG_SIBYTE_RHONE is not set
@@ -105,7 +109,6 @@
 # CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 CONFIG_GENERIC_ISA_DMA=y
 CONFIG_I8259=y
@@ -119,7 +122,7 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32_R1 is not set
+CONFIG_CPU_MIPS32_R1=y
 # CONFIG_CPU_MIPS32_R2 is not set
 # CONFIG_CPU_MIPS64_R1 is not set
 # CONFIG_CPU_MIPS64_R2 is not set
@@ -127,7 +130,7 @@
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
 # CONFIG_CPU_R4300 is not set
-CONFIG_CPU_R4X00=y
+# CONFIG_CPU_R4X00 is not set
 # CONFIG_CPU_TX49XX is not set
 # CONFIG_CPU_R5000 is not set
 # CONFIG_CPU_R5432 is not set
@@ -138,9 +141,11 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
 CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
 CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
-CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
 
 #
 # Kernel type
@@ -151,15 +156,18 @@
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
 # CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
-CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_ARCH_FLATMEM_ENABLE=y
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_PREEMPT_NONE=y
 # CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
@@ -214,8 +222,8 @@
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_TUNNEL is not set
-CONFIG_IP_TCPDIAG=y
-# CONFIG_IP_TCPDIAG_IPV6 is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
 # CONFIG_TCP_CONG_ADVANCED is not set
 CONFIG_TCP_CONG_BIC=y
 # CONFIG_IPV6 is not set
@@ -232,9 +240,15 @@
 #
 # Network testing
 #
+# CONFIG_NET_PKTGEN is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=y
+CONFIG_IEEE80211_CRYPT_CCMP=y
+CONFIG_IEEE80211_CRYPT_TKIP=y
 
 #
 # Device Drivers
@@ -248,6 +262,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -265,13 +284,12 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
 # CONFIG_CDROM_PKTCDVD is not set
 
 #
@@ -291,6 +309,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -331,6 +350,21 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=y
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
@@ -351,7 +385,6 @@
 # CONFIG_ETH16I is not set
 CONFIG_NE2000=y
 # CONFIG_NET_PCI is not set
-# CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -470,7 +503,6 @@
 # I2C support
 #
 # CONFIG_I2C is not set
-# CONFIG_I2C_SENSOR is not set
 
 #
 # Dallas's 1-wire bus
@@ -481,12 +513,17 @@
 # Hardware Monitoring support
 #
 # CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
 
 #
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -532,7 +569,6 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
 
 #
 # SN Devices
@@ -547,10 +583,6 @@
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_FS_POSIX_ACL is not set
-
-#
-# XFS support
-#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -559,6 +591,7 @@
 # CONFIG_DNOTIFY is not set
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -576,11 +609,13 @@
 #
 # Pseudo filesystems
 #
-# CONFIG_PROC_FS is not set
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
 # CONFIG_SYSFS is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -634,12 +669,35 @@
 # Security options
 #
 # CONFIG_KEYS is not set
-# CONFIG_SECURITY is not set
 
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -649,7 +707,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/rbhma4500_defconfig linux-mips-2.6.14.orig/arch/mips/configs/rbhma4500_defconfig
--- linux-2.6.14/arch/mips/configs/rbhma4500_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/configs/rbhma4500_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -0,0 +1,1257 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:50 2005
+#
+CONFIG_MIPS=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_HOTPLUG=y
+# CONFIG_KOBJECT_UEVENT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_3 is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+CONFIG_TOSHIBA_RBTX4938=y
+
+#
+# Multiplex Pin Select
+#
+CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61=y
+# CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND is not set
+# CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SWAP_IO_SPACE=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+CONFIG_HAVE_STD_PC_SERIAL_PORT=y
+CONFIG_TOSHIBA_BOARDS=y
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+CONFIG_CPU_TX49XX=y
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_TX49XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
+CONFIG_CPU_ADVANCED=y
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_WB=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+# CONFIG_PCI_LEGACY_PROC is not set
+CONFIG_ISA=y
+CONFIG_MMU=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_GENERIC is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+# CONFIG_IDEDMA_PCI_AUTO is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+# CONFIG_SCSI is not set
+
+#
+# Old CD-ROM drivers (not SCSI, not IDE)
+#
+# CONFIG_CD_NO_IDESCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_ISA=y
+# CONFIG_E2100 is not set
+# CONFIG_EWRK3 is not set
+# CONFIG_EEXPRESS is not set
+# CONFIG_EEXPRESS_PRO is not set
+# CONFIG_HPLAN_PLUS is not set
+# CONFIG_HPLAN is not set
+# CONFIG_LP486E is not set
+# CONFIG_ETH16I is not set
+CONFIG_NE2000=y
+# CONFIG_SEEQ8005 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ARLAN is not set
+# CONFIG_WAVELAN is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Prism GT/Duette 802.11(a/b/g) PCI/Cardbus support
+#
+# CONFIG_PRISM54 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_HAS_TXX9_SERIAL=y
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia Capabilities Port drivers
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SOFT_CURSOR=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON_OLD is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+CONFIG_FB_ATY=y
+CONFIG_FB_ATY_CT=y
+# CONFIG_FB_ATY_GENERIC_LCD is not set
+# CONFIG_FB_ATY_XL_INIT is not set
+# CONFIG_FB_ATY_GX is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_SMIVGX is not set
+# CONFIG_FB_CYBLA is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_E1356 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+CONFIG_USB_YEALINK=m
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_ZD1201 is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_LD is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_SECURITY is not set
+# CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=m
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -Naur linux-2.6.14/arch/mips/configs/rm200_defconfig linux-mips-2.6.14.orig/arch/mips/configs/rm200_defconfig
--- linux-2.6.14/arch/mips/configs/rm200_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/rm200_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:09 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:55 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,11 +11,13 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_POSIX_MQUEUE=y
@@ -26,14 +25,17 @@
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -43,6 +45,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -58,43 +61,73 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 CONFIG_SNI_RM200_PCI=y
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
 CONFIG_GENERIC_ISA_DMA=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -106,8 +139,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -123,24 +158,49 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R4X00=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_SYS_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
 # CONFIG_PREEMPT is not set
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_EISA=y
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-# CONFIG_PCI_NAMES is not set
 CONFIG_ISA=y
 # CONFIG_EISA is not set
 CONFIG_MMU=y
@@ -151,11 +211,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -168,6 +223,283 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=m
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+CONFIG_NET_KEY=m
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+# CONFIG_IP_NF_CT_ACCT is not set
+CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CONNTRACK_EVENTS=y
+CONFIG_IP_NF_CONNTRACK_NETLINK=m
+CONFIG_IP_NF_CT_PROTO_SCTP=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_PPTP=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_PHYSDEV=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_IP_NF_MATCH_REALM=m
+CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_DCCP=m
+CONFIG_IP_NF_MATCH_COMMENT=m
+CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_MATCH_STRING=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_TARGET_NFQUEUE=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_IP_NF_NAT_SNMP_BASIC=m
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_PPTP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_TARGET_CONNMARK=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_TARGET_NOTRACK=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_PHYSDEV=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_NFQUEUE=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_RAW=m
+
+#
+# DECnet: Netfilter Configuration
+#
+CONFIG_DECNET_NF_GRABULATOR=m
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=m
+# CONFIG_VLAN_8021Q is not set
+CONFIG_DECNET=m
+# CONFIG_DECNET_ROUTER is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CLK_JIFFIES=y
+# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
+# CONFIG_NET_SCH_CLK_CPU is not set
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_NET_CLS_IND is not set
+# CONFIG_CLS_U32_MARK is not set
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
+# CONFIG_NET_CLS_ACT is not set
+CONFIG_NET_CLS_POLICE=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_BAYCOM_PAR is not set
+# CONFIG_BAYCOM_EPP is not set
+# CONFIG_YAM is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -176,7 +508,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -188,11 +525,11 @@
 #
 CONFIG_PARPORT=m
 CONFIG_PARPORT_PC=m
-CONFIG_PARPORT_PC_CML1=m
 CONFIG_PARPORT_SERIAL=m
 # CONFIG_PARPORT_PC_FIFO is not set
 # CONFIG_PARPORT_PC_SUPERIO is not set
-# CONFIG_PARPORT_OTHER is not set
+CONFIG_PARPORT_NOT_PC=y
+# CONFIG_PARPORT_GSC is not set
 CONFIG_PARPORT_1284=y
 
 #
@@ -204,7 +541,6 @@
 # Block devices
 #
 CONFIG_BLK_DEV_FD=m
-# CONFIG_BLK_DEV_XD is not set
 CONFIG_PARIDE=m
 CONFIG_PARIDE_PARPORT=m
 
@@ -249,7 +585,6 @@
 CONFIG_BLK_DEV_RAM=m
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -272,6 +607,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -283,384 +619,133 @@
 # CONFIG_CHR_DEV_OSST is not set
 CONFIG_BLK_DEV_SR=m
 CONFIG_BLK_DEV_SR_VENDOR=y
-# CONFIG_CHR_DEV_SG is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_MULTI_LUN is not set
-CONFIG_SCSI_CONSTANTS=y
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI Transport Attributes
-#
-CONFIG_SCSI_SPI_ATTRS=y
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_7000FASST is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_AHA152X is not set
-# CONFIG_SCSI_AHA1542 is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_IN2000 is not set
-CONFIG_MEGARAID_NEWGEN=y
-CONFIG_MEGARAID_MM=m
-CONFIG_MEGARAID_MAILBOX=m
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_DTC3280 is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_GENERIC_NCR5380 is not set
-# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-CONFIG_SCSI_PPA=m
-CONFIG_SCSI_IMM=m
-# CONFIG_SCSI_IZIP_EPP16 is not set
-# CONFIG_SCSI_IZIP_SLOW_CTR is not set
-# CONFIG_SCSI_NCR53C406A is not set
-CONFIG_SCSI_SYM53C8XX_2=y
-CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
-CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
-CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
-# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_PAS16 is not set
-# CONFIG_SCSI_PSI240I is not set
-# CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
-# CONFIG_SCSI_QLOGIC_FC is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-CONFIG_SCSI_QLA2XXX=y
-# CONFIG_SCSI_QLA21XX is not set
-# CONFIG_SCSI_QLA22XX is not set
-# CONFIG_SCSI_QLA2300 is not set
-# CONFIG_SCSI_QLA2322 is not set
-# CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_SYM53C416 is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_T128 is not set
-# CONFIG_SCSI_U14_34F is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# Old CD-ROM drivers (not SCSI, not IDE)
-#
-# CONFIG_CD_NO_IDESCSI is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-CONFIG_MD=y
-CONFIG_BLK_DEV_MD=m
-CONFIG_MD_LINEAR=m
-CONFIG_MD_RAID0=m
-CONFIG_MD_RAID1=m
-CONFIG_MD_RAID10=m
-CONFIG_MD_RAID5=m
-# CONFIG_MD_RAID6 is not set
-CONFIG_MD_MULTIPATH=m
-CONFIG_MD_FAULTY=m
-CONFIG_BLK_DEV_DM=m
-# CONFIG_DM_CRYPT is not set
-CONFIG_DM_SNAPSHOT=m
-CONFIG_DM_MIRROR=m
-CONFIG_DM_ZERO=m
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-# CONFIG_IEEE1394 is not set
-
-#
-# I2O device support
-#
-# CONFIG_I2O is not set
-
-#
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=m
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=m
-CONFIG_UNIX=y
-CONFIG_NET_KEY=m
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-# CONFIG_IP_PNP is not set
-CONFIG_NET_IPIP=m
-CONFIG_NET_IPGRE=m
-CONFIG_NET_IPGRE_BROADCAST=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-CONFIG_IP_TCPDIAG_IPV6=y
-
-#
-# IP: Virtual Server Configuration
-#
-# CONFIG_IP_VS is not set
-CONFIG_IPV6=m
-CONFIG_IPV6_PRIVACY=y
-CONFIG_INET6_AH=m
-CONFIG_INET6_ESP=m
-CONFIG_INET6_IPCOMP=m
-CONFIG_INET6_TUNNEL=m
-CONFIG_IPV6_TUNNEL=m
-CONFIG_NETFILTER=y
-# CONFIG_NETFILTER_DEBUG is not set
-CONFIG_BRIDGE_NETFILTER=y
-
-#
-# IP: Netfilter Configuration
-#
-CONFIG_IP_NF_CONNTRACK=m
-# CONFIG_IP_NF_CT_ACCT is not set
-CONFIG_IP_NF_CONNTRACK_MARK=y
-CONFIG_IP_NF_CT_PROTO_SCTP=m
-CONFIG_IP_NF_FTP=m
-CONFIG_IP_NF_IRC=m
-CONFIG_IP_NF_TFTP=m
-CONFIG_IP_NF_AMANDA=m
-CONFIG_IP_NF_QUEUE=m
-CONFIG_IP_NF_IPTABLES=m
-CONFIG_IP_NF_MATCH_LIMIT=m
-CONFIG_IP_NF_MATCH_IPRANGE=m
-CONFIG_IP_NF_MATCH_MAC=m
-CONFIG_IP_NF_MATCH_PKTTYPE=m
-CONFIG_IP_NF_MATCH_MARK=m
-CONFIG_IP_NF_MATCH_MULTIPORT=m
-CONFIG_IP_NF_MATCH_TOS=m
-CONFIG_IP_NF_MATCH_RECENT=m
-CONFIG_IP_NF_MATCH_ECN=m
-CONFIG_IP_NF_MATCH_DSCP=m
-CONFIG_IP_NF_MATCH_AH_ESP=m
-CONFIG_IP_NF_MATCH_LENGTH=m
-CONFIG_IP_NF_MATCH_TTL=m
-CONFIG_IP_NF_MATCH_TCPMSS=m
-CONFIG_IP_NF_MATCH_HELPER=m
-CONFIG_IP_NF_MATCH_STATE=m
-CONFIG_IP_NF_MATCH_CONNTRACK=m
-CONFIG_IP_NF_MATCH_OWNER=m
-CONFIG_IP_NF_MATCH_PHYSDEV=m
-CONFIG_IP_NF_MATCH_ADDRTYPE=m
-CONFIG_IP_NF_MATCH_REALM=m
-CONFIG_IP_NF_MATCH_SCTP=m
-CONFIG_IP_NF_MATCH_COMMENT=m
-CONFIG_IP_NF_MATCH_CONNMARK=m
-CONFIG_IP_NF_MATCH_HASHLIMIT=m
-CONFIG_IP_NF_FILTER=m
-CONFIG_IP_NF_TARGET_REJECT=m
-CONFIG_IP_NF_TARGET_LOG=m
-CONFIG_IP_NF_TARGET_ULOG=m
-CONFIG_IP_NF_TARGET_TCPMSS=m
-CONFIG_IP_NF_NAT=m
-CONFIG_IP_NF_NAT_NEEDED=y
-CONFIG_IP_NF_TARGET_MASQUERADE=m
-CONFIG_IP_NF_TARGET_REDIRECT=m
-CONFIG_IP_NF_TARGET_NETMAP=m
-CONFIG_IP_NF_TARGET_SAME=m
-CONFIG_IP_NF_NAT_SNMP_BASIC=m
-CONFIG_IP_NF_NAT_IRC=m
-CONFIG_IP_NF_NAT_FTP=m
-CONFIG_IP_NF_NAT_TFTP=m
-CONFIG_IP_NF_NAT_AMANDA=m
-CONFIG_IP_NF_MANGLE=m
-CONFIG_IP_NF_TARGET_TOS=m
-CONFIG_IP_NF_TARGET_ECN=m
-CONFIG_IP_NF_TARGET_DSCP=m
-CONFIG_IP_NF_TARGET_MARK=m
-CONFIG_IP_NF_TARGET_CLASSIFY=m
-CONFIG_IP_NF_TARGET_CONNMARK=m
-CONFIG_IP_NF_TARGET_CLUSTERIP=m
-CONFIG_IP_NF_RAW=m
-CONFIG_IP_NF_TARGET_NOTRACK=m
-CONFIG_IP_NF_ARPTABLES=m
-CONFIG_IP_NF_ARPFILTER=m
-CONFIG_IP_NF_ARP_MANGLE=m
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
 
 #
-# IPv6: Netfilter Configuration
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
-CONFIG_IP6_NF_QUEUE=m
-CONFIG_IP6_NF_IPTABLES=m
-CONFIG_IP6_NF_MATCH_LIMIT=m
-CONFIG_IP6_NF_MATCH_MAC=m
-CONFIG_IP6_NF_MATCH_RT=m
-CONFIG_IP6_NF_MATCH_OPTS=m
-CONFIG_IP6_NF_MATCH_FRAG=m
-CONFIG_IP6_NF_MATCH_HL=m
-CONFIG_IP6_NF_MATCH_MULTIPORT=m
-CONFIG_IP6_NF_MATCH_OWNER=m
-CONFIG_IP6_NF_MATCH_MARK=m
-CONFIG_IP6_NF_MATCH_IPV6HEADER=m
-CONFIG_IP6_NF_MATCH_AHESP=m
-CONFIG_IP6_NF_MATCH_LENGTH=m
-CONFIG_IP6_NF_MATCH_EUI64=m
-CONFIG_IP6_NF_MATCH_PHYSDEV=m
-CONFIG_IP6_NF_FILTER=m
-CONFIG_IP6_NF_TARGET_LOG=m
-CONFIG_IP6_NF_MANGLE=m
-CONFIG_IP6_NF_TARGET_MARK=m
-CONFIG_IP6_NF_RAW=m
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
 
 #
-# DECnet: Netfilter Configuration
+# SCSI Transport Attributes
 #
-CONFIG_DECNET_NF_GRABULATOR=m
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
 
 #
-# Bridge: Netfilter Configuration
+# SCSI low-level drivers
 #
-CONFIG_BRIDGE_NF_EBTABLES=m
-CONFIG_BRIDGE_EBT_BROUTE=m
-CONFIG_BRIDGE_EBT_T_FILTER=m
-CONFIG_BRIDGE_EBT_T_NAT=m
-CONFIG_BRIDGE_EBT_802_3=m
-CONFIG_BRIDGE_EBT_AMONG=m
-CONFIG_BRIDGE_EBT_ARP=m
-CONFIG_BRIDGE_EBT_IP=m
-CONFIG_BRIDGE_EBT_LIMIT=m
-CONFIG_BRIDGE_EBT_MARK=m
-CONFIG_BRIDGE_EBT_PKTTYPE=m
-CONFIG_BRIDGE_EBT_STP=m
-CONFIG_BRIDGE_EBT_VLAN=m
-CONFIG_BRIDGE_EBT_ARPREPLY=m
-CONFIG_BRIDGE_EBT_DNAT=m
-CONFIG_BRIDGE_EBT_MARK_T=m
-CONFIG_BRIDGE_EBT_REDIRECT=m
-CONFIG_BRIDGE_EBT_SNAT=m
-CONFIG_BRIDGE_EBT_LOG=m
-# CONFIG_BRIDGE_EBT_ULOG is not set
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_IN2000 is not set
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_PPA=m
+CONFIG_SCSI_IMM=m
+# CONFIG_SCSI_IZIP_EPP16 is not set
+# CONFIG_SCSI_IZIP_SLOW_CTR is not set
+# CONFIG_SCSI_NCR53C406A is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
 
 #
-# SCTP Configuration (EXPERIMENTAL)
+# Old CD-ROM drivers (not SCSI, not IDE)
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-CONFIG_BRIDGE=m
-# CONFIG_VLAN_8021Q is not set
-CONFIG_DECNET=m
-# CONFIG_DECNET_ROUTER is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+# CONFIG_CD_NO_IDESCSI is not set
 
 #
-# QoS and/or fair queueing
+# Multi-device support (RAID and LVM)
 #
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CLK_JIFFIES=y
-# CONFIG_NET_SCH_CLK_GETTIMEOFDAY is not set
-# CONFIG_NET_SCH_CLK_CPU is not set
-CONFIG_NET_SCH_CBQ=m
-CONFIG_NET_SCH_HTB=m
-CONFIG_NET_SCH_HFSC=m
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_SFQ=m
-CONFIG_NET_SCH_TEQL=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_SCH_GRED=m
-CONFIG_NET_SCH_DSMARK=m
-CONFIG_NET_SCH_NETEM=m
-CONFIG_NET_SCH_INGRESS=m
-CONFIG_NET_QOS=y
-CONFIG_NET_ESTIMATOR=y
-CONFIG_NET_CLS=y
-CONFIG_NET_CLS_TCINDEX=m
-CONFIG_NET_CLS_ROUTE4=m
-CONFIG_NET_CLS_ROUTE=y
-CONFIG_NET_CLS_FW=m
-CONFIG_NET_CLS_U32=m
-# CONFIG_CLS_U32_PERF is not set
-# CONFIG_NET_CLS_IND is not set
-# CONFIG_CLS_U32_MARK is not set
-CONFIG_NET_CLS_RSVP=m
-CONFIG_NET_CLS_RSVP6=m
-# CONFIG_NET_CLS_ACT is not set
-CONFIG_NET_CLS_POLICE=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID5=m
+# CONFIG_MD_RAID6 is not set
+CONFIG_MD_MULTIPATH=m
+CONFIG_MD_FAULTY=m
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_CRYPT is not set
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
 
 #
-# Network testing
+# Fusion MPT device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-CONFIG_HAMRADIO=y
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
-# Packet Radio protocols
+# IEEE 1394 (FireWire) support
 #
-CONFIG_AX25=m
-CONFIG_AX25_DAMA_SLAVE=y
-CONFIG_NETROM=m
-CONFIG_ROSE=m
+# CONFIG_IEEE1394 is not set
 
 #
-# AX.25 network device drivers
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Network device support
 #
-CONFIG_MKISS=m
-CONFIG_6PACK=m
-CONFIG_BPQETHER=m
-# CONFIG_DMASCC is not set
-# CONFIG_SCC is not set
-# CONFIG_BAYCOM_SER_FDX is not set
-# CONFIG_BAYCOM_SER_HDX is not set
-# CONFIG_BAYCOM_PAR is not set
-# CONFIG_BAYCOM_EPP is not set
-# CONFIG_YAM is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 CONFIG_DUMMY=m
 CONFIG_BONDING=m
 CONFIG_EQUALIZER=m
 CONFIG_TUN=m
-CONFIG_ETHERTAP=m
 
 #
 # ARCnet devices
@@ -668,14 +753,29 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_NET_VENDOR_RACAL is not set
 
@@ -696,7 +796,6 @@
 # CONFIG_LP486E is not set
 # CONFIG_ETH16I is not set
 CONFIG_NE2000=m
-# CONFIG_ZNET is not set
 # CONFIG_SEEQ8005 is not set
 CONFIG_NET_PCI=y
 CONFIG_PCNET32=y
@@ -733,13 +832,17 @@
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 CONFIG_VIA_VELOCITY=m
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -752,6 +855,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -765,6 +870,8 @@
 # CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -794,20 +901,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_PARKBD=m
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -828,6 +921,18 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_PARKBD=m
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -844,13 +949,13 @@
 # CONFIG_SERIAL_8250_MANY_PORTS is not set
 CONFIG_SERIAL_8250_SHARE_IRQ=y
 CONFIG_SERIAL_8250_DETECT_IRQ=y
-CONFIG_SERIAL_8250_MULTIPORT=y
 CONFIG_SERIAL_8250_RSA=y
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=m
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -881,6 +986,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -891,15 +1001,26 @@
 CONFIG_W1=m
 CONFIG_W1_MATROX=m
 CONFIG_W1_DS9490=m
-CONFIG_W1_DS9490_BRIDGE=m
+# CONFIG_W1_DS9490_BRIDGE is not set
 CONFIG_W1_THERM=m
 CONFIG_W1_SMEM=m
+# CONFIG_W1_DS2433 is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
 
 #
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -920,7 +1041,6 @@
 CONFIG_VGA_CONSOLE=y
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -930,6 +1050,8 @@
 #
 # USB support
 #
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_USB=m
 # CONFIG_USB_DEBUG is not set
 
@@ -940,8 +1062,6 @@
 # CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
 # USB Host Controller Drivers
@@ -949,7 +1069,10 @@
 CONFIG_USB_EHCI_HCD=m
 # CONFIG_USB_EHCI_SPLIT_ISO is not set
 # CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_ISP116X_HCD is not set
 CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 CONFIG_USB_UHCI_HCD=m
 # CONFIG_USB_SL811_HCD is not set
 
@@ -965,11 +1088,10 @@
 #
 CONFIG_USB_STORAGE=m
 # CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_RW_DETECT is not set
 CONFIG_USB_STORAGE_DATAFAB=y
 CONFIG_USB_STORAGE_FREECOM=y
 CONFIG_USB_STORAGE_DPCM=y
-CONFIG_USB_STORAGE_HP8200e=y
+# CONFIG_USB_STORAGE_USBAT is not set
 CONFIG_USB_STORAGE_SDDR09=y
 CONFIG_USB_STORAGE_SDDR55=y
 CONFIG_USB_STORAGE_JUMPSHOT=y
@@ -992,12 +1114,17 @@
 CONFIG_USB_MOUSE=m
 CONFIG_USB_AIPTEK=m
 CONFIG_USB_WACOM=m
+# CONFIG_USB_ACECAD is not set
 CONFIG_USB_KBTAB=m
 CONFIG_USB_POWERMATE=m
 # CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
 CONFIG_USB_EGALAX=m
+CONFIG_USB_YEALINK=m
 CONFIG_USB_XPAD=m
 # CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
 
 #
 # USB Imaging devices
@@ -1022,30 +1149,15 @@
 CONFIG_USB_PEGASUS=m
 CONFIG_USB_RTL8150=m
 CONFIG_USB_USBNET=m
-
-#
-# USB Host-to-Host Cables
-#
-CONFIG_USB_ALI_M5632=y
-CONFIG_USB_AN2720=y
-CONFIG_USB_BELKIN=y
-CONFIG_USB_GENESYS=y
-CONFIG_USB_NET1080=y
-CONFIG_USB_PL2301=y
-CONFIG_USB_KC2190=y
-
-#
-# Intelligent USB Devices/Gadgets
-#
-CONFIG_USB_ARMLINUX=y
-CONFIG_USB_EPSON2888=y
-CONFIG_USB_ZAURUS=y
-CONFIG_USB_CDCETHER=y
-
-#
-# USB Network Adapters
-#
-CONFIG_USB_AX8817X=y
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_USB_MON=y
 
 #
 # USB port drivers
@@ -1057,9 +1169,11 @@
 #
 CONFIG_USB_SERIAL=m
 CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRPRIME=m
 CONFIG_USB_SERIAL_BELKIN=m
 CONFIG_USB_SERIAL_WHITEHEAT=m
 CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+# CONFIG_USB_SERIAL_CP2101 is not set
 CONFIG_USB_SERIAL_CYPRESS_M8=m
 CONFIG_USB_SERIAL_EMPEG=m
 CONFIG_USB_SERIAL_FTDI_SIO=m
@@ -1088,6 +1202,7 @@
 CONFIG_USB_SERIAL_KOBIL_SCT=m
 CONFIG_USB_SERIAL_MCT_U232=m
 CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_HP4X=m
 CONFIG_USB_SERIAL_SAFE=m
 CONFIG_USB_SERIAL_SAFE_PADDED=y
 # CONFIG_USB_SERIAL_TI is not set
@@ -1110,10 +1225,13 @@
 CONFIG_USB_PHIDGETKIT=m
 CONFIG_USB_PHIDGETSERVO=m
 # CONFIG_USB_IDMOUSE is not set
+CONFIG_USB_SISUSBVGA=m
+# CONFIG_USB_SISUSBVGA_CON is not set
+CONFIG_USB_LD=m
 CONFIG_USB_TEST=m
 
 #
-# USB ATM/DSL drivers
+# USB DSL modem support
 #
 
 #
@@ -1132,10 +1250,15 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=m
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -1152,17 +1275,20 @@
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
+CONFIG_XFS_EXPORT=y
+CONFIG_XFS_QUOTA=m
 CONFIG_XFS_SECURITY=y
 # CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
 CONFIG_MINIX_FS=m
 CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -1192,12 +1318,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -1224,15 +1348,18 @@
 #
 CONFIG_NFS_FS=m
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=m
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 CONFIG_NFSD_TCP=y
 CONFIG_LOCKD=m
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=m
 CONFIG_SUNRPC_GSS=m
 CONFIG_RPCSEC_GSS_KRB5=m
@@ -1256,6 +1383,7 @@
 CONFIG_CODA_FS_OLD_API=y
 CONFIG_AFS_FS=m
 CONFIG_RXRPC=m
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -1329,7 +1457,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -1352,6 +1482,7 @@
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -1360,13 +1491,13 @@
 CONFIG_CRYPTO_CAST5=m
 CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_MICHAEL_MIC=m
-# CONFIG_CRYPTO_CRC32C is not set
-CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -1376,9 +1507,12 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
diff -Naur linux-2.6.14/arch/mips/configs/sb1250-swarm_defconfig linux-mips-2.6.14.orig/arch/mips/configs/sb1250-swarm_defconfig
--- linux-2.6.14/arch/mips/configs/sb1250-swarm_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/sb1250-swarm_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:10 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:55:58 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,30 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=15
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_CPUSETS=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,32 +61,49 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-CONFIG_SIBYTE_SB1xxx_SOC=y
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
 CONFIG_SIBYTE_SWARM=y
 # CONFIG_SIBYTE_SENTOSA is not set
 # CONFIG_SIBYTE_RHONE is not set
@@ -91,9 +112,12 @@
 # CONFIG_SIBYTE_LITTLESUR is not set
 # CONFIG_SIBYTE_CRHINE is not set
 # CONFIG_SIBYTE_CRHONE is not set
-# CONFIG_SIBYTE_UNKNOWN is not set
-CONFIG_SIBYTE_BOARD=y
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_SIBYTE_SB1250=y
+CONFIG_SIBYTE_SB1xxx_SOC=y
 CONFIG_CPU_SB1_PASS_1=y
 # CONFIG_CPU_SB1_PASS_2_1250 is not set
 # CONFIG_CPU_SB1_PASS_2_2 is not set
@@ -102,18 +126,20 @@
 # CONFIG_CPU_SB1_PASS_3 is not set
 CONFIG_SIBYTE_HAS_LDT=y
 # CONFIG_SIMULATION is not set
+# CONFIG_CONFIG_SB1_CEX_ALWAYS_FATAL is not set
+# CONFIG_CONFIG_SB1_CERR_STALL is not set
 CONFIG_SIBYTE_CFE=y
 # CONFIG_SIBYTE_CFE_CONSOLE is not set
 # CONFIG_SIBYTE_BUS_WATCHER is not set
 # CONFIG_SIBYTE_SB1250_PROF is not set
 # CONFIG_SIBYTE_TBPROF is not set
-# CONFIG_SNI_RM200_PCI is not set
-# CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -121,8 +147,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -138,22 +166,46 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 CONFIG_CPU_SB1=y
+CONFIG_SYS_HAS_CPU_SB1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_32BIT is not set
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_SIBYTE_DMA_PAGEOPS is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 CONFIG_SB1_PASS_1_WORKAROUNDS=y
-# CONFIG_64BIT_PHYS_ADDR is not set
-# CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
-# CONFIG_HIGHMEM is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_SYS_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SMP=y
 CONFIG_NR_CPUS=2
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
@@ -161,7 +213,6 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -170,10 +221,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -183,7 +230,86 @@
 #
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
-CONFIG_TRAD_SIGNALS=y
+# CONFIG_BUILD_ELF64 is not set
+CONFIG_MIPS32_COMPAT=y
+CONFIG_COMPAT=y
+CONFIG_MIPS32_O32=y
+# CONFIG_MIPS32_N32 is not set
+CONFIG_BINFMT_ELF32=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
 
 #
 # Device Drivers
@@ -194,7 +320,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -213,7 +344,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -226,8 +356,6 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=9220
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
@@ -263,7 +391,7 @@
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
-CONFIG_BLK_DEV_IDE_SWARM=y
+# CONFIG_BLK_DEV_IDE_SWARM is not set
 # CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -272,6 +400,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -282,6 +411,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -294,78 +424,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
+# Network device support
 #
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -373,12 +438,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -399,12 +480,16 @@
 # CONFIG_YELLOWFIN is not set
 # CONFIG_R8169 is not set
 CONFIG_NET_SB1250_MAC=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -417,6 +502,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -428,6 +515,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -445,25 +534,15 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -472,11 +551,13 @@
 CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_ROCKETPORT is not set
 # CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
 # CONFIG_MOXA_SMARTIO is not set
 # CONFIG_ISI is not set
-# CONFIG_SYNCLINK is not set
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
 # CONFIG_STALDRV is not set
 CONFIG_SIBYTE_SB1250_DUART=y
 CONFIG_SIBYTE_SB1250_DUART_CONSOLE=y
@@ -489,6 +570,7 @@
 #
 # Non-8250 serial port support
 #
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -515,6 +597,11 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -525,10 +612,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -542,7 +639,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -552,13 +648,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -576,12 +668,17 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 CONFIG_FS_MBCACHE=y
@@ -591,10 +688,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -615,11 +714,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -643,13 +741,14 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -658,6 +757,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -678,7 +778,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=15
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 # CONFIG_SB1XXX_CORELIS is not set
@@ -695,27 +797,28 @@
 #
 CONFIG_CRYPTO=y
 CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_NULL=y
-CONFIG_CRYPTO_MD4=y
-CONFIG_CRYPTO_MD5=y
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA256=y
-CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
-CONFIG_CRYPTO_DES=y
-CONFIG_CRYPTO_BLOWFISH=y
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
 CONFIG_CRYPTO_AES=m
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_TEA=m
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
-# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
@@ -726,9 +829,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/sead_defconfig linux-mips-2.6.14.orig/arch/mips/configs/sead_defconfig
--- linux-2.6.14/arch/mips/configs/sead_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/sead_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:10 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:56:01 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,22 +11,26 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
-# CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -39,6 +40,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -48,40 +50,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 CONFIG_MIPS_SEAD=y
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -89,8 +120,10 @@
 #
 # CPU selection
 #
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS64 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -106,15 +139,42 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_SYS_HAS_CPU_MIPS64_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -128,10 +188,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -143,6 +199,11 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+# CONFIG_NET is not set
+
+#
 # Device Drivers
 #
 
@@ -154,6 +215,10 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -170,7 +235,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
@@ -178,11 +242,8 @@
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=18432
 CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=y
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -200,6 +261,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=y
 # CONFIG_SCSI is not set
 
 #
@@ -210,6 +272,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -220,9 +283,8 @@
 #
 
 #
-# Networking support
+# Network device support
 #
-# CONFIG_NET is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 
@@ -238,47 +300,18 @@
 #
 # Input device support
 #
-CONFIG_INPUT=y
+# CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
 
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
+# CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -294,7 +327,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
+CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
 
@@ -315,10 +348,13 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -329,10 +365,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -347,13 +393,6 @@
 # CONFIG_FB is not set
 
 #
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
 # Sound
 #
 # CONFIG_SOUND is not set
@@ -365,10 +404,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -381,28 +416,31 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
-CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
 
 #
 # CD-ROM/DVD Filesystems
@@ -423,10 +461,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=y
 
 #
 # Miscellaneous filesystems
@@ -448,8 +486,18 @@
 #
 # Partition Types
 #
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
 
 #
 # Native Language Support
@@ -464,15 +512,16 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
 #
 # Security options
 #
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
 
 #
@@ -488,7 +537,6 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
 # CONFIG_CRC32 is not set
 # CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
diff -Naur linux-2.6.14/arch/mips/configs/tb0226_defconfig linux-mips-2.6.14.orig/arch/mips/configs/tb0226_defconfig
--- linux-2.6.14/arch/mips/configs/tb0226_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/tb0226_defconfig	2005-11-17 11:42:18.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:12 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:56:04 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,55 +59,87 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-CONFIG_TANBAC_TB0226=y
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+CONFIG_TANBAC_TB022X=y
+CONFIG_TANBAC_TB0226=y
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
+# CONFIG_VRC4173 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 CONFIG_CPU_VR41XX=y
@@ -120,19 +155,44 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_VR41XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
 CONFIG_HW_HAS_PCI=y
-# CONFIG_PCI is not set
+CONFIG_PCI=y
+# CONFIG_PCI_LEGACY_PROC is not set
 CONFIG_MMU=y
 
 #
@@ -141,12 +201,9 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
+# CONFIG_HOTPLUG_PCI is not set
 
 #
 # Executable file formats
@@ -156,6 +213,87 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -167,6 +305,11 @@
 # CONFIG_FW_LOADER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -183,19 +326,21 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=m
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=m
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -209,33 +354,12 @@
 #
 # ATA/ATAPI/MFM/RLL support
 #
-CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-CONFIG_IDEDISK_MULTI_MODE=y
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-CONFIG_BLK_DEV_IDESCSI=y
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_IDE_GENERIC=y
-# CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_BLK_DEV_HD is not set
+# CONFIG_IDE is not set
 
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
 CONFIG_SCSI_PROC_FS=y
 
@@ -245,15 +369,15 @@
 CONFIG_BLK_DEV_SD=y
 # CONFIG_CHR_DEV_ST is not set
 # CONFIG_CHR_DEV_OSST is not set
-CONFIG_BLK_DEV_SR=y
-# CONFIG_BLK_DEV_SR_VENDOR is not set
-CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 CONFIG_SCSI_MULTI_LUN=y
-CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_CONSTANTS is not set
 # CONFIG_SCSI_LOGGING is not set
 
 #
@@ -262,11 +386,43 @@
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
 
 #
 # SCSI low-level drivers
 #
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
 # CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA24XX is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
 # CONFIG_SCSI_DEBUG is not set
 
 #
@@ -277,131 +433,134 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
 
 #
 # IEEE 1394 (FireWire) support
 #
+# CONFIG_IEEE1394 is not set
 
 #
 # I2O device support
 #
+# CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
+# Network device support
 #
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=m
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-CONFIG_SYN_COOKIES=y
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 
 #
-# SCTP Configuration (EXPERIMENTAL)
+# ARCnet devices
 #
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
+# CONFIG_ARCNET is not set
 
 #
-# QoS and/or fair queueing
+# PHY device support
 #
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
 
 #
-# Network testing
+# MII PHY device drivers
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-CONFIG_NETDEVICES=y
-# CONFIG_DUMMY is not set
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+CONFIG_EEPRO100=y
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_LAN_SAA9730 is not set
 
 #
 # Ethernet (1000 Mbit)
 #
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
 
 #
 # Token Ring devices
 #
+# CONFIG_TR is not set
 
 #
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW2200 is not set
 
 #
 # Wan interfaces
 #
 # CONFIG_WAN is not set
-CONFIG_PPP=m
-CONFIG_PPP_MULTILINK=y
-# CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=m
-CONFIG_PPP_SYNC_TTY=m
-CONFIG_PPP_DEFLATE=m
-CONFIG_PPP_BSDCOMP=m
-CONFIG_PPPOE=m
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
 # CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -421,28 +580,13 @@
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_MOUSEDEV is not set
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -452,6 +596,12 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -462,16 +612,16 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VR41XX=y
+CONFIG_SERIAL_VR41XX_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -489,14 +639,22 @@
 # CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_TANBAC_TB0219 is not set
 
 #
 # Ftape, the floppy tape device driver
 #
 # CONFIG_DRM is not set
+CONFIG_GPIO_VR41XX=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -507,10 +665,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -523,48 +691,147 @@
 #
 # Graphics support
 #
-CONFIG_FB=y
-# CONFIG_FB_MODE_HELPERS is not set
-# CONFIG_FB_TILEBLITTING is not set
-# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB is not set
 
 #
 # Console display driver support
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_FRAMEBUFFER_CONSOLE is not set
 
 #
-# Logo configuration
+# Sound
 #
-# CONFIG_LOGO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_SOUND is not set
 
 #
-# Sound
+# USB support
 #
-CONFIG_SOUND=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
 
 #
-# Advanced Linux Sound Architecture
+# Miscellaneous USB options
 #
-# CONFIG_SND is not set
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
 
 #
-# Open Sound System
+# USB Host Controller Drivers
 #
-# CONFIG_SOUND_PRIME is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
 
 #
-# USB support
+# USB Device Class drivers
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
 
 #
 # NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
 #
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
 
 #
 # USB Gadget Support
@@ -582,39 +849,41 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
 #
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_ZISOFS_FS=y
+# CONFIG_ISO9660_FS is not set
 # CONFIG_UDF_FS is not set
 
 #
 # DOS/FAT/NT Filesystems
 #
-CONFIG_FAT_FS=m
-CONFIG_MSDOS_FS=m
-CONFIG_VFAT_FS=m
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -623,13 +892,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -653,16 +919,19 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=m
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 # CONFIG_NFSD_TCP is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -673,6 +942,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -732,9 +1002,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE=""
+CONFIG_CMDLINE="mem=32M console=ttyVR0,115200"
 
 #
 # Security options
@@ -746,7 +1018,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -756,9 +1052,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=y
+CONFIG_CRC16=m
+CONFIG_CRC32=m
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
diff -Naur linux-2.6.14/arch/mips/configs/tb0229_defconfig linux-mips-2.6.14.orig/arch/mips/configs/tb0229_defconfig
--- linux-2.6.14/arch/mips/configs/tb0229_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/tb0229_defconfig	2005-11-17 11:42:19.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:12 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:56:08 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,58 +59,87 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-CONFIG_TANBAC_TB0229=y
-CONFIG_TANBAC_TB0219=y
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_PCI_VR41XX=y
-# CONFIG_VRC4173 is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+CONFIG_TANBAC_TB022X=y
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
+# CONFIG_VRC4173 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 CONFIG_CPU_VR41XX=y
@@ -123,12 +155,36 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_VR41XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -136,8 +192,7 @@
 #
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
-CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
+# CONFIG_PCI_LEGACY_PROC is not set
 CONFIG_MMU=y
 
 #
@@ -146,10 +201,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -162,6 +213,88 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+# CONFIG_NET_IPGRE_BROADCAST is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -170,7 +303,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -189,7 +327,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -199,11 +336,11 @@
 # CONFIG_BLK_DEV_CRYPTOLOOP is not set
 CONFIG_BLK_DEV_NBD=m
 # CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
 CONFIG_BLK_DEV_RAM=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=4096
 # CONFIG_BLK_DEV_INITRD is not set
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -226,6 +363,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -236,6 +374,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -248,83 +387,13 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_NETLINK_DEV=m
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-CONFIG_NET_IPIP=m
-CONFIG_NET_IPGRE=m
-# CONFIG_NET_IPGRE_BROADCAST is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-CONFIG_SYN_COOKIES=y
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
+# Network device support
 #
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 CONFIG_DUMMY=m
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -332,12 +401,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -346,7 +431,7 @@
 # CONFIG_NET_TULIP is not set
 # CONFIG_HP100 is not set
 CONFIG_NET_PCI=y
-CONFIG_PCNET32=y
+# CONFIG_PCNET32 is not set
 # CONFIG_AMD8111_ETH is not set
 # CONFIG_ADAPTEC_STARFIRE is not set
 # CONFIG_B44 is not set
@@ -358,7 +443,11 @@
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
 # CONFIG_8139CP is not set
-# CONFIG_8139TOO is not set
+CONFIG_8139TOO=y
+CONFIG_8139TOO_PIO=y
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
@@ -375,14 +464,19 @@
 # CONFIG_NS83820 is not set
 # CONFIG_HAMACHI is not set
 # CONFIG_YELLOWFIN is not set
-# CONFIG_R8169 is not set
+CONFIG_R8169=y
+# CONFIG_R8169_NAPI is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_VIA_VELOCITY is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -395,6 +489,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -416,6 +512,8 @@
 CONFIG_SLIP_MODE_SLIP6=y
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -435,29 +533,13 @@
 #
 # Userland interfaces
 #
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_MOUSEDEV is not set
 # CONFIG_INPUT_JOYDEV is not set
 # CONFIG_INPUT_TSDEV is not set
 # CONFIG_INPUT_EVDEV is not set
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -467,6 +549,12 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -477,16 +565,16 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VR41XX=y
+CONFIG_SERIAL_VR41XX_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -505,14 +593,21 @@
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
+CONFIG_TANBAC_TB0219=y
 
 #
 # Ftape, the floppy tape device driver
 #
 # CONFIG_DRM is not set
+CONFIG_GPIO_VR41XX=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -523,10 +618,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -546,7 +651,6 @@
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -556,13 +660,122 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
 
 #
 # NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
 #
+# CONFIG_USB_STORAGE is not set
+
+#
+# USB Input Devices
+#
+# CONFIG_USB_HID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_ITMTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
 
 #
 # USB Gadget Support
@@ -580,10 +793,15 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=m
 CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
@@ -597,18 +815,22 @@
 # CONFIG_JFS_SECURITY is not set
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
+# CONFIG_FS_POSIX_ACL is not set
 CONFIG_XFS_FS=y
-# CONFIG_XFS_RT is not set
+CONFIG_XFS_EXPORT=y
 CONFIG_XFS_QUOTA=y
 # CONFIG_XFS_SECURITY is not set
 CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
 # CONFIG_MINIX_FS is not set
 CONFIG_ROMFS_FS=m
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_QUOTACTL=y
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -635,13 +857,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -665,16 +884,19 @@
 #
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=y
 CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
 # CONFIG_NFSD_V4 is not set
 CONFIG_NFSD_TCP=y
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -685,6 +907,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -744,9 +967,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE="mem=64M console=ttyS0,38400 ip=bootp root=/dev/nfs"
+CONFIG_CMDLINE="mem=64M console=ttyVR0,115200 ip=any root=/dev/nfs"
 
 #
 # Security options
@@ -758,7 +983,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -768,9 +1017,8 @@
 # Library routines
 #
 CONFIG_CRC_CCITT=m
+CONFIG_CRC16=m
 CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
diff -Naur linux-2.6.14/arch/mips/configs/tb0287_defconfig linux-mips-2.6.14.orig/arch/mips/configs/tb0287_defconfig
--- linux-2.6.14/arch/mips/configs/tb0287_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/tb0287_defconfig	1969-12-31 16:00:00.000000000 -0800
@@ -1,1041 +0,0 @@
-#
-# Automatically generated make config: don't edit
-# Linux kernel version: 2.6.13-mm1
-# Thu Sep  1 22:58:34 2005
-#
-CONFIG_MIPS=y
-
-#
-# Code maturity level options
-#
-CONFIG_EXPERIMENTAL=y
-CONFIG_CLEAN_COMPILE=y
-CONFIG_BROKEN_ON_SMP=y
-CONFIG_INIT_ENV_ARG_LIMIT=32
-
-#
-# General setup
-#
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_SWAP=y
-CONFIG_SYSVIPC=y
-# CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-CONFIG_SYSCTL=y
-# CONFIG_AUDIT is not set
-# CONFIG_HOTPLUG is not set
-CONFIG_KOBJECT_UEVENT=y
-# CONFIG_IKCONFIG is not set
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_EMBEDDED=y
-CONFIG_KALLSYMS=y
-# CONFIG_KALLSYMS_EXTRA_PASS is not set
-CONFIG_PRINTK=y
-CONFIG_BUG=y
-CONFIG_BASE_FULL=y
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SHMEM=y
-CONFIG_CC_ALIGN_FUNCTIONS=0
-CONFIG_CC_ALIGN_LABELS=0
-CONFIG_CC_ALIGN_LOOPS=0
-CONFIG_CC_ALIGN_JUMPS=0
-# CONFIG_TINY_SHMEM is not set
-CONFIG_BASE_SMALL=0
-
-#
-# Loadable module support
-#
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
-CONFIG_OBSOLETE_MODPARM=y
-CONFIG_MODVERSIONS=y
-CONFIG_MODULE_SRCVERSION_ALL=y
-CONFIG_KMOD=y
-CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
-CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
-CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
-CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
-
-#
-# Kernel type
-#
-CONFIG_32BIT=y
-# CONFIG_64BIT is not set
-
-#
-# Machine selection
-#
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-CONFIG_TANBAC_TB022X=y
-# CONFIG_TANBAC_TB0226 is not set
-CONFIG_TANBAC_TB0287=y
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_PCI_VR41XX=y
-# CONFIG_VRC4173 is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
-# CONFIG_MIPS_COBALT is not set
-# CONFIG_MACH_DECSTATION is not set
-# CONFIG_MIPS_EV64120 is not set
-# CONFIG_MIPS_EV96100 is not set
-# CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
-# CONFIG_MIPS_ITE8172 is not set
-# CONFIG_MIPS_ATLAS is not set
-# CONFIG_MIPS_MALTA is not set
-# CONFIG_MIPS_SEAD is not set
-# CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
-# CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
-# CONFIG_DDB5074 is not set
-# CONFIG_DDB5476 is not set
-# CONFIG_DDB5477 is not set
-# CONFIG_QEMU is not set
-# CONFIG_SGI_IP22 is not set
-# CONFIG_SGI_IP27 is not set
-# CONFIG_SGI_IP32 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
-# CONFIG_SNI_RM200_PCI is not set
-# CONFIG_TOSHIBA_RBTX4927 is not set
-CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_NONCOHERENT=y
-CONFIG_DMA_NEED_PCI_MAP_STATE=y
-CONFIG_CPU_LITTLE_ENDIAN=y
-CONFIG_IRQ_CPU=y
-CONFIG_MIPS_L1_CACHE_SHIFT=5
-
-#
-# CPU selection
-#
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
-# CONFIG_CPU_R3000 is not set
-# CONFIG_CPU_TX39XX is not set
-CONFIG_CPU_VR41XX=y
-# CONFIG_CPU_R4300 is not set
-# CONFIG_CPU_R4X00 is not set
-# CONFIG_CPU_TX49XX is not set
-# CONFIG_CPU_R5000 is not set
-# CONFIG_CPU_R5432 is not set
-# CONFIG_CPU_R6000 is not set
-# CONFIG_CPU_NEVADA is not set
-# CONFIG_CPU_R8000 is not set
-# CONFIG_CPU_R10000 is not set
-# CONFIG_CPU_RM7000 is not set
-# CONFIG_CPU_RM9000 is not set
-# CONFIG_CPU_SB1 is not set
-CONFIG_PAGE_SIZE_4KB=y
-# CONFIG_PAGE_SIZE_8KB is not set
-# CONFIG_PAGE_SIZE_16KB is not set
-# CONFIG_PAGE_SIZE_64KB is not set
-# CONFIG_CPU_ADVANCED is not set
-CONFIG_CPU_HAS_SYNC=y
-CONFIG_ARCH_FLATMEM_ENABLE=y
-CONFIG_SELECT_MEMORY_MODEL=y
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
-CONFIG_FLATMEM=y
-CONFIG_FLAT_NODE_MEM_MAP=y
-# CONFIG_SPARSEMEM_STATIC is not set
-# CONFIG_PREEMPT is not set
-
-#
-# Bus options (PCI, PCMCIA, EISA, ISA, TC)
-#
-CONFIG_HW_HAS_PCI=y
-CONFIG_PCI=y
-# CONFIG_PCI_LEGACY_PROC is not set
-CONFIG_MMU=y
-
-#
-# PCCARD (PCMCIA/CardBus) support
-#
-# CONFIG_PCCARD is not set
-
-#
-# PCI Hotplug Support
-#
-# CONFIG_HOTPLUG_PCI is not set
-
-#
-# Executable file formats
-#
-CONFIG_BINFMT_ELF=y
-# CONFIG_BINFMT_MISC is not set
-CONFIG_TRAD_SIGNALS=y
-
-#
-# Networking
-#
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_MMAP is not set
-CONFIG_UNIX=y
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_ASK_IP_FIB_HASH=y
-# CONFIG_IP_FIB_TRIE is not set
-CONFIG_IP_FIB_HASH=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-# CONFIG_IP_ROUTE_MULTIPATH_CACHED is not set
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-CONFIG_NET_IPIP=m
-CONFIG_NET_IPGRE=m
-# CONFIG_NET_IPGRE_BROADCAST is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-CONFIG_SYN_COOKIES=y
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_INET_DIAG=y
-CONFIG_INET_TCP_DIAG=y
-CONFIG_TCP_CONG_ADVANCED=y
-
-#
-# TCP congestion control
-#
-CONFIG_TCP_CONG_BIC=y
-CONFIG_TCP_CONG_WESTWOOD=m
-CONFIG_TCP_CONG_HTCP=m
-# CONFIG_TCP_CONG_HSTCP is not set
-# CONFIG_TCP_CONG_HYBLA is not set
-# CONFIG_TCP_CONG_VEGAS is not set
-# CONFIG_TCP_CONG_SCALABLE is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-
-#
-# DCCP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_DCCP is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETFILTER_NETLINK is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_IEEE80211 is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-CONFIG_BLK_DEV_LOOP=m
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
-CONFIG_BLK_DEV_NBD=m
-# CONFIG_BLK_DEV_SX8 is not set
-# CONFIG_BLK_DEV_UB is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_BLK_DEV_RAM_SIZE=4096
-# CONFIG_BLK_DEV_INITRD is not set
-# CONFIG_LBD is not set
-# CONFIG_CDROM_PKTCDVD is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-# CONFIG_ATA_OVER_ETH is not set
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-CONFIG_IDE=y
-CONFIG_BLK_DEV_IDE=y
-
-#
-# Please see Documentation/ide.txt for help/info on IDE drives
-#
-# CONFIG_BLK_DEV_IDE_SATA is not set
-CONFIG_BLK_DEV_IDEDISK=y
-# CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_BLK_DEV_IDECD is not set
-# CONFIG_BLK_DEV_IDETAPE is not set
-# CONFIG_BLK_DEV_IDEFLOPPY is not set
-# CONFIG_BLK_DEV_IDESCSI is not set
-# CONFIG_IDE_TASK_IOCTL is not set
-
-#
-# IDE chipset support/bugfixes
-#
-CONFIG_IDE_GENERIC=y
-CONFIG_BLK_DEV_IDEPCI=y
-# CONFIG_IDEPCI_SHARE_IRQ is not set
-# CONFIG_BLK_DEV_OFFBOARD is not set
-# CONFIG_BLK_DEV_GENERIC is not set
-# CONFIG_BLK_DEV_OPTI621 is not set
-CONFIG_BLK_DEV_IDEDMA_PCI=y
-# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
-# CONFIG_IDEDMA_PCI_AUTO is not set
-# CONFIG_BLK_DEV_AEC62XX is not set
-# CONFIG_BLK_DEV_ALI15X3 is not set
-# CONFIG_BLK_DEV_AMD74XX is not set
-# CONFIG_BLK_DEV_CMD64X is not set
-# CONFIG_BLK_DEV_TRIFLEX is not set
-# CONFIG_BLK_DEV_CY82C693 is not set
-# CONFIG_BLK_DEV_CS5520 is not set
-# CONFIG_BLK_DEV_CS5530 is not set
-# CONFIG_BLK_DEV_HPT34X is not set
-# CONFIG_BLK_DEV_HPT366 is not set
-# CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_PIIX is not set
-# CONFIG_BLK_DEV_IT821X is not set
-# CONFIG_BLK_DEV_NS87415 is not set
-# CONFIG_BLK_DEV_PDC202XX_OLD is not set
-# CONFIG_BLK_DEV_PDC202XX_NEW is not set
-# CONFIG_BLK_DEV_SVWKS is not set
-CONFIG_BLK_DEV_SIIMAGE=y
-# CONFIG_BLK_DEV_SLC90E66 is not set
-# CONFIG_BLK_DEV_TRM290 is not set
-# CONFIG_BLK_DEV_VIA82CXXX is not set
-# CONFIG_IDE_ARM is not set
-CONFIG_BLK_DEV_IDEDMA=y
-# CONFIG_IDEDMA_IVB is not set
-# CONFIG_IDEDMA_AUTO is not set
-# CONFIG_BLK_DEV_HD is not set
-
-#
-# SCSI device support
-#
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI Transport Attributes
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_ARCMSR is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_FC is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-CONFIG_SCSI_QLA2XXX=y
-# CONFIG_SCSI_QLA21XX is not set
-# CONFIG_SCSI_QLA22XX is not set
-# CONFIG_SCSI_QLA2300 is not set
-# CONFIG_SCSI_QLA2322 is not set
-# CONFIG_SCSI_QLA6312 is not set
-# CONFIG_SCSI_QLA24XX is not set
-# CONFIG_SCSI_LPFC is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-# CONFIG_FUSION is not set
-# CONFIG_FUSION_SPI is not set
-# CONFIG_FUSION_FC is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-CONFIG_IEEE1394=m
-
-#
-# Subsystem Options
-#
-# CONFIG_IEEE1394_VERBOSEDEBUG is not set
-# CONFIG_IEEE1394_OUI_DB is not set
-CONFIG_IEEE1394_EXTRA_CONFIG_ROMS=y
-CONFIG_IEEE1394_CONFIG_ROM_IP1394=y
-# CONFIG_IEEE1394_EXPORT_FULL_API is not set
-
-#
-# Device Drivers
-#
-
-#
-# Texas Instruments PCILynx requires I2C
-#
-CONFIG_IEEE1394_OHCI1394=m
-
-#
-# Protocol Drivers
-#
-CONFIG_IEEE1394_VIDEO1394=m
-CONFIG_IEEE1394_SBP2=m
-# CONFIG_IEEE1394_SBP2_PHYS_DMA is not set
-CONFIG_IEEE1394_ETH1394=m
-CONFIG_IEEE1394_DV1394=m
-CONFIG_IEEE1394_RAWIO=m
-CONFIG_IEEE1394_CMP=m
-CONFIG_IEEE1394_AMDTP=m
-
-#
-# I2O device support
-#
-# CONFIG_I2O is not set
-
-#
-# Network device support
-#
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=m
-# CONFIG_BONDING is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_TUN is not set
-
-#
-# ARCnet devices
-#
-# CONFIG_ARCNET is not set
-
-#
-# PHY device support
-#
-# CONFIG_PHYLIB is not set
-
-#
-# Ethernet (10 or 100Mbit)
-#
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_HAPPYMEAL is not set
-# CONFIG_SUNGEM is not set
-# CONFIG_NET_VENDOR_3COM is not set
-
-#
-# Tulip family network device support
-#
-# CONFIG_NET_TULIP is not set
-# CONFIG_HP100 is not set
-# CONFIG_NET_PCI is not set
-
-#
-# Ethernet (1000 Mbit)
-#
-# CONFIG_ACENIC is not set
-# CONFIG_DL2K is not set
-# CONFIG_E1000 is not set
-# CONFIG_NS83820 is not set
-# CONFIG_HAMACHI is not set
-# CONFIG_YELLOWFIN is not set
-CONFIG_R8169=y
-# CONFIG_R8169_NAPI is not set
-# CONFIG_SIS190 is not set
-# CONFIG_SKGE is not set
-# CONFIG_SKY2 is not set
-# CONFIG_SK98LIN is not set
-# CONFIG_TIGON3 is not set
-# CONFIG_BNX2 is not set
-
-#
-# Ethernet (10000 Mbit)
-#
-# CONFIG_CHELSIO_T1 is not set
-# CONFIG_IXGB is not set
-# CONFIG_S2IO is not set
-
-#
-# Token Ring devices
-#
-# CONFIG_TR is not set
-
-#
-# Wireless LAN (non-hamradio)
-#
-# CONFIG_NET_RADIO is not set
-
-#
-# Wan interfaces
-#
-# CONFIG_WAN is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-# CONFIG_NET_FC is not set
-# CONFIG_SHAPER is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_KGDBOE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NETPOLL_RX is not set
-# CONFIG_NETPOLL_TRAP is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-
-#
-# ISDN subsystem
-#
-# CONFIG_ISDN is not set
-
-#
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
-# Input device support
-#
-CONFIG_INPUT=y
-
-#
-# Userland interfaces
-#
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
-# CONFIG_SERIAL_NONSTANDARD is not set
-
-#
-# Serial drivers
-#
-# CONFIG_SERIAL_8250 is not set
-
-#
-# Non-8250 serial port support
-#
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_SERIAL_VR41XX=y
-CONFIG_SERIAL_VR41XX_CONSOLE=y
-# CONFIG_SERIAL_JSM is not set
-CONFIG_UNIX98_PTYS=y
-CONFIG_LEGACY_PTYS=y
-CONFIG_LEGACY_PTY_COUNT=256
-
-#
-# IPMI
-#
-# CONFIG_IPMI_HANDLER is not set
-
-#
-# Watchdog Cards
-#
-# CONFIG_WATCHDOG is not set
-# CONFIG_RTC is not set
-# CONFIG_GEN_RTC is not set
-# CONFIG_RTC_VR41XX is not set
-# CONFIG_DTLK is not set
-# CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
-# CONFIG_TANBAC_TB0219 is not set
-
-#
-# Ftape, the floppy tape device driver
-#
-# CONFIG_DRM is not set
-CONFIG_GPIO_VR41XX=y
-# CONFIG_RAW_DRIVER is not set
-
-#
-# TPM devices
-#
-# CONFIG_TCG_TPM is not set
-
-#
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# Dallas's 1-wire bus
-#
-# CONFIG_W1 is not set
-
-#
-# Hardware Monitoring support
-#
-# CONFIG_HWMON is not set
-# CONFIG_HWMON_VID is not set
-
-#
-# Misc devices
-#
-
-#
-# Multimedia Capabilities Port drivers
-#
-
-#
-# Multimedia devices
-#
-# CONFIG_VIDEO_DEV is not set
-
-#
-# Digital Video Broadcasting Devices
-#
-# CONFIG_DVB is not set
-
-#
-# Graphics support
-#
-# CONFIG_FB is not set
-
-#
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-
-#
-# Speakup console speech
-#
-# CONFIG_SPEAKUP is not set
-
-#
-# Sound
-#
-# CONFIG_SOUND is not set
-
-#
-# USB support
-#
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
-CONFIG_USB=m
-# CONFIG_USB_DEBUG is not set
-
-#
-# Miscellaneous USB options
-#
-# CONFIG_USB_DEVICEFS is not set
-# CONFIG_USB_BANDWIDTH is not set
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_OTG is not set
-
-#
-# USB Host Controller Drivers
-#
-CONFIG_USB_EHCI_HCD=m
-# CONFIG_USB_EHCI_SPLIT_ISO is not set
-# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
-# CONFIG_USB_ISP116X_HCD is not set
-CONFIG_USB_OHCI_HCD=m
-# CONFIG_USB_OHCI_BIG_ENDIAN is not set
-CONFIG_USB_OHCI_LITTLE_ENDIAN=y
-# CONFIG_USB_UHCI_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_BLUETOOTH_TTY is not set
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-CONFIG_USB_STORAGE=m
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_DPCM is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-
-#
-# USB Input Devices
-#
-CONFIG_USB_HID=m
-CONFIG_USB_HIDINPUT=y
-# CONFIG_HID_FF is not set
-# CONFIG_USB_HIDDEV is not set
-
-#
-# USB HID Boot Protocol drivers
-#
-# CONFIG_USB_KBD is not set
-# CONFIG_USB_MOUSE is not set
-# CONFIG_USB_AIPTEK is not set
-# CONFIG_USB_WACOM is not set
-# CONFIG_USB_ACECAD is not set
-# CONFIG_USB_KBTAB is not set
-# CONFIG_USB_POWERMATE is not set
-# CONFIG_USB_MTOUCH is not set
-# CONFIG_USB_ITMTOUCH is not set
-# CONFIG_USB_EGALAX is not set
-# CONFIG_USB_YEALINK is not set
-# CONFIG_USB_XPAD is not set
-# CONFIG_USB_ATI_REMOTE is not set
-# CONFIG_USB_KEYSPAN_REMOTE is not set
-# CONFIG_USB_APPLETOUCH is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-
-#
-# USB Multimedia devices
-#
-# CONFIG_USB_DABUSB is not set
-
-#
-# Video4Linux support is needed for USB Multimedia device support
-#
-
-#
-# USB Network Adapters
-#
-# CONFIG_USB_CATC is not set
-# CONFIG_USB_KAWETH is not set
-# CONFIG_USB_PEGASUS is not set
-# CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET is not set
-CONFIG_USB_MON=y
-
-#
-# USB port drivers
-#
-
-#
-# USB Serial Converter support
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_AUERSWALD is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_GOTEMP is not set
-# CONFIG_USB_PHIDGETKIT is not set
-# CONFIG_USB_PHIDGETSERVO is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_SISUSBVGA is not set
-# CONFIG_USB_LD is not set
-
-#
-# USB DSL modem support
-#
-
-#
-# USB Gadget Support
-#
-# CONFIG_USB_GADGET is not set
-
-#
-# MMC/SD Card support
-#
-# CONFIG_MMC is not set
-
-#
-# InfiniBand support
-#
-# CONFIG_INFINIBAND is not set
-
-#
-# SN Devices
-#
-
-#
-# Distributed Lock Manager
-#
-# CONFIG_DLM is not set
-
-#
-# File systems
-#
-CONFIG_EXT2_FS=y
-# CONFIG_EXT2_FS_XATTR is not set
-# CONFIG_EXT2_FS_XIP is not set
-# CONFIG_EXT3_FS is not set
-# CONFIG_REISER4_FS is not set
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
-
-#
-# XFS support
-#
-CONFIG_XFS_FS=y
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
-# CONFIG_XFS_SECURITY is not set
-CONFIG_XFS_POSIX_ACL=y
-# CONFIG_OCFS2_FS is not set
-# CONFIG_MINIX_FS is not set
-CONFIG_ROMFS_FS=m
-CONFIG_INOTIFY=y
-# CONFIG_QUOTA is not set
-CONFIG_QUOTACTL=y
-# CONFIG_DNOTIFY is not set
-# CONFIG_AUTOFS_FS is not set
-CONFIG_AUTOFS4_FS=y
-# CONFIG_FUSE_FS is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-# CONFIG_MSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-# CONFIG_HUGETLB_PAGE is not set
-CONFIG_RAMFS=y
-# CONFIG_CONFIGFS_FS is not set
-# CONFIG_RELAYFS_FS is not set
-
-#
-# Miscellaneous filesystems
-#
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_ASFS_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-CONFIG_CRAMFS=m
-# CONFIG_VXFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-
-#
-# Network File Systems
-#
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
-# CONFIG_NFSD is not set
-CONFIG_ROOT_NFS=y
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-# CONFIG_9P_FS is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-
-#
-# Native Language Support
-#
-# CONFIG_NLS is not set
-
-#
-# Kernel hacking
-#
-# CONFIG_PRINTK_TIME is not set
-# CONFIG_DEBUG_KERNEL is not set
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE="mem=64M console=ttyVR0,115200 ip=any root=/dev/nfs"
-
-#
-# Security options
-#
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
-# CONFIG_SECURITY is not set
-
-#
-# Cryptographic options
-#
-# CONFIG_CRYPTO is not set
-
-#
-# Hardware crypto devices
-#
-
-#
-# Library routines
-#
-# CONFIG_CRC_CCITT is not set
-# CONFIG_CRC16 is not set
-CONFIG_CRC32=y
-# CONFIG_LIBCRC32C is not set
-CONFIG_ZLIB_INFLATE=m
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_ISA_DMA_API=y
diff -Naur linux-2.6.14/arch/mips/configs/workpad_defconfig linux-mips-2.6.14.orig/arch/mips/configs/workpad_defconfig
--- linux-2.6.14/arch/mips/configs/workpad_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/workpad_defconfig	2005-11-17 11:42:19.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:12 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:56:11 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,24 +11,29 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +43,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,56 +59,84 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-CONFIG_IBM_WORKPAD=y
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_VRC4171=y
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+CONFIG_IBM_WORKPAD=y
+# CONFIG_TANBAC_TB022X is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 CONFIG_CPU_VR41XX=y
@@ -121,12 +152,36 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_VR41XX=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+# CONFIG_MIPS_MT is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
 
 #
@@ -138,11 +193,17 @@
 #
 # PCCARD (PCMCIA/CardBus) support
 #
-# CONFIG_PCCARD is not set
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
 
 #
 # PC-card bridges
 #
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
 CONFIG_PCMCIA_PROBE=y
 
 #
@@ -157,6 +218,78 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -165,7 +298,12 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
 
 #
 # Memory Technology Devices (MTD)
@@ -185,18 +323,13 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_XD is not set
 # CONFIG_BLK_DEV_COW_COMMON is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -219,6 +352,7 @@
 # CONFIG_BLK_DEV_IDE_SATA is not set
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -237,6 +371,7 @@
 #
 # SCSI device support
 #
+# CONFIG_RAID_ATTRS is not set
 # CONFIG_SCSI is not set
 
 #
@@ -252,6 +387,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -262,76 +398,13 @@
 #
 
 #
-# Networking support
-#
-CONFIG_NET=y
-
+# Network device support
 #
-# Networking options
-#
-CONFIG_PACKET=y
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-# CONFIG_IP_PNP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_ARPD is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
-# CONFIG_ETHERTAP is not set
 
 #
 # ARCnet devices
@@ -339,12 +412,26 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=m
 # CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_LANCE is not set
 # CONFIG_NET_VENDOR_SMC is not set
 # CONFIG_NET_VENDOR_RACAL is not set
 # CONFIG_AT1700 is not set
@@ -352,7 +439,6 @@
 # CONFIG_HP100 is not set
 # CONFIG_NET_ISA is not set
 # CONFIG_NET_PCI is not set
-# CONFIG_NET_POCKET is not set
 
 #
 # Ethernet (1000 Mbit)
@@ -373,6 +459,19 @@
 # CONFIG_NET_RADIO is not set
 
 #
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+CONFIG_PCMCIA_3C589=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_PCMCIA_XIRC2PS=m
+CONFIG_PCMCIA_AXNET=m
+
+#
 # Wan interfaces
 #
 # CONFIG_WAN is not set
@@ -380,6 +479,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -409,18 +510,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -430,6 +519,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -440,16 +539,15 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_VR41XX=y
+CONFIG_SERIAL_VR41XX_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -484,10 +582,19 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_GPIO_VR41XX is not set
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -498,10 +605,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -522,7 +639,6 @@
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -536,10 +652,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -552,7 +664,10 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
@@ -561,6 +676,7 @@
 CONFIG_EXT2_FS_XATTR=y
 CONFIG_EXT2_FS_POSIX_ACL=y
 CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
 CONFIG_FS_MBCACHE=y
@@ -570,10 +686,12 @@
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=y
 CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -594,12 +712,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -630,6 +746,7 @@
 # CONFIG_NFSD_TCP is not set
 CONFIG_LOCKD=y
 CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -638,6 +755,7 @@
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -658,9 +776,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
-CONFIG_CMDLINE=""
+CONFIG_CMDLINE="console=ttyVR0,19200 mem=16M"
 
 #
 # Security options
@@ -672,7 +792,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -682,7 +826,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=m
+CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/configs/yosemite_defconfig linux-mips-2.6.14.orig/arch/mips/configs/yosemite_defconfig
--- linux-2.6.14/arch/mips/configs/yosemite_defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/configs/yosemite_defconfig	2005-11-17 11:42:19.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:13 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:56:14 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,25 +11,31 @@
 # CONFIG_EXPERIMENTAL is not set
 CONFIG_CLEAN_COMPILE=y
 CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+# CONFIG_CPUSETS is not set
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +45,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,34 +60,68 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-CONFIG_PMC_YOSEMITE=y
-# CONFIG_HYPERTRANSPORT is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+CONFIG_PMC_YOSEMITE=y
+# CONFIG_QEMU is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_HYPERTRANSPORT is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_IRQ_CPU_RM9K=y
@@ -93,8 +131,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -110,20 +150,43 @@
 # CONFIG_CPU_RM7000 is not set
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_RM9000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_HIGHMEM=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_SYS_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
 CONFIG_SMP=y
 CONFIG_NR_CPUS=2
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
 # CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_BKL=y
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
@@ -131,7 +194,7 @@
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
-CONFIG_PCI_NAMES=y
+# CONFIG_PCI_DEBUG is not set
 CONFIG_MMU=y
 
 #
@@ -140,10 +203,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -155,6 +214,69 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=m
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
+# CONFIG_NETFILTER is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
 # Device Drivers
 #
 
@@ -163,10 +285,15 @@
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
 # CONFIG_DEBUG_DRIVER is not set
 
 #
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
 # Memory Technology Devices (MTD)
 #
 # CONFIG_MTD is not set
@@ -183,7 +310,6 @@
 #
 # Block devices
 #
-# CONFIG_BLK_DEV_FD is not set
 # CONFIG_BLK_CPQ_DA is not set
 # CONFIG_BLK_CPQ_CISS_DA is not set
 # CONFIG_BLK_DEV_DAC960 is not set
@@ -193,7 +319,6 @@
 # CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_RAM is not set
 CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
@@ -216,6 +341,7 @@
 #
 # SCSI device support
 #
+CONFIG_RAID_ATTRS=m
 # CONFIG_SCSI is not set
 
 #
@@ -226,6 +352,7 @@
 #
 # Fusion MPT device support
 #
+# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -238,59 +365,8 @@
 # CONFIG_I2O is not set
 
 #
-# Networking support
+# Network device support
 #
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=m
-CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=m
-CONFIG_UNIX=y
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
-# CONFIG_NETFILTER is not set
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
-# CONFIG_BRIDGE is not set
-# CONFIG_VLAN_8021Q is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-
-#
-# QoS and/or fair queueing
-#
-# CONFIG_NET_SCHED is not set
-# CONFIG_NET_CLS_ROUTE is not set
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -303,12 +379,28 @@
 # CONFIG_ARCNET is not set
 
 #
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 CONFIG_MII=y
 # CONFIG_HAPPYMEAL is not set
 # CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
 # CONFIG_NET_VENDOR_3COM is not set
 
 #
@@ -327,13 +419,16 @@
 # CONFIG_NS83820 is not set
 # CONFIG_HAMACHI is not set
 # CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
 CONFIG_TITAN_GE=y
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_CHELSIO_T1 is not set
 # CONFIG_IXGB is not set
 # CONFIG_S2IO is not set
 
@@ -346,6 +441,8 @@
 # Wireless LAN (non-hamradio)
 #
 # CONFIG_NET_RADIO is not set
+# CONFIG_IPW_DEBUG is not set
+CONFIG_IPW2200=m
 
 #
 # Wan interfaces
@@ -354,6 +451,8 @@
 # CONFIG_FDDI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -371,20 +470,10 @@
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 # CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
 
 #
 # Character devices
@@ -405,6 +494,7 @@
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -432,6 +522,10 @@
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -442,10 +536,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -459,7 +563,6 @@
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -469,13 +572,9 @@
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -493,6 +592,10 @@
 # CONFIG_INFINIBAND is not set
 
 #
+# SN Devices
+#
+
+#
 # File systems
 #
 # CONFIG_EXT2_FS is not set
@@ -500,13 +603,16 @@
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 # CONFIG_QUOTA is not set
 CONFIG_DNOTIFY=y
 # CONFIG_AUTOFS_FS is not set
 # CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -527,11 +633,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -552,7 +657,7 @@
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
@@ -573,8 +678,11 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_SPINLOCK is not set
@@ -599,7 +707,31 @@
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -609,7 +741,8 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
-# CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CRC16=m
+CONFIG_CRC32=m
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/ddb5074/nile4_pic.c linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5074/nile4_pic.c
--- linux-2.6.14/arch/mips/ddb5xxx/ddb5074/nile4_pic.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5074/nile4_pic.c	2005-11-17 11:42:19.000000000 -0800
@@ -209,14 +209,13 @@
 #define nile4_irq_shutdown nile4_disable_irq
 
 static hw_irq_controller nile4_irq_controller = {
-    "nile4",
-    nile4_irq_startup,
-    nile4_irq_shutdown,
-    nile4_enable_irq,
-    nile4_disable_irq,
-    nile4_ack_irq,
-    nile4_irq_end,
-    NULL
+	.typename = "nile4",
+	.startup = nile4_irq_startup,
+	.shutdown = nile4_irq_shutdown,
+	.enable = nile4_enable_irq,
+	.disable = nile4_disable_irq,
+	.ack = nile4_ack_irq,
+	.end = nile4_irq_end,
 };
 
 void nile4_irq_setup(u32 base) {
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/ddb5074/setup.c linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5074/setup.c
--- linux-2.6.14/arch/mips/ddb5xxx/ddb5074/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5074/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -85,7 +85,7 @@
 
 
 
-static void __init ddb5074_setup(void)
+void __init plat_setup(void)
 {
 	set_io_port_base(NILE4_PCI_IO_BASE);
 	isa_slot_offset = NILE4_PCI_MEM_BASE;
@@ -106,8 +106,6 @@
 	panic_timeout = 180;
 }
 
-early_initcall(ddb5074_setup);
-
 #define USE_NILE4_SERIAL	0
 
 #if USE_NILE4_SERIAL
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/ddb5476/setup.c linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5476/setup.c
--- linux-2.6.14/arch/mips/ddb5xxx/ddb5476/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5476/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -124,7 +124,7 @@
 
 static void ddb5476_board_init(void);
 
-static void __init ddb5476_setup(void)
+void __init plat_setup(void)
 {
 	set_io_port_base(KSEG1ADDR(DDB_PCI_IO_BASE));
 
@@ -158,8 +158,6 @@
 	ddb5476_board_init();
 }
 
-early_initcall(ddb5476_setup);
-
 /*
  * We don't trust bios.  We essentially does hardware re-initialization
  * as complete as possible, as far as we know we can safely do.
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c
--- linux-2.6.14/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c	2005-11-17 11:42:19.000000000 -0800
@@ -53,14 +53,13 @@
 }
 
 static hw_irq_controller vrc5476_irq_controller = {
-	"vrc5476",
-	vrc5476_irq_startup,
-	vrc5476_irq_shutdown,
-	vrc5476_irq_enable,
-	vrc5476_irq_disable,
-	vrc5476_irq_ack,
-	vrc5476_irq_end,
-	NULL				/* no affinity stuff for UP */
+	.typename = "vrc5476",
+	.startup = vrc5476_irq_startup,
+	.shutdown = vrc5476_irq_shutdown,
+	.enable = vrc5476_irq_enable,
+	.disable = vrc5476_irq_disable,
+	.ack = vrc5476_irq_ack,
+	.end = vrc5476_irq_end
 };
 
 void __init
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/ddb5477/irq_5477.c linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5477/irq_5477.c
--- linux-2.6.14/arch/mips/ddb5xxx/ddb5477/irq_5477.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5477/irq_5477.c	2005-11-17 11:42:19.000000000 -0800
@@ -90,14 +90,13 @@
 }
 
 hw_irq_controller vrc5477_irq_controller = {
-	"vrc5477_irq",
-	vrc5477_irq_startup,
-	vrc5477_irq_shutdown,
-	vrc5477_irq_enable,
-	vrc5477_irq_disable,
-	vrc5477_irq_ack,
-	vrc5477_irq_end,
-	NULL			/* no affinity stuff for UP */
+	.typename = "vrc5477_irq",
+	.startup = vrc5477_irq_startup,
+	.shutdown = vrc5477_irq_shutdown,
+	.enable = vrc5477_irq_enable,
+	.disable = vrc5477_irq_disable,
+	.ack = vrc5477_irq_ack,
+	.end = vrc5477_irq_end
 };
 
 void __init vrc5477_irq_init(u32 irq_base)
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/ddb5477/setup.c linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5477/setup.c
--- linux-2.6.14/arch/mips/ddb5xxx/ddb5477/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/ddb5477/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -170,7 +170,7 @@
 extern struct pci_controller ddb5477_ext_controller;
 extern struct pci_controller ddb5477_io_controller;
 
-static int  ddb5477_setup(void)
+void __init plat_setup(void)
 {
 	/* initialize board - we don't trust the loader */
         ddb5477_board_init();
@@ -193,12 +193,8 @@
 
 	register_pci_controller (&ddb5477_ext_controller);
 	register_pci_controller (&ddb5477_io_controller);
-
-	return 0;
 }
 
-early_initcall(ddb5477_setup);
-
 static void __init ddb5477_board_init(void)
 {
 	/* ----------- setup PDARs ------------ */
diff -Naur linux-2.6.14/arch/mips/ddb5xxx/Kconfig linux-mips-2.6.14.orig/arch/mips/ddb5xxx/Kconfig
--- linux-2.6.14/arch/mips/ddb5xxx/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/ddb5xxx/Kconfig	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,4 @@
+config DDB5477_BUS_FREQUENCY
+	int "bus frequency (in kHZ, 0 for auto-detect)"
+	depends on DDB5477
+	default 0
diff -Naur linux-2.6.14/arch/mips/dec/ecc-berr.c linux-mips-2.6.14.orig/arch/mips/dec/ecc-berr.c
--- linux-2.6.14/arch/mips/dec/ecc-berr.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/ecc-berr.c	2005-11-17 11:42:19.000000000 -0800
@@ -6,7 +6,7 @@
  *	5000/240 (KN03), 5000/260 (KN05) and DECsystem 5900 (KN03),
  *	5900/260 (KN05) systems.
  *
- *	Copyright (c) 2003  Maciej W. Rozycki
+ *	Copyright (c) 2003, 2005  Maciej W. Rozycki
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -15,6 +15,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
@@ -57,7 +58,7 @@
 
 	const char *kind, *agent, *cycle, *event;
 	const char *status = "", *xbit = "", *fmt = "";
-	dma_addr_t address;
+	unsigned long address;
 	u16 syn = 0, sngl;
 
 	int i = 0;
@@ -66,7 +67,7 @@
 	u32 chksyn = *kn0x_chksyn;
 	int action = MIPS_BE_FATAL;
 
-	/* For non-ECC ack ASAP, so any subsequent errors get caught. */
+	/* For non-ECC ack ASAP, so that any subsequent errors get caught. */
 	if ((erraddr & (KN0X_EAR_VALID | KN0X_EAR_ECCERR)) == KN0X_EAR_VALID)
 		dec_ecc_be_ack();
 
@@ -74,7 +75,7 @@
 
 	if (!(erraddr & KN0X_EAR_VALID)) {
 		/* No idea what happened. */
-		printk(KERN_ALERT "Unidentified bus error %s.\n", kind);
+		printk(KERN_ALERT "Unidentified bus error %s\n", kind);
 		return action;
 	}
 
@@ -126,7 +127,7 @@
 			/* Ack now, no rewrite will happen. */
 			dec_ecc_be_ack();
 
-			fmt = KERN_ALERT "%s" "invalid.\n";
+			fmt = KERN_ALERT "%s" "invalid\n";
 		} else {
 			sngl = syn & KN0X_ESR_SNGLO;
 			syn &= KN0X_ESR_SYNLO;
@@ -144,7 +145,8 @@
 			} else if (!sngl) {
 				status = dbestr;
 			} else {
-				volatile u32 *ptr = (void *)KSEG1ADDR(address);
+				volatile u32 *ptr =
+					(void *)CKSEG1ADDR(address);
 
 				*ptr = *ptr;		/* Rewrite. */
 				iob();
@@ -160,12 +162,12 @@
 				if (syn == 0x01) {
 					fmt = KERN_ALERT "%s"
 					      "%#04x -- %s bit error "
-					      "at check bit C%s.\n";
+					      "at check bit C%s\n";
 					xbit = "X";
 				} else {
 					fmt = KERN_ALERT "%s"
 					      "%#04x -- %s bit error "
-					      "at check bit C%s%u.\n";
+					      "at check bit C%s%u\n";
 				}
 				i = syn >> 2;
 			} else {
@@ -175,16 +177,16 @@
 				if (i < 32)
 					fmt = KERN_ALERT "%s"
 					      "%#04x -- %s bit error "
-					      "at data bit D%s%u.\n";
+					      "at data bit D%s%u\n";
 				else
 					fmt = KERN_ALERT "%s"
-					      "%#04x -- %s bit error.\n";
+					      "%#04x -- %s bit error\n";
 			}
 		}
 	}
 
 	if (action != MIPS_BE_FIXUP)
-		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx.\n",
+		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",
 			kind, agent, cycle, event, address);
 
 	if (action != MIPS_BE_FIXUP && erraddr & KN0X_EAR_ECCERR)
@@ -203,11 +205,11 @@
 	int action = dec_ecc_be_backend(regs, 0, 1);
 
 	if (action == MIPS_BE_DISCARD)
-		return IRQ_NONE;
+		return IRQ_HANDLED;
 
 	/*
-	 * FIXME: Find affected processes and kill them, otherwise we
-	 * must die.
+	 * FIXME: Find the affected processes and kill them, otherwise
+	 * we must die.
 	 *
 	 * The interrupt is asynchronously delivered thus EPC and RA
 	 * may be irrelevant, but are printed for a reference.
@@ -225,16 +227,16 @@
  */
 static inline void dec_kn02_be_init(void)
 {
-	volatile u32 *csr = (void *)KN02_CSR_BASE;
+	volatile u32 *csr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);
 	unsigned long flags;
 
-	kn0x_erraddr = (void *)(KN02_SLOT_BASE + KN02_ERRADDR);
-	kn0x_chksyn = (void *)(KN02_SLOT_BASE + KN02_CHKSYN);
+	kn0x_erraddr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_ERRADDR);
+	kn0x_chksyn = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CHKSYN);
 
 	spin_lock_irqsave(&kn02_lock, flags);
 
 	/* Preset write-only bits of the Control Register cache. */
-	cached_kn02_csr = *csr | KN03_CSR_LEDS;
+	cached_kn02_csr = *csr | KN02_CSR_LEDS;
 
 	/* Set normal ECC detection and generation. */
 	cached_kn02_csr &= ~(KN02_CSR_DIAGCHK | KN02_CSR_DIAGGEN);
@@ -248,11 +250,11 @@
 
 static inline void dec_kn03_be_init(void)
 {
-	volatile u32 *mcr = (void *)(KN03_SLOT_BASE + IOASIC_MCR);
-	volatile u32 *mbcs = (void *)(KN03_SLOT_BASE + KN05_MB_CSR);
+	volatile u32 *mcr = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_MCR);
+	volatile u32 *mbcs = (void *)CKSEG1ADDR(KN4K_SLOT_BASE + KN4K_MB_CSR);
 
-	kn0x_erraddr = (void *)(KN03_SLOT_BASE + IOASIC_ERRADDR);
-	kn0x_chksyn = (void *)(KN03_SLOT_BASE + IOASIC_CHKSYN);
+	kn0x_erraddr = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_ERRADDR);
+	kn0x_chksyn = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_CHKSYN);
 
 	/*
 	 * Set normal ECC detection and generation, enable ECC correction.
@@ -264,7 +266,7 @@
 	*mcr = (*mcr & ~(KN03_MCR_DIAGCHK | KN03_MCR_DIAGGEN)) |
 	       KN03_MCR_CORRECT;
 	if (current_cpu_data.cputype == CPU_R4400SC)
-		*mbcs |= KN05_MB_CSR_EE;
+		*mbcs |= KN4K_MB_CSR_EE;
 	fast_iob();
 }
 
diff -Naur linux-2.6.14/arch/mips/dec/int-handler.S linux-mips-2.6.14.orig/arch/mips/dec/int-handler.S
--- linux-2.6.14/arch/mips/dec/int-handler.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/int-handler.S	2005-11-17 11:42:19.000000000 -0800
@@ -2,9 +2,9 @@
  * arch/mips/dec/int-handler.S
  *
  * Copyright (C) 1995, 1996, 1997 Paul M. Antoine and Harald Koerfgen
- * Copyright (C) 2000, 2001, 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2000, 2001, 2002, 2003, 2005  Maciej W. Rozycki
  *
- * Written by Ralf Baechle and Andreas Busse, modified for DECStation
+ * Written by Ralf Baechle and Andreas Busse, modified for DECstation
  * support by Paul Antoine and Harald Koerfgen.
  *
  * completly rewritten:
@@ -14,11 +14,12 @@
  * by Maciej W. Rozycki.
  */
 #include <linux/config.h>
+
+#include <asm/addrspace.h>
 #include <asm/asm.h>
-#include <asm/regdef.h>
 #include <asm/mipsregs.h>
+#include <asm/regdef.h>
 #include <asm/stackframe.h>
-#include <asm/addrspace.h>
 
 #include <asm/dec/interrupts.h>
 #include <asm/dec/ioasic_addrs.h>
@@ -28,11 +29,14 @@
 #include <asm/dec/kn02xa.h>
 #include <asm/dec/kn03.h>
 
+#define KN02_CSR_BASE		CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR)
+#define KN02XA_IOASIC_BASE	CKSEG1ADDR(KN02XA_SLOT_BASE + IOASIC_IOCTL)
+#define KN03_IOASIC_BASE	CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_IOCTL)
 
 		.text
 		.set	noreorder
 /*
- * decstation_handle_int: Interrupt handler for DECStations
+ * decstation_handle_int: Interrupt handler for DECstations
  *
  * We follow the model in the Indy interrupt code by David Miller, where he
  * says: a lot of complication here is taken away because:
@@ -48,7 +52,7 @@
  * 3) Linux only thinks in terms of all IRQs on or all IRQs
  *    off, nothing in between like BSD spl() brain-damage.
  *
- * Furthermore, the IRQs on the DECStations look basically (barring
+ * Furthermore, the IRQs on the DECstations look basically (barring
  * software IRQs which we don't use at all) like...
  *
  * DS2100/3100's, aka kn01, aka Pmax:
@@ -61,7 +65,7 @@
  *             3        Lance Ethernet
  *             4        DZ11 serial
  *             5        RTC
- *             6        Memory Controller
+ *             6        Memory Controller & Video
  *             7        FPU
  *
  * DS5000/200, aka kn02, aka 3max:
diff -Naur linux-2.6.14/arch/mips/dec/kn01-berr.c linux-mips-2.6.14.orig/arch/mips/dec/kn01-berr.c
--- linux-2.6.14/arch/mips/dec/kn01-berr.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/dec/kn01-berr.c	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,201 @@
+/*
+ *	linux/arch/mips/dec/kn01-berr.c
+ *
+ *	Bus error event handling code for DECstation/DECsystem 3100
+ *	and 2100 (KN01) systems equipped with parity error detection
+ *	logic.
+ *
+ *	Copyright (c) 2005  Maciej W. Rozycki
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#include <asm/inst.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/system.h>
+#include <asm/traps.h>
+#include <asm/uaccess.h>
+
+#include <asm/dec/kn01.h>
+
+
+/* CP0 hazard avoidance. */
+#define BARRIER				\
+	__asm__ __volatile__(		\
+		".set	push\n\t"	\
+		".set	noreorder\n\t"	\
+		"nop\n\t"		\
+		".set	pop\n\t")
+
+/*
+ * Bits 7:0 of the Control Register are write-only -- the
+ * corresponding bits of the Status Register have a different
+ * meaning.  Hence we use a cache.  It speeds up things a bit
+ * as well.
+ *
+ * There is no default value -- it has to be initialized.
+ */
+u16 cached_kn01_csr;
+DEFINE_SPINLOCK(kn01_lock);
+
+
+static inline void dec_kn01_be_ack(void)
+{
+	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kn01_lock, flags);
+
+	*csr = cached_kn01_csr | KN01_CSR_MEMERR;	/* Clear bus IRQ. */
+	iob();
+
+	spin_unlock_irqrestore(&kn01_lock, flags);
+}
+
+static int dec_kn01_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
+{
+	volatile u32 *kn01_erraddr = (void *)CKSEG1ADDR(KN01_SLOT_BASE +
+							KN01_ERRADDR);
+
+	static const char excstr[] = "exception";
+	static const char intstr[] = "interrupt";
+	static const char cpustr[] = "CPU";
+	static const char mreadstr[] = "memory read";
+	static const char readstr[] = "read";
+	static const char writestr[] = "write";
+	static const char timestr[] = "timeout";
+	static const char paritystr[] = "parity error";
+
+	int data = regs->cp0_cause & 4;
+	unsigned int __user *pc = (unsigned int __user *)regs->cp0_epc +
+				  ((regs->cp0_cause & CAUSEF_BD) != 0);
+	union mips_instruction insn;
+	unsigned long entrylo, offset;
+	long asid, entryhi, vaddr;
+
+	const char *kind, *agent, *cycle, *event;
+	unsigned long address;
+
+	u32 erraddr = *kn01_erraddr;
+	int action = MIPS_BE_FATAL;
+
+	/* Ack ASAP, so that any subsequent errors get caught. */
+	dec_kn01_be_ack();
+
+	kind = invoker ? intstr : excstr;
+
+	agent = cpustr;
+
+	if (invoker)
+		address = erraddr;
+	else {
+		/* Bloody hardware doesn't record the address for reads... */
+		if (data) {
+			/* This never faults. */
+			__get_user(insn.word, pc);
+			vaddr = regs->regs[insn.i_format.rs] +
+				insn.i_format.simmediate;
+		} else
+			vaddr = (long)pc;
+		if (KSEGX(vaddr) == CKSEG0 || KSEGX(vaddr) == CKSEG1)
+			address = CPHYSADDR(vaddr);
+		else {
+			/* Peek at what physical address the CPU used. */
+			asid = read_c0_entryhi();
+			entryhi = asid & (PAGE_SIZE - 1);
+			entryhi |= vaddr & ~(PAGE_SIZE - 1);
+			write_c0_entryhi(entryhi);
+			BARRIER;
+			tlb_probe();
+			/* No need to check for presence. */
+			tlb_read();
+			entrylo = read_c0_entrylo0();
+			write_c0_entryhi(asid);
+			offset = vaddr & (PAGE_SIZE - 1);
+			address = (entrylo & ~(PAGE_SIZE - 1)) | offset;
+		}
+	}
+
+	/* Treat low 256MB as memory, high -- as I/O. */
+	if (address < 0x10000000) {
+		cycle = mreadstr;
+		event = paritystr;
+	} else {
+		cycle = invoker ? writestr : readstr;
+		event = timestr;
+	}
+
+	if (is_fixup)
+		action = MIPS_BE_FIXUP;
+
+	if (action != MIPS_BE_FIXUP)
+		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",
+			kind, agent, cycle, event, address);
+
+	return action;
+}
+
+int dec_kn01_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	return dec_kn01_be_backend(regs, is_fixup, 0);
+}
+
+irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id,
+				    struct pt_regs *regs)
+{
+	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
+	int action;
+
+	if (!(*csr & KN01_CSR_MEMERR))
+		return IRQ_NONE;		/* Must have been video. */
+
+	action = dec_kn01_be_backend(regs, 0, 1);
+
+	if (action == MIPS_BE_DISCARD)
+		return IRQ_HANDLED;
+
+	/*
+	 * FIXME: Find the affected processes and kill them, otherwise
+	 * we must die.
+	 *
+	 * The interrupt is asynchronously delivered thus EPC and RA
+	 * may be irrelevant, but are printed for a reference.
+	 */
+	printk(KERN_ALERT "Fatal bus interrupt, epc == %08lx, ra == %08lx\n",
+	       regs->cp0_epc, regs->regs[31]);
+	die("Unrecoverable bus error", regs);
+}
+
+
+void __init dec_kn01_be_init(void)
+{
+	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kn01_lock, flags);
+
+	/* Preset write-only bits of the Control Register cache. */
+	cached_kn01_csr = *csr;
+	cached_kn01_csr &= KN01_CSR_STATUS | KN01_CSR_PARDIS | KN01_CSR_TXDIS;
+	cached_kn01_csr |= KN01_CSR_LEDS;
+
+	/* Enable parity error detection. */
+	cached_kn01_csr &= ~KN01_CSR_PARDIS;
+	*csr = cached_kn01_csr;
+	iob();
+
+	spin_unlock_irqrestore(&kn01_lock, flags);
+
+	/* Clear any leftover errors from the firmware. */
+	dec_kn01_be_ack();
+}
diff -Naur linux-2.6.14/arch/mips/dec/kn02-irq.c linux-mips-2.6.14.orig/arch/mips/dec/kn02-irq.c
--- linux-2.6.14/arch/mips/dec/kn02-irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/kn02-irq.c	2005-11-17 11:42:19.000000000 -0800
@@ -4,7 +4,7 @@
  *	DECstation 5000/200 (KN02) Control and Status Register
  *	interrupts.
  *
- *	Copyright (c) 2002, 2003  Maciej W. Rozycki
+ *	Copyright (c) 2002, 2003, 2005  Maciej W. Rozycki
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -37,7 +37,8 @@
 
 static inline void unmask_kn02_irq(unsigned int irq)
 {
-	volatile u32 *csr = (volatile u32 *)KN02_CSR_BASE;
+	volatile u32 *csr = (volatile u32 *)CKSEG1ADDR(KN02_SLOT_BASE +
+						       KN02_CSR);
 
 	cached_kn02_csr |= (1 << (irq - kn02_irq_base + 16));
 	*csr = cached_kn02_csr;
@@ -45,7 +46,8 @@
 
 static inline void mask_kn02_irq(unsigned int irq)
 {
-	volatile u32 *csr = (volatile u32 *)KN02_CSR_BASE;
+	volatile u32 *csr = (volatile u32 *)CKSEG1ADDR(KN02_SLOT_BASE +
+						       KN02_CSR);
 
 	cached_kn02_csr &= ~(1 << (irq - kn02_irq_base + 16));
 	*csr = cached_kn02_csr;
@@ -105,13 +107,14 @@
 
 void __init init_kn02_irqs(int base)
 {
-	volatile u32 *csr = (volatile u32 *)KN02_CSR_BASE;
+	volatile u32 *csr = (volatile u32 *)CKSEG1ADDR(KN02_SLOT_BASE +
+						       KN02_CSR);
 	unsigned long flags;
 	int i;
 
 	/* Mask interrupts. */
 	spin_lock_irqsave(&kn02_lock, flags);
-	cached_kn02_csr &= ~KN03_CSR_IOINTEN;
+	cached_kn02_csr &= ~KN02_CSR_IOINTEN;
 	*csr = cached_kn02_csr;
 	iob();
 	spin_unlock_irqrestore(&kn02_lock, flags);
diff -Naur linux-2.6.14/arch/mips/dec/kn02xa-berr.c linux-mips-2.6.14.orig/arch/mips/dec/kn02xa-berr.c
--- linux-2.6.14/arch/mips/dec/kn02xa-berr.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/dec/kn02xa-berr.c	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,139 @@
+/*
+ *	linux/arch/mips/dec/kn02xa-berr.c
+ *
+ *	Bus error event handling code for 5000-series systems equipped
+ *	with parity error detection logic, i.e. DECstation/DECsystem
+ *	5000/120, /125, /133 (KN02-BA), 5000/150 (KN04-BA) and Personal
+ *	DECstation/DECsystem 5000/20, /25, /33 (KN02-CA), 5000/50
+ *	(KN04-CA) systems.
+ *
+ *	Copyright (c) 2005  Maciej W. Rozycki
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include <asm/addrspace.h>
+#include <asm/system.h>
+#include <asm/traps.h>
+
+#include <asm/dec/kn02ca.h>
+#include <asm/dec/kn02xa.h>
+#include <asm/dec/kn05.h>
+
+static inline void dec_kn02xa_be_ack(void)
+{
+	volatile u32 *mer = (void *)CKSEG1ADDR(KN02XA_MER);
+	volatile u32 *mem_intr = (void *)CKSEG1ADDR(KN02XA_MEM_INTR);
+
+	*mer = KN02CA_MER_INTR;		/* Clear errors; keep the ARC IRQ. */
+	*mem_intr = 0;			/* Any write clears the bus IRQ. */
+	iob();
+}
+
+static int dec_kn02xa_be_backend(struct pt_regs *regs, int is_fixup,
+				 int invoker)
+{
+	volatile u32 *kn02xa_mer = (void *)CKSEG1ADDR(KN02XA_MER);
+	volatile u32 *kn02xa_ear = (void *)CKSEG1ADDR(KN02XA_EAR);
+
+	static const char excstr[] = "exception";
+	static const char intstr[] = "interrupt";
+	static const char cpustr[] = "CPU";
+	static const char mreadstr[] = "memory read";
+	static const char readstr[] = "read";
+	static const char writestr[] = "write";
+	static const char timestr[] = "timeout";
+	static const char paritystr[] = "parity error";
+	static const char lanestat[][4] = { " OK", "BAD" };
+
+	const char *kind, *agent, *cycle, *event;
+	unsigned long address;
+
+	u32 mer = *kn02xa_mer;
+	u32 ear = *kn02xa_ear;
+	int action = MIPS_BE_FATAL;
+
+	/* Ack ASAP, so that any subsequent errors get caught. */
+	dec_kn02xa_be_ack();
+
+	kind = invoker ? intstr : excstr;
+
+	/* No DMA errors? */
+	agent = cpustr;
+
+	address = ear & KN02XA_EAR_ADDRESS;
+
+	/* Low 256MB is decoded as memory, high -- as TC. */
+	if (address < 0x10000000) {
+		cycle = mreadstr;
+		event = paritystr;
+	} else {
+		cycle = invoker ? writestr : readstr;
+		event = timestr;
+	}
+
+	if (is_fixup)
+		action = MIPS_BE_FIXUP;
+
+	if (action != MIPS_BE_FIXUP)
+		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",
+			kind, agent, cycle, event, address);
+
+	if (action != MIPS_BE_FIXUP && address < 0x10000000)
+		printk(KERN_ALERT "  Byte lane status %#3x -- "
+		       "#3: %s, #2: %s, #1: %s, #0: %s\n",
+		       (mer & KN02XA_MER_BYTERR) >> 8,
+		       lanestat[(mer & KN02XA_MER_BYTERR_3) != 0],
+		       lanestat[(mer & KN02XA_MER_BYTERR_2) != 0],
+		       lanestat[(mer & KN02XA_MER_BYTERR_1) != 0],
+		       lanestat[(mer & KN02XA_MER_BYTERR_0) != 0]);
+
+	return action;
+}
+
+int dec_kn02xa_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	return dec_kn02xa_be_backend(regs, is_fixup, 0);
+}
+
+irqreturn_t dec_kn02xa_be_interrupt(int irq, void *dev_id,
+				    struct pt_regs *regs)
+{
+	int action = dec_kn02xa_be_backend(regs, 0, 1);
+
+	if (action == MIPS_BE_DISCARD)
+		return IRQ_HANDLED;
+
+	/*
+	 * FIXME: Find the affected processes and kill them, otherwise
+	 * we must die.
+	 *
+	 * The interrupt is asynchronously delivered thus EPC and RA
+	 * may be irrelevant, but are printed for a reference.
+	 */
+	printk(KERN_ALERT "Fatal bus interrupt, epc == %08lx, ra == %08lx\n",
+	       regs->cp0_epc, regs->regs[31]);
+	die("Unrecoverable bus error", regs);
+}
+
+
+void __init dec_kn02xa_be_init(void)
+{
+	volatile u32 *mbcs = (void *)CKSEG1ADDR(KN4K_SLOT_BASE + KN4K_MB_CSR);
+
+        /* For KN04 we need to make sure EE (?) is enabled in the MB.  */
+        if (current_cpu_data.cputype == CPU_R4000SC)
+		*mbcs |= KN4K_MB_CSR_EE;
+	fast_iob();
+
+	/* Clear any leftover errors from the firmware. */
+	dec_kn02xa_be_ack();
+}
diff -Naur linux-2.6.14/arch/mips/dec/Makefile linux-mips-2.6.14.orig/arch/mips/dec/Makefile
--- linux-2.6.14/arch/mips/dec/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/Makefile	2005-11-17 11:42:19.000000000 -0800
@@ -2,8 +2,8 @@
 # Makefile for the DECstation family specific parts of the kernel
 #
 
-obj-y		:= ecc-berr.o int-handler.o ioasic-irq.o kn02-irq.o reset.o \
-		   setup.o time.o
+obj-y		:= ecc-berr.o int-handler.o ioasic-irq.o kn01-berr.o \
+		   kn02-irq.o kn02xa-berr.o reset.o setup.o time.o
 
 obj-$(CONFIG_PROM_CONSOLE)	+= promcon.o
 obj-$(CONFIG_CPU_HAS_WB)	+= wbflush.o
diff -Naur linux-2.6.14/arch/mips/dec/prom/identify.c linux-mips-2.6.14.orig/arch/mips/dec/prom/identify.c
--- linux-2.6.14/arch/mips/dec/prom/identify.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/prom/identify.c	2005-11-17 11:42:19.000000000 -0800
@@ -2,7 +2,7 @@
  * identify.c: machine identification code.
  *
  * Copyright (C) 1998 Harald Koerfgen and Paul M. Antoine
- * Copyright (C) 2002, 2003, 2004  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2004, 2005  Maciej W. Rozycki
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 
 #include <asm/bootinfo.h>
+
 #include <asm/dec/ioasic.h>
 #include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/kn01.h>
@@ -21,6 +22,7 @@
 #include <asm/dec/kn03.h>
 #include <asm/dec/kn230.h>
 #include <asm/dec/prom.h>
+#include <asm/dec/system.h>
 
 #include "dectypes.h"
 
@@ -68,34 +70,44 @@
 
 static inline void prom_init_kn01(void)
 {
-	dec_rtc_base = (void *)KN01_RTC_BASE;
+	dec_kn_slot_base = KN01_SLOT_BASE;
 	dec_kn_slot_size = KN01_SLOT_SIZE;
+
+	dec_rtc_base = (void *)CKSEG1ADDR(dec_kn_slot_base + KN01_RTC);
 }
 
 static inline void prom_init_kn230(void)
 {
-	dec_rtc_base = (void *)KN01_RTC_BASE;
+	dec_kn_slot_base = KN01_SLOT_BASE;
 	dec_kn_slot_size = KN01_SLOT_SIZE;
+
+	dec_rtc_base = (void *)CKSEG1ADDR(dec_kn_slot_base + KN01_RTC);
 }
 
 static inline void prom_init_kn02(void)
 {
-	dec_rtc_base = (void *)KN02_RTC_BASE;
+	dec_kn_slot_base = KN02_SLOT_BASE;
 	dec_kn_slot_size = KN02_SLOT_SIZE;
+
+	dec_rtc_base = (void *)CKSEG1ADDR(dec_kn_slot_base + KN02_RTC);
 }
 
 static inline void prom_init_kn02xa(void)
 {
-	ioasic_base = (void *)KN02XA_IOASIC_BASE;
-	dec_rtc_base = (void *)KN02XA_RTC_BASE;
+	dec_kn_slot_base = KN02XA_SLOT_BASE;
 	dec_kn_slot_size = IOASIC_SLOT_SIZE;
+
+	ioasic_base = (void *)CKSEG1ADDR(dec_kn_slot_base + IOASIC_IOCTL);
+	dec_rtc_base = (void *)CKSEG1ADDR(dec_kn_slot_base + IOASIC_TOY);
 }
 
 static inline void prom_init_kn03(void)
 {
-	ioasic_base = (void *)KN03_IOASIC_BASE;
-	dec_rtc_base = (void *)KN03_RTC_BASE;
+	dec_kn_slot_base = KN03_SLOT_BASE;
 	dec_kn_slot_size = IOASIC_SLOT_SIZE;
+
+	ioasic_base = (void *)CKSEG1ADDR(dec_kn_slot_base + IOASIC_IOCTL);
+	dec_rtc_base = (void *)CKSEG1ADDR(dec_kn_slot_base + IOASIC_TOY);
 }
 
 
diff -Naur linux-2.6.14/arch/mips/dec/prom/init.c linux-mips-2.6.14.orig/arch/mips/dec/prom/init.c
--- linux-2.6.14/arch/mips/dec/prom/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/prom/init.c	2005-11-17 11:42:19.000000000 -0800
@@ -6,6 +6,8 @@
  */
 #include <linux/config.h>
 #include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/linkage.h>
 #include <linux/smp.h>
 #include <linux/string.h>
 #include <linux/types.h>
@@ -85,17 +87,13 @@
 
 void __init prom_init(void)
 {
-	extern void dec_machine_halt(void);
+	extern void ATTRIB_NORET dec_machine_halt(void);
 	static char cpu_msg[] __initdata =
 		"Sorry, this kernel is compiled for a wrong CPU type!\n";
-	static char r3k_msg[] __initdata =
-		"Please recompile with \"CONFIG_CPU_R3000 = y\".\n";
-	static char r4k_msg[] __initdata =
-		"Please recompile with \"CONFIG_CPU_R4x00 = y\".\n";
 	s32 argc = fw_arg0;
-	s32 argv = fw_arg1;
+	s32 *argv = (void *)fw_arg1;
 	u32 magic = fw_arg2;
-	s32 prom_vec = fw_arg3;
+	s32 *prom_vec = (void *)fw_arg3;
 
 	/*
 	 * Determine which PROM we have
@@ -113,6 +111,8 @@
 #if defined(CONFIG_CPU_R3000)
 	if ((current_cpu_data.cputype == CPU_R4000SC) ||
 	    (current_cpu_data.cputype == CPU_R4400SC)) {
+		static char r4k_msg[] __initdata =
+			"Please recompile with \"CONFIG_CPU_R4x00 = y\".\n";
 		printk(cpu_msg);
 		printk(r4k_msg);
 		dec_machine_halt();
@@ -122,6 +122,8 @@
 #if defined(CONFIG_CPU_R4X00)
 	if ((current_cpu_data.cputype == CPU_R3000) ||
 	    (current_cpu_data.cputype == CPU_R3000A)) {
+		static char r3k_msg[] __initdata =
+			"Please recompile with \"CONFIG_CPU_R3000 = y\".\n";
 		printk(cpu_msg);
 		printk(r3k_msg);
 		dec_machine_halt();
diff -Naur linux-2.6.14/arch/mips/dec/prom/memory.c linux-mips-2.6.14.orig/arch/mips/dec/prom/memory.c
--- linux-2.6.14/arch/mips/dec/prom/memory.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/prom/memory.c	2005-11-17 11:42:19.000000000 -0800
@@ -35,22 +35,22 @@
 	extern char genexcept_early;
 
 	/* Install exception handler */
-	memcpy(&old_handler, (void *)(KSEG0 + 0x80), 0x80);
-	memcpy((void *)(KSEG0 + 0x80), &genexcept_early, 0x80);
+	memcpy(&old_handler, (void *)(CKSEG0 + 0x80), 0x80);
+	memcpy((void *)(CKSEG0 + 0x80), &genexcept_early, 0x80);
 
 	/* read unmapped and uncached (KSEG1)
 	 * DECstations have at least 4MB RAM
 	 * Assume less than 480MB of RAM, as this is max for 5000/2xx
 	 * FIXME this should be replaced by the first free page!
 	 */
-	for (memory_page = (unsigned char *) KSEG1 + CHUNK_SIZE;
-	     (mem_err== 0) && (memory_page < ((unsigned char *) KSEG1+0x1E000000));
+	for (memory_page = (unsigned char *)CKSEG1 + CHUNK_SIZE;
+	     mem_err == 0 && memory_page < (unsigned char *)CKSEG1 + 0x1e00000;
   	     memory_page += CHUNK_SIZE) {
 		dummy = *memory_page;
 	}
-	memcpy((void *)(KSEG0 + 0x80), &old_handler, 0x80);
+	memcpy((void *)(CKSEG0 + 0x80), &old_handler, 0x80);
 
-	add_memory_region(0, (unsigned long)memory_page - KSEG1 - CHUNK_SIZE,
+	add_memory_region(0, (unsigned long)memory_page - CKSEG1 - CHUNK_SIZE,
 			  BOOT_MEM_RAM);
 }
 
@@ -65,7 +65,7 @@
 	memmap *bm;
 
 	/* some free 64k */
-	bm = (memmap *)KSEG0ADDR(0x28000);
+	bm = (memmap *)CKSEG0ADDR(0x28000);
 
 	bitmap_size = rex_getbitmap(bm);
 
diff -Naur linux-2.6.14/arch/mips/dec/reset.c linux-mips-2.6.14.orig/arch/mips/dec/reset.c
--- linux-2.6.14/arch/mips/dec/reset.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/reset.c	2005-11-17 11:42:19.000000000 -0800
@@ -14,7 +14,7 @@
 
 static inline void ATTRIB_NORET back_to_prom(void)
 {
-	noret_func_t func = (void *) KSEG1ADDR(0x1fc00000);
+	noret_func_t func = (void *)CKSEG1ADDR(0x1fc00000);
 
 	func();
 }
diff -Naur linux-2.6.14/arch/mips/dec/setup.c linux-mips-2.6.14.orig/arch/mips/dec/setup.c
--- linux-2.6.14/arch/mips/dec/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/dec/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -1,19 +1,20 @@
 /*
- * Setup the interrupt stuff.
+ * System-specific setup, especially interrupts.
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 1998 Harald Koerfgen
- * Copyright (C) 2000, 2001, 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2000, 2001, 2002, 2003, 2005  Maciej W. Rozycki
  */
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/param.h>
 #include <linux/console.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
 #include <linux/module.h>
+#include <linux/param.h>
+#include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
 
@@ -38,6 +39,7 @@
 #include <asm/dec/kn02ca.h>
 #include <asm/dec/kn03.h>
 #include <asm/dec/kn230.h>
+#include <asm/dec/system.h>
 
 
 extern void dec_machine_restart(char *command);
@@ -47,10 +49,16 @@
 
 extern asmlinkage void decstation_handle_int(void);
 
+unsigned long dec_kn_slot_base, dec_kn_slot_size;
+
+EXPORT_SYMBOL(dec_kn_slot_base);
+EXPORT_SYMBOL(dec_kn_slot_size);
+
 spinlock_t ioasic_ssr_lock;
 
 volatile u32 *ioasic_base;
-unsigned long dec_kn_slot_size;
+
+EXPORT_SYMBOL(ioasic_base);
 
 /*
  * IRQ routing and priority tables.  Priorites are set as follows:
@@ -77,6 +85,9 @@
 int dec_interrupt[DEC_NR_INTS] = {
 	[0 ... DEC_NR_INTS - 1] = -1
 };
+
+EXPORT_SYMBOL(dec_interrupt);
+
 int_ptr cpu_mask_nr_tbl[DEC_MAX_CPU_INTS][2] = {
 	{ { .i = ~0 }, { .p = dec_intr_unimplemented } },
 };
@@ -108,11 +119,20 @@
 /*
  * Bus error (DBE/IBE exceptions and bus interrupts) handling setup.
  */
-void __init dec_be_init(void)
+static void __init dec_be_init(void)
 {
 	switch (mips_machtype) {
 	case MACH_DS23100:	/* DS2100/DS3100 Pmin/Pmax */
+		board_be_handler = dec_kn01_be_handler;
+		busirq.handler = dec_kn01_be_interrupt;
 		busirq.flags |= SA_SHIRQ;
+		dec_kn01_be_init();
+		break;
+	case MACH_DS5000_1XX:	/* DS5000/1xx 3min */
+	case MACH_DS5000_XX:	/* DS5000/xx Maxine */
+		board_be_handler = dec_kn02xa_be_handler;
+		busirq.handler = dec_kn02xa_be_interrupt;
+		dec_kn02xa_be_init();
 		break;
 	case MACH_DS5000_200:	/* DS5000/200 3max */
 	case MACH_DS5000_2X0:	/* DS5000/240 3max+ */
@@ -128,7 +148,7 @@
 extern void dec_time_init(void);
 extern void dec_timer_setup(struct irqaction *);
 
-static void __init decstation_setup(void)
+void __init plat_setup(void)
 {
 	board_be_init = dec_be_init;
 	board_time_init = dec_time_init;
@@ -139,9 +159,10 @@
 	_machine_restart = dec_machine_restart;
 	_machine_halt = dec_machine_halt;
 	_machine_power_off = dec_machine_power_off;
-}
 
-early_initcall(decstation_setup);
+	ioport_resource.start = ~0UL;
+	ioport_resource.end = 0UL;
+}
 
 /*
  * Machine-specific initialisation for KN01, aka DS2100 (aka Pmin)
@@ -206,7 +227,7 @@
 		{ .p = cpu_all_int } },
 };
 
-void __init dec_init_kn01(void)
+static void __init dec_init_kn01(void)
 {
 	/* IRQ routing. */
 	memcpy(&dec_interrupt, &kn01_interrupt,
@@ -281,7 +302,7 @@
 		{ .p = cpu_all_int } },
 };
 
-void __init dec_init_kn230(void)
+static void __init dec_init_kn230(void)
 {
 	/* IRQ routing. */
 	memcpy(&dec_interrupt, &kn230_interrupt,
@@ -371,7 +392,7 @@
 		{ .p = kn02_all_int } },
 };
 
-void __init dec_init_kn02(void)
+static void __init dec_init_kn02(void)
 {
 	/* IRQ routing. */
 	memcpy(&dec_interrupt, &kn02_interrupt,
@@ -472,7 +493,7 @@
 		{ .p = asic_all_int } },
 };
 
-void __init dec_init_kn02ba(void)
+static void __init dec_init_kn02ba(void)
 {
 	/* IRQ routing. */
 	memcpy(&dec_interrupt, &kn02ba_interrupt,
@@ -569,7 +590,7 @@
 		{ .p = asic_all_int } },
 };
 
-void __init dec_init_kn02ca(void)
+static void __init dec_init_kn02ca(void)
 {
 	/* IRQ routing. */
 	memcpy(&dec_interrupt, &kn02ca_interrupt,
@@ -670,7 +691,7 @@
 		{ .p = asic_all_int } },
 };
 
-void __init dec_init_kn03(void)
+static void __init dec_init_kn03(void)
 {
 	/* IRQ routing. */
 	memcpy(&dec_interrupt, &kn03_interrupt,
@@ -744,7 +765,3 @@
 	if (dec_interrupt[DEC_IRQ_HALT] >= 0)
 		setup_irq(dec_interrupt[DEC_IRQ_HALT], &haltirq);
 }
-
-EXPORT_SYMBOL(ioasic_base);
-EXPORT_SYMBOL(dec_kn_slot_size);
-EXPORT_SYMBOL(dec_interrupt);
diff -Naur linux-2.6.14/arch/mips/defconfig linux-mips-2.6.14.orig/arch/mips/defconfig
--- linux-2.6.14/arch/mips/defconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/defconfig	2005-11-17 11:42:19.000000000 -0800
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:48:59 2005
+# Linux kernel version: 2.6.14-rc5
+# Sun Oct 30 18:53:36 2005
 #
 CONFIG_MIPS=y
-# CONFIG_64BIT is not set
-# CONFIG_64BIT is not set
-CONFIG_32BIT=y
 
 #
 # Code maturity level options
@@ -14,25 +11,30 @@
 CONFIG_EXPERIMENTAL=y
 CONFIG_CLEAN_COMPILE=y
 CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
 
 #
 # General setup
 #
 CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_INITRAMFS_SOURCE=""
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +44,7 @@
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,41 +60,69 @@
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_PNX8550_V2PCI is not set
+# CONFIG_PNX8550_JBS is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
-# CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
 CONFIG_SGI_IP22=y
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NEED_PCI_MAP_STATE=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_ARC32=y
@@ -103,8 +134,10 @@
 #
 # CPU selection
 #
-# CONFIG_CPU_MIPS32 is not set
-# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_MIPS32_R1 is not set
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
 # CONFIG_CPU_R3000 is not set
 # CONFIG_CPU_TX39XX is not set
 # CONFIG_CPU_VR41XX is not set
@@ -120,22 +153,48 @@
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_R4X00=y
+CONFIG_SYS_HAS_CPU_R5000=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
 CONFIG_IP22_CPU_SCACHE=y
+# CONFIG_MIPS_MT is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
 # CONFIG_PREEMPT is not set
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_EISA=y
 # CONFIG_EISA is not set
 CONFIG_MMU=y
 
@@ -145,10 +204,6 @@
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -160,115 +215,7 @@
 CONFIG_TRAD_SIGNALS=y
 
 #
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-
-#
-# Memory Technology Devices (MTD)
-#
-# CONFIG_MTD is not set
-
-#
-# Parallel port support
-#
-# CONFIG_PARPORT is not set
-
-#
-# Plug and Play support
-#
-
-#
-# Block devices
-#
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_RAM is not set
-CONFIG_BLK_DEV_RAM_COUNT=16
-CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=m
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-CONFIG_IOSCHED_AS=y
-CONFIG_IOSCHED_DEADLINE=y
-CONFIG_IOSCHED_CFQ=y
-CONFIG_ATA_OVER_ETH=m
-
-#
-# ATA/ATAPI/MFM/RLL support
-#
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI=y
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_ST=y
-# CONFIG_CHR_DEV_OSST is not set
-CONFIG_BLK_DEV_SR=y
-# CONFIG_BLK_DEV_SR_VENDOR is not set
-# CONFIG_CHR_DEV_SG is not set
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_MULTI_LUN is not set
-CONFIG_SCSI_CONSTANTS=y
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI Transport Attributes
-#
-CONFIG_SCSI_SPI_ATTRS=m
-# CONFIG_SCSI_FC_ATTRS is not set
-CONFIG_SCSI_ISCSI_ATTRS=m
-
-#
-# SCSI low-level drivers
-#
-CONFIG_SGIWD93_SCSI=y
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_DEBUG is not set
-
-#
-# Multi-device support (RAID and LVM)
-#
-# CONFIG_MD is not set
-
-#
-# Fusion MPT device support
-#
-
-#
-# IEEE 1394 (FireWire) support
-#
-
-#
-# I2O device support
-#
-
-#
-# Networking support
+# Networking
 #
 CONFIG_NET=y
 
@@ -277,12 +224,14 @@
 #
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
-CONFIG_NETLINK_DEV=y
 CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
 CONFIG_NET_KEY=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
 # CONFIG_IP_PNP_DHCP is not set
 CONFIG_IP_PNP_BOOTP=y
@@ -296,8 +245,10 @@
 CONFIG_INET_ESP=m
 CONFIG_INET_IPCOMP=m
 CONFIG_INET_TUNNEL=m
-CONFIG_IP_TCPDIAG=m
-CONFIG_IP_TCPDIAG_IPV6=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
 
 #
 # IP: Virtual Server Configuration
@@ -341,6 +292,9 @@
 CONFIG_IPV6_TUNNEL=m
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
 
 #
 # IP: Netfilter Configuration
@@ -348,11 +302,15 @@
 CONFIG_IP_NF_CONNTRACK=m
 CONFIG_IP_NF_CT_ACCT=y
 CONFIG_IP_NF_CONNTRACK_MARK=y
+CONFIG_IP_NF_CONNTRACK_EVENTS=y
+CONFIG_IP_NF_CONNTRACK_NETLINK=m
 # CONFIG_IP_NF_CT_PROTO_SCTP is not set
 CONFIG_IP_NF_FTP=m
 CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_NETBIOS_NS is not set
 CONFIG_IP_NF_TFTP=m
 CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_PPTP=m
 CONFIG_IP_NF_QUEUE=m
 CONFIG_IP_NF_IPTABLES=m
 CONFIG_IP_NF_MATCH_LIMIT=m
@@ -376,14 +334,18 @@
 CONFIG_IP_NF_MATCH_ADDRTYPE=m
 CONFIG_IP_NF_MATCH_REALM=m
 CONFIG_IP_NF_MATCH_SCTP=m
+CONFIG_IP_NF_MATCH_DCCP=m
 CONFIG_IP_NF_MATCH_COMMENT=m
 CONFIG_IP_NF_MATCH_CONNMARK=m
+CONFIG_IP_NF_MATCH_CONNBYTES=m
 CONFIG_IP_NF_MATCH_HASHLIMIT=m
+CONFIG_IP_NF_MATCH_STRING=m
 CONFIG_IP_NF_FILTER=m
 CONFIG_IP_NF_TARGET_REJECT=m
 CONFIG_IP_NF_TARGET_LOG=m
 CONFIG_IP_NF_TARGET_ULOG=m
 CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_TARGET_NFQUEUE=m
 CONFIG_IP_NF_NAT=m
 CONFIG_IP_NF_NAT_NEEDED=y
 CONFIG_IP_NF_TARGET_MASQUERADE=m
@@ -395,12 +357,14 @@
 CONFIG_IP_NF_NAT_FTP=m
 CONFIG_IP_NF_NAT_TFTP=m
 CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_PPTP=m
 CONFIG_IP_NF_MANGLE=m
 CONFIG_IP_NF_TARGET_TOS=m
 CONFIG_IP_NF_TARGET_ECN=m
 CONFIG_IP_NF_TARGET_DSCP=m
 CONFIG_IP_NF_TARGET_MARK=m
 CONFIG_IP_NF_TARGET_CLASSIFY=m
+CONFIG_IP_NF_TARGET_TTL=m
 CONFIG_IP_NF_TARGET_CONNMARK=m
 CONFIG_IP_NF_TARGET_CLUSTERIP=m
 CONFIG_IP_NF_RAW=m
@@ -410,7 +374,7 @@
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -429,11 +393,17 @@
 CONFIG_IP6_NF_MATCH_EUI64=m
 CONFIG_IP6_NF_FILTER=m
 CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_NFQUEUE=m
 CONFIG_IP6_NF_MANGLE=m
 CONFIG_IP6_NF_TARGET_MARK=m
+CONFIG_IP6_NF_TARGET_HL=m
 CONFIG_IP6_NF_RAW=m
-CONFIG_XFRM=y
-CONFIG_XFRM_USER=m
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
 
 #
 # SCTP Configuration (EXPERIMENTAL)
@@ -456,10 +426,6 @@
 CONFIG_NET_DIVERT=y
 # CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
-
-#
-# QoS and/or fair queueing
-#
 CONFIG_NET_SCHED=y
 # CONFIG_NET_SCH_CLK_JIFFIES is not set
 CONFIG_NET_SCH_CLK_GETTIMEOFDAY=y
@@ -479,6 +445,7 @@
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -489,6 +456,7 @@
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -496,17 +464,153 @@
 # Network testing
 #
 # CONFIG_NET_PKTGEN is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
 # CONFIG_HAMRADIO is not set
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
+CONFIG_IEEE80211=m
+# CONFIG_IEEE80211_DEBUG is not set
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_IEEE80211_CRYPT_TKIP=m
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=m
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+CONFIG_BLK_DEV_RAM_COUNT=16
+# CONFIG_LBD is not set
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=y
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_SCH=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=m
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+
+#
+# SCSI low-level drivers
+#
+CONFIG_SGIWD93_SCSI=y
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
 CONFIG_NETDEVICES=y
 CONFIG_DUMMY=m
 CONFIG_BONDING=m
 CONFIG_EQUALIZER=m
 CONFIG_TUN=m
-CONFIG_ETHERTAP=m
+
+#
+# PHY device support
+#
+CONFIG_PHYLIB=m
+CONFIG_PHYCONTROL=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_QSEMI_PHY=m
+CONFIG_LXT_PHY=m
+CONFIG_CICADA_PHY=m
 
 #
 # Ethernet (10 or 100Mbit)
@@ -540,6 +644,8 @@
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
 
 #
 # ISDN subsystem
@@ -569,18 +675,6 @@
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -598,6 +692,16 @@
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -644,11 +748,14 @@
 #
 # Ftape, the floppy tape device driver
 #
-# CONFIG_DRM is not set
 CONFIG_RAW_DRIVER=m
 CONFIG_MAX_RAW_DEVS=256
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -659,10 +766,20 @@
 # CONFIG_W1 is not set
 
 #
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
 # Misc devices
 #
 
 #
+# Multimedia Capabilities Port drivers
+#
+
+#
 # Multimedia devices
 #
 # CONFIG_VIDEO_DEV is not set
@@ -693,7 +810,6 @@
 # CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_LOGO_LINUX_CLUT224 is not set
 CONFIG_LOGO_SGI_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -707,10 +823,6 @@
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -723,13 +835,17 @@
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+
+#
+# SN Devices
+#
 
 #
 # File systems
 #
 CONFIG_EXT2_FS=m
 # CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
 CONFIG_EXT3_FS=y
 CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
@@ -741,12 +857,14 @@
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
-# CONFIG_XFS_RT is not set
-CONFIG_XFS_QUOTA=y
+CONFIG_XFS_EXPORT=y
+CONFIG_XFS_QUOTA=m
 CONFIG_XFS_SECURITY=y
 # CONFIG_XFS_POSIX_ACL is not set
+# CONFIG_XFS_RT is not set
 CONFIG_MINIX_FS=m
 # CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
 CONFIG_QUOTA=y
 # CONFIG_QFMT_V1 is not set
 CONFIG_QFMT_V2=m
@@ -754,6 +872,7 @@
 CONFIG_DNOTIFY=y
 CONFIG_AUTOFS_FS=m
 CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
 
 #
 # CD-ROM/DVD Filesystems
@@ -781,12 +900,10 @@
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
-CONFIG_DEVPTS_FS_XATTR=y
-CONFIG_DEVPTS_FS_SECURITY=y
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
+CONFIG_RELAYFS_FS=m
 
 #
 # Miscellaneous filesystems
@@ -811,15 +928,20 @@
 #
 CONFIG_NFS_FS=m
 CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
 # CONFIG_NFS_V4 is not set
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
 CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
 # CONFIG_NFSD_V4 is not set
 CONFIG_NFSD_TCP=y
 CONFIG_LOCKD=m
 CONFIG_LOCKD_V4=y
 CONFIG_EXPORTFS=m
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=m
 CONFIG_SUNRPC_GSS=m
 CONFIG_RPCSEC_GSS_KRB5=m
@@ -835,6 +957,7 @@
 CONFIG_CODA_FS=m
 # CONFIG_CODA_FS_OLD_API is not set
 # CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
 
 #
 # Partition Types
@@ -908,7 +1031,9 @@
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -931,6 +1056,7 @@
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -942,10 +1068,10 @@
 CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_KHAZAD=m
 CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
@@ -955,9 +1081,12 @@
 # Library routines
 #
 # CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
 CONFIG_CRC32=m
 CONFIG_LIBCRC32C=m
-CONFIG_ZLIB_INFLATE=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_GENERIC_HARDIRQS=y
-CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
diff -Naur linux-2.6.14/arch/mips/galileo-boards/ev96100/setup.c linux-mips-2.6.14.orig/arch/mips/galileo-boards/ev96100/setup.c
--- linux-2.6.14/arch/mips/galileo-boards/ev96100/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/galileo-boards/ev96100/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -55,7 +55,7 @@
 
 unsigned char mac_0_1[12];
 
-static void __init ev96100_setup(void)
+void __init plat_setup(void)
 {
 	unsigned int config = read_c0_config();
 	unsigned int status = read_c0_status();
@@ -142,8 +142,6 @@
 	tmp = GT_READ(GT_PCI0_CFGDATA_OFS);
 }
 
-early_initcall(ev96100_setup);
-
 unsigned short get_gt_devid(void)
 {
 	u32 gt_devid;
diff -Naur linux-2.6.14/arch/mips/gt64120/ev64120/Kconfig linux-mips-2.6.14.orig/arch/mips/gt64120/ev64120/Kconfig
--- linux-2.6.14/arch/mips/gt64120/ev64120/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/gt64120/ev64120/Kconfig	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,3 @@
+config EVB_PCI1
+	bool "Enable Second PCI (PCI1)"
+	depends on MIPS_EV64120
diff -Naur linux-2.6.14/arch/mips/gt64120/ev64120/setup.c linux-mips-2.6.14.orig/arch/mips/gt64120/ev64120/setup.c
--- linux-2.6.14/arch/mips/gt64120/ev64120/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/gt64120/ev64120/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -69,7 +69,7 @@
  */
 extern void gt64120_time_init(void);
 
-static void __init ev64120_setup(void)
+void __init plat_setup(void)
 {
 	_machine_restart = galileo_machine_restart;
 	_machine_halt = galileo_machine_halt;
@@ -79,8 +79,6 @@
 	set_io_port_base(KSEG1);
 }
 
-early_initcall(ev64120_setup);
-
 const char *get_system_type(void)
 {
 	return "Galileo EV64120A";
diff -Naur linux-2.6.14/arch/mips/gt64120/momenco_ocelot/setup.c linux-mips-2.6.14.orig/arch/mips/gt64120/momenco_ocelot/setup.c
--- linux-2.6.14/arch/mips/gt64120/momenco_ocelot/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/gt64120/momenco_ocelot/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -150,7 +150,7 @@
 	gt64120_base = 0xe0000000;
 }
 
-static void __init momenco_ocelot_setup(void)
+void __init plat_setup(void)
 {
 	void (*l3func)(unsigned long)=KSEG1ADDR(&setup_l3cache);
 	unsigned int tmpword;
@@ -307,8 +307,6 @@
 	GT_WRITE(GT_DEV_B3_OFS, 0xfef73);
 }
 
-early_initcall(momenco_ocelot_setup);
-
 extern int rm7k_tcache_enabled;
 /*
  * This runs in KSEG1. See the verbiage in rm7k.c::probe_scache()
diff -Naur linux-2.6.14/arch/mips/ite-boards/generic/irq.c linux-mips-2.6.14.orig/arch/mips/ite-boards/generic/irq.c
--- linux-2.6.14/arch/mips/ite-boards/generic/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ite-boards/generic/irq.c	2005-11-17 11:42:19.000000000 -0800
@@ -138,14 +138,13 @@
 }
 
 static struct hw_interrupt_type it8172_irq_type = {
-	"ITE8172",
-	startup_ite_irq,
-	shutdown_ite_irq,
-	enable_it8172_irq,
-	disable_it8172_irq,
-	mask_and_ack_ite_irq,
-	end_ite_irq,
-	NULL
+	.typename = "ITE8172",
+	.startup = startup_ite_irq,
+	.shutdown = shutdown_ite_irq,
+	.enable = enable_it8172_irq,
+	.disable = disable_it8172_irq,
+	.ack = mask_and_ack_ite_irq,
+	.end = end_ite_irq,
 };
 
 
@@ -159,13 +158,13 @@
 #define end_none	enable_none
 
 static struct hw_interrupt_type cp0_irq_type = {
-	"CP0 Count",
-	startup_none,
-	shutdown_none,
-	enable_none,
-	disable_none,
-	ack_none,
-	end_none
+	.typename = "CP0 Count",
+	.startup = startup_none,
+	.shutdown = shutdown_none,
+	.enable = enable_none,
+	.disable = disable_none,
+	.ack = ack_none,
+	.end = end_none
 };
 
 void enable_cpu_timer(void)
@@ -182,7 +181,6 @@
 	int i;
         unsigned long flags;
 
-        memset(irq_desc, 0, sizeof(irq_desc));
         set_except_vector(0, it8172_IRQ);
 
 	/* mask all interrupts */
diff -Naur linux-2.6.14/arch/mips/ite-boards/generic/it8172_setup.c linux-mips-2.6.14.orig/arch/mips/ite-boards/generic/it8172_setup.c
--- linux-2.6.14/arch/mips/ite-boards/generic/it8172_setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/ite-boards/generic/it8172_setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -105,7 +105,7 @@
 	it8172_resources.ram.end = memsize;
 }
 
-static void __init it8172_setup(void)
+void __init plat_setup(void)
 {
 	unsigned short dsr;
 	char *argptr;
@@ -251,8 +251,6 @@
 #endif /* CONFIG_IT8172_SCR1 */
 }
 
-early_initcall(it8172_setup);
-
 #ifdef CONFIG_SERIO_I8042
 /*
  * According to the ITE Special BIOS Note for waking up the
diff -Naur linux-2.6.14/arch/mips/ite-boards/Kconfig linux-mips-2.6.14.orig/arch/mips/ite-boards/Kconfig
--- linux-2.6.14/arch/mips/ite-boards/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/ite-boards/Kconfig	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,8 @@
+config IT8172_REVC
+	bool "Support for older IT8172 (Rev C)"
+	depends on MIPS_ITE8172
+	help
+	  Say Y here to support the older, Revision C version of the Integrated
+	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
+	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
+	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
diff -Naur linux-2.6.14/arch/mips/jazz/irq.c linux-mips-2.6.14.orig/arch/mips/jazz/irq.c
--- linux-2.6.14/arch/mips/jazz/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/jazz/irq.c	2005-11-17 11:42:19.000000000 -0800
@@ -58,14 +58,13 @@
 }
 
 static struct hw_interrupt_type r4030_irq_type = {
-	"R4030",
-	startup_r4030_irq,
-	shutdown_r4030_irq,
-	enable_r4030_irq,
-	disable_r4030_irq,
-	mask_and_ack_r4030_irq,
-	end_r4030_irq,
-	NULL
+	.typename = "R4030",
+	.startup = startup_r4030_irq,
+	.shutdown = shutdown_r4030_irq,
+	.enable = enable_r4030_irq,
+	.disable = disable_r4030_irq,
+	.ack = mask_and_ack_r4030_irq,
+	.end = end_r4030_irq,
 };
 
 void __init init_r4030_ints(void)
diff -Naur linux-2.6.14/arch/mips/jazz/Kconfig linux-mips-2.6.14.orig/arch/mips/jazz/Kconfig
--- linux-2.6.14/arch/mips/jazz/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/jazz/Kconfig	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,33 @@
+config ACER_PICA_61
+	bool "Support for Acer PICA 1 chipset (EXPERIMENTAL)"
+	depends on MACH_JAZZ && EXPERIMENTAL
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
+	  kernel that runs on these, say Y here. For details about Linux on
+	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+	  <http://www.linux-mips.org/>.
+
+config MIPS_MAGNUM_4000
+	bool "Support for MIPS Magnum 4000"
+	depends on MACH_JAZZ
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_BIG_ENDIAN if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+	  kernel that runs on these, say Y here. For details about Linux on
+	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+	  <http://www.linux-mips.org/>.
+
+config OLIVETTI_M700
+	bool "Support for Olivetti M700-10"
+	depends on MACH_JAZZ
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+	  kernel that runs on these, say Y here. For details about Linux on
+	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+	  <http://www.linux-mips.org/>.
diff -Naur linux-2.6.14/arch/mips/jazz/setup.c linux-mips-2.6.14.orig/arch/mips/jazz/setup.c
--- linux-2.6.14/arch/mips/jazz/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/jazz/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -50,7 +50,7 @@
 	{ "dma2", 0xc0, 0xdf, IORESOURCE_BUSY },
 };
 
-static void __init jazz_setup(void)
+void __init plat_setup(void)
 {
 	int i;
 
@@ -97,5 +97,3 @@
 
 	vdma_init();
 }
-
-early_initcall(jazz_setup);
diff -Naur linux-2.6.14/arch/mips/jmr3927/rbhma3100/irq.c linux-mips-2.6.14.orig/arch/mips/jmr3927/rbhma3100/irq.c
--- linux-2.6.14/arch/mips/jmr3927/rbhma3100/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/jmr3927/rbhma3100/irq.c	2005-11-17 11:42:19.000000000 -0800
@@ -412,13 +412,13 @@
 }
 
 static hw_irq_controller jmr3927_irq_controller = {
-	"jmr3927_irq",
-	jmr3927_irq_startup,
-	jmr3927_irq_shutdown,
-	jmr3927_irq_enable,
-	jmr3927_irq_disable,
-	jmr3927_irq_ack,
-	jmr3927_irq_end,
+	.typename = "jmr3927_irq",
+	.startup = jmr3927_irq_startup,
+	.shutdown = jmr3927_irq_shutdown,
+	.enable = jmr3927_irq_enable,
+	.disable = jmr3927_irq_disable,
+	.ack = jmr3927_irq_ack,
+	.end = jmr3927_irq_end,
 };
 
 void jmr3927_irq_init(u32 irq_base)
diff -Naur linux-2.6.14/arch/mips/jmr3927/rbhma3100/setup.c linux-mips-2.6.14.orig/arch/mips/jmr3927/rbhma3100/setup.c
--- linux-2.6.14/arch/mips/jmr3927/rbhma3100/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/jmr3927/rbhma3100/setup.c	2005-11-17 11:42:19.000000000 -0800
@@ -44,6 +44,11 @@
 #include <linux/ioport.h>
 #include <linux/param.h>	/* for HZ */
 #include <linux/delay.h>
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
 
 #include <asm/addrspace.h>
 #include <asm/time.h>
@@ -193,7 +198,7 @@
 extern struct resource pci_io_resource;
 extern struct resource pci_mem_resource;
 
-static void __init jmr3927_setup(void)
+void __init plat_setup(void)
 {
 	char *argptr;
 
@@ -211,8 +216,8 @@
 	 */
 	ioport_resource.start = pci_io_resource.start;
 	ioport_resource.end = pci_io_resource.end;
-	iomem_resource.start = pci_mem_resource.start;
-	iomem_resource.end = pci_mem_resource.end;
+	iomem_resource.start = 0;
+	iomem_resource.end = 0xffffffff;
 
 	/* Reboot on panic */
 	panic_timeout = 180;
@@ -265,18 +270,35 @@
 		strcat(argptr, " ip=bootp");
 	}
 
-#ifdef CONFIG_TXX927_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)TX3927_SIO_REG(i);
+			req.mapbase = TX3927_SIO_REG(i);
+			req.irq = i == 0 ?
+				JMR3927_IRQ_IRC_SIO0 : JMR3927_IRQ_IRC_SIO1;
+			if (i == 0)
+				req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = JMR3927_IMCLK;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
 	argptr = prom_getcmdline();
 	if ((argptr = strstr(argptr, "console=")) == NULL) {
 		argptr = prom_getcmdline();
 		strcat(argptr, " console=ttyS1,115200");
 	}
 #endif
+#endif
 }
 
-early_initcall(jmr3927_setup);
-
-
 static void tx3927_setup(void);
 
 #ifdef CONFIG_PCI
@@ -335,7 +357,7 @@
 		       jmr3927_io_dipsw());
 }
 
-static void __init tx3927_setup(void)
+void __init plat_setup(void)
 {
 	int i;
 
diff -Naur linux-2.6.14/arch/mips/Kconfig linux-mips-2.6.14.orig/arch/mips/Kconfig
--- linux-2.6.14/arch/mips/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/Kconfig	2005-11-17 11:42:18.000000000 -0800
@@ -4,216 +4,147 @@
 	# Horrible source of confusion.  Die, die, die ...
 	select EMBEDDED
 
-# shouldn't it be per-subarchitecture?
-config ARCH_MAY_HAVE_PC_FDC
-	bool
-	default y
-
 mainmenu "Linux/MIPS Kernel Configuration"
 
 source "init/Kconfig"
 
-config SYS_SUPPORTS_32BIT_KERNEL
-	bool
-config SYS_SUPPORTS_64BIT_KERNEL
-	bool
-config CPU_SUPPORTS_32BIT_KERNEL
-	bool
-config CPU_SUPPORTS_64BIT_KERNEL
-	bool
-
-menu "Kernel type"
-
-choice
-
-	prompt "Kernel code model"
-	help
-	  You should only select this option if you have a workload that
-	  actually benefits from 64-bit processing or if your machine has
-	  large memory.  You will only be presented a single option in this
-	  menu if your system does not support both 32-bit and 64-bit kernels.
-
-config 32BIT
-	bool "32-bit kernel"
-	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
-	select TRAD_SIGNALS
-	help
-	  Select this option if you want to build a 32-bit kernel.
-
-config 64BIT
-	bool "64-bit kernel"
-	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
-	help
-	  Select this option if you want to build a 64-bit kernel.
-
-endchoice
-
-endmenu
-
 menu "Machine selection"
 
-config MACH_JAZZ
-	bool "Support for the Jazz family of machines"
-	select ARC
-	select ARC32
-	select GENERIC_ISA_DMA
-	select I8259
-	select ISA
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	help
-	 This a family of machines based on the MIPS R4030 chipset which was
-	 used by several vendors to build RISC/os and Windows NT workstations.
-	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
-	 Olivetti M700-10 workstations.
+choice
+	prompt "System type"
+	default SGI_IP22
 
-config ACER_PICA_61
-	bool "Support for Acer PICA 1 chipset (EXPERIMENTAL)"
-	depends on MACH_JAZZ && EXPERIMENTAL
+config MIPS_MTX1
+	bool "Support for 4G Systems MTX-1 board"
 	select DMA_NONCOHERENT
-	help
-	  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
-	  kernel that runs on these, say Y here. For details about Linux on
-	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
-	  <http://www.linux-mips.org/>.
+	select HW_HAS_PCI
+	select SOC_AU1500
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config MIPS_MAGNUM_4000
-	bool "Support for MIPS Magnum 4000"
-	depends on MACH_JAZZ
+config MIPS_BOSPORUS
+	bool "AMD Alchemy Bosporus board"
+	select SOC_AU1500
 	select DMA_NONCOHERENT
-	help
-	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
-	  kernel that runs on these, say Y here. For details about Linux on
-	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
-	  <http://www.linux-mips.org/>.
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config OLIVETTI_M700
-	bool "Support for Olivetti M700-10"
-	depends on MACH_JAZZ
+config MIPS_PB1000
+	bool "AMD Alchemy PB1000 board"
+	select SOC_AU1000
 	select DMA_NONCOHERENT
-	help
-	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
-	  kernel that runs on these, say Y here. For details about Linux on
-	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
-	  <http://www.linux-mips.org/>.
-
-config MACH_VR41XX
-	bool "Support for NEC VR4100 series based machines"
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config NEC_CMBVR4133
-	bool "Support for NEC CMB-VR4133"
-	depends on MACH_VR41XX
-	select CPU_VR41XX
+config MIPS_PB1100
+	bool "AMD Alchemy PB1100 board"
+	select SOC_AU1100
 	select DMA_NONCOHERENT
-	select IRQ_CPU
 	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config ROCKHOPPER
-	bool "Support for Rockhopper baseboard"
-	depends on NEC_CMBVR4133
-	select I8259
-	select HAVE_STD_PC_SERIAL_PORT
+config MIPS_PB1500
+	bool "AMD Alchemy PB1500 board"
+	select SOC_AU1500
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config CASIO_E55
-	bool "Support for CASIO CASSIOPEIA E-10/15/55/65"
-	depends on MACH_VR41XX
-	select CPU_LITTLE_ENDIAN
+config MIPS_PB1550
+	bool "AMD Alchemy PB1550 board"
+	select SOC_AU1550
 	select DMA_NONCOHERENT
-	select IRQ_CPU
-	select ISA
+	select HW_HAS_PCI
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config IBM_WORKPAD
-	bool "Support for IBM WorkPad z50"
-	depends on MACH_VR41XX
-	select CPU_LITTLE_ENDIAN
+config MIPS_PB1200
+	bool "AMD Alchemy PB1200 board"
+	select SOC_AU1200
 	select DMA_NONCOHERENT
-	select IRQ_CPU
-	select ISA
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config TANBAC_TB022X
-	bool "Support for TANBAC VR4131 multichip module and TANBAC VR4131DIMM"
-	depends on MACH_VR41XX
-	select CPU_LITTLE_ENDIAN
+config MIPS_DB1000
+	bool "AMD Alchemy DB1000 board"
+	select SOC_AU1000
 	select DMA_NONCOHERENT
-	select IRQ_CPU
 	select HW_HAS_PCI
-	help
-	  The TANBAC VR4131 multichip module(TB0225) and
-	  the TANBAC VR4131DIMM(TB0229) are MIPS-based platforms
-	  manufactured by TANBAC.
-	  Please refer to <http://www.tanbac.co.jp/>
-	  about VR4131 multichip module and VR4131DIMM.
-
-config TANBAC_TB0226
-	bool "Support for TANBAC Mbase(TB0226)"
-	depends on TANBAC_TB022X
-	select GPIO_VR41XX
-	help
-	  The TANBAC Mbase(TB0226) is a MIPS-based platform manufactured by TANBAC.
-	  Please refer to <http://www.tanbac.co.jp/> about Mbase.
-
-config TANBAC_TB0287
-	bool "Support for TANBAC Mini-ITX DIMM base(TB0287)"
-	depends on TANBAC_TB022X
-	help
-	  The TANBAC Mini-ITX DIMM base(TB0287) is a MIPS-based platform manufactured by TANBAC.
-	  Please refer to <http://www.tanbac.co.jp/> about Mini-ITX DIMM base.
-
-config VICTOR_MPC30X
-	bool "Support for Victor MP-C303/304"
-	depends on MACH_VR41XX
-	select CPU_LITTLE_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config MIPS_DB1100
+	bool "AMD Alchemy DB1100 board"
+	select SOC_AU1100
 	select DMA_NONCOHERENT
-	select IRQ_CPU
-	select HW_HAS_PCI
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config ZAO_CAPCELLA
-	bool "Support for ZAO Networks Capcella"
-	depends on MACH_VR41XX
-	select CPU_LITTLE_ENDIAN
+config MIPS_DB1500
+	bool "AMD Alchemy DB1500 board"
+	select SOC_AU1500
 	select DMA_NONCOHERENT
-	select IRQ_CPU
 	select HW_HAS_PCI
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config PCI_VR41XX
-	bool "Add PCI control unit support of NEC VR4100 series"
-	depends on MACH_VR41XX && HW_HAS_PCI
-	default y
-	select PCI
+config MIPS_DB1550
+	bool "AMD Alchemy DB1550 board"
+	select SOC_AU1550
+	select HW_HAS_PCI
+	select DMA_NONCOHERENT
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config VRC4173
-	tristate "Add NEC VRC4173 companion chip support"
-	depends on MACH_VR41XX && PCI_VR41XX
-	---help---
-	  The NEC VRC4173 is a companion chip for NEC VR4122/VR4131.
+config MIPS_DB1200
+	bool "AMD Alchemy DB1200 board"
+	select SOC_AU1200
+	select DMA_COHERENT
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config TOSHIBA_JMR3927
-	bool "Support for Toshiba JMR-TX3927 board"
+config MIPS_MIRAGE
+	bool "AMD Alchemy Mirage board"
 	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select SWAP_IO_SPACE
-	select SYS_SUPPORTS_32BIT_KERNEL
+	select SOC_AU1500
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_COBALT
 	bool "Support for Cobalt Server"
-	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select I8259
 	select IRQ_CPU
+	select MIPS_GT64111
+	select SYS_HAS_CPU_NEVADA
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MACH_DECSTATION
 	bool "Support for DECstations"
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
+	select EARLY_PRINTK
 	select IRQ_CPU
+	select SYS_HAS_CPU_R3000
+	select SYS_HAS_CPU_R4X00
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-	---help---
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
 	  This enables support for DEC's MIPS based workstations.  For details
 	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
 	  DECstation porting pages on <http://decstation.unix-ag.org/>.
@@ -234,8 +165,10 @@
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select MIPS_GT64120
+	select SYS_HAS_CPU_R5000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This is an evaluation board based on the Galileo GT-64120
 	  single-chip system controller that contains a MIPS R5000 compatible
@@ -243,10 +176,6 @@
 	  <http://www.marvell.com/>.  Say Y here if you wish to build a
 	  kernel for this platform.
 
-config EVB_PCI1
-	bool "Enable Second PCI (PCI1)"
-	depends on MIPS_EV64120
-
 config MIPS_EV96100
 	bool "Support for Galileo EV96100 Evaluation board (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -256,8 +185,11 @@
 	select MIPS_GT96100
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_R5000
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This is an evaluation board based on the Galileo GT-96100 LAN/WAN
 	  communications controllers containing a MIPS R5000 compatible core
@@ -268,8 +200,11 @@
 	bool "Support for Globespan IVR board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select ITE_BOARD_GEN
+	select SYS_HAS_CPU_NEVADA
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This is an evaluation board built by Globespan to showcase thir
 	  iVR (Internet Video Recorder) design. It utilizes a QED RM5231
@@ -277,37 +212,16 @@
 	  located at <http://www.globespan.net/>. Say Y here if you wish to
 	  build a kernel for this platform.
 
-config LASAT
-	bool "Support for LASAT Networks platforms"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_GT64120
-	select R5000_CPU_SCACHE
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
-
-config PICVUE
-	tristate "PICVUE LCD display driver"
-	depends on LASAT
-
-config PICVUE_PROC
-	tristate "PICVUE LCD display driver /proc interface"
-	depends on PICVUE
-
-config DS1603
-	bool "DS1603 RTC driver"
-	depends on LASAT
-
-config LASAT_SYSCTL
-	bool "LASAT sysctl interface"
-	depends on LASAT
-
 config MIPS_ITE8172
 	bool "Support for ITE 8172G board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select ITE_BOARD_GEN
+	select SYS_HAS_CPU_R5432
+	select SYS_HAS_CPU_NEVADA
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  Ths is an evaluation board made by ITE <http://www.ite.com.tw/>
 	  with ATX form factor that utilizes a MIPS R5000 to work with its
@@ -315,42 +229,86 @@
 	  either a NEC Vr5432 or QED RM5231. Say Y here if you wish to build
 	  a kernel for this platform.
 
-config IT8172_REVC
-	bool "Support for older IT8172 (Rev C)"
-	depends on MIPS_ITE8172
+config MACH_JAZZ
+	bool "Support for the Jazz family of machines"
+	select ARC
+	select ARC32
+	select ARCH_MAY_HAVE_PC_FDC
+	select GENERIC_ISA_DMA
+	select I8259
+	select ISA
+	select SYS_HAS_CPU_R4X00
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
 	help
-	  Say Y here to support the older, Revision C version of the Integrated
-	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
-	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
-	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
+	 This a family of machines based on the MIPS R4030 chipset which was
+	 used by several vendors to build RISC/os and Windows NT workstations.
+	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
+	 Olivetti M700-10 workstations.
+
+config LASAT
+	bool "Support for LASAT Networks platforms"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select MIPS_GT64120
+	select MIPS_NILE4
+	select R5000_CPU_SCACHE
+	select SYS_HAS_CPU_R5000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_ATLAS
 	bool "Support for MIPS Atlas board"
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
+	select IRQ_CPU
 	select HW_HAS_PCI
+	select MIPS_BOARDS_GEN
+	select MIPS_BONITO64
 	select MIPS_GT64120
+	select MIPS_MSC
+	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_CPU_NEVADA
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
-	  This enables support for the QED R5231-based MIPS Atlas evaluation
+	  This enables support for the MIPS Technologies Atlas evaluation
 	  board.
 
 config MIPS_MALTA
 	bool "Support for MIPS Malta board"
+	select ARCH_MAY_HAVE_PC_FDC
 	select BOOT_ELF32
 	select HAVE_STD_PC_SERIAL_PORT
 	select DMA_NONCOHERENT
+	select IRQ_CPU
 	select GENERIC_ISA_DMA
 	select HW_HAS_PCI
 	select I8259
+	select MIPS_BOARDS_GEN
+	select MIPS_BONITO64
 	select MIPS_GT64120
+	select MIPS_MSC
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
+	select SYS_HAS_CPU_NEVADA
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
-	  This enables support for the VR5000-based MIPS Malta evaluation
+	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
 
 config MIPS_SEAD
@@ -358,50 +316,64 @@
 	depends on EXPERIMENTAL
 	select IRQ_CPU
 	select DMA_NONCOHERENT
+	select MIPS_BOARDS_GEN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select SYS_HAS_CPU_MIPS64_R1
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This enables support for the MIPS Technologies SEAD evaluation
+	  board.
 
-config MOMENCO_OCELOT
-	bool "Support for Momentum Ocelot board"
+config MIPS_SIM
+	bool 'Support for MIPS simulator (MIPSsim)'
 	select DMA_NONCOHERENT
-	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select MIPS_GT64120
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
+	  This option enables support for MIPS Technologies MIPSsim software
+	  emulator.
 
-config MOMENCO_OCELOT_G
-	bool "Support for Momentum Ocelot-G board"
+config MOMENCO_JAGUAR_ATX
+	bool "Support for Momentum Jaguar board"
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
+	select IRQ_MV64340
+	select LIMITED_DMA
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM9000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
+	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
 
-config MOMENCO_OCELOT_C
-	bool "Support for Momentum Ocelot-C board"
+config MOMENCO_OCELOT
+	bool "Support for Momentum Ocelot board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_MV64340
-	select PCI_MARVELL
+	select IRQ_CPU_RM7K
+	select MIPS_GT64120
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
@@ -417,80 +389,95 @@
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM9000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  The Ocelot-3 is based off Discovery III System Controller and
 	  PMC-Sierra Rm79000 core.
 
-config MOMENCO_JAGUAR_ATX
-	bool "Support for Momentum Jaguar board"
-	select BOOT_ELF32
+config MOMENCO_OCELOT_C
+	bool "Support for Momentum Ocelot-C board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_CPU_RM7K
 	select IRQ_MV64340
-	select LIMITED_DMA
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
+	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
 
-config JAGUAR_DMALOW
-	bool "Low DMA Mode"
-	depends on MOMENCO_JAGUAR_ATX
-	help
-	  Select to Y if jump JP5 is set on your board, N otherwise.  Normally
-	  the jumper is set, so if you feel unsafe, just say Y.
-
-config PMC_YOSEMITE
-	bool "Support for PMC-Sierra Yosemite eval board"
-	select DMA_COHERENT
+config MOMENCO_OCELOT_G
+	bool "Support for Momentum Ocelot-G board"
+	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
-	select IRQ_CPU_RM9K
+	select PCI_MARVELL
+	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	  Yosemite is an evaluation board for the RM9000x2 processor
-	  manufactured by PMC-Sierra
+	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
+	  Momentum Computer <http://www.momenco.com/>.
 
-config HYPERTRANSPORT
-	bool "Hypertransport Support for PMC-Sierra Yosemite"
-	depends on PMC_YOSEMITE
+config MIPS_XXS1500
+	bool "Support for MyCable XXS1500 board"
+	select DMA_NONCOHERENT
+	select SOC_AU1500
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PNX8550_V2PCI
+	bool "Support for Philips PNX8550 based Viper2-PCI board"
+	select PNX8550
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PNX8550_JBS
+	bool "Support for Philips PNX8550 based JBS board"
+	select PNX8550
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config DDB5074
 	bool "Support for NEC DDB Vrc-5074 (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
+	select DDB5XXX_COMMON
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select I8259
 	select ISA
+	select SYS_HAS_CPU_R5000
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This enables support for the VR5000-based NEC DDB Vrc-5074
 	  evaluation board.
 
 config DDB5476
 	bool "Support for NEC DDB Vrc-5476"
+	select DDB5XXX_COMMON
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select I8259
 	select ISA
+	select SYS_HAS_CPU_R5432
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5476
 	  evaluation board.
@@ -501,12 +488,15 @@
 
 config DDB5477
 	bool "Support for NEC DDB Vrc-5477"
+	select DDB5XXX_COMMON
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select I8259
 	select IRQ_CPU
+	select SYS_HAS_CPU_R5432
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5477,
 	  or Rockhopper/SolutionGear boards with R5432/R5500 CPUs.
@@ -514,10 +504,25 @@
 	  Features : kernel debugging, serial terminal, NFS root fs, on-board
 	  ether port USB, AC97, PCI, etc.
 
-config DDB5477_BUS_FREQUENCY
-	int "bus frequency (in kHZ, 0 for auto-detect)"
-	depends on DDB5477
-	default 0
+config MACH_VR41XX
+	bool "Support for NEC VR41XX-based machines"
+
+config PMC_YOSEMITE
+	bool "Support for PMC-Sierra Yosemite eval board"
+	select DMA_COHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select IRQ_CPU_RM7K
+	select IRQ_CPU_RM9K
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_RM9000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	help
+	  Yosemite is an evaluation board for the RM9000x2 processor
+	  manufactured by PMC-Sierra.
 
 config QEMU
 	bool "Support for Qemu"
@@ -527,15 +532,16 @@
 	select I8259
 	select ISA
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_MIPS32_R1
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	 Qemu is a software emulator which among other architectures also
-	 can simulate a MIPS32 4Kc system.  This patch adds support for the
-	 system architecture that currently is being simulated by Qemu.  It
-	 will eventually be removed again when Qemu has the capability to
-	 simulate actual MIPS hardware platforms.  More information on Qemu
-	 can be found at http://www.linux-mips.org/wiki/Qemu.
+	  Qemu is a software emulator which among other architectures also
+	  can simulate a MIPS32 4Kc system.  This patch adds support for the
+	  system architecture that currently is being simulated by Qemu.  It
+	  will eventually be removed again when Qemu has the capability to
+	  simulate actual MIPS hardware platforms.  More information on Qemu
+	  can be found at http://www.linux-mips.org/wiki/Qemu.
 
 config SGI_IP22
 	bool "Support for SGI IP22 (Indy/Indigo2)"
@@ -543,11 +549,15 @@
 	select ARC32
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
+	select HW_HAS_EISA
 	select IP22_CPU_SCACHE
 	select IRQ_CPU
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_R4X00
+	select SYS_HAS_CPU_R5000
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
 	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
@@ -557,70 +567,18 @@
 	bool "Support for SGI IP27 (Origin200/2000)"
 	select ARC
 	select ARC64
+	select BOOT_ELF64
 	select DMA_IP27
 	select HW_HAS_PCI
 	select PCI_DOMAINS
+	select SYS_HAS_CPU_R10000
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
 	  workstations.  To compile a Linux kernel that runs on these, say Y
 	  here.
 
-#config SGI_SN0_XXL
-#	bool "IP27 XXL"
-#	depends on SGI_IP27
-#	  This options adds support for userspace processes upto 16TB size.
-#	  Normally the limit is just .5TB.
-
-config SGI_SN0_N_MODE
-	bool "IP27 N-Mode"
-	depends on SGI_IP27
-	help
-	  The nodes of Origin 200, Origin 2000 and Onyx 2 systems can be
-	  configured in either N-Modes which allows for more nodes or M-Mode
-	  which allows for more memory.  Your system is most probably
-	  running in M-Mode, so you should say N here.
-
-config ARCH_DISCONTIGMEM_ENABLE
-	bool
-	default y if SGI_IP27
-	help
-	  Say Y to upport efficient handling of discontiguous physical memory,
-	  for architectures which are either NUMA (Non-Uniform Memory Access)
-	  or have huge holes in the physical address space for other reasons.
-	  See <file:Documentation/vm/numa> for more.
-
-config NUMA
-	bool "NUMA Support"
-	depends on SGI_IP27
-	help
-	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
-	  Access).  This option is for configuring high-end multiprocessor
-	  server machines.  If in doubt, say N.
-
-config MAPPED_KERNEL
-	bool "Mapped kernel support"
-	depends on SGI_IP27
-	help
-	  Change the way a Linux kernel is loaded into memory on a MIPS64
-	  machine.  This is required in order to support text replication and
-	  NUMA.  If you need to understand it, read the source code.
-
-config REPLICATE_KTEXT
-	bool "Kernel text replication support"
-	depends on SGI_IP27
-	help
-	  Say Y here to enable replicating the kernel text across multiple
-	  nodes in a NUMA cluster.  This trades memory for speed.
-
-config REPLICATE_EXHANDLERS
-	bool "Exception handler replication support"
-	depends on SGI_IP27
-	help
-	  Say Y here to enable replicating the kernel exception handlers
-	  across multiple nodes in a NUMA cluster. This trades memory for
-	  speed.
-
 config SGI_IP32
 	bool "Support for SGI IP32 (O2) (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -633,353 +591,152 @@
 	select HW_HAS_PCI
 	select R5000_CPU_SCACHE
 	select RM7000_CPU_SCACHE
+	select SYS_HAS_CPU_R5000
+	select SYS_HAS_CPU_R10000 if BROKEN
+	select SYS_HAS_CPU_RM7000
 	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  If you want this kernel to run on SGI O2 workstation, say Y here.
 
-config SOC_AU1X00
-	bool "Support for AMD/Alchemy Au1X00 SOCs"
-	select SYS_SUPPORTS_32BIT_KERNEL
-
-choice
-	prompt "Au1X00 SOC Type"
-	depends on SOC_AU1X00
-	help
-	  Say Y here to enable support for one of three AMD/Alchemy
-	  SOCs. For additional documentation see www.amd.com.
-
-config SOC_AU1000
-	bool "SOC_AU1000"
-config SOC_AU1100
-	bool "SOC_AU1100"
-config SOC_AU1500
-	bool "SOC_AU1500"
-config SOC_AU1550
-	bool "SOC_AU1550"
-
-endchoice
-
-choice
-	prompt "AMD/Alchemy Au1x00 board support"
-	depends on SOC_AU1X00
-	help
-	  These are evaluation boards built by AMD/Alchemy to
-	  showcase their Au1X00 Internet Edge Processors. The SOC design
-	  is based on the MIPS32 architecture running at 266/400/500MHz
-	  with many integrated peripherals. Further information can be
-	  found at their website, <http://www.amd.com/>. Say Y here if you
-	  wish to build a kernel for this platform.
-
-config MIPS_PB1000
-	bool "PB1000 board"
-	depends on SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select SWAP_IO_SPACE
-
-config MIPS_PB1100
-	bool "PB1100 board"
-	depends on SOC_AU1100
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select SWAP_IO_SPACE
-
-config MIPS_PB1500
-	bool "PB1500 board"
-	depends on SOC_AU1500
-	select DMA_COHERENT
-	select HW_HAS_PCI
-
-config MIPS_PB1550
-	bool "PB1550 board"
-	depends on SOC_AU1550
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-
-config MIPS_DB1000
-	bool "DB1000 board"
-	depends on SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-
-config MIPS_DB1100
-	bool "DB1100 board"
-	depends on SOC_AU1100
-	select DMA_NONCOHERENT
-
-config MIPS_DB1500
-	bool "DB1500 board"
-	depends on SOC_AU1500
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-
-config MIPS_DB1550
-	bool "DB1550 board"
-	depends on SOC_AU1550
-	select HW_HAS_PCI
-	select DMA_COHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-
-config MIPS_BOSPORUS
-	bool "Bosporus board"
-	depends on SOC_AU1500
-	select DMA_NONCOHERENT
-
-config MIPS_MIRAGE
-	bool "Mirage board"
-	depends on SOC_AU1500
-	select DMA_NONCOHERENT
-
-config MIPS_XXS1500
-	bool "MyCable XXS1500 board"
-	depends on SOC_AU1500
-	select DMA_NONCOHERENT
-
-config MIPS_MTX1
-	bool "4G Systems MTX-1 board"
-	depends on SOC_AU1500
-	select HW_HAS_PCI
-	select DMA_NONCOHERENT
-
-endchoice
-
-config SIBYTE_SB1xxx_SOC
-	bool "Support for Broadcom BCM1xxx SOCs (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
+config SIBYTE_BIGSUR
+	bool "Support for Sibyte BigSur"
 	select BOOT_ELF32
 	select DMA_COHERENT
+	select PCI_DOMAINS
+	select SIBYTE_BCM1x80
 	select SWAP_IO_SPACE
-	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
-
-choice
-	prompt "BCM1xxx SOC-based board"
-	depends on SIBYTE_SB1xxx_SOC
-	default SIBYTE_SWARM
-	help
-	  Enable support for boards based on the SiByte line of SOCs
-	  from Broadcom.  There are configurations for the known
-	  evaluation boards, or you can choose "Other" and add your
-	  own board support code.
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_SWARM
-	bool "BCM91250A-SWARM"
+	bool "Support for Sibyte BCM91250A-SWARM"
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_SENTOSA
-	bool "BCM91250E-Sentosa"
+	bool "Support for Sibyte BCM91250E-Sentosa"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_RHONE
-	bool "BCM91125E-Rhone"
+	bool "Support for Sibyte BCM91125E-Rhone"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1125H
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_CARMEL
-	bool "BCM91120x-Carmel"
+	bool "Support for Sibyte BCM91120x-Carmel"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1120
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_PTSWARM
-	bool "BCM91250PT-PTSWARM"
+	bool "Support for Sibyte BCM91250PT-PTSWARM"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_LITTLESUR
-	bool "BCM91250C2-LittleSur"
+	bool "Support for Sibyte BCM91250C2-LittleSur"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_CRHINE
-	bool "BCM91120C-CRhine"
+	bool "Support for Sibyte BCM91120C-CRhine"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1120
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_CRHONE
-	bool "BCM91125C-CRhone"
-	select SIBYTE_BCM1125
-
-config SIBYTE_UNKNOWN
-	bool "Other"
-
-endchoice
-
-config SIBYTE_BOARD
-	bool
-	depends on SIBYTE_SB1xxx_SOC && !SIBYTE_UNKNOWN
-	default y
-
-choice
-	prompt "BCM1xxx SOC Type"
-	depends on SIBYTE_UNKNOWN
-	default SIBYTE_UNK_BCM1250
-	help
-	  Since you haven't chosen a known evaluation board from
-	  Broadcom, you must explicitly pick the SOC this kernel is
-	  targetted for.
-
-config SIBYTE_UNK_BCM1250
-	bool "BCM1250"
-	select SIBYTE_SB1250
-
-config SIBYTE_UNK_BCM1120
-	bool "BCM1120"
-	select SIBYTE_BCM1120
-
-config SIBYTE_UNK_BCM1125
-	bool "BCM1125"
+	bool "Support for Sibyte BCM91125C-CRhone"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1125
-
-config SIBYTE_UNK_BCM1125H
-	bool "BCM1125H"
-	select SIBYTE_BCM1125H
-
-endchoice
-
-config SIBYTE_SB1250
-	bool
-	select HW_HAS_PCI
-
-config SIBYTE_BCM1120
-	bool
-	select SIBYTE_BCM112X
-
-config SIBYTE_BCM1125
-	bool
-	select HW_HAS_PCI
-	select SIBYTE_BCM112X
-
-config SIBYTE_BCM1125H
-	bool
-	select HW_HAS_PCI
-	select SIBYTE_BCM112X
-
-config SIBYTE_BCM112X
-	bool
-
-choice
-	prompt "SiByte SOC Stepping"
-	depends on SIBYTE_SB1xxx_SOC
-
-config CPU_SB1_PASS_1
-	bool "1250 Pass1"
-	depends on SIBYTE_SB1250
-	select CPU_HAS_PREFETCH
-
-config CPU_SB1_PASS_2_1250
-	bool "1250 An"
-	depends on SIBYTE_SB1250
-	select CPU_SB1_PASS_2
-	help
-	  Also called BCM1250 Pass 2
-
-config CPU_SB1_PASS_2_2
-	bool "1250 Bn"
-	depends on SIBYTE_SB1250
-	select CPU_HAS_PREFETCH
-	help
-	  Also called BCM1250 Pass 2.2
-
-config CPU_SB1_PASS_4
-	bool "1250 Cn"
-	depends on SIBYTE_SB1250
-	select CPU_HAS_PREFETCH
-	help
-	  Also called BCM1250 Pass 3
-
-config CPU_SB1_PASS_2_112x
-	bool "112x Hybrid"
-	depends on SIBYTE_BCM112X
-	select CPU_SB1_PASS_2
-
-config CPU_SB1_PASS_3
-	bool "112x An"
-	depends on SIBYTE_BCM112X
-	select CPU_HAS_PREFETCH
-
-endchoice
-
-config CPU_SB1_PASS_2
-	bool
-
-config SIBYTE_HAS_LDT
-	bool
-	depends on PCI && (SIBYTE_SB1250 || SIBYTE_BCM1125H)
-	default y
-
-config SIMULATION
-	bool "Running under simulation"
-	depends on SIBYTE_SB1xxx_SOC
-	help
-	  Build a kernel suitable for running under the GDB simulator.
-	  Primarily adjusts the kernel's notion of time.
-
-config SIBYTE_CFE
-	bool "Booting from CFE"
-	depends on SIBYTE_SB1xxx_SOC
-	help
-	  Make use of the CFE API for enumerating available memory,
-	  controlling secondary CPUs, and possibly console output.
-
-config SIBYTE_CFE_CONSOLE
-	bool "Use firmware console"
-	depends on SIBYTE_CFE
-	help
-	  Use the CFE API's console write routines during boot.  Other console
-	  options (VT console, sb1250 duart console, etc.) should not be
-	  configured.
-
-config SIBYTE_STANDALONE
-	bool
-	depends on SIBYTE_SB1xxx_SOC && !SIBYTE_CFE
-	default y
-
-config SIBYTE_STANDALONE_RAM_SIZE
-	int "Memory size (in megabytes)"
-	depends on SIBYTE_STANDALONE
-	default "32"
-
-config SIBYTE_BUS_WATCHER
-	bool "Support for Bus Watcher statistics"
-	depends on SIBYTE_SB1xxx_SOC
-	help
-	  Handle and keep statistics on the bus error interrupts (COR_ECC,
-	  BAD_ECC, IO_BUS).
-
-config SIBYTE_BW_TRACE
-	bool "Capture bus trace before bus error"
-	depends on SIBYTE_BUS_WATCHER
-	help
-	  Run a continuous bus trace, dumping the raw data as soon as
-	  a ZBbus error is detected.  Cannot work if ZBbus profiling
-	  is turned on, and also will interfere with JTAG-based trace
-	  buffer activity.  Raw buffer data is dumped to console, and
-	  must be processed off-line.
-
-config SIBYTE_SB1250_PROF
-	bool "Support for SB1/SOC profiling - SB1/SCD perf counters"
-	depends on SIBYTE_SB1xxx_SOC
-
-config SIBYTE_TBPROF
-	bool "Support for ZBbus profiling"
-	depends on SIBYTE_SB1xxx_SOC
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_SB1
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SNI_RM200_PCI
 	bool "Support for SNI RM200 PCI"
 	select ARC
 	select ARC32
+	select ARCH_MAY_HAVE_PC_FDC
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select GENERIC_ISA_DMA
 	select HAVE_STD_PC_SERIAL_PORT
+	select HW_HAS_EISA
 	select HW_HAS_PCI
 	select I8259
 	select ISA
+	select SYS_HAS_CPU_R4X00
 	select SYS_SUPPORTS_32BIT_KERNEL
 	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN if EXPERIMENTAL
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  The SNI RM200 PCI was a MIPS-based platform manufactured by Siemens
 	  Nixdorf Informationssysteme (SNI), parent company of Pyramid
 	  Technology and now in turn merged with Fujitsu.  Say Y here to
 	  support this machine type.
 
+config TOSHIBA_JMR3927
+	bool "Support for Toshiba JMR-TX3927 board"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select MIPS_TX3927
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_TX39XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select TOSHIBA_BOARDS
+
 config TOSHIBA_RBTX4927
 	bool "Support for Toshiba TBTX49[23]7 board"
 	select DMA_NONCOHERENT
@@ -988,15 +745,51 @@
 	select I8259
 	select ISA
 	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_TX49XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select TOSHIBA_BOARDS
+	help
+	  This Toshiba board is based on the TX4927 processor. Say Y here to
+	  support this machine type
+
+config TOSHIBA_RBTX4938
+	bool "Support for Toshiba RBTX4938 board"
+	select HAVE_STD_PC_SERIAL_PORT
+	select DMA_NONCOHERENT
+	select GENERIC_ISA_DMA
+	select HAS_TXX9_SERIAL
+	select HW_HAS_PCI
+	select I8259
+	select ISA
+	select SWAP_IO_SPACE
+	select SYS_HAS_CPU_TX49XX
 	select SYS_SUPPORTS_32BIT_KERNEL
-	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select TOSHIBA_BOARDS
 	help
-	  This Toshiba board is based on the TX4927 processor. Say Y here to
+	  This Toshiba board is based on the TX4938 processor. Say Y here to
 	  support this machine type
 
-config TOSHIBA_FPCIB0
-	bool "FPCIB0 Backplane Support"
-	depends on TOSHIBA_RBTX4927
+endchoice
+
+source "arch/mips/ddb5xxx/Kconfig"
+source "arch/mips/gt64120/ev64120/Kconfig"
+source "arch/mips/jazz/Kconfig"
+source "arch/mips/ite-boards/Kconfig"
+source "arch/mips/lasat/Kconfig"
+source "arch/mips/momentum/Kconfig"
+source "arch/mips/pmc-sierra/Kconfig"
+source "arch/mips/sgi-ip27/Kconfig"
+source "arch/mips/sibyte/Kconfig"
+source "arch/mips/tx4927/Kconfig"
+source "arch/mips/tx4938/Kconfig"
+source "arch/mips/vr41xx/Kconfig"
+source "arch/mips/philips/pnx8550/common/Kconfig"
+
+endmenu
 
 config RWSEM_GENERIC_SPINLOCK
 	bool
@@ -1014,8 +807,9 @@
 #
 config ARC
 	bool
-	depends on SNI_RM200_PCI || SGI_IP32 || SGI_IP27 || SGI_IP22 || MIPS_MAGNUM_4000 || OLIVETTI_M700 || ACER_PICA_61
-	default y
+
+config ARCH_MAY_HAVE_PC_FDC
+	bool
 
 config DMA_COHERENT
 	bool
@@ -1034,51 +828,65 @@
 config DMA_NEED_PCI_MAP_STATE
 	bool
 
+config OWN_DMA
+	bool
+
 config EARLY_PRINTK
 	bool
-	depends on MACH_DECSTATION
-	default y
 
 config GENERIC_ISA_DMA
 	bool
-	depends on SNI_RM200_PCI || MIPS_MAGNUM_4000 || OLIVETTI_M700 || ACER_PICA_61 || MIPS_MALTA
-	default y
 
 config I8259
 	bool
-	depends on SNI_RM200_PCI || DDB5477 || DDB5476 || DDB5074 || MACH_JAZZ || MIPS_MALTA || MIPS_COBALT
-	default y
 
 config LIMITED_DMA
 	bool
 	select HIGHMEM
+	select SYS_SUPPORTS_HIGHMEM
 
 config MIPS_BONITO64
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA
-	default y
 
 config MIPS_MSC
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA
-	default y
 
 config MIPS_NILE4
 	bool
-	depends on LASAT
-	default y
 
 config MIPS_DISABLE_OBSOLETE_IDE
 	bool
 
-config CPU_LITTLE_ENDIAN
-	bool "Generate little endian code"
-	default y if ACER_PICA_61 || CASIO_E55 || DDB5074 || DDB5476 || DDB5477 || MACH_DECSTATION || IBM_WORKPAD || LASAT || MIPS_COBALT || MIPS_ITE8172 || MIPS_IVR || SOC_AU1X00 || OLIVETTI_M700 || SNI_RM200_PCI || VICTOR_MPC30X || ZAO_CAPCELLA
-	default n if MIPS_EV64120 || MIPS_EV96100 || MOMENCO_OCELOT || MOMENCO_OCELOT_G || SGI_IP22 || SGI_IP27 || SGI_IP32 || TOSHIBA_JMR3927
+#
+# Endianess selection.  Suffiently obscure so many users don't know what to
+# answer,so we try hard to limit the available choices.  Also the use of a
+# choice statement should be more obvious to the user.
+#
+choice
+	prompt "Endianess selection"
 	help
 	  Some MIPS machines can be configured for either little or big endian
-	  byte order. These modes require different kernels. Say Y if your
-	  machine is little endian, N if it's a big endian machine.
+	  byte order. These modes require different kernels and a different
+	  Linux distribution.  In general there is one prefered byteorder for a
+	  particular system but some systems are just as commonly used in the
+	  one or the other endianess.
+
+config CPU_BIG_ENDIAN
+	bool "Big endian"
+	depends on SYS_SUPPORTS_BIG_ENDIAN
+
+config CPU_LITTLE_ENDIAN
+	bool "Little endian"
+	depends on SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+
+endchoice
+
+config SYS_SUPPORTS_BIG_ENDIAN
+	bool
+
+config SYS_SUPPORTS_LITTLE_ENDIAN
+	bool
 
 config IRQ_CPU
 	bool
@@ -1086,42 +894,69 @@
 config IRQ_CPU_RM7K
 	bool
 
+config IRQ_CPU_RM9K
+	bool
+
 config IRQ_MV64340
 	bool
 
 config DDB5XXX_COMMON
 	bool
-	depends on DDB5074 || DDB5476 || DDB5477
-	default y
 
 config MIPS_BOARDS_GEN
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA || MIPS_SEAD
-	default y
 
 config MIPS_GT64111
 	bool
-	depends on MIPS_COBALT
-	default y
 
 config MIPS_GT64120
 	bool
-	depends on MIPS_EV64120 || MIPS_EV96100 || LASAT || MIPS_ATLAS || MIPS_MALTA || MOMENCO_OCELOT
-	default y
 
 config MIPS_TX3927
 	bool
-	depends on TOSHIBA_JMR3927
 	select HAS_TXX9_SERIAL
-	default y
 
 config PCI_MARVELL
 	bool
 
 config ITE_BOARD_GEN
 	bool
-	depends on MIPS_IVR || MIPS_ITE8172
-	default y
+
+config SOC_AU1000
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1100
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1500
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1550
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1200
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1X00
+	bool
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+
+config PNX8550
+	bool
+	select SOC_PNX8550
+
+config SOC_PNX8550
+	bool
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select SYS_HAS_CPU_R4X00
+	select SYS_SUPPORTS_32BIT_KERNEL
 
 config SWAP_IO_SPACE
 	bool
@@ -1148,6 +983,9 @@
 
 endchoice
 
+config ARC32
+	bool
+
 config AU1X00_USB_DEVICE
 	bool
 	depends on MIPS_PB1500 || MIPS_PB1100 || MIPS_PB1000
@@ -1155,11 +993,7 @@
 
 config MIPS_GT96100
 	bool
-	depends on MIPS_EV96100
-	default y
-	help
-	  Say Y here to support the Galileo Technology GT96100 communications
-	  controller card.  There is a web page at <http://www.galileot.com/>.
+	select MIPS_GT64120
 
 config IT8172_CIR
 	bool
@@ -1173,8 +1007,6 @@
 
 config BOOT_ELF32
 	bool
-	depends on MACH_DECSTATION || MIPS_ATLAS || MIPS_MALTA || MOMENCO_JAGUAR_ATX || MOMENCO_OCELOT_3 || SIBYTE_SB1xxx_SOC || SGI_IP32 || SGI_IP22 || SNI_RM200_PCI
-	default y
 
 config MIPS_L1_CACHE_SHIFT
 	int
@@ -1182,12 +1014,10 @@
 	default "7" if SGI_IP27
 	default "5"
 
-config ARC32
+config HAVE_STD_PC_SERIAL_PORT
 	bool
-	depends on MACH_JAZZ || SNI_RM200_PCI || SGI_IP22 || SGI_IP32
-	default y
 
-config HAVE_STD_PC_SERIAL_PORT
+config VR4181
 	bool
 
 config ARC_CONSOLE
@@ -1206,30 +1036,12 @@
 
 config ARC64
 	bool
-	depends on SGI_IP27
-	default y
 
 config BOOT_ELF64
 	bool
-	depends on SGI_IP27
-	default y
-
-#config MAPPED_PCI_IO y
-#	bool
-#	depends on SGI_IP27
-#	default y
-
-config QL_ISP_A64
-	bool
-	depends on SGI_IP27
-	default y
 
 config TOSHIBA_BOARDS
 	bool
-	depends on TOSHIBA_JMR3927 || TOSHIBA_RBTX4927
-	default y
-
-endmenu
 
 menu "CPU selection"
 
@@ -1237,18 +1049,69 @@
 	prompt "CPU type"
 	default CPU_R4X00
 
-config CPU_MIPS32
-	bool "MIPS32"
+config CPU_MIPS32_R1
+	bool "MIPS32 Release 1"
+	depends on SYS_HAS_CPU_MIPS32_R1
+	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
-
-config CPU_MIPS64
-	bool "MIPS64"
+	help
+	  Choose this option to build a kernel for release 1 or later of the
+	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
+	  MIPS processor are based on a MIPS32 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
+	  Release 2 of the MIPS32 architecture is available since several
+	  years so chances are you even have a MIPS32 Release 2 processor
+	  in which case you should choose CPU_MIPS32_R2 instead for better
+	  performance.
+
+config CPU_MIPS32_R2
+	bool "MIPS32 Release 2"
+	depends on SYS_HAS_CPU_MIPS32_R2
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	help
+	  Choose this option to build a kernel for release 2 or later of the
+	  MIPS32 architecture.  Most modern embedded systems with a 32-bit
+	  MIPS processor are based on a MIPS32 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS32_R1 is a safe bet for any MIPS32 system.
+
+config CPU_MIPS64_R1
+	bool "MIPS64 Release 1"
+	depends on SYS_HAS_CPU_MIPS64_R1
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  Choose this option to build a kernel for release 1 or later of the
+	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
+	  MIPS processor are based on a MIPS64 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.
+	  Release 2 of the MIPS64 architecture is available since several
+	  years so chances are you even have a MIPS64 Release 2 processor
+	  in which case you should choose CPU_MIPS64_R2 instead for better
+	  performance.
+
+config CPU_MIPS64_R2
+	bool "MIPS64 Release 2"
+	depends on SYS_HAS_CPU_MIPS64_R2
+	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
+	help
+	  Choose this option to build a kernel for release 2 or later of the
+	  MIPS64 architecture.  Many modern embedded systems with a 64-bit
+	  MIPS processor are based on a MIPS64 processor.  If you know the
+	  specific type of processor in your system, choose those that one
+	  otherwise CPU_MIPS64_R1 is a safe bet for any MIPS64 system.
 
 config CPU_R3000
 	bool "R3000"
+	depends on SYS_HAS_CPU_R3000
 	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
 	help
 	  Please make sure to pick the right CPU type. Linux/MIPS is not
 	  designed to be generic, i.e. Kernels compiled for R3000 CPUs will
@@ -1259,10 +1122,12 @@
 
 config CPU_TX39XX
 	bool "R39XX"
+	depends on SYS_HAS_CPU_TX39XX
 	select CPU_SUPPORTS_32BIT_KERNEL
 
 config CPU_VR41XX
 	bool "R41xx"
+	depends on SYS_HAS_CPU_VR41XX
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
 	help
@@ -1273,6 +1138,7 @@
 
 config CPU_R4300
 	bool "R4300"
+	depends on SYS_HAS_CPU_R4300
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
 	help
@@ -1280,6 +1146,7 @@
 
 config CPU_R4X00
 	bool "R4x00"
+	depends on SYS_HAS_CPU_R4X00
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
 	help
@@ -1288,11 +1155,13 @@
 
 config CPU_TX49XX
 	bool "R49XX"
+	depends on SYS_HAS_CPU_TX49XX
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
 
 config CPU_R5000
 	bool "R5000"
+	depends on SYS_HAS_CPU_R5000
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
 	help
@@ -1300,10 +1169,14 @@
 
 config CPU_R5432
 	bool "R5432"
+	depends on SYS_HAS_CPU_R5432
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 
 config CPU_R6000
 	bool "R6000"
 	depends on EXPERIMENTAL
+	depends on SYS_HAS_CPU_R6000
 	select CPU_SUPPORTS_32BIT_KERNEL
 	help
 	  MIPS Technologies R6000 and R6000A series processors.  Note these
@@ -1311,6 +1184,7 @@
 
 config CPU_NEVADA
 	bool "RM52xx"
+	depends on SYS_HAS_CPU_NEVADA
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
 	help
@@ -1319,6 +1193,8 @@
 config CPU_R8000
 	bool "R8000"
 	depends on EXPERIMENTAL
+	depends on SYS_HAS_CPU_R8000
+	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  MIPS Technologies R8000 processors.  Note these processors are
@@ -1326,25 +1202,151 @@
 
 config CPU_R10000
 	bool "R10000"
+	depends on SYS_HAS_CPU_R10000
+	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
 	help
 	  MIPS Technologies R10000-series processors.
 
 config CPU_RM7000
 	bool "RM7000"
+	depends on SYS_HAS_CPU_RM7000
+	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
 
 config CPU_RM9000
 	bool "RM9000"
+	depends on SYS_HAS_CPU_RM9000
+	select CPU_HAS_PREFETCH
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
 
 config CPU_SB1
 	bool "SB1"
+	depends on SYS_HAS_CPU_SB1
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_SUPPORTS_HIGHMEM
+
+endchoice
+
+config SYS_HAS_CPU_MIPS32_R1
+	bool
+
+config SYS_HAS_CPU_MIPS32_R2
+	bool
+
+config SYS_HAS_CPU_MIPS64_R1
+	bool
+
+config SYS_HAS_CPU_MIPS64_R2
+	bool
+
+config SYS_HAS_CPU_R3000
+	bool
+
+config SYS_HAS_CPU_TX39XX
+	bool
+
+config SYS_HAS_CPU_VR41XX
+	bool
+
+config SYS_HAS_CPU_R4300
+	bool
+
+config SYS_HAS_CPU_R4X00
+	bool
+
+config SYS_HAS_CPU_TX49XX
+	bool
+
+config SYS_HAS_CPU_R5000
+	bool
+
+config SYS_HAS_CPU_R5432
+	bool
+
+config SYS_HAS_CPU_R6000
+	bool
+
+config SYS_HAS_CPU_NEVADA
+	bool
+
+config SYS_HAS_CPU_R8000
+	bool
+
+config SYS_HAS_CPU_R10000
+	bool
+
+config SYS_HAS_CPU_RM7000
+	bool
+
+config SYS_HAS_CPU_RM9000
+	bool
+
+config SYS_HAS_CPU_SB1
+	bool
+
+endmenu
+
+#
+# These two indicate any levelof the MIPS32 and MIPS64 architecture
+#
+config CPU_MIPS32
+	bool
+	default y if CPU_MIPS32_R1 || CPU_MIPS32_R2
+
+config CPU_MIPS64
+	bool
+	default y if CPU_MIPS64_R1 || CPU_MIPS64_R2
+
+#
+# These two indicate the revision of the architecture, either 32 bot 64 bit.
+#
+config CPU_MIPSR1
+	bool
+	default y if CPU_MIPS32_R1 || CPU_MIPS64_R1
+
+config CPU_MIPSR2
+	bool
+	default y if CPU_MIPS32_R2 || CPU_MIPS64_R2
+
+config SYS_SUPPORTS_32BIT_KERNEL
+	bool
+config SYS_SUPPORTS_64BIT_KERNEL
+	bool
+config CPU_SUPPORTS_32BIT_KERNEL
+	bool
+config CPU_SUPPORTS_64BIT_KERNEL
+	bool
+
+menu "Kernel type"
+
+choice
+
+	prompt "Kernel code model"
+	help
+	  You should only select this option if you have a workload that
+	  actually benefits from 64-bit processing or if your machine has
+	  large memory.  You will only be presented a single option in this
+	  menu if your system does not support both 32-bit and 64-bit kernels.
+
+config 32BIT
+	bool "32-bit kernel"
+	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
+	select TRAD_SIGNALS
+	help
+	  Select this option if you want to build a 32-bit kernel.
+config 64BIT
+	bool "64-bit kernel"
+	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
+	help
+	  Select this option if you want to build a 64-bit kernel.
 
 endchoice
 
@@ -1416,12 +1418,43 @@
 	  SiByte Linux port.  Seems to give a small performance benefit.
 
 config CPU_HAS_PREFETCH
-	bool "Enable prefetches" if CPU_SB1 && !CPU_SB1_PASS_2
-	default y if CPU_MIPS32 || CPU_MIPS64 || CPU_RM7000 || CPU_RM9000 || CPU_R10000
+	bool
+
+config MIPS_MT
+	bool "Enable MIPS MT"
 
-config VTAG_ICACHE
-	bool "Support for Virtual Tagged I-cache" if CPU_MIPS64 || CPU_MIPS32
-	default y if CPU_SB1
+choice
+	prompt "MIPS MT options"
+	depends on MIPS_MT
+
+config MIPS_MT_SMP
+	bool "Use 1 TC on each available VPE for SMP"
+	select SMP
+
+config MIPS_VPE_LOADER
+	bool "VPE loader support."
+	depends on MIPS_MT
+	help
+	  Includes a loader for loading an elf relocatable object
+	  onto another VPE and running it.
+
+endchoice
+
+config MIPS_VPE_LOADER_TOM
+	bool "Load VPE program into memory hidden from linux"
+	depends on MIPS_VPE_LOADER
+	default y
+	help
+	  The loader can use memory that is present but has been hidden from
+	  Linux using the kernel command line option "mem=xxMB". It's up to
+	  you to ensure the amount you put in the option and the space your
+	  program requires is less or equal to the amount physically present.
+
+# this should possibly be in drivers/char, but it is rather cpu related. Hmmm
+config MIPS_VPE_APSP_API
+	bool "Enable support for AP/SP API (RTLX)"
+	depends on MIPS_VPE_LOADER
+	help
 
 config SB1_PASS_1_WORKAROUNDS
 	bool
@@ -1440,7 +1473,7 @@
 
 config 64BIT_PHYS_ADDR
 	bool "Support for 64-bit physical address space"
-	depends on (CPU_R4X00 || CPU_R5000 || CPU_RM7000 || CPU_RM9000 || CPU_R10000 || CPU_SB1 || CPU_MIPS32 || CPU_MIPS64) && 32BIT
+	depends on (CPU_R4X00 || CPU_R5000 || CPU_RM7000 || CPU_RM9000 || CPU_R10000 || CPU_SB1 || CPU_MIPS32_R1 || CPU_MIPS64_R1) && 32BIT
 
 config CPU_ADVANCED
 	bool "Override CPU Options"
@@ -1463,7 +1496,7 @@
 
 config CPU_HAS_LLDSCD
 	bool "lld/scd Instructions available" if CPU_ADVANCED
-	default y if !CPU_ADVANCED && !CPU_R3000 && !CPU_VR41XX && !CPU_TX39XX && !CPU_MIPS32
+	default y if !CPU_ADVANCED && !CPU_R3000 && !CPU_VR41XX && !CPU_TX39XX && !CPU_MIPS32_R1
 	help
 	  Say Y here if your CPU has the lld and scd instructions, the 64-bit
 	  equivalents of ll and sc.  Say Y here for better performance, N if
@@ -1477,12 +1510,52 @@
 	  machines which require flushing of write buffers in software.  Saying
 	  Y is the safe option; N may result in kernel malfunction and crashes.
 
+menu "MIPSR2 Interrupt handling"
+	depends on CPU_MIPSR2 && CPU_ADVANCED
+
+config CPU_MIPSR2_IRQ_VI
+	bool "Vectored interrupt mode"
+	help
+	   Vectored interrupt mode allowing faster dispatching of interrupts.
+	   The board support code needs to be written to take advantage of this
+	   mode.  Compatibility code is included to allow the kernel to run on
+	   a CPU that does not support vectored interrupts.  It's safe to
+	   say Y here.
+
+config CPU_MIPSR2_IRQ_EI
+	bool "External interrupt controller mode"
+	help
+	   Extended interrupt mode takes advantage of an external interrupt
+	   controller to allow fast dispatching from many possible interrupt
+	   sources. Say N unless you know that external interrupt support is
+	   required.
+
+config CPU_MIPSR2_SRS
+	bool "Make shadow set registers available for interrupt handlers"
+	depends on CPU_MIPSR2_IRQ_VI || CPU_MIPSR2_IRQ_EI
+	help
+	   Allow the kernel to use shadow register sets for fast interrupts.
+	   Interrupt handlers must be specially written to use shadow sets.
+	   Say N unless you know that shadow register set upport is needed.
+endmenu
+
 config CPU_HAS_SYNC
 	bool
 	depends on !CPU_R3000
 	default y
 
 #
+# Use the generic interrupt handling code in kernel/irq/:
+#
+config GENERIC_HARDIRQS
+	bool
+	default y
+
+config GENERIC_IRQ_PROBE
+	bool
+	default y
+
+#
 # - Highmem only makes sense for the 32-bit kernel.
 # - The current highmem code will only work properly on physically indexed
 #   caches such as R3000, SB1, R7000 or those that look like they're virtually
@@ -1491,14 +1564,19 @@
 #   where it's known to be safe.  This will not offer highmem on a few systems
 #   such as MIPS32 and MIPS64 CPUs which may have virtual and physically
 #   indexed CPUs but we're playing safe.
-# - We should not offer highmem for system of which we already know that they
-#   don't have memory configurations that could gain from highmem support in
-#   the kernel because they don't support configurations with RAM at physical
-#   addresses > 0x20000000.
+# - We use SYS_SUPPORTS_HIGHMEM to offer highmem only for systems where we
+#   know they might have memory configurations that could make use of highmem
+#   support.
 #
 config HIGHMEM
 	bool "High Memory Support"
-	depends on 32BIT && (CPU_R3000 || CPU_SB1 || CPU_R7000 || CPU_RM9000 || CPU_R10000) && !(MACH_DECSTATION || MOMENCO_JAGUAR_ATX)
+	depends on 32BIT && CPU_SUPPORTS_HIGHMEM && SYS_SUPPORTS_HIGHMEM
+
+config CPU_SUPPORTS_HIGHMEM
+	bool
+
+config SYS_SUPPORTS_HIGHMEM
+	bool
 
 config ARCH_FLATMEM_ENABLE
 	def_bool y
@@ -1508,7 +1586,7 @@
 
 config SMP
 	bool "Multi-Processing support"
-	depends on CPU_RM9000 || (SIBYTE_SB1250 && !SIBYTE_STANDALONE) || SGI_IP27
+	depends on CPU_RM9000 || ((SIBYTE_BCM1x80 || SIBYTE_BCM1x55 || SIBYTE_SB1250) && !SIBYTE_STANDALONE) || SGI_IP27 || MIPS_MT_SMP
 	---help---
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
@@ -1543,14 +1621,7 @@
 	  This is purely to save memory - each supported CPU adds
 	  approximately eight kilobytes to the kernel image.
 
-config PREEMPT
-	bool "Preemptible Kernel"
-	help
-	  This option reduces the latency of the kernel when reacting to
-	  real-time or interactive events by allowing a low priority process to
-	  be preempted even if it is in kernel mode executing a system call.
-	  This allows applications to run more reliably even when the system is
-	  under load.
+source "kernel/Kconfig.preempt"
 
 config RTC_DS1742
 	bool "DS1742 BRAM/RTC support"
@@ -1566,14 +1637,16 @@
 	  This will result in additional memory usage, so it is not
 	  recommended for normal users.
 
+endmenu
+
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
 
-endmenu
-
 menu "Bus options (PCI, PCMCIA, EISA, ISA, TC)"
 
+config HW_HAS_EISA
+	bool
 config HW_HAS_PCI
 	bool
 
@@ -1607,7 +1680,7 @@
 
 config EISA
 	bool "EISA support"
-	depends on SGI_IP22 || SNI_RM200_PCI
+	depends on HW_HAS_EISA
 	select ISA
 	---help---
 	  The Extended Industry Standard Architecture (EISA) bus was
@@ -1641,12 +1714,6 @@
 	bool
 	default y
 
-config MCA
-	bool
-
-config SBUS
-	bool
-
 source "drivers/pcmcia/Kconfig"
 
 source "drivers/pci/hotplug/Kconfig"
@@ -1659,7 +1726,6 @@
 
 config TRAD_SIGNALS
 	bool
-	default y if 32BIT
 
 config BUILD_ELF64
 	bool "Use 64-bit ELF format for building"
@@ -1678,7 +1744,7 @@
 
 config BINFMT_IRIX
 	bool "Include IRIX binary compatibility"
-	depends on !CPU_LITTLE_ENDIAN && 32BIT && BROKEN
+	depends on CPU_BIG_ENDIAN && 32BIT && BROKEN
 
 config MIPS32_COMPAT
 	bool "Kernel support for Linux/MIPS 32-bit binary compatibility"
@@ -1718,9 +1784,26 @@
 	bool
 	default y if MIPS32_O32 || MIPS32_N32
 
+config SECCOMP
+	bool "Enable seccomp to safely compute untrusted bytecode"
+	depends on PROC_FS && BROKEN
+	default y
+	help
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via /proc/<pid>/seccomp, it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+	  If unsure, say Y. Only embedded should say N here.
+
 config PM
 	bool "Power Management support (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && MACH_AU1X00
+	depends on EXPERIMENTAL && SOC_AU1X00
 
 endmenu
 
@@ -1730,6 +1813,8 @@
 
 source "fs/Kconfig"
 
+source "arch/mips/oprofile/Kconfig"
+
 source "arch/mips/Kconfig.debug"
 
 source "security/Kconfig"
@@ -1737,18 +1822,3 @@
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
-
-#
-# Use the generic interrupt handling code in kernel/irq/:
-#
-config GENERIC_HARDIRQS
-	bool
-	default y
-
-config GENERIC_IRQ_PROBE
-	bool
-	default y
-
-config ISA_DMA_API
-	bool
-	default y
diff -Naur linux-2.6.14/arch/mips/kernel/asm-offsets.c linux-mips-2.6.14.orig/arch/mips/kernel/asm-offsets.c
--- linux-2.6.14/arch/mips/kernel/asm-offsets.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/asm-offsets.c	2005-11-17 11:42:19.000000000 -0800
@@ -95,6 +95,7 @@
 	offset("#define TI_PRE_COUNT       ", struct thread_info, preempt_count);
 	offset("#define TI_ADDR_LIMIT      ", struct thread_info, addr_limit);
 	offset("#define TI_RESTART_BLOCK   ", struct thread_info, restart_block);
+	offset("#define TI_TP_VALUE	   ", struct thread_info, tp_value);
 	constant("#define _THREAD_SIZE_ORDER ", THREAD_SIZE_ORDER);
 	constant("#define _THREAD_SIZE       ", THREAD_SIZE);
 	constant("#define _THREAD_MASK       ", THREAD_MASK);
@@ -240,6 +241,7 @@
 	linefeed;
 }
 
+#ifdef CONFIG_32BIT
 void output_sc_defines(void)
 {
 	text("/* Linux sigcontext offsets. */");
@@ -251,10 +253,29 @@
 	offset("#define SC_STATUS     ", struct sigcontext, sc_status);
 	offset("#define SC_FPC_CSR    ", struct sigcontext, sc_fpc_csr);
 	offset("#define SC_FPC_EIR    ", struct sigcontext, sc_fpc_eir);
-	offset("#define SC_CAUSE      ", struct sigcontext, sc_cause);
-	offset("#define SC_BADVADDR   ", struct sigcontext, sc_badvaddr);
+	offset("#define SC_HI1        ", struct sigcontext, sc_hi1);
+	offset("#define SC_LO1        ", struct sigcontext, sc_lo1);
+	offset("#define SC_HI2        ", struct sigcontext, sc_hi2);
+	offset("#define SC_LO2        ", struct sigcontext, sc_lo2);
+	offset("#define SC_HI3        ", struct sigcontext, sc_hi3);
+	offset("#define SC_LO3        ", struct sigcontext, sc_lo3);
 	linefeed;
 }
+#endif
+
+#ifdef CONFIG_64BIT
+void output_sc_defines(void)
+{
+	text("/* Linux sigcontext offsets. */");
+	offset("#define SC_REGS       ", struct sigcontext, sc_regs);
+	offset("#define SC_FPREGS     ", struct sigcontext, sc_fpregs);
+	offset("#define SC_MDHI       ", struct sigcontext, sc_hi);
+	offset("#define SC_MDLO       ", struct sigcontext, sc_lo);
+	offset("#define SC_PC         ", struct sigcontext, sc_pc);
+	offset("#define SC_FPC_CSR    ", struct sigcontext, sc_fpc_csr);
+	linefeed;
+}
+#endif
 
 #ifdef CONFIG_MIPS32_COMPAT
 void output_sc32_defines(void)
diff -Naur linux-2.6.14/arch/mips/kernel/binfmt_elfn32.c linux-mips-2.6.14.orig/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.14/arch/mips/kernel/binfmt_elfn32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/binfmt_elfn32.c	2005-11-17 11:42:19.000000000 -0800
@@ -52,7 +52,6 @@
 
 #include <asm/processor.h>
 #include <linux/module.h>
-#include <linux/config.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
 
@@ -116,4 +115,7 @@
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#undef TASK_SIZE
+#define TASK_SIZE TASK_SIZE32
+
 #include "../../../fs/binfmt_elf.c"
diff -Naur linux-2.6.14/arch/mips/kernel/binfmt_elfo32.c linux-mips-2.6.14.orig/arch/mips/kernel/binfmt_elfo32.c
--- linux-2.6.14/arch/mips/kernel/binfmt_elfo32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/binfmt_elfo32.c	2005-11-17 11:42:19.000000000 -0800
@@ -54,7 +54,6 @@
 
 #include <asm/processor.h>
 #include <linux/module.h>
-#include <linux/config.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
 
@@ -98,7 +97,7 @@
 #define init_elf_binfmt init_elf32_binfmt
 
 #define jiffies_to_timeval jiffies_to_compat_timeval
-static __inline__ void
+static inline void
 jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)
 {
 	/*
@@ -113,21 +112,26 @@
 #undef ELF_CORE_COPY_REGS
 #define ELF_CORE_COPY_REGS(_dest,_regs) elf32_core_copy_regs(_dest,_regs);
 
-void elf32_core_copy_regs(elf_gregset_t _dest, struct pt_regs *_regs)
+void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs)
 {
 	int i;
 
-	memset(_dest, 0, sizeof(elf_gregset_t));
-
-	/* XXXKW the 6 is from EF_REG0 in gdb/gdb/mips-linux-tdep.c, include/asm-mips/reg.h */
-	for (i=6; i<38; i++)
-		_dest[i] = (elf_greg_t) _regs->regs[i-6];
-	_dest[i++] = (elf_greg_t) _regs->lo;
-	_dest[i++] = (elf_greg_t) _regs->hi;
-	_dest[i++] = (elf_greg_t) _regs->cp0_epc;
-	_dest[i++] = (elf_greg_t) _regs->cp0_badvaddr;
-	_dest[i++] = (elf_greg_t) _regs->cp0_status;
-	_dest[i++] = (elf_greg_t) _regs->cp0_cause;
+	for (i = 0; i < EF_R0; i++)
+		grp[i] = 0;
+	grp[EF_R0] = 0;
+	for (i = 1; i <= 31; i++)
+		grp[EF_R0 + i] = (elf_greg_t) regs->regs[i];
+	grp[EF_R26] = 0;
+	grp[EF_R27] = 0;
+	grp[EF_LO] = (elf_greg_t) regs->lo;
+	grp[EF_HI] = (elf_greg_t) regs->hi;
+	grp[EF_CP0_EPC] = (elf_greg_t) regs->cp0_epc;
+	grp[EF_CP0_BADVADDR] = (elf_greg_t) regs->cp0_badvaddr;
+	grp[EF_CP0_STATUS] = (elf_greg_t) regs->cp0_status;
+	grp[EF_CP0_CAUSE] = (elf_greg_t) regs->cp0_cause;
+#ifdef EF_UNUSED0
+	grp[EF_UNUSED0] = 0;
+#endif
 }
 
 MODULE_DESCRIPTION("Binary format loader for compatibility with o32 Linux/MIPS binaries");
@@ -136,4 +140,7 @@
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#undef TASK_SIZE
+#define TASK_SIZE TASK_SIZE32
+
 #include "../../../fs/binfmt_elf.c"
diff -Naur linux-2.6.14/arch/mips/kernel/branch.c linux-mips-2.6.14.orig/arch/mips/kernel/branch.c
--- linux-2.6.14/arch/mips/kernel/branch.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/branch.c	2005-11-17 11:42:19.000000000 -0800
@@ -12,6 +12,7 @@
 #include <asm/branch.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
+#include <asm/fpu.h>
 #include <asm/inst.h>
 #include <asm/ptrace.h>
 #include <asm/uaccess.h>
@@ -21,7 +22,7 @@
  */
 int __compute_return_epc(struct pt_regs *regs)
 {
-	unsigned int *addr, bit, fcr31;
+	unsigned int *addr, bit, fcr31, dspcontrol;
 	long epc;
 	union mips_instruction insn;
 
@@ -98,6 +99,18 @@
 				epc += 8;
 			regs->cp0_epc = epc;
 			break;
+		case bposge32_op:
+			if (!cpu_has_dsp)
+				goto sigill;
+
+			dspcontrol = rddsp(0x01);
+
+			if (dspcontrol >= 32) {
+				epc = epc + 4 + (insn.i_format.simmediate << 2);
+			} else
+				epc += 8;
+			regs->cp0_epc = epc;
+			break;
 		}
 		break;
 
@@ -161,10 +174,13 @@
 	 * And now the FPA/cp1 branch instructions.
 	 */
 	case cop1_op:
-		if (!cpu_has_fpu)
-			fcr31 = current->thread.fpu.soft.fcr31;
-		else
+		preempt_disable();
+		if (is_fpu_owner())
 			asm volatile("cfc1\t%0,$31" : "=r" (fcr31));
+		else
+			fcr31 = current->thread.fpu.hard.fcr31;
+		preempt_enable();
+
 		bit = (insn.i_format.rt >> 2);
 		bit += (bit != 0);
 		bit += 23;
@@ -196,4 +212,9 @@
 	printk("%s: unaligned epc - sending SIGBUS.\n", current->comm);
 	force_sig(SIGBUS, current);
 	return -EFAULT;
+
+sigill:
+	printk("%s: DSP branch but not DSP ASE - sending SIGBUS.\n", current->comm);
+	force_sig(SIGBUS, current);
+	return -EFAULT;
 }
diff -Naur linux-2.6.14/arch/mips/kernel/cpu-probe.c linux-mips-2.6.14.orig/arch/mips/kernel/cpu-probe.c
--- linux-2.6.14/arch/mips/kernel/cpu-probe.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/cpu-probe.c	2005-11-17 11:42:19.000000000 -0800
@@ -2,9 +2,9 @@
  * Processor capabilities determination functions.
  *
  * Copyright (C) xxxx  the Anonymous
- * Copyright (C) 2003  Maciej W. Rozycki
+ * Copyright (C) 2003, 2004  Maciej W. Rozycki
  * Copyright (C) 1994 - 2003 Ralf Baechle
- * Copyright (C) 2001 MIPS Inc.
+ * Copyright (C) 2001, 2004  MIPS Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -17,7 +17,6 @@
 #include <linux/ptrace.h>
 #include <linux/stddef.h>
 
-#include <asm/bugs.h>
 #include <asm/cpu.h>
 #include <asm/fpu.h>
 #include <asm/mipsregs.h>
@@ -51,36 +50,48 @@
 		".set\tmips0");
 }
 
-/*
- * The Au1xxx wait is available only if we run CONFIG_PM and
- * the timer setup found we had a 32KHz counter available.
- * There are still problems with functions that may call au1k_wait
- * directly, but that will be discovered pretty quickly.
- */
-extern void (*au1k_wait_ptr)(void);
+/* The Au1xxx wait is available only if using 32khz counter or
+ * external timer source, but specifically not CP0 Counter. */
+int allow_au1k_wait;
 
-void au1k_wait(void)
+static void au1k_wait(void)
 {
-#ifdef CONFIG_PM
 	/* using the wait instruction makes CP0 counter unusable */
-	__asm__(".set\tmips3\n\t"
+	__asm__(".set mips3\n\t"
+		"cache 0x14, 0(%0)\n\t"
+		"cache 0x14, 32(%0)\n\t"
+		"sync\n\t"
+		"nop\n\t"
 		"wait\n\t"
 		"nop\n\t"
 		"nop\n\t"
 		"nop\n\t"
 		"nop\n\t"
-		".set\tmips0");
-#else
-	__asm__("nop\n\t"
-		"nop");
-#endif
+		".set mips0\n\t"
+		: : "r" (au1k_wait));
+}
+
+static int __initdata nowait = 0;
+
+int __init wait_disable(char *s)
+{
+	nowait = 1;
+
+	return 1;
 }
 
+__setup("nowait", wait_disable);
+
 static inline void check_wait(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 
 	printk("Checking for 'wait' instruction... ");
+	if (nowait) {
+		printk (" disabled.\n");
+		return;
+	}
+
 	switch (c->cputype) {
 	case CPU_R3081:
 	case CPU_R3081E:
@@ -109,22 +120,22 @@
 /*	case CPU_20KC:*/
 	case CPU_24K:
 	case CPU_25KF:
+	case CPU_34K:
+ 	case CPU_PR4450:
 		cpu_wait = r4k_wait;
 		printk(" available.\n");
 		break;
-#ifdef CONFIG_PM
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
-		if (au1k_wait_ptr != NULL) {
-			cpu_wait = au1k_wait_ptr;
+	case CPU_AU1550:
+	case CPU_AU1200:
+		if (allow_au1k_wait) {
+			cpu_wait = au1k_wait;
 			printk(" available.\n");
-		}
-		else {
+		} else
 			printk(" unavailable.\n");
-		}
 		break;
-#endif
 	default:
 		printk(" unavailable.\n");
 		break;
@@ -180,7 +191,7 @@
 	return ((cpu_get_fpu_id() & 0xff00) != FPIR_IMP_NONE);
 }
 
-#define R4K_OPTS (MIPS_CPU_TLB | MIPS_CPU_4KEX | MIPS_CPU_4KTLB \
+#define R4K_OPTS (MIPS_CPU_TLB | MIPS_CPU_4KEX | MIPS_CPU_4K_CACHE \
 		| MIPS_CPU_COUNTER)
 
 static inline void cpu_probe_legacy(struct cpuinfo_mips *c)
@@ -189,7 +200,8 @@
 	case PRID_IMP_R2000:
 		c->cputype = CPU_R2000;
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE |
+		             MIPS_CPU_NOFPUEX;
 		if (__cpu_has_fpu())
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
@@ -203,7 +215,8 @@
 		else
 			c->cputype = CPU_R3000;
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE |
+		             MIPS_CPU_NOFPUEX;
 		if (__cpu_has_fpu())
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
@@ -229,9 +242,15 @@
 		break;
 	case PRID_IMP_VR41XX:
 		switch (c->processor_id & 0xf0) {
+#ifndef CONFIG_VR4181
 		case PRID_REV_VR4111:
 			c->cputype = CPU_VR4111;
 			break;
+#else
+		case PRID_REV_VR4181:
+			c->cputype = CPU_VR4181;
+			break;
+#endif
 		case PRID_REV_VR4121:
 			c->cputype = CPU_VR4121;
 			break;
@@ -266,7 +285,8 @@
 	case PRID_IMP_R4600:
 		c->cputype = CPU_R4600;
 		c->isa_level = MIPS_CPU_ISA_III;
-		c->options = R4K_OPTS | MIPS_CPU_FPU | MIPS_CPU_LLSC;
+		c->options = R4K_OPTS | MIPS_CPU_FPU | MIPS_CPU_32FPR |
+			     MIPS_CPU_LLSC;
 		c->tlbsize = 48;
 		break;
 	#if 0
@@ -285,7 +305,7 @@
 	#endif
 	case PRID_IMP_TX39:
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_TX39_CACHE;
 
 		if ((c->processor_id & 0xf0) == (PRID_REV_TX3927 & 0xf0)) {
 			c->cputype = CPU_TX3927;
@@ -421,74 +441,147 @@
 	}
 }
 
-static inline void decode_config1(struct cpuinfo_mips *c)
+static inline unsigned int decode_config0(struct cpuinfo_mips *c)
 {
-	unsigned long config0 = read_c0_config();
-	unsigned long config1;
+	unsigned int config0;
+	int isa;
 
-	if ((config0 & (1 << 31)) == 0)
-		return;			/* actually wort a panic() */
+	config0 = read_c0_config();
+
+	if (((config0 & MIPS_CONF_MT) >> 7) == 1)
+		c->options |= MIPS_CPU_TLB;
+	isa = (config0 & MIPS_CONF_AT) >> 13;
+	switch (isa) {
+	case 0:
+		c->isa_level = MIPS_CPU_ISA_M32;
+		break;
+	case 2:
+		c->isa_level = MIPS_CPU_ISA_M64;
+		break;
+	default:
+		panic("Unsupported ISA type, cp0.config0.at: %d.", isa);
+	}
+
+	return config0 & MIPS_CONF_M;
+}
+
+static inline unsigned int decode_config1(struct cpuinfo_mips *c)
+{
+	unsigned int config1;
 
-	/* MIPS32 or MIPS64 compliant CPU. Read Config 1 register. */
-	c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX |
-		MIPS_CPU_4KTLB | MIPS_CPU_COUNTER | MIPS_CPU_DIVEC |
-		MIPS_CPU_LLSC | MIPS_CPU_MCHECK;
 	config1 = read_c0_config1();
-	if (config1 & (1 << 3))
+
+	if (config1 & MIPS_CONF1_MD)
+		c->ases |= MIPS_ASE_MDMX;
+	if (config1 & MIPS_CONF1_WR)
 		c->options |= MIPS_CPU_WATCH;
-	if (config1 & (1 << 2))
-		c->options |= MIPS_CPU_MIPS16;
-	if (config1 & (1 << 1))
+	if (config1 & MIPS_CONF1_CA)
+		c->ases |= MIPS_ASE_MIPS16;
+	if (config1 & MIPS_CONF1_EP)
 		c->options |= MIPS_CPU_EJTAG;
-	if (config1 & 1) {
+	if (config1 & MIPS_CONF1_FP) {
 		c->options |= MIPS_CPU_FPU;
 		c->options |= MIPS_CPU_32FPR;
 	}
+	if (cpu_has_tlb)
+		c->tlbsize = ((config1 & MIPS_CONF1_TLBS) >> 25) + 1;
+
+	return config1 & MIPS_CONF_M;
+}
+
+static inline unsigned int decode_config2(struct cpuinfo_mips *c)
+{
+	unsigned int config2;
+
+	config2 = read_c0_config2();
+
+	if (config2 & MIPS_CONF2_SL)
+		c->scache.flags &= ~MIPS_CACHE_NOT_PRESENT;
+
+	return config2 & MIPS_CONF_M;
+}
+
+static inline unsigned int decode_config3(struct cpuinfo_mips *c)
+{
+	unsigned int config3;
+
+	config3 = read_c0_config3();
+
+	if (config3 & MIPS_CONF3_SM)
+		c->ases |= MIPS_ASE_SMARTMIPS;
+	if (config3 & MIPS_CONF3_DSP)
+		c->ases |= MIPS_ASE_DSP;
+	if (config3 & MIPS_CONF3_VINT)
+		c->options |= MIPS_CPU_VINT;
+	if (config3 & MIPS_CONF3_VEIC)
+		c->options |= MIPS_CPU_VEIC;
+	if (config3 & MIPS_CONF3_MT)
+                c->ases |= MIPS_ASE_MIPSMT;
+
+	return config3 & MIPS_CONF_M;
+}
+
+static inline void decode_configs(struct cpuinfo_mips *c)
+{
+	/* MIPS32 or MIPS64 compliant CPU.  */
+	c->options = MIPS_CPU_4KEX | MIPS_CPU_4K_CACHE | MIPS_CPU_COUNTER |
+	             MIPS_CPU_DIVEC | MIPS_CPU_LLSC | MIPS_CPU_MCHECK;
+
 	c->scache.flags = MIPS_CACHE_NOT_PRESENT;
 
-	c->tlbsize = ((config1 >> 25) & 0x3f) + 1;
+	/* Read Config registers.  */
+	if (!decode_config0(c))
+		return;			/* actually worth a panic() */
+	if (!decode_config1(c))
+		return;
+	if (!decode_config2(c))
+		return;
+	if (!decode_config3(c))
+		return;
 }
 
 static inline void cpu_probe_mips(struct cpuinfo_mips *c)
 {
-	decode_config1(c);
+	decode_configs(c);
 	switch (c->processor_id & 0xff00) {
 	case PRID_IMP_4KC:
 		c->cputype = CPU_4KC;
-		c->isa_level = MIPS_CPU_ISA_M32;
 		break;
 	case PRID_IMP_4KEC:
 		c->cputype = CPU_4KEC;
-		c->isa_level = MIPS_CPU_ISA_M32;
+		break;
+	case PRID_IMP_4KECR2:
+		c->cputype = CPU_4KEC;
 		break;
 	case PRID_IMP_4KSC:
+	case PRID_IMP_4KSD:
 		c->cputype = CPU_4KSC;
-		c->isa_level = MIPS_CPU_ISA_M32;
 		break;
 	case PRID_IMP_5KC:
 		c->cputype = CPU_5KC;
-		c->isa_level = MIPS_CPU_ISA_M64;
 		break;
 	case PRID_IMP_20KC:
 		c->cputype = CPU_20KC;
-		c->isa_level = MIPS_CPU_ISA_M64;
 		break;
 	case PRID_IMP_24K:
+	case PRID_IMP_24KE:
 		c->cputype = CPU_24K;
-		c->isa_level = MIPS_CPU_ISA_M32;
 		break;
 	case PRID_IMP_25KF:
 		c->cputype = CPU_25KF;
-		c->isa_level = MIPS_CPU_ISA_M64;
 		/* Probe for L2 cache */
 		c->scache.flags &= ~MIPS_CACHE_NOT_PRESENT;
 		break;
+	case PRID_IMP_34K:
+		c->cputype = CPU_34K;
+		c->isa_level = MIPS_CPU_ISA_M32;
+		break;
 	}
 }
 
 static inline void cpu_probe_alchemy(struct cpuinfo_mips *c)
 {
-	decode_config1(c);
+	decode_configs(c);
 	switch (c->processor_id & 0xff00) {
 	case PRID_IMP_AU1_REV1:
 	case PRID_IMP_AU1_REV2:
@@ -505,50 +598,70 @@
 		case 3:
 			c->cputype = CPU_AU1550;
 			break;
+		case 4:
+			c->cputype = CPU_AU1200;
+			break;
 		default:
 			panic("Unknown Au Core!");
 			break;
 		}
-		c->isa_level = MIPS_CPU_ISA_M32;
 		break;
 	}
 }
 
 static inline void cpu_probe_sibyte(struct cpuinfo_mips *c)
 {
-	decode_config1(c);
+	decode_configs(c);
+
+	/*
+	 * For historical reasons the SB1 comes with it's own variant of
+	 * cache code which eventually will be folded into c-r4k.c.  Until
+	 * then we pretend it's got it's own cache architecture.
+	 */
+	c->options &= ~MIPS_CPU_4K_CACHE;
+	c->options |= MIPS_CPU_SB1_CACHE;
+
 	switch (c->processor_id & 0xff00) {
 	case PRID_IMP_SB1:
 		c->cputype = CPU_SB1;
-		c->isa_level = MIPS_CPU_ISA_M64;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX |
-		             MIPS_CPU_COUNTER | MIPS_CPU_DIVEC |
-		             MIPS_CPU_MCHECK | MIPS_CPU_EJTAG |
-		             MIPS_CPU_WATCH | MIPS_CPU_LLSC;
-#ifndef CONFIG_SB1_PASS_1_WORKAROUNDS
+#ifdef CONFIG_SB1_PASS_1_WORKAROUNDS
 		/* FPU in pass1 is known to have issues. */
-		c->options |= MIPS_CPU_FPU | MIPS_CPU_32FPR;
+		c->options &= ~(MIPS_CPU_FPU | MIPS_CPU_32FPR);
 #endif
 		break;
+	case PRID_IMP_SB1A:
+		c->cputype = CPU_SB1A;
+		break;
 	}
 }
 
 static inline void cpu_probe_sandcraft(struct cpuinfo_mips *c)
 {
-	decode_config1(c);
+	decode_configs(c);
 	switch (c->processor_id & 0xff00) {
 	case PRID_IMP_SR71000:
 		c->cputype = CPU_SR71000;
-		c->isa_level = MIPS_CPU_ISA_M64;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX |
-		             MIPS_CPU_4KTLB | MIPS_CPU_FPU |
-		             MIPS_CPU_COUNTER | MIPS_CPU_MCHECK;
 		c->scache.ways = 8;
 		c->tlbsize = 64;
 		break;
 	}
 }
 
+static inline void cpu_probe_philips(struct cpuinfo_mips *c)
+{
+	decode_configs(c);
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_PR4450:
+		c->cputype = CPU_PR4450;
+		c->isa_level = MIPS_CPU_ISA_M32;
+		break;
+	default:
+		panic("Unknown Philips Core!"); /* REVISIT: die? */
+		break;
+	}
+}
+
+
 __init void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -571,15 +684,24 @@
 	case PRID_COMP_SIBYTE:
 		cpu_probe_sibyte(c);
 		break;
-
 	case PRID_COMP_SANDCRAFT:
 		cpu_probe_sandcraft(c);
 		break;
+ 	case PRID_COMP_PHILIPS:
+		cpu_probe_philips(c);
+ 		break;
 	default:
 		c->cputype = CPU_UNKNOWN;
 	}
-	if (c->options & MIPS_CPU_FPU)
+	if (c->options & MIPS_CPU_FPU) {
 		c->fpu_id = cpu_get_fpu_id();
+
+		if (c->isa_level == MIPS_CPU_ISA_M32 ||
+		    c->isa_level == MIPS_CPU_ISA_M64) {
+			if (c->fpu_id & MIPS_FPIR_3D)
+				c->ases |= MIPS_ASE_MIPS3D;
+		}
+	}
 }
 
 __init void cpu_report(void)
diff -Naur linux-2.6.14/arch/mips/kernel/dma-no-isa.c linux-mips-2.6.14.orig/arch/mips/kernel/dma-no-isa.c
--- linux-2.6.14/arch/mips/kernel/dma-no-isa.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/kernel/dma-no-isa.c	2005-11-17 11:42:19.000000000 -0800
@@ -0,0 +1,28 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ *
+ * Dummy ISA DMA functions for systems that don't have ISA but share drivers
+ * with ISA such as legacy free PCI.
+ */
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+DEFINE_SPINLOCK(dma_spin_lock);
+
+int request_dma(unsigned int dmanr, const char * device_id)
+{
+	return -EINVAL;
+}
+
+void free_dma(unsigned int dmanr)
+{
+}
+
+EXPORT_SYMBOL(dma_spin_lock);
+EXPORT_SYMBOL(request_dma);
+EXPORT_SYMBOL(free_dma);
diff -Naur linux-2.6.14/arch/mips/kernel/entry.S linux-mips-2.6.14.orig/arch/mips/kernel/entry.S
--- linux-2.6.14/arch/mips/kernel/entry.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/entry.S	2005-11-17 11:42:19.000000000 -0800
@@ -19,11 +19,11 @@
 #include <asm/war.h>
 
 #ifdef CONFIG_PREEMPT
-	.macro	preempt_stop reg=t0
+	.macro	preempt_stop
 	.endm
 #else
-	.macro	preempt_stop reg=t0
-	local_irq_disable \reg
+	.macro	preempt_stop
+	local_irq_disable
 	.endm
 #define resume_kernel	restore_all
 #endif
@@ -37,17 +37,18 @@
 	andi	t0, t0, KU_USER
 	beqz	t0, resume_kernel
 
-FEXPORT(resume_userspace)
-	local_irq_disable	t0	# make sure we dont miss an
+resume_userspace:
+	local_irq_disable		# make sure we dont miss an
 					# interrupt setting need_resched
 					# between sampling and return
 	LONG_L	a2, TI_FLAGS($28)	# current->work
-	andi	a2, _TIF_WORK_MASK	# (ignoring syscall_trace)
-	bnez	a2, work_pending
+	andi	t0, a2, _TIF_WORK_MASK	# (ignoring syscall_trace)
+	bnez	t0, work_pending
 	j	restore_all
 
 #ifdef CONFIG_PREEMPT
-ENTRY(resume_kernel)
+resume_kernel:
+	local_irq_disable
 	lw	t0, TI_PRE_COUNT($28)
 	bnez	t0, restore_all
 need_resched:
@@ -57,12 +58,7 @@
 	LONG_L	t0, PT_STATUS(sp)		# Interrupts off?
 	andi	t0, 1
 	beqz	t0, restore_all
-	li	t0, PREEMPT_ACTIVE
-	sw	t0, TI_PRE_COUNT($28)
-	local_irq_enable t0
-	jal	schedule
-	sw	zero, TI_PRE_COUNT($28)
-	local_irq_disable t0
+	jal	preempt_schedule_irq
 	b	need_resched
 #endif
 
@@ -88,13 +84,13 @@
 	RESTORE_SP_AND_RET
 	.set	at
 
-FEXPORT(work_pending)
-	andi	t0, a2, _TIF_NEED_RESCHED
+work_pending:
+	andi	t0, a2, _TIF_NEED_RESCHED # a2 is preloaded with TI_FLAGS
 	beqz	t0, work_notifysig
 work_resched:
 	jal	schedule
 
-	local_irq_disable t0		# make sure need_resched and
+	local_irq_disable		# make sure need_resched and
 					# signals dont change between
 					# sampling and return
 	LONG_L	a2, TI_FLAGS($28)
@@ -109,15 +105,14 @@
 	move	a0, sp
 	li	a1, 0
 	jal	do_notify_resume	# a2 already loaded
-	j	restore_all
+	j	resume_userspace
 
 FEXPORT(syscall_exit_work_partial)
 	SAVE_STATIC
-FEXPORT(syscall_exit_work)
-	LONG_L	t0, TI_FLAGS($28)
-	li	t1, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
-	and	t0, t1
-	beqz	t0, work_pending	# trace bit is set
+syscall_exit_work:
+	li	t0, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
+	and	t0, a2			# a2 is preloaded with TI_FLAGS
+	beqz	t0, work_pending	# trace bit set?
 	local_irq_enable		# could let do_syscall_trace()
 					# call schedule() instead
 	move	a0, sp
@@ -128,28 +123,25 @@
 /*
  * Common spurious interrupt handler.
  */
-	.text
-	.align  5
 LEAF(spurious_interrupt)
 	/*
 	 * Someone tried to fool us by sending an interrupt but we
 	 * couldn't find a cause for it.
 	 */
+	PTR_LA	t1, irq_err_count
 #ifdef CONFIG_SMP
-	lui     t1, %hi(irq_err_count)
-1:	ll      t0, %lo(irq_err_count)(t1)
+1:	ll      t0, (t1)
 	addiu   t0, 1
-	sc      t0, %lo(irq_err_count)(t1)
+	sc      t0, (t1)
 #if R10000_LLSC_WAR
 	beqzl	t0, 1b
 #else
 	beqz	t0, 1b
 #endif
 #else
-	lui     t1, %hi(irq_err_count)
-	lw      t0, %lo(irq_err_count)(t1)
+	lw      t0, (t1)
 	addiu   t0, 1
-	sw      t0, %lo(irq_err_count)(t1)
+	sw      t0, (t1)
 #endif
 	j	ret_from_irq
 	END(spurious_interrupt)
diff -Naur linux-2.6.14/arch/mips/kernel/gdb-low.S linux-mips-2.6.14.orig/arch/mips/kernel/gdb-low.S
--- linux-2.6.14/arch/mips/kernel/gdb-low.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/gdb-low.S	2005-11-17 11:42:19.000000000 -0800
@@ -52,16 +52,15 @@
 		/*
 		 * Called from user mode, go somewhere else.
 		 */
-		lui	k1, %hi(saved_vectors)
 		mfc0	k0, CP0_CAUSE
 		andi	k0, k0, 0x7c
 		add	k1, k1, k0
-		lw	k0, %lo(saved_vectors)(k1)
+		PTR_L	k0, saved_vectors(k1)
 		jr	k0
 		nop
 1:
 		move	k0, sp
-		subu	sp, k1, GDB_FR_SIZE*2	# see comment above
+		PTR_SUBU sp, k1, GDB_FR_SIZE*2	# see comment above
 		LONG_S	k0, GDB_FR_REG29(sp)
 		LONG_S	$2, GDB_FR_REG2(sp)
 
diff -Naur linux-2.6.14/arch/mips/kernel/gdb-stub.c linux-mips-2.6.14.orig/arch/mips/kernel/gdb-stub.c
--- linux-2.6.14/arch/mips/kernel/gdb-stub.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/gdb-stub.c	2005-11-17 11:42:19.000000000 -0800
@@ -176,8 +176,10 @@
 /*
  * spin locks for smp case
  */
-static spinlock_t kgdb_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t kgdb_cpulock[NR_CPUS] = { [0 ... NR_CPUS-1] = SPIN_LOCK_UNLOCKED};
+static DEFINE_SPINLOCK(kgdb_lock);
+static raw_spinlock_t kgdb_cpulock[NR_CPUS] = {
+	[0 ... NR_CPUS-1] = __RAW_SPIN_LOCK_UNLOCKED;
+};
 
 /*
  * BUFMAX defines the maximum number of characters in inbound/outbound buffers
@@ -637,29 +639,32 @@
  * and only one can be active at a time.
  */
 extern spinlock_t smp_call_lock;
+
 void set_async_breakpoint(unsigned long *epc)
 {
 	/* skip breaking into userland */
 	if ((*epc & 0x80000000) == 0)
 		return;
 
+#ifdef CONFIG_SMP
 	/* avoid deadlock if someone is make IPC */
 	if (spin_is_locked(&smp_call_lock))
 		return;
+#endif
 
 	async_bp.addr = *epc;
 	*epc = (unsigned long)async_breakpoint;
 }
 
-void kgdb_wait(void *arg)
+static void kgdb_wait(void *arg)
 {
 	unsigned flags;
 	int cpu = smp_processor_id();
 
 	local_irq_save(flags);
 
-	spin_lock(&kgdb_cpulock[cpu]);
-	spin_unlock(&kgdb_cpulock[cpu]);
+	__raw_spin_lock(&kgdb_cpulock[cpu]);
+	__raw_spin_unlock(&kgdb_cpulock[cpu]);
 
 	local_irq_restore(flags);
 }
@@ -707,7 +712,7 @@
 	 * acquire the CPU spinlocks
 	 */
 	for (i = num_online_cpus()-1; i >= 0; i--)
-		if (spin_trylock(&kgdb_cpulock[i]) == 0)
+		if (__raw_spin_trylock(&kgdb_cpulock[i]) == 0)
 			panic("kgdb: couldn't get cpulock %d\n", i);
 
 	/*
@@ -982,7 +987,7 @@
 exit_kgdb_exception:
 	/* release locks so other CPUs can go */
 	for (i = num_online_cpus()-1; i >= 0; i--)
-		spin_unlock(&kgdb_cpulock[i]);
+		__raw_spin_unlock(&kgdb_cpulock[i]);
 	spin_unlock(&kgdb_lock);
 
 	__flush_cache_all();
@@ -1036,12 +1041,12 @@
  * malloc is needed by gdb client in "call func()", even a private one
  * will make gdb happy
  */
-static void *malloc(size_t size)
+static void * __attribute_used__ malloc(size_t size)
 {
 	return kmalloc(size, GFP_ATOMIC);
 }
 
-static void free(void *where)
+static void __attribute_used__ free (void *where)
 {
 	kfree(where);
 }
diff -Naur linux-2.6.14/arch/mips/kernel/genex.S linux-mips-2.6.14.orig/arch/mips/kernel/genex.S
--- linux-2.6.14/arch/mips/kernel/genex.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/genex.S	2005-11-17 11:42:19.000000000 -0800
@@ -82,7 +82,7 @@
 	 li	k0, 14<<2
 	beq	k1, k0, handle_vcei
 #ifdef CONFIG_64BIT
-	dsll	k1, k1, 1
+	 dsll	k1, k1, 1
 #endif
 	.set	pop
 	PTR_L	k0, exception_handlers(k1)
@@ -90,17 +90,17 @@
 
 	/*
 	 * Big shit, we now may have two dirty primary cache lines for the same
-	 * physical address.  We can savely invalidate the line pointed to by
+	 * physical address.  We can safely invalidate the line pointed to by
 	 * c0_badvaddr because after return from this exception handler the
 	 * load / store will be re-executed.
 	 */
 handle_vced:
-	DMFC0	k0, CP0_BADVADDR
+	MFC0	k0, CP0_BADVADDR
 	li	k1, -4					# Is this ...
 	and	k0, k1					# ... really needed?
 	mtc0	zero, CP0_TAGLO
-	cache	Index_Store_Tag_D,(k0)
-	cache	Hit_Writeback_Inv_SD,(k0)
+	cache	Index_Store_Tag_D, (k0)
+	cache	Hit_Writeback_Inv_SD, (k0)
 #ifdef CONFIG_PROC_FS
 	PTR_LA	k0, vced_count
 	lw	k1, (k0)
@@ -148,6 +148,38 @@
 	__FINIT
 
 /*
+ * Vectored interrupt handler.
+ * This prototype is copied to ebase + n*IntCtl.VS and patched
+ * to invoke the handler
+ */
+NESTED(except_vec_vi, 0, sp)
+	SAVE_SOME
+	SAVE_AT
+	.set	push
+	.set	noreorder
+EXPORT(except_vec_vi_lui)
+	lui	v0, 0		/* Patched */
+	j	except_vec_vi_handler
+EXPORT(except_vec_vi_ori)
+	 ori	v0, 0		/* Patched */
+	.set	pop
+	END(except_vec_vi)
+EXPORT(except_vec_vi_end)
+
+/*
+ * Common Vectored Interrupt code
+ * Complete the register saves and invoke the handler which is passed in $v0
+ */
+NESTED(except_vec_vi_handler, 0, sp)
+	SAVE_TEMP
+	SAVE_STATIC
+	CLI
+	move	a0, sp
+	jalr	v0
+	j	ret_from_irq
+	END(except_vec_vi_handler)
+
+/*
  * EJTAG debug exception handler.
  */
 NESTED(ejtag_debug_handler, PT_SIZE, sp)
@@ -291,6 +323,8 @@
 	BUILD_HANDLER mdmx mdmx sti silent		/* #22 */
 	BUILD_HANDLER watch watch sti verbose		/* #23 */
 	BUILD_HANDLER mcheck mcheck cli verbose		/* #24 */
+	BUILD_HANDLER mt mt sti verbose			/* #25 */
+	BUILD_HANDLER dsp dsp sti silent		/* #26 */
 	BUILD_HANDLER reserved reserved sti verbose	/* others */
 
 #ifdef CONFIG_64BIT
diff -Naur linux-2.6.14/arch/mips/kernel/genrtc.c linux-mips-2.6.14.orig/arch/mips/kernel/genrtc.c
--- linux-2.6.14/arch/mips/kernel/genrtc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/genrtc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,64 +0,0 @@
-/*
- * A glue layer that provides RTC read/write to drivers/char/genrtc.c driver
- * based on MIPS internal RTC routines.  It does take care locking
- * issues so that we are SMP/Preemption safe.
- *
- * Copyright (C) 2004 MontaVista Software Inc.
- * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * Please read the COPYING file for all license details.
- */
-
-#include <linux/spinlock.h>
-
-#include <asm/rtc.h>
-#include <asm/time.h>
-
-static DEFINE_SPINLOCK(mips_rtc_lock);
-
-unsigned int get_rtc_time(struct rtc_time *time)
-{
-	unsigned long nowtime;
-
-	spin_lock(&mips_rtc_lock);
-	nowtime = rtc_get_time();
-	to_tm(nowtime, time);
-	time->tm_year -= 1900;
-	spin_unlock(&mips_rtc_lock);
-
-	return RTC_24H;
-}
-
-int set_rtc_time(struct rtc_time *time)
-{
-	unsigned long nowtime;
-	int ret;
-
-	spin_lock(&mips_rtc_lock);
-	nowtime = mktime(time->tm_year+1900, time->tm_mon+1,
-			time->tm_mday, time->tm_hour, time->tm_min,
-			time->tm_sec);
-	ret = rtc_set_time(nowtime);
-	spin_unlock(&mips_rtc_lock);
-
-	return ret;
-}
-
-unsigned int get_rtc_ss(void)
-{
-	struct rtc_time h;
-
-	get_rtc_time(&h);
-	return h.tm_sec;
-}
-
-int get_rtc_pll(struct rtc_pll_info *pll)
-{
-	return -EINVAL;
-}
-
-int set_rtc_pll(struct rtc_pll_info *pll)
-{
-	return -EINVAL;
-}
-
diff -Naur linux-2.6.14/arch/mips/kernel/head.S linux-mips-2.6.14.orig/arch/mips/kernel/head.S
--- linux-2.6.14/arch/mips/kernel/head.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/head.S	2005-11-17 11:42:19.000000000 -0800
@@ -22,11 +22,8 @@
 #include <asm/page.h>
 #include <asm/mipsregs.h>
 #include <asm/stackframe.h>
-#ifdef CONFIG_SGI_IP27
-#include <asm/sn/addrs.h>
-#include <asm/sn/sn0/hubni.h>
-#include <asm/sn/klkernvars.h>
-#endif
+
+#include <kernel-entry-init.h>
 
 	.macro	ARC64_TWIDDLE_PC
 #if defined(CONFIG_ARC64) || defined(CONFIG_MAPPED_KERNEL)
@@ -38,18 +35,6 @@
 #endif
 	.endm
 
-#ifdef CONFIG_SGI_IP27
-	/*
-	 * outputs the local nasid into res.  IP27 stuff.
-	 */
-	.macro GET_NASID_ASM res
-	dli	\res, LOCAL_HUB_ADDR(NI_STATUS_REV_ID)
-	ld	\res, (\res)
-	and	\res, NSRI_NODEID_MASK
-	dsrl	\res, NSRI_NODEID_SHFT
-	.endm
-#endif /* CONFIG_SGI_IP27 */
-
 	/*
 	 * inputs are the text nasid in t1, data nasid in t2.
 	 */
@@ -131,16 +116,21 @@
 EXPORT(stext)					# used for profiling
 EXPORT(_stext)
 
+#if defined(CONFIG_QEMU) || defined(CONFIG_MIPS_SIM)
+	/*
+	 * Give us a fighting chance of running if execution beings at the
+	 * kernel load address.  This is needed because this platform does
+	 * not have a ELF loader yet.
+	 */
+	j	kernel_entry
+#endif
 	__INIT
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
-	setup_c0_status_pri
 
-#ifdef CONFIG_SGI_IP27
-	GET_NASID_ASM	t1
-	move	t2, t1				# text and data are here
-	MAPPED_KERNEL_SETUP_TLB
-#endif /* IP27 */
+	kernel_entry_setup			# cpu specific setup
+
+	setup_c0_status_pri
 
 	ARC64_TWIDDLE_PC
 
@@ -157,6 +147,7 @@
 	LONG_S		a2, fw_arg2
 	LONG_S		a3, fw_arg3
 
+	MTC0		zero, CP0_CONTEXT	# clear context register
 	PTR_LA		$28, init_thread_union
 	PTR_ADDIU	sp, $28, _THREAD_SIZE - 32
 	set_saved_sp	sp, t0, t1
@@ -165,6 +156,10 @@
 	j		start_kernel
 	END(kernel_entry)
 
+#ifdef CONFIG_QEMU
+	__INIT
+#endif
+
 #ifdef CONFIG_SMP
 /*
  * SMP slave cpus entry point.  Board specific code for bootstrap calls this
@@ -172,20 +167,7 @@
  */
 NESTED(smp_bootstrap, 16, sp)
 	setup_c0_status_sec
-
-#ifdef CONFIG_SGI_IP27
-	GET_NASID_ASM	t1
-	dli	t0, KLDIR_OFFSET + (KLI_KERN_VARS * KLDIR_ENT_SIZE) + \
-		    KLDIR_OFF_POINTER + CAC_BASE
-	dsll	t1, NASID_SHFT
-	or	t0, t0, t1
-	ld	t0, 0(t0)			# t0 points to kern_vars struct
-	lh	t1, KV_RO_NASID_OFFSET(t0)
-	lh	t2, KV_RW_NASID_OFFSET(t0)
-	MAPPED_KERNEL_SETUP_TLB
-	ARC64_TWIDDLE_PC
-#endif /* CONFIG_SGI_IP27 */
-
+	smp_slave_setup
 	j	start_secondary
 	END(smp_bootstrap)
 #endif /* CONFIG_SMP */
@@ -200,19 +182,13 @@
 	.comm	fw_arg2, SZREG, SZREG
 	.comm	fw_arg3, SZREG, SZREG
 
-	.macro	page name, order=0
-	.globl	\name
-\name:	.size	\name, (_PAGE_SIZE << \order)
-	.org	. + (_PAGE_SIZE << \order)
-	.type	\name, @object
+	.macro page name, order
+	.comm	\name, (_PAGE_SIZE << \order), (_PAGE_SIZE << \order)
 	.endm
 
-	.data
-	.align	PAGE_SHIFT
-
 	/*
-	 * ... but on 64-bit we've got three-level pagetables with a
-	 * slightly different layout ...
+	 * On 64-bit we've got three-level pagetables with a slightly
+	 * different layout ...
 	 */
 	page	swapper_pg_dir, _PGD_ORDER
 #ifdef CONFIG_64BIT
diff -Naur linux-2.6.14/arch/mips/kernel/i8259.c linux-mips-2.6.14.orig/arch/mips/kernel/i8259.c
--- linux-2.6.14/arch/mips/kernel/i8259.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/i8259.c	2005-11-17 11:42:19.000000000 -0800
@@ -31,7 +31,7 @@
  * moves to arch independent land
  */
 
-spinlock_t DEFINE_SPINLOCK(i8259A_lock);
+DEFINE_SPINLOCK(i8259A_lock);
 
 static void end_8259A_irq (unsigned int irq)
 {
@@ -52,14 +52,13 @@
 }
 
 static struct hw_interrupt_type i8259A_irq_type = {
-	"XT-PIC",
-	startup_8259A_irq,
-	shutdown_8259A_irq,
-	enable_8259A_irq,
-	disable_8259A_irq,
-	mask_and_ack_8259A,
-	end_8259A_irq,
-	NULL
+	.typename = "XT-PIC",
+	.startup = startup_8259A_irq,
+	.shutdown = shutdown_8259A_irq,
+	.enable = enable_8259A_irq,
+	.disable = disable_8259A_irq,
+	.ack = mask_and_ack_8259A,
+	.end = end_8259A_irq,
 };
 
 /*
@@ -308,7 +307,7 @@
 
 /*
  * On systems with i8259-style interrupt controllers we assume for
- * driver compatibility reasons interrupts 0 - 15 to be the i8295
+ * driver compatibility reasons interrupts 0 - 15 to be the i8259
  * interrupts even if the hardware uses a different interrupt numbering.
  */
 void __init init_i8259_irqs (void)
@@ -322,7 +321,7 @@
 
 	for (i = 0; i < 16; i++) {
 		irq_desc[i].status = IRQ_DISABLED;
-		irq_desc[i].action = 0;
+		irq_desc[i].action = NULL;
 		irq_desc[i].depth = 1;
 		irq_desc[i].handler = &i8259A_irq_type;
 	}
diff -Naur linux-2.6.14/arch/mips/kernel/ioctl32.c linux-mips-2.6.14.orig/arch/mips/kernel/ioctl32.c
--- linux-2.6.14/arch/mips/kernel/ioctl32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/ioctl32.c	2005-11-17 11:42:19.000000000 -0800
@@ -41,12 +41,6 @@
 #define DECLARES
 #include "compat_ioctl.c"
 
-#ifdef CONFIG_SIBYTE_TBPROF
-COMPATIBLE_IOCTL(SBPROF_ZBSTART)
-COMPATIBLE_IOCTL(SBPROF_ZBSTOP)
-COMPATIBLE_IOCTL(SBPROF_ZBWAITFULL)
-#endif /* CONFIG_SIBYTE_TBPROF */
-
 /*HANDLE_IOCTL(RTC_IRQP_READ, w_long)
 COMPATIBLE_IOCTL(RTC_IRQP_SET)
 HANDLE_IOCTL(RTC_EPOCH_READ, w_long)
diff -Naur linux-2.6.14/arch/mips/kernel/irixelf.c linux-mips-2.6.14.orig/arch/mips/kernel/irixelf.c
--- linux-2.6.14/arch/mips/kernel/irixelf.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irixelf.c	2005-11-17 11:42:19.000000000 -0800
@@ -8,7 +8,7 @@
  *
  * Copyright (C) 1993 - 1994 Eric Youngdale <ericy@cais.com>
  * Copyright (C) 1996 - 2004 David S. Miller <dm@engr.sgi.com>
- * Copyright (C) 2004 Steven J. Hill <sjhill@realitydiluted.com>
+ * Copyright (C) 2004 - 2005 Steven J. Hill <sjhill@realitydiluted.com>
  */
 #include <linux/module.h>
 #include <linux/fs.h>
@@ -31,15 +31,16 @@
 #include <linux/elfcore.h>
 #include <linux/smp_lock.h>
 
-#include <asm/uaccess.h>
 #include <asm/mipsregs.h>
+#include <asm/namei.h>
 #include <asm/prctl.h>
+#include <asm/uaccess.h>
 
 #define DLINFO_ITEMS 12
 
 #include <linux/elf.h>
 
-#undef DEBUG_ELF
+#undef DEBUG
 
 static int load_irix_binary(struct linux_binprm * bprm, struct pt_regs * regs);
 static int load_irix_library(struct file *);
@@ -55,7 +56,7 @@
 #define elf_addr_t unsigned long
 #endif
 
-#ifdef DEBUG_ELF
+#ifdef DEBUG
 /* Debugging routines. */
 static char *get_elf_p_type(Elf32_Word p_type)
 {
@@ -120,7 +121,7 @@
 			print_phdr(i, ep);
 	}
 }
-#endif /* (DEBUG_ELF) */
+#endif /* DEBUG */
 
 static void set_brk(unsigned long start, unsigned long end)
 {
@@ -146,20 +147,20 @@
 	nbyte = elf_bss & (PAGE_SIZE-1);
 	if (nbyte) {
 		nbyte = PAGE_SIZE - nbyte;
-		clear_user((void *) elf_bss, nbyte);
+		clear_user((void __user *) elf_bss, nbyte);
 	}
 }
 
-unsigned long * create_irix_tables(char * p, int argc, int envc,
-				   struct elfhdr * exec, unsigned int load_addr,
-				   unsigned int interp_load_addr,
-				   struct pt_regs *regs, struct elf_phdr *ephdr)
+static unsigned long * create_irix_tables(char * p, int argc, int envc,
+	struct elfhdr * exec, unsigned int load_addr,
+	unsigned int interp_load_addr, struct pt_regs *regs,
+	struct elf_phdr *ephdr)
 {
 	elf_addr_t *argv;
 	elf_addr_t *envp;
 	elf_addr_t *sp, *csp;
 
-#ifdef DEBUG_ELF
+#ifdef DEBUG
 	printk("create_irix_tables: p[%p] argc[%d] envc[%d] "
 	       "load_addr[%08x] interp_load_addr[%08x]\n",
 	       p, argc, envc, load_addr, interp_load_addr);
@@ -248,14 +249,13 @@
 	last_bss = 0;
 	error = load_addr = 0;
 
-#ifdef DEBUG_ELF
+#ifdef DEBUG
 	print_elfhdr(interp_elf_ex);
 #endif
 
 	/* First of all, some simple consistency checks */
 	if ((interp_elf_ex->e_type != ET_EXEC &&
 	     interp_elf_ex->e_type != ET_DYN) ||
-	     !irix_elf_check_arch(interp_elf_ex) ||
 	     !interpreter->f_op->mmap) {
 		printk("IRIX interp has bad e_type %d\n", interp_elf_ex->e_type);
 		return 0xffffffff;
@@ -290,7 +290,7 @@
 			   (char *) elf_phdata,
 			   sizeof(struct elf_phdr) * interp_elf_ex->e_phnum);
 
-#ifdef DEBUG_ELF
+#ifdef DEBUG
 	dump_phdrs(elf_phdata, interp_elf_ex->e_phnum);
 #endif
 
@@ -306,13 +306,11 @@
 	    elf_type |= MAP_FIXED;
 	    vaddr = eppnt->p_vaddr;
 
-#ifdef DEBUG_ELF
-	    printk("INTERP do_mmap(%p, %08lx, %08lx, %08lx, %08lx, %08lx) ",
+	    pr_debug("INTERP do_mmap(%p, %08lx, %08lx, %08lx, %08lx, %08lx) ",
 		   interpreter, vaddr,
 		   (unsigned long) (eppnt->p_filesz + (eppnt->p_vaddr & 0xfff)),
 		   (unsigned long) elf_prot, (unsigned long) elf_type,
 		   (unsigned long) (eppnt->p_offset & 0xfffff000));
-#endif
 	    down_write(&current->mm->mmap_sem);
 	    error = do_mmap(interpreter, vaddr,
 			    eppnt->p_filesz + (eppnt->p_vaddr & 0xfff),
@@ -324,14 +322,10 @@
 		    printk("Aieee IRIX interp mmap error=%d\n", error);
 		    break;  /* Real error */
 	    }
-#ifdef DEBUG_ELF
-	    printk("error=%08lx ", (unsigned long) error);
-#endif
+	    pr_debug("error=%08lx ", (unsigned long) error);
 	    if(!load_addr && interp_elf_ex->e_type == ET_DYN) {
 	      load_addr = error;
-#ifdef DEBUG_ELF
-              printk("load_addr = error ");
-#endif
+              pr_debug("load_addr = error ");
 	    }
 
 	    /* Find the end of the file  mapping for this phdr, and keep
@@ -345,17 +339,13 @@
 	     */
 	    k = eppnt->p_memsz + eppnt->p_vaddr;
 	    if(k > last_bss) last_bss = k;
-#ifdef DEBUG_ELF
-	    printk("\n");
-#endif
+	    pr_debug("\n");
 	  }
 	}
 
 	/* Now use mmap to map the library into memory. */
 	if(error < 0 && error > -1024) {
-#ifdef DEBUG_ELF
-		printk("got error %d\n", error);
-#endif
+		pr_debug("got error %d\n", error);
 		kfree(elf_phdata);
 		return 0xffffffff;
 	}
@@ -365,16 +355,12 @@
 	 * that there are zero-mapped pages up to and including the
 	 * last bss page.
 	 */
-#ifdef DEBUG_ELF
-	printk("padzero(%08lx) ", (unsigned long) (elf_bss));
-#endif
+	pr_debug("padzero(%08lx) ", (unsigned long) (elf_bss));
 	padzero(elf_bss);
 	len = (elf_bss + 0xfff) & 0xfffff000; /* What we have mapped so far */
 
-#ifdef DEBUG_ELF
-	printk("last_bss[%08lx] len[%08lx]\n", (unsigned long) last_bss,
-	       (unsigned long) len);
-#endif
+	pr_debug("last_bss[%08lx] len[%08lx]\n", (unsigned long) last_bss,
+	         (unsigned long) len);
 
 	/* Map the last of the bss segment */
 	if (last_bss > len) {
@@ -396,12 +382,7 @@
 
 	/* First of all, some simple consistency checks */
 	if((ehp->e_type != ET_EXEC && ehp->e_type != ET_DYN) ||
-	    !irix_elf_check_arch(ehp) || !bprm->file->f_op->mmap) {
-		return -ENOEXEC;
-	}
-
-	/* Only support MIPS ARCH2 or greater IRIX binaries for now. */
-	if(!(ehp->e_flags & EF_MIPS_ARCH) && !(ehp->e_flags & 0x04)) {
+	    !bprm->file->f_op->mmap) {
 		return -ENOEXEC;
 	}
 
@@ -411,16 +392,17 @@
 	 * XXX all registers as 64bits on cpu's capable of this at
 	 * XXX exception time plus frob the XTLB exception vector.
 	 */
-	if((ehp->e_flags & 0x20)) {
+	if((ehp->e_flags & EF_MIPS_ABI2))
 		return -ENOEXEC;
-	}
 
-	return 0; /* It's ok. */
+	return 0;
 }
 
-#define IRIX_INTERP_PREFIX "/usr/gnemul/irix"
-
-/* Look for an IRIX ELF interpreter. */
+/*
+ * This is where the detailed check is performed. Irix binaries
+ * use interpreters with 'libc.so' in the name, so this function
+ * can differentiate between Linux and Irix binaries.
+ */
 static inline int look_for_irix_interpreter(char **name,
 					    struct file **interpreter,
 					    struct elfhdr *interp_elf_ex,
@@ -440,12 +422,11 @@
 		if (*name != NULL)
 			goto out;
 
-		*name = kmalloc((epp->p_filesz + strlen(IRIX_INTERP_PREFIX)),
-				GFP_KERNEL);
+		*name = kmalloc(epp->p_filesz + strlen(IRIX_EMUL), GFP_KERNEL);
 		if (!*name)
 			return -ENOMEM;
 
-		strcpy(*name, IRIX_INTERP_PREFIX);
+		strcpy(*name, IRIX_EMUL);
 		retval = kernel_read(bprm->file, epp->p_offset, (*name + 16),
 		                     epp->p_filesz);
 		if (retval < 0)
@@ -562,7 +543,7 @@
  * process and the system, here we map the page and fill the
  * structure
  */
-void irix_map_prda_page (void)
+static void irix_map_prda_page(void)
 {
 	unsigned long v;
 	struct prda *pp;
@@ -601,14 +582,33 @@
 
 	load_addr = 0;
 	has_interp = has_ephdr = 0;
-	elf_ihdr = elf_ephdr = 0;
+	elf_ihdr = elf_ephdr = NULL;
 	elf_ex = *((struct elfhdr *) bprm->buf);
 	retval = -ENOEXEC;
 
 	if (verify_binary(&elf_ex, bprm))
 		goto out;
 
-#ifdef DEBUG_ELF
+	/*
+	 * Telling -o32 static binaries from Linux and Irix apart from each
+	 * other is difficult. There are 2 differences to be noted for static
+	 * binaries from the 2 operating systems:
+	 *
+	 *    1) Irix binaries have their .text section before their .init
+	 *       section. Linux binaries are just the opposite.
+	 *
+	 *    2) Irix binaries usually have <= 12 sections and Linux
+	 *       binaries have > 20.
+	 *
+	 * We will use Method #2 since Method #1 would require us to read in
+	 * the section headers which is way too much overhead. This appears
+	 * to work for everything we have ran into so far. If anyone has a
+	 * better method to tell the binaries apart, I'm listening.
+	 */
+	if (elf_ex.e_shnum > 20)
+		goto out;
+
+#ifdef DEBUG
 	print_elfhdr(&elf_ex);
 #endif
 
@@ -623,11 +623,10 @@
 	}
 
 	retval = kernel_read(bprm->file, elf_ex.e_phoff, (char *)elf_phdata, size);
-
 	if (retval < 0)
 		goto out_free_ph;
 
-#ifdef DEBUG_ELF
+#ifdef DEBUG
 	dump_phdrs(elf_phdata, elf_ex.e_phnum);
 #endif
 
@@ -644,9 +643,8 @@
 			break;
 		};
 	}
-#ifdef DEBUG_ELF
-	printk("\n");
-#endif
+
+	pr_debug("\n");
 
 	elf_bss = 0;
 	elf_brk = 0;
@@ -657,12 +655,19 @@
 	end_code = 0;
 	end_data = 0;
 
-	retval = look_for_irix_interpreter(&elf_interpreter,
-	                                   &interpreter,
+	/*
+	 * If we get a return value, we change the value to be ENOEXEC
+	 * so that we can exit gracefully and the main binary format
+	 * search loop in 'fs/exec.c' will move onto the next handler
+	 * which should be the normal ELF binary handler.
+	 */
+	retval = look_for_irix_interpreter(&elf_interpreter, &interpreter,
 					   &interp_elf_ex, elf_phdata, bprm,
 					   elf_ex.e_phnum);
-	if (retval)
+	if (retval) {
+		retval = -ENOEXEC;
 		goto out_free_file;
+	}
 
 	if (elf_interpreter) {
 		retval = verify_irix_interpreter(&interp_elf_ex);
@@ -746,18 +751,16 @@
 	 * IRIX maps a page at 0x200000 which holds some system
 	 * information.  Programs depend on this.
 	 */
-	irix_map_prda_page ();
+	irix_map_prda_page();
 
 	padzero(elf_bss);
 
-#ifdef DEBUG_ELF
-	printk("(start_brk) %lx\n" , (long) current->mm->start_brk);
-	printk("(end_code) %lx\n" , (long) current->mm->end_code);
-	printk("(start_code) %lx\n" , (long) current->mm->start_code);
-	printk("(end_data) %lx\n" , (long) current->mm->end_data);
-	printk("(start_stack) %lx\n" , (long) current->mm->start_stack);
-	printk("(brk) %lx\n" , (long) current->mm->brk);
-#endif
+	pr_debug("(start_brk) %lx\n" , (long) current->mm->start_brk);
+	pr_debug("(end_code) %lx\n" , (long) current->mm->end_code);
+	pr_debug("(start_code) %lx\n" , (long) current->mm->start_code);
+	pr_debug("(end_data) %lx\n" , (long) current->mm->end_data);
+	pr_debug("(start_stack) %lx\n" , (long) current->mm->start_stack);
+	pr_debug("(brk) %lx\n" , (long) current->mm->brk);
 
 #if 0 /* XXX No fucking way dude... */
 	/* Why this, you ask???  Well SVr4 maps page 0 as read-only,
@@ -782,8 +785,7 @@
 	allow_write_access(interpreter);
 	fput(interpreter);
 out_free_interp:
-	if (elf_interpreter)
-		kfree(elf_interpreter);
+	kfree(elf_interpreter);
 out_free_file:
 out_free_ph:
 	kfree (elf_phdata);
@@ -813,7 +815,7 @@
 
 	/* First of all, some simple consistency checks. */
 	if(elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||
-	   !irix_elf_check_arch(&elf_ex) || !file->f_op->mmap)
+	   !file->f_op->mmap)
 		return -ENOEXEC;
 
 	/* Now read in all of the header information. */
@@ -874,35 +876,36 @@
  * phdrs there are in the USER_PHDRP array.  We return the vaddr the
  * first phdr was successfully mapped to.
  */
-unsigned long irix_mapelf(int fd, struct elf_phdr *user_phdrp, int cnt)
+unsigned long irix_mapelf(int fd, struct elf_phdr __user *user_phdrp, int cnt)
 {
-	struct elf_phdr *hp;
+	unsigned long type, vaddr, filesz, offset, flags;
+	struct elf_phdr __user *hp;
 	struct file *filp;
 	int i, retval;
 
-#ifdef DEBUG_ELF
-	printk("irix_mapelf: fd[%d] user_phdrp[%p] cnt[%d]\n",
-	       fd, user_phdrp, cnt);
-#endif
+	pr_debug("irix_mapelf: fd[%d] user_phdrp[%p] cnt[%d]\n",
+	         fd, user_phdrp, cnt);
 
 	/* First get the verification out of the way. */
 	hp = user_phdrp;
 	if (!access_ok(VERIFY_READ, hp, (sizeof(struct elf_phdr) * cnt))) {
-#ifdef DEBUG_ELF
-		printk("irix_mapelf: access_ok fails!\n");
-#endif
+		pr_debug("irix_mapelf: bad pointer to ELF PHDR!\n");
+
 		return -EFAULT;
 	}
 
-#ifdef DEBUG_ELF
+#ifdef DEBUG
 	dump_phdrs(user_phdrp, cnt);
 #endif
 
-	for(i = 0; i < cnt; i++, hp++)
-		if(hp->p_type != PT_LOAD) {
+	for (i = 0; i < cnt; i++, hp++) {
+		if (__get_user(type, &hp->p_type))
+			return -EFAULT;
+		if (type != PT_LOAD) {
 			printk("irix_mapelf: One section is not PT_LOAD!\n");
 			return -ENOEXEC;
 		}
+	}
 
 	filp = fget(fd);
 	if (!filp)
@@ -917,29 +920,40 @@
 	for(i = 0; i < cnt; i++, hp++) {
 		int prot;
 
-		prot  = (hp->p_flags & PF_R) ? PROT_READ : 0;
-		prot |= (hp->p_flags & PF_W) ? PROT_WRITE : 0;
-		prot |= (hp->p_flags & PF_X) ? PROT_EXEC : 0;
+		retval = __get_user(vaddr, &hp->p_vaddr);
+		retval |= __get_user(filesz, &hp->p_filesz);
+		retval |= __get_user(offset, &hp->p_offset);
+		retval |= __get_user(flags, &hp->p_flags);
+		if (retval)
+			return retval;
+
+		prot  = (flags & PF_R) ? PROT_READ : 0;
+		prot |= (flags & PF_W) ? PROT_WRITE : 0;
+		prot |= (flags & PF_X) ? PROT_EXEC : 0;
+
 		down_write(&current->mm->mmap_sem);
-		retval = do_mmap(filp, (hp->p_vaddr & 0xfffff000),
-				 (hp->p_filesz + (hp->p_vaddr & 0xfff)),
+		retval = do_mmap(filp, (vaddr & 0xfffff000),
+				 (filesz + (vaddr & 0xfff)),
 				 prot, (MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE),
-				 (hp->p_offset & 0xfffff000));
+				 (offset & 0xfffff000));
 		up_write(&current->mm->mmap_sem);
 
-		if(retval != (hp->p_vaddr & 0xfffff000)) {
+		if (retval != (vaddr & 0xfffff000)) {
 			printk("irix_mapelf: do_mmap fails with %d!\n", retval);
 			fput(filp);
 			return retval;
 		}
 	}
 
-#ifdef DEBUG_ELF
-	printk("irix_mapelf: Success, returning %08lx\n",
-		(unsigned long) user_phdrp->p_vaddr);
-#endif
+	pr_debug("irix_mapelf: Success, returning %08lx\n",
+		 (unsigned long) user_phdrp->p_vaddr);
+
 	fput(filp);
-	return user_phdrp->p_vaddr;
+
+	if (__get_user(vaddr, &user_phdrp->p_vaddr))
+		return -EFAULT;
+
+	return vaddr;
 }
 
 /*
@@ -952,9 +966,9 @@
 /* These are the only things you should do on a core-file: use only these
  * functions to write out all the necessary info.
  */
-static int dump_write(struct file *file, const void *addr, int nr)
+static int dump_write(struct file *file, const void __user *addr, int nr)
 {
-	return file->f_op->write(file, addr, nr, &file->f_pos) == nr;
+	return file->f_op->write(file, (const char __user *) addr, nr, &file->f_pos) == nr;
 }
 
 static int dump_seek(struct file *file, off_t off)
@@ -1073,7 +1087,7 @@
 	/* Count what's needed to dump, up to the limit of coredump size. */
 	segs = 0;
 	size = 0;
-	for(vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {
+	for (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {
 		if (maydump(vma))
 		{
 			int sz = vma->vm_end-vma->vm_start;
@@ -1187,9 +1201,9 @@
 
 		len = current->mm->arg_end - current->mm->arg_start;
 		len = len >= ELF_PRARGSZ ? ELF_PRARGSZ : len;
-		copy_from_user(&psinfo.pr_psargs,
-			       (const char *)current->mm->arg_start, len);
-		for(i = 0; i < len; i++)
+		(void *) copy_from_user(&psinfo.pr_psargs,
+			       (const char __user *)current->mm->arg_start, len);
+		for (i = 0; i < len; i++)
 			if (psinfo.pr_psargs[i] == 0)
 				psinfo.pr_psargs[i] = ' ';
 		psinfo.pr_psargs[len] = 0;
@@ -1256,8 +1270,10 @@
 		phdr.p_memsz = sz;
 		offset += phdr.p_filesz;
 		phdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;
-		if (vma->vm_flags & VM_WRITE) phdr.p_flags |= PF_W;
-		if (vma->vm_flags & VM_EXEC) phdr.p_flags |= PF_X;
+		if (vma->vm_flags & VM_WRITE)
+			phdr.p_flags |= PF_W;
+		if (vma->vm_flags & VM_EXEC)
+			phdr.p_flags |= PF_X;
 		phdr.p_align = PAGE_SIZE;
 
 		DUMP_WRITE(&phdr, sizeof(phdr));
@@ -1283,7 +1299,7 @@
 #ifdef DEBUG
 		printk("elf_core_dump: writing %08lx %lx\n", addr, len);
 #endif
-		DUMP_WRITE((void *)addr, len);
+		DUMP_WRITE((void __user *)addr, len);
 	}
 
 	if ((off_t) file->f_pos != offset) {
@@ -1299,7 +1315,7 @@
 
 static int __init init_irix_binfmt(void)
 {
-	int init_inventory(void);
+	extern int init_inventory(void);
 	extern asmlinkage unsigned long sys_call_table;
 	extern asmlinkage unsigned long sys_call_table_irix5;
 
@@ -1318,7 +1334,9 @@
 
 static void __exit exit_irix_binfmt(void)
 {
-	/* Remove the IRIX ELF loaders. */
+	/*
+	 * Remove the Irix ELF loader.
+	 */
 	unregister_binfmt(&irix_format);
 }
 
diff -Naur linux-2.6.14/arch/mips/kernel/irixinv.c linux-mips-2.6.14.orig/arch/mips/kernel/irixinv.c
--- linux-2.6.14/arch/mips/kernel/irixinv.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irixinv.c	2005-11-17 11:42:19.000000000 -0800
@@ -30,10 +30,10 @@
 	inventory_items++;
 }
 
-int dump_inventory_to_user (void *userbuf, int size)
+int dump_inventory_to_user (void __user *userbuf, int size)
 {
 	inventory_t *inv  = &inventory [0];
-	inventory_t *user = userbuf;
+	inventory_t __user *user = userbuf;
 	int v;
 
 	if (!access_ok(VERIFY_WRITE, userbuf, size))
@@ -41,7 +41,8 @@
 
 	for (v = 0; v < inventory_items; v++){
 		inv = &inventory [v];
-		copy_to_user (user, inv, sizeof (inventory_t));
+		if (copy_to_user (user, inv, sizeof (inventory_t)))
+			return -EFAULT;
 		user++;
 	}
 	return inventory_items * sizeof (inventory_t);
diff -Naur linux-2.6.14/arch/mips/kernel/irixioctl.c linux-mips-2.6.14.orig/arch/mips/kernel/irixioctl.c
--- linux-2.6.14/arch/mips/kernel/irixioctl.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irixioctl.c	2005-11-17 11:42:19.000000000 -0800
@@ -59,7 +59,7 @@
 {
 	struct tty_struct *tp, *rtp;
 	mm_segment_t old_fs;
-	int error = 0;
+	int i, error = 0;
 
 #ifdef DEBUG_IOCTLS
 	printk("[%s:%d] irix_ioctl(%d, ", current->comm, current->pid, fd);
@@ -74,12 +74,13 @@
 
 	case 0x0000540d: {
 		struct termios kt;
-		struct irix_termios *it = (struct irix_termios *) arg;
+		struct irix_termios __user *it =
+			(struct irix_termios __user *) arg;
 
 #ifdef DEBUG_IOCTLS
 		printk("TCGETS, %08lx) ", arg);
 #endif
-		if(!access_ok(VERIFY_WRITE, it, sizeof(*it))) {
+		if (!access_ok(VERIFY_WRITE, it, sizeof(*it))) {
 			error = -EFAULT;
 			break;
 		}
@@ -88,13 +89,14 @@
 		set_fs(old_fs);
 		if (error)
 			break;
-		__put_user(kt.c_iflag, &it->c_iflag);
-		__put_user(kt.c_oflag, &it->c_oflag);
-		__put_user(kt.c_cflag, &it->c_cflag);
-		__put_user(kt.c_lflag, &it->c_lflag);
-		for(error = 0; error < NCCS; error++)
-			__put_user(kt.c_cc[error], &it->c_cc[error]);
-		error = 0;
+
+		error = __put_user(kt.c_iflag, &it->c_iflag);
+		error |= __put_user(kt.c_oflag, &it->c_oflag);
+		error |= __put_user(kt.c_cflag, &it->c_cflag);
+		error |= __put_user(kt.c_lflag, &it->c_lflag);
+
+		for (i = 0; i < NCCS; i++)
+			error |= __put_user(kt.c_cc[i], &it->c_cc[i]);
 		break;
 	}
 
@@ -112,14 +114,19 @@
 		old_fs = get_fs(); set_fs(get_ds());
 		error = sys_ioctl(fd, TCGETS, (unsigned long) &kt);
 		set_fs(old_fs);
-		if(error)
+		if (error)
+			break;
+
+		error = __get_user(kt.c_iflag, &it->c_iflag);
+		error |= __get_user(kt.c_oflag, &it->c_oflag);
+		error |= __get_user(kt.c_cflag, &it->c_cflag);
+		error |= __get_user(kt.c_lflag, &it->c_lflag);
+
+		for (i = 0; i < NCCS; i++)
+			error |= __get_user(kt.c_cc[i], &it->c_cc[i]);
+
+		if (error)
 			break;
-		__get_user(kt.c_iflag, &it->c_iflag);
-		__get_user(kt.c_oflag, &it->c_oflag);
-		__get_user(kt.c_cflag, &it->c_cflag);
-		__get_user(kt.c_lflag, &it->c_lflag);
-		for(error = 0; error < NCCS; error++)
-			__get_user(kt.c_cc[error], &it->c_cc[error]);
 		old_fs = get_fs(); set_fs(get_ds());
 		error = sys_ioctl(fd, TCSETS, (unsigned long) &kt);
 		set_fs(old_fs);
@@ -153,7 +160,7 @@
 #ifdef DEBUG_IOCTLS
 		printk("rtp->session=%d ", rtp->session);
 #endif
-		error = put_user(rtp->session, (unsigned long *) arg);
+		error = put_user(rtp->session, (unsigned long __user *) arg);
 		break;
 
 	case 0x746e:
@@ -195,50 +202,32 @@
 		break;
 
 	case 0x8004667e:
-#ifdef DEBUG_IOCTLS
-		printk("FIONBIO, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, FIONBIO, arg);
 		break;
 
 	case 0x80047476:
-#ifdef DEBUG_IOCTLS
-		printk("TIOCSPGRP, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, TIOCSPGRP, arg);
 		break;
 
 	case 0x8020690c:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCSIFADDR, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCSIFADDR, arg);
 		break;
 
 	case 0x80206910:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCSIFFLAGS, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCSIFFLAGS, arg);
 		break;
 
 	case 0xc0206911:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCGIFFLAGS, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCGIFFLAGS, arg);
 		break;
 
 	case 0xc020691b:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCGIFMETRIC, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCGIFMETRIC, arg);
 		break;
 
 	default: {
 #ifdef DEBUG_MISSING_IOCTL
-		char *msg = "Unimplemented IOCTL cmd tell linux@engr.sgi.com\n";
+		char *msg = "Unimplemented IOCTL cmd tell linux-mips@linux-mips.org\n";
 
 #ifdef DEBUG_IOCTLS
 		printk("UNIMP_IOCTL, %08lx)\n", arg);
diff -Naur linux-2.6.14/arch/mips/kernel/irixsig.c linux-mips-2.6.14.orig/arch/mips/kernel/irixsig.c
--- linux-2.6.14/arch/mips/kernel/irixsig.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irixsig.c	2005-11-17 11:42:19.000000000 -0800
@@ -76,36 +76,39 @@
 }
 #endif
 
-static void setup_irix_frame(struct k_sigaction *ka, struct pt_regs *regs,
-			     int signr, sigset_t *oldmask)
+static int setup_irix_frame(struct k_sigaction *ka, struct pt_regs *regs,
+			    int signr, sigset_t *oldmask)
 {
+	struct sigctx_irix5 __user *ctx;
 	unsigned long sp;
-	struct sigctx_irix5 *ctx;
-	int i;
+	int error, i;
 
 	sp = regs->regs[29];
 	sp -= sizeof(struct sigctx_irix5);
 	sp &= ~(0xf);
-	ctx = (struct sigctx_irix5 *) sp;
+	ctx = (struct sigctx_irix5 __user *) sp;
 	if (!access_ok(VERIFY_WRITE, ctx, sizeof(*ctx)))
 		goto segv_and_exit;
 
-	__put_user(0, &ctx->weird_fpu_thing);
-	__put_user(~(0x00000001), &ctx->rmask);
-	__put_user(0, &ctx->regs[0]);
+	error = __put_user(0, &ctx->weird_fpu_thing);
+	error |= __put_user(~(0x00000001), &ctx->rmask);
+	error |= __put_user(0, &ctx->regs[0]);
 	for(i = 1; i < 32; i++)
-		__put_user((u64) regs->regs[i], &ctx->regs[i]);
+		error |= __put_user((u64) regs->regs[i], &ctx->regs[i]);
 
-	__put_user((u64) regs->hi, &ctx->hi);
-	__put_user((u64) regs->lo, &ctx->lo);
-	__put_user((u64) regs->cp0_epc, &ctx->pc);
-	__put_user(!!used_math(), &ctx->usedfp);
-	__put_user((u64) regs->cp0_cause, &ctx->cp0_cause);
-	__put_user((u64) regs->cp0_badvaddr, &ctx->cp0_badvaddr);
+	error |= __put_user((u64) regs->hi, &ctx->hi);
+	error |= __put_user((u64) regs->lo, &ctx->lo);
+	error |= __put_user((u64) regs->cp0_epc, &ctx->pc);
+	error |= __put_user(!!used_math(), &ctx->usedfp);
+	error |= __put_user((u64) regs->cp0_cause, &ctx->cp0_cause);
+	error |= __put_user((u64) regs->cp0_badvaddr, &ctx->cp0_badvaddr);
 
-	__put_user(0, &ctx->sstk_flags); /* XXX sigstack unimp... todo... */
+	error |= __put_user(0, &ctx->sstk_flags); /* XXX sigstack unimp... todo... */
 
-	__copy_to_user(&ctx->sigset, oldmask, sizeof(irix_sigset_t));
+	error |= __copy_to_user(&ctx->sigset, oldmask, sizeof(irix_sigset_t)) ? -EFAULT : 0;
+
+	if (error)
+		goto segv_and_exit;
 
 #ifdef DEBUG_SIG
 	dump_irix5_sigctx(ctx);
@@ -117,13 +120,14 @@
 	regs->regs[7] = (unsigned long) ka->sa.sa_handler;
 	regs->regs[25] = regs->cp0_epc = (unsigned long) ka->sa_restorer;
 
-	return;
+	return 1;
 
 segv_and_exit:
 	force_sigsegv(signr, current);
+	return 0;
 }
 
-static void inline
+static int inline
 setup_irix_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
                int signr, sigset_t *oldmask, siginfo_t *info)
 {
@@ -131,9 +135,11 @@
 	do_exit(SIGSEGV);
 }
 
-static inline void handle_signal(unsigned long sig, siginfo_t *info,
+static inline int handle_signal(unsigned long sig, siginfo_t *info,
 	struct k_sigaction *ka, sigset_t *oldset, struct pt_regs * regs)
 {
+	int ret;
+
 	switch(regs->regs[0]) {
 	case ERESTARTNOHAND:
 		regs->regs[2] = EINTR;
@@ -151,9 +157,9 @@
 	regs->regs[0] = 0;		/* Don't deal with this again.  */
 
 	if (ka->sa.sa_flags & SA_SIGINFO)
-		setup_irix_rt_frame(ka, regs, sig, oldset, info);
+		ret = setup_irix_rt_frame(ka, regs, sig, oldset, info);
 	else
-		setup_irix_frame(ka, regs, sig, oldset);
+		ret = setup_irix_frame(ka, regs, sig, oldset);
 
 	spin_lock_irq(&current->sighand->siglock);
 	sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
@@ -161,6 +167,8 @@
 		sigaddset(&current->blocked,sig);
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
+
+	return ret;
 }
 
 asmlinkage int do_irix_signal(sigset_t *oldset, struct pt_regs *regs)
@@ -184,10 +192,8 @@
 		oldset = &current->blocked;
 
 	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
-	if (signr > 0) {
-		handle_signal(signr, &info, &ka, oldset, regs);
-		return 1;
-	}
+	if (signr > 0)
+		return handle_signal(signr, &info, &ka, oldset, regs);
 
 no_signal:
 	/*
@@ -208,10 +214,11 @@
 asmlinkage void
 irix_sigreturn(struct pt_regs *regs)
 {
-	struct sigctx_irix5 *context, *magic;
+	struct sigctx_irix5 __user *context, *magic;
 	unsigned long umask, mask;
 	u64 *fregs;
-	int sig, i, base = 0;
+	u32 usedfp;
+	int error, sig, i, base = 0;
 	sigset_t blocked;
 
 	/* Always make any pending restarted system calls return -EINTR */
@@ -220,8 +227,8 @@
 	if (regs->regs[2] == 1000)
 		base = 1;
 
-	context = (struct sigctx_irix5 *) regs->regs[base + 4];
-	magic = (struct sigctx_irix5 *) regs->regs[base + 5];
+	context = (struct sigctx_irix5 __user *) regs->regs[base + 4];
+	magic = (struct sigctx_irix5 __user *) regs->regs[base + 5];
 	sig = (int) regs->regs[base + 6];
 #ifdef DEBUG_SIG
 	printk("[%s:%d] IRIX sigreturn(scp[%p],ucp[%p],sig[%d])\n",
@@ -236,25 +243,31 @@
 	dump_irix5_sigctx(context);
 #endif
 
-	__get_user(regs->cp0_epc, &context->pc);
-	umask = context->rmask; mask = 2;
+	error = __get_user(regs->cp0_epc, &context->pc);
+	error |= __get_user(umask, &context->rmask);
+
+	mask = 2;
 	for (i = 1; i < 32; i++, mask <<= 1) {
-		if(umask & mask)
-			__get_user(regs->regs[i], &context->regs[i]);
+		if (umask & mask)
+			error |= __get_user(regs->regs[i], &context->regs[i]);
 	}
-	__get_user(regs->hi, &context->hi);
-	__get_user(regs->lo, &context->lo);
+	error |= __get_user(regs->hi, &context->hi);
+	error |= __get_user(regs->lo, &context->lo);
 
-	if ((umask & 1) && context->usedfp) {
+	error |= __get_user(usedfp, &context->usedfp);
+	if ((umask & 1) && usedfp) {
 		fregs = (u64 *) &current->thread.fpu;
+
 		for(i = 0; i < 32; i++)
-			fregs[i] = (u64) context->fpregs[i];
-		__get_user(current->thread.fpu.hard.fcr31, &context->fpcsr);
+			error |= __get_user(fregs[i], &context->fpregs[i]);
+		error |= __get_user(current->thread.fpu.hard.fcr31, &context->fpcsr);
 	}
 
 	/* XXX do sigstack crapola here... XXX */
 
-	if (__copy_from_user(&blocked, &context->sigset, sizeof(blocked)))
+	error |= __copy_from_user(&blocked, &context->sigset, sizeof(blocked)) ? -EFAULT : 0;
+
+	if (error)
 		goto badframe;
 
 	sigdelsetmask(&blocked, ~_BLOCKABLE);
@@ -296,8 +309,8 @@
 #endif
 
 asmlinkage int
-irix_sigaction(int sig, const struct sigaction *act,
-	      struct sigaction *oact, void *trampoline)
+irix_sigaction(int sig, const struct sigaction __user *act,
+	      struct sigaction __user *oact, void __user *trampoline)
 {
 	struct k_sigaction new_ka, old_ka;
 	int ret;
@@ -311,12 +324,16 @@
 #endif
 	if (act) {
 		sigset_t mask;
-		if (!access_ok(VERIFY_READ, act, sizeof(*act)) ||
-		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
-		    __get_user(new_ka.sa.sa_flags, &act->sa_flags))
+		int err;
+
+		if (!access_ok(VERIFY_READ, act, sizeof(*act)))
 			return -EFAULT;
+		err = __get_user(new_ka.sa.sa_handler, &act->sa_handler);
+		err |= __get_user(new_ka.sa.sa_flags, &act->sa_flags);
 
-		__copy_from_user(&mask, &act->sa_mask, sizeof(sigset_t));
+		err |= __copy_from_user(&mask, &act->sa_mask, sizeof(sigset_t)) ? -EFAULT : 0;
+		if (err)
+			return err;
 
 		/*
 		 * Hmmm... methinks IRIX libc always passes a valid trampoline
@@ -330,30 +347,37 @@
 	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
 
 	if (!ret && oact) {
-		if (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||
-		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
-		    __put_user(old_ka.sa.sa_flags, &oact->sa_flags))
+		int err;
+
+		if (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)))
+			return -EFAULT;
+
+		err = __put_user(old_ka.sa.sa_handler, &oact->sa_handler);
+		err |= __put_user(old_ka.sa.sa_flags, &oact->sa_flags);
+		err |= __copy_to_user(&oact->sa_mask, &old_ka.sa.sa_mask,
+		               sizeof(sigset_t)) ? -EFAULT : 0;
+		if (err)
 			return -EFAULT;
-		__copy_to_user(&old_ka.sa.sa_mask, &oact->sa_mask,
-		               sizeof(sigset_t));
 	}
 
 	return ret;
 }
 
-asmlinkage int irix_sigpending(irix_sigset_t *set)
+asmlinkage int irix_sigpending(irix_sigset_t __user *set)
 {
 	return do_sigpending(set, sizeof(*set));
 }
 
-asmlinkage int irix_sigprocmask(int how, irix_sigset_t *new, irix_sigset_t *old)
+asmlinkage int irix_sigprocmask(int how, irix_sigset_t __user *new,
+	irix_sigset_t __user *old)
 {
 	sigset_t oldbits, newbits;
 
 	if (new) {
 		if (!access_ok(VERIFY_READ, new, sizeof(*new)))
 			return -EFAULT;
-		__copy_from_user(&newbits, new, sizeof(unsigned long)*4);
+		if (__copy_from_user(&newbits, new, sizeof(unsigned long)*4))
+			return -EFAULT;
 		sigdelsetmask(&newbits, ~_BLOCKABLE);
 
 		spin_lock_irq(&current->sighand->siglock);
@@ -381,20 +405,19 @@
 		recalc_sigpending();
 		spin_unlock_irq(&current->sighand->siglock);
 	}
-	if(old) {
-		if (!access_ok(VERIFY_WRITE, old, sizeof(*old)))
-			return -EFAULT;
-		__copy_to_user(old, &current->blocked, sizeof(unsigned long)*4);
-	}
+	if (old)
+		return copy_to_user(old, &current->blocked,
+		                  sizeof(unsigned long)*4) ? -EFAULT : 0;
 
 	return 0;
 }
 
 asmlinkage int irix_sigsuspend(struct pt_regs *regs)
 {
-	sigset_t *uset, saveset, newset;
+	sigset_t saveset, newset;
+	sigset_t __user *uset;
 
-	uset = (sigset_t *) regs->regs[4];
+	uset = (sigset_t __user *) regs->regs[4];
 	if (copy_from_user(&newset, uset, sizeof(sigset_t)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -440,12 +463,13 @@
 	} stuff;
 };
 
-asmlinkage int irix_sigpoll_sys(unsigned long *set, struct irix5_siginfo *info,
-				struct timespec *tp)
+asmlinkage int irix_sigpoll_sys(unsigned long __user *set,
+	struct irix5_siginfo __user *info, struct timespec __user *tp)
 {
 	long expire = MAX_SCHEDULE_TIMEOUT;
 	sigset_t kset;
 	int i, sig, error, timeo = 0;
+	struct timespec ktp;
 
 #ifdef DEBUG_SIG
 	printk("[%s:%d] irix_sigpoll_sys(%p,%p,%p)\n",
@@ -456,14 +480,8 @@
 	if (!set)
 		return -EINVAL;
 
-	if (!access_ok(VERIFY_READ, set, sizeof(kset))) {
-		error = -EFAULT;
-		goto out;
-	}
-
-	__copy_from_user(&kset, set, sizeof(set));
-	if (error)
-		goto out;
+	if (copy_from_user(&kset, set, sizeof(set)))
+		return -EFAULT;
 
 	if (info && clear_user(info, sizeof(*info))) {
 		error = -EFAULT;
@@ -471,19 +489,21 @@
 	}
 
 	if (tp) {
-		if (!access_ok(VERIFY_READ, tp, sizeof(*tp)))
+		if (copy_from_user(&ktp, tp, sizeof(*tp)))
 			return -EFAULT;
-		if (!tp->tv_sec && !tp->tv_nsec) {
-			error = -EINVAL;
-			goto out;
-		}
-		expire = timespec_to_jiffies(tp) + (tp->tv_sec||tp->tv_nsec);
+
+		if (!ktp.tv_sec && !ktp.tv_nsec)
+			return -EINVAL;
+
+		expire = timespec_to_jiffies(&ktp) +
+		         (ktp.tv_sec || ktp.tv_nsec);
 	}
 
 	while(1) {
 		long tmp = 0;
 
-		expire = schedule_timeout_interruptible(expire);
+		current->state = TASK_INTERRUPTIBLE;
+		expire = schedule_timeout(expire);
 
 		for (i=0; i<=4; i++)
 			tmp |= (current->pending.signal.sig[i] & kset.sig[i]);
@@ -500,15 +520,14 @@
 	if (timeo)
 		return -EAGAIN;
 
-	for(sig = 1; i <= 65 /* IRIX_NSIG */; sig++) {
+	for (sig = 1; i <= 65 /* IRIX_NSIG */; sig++) {
 		if (sigismember (&kset, sig))
 			continue;
 		if (sigismember (&current->pending.signal, sig)) {
 			/* XXX need more than this... */
 			if (info)
-				info->sig = sig;
-			error = 0;
-			goto out;
+				return copy_to_user(&info->sig, &sig, sizeof(sig));
+			return 0;
 		}
 	}
 
@@ -534,8 +553,9 @@
 
 #define W_MASK      (W_EXITED | W_TRAPPED | W_STOPPED | W_CONT | W_NOHANG)
 
-asmlinkage int irix_waitsys(int type, int pid, struct irix5_siginfo *info,
-			    int options, struct rusage *ru)
+asmlinkage int irix_waitsys(int type, int pid,
+	struct irix5_siginfo __user *info, int options,
+	struct rusage __user *ru)
 {
 	int flag, retval;
 	DECLARE_WAITQUEUE(wait, current);
@@ -543,28 +563,22 @@
 	struct task_struct *p;
 	struct list_head *_p;
 
-	if (!info) {
-		retval = -EINVAL;
-		goto out;
-	}
-	if (!access_ok(VERIFY_WRITE, info, sizeof(*info))) {
-		retval = -EFAULT;
-		goto out;
-	}
-	if (ru) {
-		if (!access_ok(VERIFY_WRITE, ru, sizeof(*ru))) {
-			retval = -EFAULT;
-			goto out;
-		}
-	}
-	if (options & ~(W_MASK)) {
-		retval = -EINVAL;
-		goto out;
-	}
-	if (type != IRIX_P_PID && type != IRIX_P_PGID && type != IRIX_P_ALL) {
-		retval = -EINVAL;
-		goto out;
-	}
+	if (!info)
+		return -EINVAL;
+
+	if (!access_ok(VERIFY_WRITE, info, sizeof(*info)))
+		return -EFAULT;
+
+	if (ru)
+		if (!access_ok(VERIFY_WRITE, ru, sizeof(*ru)))
+			return -EFAULT;
+
+	if (options & ~W_MASK)
+		return -EINVAL;
+
+	if (type != IRIX_P_PID && type != IRIX_P_PGID && type != IRIX_P_ALL)
+		return -EINVAL;
+
 	add_wait_queue(&current->signal->wait_chldexit, &wait);
 repeat:
 	flag = 0;
@@ -595,18 +609,20 @@
 			add_parent(p, p->parent);
 			write_unlock_irq(&tasklist_lock);
 			retval = ru ? getrusage(p, RUSAGE_BOTH, ru) : 0;
-			if (!retval && ru) {
-				retval |= __put_user(SIGCHLD, &info->sig);
-				retval |= __put_user(0, &info->code);
-				retval |= __put_user(p->pid, &info->stuff.procinfo.pid);
-				retval |= __put_user((p->exit_code >> 8) & 0xff,
-				           &info->stuff.procinfo.procdata.child.status);
-				retval |= __put_user(p->utime, &info->stuff.procinfo.procdata.child.utime);
-				retval |= __put_user(p->stime, &info->stuff.procinfo.procdata.child.stime);
-			}
-			if (!retval) {
-				p->exit_code = 0;
-			}
+			if (retval)
+				goto end_waitsys;
+
+			retval = __put_user(SIGCHLD, &info->sig);
+			retval |= __put_user(0, &info->code);
+			retval |= __put_user(p->pid, &info->stuff.procinfo.pid);
+			retval |= __put_user((p->exit_code >> 8) & 0xff,
+			           &info->stuff.procinfo.procdata.child.status);
+			retval |= __put_user(p->utime, &info->stuff.procinfo.procdata.child.utime);
+			retval |= __put_user(p->stime, &info->stuff.procinfo.procdata.child.stime);
+			if (retval)
+				goto end_waitsys;
+
+			p->exit_code = 0;
 			goto end_waitsys;
 
 		case EXIT_ZOMBIE:
@@ -614,16 +630,18 @@
 			current->signal->cstime += p->stime + p->signal->cstime;
 			if (ru != NULL)
 				getrusage(p, RUSAGE_BOTH, ru);
-			__put_user(SIGCHLD, &info->sig);
-			__put_user(1, &info->code);      /* CLD_EXITED */
-			__put_user(p->pid, &info->stuff.procinfo.pid);
-			__put_user((p->exit_code >> 8) & 0xff,
+			retval = __put_user(SIGCHLD, &info->sig);
+			retval |= __put_user(1, &info->code);      /* CLD_EXITED */
+			retval |= __put_user(p->pid, &info->stuff.procinfo.pid);
+			retval |= __put_user((p->exit_code >> 8) & 0xff,
 			           &info->stuff.procinfo.procdata.child.status);
-			__put_user(p->utime,
+			retval |= __put_user(p->utime,
 			           &info->stuff.procinfo.procdata.child.utime);
-			__put_user(p->stime,
+			retval |= __put_user(p->stime,
 			           &info->stuff.procinfo.procdata.child.stime);
-			retval = 0;
+			if (retval)
+				return retval;
+
 			if (p->real_parent != p->parent) {
 				write_lock_irq(&tasklist_lock);
 				remove_parent(p);
@@ -656,7 +674,6 @@
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&current->signal->wait_chldexit, &wait);
 
-out:
 	return retval;
 }
 
@@ -675,39 +692,39 @@
 
 asmlinkage int irix_getcontext(struct pt_regs *regs)
 {
-	int i, base = 0;
-	struct irix5_context *ctx;
+	int error, i, base = 0;
+	struct irix5_context __user *ctx;
 	unsigned long flags;
 
 	if (regs->regs[2] == 1000)
 		base = 1;
-	ctx = (struct irix5_context *) regs->regs[base + 4];
+	ctx = (struct irix5_context __user *) regs->regs[base + 4];
 
 #ifdef DEBUG_SIG
 	printk("[%s:%d] irix_getcontext(%p)\n",
 	       current->comm, current->pid, ctx);
 #endif
 
-	if (!access_ok(VERIFY_WRITE, ctx, sizeof(*ctx)))
+	if (!access_ok(VERIFY_WRITE, ctx, sizeof(*ctx)));
 		return -EFAULT;
 
-	__put_user(current->thread.irix_oldctx, &ctx->link);
+	error = __put_user(current->thread.irix_oldctx, &ctx->link);
 
-	__copy_to_user(&ctx->sigmask, &current->blocked, sizeof(irix_sigset_t));
+	error |= __copy_to_user(&ctx->sigmask, &current->blocked, sizeof(irix_sigset_t)) ? -EFAULT : 0;
 
 	/* XXX Do sigstack stuff someday... */
-	__put_user(0, &ctx->stack.sp);
-	__put_user(0, &ctx->stack.size);
-	__put_user(0, &ctx->stack.flags);
+	error |= __put_user(0, &ctx->stack.sp);
+	error |= __put_user(0, &ctx->stack.size);
+	error |= __put_user(0, &ctx->stack.flags);
 
-	__put_user(0, &ctx->weird_graphics_thing);
-	__put_user(0, &ctx->regs[0]);
+	error |= __put_user(0, &ctx->weird_graphics_thing);
+	error |= __put_user(0, &ctx->regs[0]);
 	for (i = 1; i < 32; i++)
-		__put_user(regs->regs[i], &ctx->regs[i]);
-	__put_user(regs->lo, &ctx->regs[32]);
-	__put_user(regs->hi, &ctx->regs[33]);
-	__put_user(regs->cp0_cause, &ctx->regs[34]);
-	__put_user(regs->cp0_epc, &ctx->regs[35]);
+		error |= __put_user(regs->regs[i], &ctx->regs[i]);
+	error |= __put_user(regs->lo, &ctx->regs[32]);
+	error |= __put_user(regs->hi, &ctx->regs[33]);
+	error |= __put_user(regs->cp0_cause, &ctx->regs[34]);
+	error |= __put_user(regs->cp0_epc, &ctx->regs[35]);
 
 	flags = 0x0f;
 	if (!used_math()) {
@@ -716,119 +733,124 @@
 		/* XXX wheee... */
 		printk("Wheee, no code for saving IRIX FPU context yet.\n");
 	}
-	__put_user(flags, &ctx->flags);
+	error |= __put_user(flags, &ctx->flags);
 
-	return 0;
+	return error;
 }
 
-asmlinkage unsigned long irix_setcontext(struct pt_regs *regs)
+asmlinkage void irix_setcontext(struct pt_regs *regs)
 {
-	int error, base = 0;
-	struct irix5_context *ctx;
+	struct irix5_context __user *ctx;
+	int err, base = 0;
+	u32 flags;
 
-	if(regs->regs[2] == 1000)
+	if (regs->regs[2] == 1000)
 		base = 1;
-	ctx = (struct irix5_context *) regs->regs[base + 4];
+	ctx = (struct irix5_context __user *) regs->regs[base + 4];
 
 #ifdef DEBUG_SIG
 	printk("[%s:%d] irix_setcontext(%p)\n",
 	       current->comm, current->pid, ctx);
 #endif
 
-	if (!access_ok(VERIFY_READ, ctx, sizeof(*ctx))) {
-		error = -EFAULT;
-		goto out;
-	}
+	if (!access_ok(VERIFY_READ, ctx, sizeof(*ctx)))
+		goto segv_and_exit;
 
-	if (ctx->flags & 0x02) {
+	err = __get_user(flags, &ctx->flags);
+	if (flags & 0x02) {
 		/* XXX sigstack garbage, todo... */
 		printk("Wheee, cannot do sigstack stuff in setcontext\n");
 	}
 
-	if (ctx->flags & 0x04) {
+	if (flags & 0x04) {
 		int i;
 
 		/* XXX extra control block stuff... todo... */
-		for(i = 1; i < 32; i++)
-			regs->regs[i] = ctx->regs[i];
-		regs->lo = ctx->regs[32];
-		regs->hi = ctx->regs[33];
-		regs->cp0_epc = ctx->regs[35];
+		for (i = 1; i < 32; i++)
+			err |= __get_user(regs->regs[i], &ctx->regs[i]);
+		err |= __get_user(regs->lo, &ctx->regs[32]);
+		err |= __get_user(regs->hi, &ctx->regs[33]);
+		err |= __get_user(regs->cp0_epc, &ctx->regs[35]);
 	}
 
-	if (ctx->flags & 0x08) {
+	if (flags & 0x08)
 		/* XXX fpu context, blah... */
-		printk("Wheee, cannot restore FPU context yet...\n");
-	}
-	current->thread.irix_oldctx = ctx->link;
-	error = regs->regs[2];
+		printk(KERN_ERR "Wheee, cannot restore FPU context yet...\n");
 
-out:
-	return error;
+	err |= __get_user(current->thread.irix_oldctx, &ctx->link);
+	if (err)
+		goto segv_and_exit;
+
+	/*
+	 * Don't let your children do this ...
+	 */
+	if (current_thread_info()->flags & TIF_SYSCALL_TRACE)
+		do_syscall_trace(regs, 1);
+	__asm__ __volatile__(
+		"move\t$29,%0\n\t"
+		"j\tsyscall_exit"
+		:/* no outputs */
+		:"r" (&regs));
+		/* Unreached */
+
+segv_and_exit:
+	force_sigsegv(SIGSEGV, current);
 }
 
-struct irix_sigstack { unsigned long sp; int status; };
+struct irix_sigstack {
+	unsigned long sp;
+	int status;
+};
 
-asmlinkage int irix_sigstack(struct irix_sigstack *new, struct irix_sigstack *old)
+asmlinkage int irix_sigstack(struct irix_sigstack __user *new,
+	struct irix_sigstack __user *old)
 {
-	int error = -EFAULT;
-
 #ifdef DEBUG_SIG
 	printk("[%s:%d] irix_sigstack(%p,%p)\n",
 	       current->comm, current->pid, new, old);
 #endif
-	if(new) {
+	if (new) {
 		if (!access_ok(VERIFY_READ, new, sizeof(*new)))
-			goto out;
+			return -EFAULT;
 	}
 
-	if(old) {
+	if (old) {
 		if (!access_ok(VERIFY_WRITE, old, sizeof(*old)))
-			goto out;
+			return -EFAULT;
 	}
-	error = 0;
 
-out:
-	return error;
+	return 0;
 }
 
 struct irix_sigaltstack { unsigned long sp; int size; int status; };
 
-asmlinkage int irix_sigaltstack(struct irix_sigaltstack *new,
-				struct irix_sigaltstack *old)
+asmlinkage int irix_sigaltstack(struct irix_sigaltstack __user *new,
+				struct irix_sigaltstack __user *old)
 {
-	int error = -EFAULT;
-
 #ifdef DEBUG_SIG
 	printk("[%s:%d] irix_sigaltstack(%p,%p)\n",
 	       current->comm, current->pid, new, old);
 #endif
-	if (new) {
+	if (new)
 		if (!access_ok(VERIFY_READ, new, sizeof(*new)))
-			goto out;
-	}
+			return -EFAULT;
 
 	if (old) {
 		if (!access_ok(VERIFY_WRITE, old, sizeof(*old)))
-			goto out;
+			return -EFAULT;
 	}
-	error = 0;
-
-out:
-	error = 0;
 
-	return error;
+	return 0;
 }
 
 struct irix_procset {
 	int cmd, ltype, lid, rtype, rid;
 };
 
-asmlinkage int irix_sigsendset(struct irix_procset *pset, int sig)
+asmlinkage int irix_sigsendset(struct irix_procset __user *pset, int sig)
 {
 	if (!access_ok(VERIFY_READ, pset, sizeof(*pset)))
 		return -EFAULT;
-
 #ifdef DEBUG_SIG
 	printk("[%s:%d] irix_sigsendset([%d,%d,%d,%d,%d],%d)\n",
 	       current->comm, current->pid,
diff -Naur linux-2.6.14/arch/mips/kernel/irq_cpu.c linux-mips-2.6.14.orig/arch/mips/kernel/irq_cpu.c
--- linux-2.6.14/arch/mips/kernel/irq_cpu.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irq_cpu.c	2005-11-17 11:42:19.000000000 -0800
@@ -3,6 +3,8 @@
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
  *
  * Copyright (C) 2001 Ralf Baechle
+ * Copyright (C) 2005  MIPS Technologies, Inc.  All rights reserved.
+ *      Author: Maciej W. Rozycki <macro@mips.com>
  *
  * This file define the irq handler for MIPS CPU interrupts.
  *
@@ -31,19 +33,21 @@
 
 #include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
 #include <asm/system.h>
 
 static int mips_cpu_irq_base;
 
 static inline void unmask_mips_irq(unsigned int irq)
 {
-	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
 	set_c0_status(0x100 << (irq - mips_cpu_irq_base));
+	irq_enable_hazard();
 }
 
 static inline void mask_mips_irq(unsigned int irq)
 {
 	clear_c0_status(0x100 << (irq - mips_cpu_irq_base));
+	irq_disable_hazard();
 }
 
 static inline void mips_cpu_irq_enable(unsigned int irq)
@@ -52,6 +56,7 @@
 
 	local_irq_save(flags);
 	unmask_mips_irq(irq);
+	back_to_back_c0_hazard();
 	local_irq_restore(flags);
 }
 
@@ -61,6 +66,7 @@
 
 	local_irq_save(flags);
 	mask_mips_irq(irq);
+	back_to_back_c0_hazard();
 	local_irq_restore(flags);
 }
 
@@ -71,7 +77,7 @@
 	return 0;
 }
 
-#define	mips_cpu_irq_shutdown	mips_cpu_irq_disable
+#define	mips_cpu_irq_shutdown		mips_cpu_irq_disable
 
 /*
  * While we ack the interrupt interrupts are disabled and thus we don't need
@@ -79,9 +85,6 @@
  */
 static void mips_cpu_irq_ack(unsigned int irq)
 {
-	/* Only necessary for soft interrupts */
-	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
-
 	mask_mips_irq(irq);
 }
 
@@ -92,22 +95,82 @@
 }
 
 static hw_irq_controller mips_cpu_irq_controller = {
-	"MIPS",
-	mips_cpu_irq_startup,
-	mips_cpu_irq_shutdown,
-	mips_cpu_irq_enable,
-	mips_cpu_irq_disable,
-	mips_cpu_irq_ack,
-	mips_cpu_irq_end,
-	NULL			/* no affinity stuff for UP */
+	.typename	= "MIPS",
+	.startup	= mips_cpu_irq_startup,
+	.shutdown	= mips_cpu_irq_shutdown,
+	.enable		= mips_cpu_irq_enable,
+	.disable	= mips_cpu_irq_disable,
+	.ack		= mips_cpu_irq_ack,
+	.end		= mips_cpu_irq_end,
 };
 
+/*
+ * Basically the same as above but taking care of all the MT stuff
+ */
+
+#define unmask_mips_mt_irq	unmask_mips_irq
+#define mask_mips_mt_irq	mask_mips_irq
+#define mips_mt_cpu_irq_enable	mips_cpu_irq_enable
+#define mips_mt_cpu_irq_disable	mips_cpu_irq_disable
+
+static unsigned int mips_mt_cpu_irq_startup(unsigned int irq)
+{
+	unsigned int vpflags = dvpe();
+
+	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
+	evpe(vpflags);
+	mips_mt_cpu_irq_enable(irq);
+
+	return 0;
+}
+
+#define	mips_mt_cpu_irq_shutdown	mips_mt_cpu_irq_disable
+
+/*
+ * While we ack the interrupt interrupts are disabled and thus we don't need
+ * to deal with concurrency issues.  Same for mips_cpu_irq_end.
+ */
+static void mips_mt_cpu_irq_ack(unsigned int irq)
+{
+	unsigned int vpflags = dvpe();
+	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
+	evpe(vpflags);
+	mask_mips_mt_irq(irq);
+}
+
+#define mips_mt_cpu_irq_end mips_cpu_irq_end
+
+static hw_irq_controller mips_mt_cpu_irq_controller = {
+	.typename	= "MIPS",
+	.startup	= mips_mt_cpu_irq_startup,
+	.shutdown	= mips_mt_cpu_irq_shutdown,
+	.enable		= mips_mt_cpu_irq_enable,
+	.disable	= mips_mt_cpu_irq_disable,
+	.ack		= mips_mt_cpu_irq_ack,
+	.end		= mips_mt_cpu_irq_end,
+};
 
 void __init mips_cpu_irq_init(int irq_base)
 {
 	int i;
 
-	for (i = irq_base; i < irq_base + 8; i++) {
+	/* Mask interrupts. */
+	clear_c0_status(ST0_IM);
+	clear_c0_cause(CAUSEF_IP);
+
+	/*
+	 * Only MT is using the software interrupts currently, so we just
+	 * leave them uninitialized for other processors.
+	 */
+	if (cpu_has_mipsmt)
+		for (i = irq_base; i < irq_base + 2; i++) {
+			irq_desc[i].status = IRQ_DISABLED;
+			irq_desc[i].action = NULL;
+			irq_desc[i].depth = 1;
+			irq_desc[i].handler = &mips_mt_cpu_irq_controller;
+		}
+
+	for (i = irq_base + 2; i < irq_base + 8; i++) {
 		irq_desc[i].status = IRQ_DISABLED;
 		irq_desc[i].action = NULL;
 		irq_desc[i].depth = 1;
diff -Naur linux-2.6.14/arch/mips/kernel/irq-msc01.c linux-mips-2.6.14.orig/arch/mips/kernel/irq-msc01.c
--- linux-2.6.14/arch/mips/kernel/irq-msc01.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irq-msc01.c	2005-11-17 11:42:19.000000000 -0800
@@ -74,7 +74,7 @@
 static void level_mask_and_ack_msc_irq(unsigned int irq)
 {
 	mask_msc_irq(irq);
-	if (!cpu_has_ei)
+	if (!cpu_has_veic)
 		MSCIC_WRITE(MSC01_IC_EOI, 0);
 }
 
@@ -84,7 +84,7 @@
 static void edge_mask_and_ack_msc_irq(unsigned int irq)
 {
 	mask_msc_irq(irq);
-	if (!cpu_has_ei)
+	if (!cpu_has_veic)
 		MSCIC_WRITE(MSC01_IC_EOI, 0);
 	else {
 		u32 r;
@@ -129,25 +129,23 @@
 #define shutdown_msc_irq	disable_msc_irq
 
 struct hw_interrupt_type msc_levelirq_type = {
-	"SOC-it-Level",
-	startup_msc_irq,
-	shutdown_msc_irq,
-	enable_msc_irq,
-	disable_msc_irq,
-	level_mask_and_ack_msc_irq,
-	end_msc_irq,
-	NULL
+	.typename = "SOC-it-Level",
+	.startup = startup_msc_irq,
+	.shutdown = shutdown_msc_irq,
+	.enable = enable_msc_irq,
+	.disable = disable_msc_irq,
+	.ack = level_mask_and_ack_msc_irq,
+	.end = end_msc_irq,
 };
 
 struct hw_interrupt_type msc_edgeirq_type = {
-	"SOC-it-Edge",
-	startup_msc_irq,
-	shutdown_msc_irq,
-	enable_msc_irq,
-	disable_msc_irq,
-	edge_mask_and_ack_msc_irq,
-	end_msc_irq,
-	NULL
+	.typename = "SOC-it-Edge",
+	.startup =startup_msc_irq,
+	.shutdown = shutdown_msc_irq,
+	.enable = enable_msc_irq,
+	.disable = disable_msc_irq,
+	.ack = edge_mask_and_ack_msc_irq,
+	.end = end_msc_irq,
 };
 
 
@@ -168,14 +166,14 @@
 		switch (imp->im_type) {
 		case MSC01_IRQ_EDGE:
 			irq_desc[base+n].handler = &msc_edgeirq_type;
-			if (cpu_has_ei)
+			if (cpu_has_veic)
 				MSCIC_WRITE(MSC01_IC_SUP+n*8, MSC01_IC_SUP_EDGE_BIT);
 			else
 				MSCIC_WRITE(MSC01_IC_SUP+n*8, MSC01_IC_SUP_EDGE_BIT | imp->im_lvl);
 			break;
 		case MSC01_IRQ_LEVEL:
 			irq_desc[base+n].handler = &msc_levelirq_type;
-			if (cpu_has_ei)
+			if (cpu_has_veic)
 				MSCIC_WRITE(MSC01_IC_SUP+n*8, 0);
 			else
 				MSCIC_WRITE(MSC01_IC_SUP+n*8, imp->im_lvl);
diff -Naur linux-2.6.14/arch/mips/kernel/irq-mv6434x.c linux-mips-2.6.14.orig/arch/mips/kernel/irq-mv6434x.c
--- linux-2.6.14/arch/mips/kernel/irq-mv6434x.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irq-mv6434x.c	2005-11-17 11:42:19.000000000 -0800
@@ -135,14 +135,13 @@
 #define shutdown_mv64340_irq	disable_mv64340_irq
 
 struct hw_interrupt_type mv64340_irq_type = {
-	"MV-64340",
-	startup_mv64340_irq,
-	shutdown_mv64340_irq,
-	enable_mv64340_irq,
-	disable_mv64340_irq,
-	mask_and_ack_mv64340_irq,
-	end_mv64340_irq,
-	NULL
+	.typename = "MV-64340",
+	.startup = startup_mv64340_irq,
+	.shutdown = shutdown_mv64340_irq,
+	.enable = enable_mv64340_irq,
+	.disable = disable_mv64340_irq,
+	.ack = mask_and_ack_mv64340_irq,
+	.end = end_mv64340_irq,
 };
 
 void __init mv64340_irq_init(unsigned int base)
diff -Naur linux-2.6.14/arch/mips/kernel/irq-rm7000.c linux-mips-2.6.14.orig/arch/mips/kernel/irq-rm7000.c
--- linux-2.6.14/arch/mips/kernel/irq-rm7000.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irq-rm7000.c	2005-11-17 11:42:19.000000000 -0800
@@ -72,13 +72,13 @@
 }
 
 static hw_irq_controller rm7k_irq_controller = {
-	"RM7000",
-	rm7k_cpu_irq_startup,
-	rm7k_cpu_irq_shutdown,
-	rm7k_cpu_irq_enable,
-	rm7k_cpu_irq_disable,
-	rm7k_cpu_irq_ack,
-	rm7k_cpu_irq_end,
+	.typename = "RM7000",
+	.startup = rm7k_cpu_irq_startup,
+	.shutdown = rm7k_cpu_irq_shutdown,
+	.enable = rm7k_cpu_irq_enable,
+	.disable = rm7k_cpu_irq_disable,
+	.ack = rm7k_cpu_irq_ack,
+	.end = rm7k_cpu_irq_end,
 };
 
 void __init rm7k_cpu_irq_init(int base)
diff -Naur linux-2.6.14/arch/mips/kernel/irq-rm9000.c linux-mips-2.6.14.orig/arch/mips/kernel/irq-rm9000.c
--- linux-2.6.14/arch/mips/kernel/irq-rm9000.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/irq-rm9000.c	2005-11-17 11:42:19.000000000 -0800
@@ -106,23 +106,23 @@
 }
 
 static hw_irq_controller rm9k_irq_controller = {
-	"RM9000",
-	rm9k_cpu_irq_startup,
-	rm9k_cpu_irq_shutdown,
-	rm9k_cpu_irq_enable,
-	rm9k_cpu_irq_disable,
-	rm9k_cpu_irq_ack,
-	rm9k_cpu_irq_end,
+	.typename = "RM9000",
+	.startup = rm9k_cpu_irq_startup,
+	.shutdown = rm9k_cpu_irq_shutdown,
+	.enable = rm9k_cpu_irq_enable,
+	.disable = rm9k_cpu_irq_disable,
+	.ack = rm9k_cpu_irq_ack,
+	.end = rm9k_cpu_irq_end,
 };
 
 static hw_irq_controller rm9k_perfcounter_irq = {
-	"RM9000",
-	rm9k_perfcounter_irq_startup,
-	rm9k_perfcounter_irq_shutdown,
-	rm9k_cpu_irq_enable,
-	rm9k_cpu_irq_disable,
-	rm9k_cpu_irq_ack,
-	rm9k_cpu_irq_end,
+	.typename = "RM9000",
+	.startup = rm9k_perfcounter_irq_startup,
+	.shutdown = rm9k_perfcounter_irq_shutdown,
+	.enable = rm9k_cpu_irq_enable,
+	.disable = rm9k_cpu_irq_disable,
+	.ack = rm9k_cpu_irq_ack,
+	.end = rm9k_cpu_irq_end,
 };
 
 unsigned int rm9000_perfcount_irq;
diff -Naur linux-2.6.14/arch/mips/kernel/linux32.c linux-mips-2.6.14.orig/arch/mips/kernel/linux32.c
--- linux-2.6.14/arch/mips/kernel/linux32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/linux32.c	2005-11-17 11:42:19.000000000 -0800
@@ -215,81 +215,32 @@
 	return(n);
 }
 
-struct rusage32 {
-        struct compat_timeval ru_utime;
-        struct compat_timeval ru_stime;
-        int    ru_maxrss;
-        int    ru_ixrss;
-        int    ru_idrss;
-        int    ru_isrss;
-        int    ru_minflt;
-        int    ru_majflt;
-        int    ru_nswap;
-        int    ru_inblock;
-        int    ru_oublock;
-        int    ru_msgsnd;
-        int    ru_msgrcv;
-        int    ru_nsignals;
-        int    ru_nvcsw;
-        int    ru_nivcsw;
-};
-
-static int
-put_rusage (struct rusage32 *ru, struct rusage *r)
+asmlinkage int
+sys32_waitpid(compat_pid_t pid, unsigned int *stat_addr, int options)
 {
-	int err;
-
-	if (!access_ok(VERIFY_WRITE, ru, sizeof *ru))
-		return -EFAULT;
-
-	err = __put_user (r->ru_utime.tv_sec, &ru->ru_utime.tv_sec);
-	err |= __put_user (r->ru_utime.tv_usec, &ru->ru_utime.tv_usec);
-	err |= __put_user (r->ru_stime.tv_sec, &ru->ru_stime.tv_sec);
-	err |= __put_user (r->ru_stime.tv_usec, &ru->ru_stime.tv_usec);
-	err |= __put_user (r->ru_maxrss, &ru->ru_maxrss);
-	err |= __put_user (r->ru_ixrss, &ru->ru_ixrss);
-	err |= __put_user (r->ru_idrss, &ru->ru_idrss);
-	err |= __put_user (r->ru_isrss, &ru->ru_isrss);
-	err |= __put_user (r->ru_minflt, &ru->ru_minflt);
-	err |= __put_user (r->ru_majflt, &ru->ru_majflt);
-	err |= __put_user (r->ru_nswap, &ru->ru_nswap);
-	err |= __put_user (r->ru_inblock, &ru->ru_inblock);
-	err |= __put_user (r->ru_oublock, &ru->ru_oublock);
-	err |= __put_user (r->ru_msgsnd, &ru->ru_msgsnd);
-	err |= __put_user (r->ru_msgrcv, &ru->ru_msgrcv);
-	err |= __put_user (r->ru_nsignals, &ru->ru_nsignals);
-	err |= __put_user (r->ru_nvcsw, &ru->ru_nvcsw);
-	err |= __put_user (r->ru_nivcsw, &ru->ru_nivcsw);
-
-	return err;
+	return compat_sys_wait4(pid, stat_addr, options, NULL);
 }
 
-asmlinkage int
-sys32_wait4(compat_pid_t pid, unsigned int * stat_addr, int options,
-	    struct rusage32 * ru)
+asmlinkage long
+sysn32_waitid(int which, compat_pid_t pid,
+	      siginfo_t __user *uinfo, int options,
+	      struct compat_rusage __user *uru)
 {
-	if (!ru)
-		return sys_wait4(pid, stat_addr, options, NULL);
-	else {
-		struct rusage r;
-		int ret;
-		unsigned int status;
-		mm_segment_t old_fs = get_fs();
+	struct rusage ru;
+	long ret;
+	mm_segment_t old_fs = get_fs();
 
-		set_fs(KERNEL_DS);
-		ret = sys_wait4(pid, stat_addr ? &status : NULL, options, &r);
-		set_fs(old_fs);
-		if (put_rusage (ru, &r)) return -EFAULT;
-		if (stat_addr && put_user (status, stat_addr))
-			return -EFAULT;
+	set_fs (KERNEL_DS);
+	ret = sys_waitid(which, pid, uinfo, options,
+			 uru ? (struct rusage __user *) &ru : NULL);
+	set_fs (old_fs);
+
+	if (ret < 0 || uinfo->si_signo == 0)
 		return ret;
-	}
-}
 
-asmlinkage int
-sys32_waitpid(compat_pid_t pid, unsigned int *stat_addr, int options)
-{
-	return sys32_wait4(pid, stat_addr, options, NULL);
+	if (uru)
+		ret = put_compat_rusage(&ru, uru);
+	return ret;
 }
 
 struct sysinfo32 {
@@ -1467,3 +1418,80 @@
 	}
 	return err;
 }
+
+struct sigevent32 {
+	u32 sigev_value;
+	u32 sigev_signo;
+	u32 sigev_notify;
+	u32 payload[(64 / 4) - 3];
+};
+
+extern asmlinkage long
+sys_timer_create(clockid_t which_clock,
+		 struct sigevent __user *timer_event_spec,
+		 timer_t __user * created_timer_id);
+
+long
+sys32_timer_create(u32 clock, struct sigevent32 __user *se32, timer_t __user *timer_id)
+{
+	struct sigevent __user *p = NULL;
+	if (se32) {
+		struct sigevent se;
+		p = compat_alloc_user_space(sizeof(struct sigevent));
+		memset(&se, 0, sizeof(struct sigevent));
+		if (get_user(se.sigev_value.sival_int,  &se32->sigev_value) ||
+		    __get_user(se.sigev_signo, &se32->sigev_signo) ||
+		    __get_user(se.sigev_notify, &se32->sigev_notify) ||
+		    __copy_from_user(&se._sigev_un._pad, &se32->payload,
+				     sizeof(se32->payload)) ||
+		    copy_to_user(p, &se, sizeof(se)))
+			return -EFAULT;
+	}
+	return sys_timer_create(clock, p, timer_id);
+}
+
+asmlinkage long
+sysn32_rt_sigtimedwait(const sigset_t __user *uthese,
+		       siginfo_t __user *uinfo,
+		       const struct compat_timespec __user *uts32,
+		       size_t sigsetsize)
+{
+	struct timespec __user *uts = NULL;
+
+	if (uts32) {
+		struct timespec ts;
+		uts = compat_alloc_user_space(sizeof(struct timespec));
+		if (get_user(ts.tv_sec, &uts32->tv_sec) ||
+		    get_user(ts.tv_nsec, &uts32->tv_nsec) ||
+		    copy_to_user (uts, &ts, sizeof (ts)))
+			return -EFAULT;
+	}
+	return sys_rt_sigtimedwait(uthese, uinfo, uts, sigsetsize);
+}
+
+save_static_function(sys32_clone);
+__attribute_used__ noinline static int
+_sys32_clone(nabi_no_regargs struct pt_regs regs)
+{
+	unsigned long clone_flags;
+	unsigned long newsp;
+	int __user *parent_tidptr, *child_tidptr;
+
+	clone_flags = regs.regs[4];
+	newsp = regs.regs[5];
+	if (!newsp)
+		newsp = regs.regs[29];
+	parent_tidptr = (int *) regs.regs[6];
+
+	/* Use __dummy4 instead of getting it off the stack, so that
+	   syscall() works.  */
+	child_tidptr = (int __user *) __dummy4;
+	return do_fork(clone_flags, newsp, &regs, 0,
+	               parent_tidptr, child_tidptr);
+}
+
+extern asmlinkage void sys_set_thread_area(u32 addr);
+asmlinkage void sys32_set_thread_area(u32 addr)
+{
+	sys_set_thread_area(AA(addr));
+}
diff -Naur linux-2.6.14/arch/mips/kernel/Makefile linux-mips-2.6.14.orig/arch/mips/kernel/Makefile
--- linux-2.6.14/arch/mips/kernel/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/Makefile	2005-11-17 11:42:19.000000000 -0800
@@ -11,11 +11,7 @@
 binfmt_irix-objs	:= irixelf.o irixinv.o irixioctl.o irixsig.o	\
 			   irix5sys.o sysirix.o
 
-ifdef CONFIG_MODULES
-obj-y				+= mips_ksyms.o module.o
-obj-$(CONFIG_32BIT)		+= module-elf32.o
-obj-$(CONFIG_64BIT)		+= module-elf64.o
-endif
+obj-$(CONFIG_MODULES)		+= mips_ksyms.o module.o
 
 obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_TX39XX)	+= r2300_fpu.o r2300_switch.o
@@ -38,12 +34,18 @@
 
 obj-$(CONFIG_SMP)		+= smp.o
 
+obj-$(CONFIG_MIPS_MT_SMP)	+= smp_mt.o
+
+obj-$(CONFIG_MIPS_VPE_LOADER)	+= vpe.o
+obj-$(CONFIG_MIPS_VPE_APSP_API)	+= rtlx.o
+
 obj-$(CONFIG_NO_ISA)		+= dma-no-isa.o
 obj-$(CONFIG_I8259)		+= i8259.o
 obj-$(CONFIG_IRQ_CPU)		+= irq_cpu.o
 obj-$(CONFIG_IRQ_CPU_RM7K)	+= irq-rm7000.o
 obj-$(CONFIG_IRQ_CPU_RM9K)	+= irq-rm9000.o
 obj-$(CONFIG_IRQ_MV64340)	+= irq-mv6434x.o
+obj-$(CONFIG_MIPS_BOARDS_GEN)	+= irq-msc01.o
 
 obj-$(CONFIG_32BIT)		+= scall32-o32.o
 obj-$(CONFIG_64BIT)		+= scall64-64.o
@@ -57,8 +59,6 @@
 
 obj-$(CONFIG_64BIT)		+= cpu-bugs64.o
 
-obj-$(CONFIG_GEN_RTC)		+= genrtc.o
-
 CFLAGS_cpu-bugs64.o	= $(shell if $(CC) $(CFLAGS) -Wa,-mdaddi -c -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-DHAVE_AS_SET_DADDI"; fi)
 CFLAGS_ioctl32.o	+= -Ifs/
 
diff -Naur linux-2.6.14/arch/mips/kernel/module.c linux-mips-2.6.14.orig/arch/mips/kernel/module.c
--- linux-2.6.14/arch/mips/kernel/module.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/module.c	2005-11-17 11:42:19.000000000 -0800
@@ -1,9 +1,345 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Copyright (C) 2001 Rusty Russell.
+ *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2005 Thiemo Seufer
+ */
+
+#undef DEBUG
+
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 
+struct mips_hi16 {
+	struct mips_hi16 *next;
+	Elf_Addr *addr;
+	Elf_Addr value;
+};
+
+static struct mips_hi16 *mips_hi16_list;
+
 static LIST_HEAD(dbe_list);
 static DEFINE_SPINLOCK(dbe_lock);
 
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+           table entries. */
+}
+
+int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
+			      char *secstrings, struct module *mod)
+{
+	return 0;
+}
+
+static int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
+{
+	return 0;
+}
+
+static int apply_r_mips_32_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location += v;
+
+	return 0;
+}
+
+static int apply_r_mips_32_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = v;
+
+	return 0;
+}
+
+static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
+		return -ENOEXEC;
+	}
+
+	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+		printk(KERN_ERR
+		       "module %s: relocation overflow\n",
+		       me->name);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & ~0x03ffffff) |
+	            ((*location + (v >> 2)) & 0x03ffffff);
+
+	return 0;
+}
+
+static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
+		return -ENOEXEC;
+	}
+
+	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+		printk(KERN_ERR
+		       "module %s: relocation overflow\n",
+		       me->name);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
+
+	return 0;
+}
+
+static int apply_r_mips_hi16_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	struct mips_hi16 *n;
+
+	/*
+	 * We cannot relocate this one now because we don't know the value of
+	 * the carry we need to add.  Save the information, and let LO16 do the
+	 * actual relocation.
+	 */
+	n = kmalloc(sizeof *n, GFP_KERNEL);
+	if (!n)
+		return -ENOMEM;
+
+	n->addr = (Elf_Addr *)location;
+	n->value = v;
+	n->next = mips_hi16_list;
+	mips_hi16_list = n;
+
+	return 0;
+}
+
+static int apply_r_mips_hi16_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x8000LL) >> 16) & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_lo16_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	unsigned long insnlo = *location;
+	Elf_Addr val, vallo;
+
+	/* Sign extend the addend we extract from the lo insn.  */
+	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
+
+	if (mips_hi16_list != NULL) {
+		struct mips_hi16 *l;
+
+		l = mips_hi16_list;
+		while (l != NULL) {
+			struct mips_hi16 *next;
+			unsigned long insn;
+
+			/*
+			 * The value for the HI16 had best be the same.
+			 */
+			if (v != l->value)
+				goto out_danger;
+
+			/*
+			 * Do the HI16 relocation.  Note that we actually don't
+			 * need to know anything about the LO16 itself, except
+			 * where to find the low 16 bits of the addend needed
+			 * by the LO16.
+			 */
+			insn = *l->addr;
+			val = ((insn & 0xffff) << 16) + vallo;
+			val += v;
+
+			/*
+			 * Account for the sign extension that will happen in
+			 * the low bits.
+			 */
+			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
+
+			insn = (insn & ~0xffff) | val;
+			*l->addr = insn;
+
+			next = l->next;
+			kfree(l);
+			l = next;
+		}
+
+		mips_hi16_list = NULL;
+	}
+
+	/*
+	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
+	 */
+	val = v + vallo;
+	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
+	*location = insnlo;
+
+	return 0;
+
+out_danger:
+	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
+
+	return -ENOEXEC;
+}
+
+static int apply_r_mips_lo16_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) | (v & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_64_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*(Elf_Addr *)location = v;
+
+	return 0;
+}
+
+static int apply_r_mips_higher_rela(struct module *me, u32 *location,
+				    Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x80008000LL) >> 32) & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_highest_rela(struct module *me, u32 *location,
+				     Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x800080008000LL) >> 48) & 0xffff);
+
+	return 0;
+}
+
+static int (*reloc_handlers_rel[]) (struct module *me, u32 *location,
+				Elf_Addr v) = {
+	[R_MIPS_NONE]		= apply_r_mips_none,
+	[R_MIPS_32]		= apply_r_mips_32_rel,
+	[R_MIPS_26]		= apply_r_mips_26_rel,
+	[R_MIPS_HI16]		= apply_r_mips_hi16_rel,
+	[R_MIPS_LO16]		= apply_r_mips_lo16_rel
+};
+
+static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,
+				Elf_Addr v) = {
+	[R_MIPS_NONE]		= apply_r_mips_none,
+	[R_MIPS_32]		= apply_r_mips_32_rela,
+	[R_MIPS_26]		= apply_r_mips_26_rela,
+	[R_MIPS_HI16]		= apply_r_mips_hi16_rela,
+	[R_MIPS_LO16]		= apply_r_mips_lo16_rela,
+	[R_MIPS_64]		= apply_r_mips_64_rela,
+	[R_MIPS_HIGHER]		= apply_r_mips_higher_rela,
+	[R_MIPS_HIGHEST]	= apply_r_mips_highest_rela
+};
+
+int apply_relocate(Elf_Shdr *sechdrs, const char *strtab,
+		   unsigned int symindex, unsigned int relsec,
+		   struct module *me)
+{
+	Elf_Mips_Rel *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf_Sym *sym;
+	u32 *location;
+	unsigned int i;
+	Elf_Addr v;
+	int res;
+
+	pr_debug("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_MIPS_R_SYM(rel[i]);
+		if (!sym->st_value) {
+			printk(KERN_WARNING "%s: Unknown symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			return -ENOENT;
+		}
+
+		v = sym->st_value;
+
+		res = reloc_handlers_rel[ELF_MIPS_R_TYPE(rel[i])](me, location, v);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
+int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
+		       unsigned int symindex, unsigned int relsec,
+		       struct module *me)
+{
+	Elf_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf_Sym *sym;
+	u32 *location;
+	unsigned int i;
+	Elf_Addr v;
+	int res;
+
+	pr_debug("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_MIPS_R_SYM(rel[i]);
+		if (!sym->st_value) {
+			printk(KERN_WARNING "%s: Unknown symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			return -ENOENT;
+		}
+
+		v = sym->st_value + rel[i].r_addend;
+
+		res = reloc_handlers_rela[ELF_MIPS_R_TYPE(rel[i])](me, location, v);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
 /* Given an address, look for it in the module exception tables. */
 const struct exception_table_entry *search_module_dbetables(unsigned long addr)
 {
diff -Naur linux-2.6.14/arch/mips/kernel/module-elf32.c linux-mips-2.6.14.orig/arch/mips/kernel/module-elf32.c
--- linux-2.6.14/arch/mips/kernel/module-elf32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/module-elf32.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,250 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *  Copyright (C) 2001 Rusty Russell.
- *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-
-#undef DEBUG
-
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-struct mips_hi16 {
-	struct mips_hi16 *next;
-	Elf32_Addr *addr;
-	Elf32_Addr value;
-};
-
-static struct mips_hi16 *mips_hi16_list;
-
-void *module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-
-/* Free memory returned from module_alloc */
-void module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-	/* FIXME: If module_region == mod->init_region, trim exception
-           table entries. */
-}
-
-int module_frob_arch_sections(Elf_Ehdr *hdr,
-			      Elf_Shdr *sechdrs,
-			      char *secstrings,
-			      struct module *mod)
-{
-	return 0;
-}
-
-static int apply_r_mips_none(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	return 0;
-}
-
-static int apply_r_mips_32(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	*location += v;
-
-	return 0;
-}
-
-static int apply_r_mips_26(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
-
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
-
-	*location = (*location & ~0x03ffffff) |
-	            ((*location + (v >> 2)) & 0x03ffffff);
-
-	return 0;
-}
-
-static int apply_r_mips_hi16(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	struct mips_hi16 *n;
-
-	/*
-	 * We cannot relocate this one now because we don't know the value of
-	 * the carry we need to add.  Save the information, and let LO16 do the
-	 * actual relocation.
-	 */
-	n = kmalloc(sizeof *n, GFP_KERNEL);
-	if (!n)
-		return -ENOMEM;
-
-	n->addr = location;
-	n->value = v;
-	n->next = mips_hi16_list;
-	mips_hi16_list = n;
-
-	return 0;
-}
-
-static int apply_r_mips_lo16(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	unsigned long insnlo = *location;
-	Elf32_Addr val, vallo;
-
-	/* Sign extend the addend we extract from the lo insn.  */
-	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
-
-	if (mips_hi16_list != NULL) {
-		struct mips_hi16 *l;
-
-		l = mips_hi16_list;
-		while (l != NULL) {
-			struct mips_hi16 *next;
-			unsigned long insn;
-
-			/*
-			 * The value for the HI16 had best be the same.
-			 */
-			if (v != l->value)
-				goto out_danger;
-
-			/*
-			 * Do the HI16 relocation.  Note that we actually don't
-			 * need to know anything about the LO16 itself, except
-			 * where to find the low 16 bits of the addend needed
-			 * by the LO16.
-			 */
-			insn = *l->addr;
-			val = ((insn & 0xffff) << 16) + vallo;
-			val += v;
-
-			/*
-			 * Account for the sign extension that will happen in
-			 * the low bits.
-			 */
-			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
-
-			insn = (insn & ~0xffff) | val;
-			*l->addr = insn;
-
-			next = l->next;
-			kfree(l);
-			l = next;
-		}
-
-		mips_hi16_list = NULL;
-	}
-
-	/*
-	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
-	 */
-	val = v + vallo;
-	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
-	*location = insnlo;
-
-	return 0;
-
-out_danger:
-	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
-
-	return -ENOEXEC;
-}
-
-static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
-	Elf32_Addr v) = {
-	[R_MIPS_NONE]	= apply_r_mips_none,
-	[R_MIPS_32]	= apply_r_mips_32,
-	[R_MIPS_26]	= apply_r_mips_26,
-	[R_MIPS_HI16]	= apply_r_mips_hi16,
-	[R_MIPS_LO16]	= apply_r_mips_lo16
-};
-
-int apply_relocate(Elf32_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	Elf32_Rel *rel = (void *) sechdrs[relsec].sh_addr;
-	Elf32_Sym *sym;
-	uint32_t *location;
-	unsigned int i;
-	Elf32_Addr v;
-	int res;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-	       sechdrs[relsec].sh_info);
-
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		Elf32_Word r_info = rel[i].r_info;
-
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to */
-		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
-			+ ELF32_R_SYM(r_info);
-		if (!sym->st_value) {
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       me->name, strtab + sym->st_name);
-			return -ENOENT;
-		}
-
-		v = sym->st_value;
-
-		res = reloc_handlers[ELF32_R_TYPE(r_info)](me, location, v);
-		if (res)
-			return res;
-	}
-
-	return 0;
-}
-
-int apply_relocate_add(Elf32_Shdr *sechdrs,
-		       const char *strtab,
-		       unsigned int symindex,
-		       unsigned int relsec,
-		       struct module *me)
-{
-	/*
-	 * Current binutils always generate .rela relocations.  Keep smiling
-	 * if it's empty, abort otherwise.
-	 */
-	if (!sechdrs[relsec].sh_size)
-		return 0;
-
-	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
-	       me->name);
-	return -ENOEXEC;
-}
diff -Naur linux-2.6.14/arch/mips/kernel/module-elf64.c linux-mips-2.6.14.orig/arch/mips/kernel/module-elf64.c
--- linux-2.6.14/arch/mips/kernel/module-elf64.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/module-elf64.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,274 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *  Copyright (C) 2001 Rusty Russell.
- *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-
-#undef DEBUG
-
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-struct mips_hi16 {
-	struct mips_hi16 *next;
-	Elf32_Addr *addr;
-	Elf64_Addr value;
-};
-
-static struct mips_hi16 *mips_hi16_list;
-
-void *module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-
-/* Free memory returned from module_alloc */
-void module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-	/* FIXME: If module_region == mod->init_region, trim exception
-           table entries. */
-}
-
-int module_frob_arch_sections(Elf_Ehdr *hdr,
-			      Elf_Shdr *sechdrs,
-			      char *secstrings,
-			      struct module *mod)
-{
-	return 0;
-}
-
-int apply_relocate(Elf64_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	/*
-	 * We don't want to deal with REL relocations - RELA is so much saner.
-	 */
-	if (!sechdrs[relsec].sh_size)
-		return 0;
-
-	printk(KERN_ERR "module %s: REL relocation unsupported\n",
-	       me->name);
-	return -ENOEXEC;
-}
-
-static int apply_r_mips_none(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	return 0;
-}
-
-static int apply_r_mips_32(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = v;
-
-	return 0;
-}
-
-static int apply_r_mips_26(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
-
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
-
-	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
-
-	return 0;
-}
-
-static int apply_r_mips_hi16(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	struct mips_hi16 *n;
-
-	/*
-	 * We cannot relocate this one now because we don't know the value of
-	 * the carry we need to add.  Save the information, and let LO16 do the
-	 * actual relocation.
-	 */
-	n = kmalloc(sizeof *n, GFP_KERNEL);
-	if (!n)
-		return -ENOMEM;
-
-	n->addr = location;
-	n->value = v;
-	n->next = mips_hi16_list;
-	mips_hi16_list = n;
-
-	return 0;
-}
-
-static int apply_r_mips_lo16(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	unsigned long insnlo = *location;
-	Elf32_Addr val, vallo;
-
-	/* Sign extend the addend we extract from the lo insn.  */
-	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
-
-	if (mips_hi16_list != NULL) {
-		struct mips_hi16 *l;
-
-		l = mips_hi16_list;
-		while (l != NULL) {
-			struct mips_hi16 *next;
-			unsigned long insn;
-
-			/*
-			 * The value for the HI16 had best be the same.
-			 */
-			if (v != l->value)
-				goto out_danger;
-
-			/*
-			 * Do the HI16 relocation.  Note that we actually don't
-			 * need to know anything about the LO16 itself, except
-			 * where to find the low 16 bits of the addend needed
-			 * by the LO16.
-			 */
-			insn = *l->addr;
-			val = ((insn & 0xffff) << 16) + vallo;
-			val += v;
-
-			/*
-			 * Account for the sign extension that will happen in
-			 * the low bits.
-			 */
-			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
-
-			insn = (insn & ~0xffff) | val;
-			*l->addr = insn;
-
-			next = l->next;
-			kfree(l);
-			l = next;
-		}
-
-		mips_hi16_list = NULL;
-	}
-
-	/*
-	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
-	 */
-	insnlo = (insnlo & ~0xffff) | (v & 0xffff);
-	*location = insnlo;
-
-	return 0;
-
-out_danger:
-	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
-
-	return -ENOEXEC;
-}
-
-static int apply_r_mips_64(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*(uint64_t *) location = v;
-
-	return 0;
-}
-
-
-static int apply_r_mips_higher(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = (*location & 0xffff0000) |
-	            ((((long long) v + 0x80008000LL) >> 32) & 0xffff);
-
-	return 0;
-}
-
-static int apply_r_mips_highest(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = (*location & 0xffff0000) |
-	            ((((long long) v + 0x800080008000LL) >> 48) & 0xffff);
-
-	return 0;
-}
-
-static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
-	Elf64_Addr v) = {
-	[R_MIPS_NONE]		= apply_r_mips_none,
-	[R_MIPS_32]		= apply_r_mips_32,
-	[R_MIPS_26]		= apply_r_mips_26,
-	[R_MIPS_HI16]		= apply_r_mips_hi16,
-	[R_MIPS_LO16]		= apply_r_mips_lo16,
-	[R_MIPS_64]		= apply_r_mips_64,
-	[R_MIPS_HIGHER]		= apply_r_mips_higher,
-	[R_MIPS_HIGHEST]	= apply_r_mips_highest
-};
-
-int apply_relocate_add(Elf64_Shdr *sechdrs,
-		       const char *strtab,
-		       unsigned int symindex,
-		       unsigned int relsec,
-		       struct module *me)
-{
-	Elf64_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
-	Elf64_Sym *sym;
-	uint32_t *location;
-	unsigned int i;
-	Elf64_Addr v;
-	int res;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-	       sechdrs[relsec].sh_info);
-
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to */
-		sym = (Elf64_Sym *)sechdrs[symindex].sh_addr + rel[i].r_sym;
-		if (!sym->st_value) {
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       me->name, strtab + sym->st_name);
-			return -ENOENT;
-		}
-
-		v = sym->st_value;
-
-		res = reloc_handlers[rel[i].r_type](me, location, v);
-		if (res)
-			return res;
-	}
-
-	return 0;
-}
diff -Naur linux-2.6.14/arch/mips/kernel/proc.c linux-mips-2.6.14.orig/arch/mips/kernel/proc.c
--- linux-2.6.14/arch/mips/kernel/proc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/proc.c	2005-11-17 11:42:19.000000000 -0800
@@ -2,7 +2,8 @@
  *  linux/arch/mips/kernel/proc.c
  *
  *  Copyright (C) 1995, 1996, 2001  Ralf Baechle
- *  Copyright (C) 2001  MIPS Technologies, Inc.
+ *  Copyright (C) 2001, 2004  MIPS Technologies, Inc.
+ *  Copyright (C) 2004  Maciej W. Rozycki
  */
 #include <linux/config.h>
 #include <linux/delay.h>
@@ -19,63 +20,69 @@
 unsigned int vced_count, vcei_count;
 
 static const char *cpu_name[] = {
-	[CPU_UNKNOWN]	"unknown",
-	[CPU_R2000]	"R2000",
-	[CPU_R3000]	"R3000",
-	[CPU_R3000A]	"R3000A",
-	[CPU_R3041]	"R3041",
-	[CPU_R3051]	"R3051",
-	[CPU_R3052]	"R3052",
-	[CPU_R3081]	"R3081",
-	[CPU_R3081E]	"R3081E",
-	[CPU_R4000PC]	"R4000PC",
-	[CPU_R4000SC]	"R4000SC",
-	[CPU_R4000MC]	"R4000MC",
-        [CPU_R4200]	"R4200",
-	[CPU_R4400PC]	"R4400PC",
-	[CPU_R4400SC]	"R4400SC",
-	[CPU_R4400MC]	"R4400MC",
-	[CPU_R4600]	"R4600",
-	[CPU_R6000]	"R6000",
-        [CPU_R6000A]	"R6000A",
-	[CPU_R8000]	"R8000",
-	[CPU_R10000]	"R10000",
-	[CPU_R12000]	"R12000",
-	[CPU_R4300]	"R4300",
-	[CPU_R4650]	"R4650",
-	[CPU_R4700]	"R4700",
-	[CPU_R5000]	"R5000",
-        [CPU_R5000A]	"R5000A",
-	[CPU_R4640]	"R4640",
-	[CPU_NEVADA]	"Nevada",
-	[CPU_RM7000]	"RM7000",
-	[CPU_RM9000]	"RM9000",
-	[CPU_R5432]	"R5432",
-	[CPU_4KC]	"MIPS 4Kc",
-        [CPU_5KC]	"MIPS 5Kc",
-	[CPU_R4310]	"R4310",
-	[CPU_SB1]	"SiByte SB1",
-	[CPU_TX3912]	"TX3912",
-	[CPU_TX3922]	"TX3922",
-	[CPU_TX3927]	"TX3927",
-	[CPU_AU1000]	"Au1000",
-	[CPU_AU1500]	"Au1500",
-	[CPU_4KEC]	"MIPS 4KEc",
-	[CPU_4KSC]	"MIPS 4KSc",
-	[CPU_VR41XX]	"NEC Vr41xx",
-	[CPU_R5500]	"R5500",
-	[CPU_TX49XX]	"TX49xx",
-	[CPU_20KC]	"MIPS 20Kc",
-	[CPU_24K]	"MIPS 24K",
-	[CPU_25KF]	"MIPS 25Kf",
-	[CPU_VR4111]	"NEC VR4111",
-	[CPU_VR4121]	"NEC VR4121",
-	[CPU_VR4122]	"NEC VR4122",
-	[CPU_VR4131]	"NEC VR4131",
-	[CPU_VR4133]	"NEC VR4133",
-	[CPU_VR4181]	"NEC VR4181",
-	[CPU_VR4181A]	"NEC VR4181A",
-	[CPU_SR71000]	"Sandcraft SR71000"
+	[CPU_UNKNOWN]	= "unknown",
+	[CPU_R2000]	= "R2000",
+	[CPU_R3000]	= "R3000",
+	[CPU_R3000A]	= "R3000A",
+	[CPU_R3041]	= "R3041",
+	[CPU_R3051]	= "R3051",
+	[CPU_R3052]	= "R3052",
+	[CPU_R3081]	= "R3081",
+	[CPU_R3081E]	= "R3081E",
+	[CPU_R4000PC]	= "R4000PC",
+	[CPU_R4000SC]	= "R4000SC",
+	[CPU_R4000MC]	= "R4000MC",
+        [CPU_R4200]	= "R4200",
+	[CPU_R4400PC]	= "R4400PC",
+	[CPU_R4400SC]	= "R4400SC",
+	[CPU_R4400MC]	= "R4400MC",
+	[CPU_R4600]	= "R4600",
+	[CPU_R6000]	= "R6000",
+        [CPU_R6000A]	= "R6000A",
+	[CPU_R8000]	= "R8000",
+	[CPU_R10000]	= "R10000",
+	[CPU_R12000]	= "R12000",
+	[CPU_R4300]	= "R4300",
+	[CPU_R4650]	= "R4650",
+	[CPU_R4700]	= "R4700",
+	[CPU_R5000]	= "R5000",
+        [CPU_R5000A]	= "R5000A",
+	[CPU_R4640]	= "R4640",
+	[CPU_NEVADA]	= "Nevada",
+	[CPU_RM7000]	= "RM7000",
+	[CPU_RM9000]	= "RM9000",
+	[CPU_R5432]	= "R5432",
+	[CPU_4KC]	= "MIPS 4Kc",
+        [CPU_5KC]	= "MIPS 5Kc",
+	[CPU_R4310]	= "R4310",
+	[CPU_SB1]	= "SiByte SB1",
+	[CPU_SB1A]	= "SiByte SB1A",
+	[CPU_TX3912]	= "TX3912",
+	[CPU_TX3922]	= "TX3922",
+	[CPU_TX3927]	= "TX3927",
+	[CPU_AU1000]	= "Au1000",
+	[CPU_AU1500]	= "Au1500",
+	[CPU_AU1100]	= "Au1100",
+	[CPU_AU1550]	= "Au1550",
+	[CPU_AU1200]	= "Au1200",
+	[CPU_4KEC]	= "MIPS 4KEc",
+	[CPU_4KSC]	= "MIPS 4KSc",
+	[CPU_VR41XX]	= "NEC Vr41xx",
+	[CPU_R5500]	= "R5500",
+	[CPU_TX49XX]	= "TX49xx",
+	[CPU_20KC]	= "MIPS 20Kc",
+	[CPU_24K]	= "MIPS 24K",
+	[CPU_25KF]	= "MIPS 25Kf",
+	[CPU_34K]	= "MIPS 34K",
+	[CPU_VR4111]	= "NEC VR4111",
+	[CPU_VR4121]	= "NEC VR4121",
+	[CPU_VR4122]	= "NEC VR4122",
+	[CPU_VR4131]	= "NEC VR4131",
+	[CPU_VR4133]	= "NEC VR4133",
+	[CPU_VR4181]	= "NEC VR4181",
+	[CPU_VR4181A]	= "NEC VR4181A",
+	[CPU_SR71000]	= "Sandcraft SR71000",
+	[CPU_PR4450]	= "Philips PR4450",
 };
 
 
@@ -105,8 +112,8 @@
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
-	              loops_per_jiffy / (500000/HZ),
-	              (loops_per_jiffy / (5000/HZ)) % 100);
+	              cpu_data[n].udelay_val / (500000/HZ),
+	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
@@ -115,6 +122,14 @@
 	              cpu_has_divec ? "yes" : "no");
 	seq_printf(m, "hardware watchpoint\t: %s\n",
 	              cpu_has_watch ? "yes" : "no");
+	seq_printf(m, "ASEs implemented\t:%s%s%s%s%s%s\n",
+		      cpu_has_mips16 ? " mips16" : "",
+		      cpu_has_mdmx ? " mdmx" : "",
+		      cpu_has_mips3d ? " mips3d" : "",
+		      cpu_has_smartmips ? " smartmips" : "",
+		      cpu_has_dsp ? " dsp" : "",
+		      cpu_has_mipsmt ? " mt" : ""
+		);
 
 	sprintf(fmt, "VCE%%c exceptions\t\t: %s\n",
 	        cpu_has_vce ? "%u" : "not available");
diff -Naur linux-2.6.14/arch/mips/kernel/process.c linux-mips-2.6.14.orig/arch/mips/kernel/process.c
--- linux-2.6.14/arch/mips/kernel/process.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/process.c	2005-11-17 11:42:20.000000000 -0800
@@ -25,8 +25,10 @@
 #include <linux/init.h>
 #include <linux/completion.h>
 
+#include <asm/abi.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
+#include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -39,14 +41,6 @@
 #include <asm/inst.h>
 
 /*
- * We use this if we don't have any better idle routine..
- * (This to kill: kernel/platform.c.
- */
-void default_idle (void)
-{
-}
-
-/*
  * The idle thread. There's no useful work to be done, so just try to conserve
  * power and have a low exit latency (ie sit in a loop waiting for somebody to
  * say that they'd like to reschedule)
@@ -62,6 +56,54 @@
 	}
 }
 
+extern int do_signal(sigset_t *oldset, struct pt_regs *regs);
+extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
+
+/*
+ * Native o32 and N64 ABI without DSP ASE
+ */
+extern int setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set);
+extern int setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set, siginfo_t *info);
+
+struct mips_abi mips_abi = {
+	.do_signal	= do_signal,
+#ifdef CONFIG_TRAD_SIGNALS
+	.setup_frame	= setup_frame,
+#endif
+	.setup_rt_frame	= setup_rt_frame
+};
+
+#ifdef CONFIG_MIPS32_O32
+/*
+ * o32 compatibility on 64-bit kernels, without DSP ASE
+ */
+extern int setup_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set);
+extern int setup_rt_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set, siginfo_t *info);
+
+struct mips_abi mips_abi_32 = {
+	.do_signal	= do_signal32,
+	.setup_frame	= setup_frame_32,
+	.setup_rt_frame	= setup_rt_frame_32
+};
+#endif /* CONFIG_MIPS32_O32 */
+
+#ifdef CONFIG_MIPS32_N32
+/*
+ * N32 on 64-bit kernels, without DSP ASE
+ */
+extern int setup_rt_frame_n32(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set, siginfo_t *info);
+
+struct mips_abi mips_abi_n32 = {
+	.do_signal	= do_signal,
+	.setup_rt_frame	= setup_rt_frame_n32
+};
+#endif /* CONFIG_MIPS32_N32 */
+
 asmlinkage void ret_from_fork(void);
 
 void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
@@ -78,6 +120,8 @@
 	regs->cp0_status = status;
 	clear_used_math();
 	lose_fpu();
+	if (cpu_has_dsp)
+		__init_dsp();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 	current_thread_info()->addr_limit = USER_DS;
@@ -97,14 +141,17 @@
 	struct thread_info *ti = p->thread_info;
 	struct pt_regs *childregs;
 	long childksp;
+	p->set_child_tid = p->clear_child_tid = NULL;
 
 	childksp = (unsigned long)ti + THREAD_SIZE - 32;
 
 	preempt_disable();
 
-	if (is_fpu_owner()) {
+	if (is_fpu_owner())
 		save_fp(p);
-	}
+
+	if (cpu_has_dsp)
+		save_dsp(p);
 
 	preempt_enable();
 
@@ -142,6 +189,9 @@
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
 
+	if (clone_flags & CLONE_SETTLS)
+		ti->tp_value = regs->regs[7];
+
 	return 0;
 }
 
@@ -175,6 +225,14 @@
 #endif
 }
 
+int dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
+{
+	struct thread_info *ti = tsk->thread_info;
+	long ksp = (unsigned long)ti + THREAD_SIZE - 32;
+	dump_regs(&(*regs)[0], (struct pt_regs *) ksp - 1);
+	return 1;
+}
+
 int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
 {
 	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));
@@ -211,22 +269,48 @@
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
-struct mips_frame_info {
+static struct mips_frame_info {
+	void *func;
+	int omit_fp;	/* compiled without fno-omit-frame-pointer */
 	int frame_offset;
 	int pc_offset;
+} schedule_frame, mfinfo[] = {
+	{ schedule, 0 },	/* must be first */
+	/* arch/mips/kernel/semaphore.c */
+	{ __down, 1 },
+	{ __down_interruptible, 1 },
+	/* kernel/sched.c */
+#ifdef CONFIG_PREEMPT
+	{ preempt_schedule, 0 },
+#endif
+	{ wait_for_completion, 0 },
+	{ interruptible_sleep_on, 0 },
+	{ interruptible_sleep_on_timeout, 0 },
+	{ sleep_on, 0 },
+	{ sleep_on_timeout, 0 },
+	{ yield, 0 },
+	{ io_schedule, 0 },
+	{ io_schedule_timeout, 0 },
+#if defined(CONFIG_SMP) && defined(CONFIG_PREEMPT)
+	{ __preempt_spin_lock, 0 },
+	{ __preempt_write_lock, 0 },
+#endif
+	/* kernel/timer.c */
+	{ schedule_timeout, 1 },
+/*	{ nanosleep_restart, 1 }, */
+	/* lib/rwsem-spinlock.c */
+	{ __down_read, 1 },
+	{ __down_write, 1 },
 };
-static struct mips_frame_info schedule_frame;
-static struct mips_frame_info schedule_timeout_frame;
-static struct mips_frame_info sleep_on_frame;
-static struct mips_frame_info sleep_on_timeout_frame;
-static struct mips_frame_info wait_for_completion_frame;
+
 static int mips_frame_info_initialized;
-static int __init get_frame_info(struct mips_frame_info *info, void *func)
+static int __init get_frame_info(struct mips_frame_info *info)
 {
 	int i;
+	void *func = info->func;
 	union mips_instruction *ip = (union mips_instruction *)func;
 	info->pc_offset = -1;
-	info->frame_offset = -1;
+	info->frame_offset = info->omit_fp ? 0 : -1;
 	for (i = 0; i < 128; i++, ip++) {
 		/* if jal, jalr, jr, stop. */
 		if (ip->j_format.opcode == jal_op ||
@@ -247,14 +331,16 @@
 			/* sw / sd $ra, offset($sp) */
 			if (ip->i_format.rt == 31) {
 				if (info->pc_offset != -1)
-					break;
+					continue;
 				info->pc_offset =
 					ip->i_format.simmediate / sizeof(long);
 			}
 			/* sw / sd $s8, offset($sp) */
 			if (ip->i_format.rt == 30) {
+//#if 0	/* gcc 3.4 does aggressive optimization... */
 				if (info->frame_offset != -1)
-					break;
+					continue;
+//#endif
 				info->frame_offset =
 					ip->i_format.simmediate / sizeof(long);
 			}
@@ -272,13 +358,25 @@
 
 static int __init frame_info_init(void)
 {
-	mips_frame_info_initialized =
-		!get_frame_info(&schedule_frame, schedule) &&
-		!get_frame_info(&schedule_timeout_frame, schedule_timeout) &&
-		!get_frame_info(&sleep_on_frame, sleep_on) &&
-		!get_frame_info(&sleep_on_timeout_frame, sleep_on_timeout) &&
-		!get_frame_info(&wait_for_completion_frame, wait_for_completion);
-
+	int i, found;
+	for (i = 0; i < ARRAY_SIZE(mfinfo); i++)
+		if (get_frame_info(&mfinfo[i]))
+			return -1;
+	schedule_frame = mfinfo[0];
+	/* bubble sort */
+	do {
+		struct mips_frame_info tmp;
+		found = 0;
+		for (i = 1; i < ARRAY_SIZE(mfinfo); i++) {
+			if (mfinfo[i-1].func > mfinfo[i].func) {
+				tmp = mfinfo[i];
+				mfinfo[i] = mfinfo[i-1];
+				mfinfo[i-1] = tmp;
+				found = 1;
+			}
+		}
+	} while (found);
+	mips_frame_info_initialized = 1;
 	return 0;
 }
 
@@ -303,60 +401,39 @@
 /* get_wchan - a maintenance nightmare^W^Wpain in the ass ...  */
 unsigned long get_wchan(struct task_struct *p)
 {
+	unsigned long stack_page;
 	unsigned long frame, pc;
 
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	if (!mips_frame_info_initialized)
+	stack_page = (unsigned long)p->thread_info;
+	if (!stack_page || !mips_frame_info_initialized)
 		return 0;
+
 	pc = thread_saved_pc(p);
 	if (!in_sched_functions(pc))
-		goto out;
-
-	if (pc >= (unsigned long) sleep_on_timeout)
-		goto schedule_timeout_caller;
-	if (pc >= (unsigned long) sleep_on)
-		goto schedule_caller;
-	if (pc >= (unsigned long) interruptible_sleep_on_timeout)
-		goto schedule_timeout_caller;
-	if (pc >= (unsigned long)interruptible_sleep_on)
-		goto schedule_caller;
-	if (pc >= (unsigned long)wait_for_completion)
-		goto schedule_caller;
-	goto schedule_timeout_caller;
-
-schedule_caller:
-	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
-	if (pc >= (unsigned long) sleep_on)
-		pc = ((unsigned long *)frame)[sleep_on_frame.pc_offset];
-	else
-		pc = ((unsigned long *)frame)[wait_for_completion_frame.pc_offset];
-	goto out;
+		return pc;
 
-schedule_timeout_caller:
-	/*
-	 * The schedule_timeout frame
-	 */
 	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
+	do {
+		int i;
 
-	/*
-	 * frame now points to sleep_on_timeout's frame
-	 */
-	pc    = ((unsigned long *)frame)[schedule_timeout_frame.pc_offset];
-
-	if (in_sched_functions(pc)) {
-		/* schedule_timeout called by [interruptible_]sleep_on_timeout */
-		frame = ((unsigned long *)frame)[schedule_timeout_frame.frame_offset];
-		pc    = ((unsigned long *)frame)[sleep_on_timeout_frame.pc_offset];
-	}
+		if (frame < stack_page || frame > stack_page + THREAD_SIZE - 32)
+			return 0;
 
-out:
+		for (i = ARRAY_SIZE(mfinfo) - 1; i >= 0; i--) {
+			if (pc >= (unsigned long) mfinfo[i].func)
+				break;
+		}
+		if (i < 0)
+			break;
 
-#ifdef CONFIG_64BIT
-	if (current->thread.mflags & MF_32BIT_REGS) /* Kludge for 32-bit ps  */
-		pc &= 0xffffffffUL;
-#endif
+		if (mfinfo[i].omit_fp)
+			break;
+		pc = ((unsigned long *)frame)[mfinfo[i].pc_offset];
+		frame = ((unsigned long *)frame)[mfinfo[i].frame_offset];
+	} while (in_sched_functions(pc));
 
 	return pc;
 }
diff -Naur linux-2.6.14/arch/mips/kernel/ptrace32.c linux-mips-2.6.14.orig/arch/mips/kernel/ptrace32.c
--- linux-2.6.14/arch/mips/kernel/ptrace32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/ptrace32.c	2005-11-17 11:42:20.000000000 -0800
@@ -24,17 +24,24 @@
 #include <linux/smp_lock.h>
 #include <linux/user.h>
 #include <linux/security.h>
-#include <linux/signal.h>
 
 #include <asm/cpu.h>
+#include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
 
+int ptrace_getregs (struct task_struct *child, __s64 __user *data);
+int ptrace_setregs (struct task_struct *child, __s64 __user *data);
+
+int ptrace_getfpregs (struct task_struct *child, __u32 __user *data);
+int ptrace_setfpregs (struct task_struct *child, __u32 __user *data);
+
 /*
  * Tracing a 32-bit process with a 64-bit strace and vice versa will not
  * work.  I don't know how to fix this.
@@ -99,6 +106,35 @@
 		break;
 	}
 
+	/*
+	 * Read 4 bytes of the other process' storage
+	 *  data is a pointer specifying where the user wants the
+	 *	4 bytes copied into
+	 *  addr is a pointer in the user's storage that contains an 8 byte
+	 *	address in the other process of the 4 bytes that is to be read
+	 * (this is run in a 32-bit process looking at a 64-bit process)
+	 * when I and D space are separate, these will need to be fixed.
+	 */
+	case PTRACE_PEEKTEXT_3264:
+	case PTRACE_PEEKDATA_3264: {
+		u32 tmp;
+		int copied;
+		u32 __user * addrOthers;
+
+		ret = -EIO;
+
+		/* Get the addr in the other process that we want to read */
+		if (get_user(addrOthers, (u32 __user * __user *) (unsigned long) addr) != 0)
+			break;
+
+		copied = access_process_vm(child, (u64)addrOthers, &tmp,
+				sizeof(tmp), 0);
+		if (copied != sizeof(tmp))
+			break;
+		ret = put_user(tmp, (u32 __user *) (unsigned long) data);
+		break;
+	}
+
 	/* Read the word at location addr in the USER area. */
 	case PTRACE_PEEKUSR: {
 		struct pt_regs *regs;
@@ -156,12 +192,44 @@
 			if (!cpu_has_fpu)
 				break;
 
-			flags = read_c0_status();
-			__enable_fpu();
-			__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
-			write_c0_status(flags);
+			preempt_disable();
+			if (cpu_has_mipsmt) {
+				unsigned int vpflags = dvpe();
+				flags = read_c0_status();
+				__enable_fpu();
+				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				write_c0_status(flags);
+				evpe(vpflags);
+			} else {
+				flags = read_c0_status();
+				__enable_fpu();
+				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				write_c0_status(flags);
+			}
+			preempt_enable();
 			break;
 		}
+		case DSP_BASE ... DSP_BASE + 5:
+			if (!cpu_has_dsp) {
+				tmp = 0;
+				ret = -EIO;
+				goto out_tsk;
+			}
+			if (child->thread.dsp.used_dsp) {
+				dspreg_t *dregs = __get_dsp_regs(child);
+				tmp = (unsigned long) (dregs[addr - DSP_BASE]);
+			} else {
+				tmp = -1;	/* DSP registers yet used  */
+			}
+			break;
+		case DSP_CONTROL:
+			if (!cpu_has_dsp) {
+				tmp = 0;
+				ret = -EIO;
+				goto out_tsk;
+			}
+			tmp = child->thread.dsp.dspcontrol;
+			break;
 		default:
 			tmp = 0;
 			ret = -EIO;
@@ -181,6 +249,31 @@
 		ret = -EIO;
 		break;
 
+	/*
+	 * Write 4 bytes into the other process' storage
+	 *  data is the 4 bytes that the user wants written
+	 *  addr is a pointer in the user's storage that contains an
+	 *	8 byte address in the other process where the 4 bytes
+	 *	that is to be written
+	 * (this is run in a 32-bit process looking at a 64-bit process)
+	 * when I and D space are separate, these will need to be fixed.
+	 */
+	case PTRACE_POKETEXT_3264:
+	case PTRACE_POKEDATA_3264: {
+		u32 __user * addrOthers;
+
+		/* Get the addr in the other process that we want to write into */
+		ret = -EIO;
+		if (get_user(addrOthers, (u32 __user * __user *) (unsigned long) addr) != 0)
+			break;
+		ret = 0;
+		if (access_process_vm(child, (u64)addrOthers, &data,
+					sizeof(data), 1) == sizeof(data))
+			break;
+		ret = -EIO;
+		break;
+	}
+
 	case PTRACE_POKEUSR: {
 		struct pt_regs *regs;
 		ret = 0;
@@ -231,6 +324,22 @@
 			else
 				child->thread.fpu.soft.fcr31 = data;
 			break;
+		case DSP_BASE ... DSP_BASE + 5:
+			if (!cpu_has_dsp) {
+				ret = -EIO;
+				break;
+			}
+
+			dspreg_t *dregs = __get_dsp_regs(child);
+			dregs[addr - DSP_BASE] = data;
+			break;
+		case DSP_CONTROL:
+			if (!cpu_has_dsp) {
+				ret = -EIO;
+				break;
+			}
+			child->thread.dsp.dspcontrol = data;
+			break;
 		default:
 			/* The rest are not allowed. */
 			ret = -EIO;
@@ -239,6 +348,22 @@
 		break;
 		}
 
+	case PTRACE_GETREGS:
+		ret = ptrace_getregs (child, (__u64 __user *) (__u64) data);
+		break;
+
+	case PTRACE_SETREGS:
+		ret = ptrace_setregs (child, (__u64 __user *) (__u64) data);
+		break;
+
+	case PTRACE_GETFPREGS:
+		ret = ptrace_getfpregs (child, (__u32 __user *) (__u64) data);
+		break;
+
+	case PTRACE_SETFPREGS:
+		ret = ptrace_setfpregs (child, (__u32 __user *) (__u64) data);
+		break;
+
 	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
 	case PTRACE_CONT: { /* restart after signal. */
 		ret = -EIO;
@@ -269,10 +394,25 @@
 		wake_up_process(child);
 		break;
 
+	case PTRACE_GET_THREAD_AREA:
+		ret = put_user(child->thread_info->tp_value,
+				(unsigned int __user *) (unsigned long) data);
+		break;
+
 	case PTRACE_DETACH: /* detach a process that was attached. */
 		ret = ptrace_detach(child, data);
 		break;
 
+	case PTRACE_GETEVENTMSG:
+		ret = put_user(child->ptrace_message,
+			       (unsigned int __user *) (unsigned long) data);
+		break;
+
+	case PTRACE_GET_THREAD_AREA_3264:
+		ret = put_user(child->thread_info->tp_value,
+				(unsigned long __user *) (unsigned long) data);
+		break;
+
 	default:
 		ret = ptrace_request(child, request, addr, data);
 		break;
diff -Naur linux-2.6.14/arch/mips/kernel/ptrace.c linux-mips-2.6.14.orig/arch/mips/kernel/ptrace.c
--- linux-2.6.14/arch/mips/kernel/ptrace.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/ptrace.c	2005-11-17 11:42:20.000000000 -0800
@@ -21,21 +21,25 @@
 #include <linux/mm.h>
 #include <linux/errno.h>
 #include <linux/ptrace.h>
-#include <linux/audit.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/user.h>
 #include <linux/security.h>
-#include <linux/signal.h>
+#include <linux/audit.h>
+#include <linux/seccomp.h>
 
+#include <asm/byteorder.h>
 #include <asm/cpu.h>
+#include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
 #include <asm/pgtable.h>
 #include <asm/page.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
+#include <asm/reg.h>
 
 /*
  * Called by kernel/ptrace.c when detaching..
@@ -47,6 +51,129 @@
 	/* Nothing to do.. */
 }
 
+/*
+ * Read a general register set.  We always use the 64-bit format, even
+ * for 32-bit kernels and for 32-bit processes on a 64-bit kernel.
+ * Registers are sign extended to fill the available space.
+ */
+int ptrace_getregs (struct task_struct *child, __s64 __user *data)
+{
+	struct pt_regs *regs;
+	int i;
+
+	if (!access_ok(VERIFY_WRITE, data, 38 * 8))
+		return -EIO;
+
+	regs = (struct pt_regs *) ((unsigned long) child->thread_info +
+	       THREAD_SIZE - 32 - sizeof(struct pt_regs));
+
+	for (i = 0; i < 32; i++)
+		__put_user (regs->regs[i], data + i);
+	__put_user (regs->lo, data + EF_LO - EF_R0);
+	__put_user (regs->hi, data + EF_HI - EF_R0);
+	__put_user (regs->cp0_epc, data + EF_CP0_EPC - EF_R0);
+	__put_user (regs->cp0_badvaddr, data + EF_CP0_BADVADDR - EF_R0);
+	__put_user (regs->cp0_status, data + EF_CP0_STATUS - EF_R0);
+	__put_user (regs->cp0_cause, data + EF_CP0_CAUSE - EF_R0);
+
+	return 0;
+}
+
+/*
+ * Write a general register set.  As for PTRACE_GETREGS, we always use
+ * the 64-bit format.  On a 32-bit kernel only the lower order half
+ * (according to endianness) will be used.
+ */
+int ptrace_setregs (struct task_struct *child, __s64 __user *data)
+{
+	struct pt_regs *regs;
+	int i;
+
+	if (!access_ok(VERIFY_READ, data, 38 * 8))
+		return -EIO;
+
+	regs = (struct pt_regs *) ((unsigned long) child->thread_info +
+	       THREAD_SIZE - 32 - sizeof(struct pt_regs));
+
+	for (i = 0; i < 32; i++)
+		__get_user (regs->regs[i], data + i);
+	__get_user (regs->lo, data + EF_LO - EF_R0);
+	__get_user (regs->hi, data + EF_HI - EF_R0);
+	__get_user (regs->cp0_epc, data + EF_CP0_EPC - EF_R0);
+
+	/* badvaddr, status, and cause may not be written.  */
+
+	return 0;
+}
+
+int ptrace_getfpregs (struct task_struct *child, __u32 __user *data)
+{
+	int i;
+
+	if (!access_ok(VERIFY_WRITE, data, 33 * 8))
+		return -EIO;
+
+	if (tsk_used_math(child)) {
+		fpureg_t *fregs = get_fpu_regs(child);
+		for (i = 0; i < 32; i++)
+			__put_user (fregs[i], i + (__u64 __user *) data);
+	} else {
+		for (i = 0; i < 32; i++)
+			__put_user ((__u64) -1, i + (__u64 __user *) data);
+	}
+
+	if (cpu_has_fpu) {
+		unsigned int flags, tmp;
+
+		__put_user (child->thread.fpu.hard.fcr31, data + 64);
+
+		preempt_disable();
+		if (cpu_has_mipsmt) {
+			unsigned int vpflags = dvpe();
+			flags = read_c0_status();
+			__enable_fpu();
+			__asm__ __volatile__("cfc1\t%0,$0" : "=r" (tmp));
+			write_c0_status(flags);
+			evpe(vpflags);
+		} else {
+			flags = read_c0_status();
+			__enable_fpu();
+			__asm__ __volatile__("cfc1\t%0,$0" : "=r" (tmp));
+			write_c0_status(flags);
+		}
+		preempt_enable();
+		__put_user (tmp, data + 65);
+	} else {
+		__put_user (child->thread.fpu.soft.fcr31, data + 64);
+		__put_user ((__u32) 0, data + 65);
+	}
+
+	return 0;
+}
+
+int ptrace_setfpregs (struct task_struct *child, __u32 __user *data)
+{
+	fpureg_t *fregs;
+	int i;
+
+	if (!access_ok(VERIFY_READ, data, 33 * 8))
+		return -EIO;
+
+	fregs = get_fpu_regs(child);
+
+	for (i = 0; i < 32; i++)
+		__get_user (fregs[i], i + (__u64 __user *) data);
+
+	if (cpu_has_fpu)
+		__get_user (child->thread.fpu.hard.fcr31, data + 64);
+	else
+		__get_user (child->thread.fpu.soft.fcr31, data + 64);
+
+	/* FIR may not be written.  */
+
+	return 0;
+}
+
 asmlinkage int sys_ptrace(long request, long pid, long addr, long data)
 {
 	struct task_struct *child;
@@ -103,7 +230,7 @@
 		ret = -EIO;
 		if (copied != sizeof(tmp))
 			break;
-		ret = put_user(tmp,(unsigned long *) data);
+		ret = put_user(tmp,(unsigned long __user *) data);
 		break;
 	}
 
@@ -169,18 +296,53 @@
 			if (!cpu_has_fpu)
 				break;
 
-			flags = read_c0_status();
-			__enable_fpu();
-			__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
-			write_c0_status(flags);
+			preempt_disable();
+			if (cpu_has_mipsmt) {
+				unsigned int vpflags = dvpe();
+				flags = read_c0_status();
+				__enable_fpu();
+				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				write_c0_status(flags);
+				evpe(vpflags);
+			} else {
+				flags = read_c0_status();
+				__enable_fpu();
+				__asm__ __volatile__("cfc1\t%0,$0": "=r" (tmp));
+				write_c0_status(flags);
+			}
+			preempt_enable();
+			break;
+		}
+		case DSP_BASE ... DSP_BASE + 5: {
+			dspreg_t *dregs;
+
+			if (!cpu_has_dsp) {
+				tmp = 0;
+				ret = -EIO;
+				goto out_tsk;
+			}
+			if (child->thread.dsp.used_dsp) {
+				dregs = __get_dsp_regs(child);
+				tmp = (unsigned long) (dregs[addr - DSP_BASE]);
+			} else {
+				tmp = -1;	/* DSP registers yet used  */
+			}
 			break;
 		}
+		case DSP_CONTROL:
+			if (!cpu_has_dsp) {
+				tmp = 0;
+				ret = -EIO;
+				goto out_tsk;
+			}
+			tmp = child->thread.dsp.dspcontrol;
+			break;
 		default:
 			tmp = 0;
 			ret = -EIO;
 			goto out_tsk;
 		}
-		ret = put_user(tmp, (unsigned long *) data);
+		ret = put_user(tmp, (unsigned long __user *) data);
 		break;
 	}
 
@@ -247,6 +409,25 @@
 			else
 				child->thread.fpu.soft.fcr31 = data;
 			break;
+		case DSP_BASE ... DSP_BASE + 5: {
+			dspreg_t *dregs;
+
+			if (!cpu_has_dsp) {
+				ret = -EIO;
+				break;
+			}
+
+			dregs = __get_dsp_regs(child);
+			dregs[addr - DSP_BASE] = data;
+			break;
+		}
+		case DSP_CONTROL:
+			if (!cpu_has_dsp) {
+				ret = -EIO;
+				break;
+			}
+			child->thread.dsp.dspcontrol = data;
+			break;
 		default:
 			/* The rest are not allowed. */
 			ret = -EIO;
@@ -255,6 +436,22 @@
 		break;
 		}
 
+	case PTRACE_GETREGS:
+		ret = ptrace_getregs (child, (__u64 __user *) data);
+		break;
+
+	case PTRACE_SETREGS:
+		ret = ptrace_setregs (child, (__u64 __user *) data);
+		break;
+
+	case PTRACE_GETFPREGS:
+		ret = ptrace_getfpregs (child, (__u32 __user *) data);
+		break;
+
+	case PTRACE_SETFPREGS:
+		ret = ptrace_setfpregs (child, (__u32 __user *) data);
+		break;
+
 	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
 	case PTRACE_CONT: { /* restart after signal. */
 		ret = -EIO;
@@ -289,6 +486,11 @@
 		ret = ptrace_detach(child, data);
 		break;
 
+	case PTRACE_GET_THREAD_AREA:
+		ret = put_user(child->thread_info->tp_value,
+				(unsigned long __user *) data);
+		break;
+
 	default:
 		ret = ptrace_request(child, request, addr, data);
 		break;
@@ -303,21 +505,14 @@
 
 static inline int audit_arch(void)
 {
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
+	int arch = EM_MIPS;
 #ifdef CONFIG_64BIT
-	if (!(current->thread.mflags & MF_32BIT_REGS))
-		return AUDIT_ARCH_MIPSEL64;
-#endif /* MIPS64 */
-	return AUDIT_ARCH_MIPSEL;
-
-#else /* big endian... */
-#ifdef CONFIG_64BIT
-	if (!(current->thread.mflags & MF_32BIT_REGS))
-		return AUDIT_ARCH_MIPS64;
-#endif /* MIPS64 */
-	return AUDIT_ARCH_MIPS;
-
-#endif /* endian */
+	arch |=  __AUDIT_ARCH_64BIT;
+#endif
+#if defined(__LITTLE_ENDIAN)
+	arch |=  __AUDIT_ARCH_LE;
+#endif
+	return arch;
 }
 
 /*
@@ -326,14 +521,19 @@
  */
 asmlinkage void do_syscall_trace(struct pt_regs *regs, int entryexit)
 {
+	/* do the secure computing check first */
+	secure_computing(regs->orig_eax);
+
 	if (unlikely(current->audit_context) && entryexit)
-		audit_syscall_exit(current, AUDITSC_RESULT(regs->regs[2]), regs->regs[2]);
+		audit_syscall_exit(current, AUDITSC_RESULT(regs->regs[2]),
+		                   regs->regs[2]);
 
-	if (!test_thread_flag(TIF_SYSCALL_TRACE))
-		goto out;
 	if (!(current->ptrace & PT_PTRACED))
 		goto out;
 
+	if (!test_thread_flag(TIF_SYSCALL_TRACE))
+		goto out;
+
 	/* The 0x80 provides a way for the tracing parent to distinguish
 	   between a syscall stop and SIGTRAP delivery */
 	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD) ?
@@ -348,9 +548,14 @@
 		send_sig(current->exit_code, current, 1);
 		current->exit_code = 0;
 	}
- out:
+
+out:
+	/* There is no ->orig_eax and that's quite intensional for now making
+	   this work will require some work in various other place before it's
+	   more than a placebo.  */
+
 	if (unlikely(current->audit_context) && !entryexit)
-		audit_syscall_entry(current, audit_arch(), regs->regs[2],
-				    regs->regs[4], regs->regs[5],
-				    regs->regs[6], regs->regs[7]);
+		audit_syscall_entry(current, audit_arch(), regs->orig_eax,
+		                    regs->regs[4], regs->regs[5],
+		                    regs->regs[6], regs->regs[7]);
 }
diff -Naur linux-2.6.14/arch/mips/kernel/r4k_fpu.S linux-mips-2.6.14.orig/arch/mips/kernel/r4k_fpu.S
--- linux-2.6.14/arch/mips/kernel/r4k_fpu.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/r4k_fpu.S	2005-11-17 11:42:21.000000000 -0800
@@ -32,7 +32,7 @@
 
 	.set	noreorder
 	.set	mips3
-	/* Save floating point context */
+
 LEAF(_save_fp_context)
 	cfc1	t1, fcr31
 
@@ -74,9 +74,6 @@
 	EX	sdc1 $f28, SC_FPREGS+224(a0)
 	EX	sdc1 $f30, SC_FPREGS+240(a0)
 	EX	sw t1, SC_FPC_CSR(a0)
-	cfc1	t0, $0				# implementation/version
-	EX	sw t0, SC_FPC_EIR(a0)
-
 	jr	ra
 	 li	v0, 0					# success
 	END(_save_fp_context)
diff -Naur linux-2.6.14/arch/mips/kernel/rtlx.c linux-mips-2.6.14.orig/arch/mips/kernel/rtlx.c
--- linux-2.6.14/arch/mips/kernel/rtlx.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/kernel/rtlx.c	2005-11-17 11:42:21.000000000 -0800
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+#include <linux/elf.h>
+#include <linux/seq_file.h>
+#include <linux/syscalls.h>
+#include <linux/moduleloader.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <asm/mipsmtregs.h>
+#include <asm/cacheflush.h>
+#include <asm/atomic.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/rtlx.h>
+
+#define RTLX_MAJOR 64
+#define RTLX_TARG_VPE 1
+
+struct rtlx_info *rtlx;
+static int major;
+static char module_name[] = "rtlx";
+static inline int spacefree(int read, int write, int size);
+
+static struct chan_waitqueues {
+	wait_queue_head_t rt_queue;
+	wait_queue_head_t lx_queue;
+} channel_wqs[RTLX_CHANNELS];
+
+static struct irqaction irq;
+static int irq_num;
+
+extern void *vpe_get_shared(int index);
+
+static void rtlx_dispatch(struct pt_regs *regs)
+{
+	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ, regs);
+}
+
+irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	irqreturn_t r = IRQ_HANDLED;
+	int i;
+
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		struct rtlx_channel *chan = &rtlx->channel[i];
+
+		if (chan->lx_read != chan->lx_write)
+			wake_up_interruptible(&channel_wqs[i].lx_queue);
+	}
+
+	return r;
+}
+
+void dump_rtlx(void)
+{
+	int i;
+
+	printk("id 0x%lx state %d\n", rtlx->id, rtlx->state);
+
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		struct rtlx_channel *chan = &rtlx->channel[i];
+
+		printk(" rt_state %d lx_state %d buffer_size %d\n",
+		       chan->rt_state, chan->lx_state, chan->buffer_size);
+
+		printk(" rt_read %d rt_write %d\n",
+		       chan->rt_read, chan->rt_write);
+
+		printk(" lx_read %d lx_write %d\n",
+		       chan->lx_read, chan->lx_write);
+
+		printk(" rt_buffer <%s>\n", chan->rt_buffer);
+		printk(" lx_buffer <%s>\n", chan->lx_buffer);
+	}
+}
+
+/* call when we have the address of the shared structure from the SP side. */
+static int rtlx_init(struct rtlx_info *rtlxi)
+{
+	int i;
+
+	if (rtlxi->id != RTLX_ID) {
+		printk(KERN_WARNING "no valid RTLX id at 0x%p\n", rtlxi);
+		return (-ENOEXEC);
+	}
+
+	/* initialise the wait queues */
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		init_waitqueue_head(&channel_wqs[i].rt_queue);
+		init_waitqueue_head(&channel_wqs[i].lx_queue);
+	}
+
+	/* set up for interrupt handling */
+	memset(&irq, 0, sizeof(struct irqaction));
+
+	if (cpu_has_vint) {
+		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
+	}
+
+	irq_num = MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ;
+	irq.handler = rtlx_interrupt;
+	irq.flags = SA_INTERRUPT;
+	irq.name = "RTLX";
+	irq.dev_id = rtlx;
+	setup_irq(irq_num, &irq);
+
+	rtlx = rtlxi;
+	return (0);
+}
+
+/* only allow one open process at a time to open each channel */
+static int rtlx_open(struct inode *inode, struct file *filp)
+{
+	int minor, ret;
+	struct rtlx_channel *chan;
+
+	/* assume only 1 device at the mo. */
+	minor = MINOR(inode->i_rdev);
+
+	if (rtlx == NULL) {
+		struct rtlx_info **p;
+		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
+			printk(" vpe_get_shared is NULL. Has an SP program been loaded?\n");
+			return (-EFAULT);
+		}
+
+		if (*p == NULL) {
+			printk(" vpe_shared %p %p\n", p, *p);
+			return (-EFAULT);
+		}
+
+		if ((ret = rtlx_init(*p)) < 0)
+			return (ret);
+	}
+
+	chan = &rtlx->channel[minor];
+
+	/* already open? */
+	if (chan->lx_state == RTLX_STATE_OPENED)
+		return (-EBUSY);
+
+	chan->lx_state = RTLX_STATE_OPENED;
+	return (0);
+}
+
+static int rtlx_release(struct inode *inode, struct file *filp)
+{
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+	rtlx->channel[minor].lx_state = RTLX_STATE_UNUSED;
+	return (0);
+}
+
+static unsigned int rtlx_poll(struct file *file, poll_table * wait)
+{
+	int minor;
+	unsigned int mask = 0;
+	struct rtlx_channel *chan;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	chan = &rtlx->channel[minor];
+
+	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
+	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
+
+	/* data available to read? */
+	if (chan->lx_read != chan->lx_write)
+		mask |= POLLIN | POLLRDNORM;
+
+	/* space to write */
+	if (spacefree(chan->rt_read, chan->rt_write, chan->buffer_size))
+		mask |= POLLOUT | POLLWRNORM;
+
+	return (mask);
+}
+
+static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
+			 loff_t * ppos)
+{
+	size_t fl = 0L;
+	int minor;
+	struct rtlx_channel *lx;
+	DECLARE_WAITQUEUE(wait, current);
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	lx = &rtlx->channel[minor];
+
+	/* data available? */
+	if (lx->lx_write == lx->lx_read) {
+		if (file->f_flags & O_NONBLOCK)
+			return (0);	// -EAGAIN makes cat whinge
+
+		/* go to sleep */
+		add_wait_queue(&channel_wqs[minor].lx_queue, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		while (lx->lx_write == lx->lx_read)
+			schedule();
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&channel_wqs[minor].lx_queue, &wait);
+
+		/* back running */
+	}
+
+	/* find out how much in total */
+	count = min( count,
+		     (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read) % lx->buffer_size);
+
+	/* then how much from the read pointer onwards */
+	fl = min( count, (size_t)lx->buffer_size - lx->lx_read);
+
+	copy_to_user (buffer, &lx->lx_buffer[lx->lx_read], fl);
+
+	/* and if there is anything left at the beginning of the buffer */
+	if ( count - fl )
+		copy_to_user (buffer + fl, lx->lx_buffer, count - fl);
+
+	/* update the index */
+	lx->lx_read += count;
+	lx->lx_read %= lx->buffer_size;
+
+	return (count);
+}
+
+static inline int spacefree(int read, int write, int size)
+{
+	if (read == write) {
+		/* never fill the buffer completely, so indexes are always equal if empty
+		   and only empty, or !equal if data available */
+		return (size - 1);
+	}
+
+	return ((read + size - write) % size) - 1;
+}
+
+static ssize_t rtlx_write(struct file *file, const char __user * buffer,
+			  size_t count, loff_t * ppos)
+{
+	int minor;
+	struct rtlx_channel *rt;
+	size_t fl;
+	DECLARE_WAITQUEUE(wait, current);
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	rt = &rtlx->channel[minor];
+
+	/* any space left... */
+	if (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size)) {
+
+		if (file->f_flags & O_NONBLOCK)
+			return (-EAGAIN);
+
+		add_wait_queue(&channel_wqs[minor].rt_queue, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		while (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size))
+			schedule();
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&channel_wqs[minor].rt_queue, &wait);
+	}
+
+	/* total number of bytes to copy */
+	count = min( count, (size_t)spacefree(rt->rt_read, rt->rt_write, rt->buffer_size) );
+
+	/* first bit from write pointer to the end of the buffer, or count */
+	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
+
+	copy_from_user(&rt->rt_buffer[rt->rt_write], buffer, fl);
+
+	/* if there's any left copy to the beginning of the buffer */
+	if( count - fl )
+		copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
+
+	rt->rt_write += count;
+	rt->rt_write %= rt->buffer_size;
+
+	return(count);
+}
+
+static struct file_operations rtlx_fops = {
+	.owner = THIS_MODULE,
+	.open = rtlx_open,
+	.release = rtlx_release,
+	.write = rtlx_write,
+	.read = rtlx_read,
+	.poll = rtlx_poll
+};
+
+static int rtlx_module_init(void)
+{
+	if ((major = register_chrdev(RTLX_MAJOR, module_name, &rtlx_fops)) < 0) {
+		printk("rtlx_module_init: unable to register device\n");
+		return (-EBUSY);
+	}
+
+	if (major == 0)
+		major = RTLX_MAJOR;
+
+	return (0);
+}
+
+static void rtlx_module_exit(void)
+{
+	unregister_chrdev(major, module_name);
+}
+
+module_init(rtlx_module_init);
+module_exit(rtlx_module_exit);
+MODULE_DESCRIPTION("MIPS RTLX");
+MODULE_AUTHOR("Elizabeth Clarke, MIPS Technologies, Inc");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/arch/mips/kernel/scall32-o32.S linux-mips-2.6.14.orig/arch/mips/kernel/scall32-o32.S
--- linux-2.6.14/arch/mips/kernel/scall32-o32.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/scall32-o32.S	2005-11-17 11:42:21.000000000 -0800
@@ -578,7 +578,7 @@
 	sys	sys_fremovexattr	2	/* 4235 */
 	sys	sys_tkill		2
 	sys	sys_sendfile64		5
-	sys	sys_futex		2
+	sys	sys_futex		6
 	sys	sys_sched_setaffinity	3
 	sys	sys_sched_getaffinity	3	/* 4240 */
 	sys	sys_io_setup		2
@@ -587,7 +587,7 @@
 	sys	sys_io_submit		3
 	sys	sys_io_cancel		3	/* 4245 */
 	sys	sys_exit_group		1
-	sys	sys_lookup_dcookie	3
+	sys	sys_lookup_dcookie	4
 	sys	sys_epoll_create	1
 	sys	sys_epoll_ctl		4
 	sys	sys_epoll_wait		3	/* 4250 */
@@ -618,12 +618,15 @@
 	sys	sys_mq_notify		2	/* 4275 */
 	sys	sys_mq_getsetattr	3
 	sys	sys_ni_syscall		0	/* sys_vserver */
-	sys	sys_waitid		4
+	sys	sys_waitid		5
 	sys	sys_ni_syscall		0	/* available, was setaltroot */
-	sys	sys_add_key		5
+	sys	sys_add_key		5	/* 4280 */
 	sys	sys_request_key		4
 	sys	sys_keyctl		5
-
+	sys	sys_set_thread_area	1
+	sys	sys_inotify_init	0
+	sys	sys_inotify_add_watch	3	/* 4285 */
+	sys	sys_inotify_rm_watch	2
 	.endm
 
 	/* We pre-compute the number of _instruction_ bytes needed to
diff -Naur linux-2.6.14/arch/mips/kernel/scall64-64.S linux-mips-2.6.14.orig/arch/mips/kernel/scall64-64.S
--- linux-2.6.14/arch/mips/kernel/scall64-64.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/scall64-64.S	2005-11-17 11:42:21.000000000 -0800
@@ -449,3 +449,7 @@
 	PTR	sys_add_key
 	PTR	sys_request_key			/* 5240 */
 	PTR	sys_keyctl
+	PTR	sys_set_thread_area
+	PTR	sys_inotify_init
+	PTR	sys_inotify_add_watch
+	PTR	sys_inotify_rm_watch		/* 5245 */
diff -Naur linux-2.6.14/arch/mips/kernel/scall64-n32.S linux-mips-2.6.14.orig/arch/mips/kernel/scall64-n32.S
--- linux-2.6.14/arch/mips/kernel/scall64-n32.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/scall64-n32.S	2005-11-17 11:42:21.000000000 -0800
@@ -176,7 +176,7 @@
 	PTR	sys_fork
 	PTR	sys32_execve
 	PTR	sys_exit
-	PTR	sys32_wait4
+	PTR	compat_sys_wait4
 	PTR	sys_kill			/* 6060 */
 	PTR	sys32_newuname
 	PTR	sys_semget
@@ -216,7 +216,7 @@
 	PTR	compat_sys_getrusage
 	PTR	sys32_sysinfo
 	PTR	compat_sys_times
-	PTR	sys_ptrace
+	PTR	sys32_ptrace
 	PTR	sys_getuid			/* 6100 */
 	PTR	sys_syslog
 	PTR	sys_getgid
@@ -243,14 +243,14 @@
 	PTR	sys_capget
 	PTR	sys_capset
 	PTR	sys32_rt_sigpending		/* 6125 */
-	PTR	compat_sys_rt_sigtimedwait
-	PTR	sys32_rt_sigqueueinfo
+	PTR	sysn32_rt_sigtimedwait
+	PTR	sys_rt_sigqueueinfo
 	PTR	sys32_rt_sigsuspend
 	PTR	sys32_sigaltstack
 	PTR	compat_sys_utime		/* 6130 */
 	PTR	sys_mknod
 	PTR	sys32_personality
-	PTR	sys_ustat
+	PTR	sys32_ustat
 	PTR	compat_sys_statfs
 	PTR	compat_sys_fstatfs		/* 6135 */
 	PTR	sys_sysfs
@@ -329,7 +329,7 @@
 	PTR	sys_epoll_wait
 	PTR	sys_remap_file_pages		/* 6210 */
 	PTR	sysn32_rt_sigreturn
-	PTR	sys_fcntl
+	PTR	compat_sys_fcntl64
 	PTR	sys_set_tid_address
 	PTR	sys_restart_syscall
 	PTR	sys_semtimedop			/* 6215 */
@@ -337,15 +337,15 @@
 	PTR	compat_sys_statfs64
 	PTR	compat_sys_fstatfs64
 	PTR	sys_sendfile64
-	PTR	sys_timer_create		/* 6220 */
-	PTR	sys_timer_settime
-	PTR	sys_timer_gettime
+	PTR	sys32_timer_create		/* 6220 */
+	PTR	compat_sys_timer_settime
+	PTR	compat_sys_timer_gettime
 	PTR	sys_timer_getoverrun
 	PTR	sys_timer_delete
-	PTR	sys_clock_settime		/* 6225 */
-	PTR	sys_clock_gettime
-	PTR	sys_clock_getres
-	PTR	sys_clock_nanosleep
+	PTR	compat_sys_clock_settime		/* 6225 */
+	PTR	compat_sys_clock_gettime
+	PTR	compat_sys_clock_getres
+	PTR	compat_sys_clock_nanosleep
 	PTR	sys_tgkill
 	PTR	compat_sys_utimes		/* 6230 */
 	PTR	sys_ni_syscall			/* sys_mbind */
@@ -358,8 +358,12 @@
 	PTR	compat_sys_mq_notify
 	PTR	compat_sys_mq_getsetattr
 	PTR	sys_ni_syscall			/* 6240, sys_vserver */
-	PTR	sys_waitid
+	PTR	sysn32_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
 	PTR	sys_request_key
 	PTR	sys_keyctl			/* 6245 */
+	PTR	sys_set_thread_area
+	PTR	sys_inotify_init
+	PTR	sys_inotify_add_watch
+	PTR	sys_inotify_rm_watch
diff -Naur linux-2.6.14/arch/mips/kernel/scall64-o32.S linux-mips-2.6.14.orig/arch/mips/kernel/scall64-o32.S
--- linux-2.6.14/arch/mips/kernel/scall64-o32.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/scall64-o32.S	2005-11-17 11:42:21.000000000 -0800
@@ -316,13 +316,13 @@
 	PTR	sys_vhangup
 	PTR	sys_ni_syscall			/* was sys_idle	 */
 	PTR	sys_ni_syscall			/* sys_vm86 */
-	PTR	sys32_wait4
+	PTR	compat_sys_wait4
 	PTR	sys_swapoff			/* 4115 */
 	PTR	sys32_sysinfo
 	PTR	sys32_ipc
 	PTR	sys_fsync
 	PTR	sys32_sigreturn
-	PTR	sys_clone			/* 4120 */
+	PTR	sys32_clone			/* 4120 */
 	PTR	sys_setdomainname
 	PTR	sys32_newuname
 	PTR	sys_ni_syscall			/* sys_modify_ldt */
@@ -391,7 +391,7 @@
 	PTR	sys_getresuid
 	PTR	sys_ni_syscall			/* was query_module */
 	PTR	sys_poll
-	PTR	sys_nfsservctl
+	PTR	compat_sys_nfsservctl
 	PTR	sys_setresgid			/* 4190 */
 	PTR	sys_getresgid
 	PTR	sys_prctl
@@ -459,7 +459,7 @@
 	PTR	sys_fadvise64_64
 	PTR	compat_sys_statfs64		/* 4255 */
 	PTR	compat_sys_fstatfs64
-	PTR	sys_timer_create
+	PTR	sys32_timer_create
 	PTR	compat_sys_timer_settime
 	PTR	compat_sys_timer_gettime
 	PTR	sys_timer_getoverrun		/* 4260 */
@@ -480,9 +480,13 @@
 	PTR	compat_sys_mq_notify		/* 4275 */
 	PTR	compat_sys_mq_getsetattr
 	PTR	sys_ni_syscall			/* sys_vserver */
-	PTR	sys_waitid
+	PTR	sys32_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key			/* 4280 */
 	PTR	sys_request_key
 	PTR	sys_keyctl
+	PTR	sys_set_thread_area
+	PTR	sys_inotify_init
+	PTR	sys_inotify_add_watch		/* 4285 */
+	PTR	sys_inotify_rm_watch
 	.size	sys_call_table,.-sys_call_table
diff -Naur linux-2.6.14/arch/mips/kernel/semaphore.c linux-mips-2.6.14.orig/arch/mips/kernel/semaphore.c
--- linux-2.6.14/arch/mips/kernel/semaphore.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/semaphore.c	2005-11-17 11:42:21.000000000 -0800
@@ -42,24 +42,28 @@
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		__asm__ __volatile__(
-		"1:	ll	%0, %2					\n"
+		"	.set	mips3					\n"
+		"1:	ll	%0, %2		# __sem_update_count	\n"
 		"	sra	%1, %0, 31				\n"
 		"	not	%1					\n"
 		"	and	%1, %0, %1				\n"
-		"	add	%1, %1, %3				\n"
+		"	addu	%1, %1, %3				\n"
 		"	sc	%1, %2					\n"
 		"	beqzl	%1, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (old_count), "=&r" (tmp), "=m" (sem->count)
 		: "r" (incr), "m" (sem->count));
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
-		"1:	ll	%0, %2					\n"
+		"	.set	mips3					\n"
+		"1:	ll	%0, %2		# __sem_update_count	\n"
 		"	sra	%1, %0, 31				\n"
 		"	not	%1					\n"
 		"	and	%1, %0, %1				\n"
-		"	add	%1, %1, %3				\n"
+		"	addu	%1, %1, %3				\n"
 		"	sc	%1, %2					\n"
 		"	beqz	%1, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (old_count), "=&r" (tmp), "=m" (sem->count)
 		: "r" (incr), "m" (sem->count));
 	} else {
diff -Naur linux-2.6.14/arch/mips/kernel/setup.c linux-mips-2.6.14.orig/arch/mips/kernel/setup.c
--- linux-2.6.14/arch/mips/kernel/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/setup.c	2005-11-17 11:42:22.000000000 -0800
@@ -37,12 +37,13 @@
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
+#include <asm/cache.h>
 #include <asm/cpu.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/system.h>
 
-struct cpuinfo_mips cpu_data[NR_CPUS];
+struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
 
@@ -62,8 +63,8 @@
  *
  * These are initialized so they are in the .data section
  */
-unsigned long mips_machtype = MACH_UNKNOWN;
-unsigned long mips_machgroup = MACH_GROUP_UNKNOWN;
+unsigned long mips_machtype __read_mostly = MACH_UNKNOWN;
+unsigned long mips_machgroup __read_mostly = MACH_GROUP_UNKNOWN;
 
 EXPORT_SYMBOL(mips_machtype);
 EXPORT_SYMBOL(mips_machgroup);
@@ -77,7 +78,7 @@
  * mips_io_port_base is the begin of the address space to which x86 style
  * I/O ports are mapped.
  */
-const unsigned long mips_io_port_base = -1;
+const unsigned long mips_io_port_base __read_mostly = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
 /*
@@ -510,31 +511,7 @@
 #undef MAXMEM
 #undef MAXMEM_PFN
 
-static int __initdata earlyinit_debug;
-
-static int __init earlyinit_debug_setup(char *str)
-{
-	earlyinit_debug = 1;
-	return 1;
-}
-__setup("earlyinit_debug", earlyinit_debug_setup);
-
-extern initcall_t __earlyinitcall_start, __earlyinitcall_end;
-
-static void __init do_earlyinitcalls(void)
-{
-	initcall_t *call, *start, *end;
-
-	start = &__earlyinitcall_start;
-	end = &__earlyinitcall_end;
-
-	for (call = start; call < end; call++) {
-		if (earlyinit_debug)
-			printk("calling earlyinitcall 0x%p\n", *call);
-
-		(*call)();
-	}
-}
+extern void plat_setup(void);
 
 void __init setup_arch(char **cmdline_p)
 {
@@ -551,7 +528,7 @@
 #endif
 
 	/* call board setup routine */
-	do_earlyinitcalls();
+	plat_setup();
 
 	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
 	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
@@ -573,3 +550,12 @@
 }
 
 __setup("nofpu", fpu_disable);
+
+int __init dsp_disable(char *s)
+{
+	cpu_data[0].ases &= ~MIPS_ASE_DSP;
+
+	return 1;
+}
+
+__setup("nodsp", dsp_disable);
diff -Naur linux-2.6.14/arch/mips/kernel/signal32.c linux-mips-2.6.14.orig/arch/mips/kernel/signal32.c
--- linux-2.6.14/arch/mips/kernel/signal32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/signal32.c	2005-11-17 11:42:22.000000000 -0800
@@ -7,6 +7,7 @@
  * Copyright (C) 1994 - 2000  Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  */
+#include <linux/cache.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -21,6 +22,7 @@
 #include <linux/suspend.h>
 #include <linux/compiler.h>
 
+#include <asm/abi.h>
 #include <asm/asm.h>
 #include <linux/bitops.h>
 #include <asm/cacheflush.h>
@@ -29,6 +31,7 @@
 #include <asm/ucontext.h>
 #include <asm/system.h>
 #include <asm/fpu.h>
+#include <asm/war.h>
 
 #define SI_PAD_SIZE32   ((SI_MAX_SIZE/sizeof(int)) - 3)
 
@@ -76,8 +79,10 @@
 
 		/* POSIX.1b timers */
 		struct {
-			unsigned int _timer1;
-			unsigned int _timer2;
+			timer_t _tid;		/* timer id */
+			int _overrun;		/* overrun count */
+			compat_sigval_t _sigval;/* same as below */
+			int _sys_private;       /* not to be passed to user */
 		} _timer;
 
 		/* POSIX.1b signals */
@@ -259,11 +264,12 @@
 
 	if (act) {
 		old_sigset_t mask;
+		s32 handler;
 
 		if (!access_ok(VERIFY_READ, act, sizeof(*act)))
 			return -EFAULT;
-		err |= __get_user((u32)(u64)new_ka.sa.sa_handler,
-		                  &act->sa_handler);
+		err |= __get_user(handler, &act->sa_handler);
+		new_ka.sa.sa_handler = (void*)(s64)handler;
 		err |= __get_user(new_ka.sa.sa_flags, &act->sa_flags);
 		err |= __get_user(mask, &act->sa_mask.sig[0]);
 		if (err)
@@ -331,8 +337,9 @@
 
 static int restore_sigcontext32(struct pt_regs *regs, struct sigcontext32 *sc)
 {
+	u32 used_math;
 	int err = 0;
-	__u32 used_math;
+	s32 treg;
 
 	/* Always make any pending restarted system calls return -EINTR */
 	current_thread_info()->restart_block.fn = do_no_restart_syscall;
@@ -340,6 +347,15 @@
 	err |= __get_user(regs->cp0_epc, &sc->sc_pc);
 	err |= __get_user(regs->hi, &sc->sc_mdhi);
 	err |= __get_user(regs->lo, &sc->sc_mdlo);
+	if (cpu_has_dsp) {
+		err |= __get_user(treg, &sc->sc_hi1); mthi1(treg);
+		err |= __get_user(treg, &sc->sc_lo1); mtlo1(treg);
+		err |= __get_user(treg, &sc->sc_hi2); mthi2(treg);
+		err |= __get_user(treg, &sc->sc_lo2); mtlo2(treg);
+		err |= __get_user(treg, &sc->sc_hi3); mthi3(treg);
+		err |= __get_user(treg, &sc->sc_lo3); mtlo3(treg);
+		err |= __get_user(treg, &sc->sc_dsp); wrdsp(treg, DSP_MASK);
+	}
 
 #define restore_gp_reg(i) do {						\
 	err |= __get_user(regs->regs[i], &sc->sc_regs[i]);		\
@@ -378,16 +394,30 @@
 
 struct sigframe {
 	u32 sf_ass[4];			/* argument save space for o32 */
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 sf_pad[2];
+#else
 	u32 sf_code[2];			/* signal trampoline */
+#endif
 	struct sigcontext32 sf_sc;
 	sigset_t sf_mask;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 sf_code[8] ____cacheline_aligned;	/* signal trampoline */
+#endif
 };
 
 struct rt_sigframe32 {
 	u32 rs_ass[4];			/* argument save space for o32 */
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 rs_pad[2];
+#else
 	u32 rs_code[2];			/* signal trampoline */
+#endif
 	compat_siginfo_t rs_info;
 	struct ucontext32 rs_uc;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 rs_code[8] __attribute__((aligned(32)));	/* signal trampoline */
+#endif
 };
 
 int copy_siginfo_to_user32(compat_siginfo_t *to, siginfo_t *from)
@@ -411,6 +441,11 @@
 		err |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);
 	else {
 		switch (from->si_code >> 16) {
+		case __SI_TIMER >> 16:
+			err |= __put_user(from->si_tid, &to->si_tid);
+			err |= __put_user(from->si_overrun, &to->si_overrun);
+			err |= __put_user(from->si_int, &to->si_int);
+			break;
 		case __SI_CHLD >> 16:
 			err |= __put_user(from->si_utime, &to->si_utime);
 			err |= __put_user(from->si_stime, &to->si_stime);
@@ -480,6 +515,7 @@
 _sys32_rt_sigreturn(nabi_no_regargs struct pt_regs regs)
 {
 	struct rt_sigframe32 *frame;
+	mm_segment_t old_fs;
 	sigset_t set;
 	stack_t st;
 	s32 sp;
@@ -510,7 +546,10 @@
 
 	/* It is more difficult to avoid calling this function than to
 	   call it and ignore errors.  */
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
 	do_sigaltstack(&st, NULL, regs.regs[29]);
+	set_fs (old_fs);
 
 	/*
 	 * Don't let your children do this ...
@@ -550,8 +589,15 @@
 
 	err |= __put_user(regs->hi, &sc->sc_mdhi);
 	err |= __put_user(regs->lo, &sc->sc_mdlo);
-	err |= __put_user(regs->cp0_cause, &sc->sc_cause);
-	err |= __put_user(regs->cp0_badvaddr, &sc->sc_badvaddr);
+	if (cpu_has_dsp) {
+		err |= __put_user(rddsp(DSP_MASK), &sc->sc_hi1);
+		err |= __put_user(mfhi1(), &sc->sc_hi1);
+		err |= __put_user(mflo1(), &sc->sc_lo1);
+		err |= __put_user(mfhi2(), &sc->sc_hi2);
+		err |= __put_user(mflo2(), &sc->sc_lo2);
+		err |= __put_user(mfhi3(), &sc->sc_hi3);
+		err |= __put_user(mflo3(), &sc->sc_lo3);
+	}
 
 	err |= __put_user(!!used_math(), &sc->sc_used_math);
 
@@ -601,7 +647,7 @@
 	return (void *)((sp - frame_size) & ALMASK);
 }
 
-static inline void setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
+void setup_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
 			       int signr, sigset_t *set)
 {
 	struct sigframe *frame;
@@ -654,9 +700,7 @@
 	force_sigsegv(signr, current);
 }
 
-static inline void setup_rt_frame(struct k_sigaction * ka,
-				  struct pt_regs *regs, int signr,
-				  sigset_t *set, siginfo_t *info)
+void setup_rt_frame_32(struct k_sigaction * ka, struct pt_regs *regs, int signr,	sigset_t *set, siginfo_t *info)
 {
 	struct rt_sigframe32 *frame;
 	int err = 0;
@@ -725,9 +769,11 @@
 	force_sigsegv(signr, current);
 }
 
-static inline void handle_signal(unsigned long sig, siginfo_t *info,
+static inline int handle_signal(unsigned long sig, siginfo_t *info,
 	struct k_sigaction *ka, sigset_t *oldset, struct pt_regs * regs)
 {
+	int ret;
+
 	switch (regs->regs[0]) {
 	case ERESTART_RESTARTBLOCK:
 	case ERESTARTNOHAND:
@@ -747,9 +793,9 @@
 	regs->regs[0] = 0;		/* Don't deal with this again.  */
 
 	if (ka->sa.sa_flags & SA_SIGINFO)
-		setup_rt_frame(ka, regs, sig, oldset, info);
+		ret = current->thread.abi->setup_rt_frame(ka, regs, sig, oldset, info);
 	else
-		setup_frame(ka, regs, sig, oldset);
+		ret = current->thread.abi->setup_frame(ka, regs, sig, oldset);
 
 	spin_lock_irq(&current->sighand->siglock);
 	sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
@@ -757,6 +803,8 @@
 		sigaddset(&current->blocked,sig);
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
+
+	return ret;
 }
 
 int do_signal32(sigset_t *oldset, struct pt_regs *regs)
@@ -780,10 +828,8 @@
 		oldset = &current->blocked;
 
 	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
-	if (signr > 0) {
-		handle_signal(signr, &info, &ka, oldset, regs);
-		return 1;
-	}
+	if (signr > 0)
+		return handle_signal(signr, &info, &ka, oldset, regs);
 
 no_signal:
 	/*
@@ -819,12 +865,13 @@
 		goto out;
 
 	if (act) {
+		s32 handler;
 		int err = 0;
 
 		if (!access_ok(VERIFY_READ, act, sizeof(*act)))
 			return -EFAULT;
-		err |= __get_user((u32)(u64)new_sa.sa.sa_handler,
-		                  &act->sa_handler);
+		err |= __get_user(handler, &act->sa_handler);
+		new_sa.sa.sa_handler = (void*)(s64)handler;
 		err |= __get_user(new_sa.sa.sa_flags, &act->sa_flags);
 		err |= get_sigset(&new_sa.sa.sa_mask, &act->sa_mask);
 		if (err)
@@ -902,3 +949,30 @@
 	set_fs (old_fs);
 	return ret;
 }
+
+asmlinkage long
+sys32_waitid(int which, compat_pid_t pid,
+	     compat_siginfo_t __user *uinfo, int options,
+	     struct compat_rusage __user *uru)
+{
+	siginfo_t info;
+	struct rusage ru;
+	long ret;
+	mm_segment_t old_fs = get_fs();
+
+	info.si_signo = 0;
+	set_fs (KERNEL_DS);
+	ret = sys_waitid(which, pid, (siginfo_t __user *) &info, options,
+			 uru ? (struct rusage __user *) &ru : NULL);
+	set_fs (old_fs);
+
+	if (ret < 0 || info.si_signo == 0)
+		return ret;
+
+	if (uru && (ret = put_compat_rusage(&ru, uru)))
+		return ret;
+
+	BUG_ON(info.si_code & __SI_MASK);
+	info.si_code |= __SI_CHLD;
+	return copy_siginfo_to_user32(uinfo, &info);
+}
diff -Naur linux-2.6.14/arch/mips/kernel/signal.c linux-mips-2.6.14.orig/arch/mips/kernel/signal.c
--- linux-2.6.14/arch/mips/kernel/signal.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/signal.c	2005-11-17 11:42:22.000000000 -0800
@@ -8,6 +8,7 @@
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  */
 #include <linux/config.h>
+#include <linux/cache.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/personality.h>
@@ -21,6 +22,7 @@
 #include <linux/unistd.h>
 #include <linux/compiler.h>
 
+#include <asm/abi.h>
 #include <asm/asm.h>
 #include <linux/bitops.h>
 #include <asm/cacheflush.h>
@@ -29,6 +31,7 @@
 #include <asm/uaccess.h>
 #include <asm/ucontext.h>
 #include <asm/cpu-features.h>
+#include <asm/war.h>
 
 #include "signal-common.h"
 
@@ -36,7 +39,7 @@
 
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-static int do_signal(sigset_t *oldset, struct pt_regs *regs);
+int do_signal(sigset_t *oldset, struct pt_regs *regs);
 
 /*
  * Atomically swap in the new signal mask, and wait for a signal.
@@ -47,9 +50,10 @@
 __attribute_used__ noinline static int
 _sys_sigsuspend(nabi_no_regargs struct pt_regs regs)
 {
-	sigset_t *uset, saveset, newset;
+	sigset_t saveset, newset;
+	sigset_t __user *uset;
 
-	uset = (sigset_t *) regs.regs[4];
+	uset = (sigset_t __user *) regs.regs[4];
 	if (copy_from_user(&newset, uset, sizeof(sigset_t)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -75,7 +79,8 @@
 __attribute_used__ noinline static int
 _sys_rt_sigsuspend(nabi_no_regargs struct pt_regs regs)
 {
-	sigset_t *unewset, saveset, newset;
+	sigset_t saveset, newset;
+	sigset_t __user *unewset;
 	size_t sigsetsize;
 
 	/* XXX Don't preclude handling different sized sigset_t's.  */
@@ -83,7 +88,7 @@
 	if (sigsetsize != sizeof(sigset_t))
 		return -EINVAL;
 
-	unewset = (sigset_t *) regs.regs[4];
+	unewset = (sigset_t __user *) regs.regs[4];
 	if (copy_from_user(&newset, unewset, sizeof(newset)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -147,33 +152,46 @@
 
 asmlinkage int sys_sigaltstack(nabi_no_regargs struct pt_regs regs)
 {
-	const stack_t *uss = (const stack_t *) regs.regs[4];
-	stack_t *uoss = (stack_t *) regs.regs[5];
+	const stack_t __user *uss = (const stack_t __user *) regs.regs[4];
+	stack_t __user *uoss = (stack_t __user *) regs.regs[5];
 	unsigned long usp = regs.regs[29];
 
 	return do_sigaltstack(uss, uoss, usp);
 }
 
-#if PLAT_TRAMPOLINE_STUFF_LINE
-#define __tramp __attribute__((aligned(PLAT_TRAMPOLINE_STUFF_LINE)))
-#else
-#define __tramp
-#endif
-
+/*
+ * Horribly complicated - with the bloody RM9000 workarounds enabled
+ * the signal trampolines is moving to the end of the structure so we can
+ * increase the alignment without breaking software compatibility.
+ */
 #ifdef CONFIG_TRAD_SIGNALS
 struct sigframe {
 	u32 sf_ass[4];			/* argument save space for o32 */
-	u32 sf_code[2] __tramp;		/* signal trampoline */
-	struct sigcontext sf_sc __tramp;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 sf_pad[2];
+#else
+	u32 sf_code[2];			/* signal trampoline */
+#endif
+	struct sigcontext sf_sc;
 	sigset_t sf_mask;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 sf_code[8] ____cacheline_aligned;	/* signal trampoline */
+#endif
 };
 #endif
 
 struct rt_sigframe {
 	u32 rs_ass[4];			/* argument save space for o32 */
-	u32 rs_code[2] __tramp;		/* signal trampoline */
-	struct siginfo rs_info __tramp;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 rs_pad[2];
+#else
+	u32 rs_code[2];			/* signal trampoline */
+#endif
+	struct siginfo rs_info;
 	struct ucontext rs_uc;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 rs_code[8] ____cacheline_aligned;	/* signal trampoline */
+#endif
 };
 
 #ifdef CONFIG_TRAD_SIGNALS
@@ -214,7 +232,7 @@
 badframe:
 	force_sig(SIGSEGV, current);
 }
-#endif
+#endif /* CONFIG_TRAD_SIGNALS */
 
 save_static_function(sys_rt_sigreturn);
 __attribute_used__ noinline static void
@@ -260,7 +278,7 @@
 }
 
 #ifdef CONFIG_TRAD_SIGNALS
-static void inline setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
+int setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
 	int signr, sigset_t *set)
 {
 	struct sigframe *frame;
@@ -270,17 +288,7 @@
 	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
 		goto give_sigsegv;
 
-	/*
-	 * Set up the return code ...
-	 *
-	 *         li      v0, __NR_sigreturn
-	 *         syscall
-	 */
-	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		__clear_user(frame->sf_code, PLAT_TRAMPOLINE_STUFF_LINE);
-	err |= __put_user(0x24020000 + __NR_sigreturn, frame->sf_code + 0);
-	err |= __put_user(0x0000000c                 , frame->sf_code + 1);
-	flush_cache_sigtramp((unsigned long) frame->sf_code);
+	install_sigtramp(frame->sf_code, __NR_sigreturn);
 
 	err |= setup_sigcontext(regs, &frame->sf_sc);
 	err |= __copy_to_user(&frame->sf_mask, set, sizeof(*set));
@@ -309,14 +317,15 @@
 	       current->comm, current->pid,
 	       frame, regs->cp0_epc, frame->regs[31]);
 #endif
-        return;
+        return 1;
 
 give_sigsegv:
 	force_sigsegv(signr, current);
+	return 0;
 }
 #endif
 
-static void inline setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
+int setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
 	int signr, sigset_t *set, siginfo_t *info)
 {
 	struct rt_sigframe *frame;
@@ -326,17 +335,7 @@
 	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
 		goto give_sigsegv;
 
-	/*
-	 * Set up the return code ...
-	 *
-	 *         li      v0, __NR_rt_sigreturn
-	 *         syscall
-	 */
-	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		__clear_user(frame->rs_code, PLAT_TRAMPOLINE_STUFF_LINE);
-	err |= __put_user(0x24020000 + __NR_rt_sigreturn, frame->rs_code + 0);
-	err |= __put_user(0x0000000c                    , frame->rs_code + 1);
-	flush_cache_sigtramp((unsigned long) frame->rs_code);
+	install_sigtramp(frame->rs_code, __NR_rt_sigreturn);
 
 	/* Create siginfo.  */
 	err |= copy_siginfo_to_user(&frame->rs_info, info);
@@ -378,18 +377,21 @@
 	       current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 #endif
-	return;
+	return 1;
 
 give_sigsegv:
 	force_sigsegv(signr, current);
+	return 0;
 }
 
 extern void setup_rt_frame_n32(struct k_sigaction * ka,
 	struct pt_regs *regs, int signr, sigset_t *set, siginfo_t *info);
 
-static inline void handle_signal(unsigned long sig, siginfo_t *info,
+static inline int handle_signal(unsigned long sig, siginfo_t *info,
 	struct k_sigaction *ka, sigset_t *oldset, struct pt_regs *regs)
 {
+	int ret;
+
 	switch(regs->regs[0]) {
 	case ERESTART_RESTARTBLOCK:
 	case ERESTARTNOHAND:
@@ -408,22 +410,10 @@
 
 	regs->regs[0] = 0;		/* Don't deal with this again.  */
 
-#ifdef CONFIG_TRAD_SIGNALS
-	if (ka->sa.sa_flags & SA_SIGINFO) {
-#else
-	if (1) {
-#endif
-#ifdef CONFIG_MIPS32_N32
-		if ((current->thread.mflags & MF_ABI_MASK) == MF_N32)
-			setup_rt_frame_n32 (ka, regs, sig, oldset, info);
-		else
-#endif
-			setup_rt_frame(ka, regs, sig, oldset, info);
-	}
-#ifdef CONFIG_TRAD_SIGNALS
+	if (sig_uses_siginfo(ka))
+		ret = current->thread.abi->setup_rt_frame(ka, regs, sig, oldset, info);
 	else
-		setup_frame(ka, regs, sig, oldset);
-#endif
+		ret = current->thread.abi->setup_frame(ka, regs, sig, oldset);
 
 	spin_lock_irq(&current->sighand->siglock);
 	sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
@@ -431,23 +421,16 @@
 		sigaddset(&current->blocked,sig);
 	recalc_sigpending();
 	spin_unlock_irq(&current->sighand->siglock);
-}
 
-extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
-extern int do_irix_signal(sigset_t *oldset, struct pt_regs *regs);
+	return ret;
+}
 
-static int do_signal(sigset_t *oldset, struct pt_regs *regs)
+int do_signal(sigset_t *oldset, struct pt_regs *regs)
 {
 	struct k_sigaction ka;
 	siginfo_t info;
 	int signr;
 
-#ifdef CONFIG_BINFMT_ELF32
-	if ((current->thread.mflags & MF_ABI_MASK) == MF_O32) {
-		return do_signal32(oldset, regs);
-	}
-#endif
-
 	/*
 	 * We want the common case to go fast, which is why we may in certain
 	 * cases get here from kernel mode. Just return without doing anything
@@ -463,10 +446,8 @@
 		oldset = &current->blocked;
 
 	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
-	if (signr > 0) {
-		handle_signal(signr, &info, &ka, oldset, regs);
-		return 1;
-	}
+	if (signr > 0)
+		return handle_signal(signr, &info, &ka, oldset, regs);
 
 no_signal:
 	/*
@@ -499,18 +480,6 @@
 {
 	/* deal with pending signal delivery */
 	if (thread_info_flags & _TIF_SIGPENDING) {
-#ifdef CONFIG_BINFMT_ELF32
-		if (likely((current->thread.mflags & MF_ABI_MASK) == MF_O32)) {
-			do_signal32(oldset, regs);
-			return;
-		}
-#endif
-#ifdef CONFIG_BINFMT_IRIX
-		if (unlikely(current->personality != PER_LINUX)) {
-			do_irix_signal(oldset, regs);
-			return;
-		}
-#endif
-		do_signal(oldset, regs);
+		current->thread.abi->do_signal(oldset, regs);
 	}
 }
diff -Naur linux-2.6.14/arch/mips/kernel/signal-common.h linux-mips-2.6.14.orig/arch/mips/kernel/signal-common.h
--- linux-2.6.14/arch/mips/kernel/signal-common.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/signal-common.h	2005-11-17 11:42:22.000000000 -0800
@@ -8,13 +8,14 @@
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  */
 
+#include <linux/config.h>
+
 static inline int
 setup_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
 {
 	int err = 0;
 
 	err |= __put_user(regs->cp0_epc, &sc->sc_pc);
-	err |= __put_user(regs->cp0_status, &sc->sc_status);
 
 #define save_gp_reg(i) do {						\
 	err |= __put_user(regs->regs[i], &sc->sc_regs[i]);		\
@@ -30,10 +31,32 @@
 	save_gp_reg(31);
 #undef save_gp_reg
 
+#ifdef CONFIG_32BIT
 	err |= __put_user(regs->hi, &sc->sc_mdhi);
 	err |= __put_user(regs->lo, &sc->sc_mdlo);
-	err |= __put_user(regs->cp0_cause, &sc->sc_cause);
-	err |= __put_user(regs->cp0_badvaddr, &sc->sc_badvaddr);
+	if (cpu_has_dsp) {
+		err |= __put_user(mfhi1(), &sc->sc_hi1);
+		err |= __put_user(mflo1(), &sc->sc_lo1);
+		err |= __put_user(mfhi2(), &sc->sc_hi2);
+		err |= __put_user(mflo2(), &sc->sc_lo2);
+		err |= __put_user(mfhi3(), &sc->sc_hi3);
+		err |= __put_user(mflo3(), &sc->sc_lo3);
+		err |= __put_user(rddsp(DSP_MASK), &sc->sc_dsp);
+	}
+#endif
+#ifdef CONFIG_64BIT
+	err |= __put_user(regs->hi, &sc->sc_hi[0]);
+	err |= __put_user(regs->lo, &sc->sc_lo[0]);
+	if (cpu_has_dsp) {
+		err |= __put_user(mfhi1(), &sc->sc_hi[1]);
+		err |= __put_user(mflo1(), &sc->sc_lo[1]);
+		err |= __put_user(mfhi2(), &sc->sc_hi[2]);
+		err |= __put_user(mflo2(), &sc->sc_lo[2]);
+		err |= __put_user(mfhi3(), &sc->sc_hi[3]);
+		err |= __put_user(mflo3(), &sc->sc_lo[3]);
+		err |= __put_user(rddsp(DSP_MASK), &sc->sc_dsp);
+	}
+#endif
 
 	err |= __put_user(!!used_math(), &sc->sc_used_math);
 
@@ -61,15 +84,40 @@
 static inline int
 restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
 {
-	int err = 0;
 	unsigned int used_math;
+	unsigned long treg;
+	int err = 0;
 
 	/* Always make any pending restarted system calls return -EINTR */
 	current_thread_info()->restart_block.fn = do_no_restart_syscall;
 
 	err |= __get_user(regs->cp0_epc, &sc->sc_pc);
+#ifdef CONFIG_32BIT
 	err |= __get_user(regs->hi, &sc->sc_mdhi);
 	err |= __get_user(regs->lo, &sc->sc_mdlo);
+	if (cpu_has_dsp) {
+		err |= __get_user(treg, &sc->sc_hi1); mthi1(treg);
+		err |= __get_user(treg, &sc->sc_lo1); mtlo1(treg);
+		err |= __get_user(treg, &sc->sc_hi2); mthi2(treg);
+		err |= __get_user(treg, &sc->sc_lo2); mtlo2(treg);
+		err |= __get_user(treg, &sc->sc_hi3); mthi3(treg);
+		err |= __get_user(treg, &sc->sc_lo3); mtlo3(treg);
+		err |= __get_user(treg, &sc->sc_dsp); wrdsp(treg, DSP_MASK);
+	}
+#endif
+#ifdef CONFIG_64BIT
+	err |= __get_user(regs->hi, &sc->sc_hi[0]);
+	err |= __get_user(regs->lo, &sc->sc_lo[0]);
+	if (cpu_has_dsp) {
+		err |= __get_user(treg, &sc->sc_hi[1]); mthi1(treg);
+		err |= __get_user(treg, &sc->sc_lo[1]); mthi1(treg);
+		err |= __get_user(treg, &sc->sc_hi[2]); mthi2(treg);
+		err |= __get_user(treg, &sc->sc_lo[2]); mthi2(treg);
+		err |= __get_user(treg, &sc->sc_hi[3]); mthi3(treg);
+		err |= __get_user(treg, &sc->sc_lo[3]); mthi3(treg);
+		err |= __get_user(treg, &sc->sc_dsp); wrdsp(treg, DSP_MASK);
+	}
+#endif
 
 #define restore_gp_reg(i) do {						\
 	err |= __get_user(regs->regs[i], &sc->sc_regs[i]);		\
@@ -112,7 +160,7 @@
 static inline void *
 get_sigframe(struct k_sigaction *ka, struct pt_regs *regs, size_t frame_size)
 {
-	unsigned long sp, almask;
+	unsigned long sp;
 
 	/* Default to using normal stack */
 	sp = regs->regs[29];
@@ -128,10 +176,32 @@
 	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
 		sp = current->sas_ss_sp + current->sas_ss_size;
 
-	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		almask = ~(PLAT_TRAMPOLINE_STUFF_LINE - 1);
-	else
-		almask = ALMASK;
+	return (void *)((sp - frame_size) & (ICACHE_REFILLS_WORKAROUND_WAR ? 32 : ALMASK));
+}
+
+static inline int install_sigtramp(unsigned int __user *tramp,
+	unsigned int syscall)
+{
+	int err;
+
+	/*
+	 * Set up the return code ...
+	 *
+	 *         li      v0, __NR__foo_sigreturn
+	 *         syscall
+	 */
+
+	err = __put_user(0x24020000 + syscall, tramp + 0);
+	err |= __put_user(0x0000000c          , tramp + 1);
+	if (ICACHE_REFILLS_WORKAROUND_WAR) {
+		err |= __put_user(0, tramp + 2);
+		err |= __put_user(0, tramp + 3);
+		err |= __put_user(0, tramp + 4);
+		err |= __put_user(0, tramp + 5);
+		err |= __put_user(0, tramp + 6);
+		err |= __put_user(0, tramp + 7);
+	}
+	flush_cache_sigtramp((unsigned long) tramp);
 
-	return (void *)((sp - frame_size) & almask);
+	return err;
 }
diff -Naur linux-2.6.14/arch/mips/kernel/signal_n32.c linux-mips-2.6.14.orig/arch/mips/kernel/signal_n32.c
--- linux-2.6.14/arch/mips/kernel/signal_n32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/signal_n32.c	2005-11-17 11:42:22.000000000 -0800
@@ -15,6 +15,8 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
+#include <linux/cache.h>
+#include <linux/sched.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -36,6 +38,7 @@
 #include <asm/system.h>
 #include <asm/fpu.h>
 #include <asm/cpu-features.h>
+#include <asm/war.h>
 
 #include "signal-common.h"
 
@@ -62,17 +65,18 @@
 	sigset_t            uc_sigmask;   /* mask last for extensibility */
 };
 
-#if PLAT_TRAMPOLINE_STUFF_LINE
-#define __tramp __attribute__((aligned(PLAT_TRAMPOLINE_STUFF_LINE)))
-#else
-#define __tramp
-#endif
-
 struct rt_sigframe_n32 {
 	u32 rs_ass[4];			/* argument save space for o32 */
-	u32 rs_code[2] __tramp;		/* signal trampoline */
-	struct siginfo rs_info __tramp;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 rs_pad[2];
+#else
+	u32 rs_code[2];			/* signal trampoline */
+#endif
+	struct siginfo rs_info;
 	struct ucontextn32 rs_uc;
+#if ICACHE_REFILLS_WORKAROUND_WAR
+	u32 rs_code[8] ____cacheline_aligned;		/* signal trampoline */
+#endif
 };
 
 save_static_function(sysn32_rt_sigreturn);
@@ -126,7 +130,7 @@
 	force_sig(SIGSEGV, current);
 }
 
-void setup_rt_frame_n32(struct k_sigaction * ka,
+int setup_rt_frame_n32(struct k_sigaction * ka,
 	struct pt_regs *regs, int signr, sigset_t *set, siginfo_t *info)
 {
 	struct rt_sigframe_n32 *frame;
@@ -137,17 +141,7 @@
 	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
 		goto give_sigsegv;
 
-	/*
-	 * Set up the return code ...
-	 *
-	 *         li      v0, __NR_rt_sigreturn
-	 *         syscall
-	 */
-	if (PLAT_TRAMPOLINE_STUFF_LINE)
-		__clear_user(frame->rs_code, PLAT_TRAMPOLINE_STUFF_LINE);
-	err |= __put_user(0x24020000 + __NR_N32_rt_sigreturn, frame->rs_code + 0);
-	err |= __put_user(0x0000000c                        , frame->rs_code + 1);
-	flush_cache_sigtramp((unsigned long) frame->rs_code);
+	install_sigtramp(frame->rs_code, __NR_N32_rt_sigreturn);
 
 	/* Create siginfo.  */
 	err |= copy_siginfo_to_user(&frame->rs_info, info);
@@ -190,8 +184,9 @@
 	       current->comm, current->pid,
 	       frame, regs->cp0_epc, regs->regs[31]);
 #endif
-	return;
+	return 1;
 
 give_sigsegv:
 	force_sigsegv(signr, current);
+	return 0;
 }
diff -Naur linux-2.6.14/arch/mips/kernel/smp.c linux-mips-2.6.14.orig/arch/mips/kernel/smp.c
--- linux-2.6.14/arch/mips/kernel/smp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/smp.c	2005-11-17 11:42:22.000000000 -0800
@@ -50,7 +50,6 @@
 {
 	struct cache_desc *cd = &current_cpu_data.scache;
 	unsigned long cachesize;       /* kB   */
-	unsigned long bandwidth = 350; /* MB/s */
 	unsigned long cpu_khz;
 
 	/*
@@ -121,7 +120,19 @@
  * or are or have executed.
  *
  * You must not call this function with disabled interrupts or from a
- * hardware interrupt handler or from a bottom half handler.
+ * hardware interrupt handler or from a bottom half handler:
+ *
+ * CPU A                               CPU B
+ * Disable interrupts
+ *                                     smp_call_function()
+ *                                     Take call_lock
+ *                                     Send IPIs
+ *                                     Wait for all cpus to acknowledge IPI
+ *                                     CPU A has not responded, spin waiting
+ *                                     for cpu A to respond, holding call_lock
+ * smp_call_function()
+ * Spin waiting for call_lock
+ * Deadlock                            Deadlock
  */
 int smp_call_function (void (*func) (void *info), void *info, int retry,
 								int wait)
@@ -130,6 +141,11 @@
 	int i, cpus = num_online_cpus() - 1;
 	int cpu = smp_processor_id();
 
+	/*
+	 * Can die spectacularly if this CPU isn't yet marked online
+	 */
+	BUG_ON(!cpu_online(cpu));
+
 	if (!cpus)
 		return 0;
 
@@ -214,7 +230,6 @@
 /* called from main before smp_init() */
 void __init smp_prepare_cpus(unsigned int max_cpus)
 {
-	cpu_data[0].udelay_val = loops_per_jiffy;
 	init_new_context(current, &init_mm);
 	current_thread_info()->cpu = 0;
 	smp_tune_scheduling();
@@ -236,23 +251,28 @@
 }
 
 /*
- * Startup the CPU with this logical number
+ * Called once for each "cpu_possible(cpu)".  Needs to spin up the cpu
+ * and keep control until "cpu_online(cpu)" is set.  Note: cpu is
+ * physical, not logical.
  */
-static int __init do_boot_cpu(int cpu)
+int __devinit __cpu_up(unsigned int cpu)
 {
 	struct task_struct *idle;
 
 	/*
+	 * Processor goes to start_secondary(), sets online flag
 	 * The following code is purely to make sure
 	 * Linux can schedule processes on this slave.
 	 */
 	idle = fork_idle(cpu);
 	if (IS_ERR(idle))
-		panic("failed fork for CPU %d\n", cpu);
+		panic(KERN_ERR "Fork failed for CPU %d", cpu);
 
 	prom_boot_secondary(cpu, idle);
 
-	/* XXXKW timeout */
+	/*
+	 * Trust is futile.  We should really have timeouts ...
+	 */
 	while (!cpu_isset(cpu, cpu_callin_map))
 		udelay(100);
 
@@ -261,23 +281,6 @@
 	return 0;
 }
 
-/*
- * Called once for each "cpu_possible(cpu)".  Needs to spin up the cpu
- * and keep control until "cpu_online(cpu)" is set.  Note: cpu is
- * physical, not logical.
- */
-int __devinit __cpu_up(unsigned int cpu)
-{
-	int ret;
-
-	/* Processor goes to start_secondary(), sets online flag */
-	ret = do_boot_cpu(cpu);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
 /* Not really SMP stuff ... */
 int setup_profiling_timer(unsigned int multiplier)
 {
diff -Naur linux-2.6.14/arch/mips/kernel/smp_mt.c linux-mips-2.6.14.orig/arch/mips/kernel/smp_mt.c
--- linux-2.6.14/arch/mips/kernel/smp_mt.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/kernel/smp_mt.c	2005-11-17 11:42:22.000000000 -0800
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2004, 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  Elizabeth Clarke (beth@mips.com)
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cpumask.h>
+#include <linux/interrupt.h>
+#include <linux/compiler.h>
+
+#include <asm/atomic.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/hardirq.h>
+#include <asm/mmu_context.h>
+#include <asm/smp.h>
+#include <asm/time.h>
+#include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
+#include <asm/cacheflush.h>
+#include <asm/mips-boards/maltaint.h>
+
+#define MIPS_CPU_IPI_RESCHED_IRQ 0
+#define MIPS_CPU_IPI_CALL_IRQ 1
+
+static int cpu_ipi_resched_irq, cpu_ipi_call_irq;
+
+#if 0
+static void dump_mtregisters(int vpe, int tc)
+{
+	printk("vpe %d tc %d\n", vpe, tc);
+
+	settc(tc);
+
+	printk("  c0 status  0x%lx\n", read_vpe_c0_status());
+	printk("  vpecontrol 0x%lx\n", read_vpe_c0_vpecontrol());
+	printk("  vpeconf0    0x%lx\n", read_vpe_c0_vpeconf0());
+	printk("  tcstatus 0x%lx\n", read_tc_c0_tcstatus());
+	printk("  tcrestart 0x%lx\n", read_tc_c0_tcrestart());
+	printk("  tcbind 0x%lx\n", read_tc_c0_tcbind());
+	printk("  tchalt 0x%lx\n", read_tc_c0_tchalt());
+}
+#endif
+
+void __init sanitize_tlb_entries(void)
+{
+	int i, tlbsiz;
+	unsigned long mvpconf0, ncpu;
+
+	if (!cpu_has_mipsmt)
+		return;
+
+	set_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	/* Disable TLB sharing */
+	clear_c0_mvpcontrol(MVPCONTROL_STLB);
+
+	mvpconf0 = read_c0_mvpconf0();
+
+	printk(KERN_INFO "MVPConf0 0x%lx TLBS %lx PTLBE %ld\n", mvpconf0,
+		   (mvpconf0 & MVPCONF0_TLBS) >> MVPCONF0_TLBS_SHIFT,
+			   (mvpconf0 & MVPCONF0_PTLBE) >> MVPCONF0_PTLBE_SHIFT);
+
+	tlbsiz = (mvpconf0 & MVPCONF0_PTLBE) >> MVPCONF0_PTLBE_SHIFT;
+	ncpu = ((mvpconf0 & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1;
+
+	printk(" tlbsiz %d ncpu %ld\n", tlbsiz, ncpu);
+
+	if (tlbsiz > 0) {
+		/* share them out across the vpe's */
+		tlbsiz /= ncpu;
+
+		printk(KERN_INFO "setting Config1.MMU_size to %d\n", tlbsiz);
+
+		for (i = 0; i < ncpu; i++) {
+			settc(i);
+
+			if (i == 0)
+				write_c0_config1((read_c0_config1() & ~(0x3f << 25)) | (tlbsiz << 25));
+			else
+				write_vpe_c0_config1((read_vpe_c0_config1() & ~(0x3f << 25)) |
+						   (tlbsiz << 25));
+		}
+	}
+
+	clear_c0_mvpcontrol(MVPCONTROL_VPC);
+}
+
+#if 0
+/*
+ * Use c0_MVPConf0 to find out how many CPUs are available, setting up
+ * phys_cpu_present_map and the logical/physical mappings.
+ */
+void __init prom_build_cpu_map(void)
+{
+	int i, num, ncpus;
+
+	cpus_clear(phys_cpu_present_map);
+
+	/* assume we boot on cpu 0.... */
+	cpu_set(0, phys_cpu_present_map);
+	__cpu_number_map[0] = 0;
+	__cpu_logical_map[0] = 0;
+
+	if (cpu_has_mipsmt) {
+		ncpus = ((read_c0_mvpconf0() & (MVPCONF0_PVPE)) >> MVPCONF0_PVPE_SHIFT) + 1;
+		for (i=1, num=0; i< NR_CPUS && i<ncpus; i++) {
+			cpu_set(i, phys_cpu_present_map);
+			__cpu_number_map[i] = ++num;
+			__cpu_logical_map[num] = i;
+		}
+
+		printk(KERN_INFO "%i available secondary CPU(s)\n", num);
+	}
+}
+#endif
+
+static void ipi_resched_dispatch (struct pt_regs *regs)
+{
+	do_IRQ(MIPS_CPU_IPI_RESCHED_IRQ, regs);
+}
+
+static void ipi_call_dispatch (struct pt_regs *regs)
+{
+	do_IRQ(MIPS_CPU_IPI_CALL_IRQ, regs);
+}
+
+irqreturn_t ipi_resched_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+irqreturn_t ipi_call_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	smp_call_function_interrupt();
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction irq_resched = {
+	.handler	= ipi_resched_interrupt,
+	.flags		= SA_INTERRUPT,
+	.name		= "IPI_resched"
+};
+
+static struct irqaction irq_call = {
+	.handler	= ipi_call_interrupt,
+	.flags		= SA_INTERRUPT,
+	.name		= "IPI_call"
+};
+
+/*
+ * Common setup before any secondaries are started
+ * Make sure all CPU's are in a sensible state before we boot any of the
+ * secondarys
+ */
+void prom_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned long val;
+	int i, num;
+
+	if (!cpu_has_mipsmt)
+		return;
+
+	/* disable MT so we can configure */
+	dvpe();
+	dmt();
+
+	/* Put MVPE's into 'configuration state' */
+	set_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	val = read_c0_mvpconf0();
+
+	/* we'll always have more TC's than VPE's, so loop setting everything
+	   to a sensible state */
+	for (i = 0, num = 0; i <= ((val & MVPCONF0_PTC) >> MVPCONF0_PTC_SHIFT); i++) {
+		settc(i);
+
+		/* VPE's */
+		if (i <= ((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT)) {
+
+			/* deactivate all but vpe0 */
+			if (i != 0) {
+				unsigned long tmp = read_vpe_c0_vpeconf0();
+
+				tmp &= ~VPECONF0_VPA;
+
+				/* master VPE */
+				tmp |= VPECONF0_MVP;
+				write_vpe_c0_vpeconf0(tmp);
+
+				/* Record this as available CPU */
+				if (i < max_cpus) {
+					cpu_set(i, phys_cpu_present_map);
+					__cpu_number_map[i]	= ++num;
+					__cpu_logical_map[num]	= i;
+				}
+			}
+
+			/* disable multi-threading with TC's */
+			write_vpe_c0_vpecontrol(read_vpe_c0_vpecontrol() & ~VPECONTROL_TE);
+
+			if (i != 0) {
+				write_vpe_c0_status((read_c0_status() & ~(ST0_IM | ST0_IE | ST0_KSU)) | ST0_CU0);
+				write_vpe_c0_cause(read_vpe_c0_cause() & ~CAUSEF_IP);
+
+				/* set config to be the same as vpe0, particularly kseg0 coherency alg */
+				write_vpe_c0_config( read_c0_config());
+			}
+
+		}
+
+		/* TC's */
+
+		if (i != 0) {
+			unsigned long tmp;
+
+			/* bind a TC to each VPE, May as well put all excess TC's
+			   on the last VPE */
+			if ( i >= (((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT)+1) )
+				write_tc_c0_tcbind(read_tc_c0_tcbind() | ((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) );
+			else {
+				write_tc_c0_tcbind( read_tc_c0_tcbind() | i);
+
+				/* and set XTC */
+				write_vpe_c0_vpeconf0( read_vpe_c0_vpeconf0() | (i << VPECONF0_XTC_SHIFT));
+			}
+
+			tmp = read_tc_c0_tcstatus();
+
+			/* mark not allocated and not dynamically allocatable */
+			tmp &= ~(TCSTATUS_A | TCSTATUS_DA);
+			tmp |= TCSTATUS_IXMT;		/* interrupt exempt */
+			write_tc_c0_tcstatus(tmp);
+
+			write_tc_c0_tchalt(TCHALT_H);
+		}
+	}
+
+	/* Release config state */
+	clear_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	/* We'll wait until starting the secondaries before starting MVPE */
+
+	printk(KERN_INFO "Detected %i available secondary CPU(s)\n", num);
+
+	/* set up ipi interrupts */
+	if (cpu_has_vint) {
+		set_vi_handler (MIPS_CPU_IPI_RESCHED_IRQ, ipi_resched_dispatch);
+		set_vi_handler (MIPS_CPU_IPI_CALL_IRQ, ipi_call_dispatch);
+	}
+
+	cpu_ipi_resched_irq = MIPSCPU_INT_BASE + MIPS_CPU_IPI_RESCHED_IRQ;
+	cpu_ipi_call_irq = MIPSCPU_INT_BASE + MIPS_CPU_IPI_CALL_IRQ;
+
+	setup_irq(cpu_ipi_resched_irq, &irq_resched);
+	setup_irq(cpu_ipi_call_irq, &irq_call);
+
+	/* need to mark IPI's as IRQ_PER_CPU */
+	irq_desc[cpu_ipi_resched_irq].status |= IRQ_PER_CPU;
+	irq_desc[cpu_ipi_call_irq].status |= IRQ_PER_CPU;
+}
+
+/*
+ * Setup the PC, SP, and GP of a secondary processor and start it
+ * running!
+ * smp_bootstrap is the place to resume from
+ * __KSTK_TOS(idle) is apparently the stack pointer
+ * (unsigned long)idle->thread_info the gp
+ * assumes a 1:1 mapping of TC => VPE
+ */
+void prom_boot_secondary(int cpu, struct task_struct *idle)
+{
+	dvpe();
+	set_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	settc(cpu);
+
+	/* restart */
+	write_tc_c0_tcrestart((unsigned long)&smp_bootstrap);
+
+	/* enable the tc this vpe/cpu will be running */
+	write_tc_c0_tcstatus((read_tc_c0_tcstatus() & ~TCSTATUS_IXMT) | TCSTATUS_A);
+
+	write_tc_c0_tchalt(0);
+
+	/* enable the VPE */
+	write_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() | VPECONF0_VPA);
+
+	/* stack pointer */
+	write_tc_gpr_sp( __KSTK_TOS(idle));
+
+	/* global pointer */
+	write_tc_gpr_gp((unsigned long)idle->thread_info);
+
+	flush_icache_range((unsigned long)idle->thread_info,
+					   (unsigned long)idle->thread_info +
+					   sizeof(struct thread_info));
+
+	/* finally out of configuration and into chaos */
+	clear_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	evpe(EVPE_ENABLE);
+}
+
+void prom_init_secondary(void)
+{
+	write_c0_status((read_c0_status() & ~ST0_IM ) |
+	                (STATUSF_IP0 | STATUSF_IP1 | STATUSF_IP7));
+}
+
+void prom_smp_finish(void)
+{
+	write_c0_compare(read_c0_count() + (8* mips_hpt_frequency/HZ));
+
+	local_irq_enable();
+}
+
+void prom_cpus_done(void)
+{
+}
+
+void core_send_ipi(int cpu, unsigned int action)
+{
+	int i;
+	unsigned long flags;
+	int vpflags;
+
+	local_irq_save (flags);
+
+	vpflags = dvpe();	/* cant access the other CPU's registers whilst MVPE enabled */
+
+	switch (action) {
+	case SMP_CALL_FUNCTION:
+		i = C_SW1;
+		break;
+
+	case SMP_RESCHEDULE_YOURSELF:
+	default:
+		i = C_SW0;
+		break;
+	}
+
+	/* 1:1 mapping of vpe and tc... */
+	settc(cpu);
+	write_vpe_c0_cause(read_vpe_c0_cause() | i);
+	evpe(vpflags);
+
+	local_irq_restore(flags);
+}
diff -Naur linux-2.6.14/arch/mips/kernel/syscall.c linux-mips-2.6.14.orig/arch/mips/kernel/syscall.c
--- linux-2.6.14/arch/mips/kernel/syscall.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/syscall.c	2005-11-17 11:42:22.000000000 -0800
@@ -7,6 +7,7 @@
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2001 MIPS Technologies, Inc.
  */
+#include <linux/config.h>
 #include <linux/a.out.h>
 #include <linux/errno.h>
 #include <linux/linkage.h>
@@ -26,6 +27,7 @@
 #include <linux/msg.h>
 #include <linux/shm.h>
 #include <linux/compiler.h>
+#include <linux/module.h>
 
 #include <asm/branch.h>
 #include <asm/cachectl.h>
@@ -56,6 +58,8 @@
 
 unsigned long shm_align_mask = PAGE_SIZE - 1;	/* Sane caches */
 
+EXPORT_SYMBOL(shm_align_mask);
+
 #define COLOUR_ALIGN(addr,pgoff)				\
 	((((addr) + shm_align_mask) & ~shm_align_mask) +	\
 	 (((pgoff) << PAGE_SHIFT) & shm_align_mask))
@@ -173,14 +177,28 @@
 {
 	unsigned long clone_flags;
 	unsigned long newsp;
-	int *parent_tidptr, *child_tidptr;
+	int __user *parent_tidptr, *child_tidptr;
 
 	clone_flags = regs.regs[4];
 	newsp = regs.regs[5];
 	if (!newsp)
 		newsp = regs.regs[29];
-	parent_tidptr = (int *) regs.regs[6];
-	child_tidptr = (int *) regs.regs[7];
+	parent_tidptr = (int __user *) regs.regs[6];
+#ifdef CONFIG_32BIT
+	/* We need to fetch the fifth argument off the stack.  */
+	child_tidptr = NULL;
+	if (clone_flags & (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID)) {
+		int __user *__user *usp = (int __user *__user *) regs.regs[29];
+		if (regs.regs[2] == __NR_syscall) {
+			if (get_user (child_tidptr, &usp[5]))
+				return -EFAULT;
+		}
+		else if (get_user (child_tidptr, &usp[4]))
+			return -EFAULT;
+	}
+#else
+	child_tidptr = (int __user *) regs.regs[8];
+#endif
 	return do_fork(clone_flags, newsp, &regs, 0,
 	               parent_tidptr, child_tidptr);
 }
@@ -242,6 +260,16 @@
 	return error;
 }
 
+void sys_set_thread_area(unsigned long addr)
+{
+	struct thread_info *ti = current->thread_info;
+
+	ti->tp_value = addr;
+
+	/* If some future MIPS implementation has this register in hardware,
+	 * we will need to update it here (and in context switches).  */
+}
+
 asmlinkage int _sys_sysmips(int cmd, long arg1, int arg2, int arg3)
 {
 	int	tmp, len;
diff -Naur linux-2.6.14/arch/mips/kernel/sysirix.c linux-mips-2.6.14.orig/arch/mips/kernel/sysirix.c
--- linux-2.6.14/arch/mips/kernel/sysirix.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/sysirix.c	2005-11-17 11:42:23.000000000 -0800
@@ -73,32 +73,30 @@
 }
 
 /* The prctl commands. */
-#define PR_MAXPROCS          1 /* Tasks/user. */
-#define PR_ISBLOCKED         2 /* If blocked, return 1. */
-#define PR_SETSTACKSIZE      3 /* Set largest task stack size. */
-#define PR_GETSTACKSIZE      4 /* Get largest task stack size. */
-#define PR_MAXPPROCS         5 /* Num parallel tasks. */
-#define PR_UNBLKONEXEC       6 /* When task exec/exit's, unblock. */
-#define PR_SETEXITSIG        8 /* When task exit's, set signal. */
-#define PR_RESIDENT          9 /* Make task unswappable. */
-#define PR_ATTACHADDR       10 /* (Re-)Connect a vma to a task. */
-#define PR_DETACHADDR       11 /* Disconnect a vma from a task. */
-#define PR_TERMCHILD        12 /* When parent sleeps with fishes, kill child. */
-#define PR_GETSHMASK        13 /* Get the sproc() share mask. */
-#define PR_GETNSHARE        14 /* Number of share group members. */
-#define PR_COREPID          15 /* Add task pid to name when it core. */
-#define	PR_ATTACHADDRPERM   16 /* (Re-)Connect vma, with specified prot. */
-#define PR_PTHREADEXIT      17 /* Kill a pthread without prejudice. */
+#define PR_MAXPROCS		 1 /* Tasks/user. */
+#define PR_ISBLOCKED		 2 /* If blocked, return 1. */
+#define PR_SETSTACKSIZE		 3 /* Set largest task stack size. */
+#define PR_GETSTACKSIZE		 4 /* Get largest task stack size. */
+#define PR_MAXPPROCS		 5 /* Num parallel tasks. */
+#define PR_UNBLKONEXEC		 6 /* When task exec/exit's, unblock. */
+#define PR_SETEXITSIG		 8 /* When task exit's, set signal. */
+#define PR_RESIDENT		 9 /* Make task unswappable. */
+#define PR_ATTACHADDR		10 /* (Re-)Connect a vma to a task. */
+#define PR_DETACHADDR		11 /* Disconnect a vma from a task. */
+#define PR_TERMCHILD		12 /* Kill child if the parent dies. */
+#define PR_GETSHMASK		13 /* Get the sproc() share mask. */
+#define PR_GETNSHARE		14 /* Number of share group members. */
+#define PR_COREPID		15 /* Add task pid to name when it core. */
+#define PR_ATTACHADDRPERM	16 /* (Re-)Connect vma, with specified prot. */
+#define PR_PTHREADEXIT		17 /* Kill a pthread, only for IRIX 6.[234] */
 
-asmlinkage int irix_prctl(struct pt_regs *regs)
+asmlinkage int irix_prctl(unsigned option, ...)
 {
-	unsigned long cmd;
-	int error = 0, base = 0;
+	va_list args;
+	int error = 0;
 
-	if (regs->regs[2] == 1000)
-		base = 1;
-	cmd = regs->regs[base + 4];
-	switch (cmd) {
+	va_start(args, option);
+	switch (option) {
 	case PR_MAXPROCS:
 		printk("irix_prctl[%s:%d]: Wants PR_MAXPROCS\n",
 		       current->comm, current->pid);
@@ -111,7 +109,7 @@
 		printk("irix_prctl[%s:%d]: Wants PR_ISBLOCKED\n",
 		       current->comm, current->pid);
 		read_lock(&tasklist_lock);
-		task = find_task_by_pid(regs->regs[base + 5]);
+		task = find_task_by_pid(va_arg(args, pid_t));
 		error = -ESRCH;
 		if (error)
 			error = (task->run_list.next != NULL);
@@ -121,7 +119,7 @@
 	}
 
 	case PR_SETSTACKSIZE: {
-		long value = regs->regs[base + 5];
+		long value = va_arg(args, long);
 
 		printk("irix_prctl[%s:%d]: Wants PR_SETSTACKSIZE<%08lx>\n",
 		       current->comm, current->pid, (unsigned long) value);
@@ -222,24 +220,20 @@
 		error = -EINVAL;
 		break;
 
-	case PR_PTHREADEXIT:
-		printk("irix_prctl[%s:%d]: Wants PR_PTHREADEXIT\n",
-		       current->comm, current->pid);
-		do_exit(regs->regs[base + 5]);
-
 	default:
 		printk("irix_prctl[%s:%d]: Non-existant opcode %d\n",
-		       current->comm, current->pid, (int)cmd);
+		       current->comm, current->pid, option);
 		error = -EINVAL;
 		break;
 	}
+	va_end(args);
 
 	return error;
 }
 
 #undef DEBUG_PROCGRPS
 
-extern unsigned long irix_mapelf(int fd, struct elf_phdr *user_phdrp, int cnt);
+extern unsigned long irix_mapelf(int fd, struct elf_phdr __user *user_phdrp, int cnt);
 extern int getrusage(struct task_struct *p, int who, struct rusage __user *ru);
 extern char *prom_getenv(char *name);
 extern long prom_setenv(char *name, char *value);
@@ -276,23 +270,19 @@
 	cmd = regs->regs[base + 4];
 	switch(cmd) {
 	case SGI_SYSID: {
-		char *buf = (char *) regs->regs[base + 5];
+		char __user *buf = (char __user *) regs->regs[base + 5];
 
 		/* XXX Use ethernet addr.... */
-		retval = clear_user(buf, 64);
+		retval = clear_user(buf, 64) ? -EFAULT : 0;
 		break;
 	}
 #if 0
 	case SGI_RDNAME: {
 		int pid = (int) regs->regs[base + 5];
-		char *buf = (char *) regs->regs[base + 6];
+		char __user *buf = (char __user *) regs->regs[base + 6];
 		struct task_struct *p;
 		char tcomm[sizeof(current->comm)];
 
-		if (!access_ok(VERIFY_WRITE, buf, sizeof(tcomm))) {
-			retval = -EFAULT;
-			break;
-		}
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
 		if (!p) {
@@ -304,34 +294,28 @@
 		read_unlock(&tasklist_lock);
 
 		/* XXX Need to check sizes. */
-		copy_to_user(buf, tcomm, sizeof(tcomm));
-		retval = 0;
+		retval = copy_to_user(buf, tcomm, sizeof(tcomm)) ? -EFAULT : 0;
 		break;
 	}
 
 	case SGI_GETNVRAM: {
-		char *name = (char *) regs->regs[base+5];
-		char *buf = (char *) regs->regs[base+6];
+		char __user *name = (char __user *) regs->regs[base+5];
+		char __user *buf = (char __user *) regs->regs[base+6];
 		char *value;
 		return -EINVAL;	/* til I fix it */
-		if (!access_ok(VERIFY_WRITE, buf, 128)) {
-			retval = -EFAULT;
-			break;
-		}
 		value = prom_getenv(name);	/* PROM lock?  */
 		if (!value) {
 			retval = -EINVAL;
 			break;
 		}
 		/* Do I strlen() for the length? */
-		copy_to_user(buf, value, 128);
-		retval = 0;
+		retval = copy_to_user(buf, value, 128) ? -EFAULT : 0;
 		break;
 	}
 
 	case SGI_SETNVRAM: {
-		char *name = (char *) regs->regs[base+5];
-		char *value = (char *) regs->regs[base+6];
+		char __user *name = (char __user *) regs->regs[base+5];
+		char __user *value = (char __user *) regs->regs[base+6];
 		return -EINVAL;	/* til I fix it */
 		retval = prom_setenv(name, value);
 		/* XXX make sure retval conforms to syssgi(2) */
@@ -407,16 +391,16 @@
 
 	case SGI_SETGROUPS:
 		retval = sys_setgroups((int) regs->regs[base + 5],
-		                       (gid_t *) regs->regs[base + 6]);
+		                       (gid_t __user *) regs->regs[base + 6]);
 		break;
 
 	case SGI_GETGROUPS:
 		retval = sys_getgroups((int) regs->regs[base + 5],
-		                       (gid_t *) regs->regs[base + 6]);
+		                       (gid_t __user *) regs->regs[base + 6]);
 		break;
 
 	case SGI_RUSAGE: {
-		struct rusage *ru = (struct rusage *) regs->regs[base + 6];
+		struct rusage __user *ru = (struct rusage __user *) regs->regs[base + 6];
 
 		switch((int) regs->regs[base + 5]) {
 		case 0:
@@ -453,7 +437,7 @@
 
 	case SGI_ELFMAP:
 		retval = irix_mapelf((int) regs->regs[base + 5],
-				     (struct elf_phdr *) regs->regs[base + 6],
+				     (struct elf_phdr __user *) regs->regs[base + 6],
 				     (int) regs->regs[base + 7]);
 		break;
 
@@ -468,24 +452,24 @@
 
 	case SGI_PHYSP: {
 		unsigned long addr = regs->regs[base + 5];
-		int *pageno = (int *) (regs->regs[base + 6]);
+		int __user *pageno = (int __user *) (regs->regs[base + 6]);
 		struct mm_struct *mm = current->mm;
 		pgd_t *pgdp;
+		pud_t *pudp;
 		pmd_t *pmdp;
 		pte_t *ptep;
 
-		if (!access_ok(VERIFY_WRITE, pageno, sizeof(int)))
-			return -EFAULT;
-
 		down_read(&mm->mmap_sem);
 		pgdp = pgd_offset(mm, addr);
-		pmdp = pmd_offset(pgdp, addr);
+		pudp = pud_offset(pgdp, addr);
+		pmdp = pmd_offset(pudp, addr);
 		ptep = pte_offset(pmdp, addr);
 		retval = -EINVAL;
 		if (ptep) {
 			pte_t pte = *ptep;
 
 			if (pte_val(pte) & (_PAGE_VALID | _PAGE_PRESENT)) {
+				/* b0rked on 64-bit */
 				retval =  put_user((pte_val(pte) & PAGE_MASK) >>
 				                   PAGE_SHIFT, pageno);
 			}
@@ -496,7 +480,7 @@
 
 	case SGI_INVENT: {
 		int  arg1    = (int)    regs->regs [base + 5];
-		void *buffer = (void *) regs->regs [base + 6];
+		void __user *buffer = (void __user *) regs->regs [base + 6];
 		int  count   = (int)    regs->regs [base + 7];
 
 		switch (arg1) {
@@ -692,8 +676,8 @@
 }
 
 /* XXX need more than this... */
-asmlinkage int irix_mount(char *dev_name, char *dir_name, unsigned long flags,
-			  char *type, void *data, int datalen)
+asmlinkage int irix_mount(char __user *dev_name, char __user *dir_name,
+	unsigned long flags, char __user *type, void __user *data, int datalen)
 {
 	printk("[%s:%d] irix_mount(%p,%p,%08lx,%p,%p,%d)\n",
 	       current->comm, current->pid,
@@ -708,8 +692,8 @@
 	char  f_fname[6], f_fpack[6];
 };
 
-asmlinkage int irix_statfs(const char *path, struct irix_statfs *buf,
-			   int len, int fs_type)
+asmlinkage int irix_statfs(const char __user *path,
+	struct irix_statfs __user *buf, int len, int fs_type)
 {
 	struct nameidata nd;
 	struct kstatfs kbuf;
@@ -724,6 +708,7 @@
 		error = -EFAULT;
 		goto out;
 	}
+
 	error = user_path_walk(path, &nd);
 	if (error)
 		goto out;
@@ -732,18 +717,17 @@
 	if (error)
 		goto dput_and_out;
 
-	__put_user(kbuf.f_type, &buf->f_type);
-	__put_user(kbuf.f_bsize, &buf->f_bsize);
-	__put_user(kbuf.f_frsize, &buf->f_frsize);
-	__put_user(kbuf.f_blocks, &buf->f_blocks);
-	__put_user(kbuf.f_bfree, &buf->f_bfree);
-	__put_user(kbuf.f_files, &buf->f_files);
-	__put_user(kbuf.f_ffree, &buf->f_ffree);
+	error = __put_user(kbuf.f_type, &buf->f_type);
+	error |= __put_user(kbuf.f_bsize, &buf->f_bsize);
+	error |= __put_user(kbuf.f_frsize, &buf->f_frsize);
+	error |= __put_user(kbuf.f_blocks, &buf->f_blocks);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bfree);
+	error |= __put_user(kbuf.f_files, &buf->f_files);
+	error |= __put_user(kbuf.f_ffree, &buf->f_ffree);
 	for (i = 0; i < 6; i++) {
-		__put_user(0, &buf->f_fname[i]);
-		__put_user(0, &buf->f_fpack[i]);
+		error |= __put_user(0, &buf->f_fname[i]);
+		error |= __put_user(0, &buf->f_fpack[i]);
 	}
-	error = 0;
 
 dput_and_out:
 	path_release(&nd);
@@ -751,7 +735,7 @@
 	return error;
 }
 
-asmlinkage int irix_fstatfs(unsigned int fd, struct irix_statfs *buf)
+asmlinkage int irix_fstatfs(unsigned int fd, struct irix_statfs __user *buf)
 {
 	struct kstatfs kbuf;
 	struct file *file;
@@ -761,6 +745,7 @@
 		error = -EFAULT;
 		goto out;
 	}
+
 	if (!(file = fget(fd))) {
 		error = -EBADF;
 		goto out;
@@ -770,16 +755,17 @@
 	if (error)
 		goto out_f;
 
-	__put_user(kbuf.f_type, &buf->f_type);
-	__put_user(kbuf.f_bsize, &buf->f_bsize);
-	__put_user(kbuf.f_frsize, &buf->f_frsize);
-	__put_user(kbuf.f_blocks, &buf->f_blocks);
-	__put_user(kbuf.f_bfree, &buf->f_bfree);
-	__put_user(kbuf.f_files, &buf->f_files);
-	__put_user(kbuf.f_ffree, &buf->f_ffree);
-	for(i = 0; i < 6; i++) {
-		__put_user(0, &buf->f_fname[i]);
-		__put_user(0, &buf->f_fpack[i]);
+	error = __put_user(kbuf.f_type, &buf->f_type);
+	error |= __put_user(kbuf.f_bsize, &buf->f_bsize);
+	error |= __put_user(kbuf.f_frsize, &buf->f_frsize);
+	error |= __put_user(kbuf.f_blocks, &buf->f_blocks);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bfree);
+	error |= __put_user(kbuf.f_files, &buf->f_files);
+	error |= __put_user(kbuf.f_ffree, &buf->f_ffree);
+
+	for (i = 0; i < 6; i++) {
+		error |= __put_user(0, &buf->f_fname[i]);
+		error |= __put_user(0, &buf->f_fpack[i]);
 	}
 
 out_f:
@@ -806,14 +792,15 @@
 	return error;
 }
 
-asmlinkage int irix_times(struct tms * tbuf)
+asmlinkage int irix_times(struct tms __user *tbuf)
 {
 	int err = 0;
 
 	if (tbuf) {
 		if (!access_ok(VERIFY_WRITE,tbuf,sizeof *tbuf))
 			return -EFAULT;
-		err |= __put_user(current->utime, &tbuf->tms_utime);
+
+		err = __put_user(current->utime, &tbuf->tms_utime);
 		err |= __put_user(current->stime, &tbuf->tms_stime);
 		err |= __put_user(current->signal->cutime, &tbuf->tms_cutime);
 		err |= __put_user(current->signal->cstime, &tbuf->tms_cstime);
@@ -829,13 +816,13 @@
 
 	if(regs->regs[2] == 1000)
 		base = 1;
-	filename = getname((char *) (long)regs->regs[base + 4]);
+	filename = getname((char __user *) (long)regs->regs[base + 4]);
 	error = PTR_ERR(filename);
 	if (IS_ERR(filename))
 		return error;
 
-	error = do_execve(filename, (char **) (long)regs->regs[base + 5],
-	                  (char **) 0, regs);
+	error = do_execve(filename, (char __user * __user *) (long)regs->regs[base + 5],
+	                  NULL, regs);
 	putname(filename);
 
 	return error;
@@ -848,12 +835,12 @@
 
 	if (regs->regs[2] == 1000)
 		base = 1;
-	filename = getname((char *) (long)regs->regs[base + 4]);
+	filename = getname((char __user *) (long)regs->regs[base + 4]);
 	error = PTR_ERR(filename);
 	if (IS_ERR(filename))
 		return error;
-	error = do_execve(filename, (char **) (long)regs->regs[base + 5],
-	                  (char **) (long)regs->regs[base + 6], regs);
+	error = do_execve(filename, (char __user * __user *) (long)regs->regs[base + 5],
+	                  (char __user * __user *) (long)regs->regs[base + 6], regs);
 	putname(filename);
 
 	return error;
@@ -909,22 +896,17 @@
 	return sys_socket(family, type, protocol);
 }
 
-asmlinkage int irix_getdomainname(char *name, int len)
+asmlinkage int irix_getdomainname(char __user *name, int len)
 {
-	int error;
-
-	if (!access_ok(VERIFY_WRITE, name, len))
-		return -EFAULT;
+	int err;
 
 	down_read(&uts_sem);
 	if (len > __NEW_UTS_LEN)
 		len = __NEW_UTS_LEN;
-	error = 0;
-	if (copy_to_user(name, system_utsname.domainname, len))
-		error = -EFAULT;
+	err = copy_to_user(name, system_utsname.domainname, len) ? -EFAULT : 0;
 	up_read(&uts_sem);
 
-	return error;
+	return err;
 }
 
 asmlinkage unsigned long irix_getpagesize(void)
@@ -940,12 +922,13 @@
 	case 0:
 		return sys_msgget((key_t) arg0, (int) arg1);
 	case 1:
-		return sys_msgctl((int) arg0, (int) arg1, (struct msqid_ds *)arg2);
+		return sys_msgctl((int) arg0, (int) arg1,
+		                  (struct msqid_ds __user *)arg2);
 	case 2:
-		return sys_msgrcv((int) arg0, (struct msgbuf *) arg1,
+		return sys_msgrcv((int) arg0, (struct msgbuf __user *) arg1,
 				  (size_t) arg2, (long) arg3, (int) arg4);
 	case 3:
-		return sys_msgsnd((int) arg0, (struct msgbuf *) arg1,
+		return sys_msgsnd((int) arg0, (struct msgbuf __user *) arg1,
 				  (size_t) arg2, (int) arg3);
 	default:
 		return -EINVAL;
@@ -957,12 +940,13 @@
 {
 	switch (opcode) {
 	case 0:
-		return do_shmat((int) arg0, (char *)arg1, (int) arg2,
+		return do_shmat((int) arg0, (char __user *) arg1, (int) arg2,
 				 (unsigned long *) arg3);
 	case 1:
-		return sys_shmctl((int)arg0, (int)arg1, (struct shmid_ds *)arg2);
+		return sys_shmctl((int)arg0, (int)arg1,
+		                  (struct shmid_ds __user *)arg2);
 	case 2:
-		return sys_shmdt((char *)arg0);
+		return sys_shmdt((char __user *)arg0);
 	case 3:
 		return sys_shmget((key_t) arg0, (int) arg1, (int) arg2);
 	default:
@@ -980,7 +964,7 @@
 	case 1:
 		return sys_semget((key_t) arg0, (int) arg1, (int) arg2);
 	case 2:
-		return sys_semop((int) arg0, (struct sembuf *)arg1,
+		return sys_semop((int) arg0, (struct sembuf __user *)arg1,
 				 (unsigned int) arg2);
 	default:
 		return -EINVAL;
@@ -998,15 +982,16 @@
 	lock_kernel();
 	retval = fn(file, offset, origin);
 	unlock_kernel();
+
 	return retval;
 }
 
 asmlinkage int irix_lseek64(int fd, int _unused, int offhi, int offlow,
                             int origin)
 {
-	int retval;
 	struct file * file;
 	loff_t offset;
+	int retval;
 
 	retval = -EBADF;
 	file = fget(fd);
@@ -1031,12 +1016,12 @@
 	return 0;
 }
 
-asmlinkage int irix_sgikopt(char *istring, char *ostring, int len)
+asmlinkage int irix_sgikopt(char __user *istring, char __user *ostring, int len)
 {
 	return -EINVAL;
 }
 
-asmlinkage int irix_gettimeofday(struct timeval *tv)
+asmlinkage int irix_gettimeofday(struct timeval __user *tv)
 {
 	time_t sec;
 	long nsec, seq;
@@ -1077,7 +1062,7 @@
 
 			if (max_size > file->f_dentry->d_inode->i_size) {
 				old_pos = sys_lseek (fd, max_size - 1, 0);
-				sys_write (fd, "", 1);
+				sys_write (fd, (void __user *) "", 1);
 				sys_lseek (fd, old_pos, 0);
 			}
 		}
@@ -1102,7 +1087,7 @@
 	return -EINVAL;
 }
 
-asmlinkage int irix_pagelock(char *addr, int len, int op)
+asmlinkage int irix_pagelock(char __user *addr, int len, int op)
 {
 	printk("[%s:%d] Wheee.. irix_pagelock(%p,%d,%d)\n",
 	       current->comm, current->pid, addr, len, op);
@@ -1142,7 +1127,7 @@
 	return error;
 }
 
-asmlinkage int irix_systeminfo(int cmd, char *buf, int cnt)
+asmlinkage int irix_systeminfo(int cmd, char __user *buf, int cnt)
 {
 	printk("[%s:%d] Wheee.. irix_systeminfo(%d,%p,%d)\n",
 	       current->comm, current->pid, cmd, buf, cnt);
@@ -1158,14 +1143,14 @@
 	char _unused3[257], _unused4[257], _unused5[257];
 };
 
-asmlinkage int irix_uname(struct iuname *buf)
+asmlinkage int irix_uname(struct iuname __user *buf)
 {
 	down_read(&uts_sem);
-	if (copy_to_user(system_utsname.sysname, buf->sysname, 65)
-	    || copy_to_user(system_utsname.nodename, buf->nodename, 65)
-	    || copy_to_user(system_utsname.release, buf->release, 65)
-	    || copy_to_user(system_utsname.version, buf->version, 65)
-	    || copy_to_user(system_utsname.machine, buf->machine, 65)) {
+	if (copy_from_user(system_utsname.sysname, buf->sysname, 65)
+	    || copy_from_user(system_utsname.nodename, buf->nodename, 65)
+	    || copy_from_user(system_utsname.release, buf->release, 65)
+	    || copy_from_user(system_utsname.version, buf->version, 65)
+	    || copy_from_user(system_utsname.machine, buf->machine, 65)) {
 		return -EFAULT;
 	}
 	up_read(&uts_sem);
@@ -1175,7 +1160,7 @@
 
 #undef DEBUG_XSTAT
 
-static int irix_xstat32_xlate(struct kstat *stat, void *ubuf)
+static int irix_xstat32_xlate(struct kstat *stat, void __user *ubuf)
 {
 	struct xstat32 {
 		u32 st_dev, st_pad1[3], st_ino, st_mode, st_nlink, st_uid, st_gid;
@@ -1215,7 +1200,7 @@
 	return copy_to_user(ubuf, &ub, sizeof(ub)) ? -EFAULT : 0;
 }
 
-static int irix_xstat64_xlate(struct kstat *stat, void *ubuf)
+static int irix_xstat64_xlate(struct kstat *stat, void __user *ubuf)
 {
 	struct xstat64 {
 		u32 st_dev; s32 st_pad1[3];
@@ -1265,7 +1250,7 @@
 	return copy_to_user(ubuf, &ks, sizeof(ks)) ? -EFAULT : 0;
 }
 
-asmlinkage int irix_xstat(int version, char *filename, struct stat *statbuf)
+asmlinkage int irix_xstat(int version, char __user *filename, struct stat __user *statbuf)
 {
 	int retval;
 	struct kstat stat;
@@ -1291,7 +1276,7 @@
 	return retval;
 }
 
-asmlinkage int irix_lxstat(int version, char *filename, struct stat *statbuf)
+asmlinkage int irix_lxstat(int version, char __user *filename, struct stat __user *statbuf)
 {
 	int error;
 	struct kstat stat;
@@ -1318,7 +1303,7 @@
 	return error;
 }
 
-asmlinkage int irix_fxstat(int version, int fd, struct stat *statbuf)
+asmlinkage int irix_fxstat(int version, int fd, struct stat __user *statbuf)
 {
 	int error;
 	struct kstat stat;
@@ -1344,7 +1329,7 @@
 	return error;
 }
 
-asmlinkage int irix_xmknod(int ver, char *filename, int mode, unsigned dev)
+asmlinkage int irix_xmknod(int ver, char __user *filename, int mode, unsigned dev)
 {
 	int retval;
 	printk("[%s:%d] Wheee.. irix_xmknod(%d,%s,%x,%x)\n",
@@ -1364,7 +1349,7 @@
 	return retval;
 }
 
-asmlinkage int irix_swapctl(int cmd, char *arg)
+asmlinkage int irix_swapctl(int cmd, char __user *arg)
 {
 	printk("[%s:%d] Wheee.. irix_swapctl(%d,%p)\n",
 	       current->comm, current->pid, cmd, arg);
@@ -1380,7 +1365,7 @@
 	char	f_fstr[32]; u32 f_filler[16];
 };
 
-asmlinkage int irix_statvfs(char *fname, struct irix_statvfs *buf)
+asmlinkage int irix_statvfs(char __user *fname, struct irix_statvfs __user *buf)
 {
 	struct nameidata nd;
 	struct kstatfs kbuf;
@@ -1388,10 +1373,9 @@
 
 	printk("[%s:%d] Wheee.. irix_statvfs(%s,%p)\n",
 	       current->comm, current->pid, fname, buf);
-	if (!access_ok(VERIFY_WRITE, buf, sizeof(struct irix_statvfs))) {
-		error = -EFAULT;
-		goto out;
-	}
+	if (!access_ok(VERIFY_WRITE, buf, sizeof(struct irix_statvfs)))
+		return -EFAULT;
+
 	error = user_path_walk(fname, &nd);
 	if (error)
 		goto out;
@@ -1399,27 +1383,25 @@
 	if (error)
 		goto dput_and_out;
 
-	__put_user(kbuf.f_bsize, &buf->f_bsize);
-	__put_user(kbuf.f_frsize, &buf->f_frsize);
-	__put_user(kbuf.f_blocks, &buf->f_blocks);
-	__put_user(kbuf.f_bfree, &buf->f_bfree);
-	__put_user(kbuf.f_bfree, &buf->f_bavail);  /* XXX hackety hack... */
-	__put_user(kbuf.f_files, &buf->f_files);
-	__put_user(kbuf.f_ffree, &buf->f_ffree);
-	__put_user(kbuf.f_ffree, &buf->f_favail);  /* XXX hackety hack... */
+	error |= __put_user(kbuf.f_bsize, &buf->f_bsize);
+	error |= __put_user(kbuf.f_frsize, &buf->f_frsize);
+	error |= __put_user(kbuf.f_blocks, &buf->f_blocks);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bfree);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bavail);  /* XXX hackety hack... */
+	error |= __put_user(kbuf.f_files, &buf->f_files);
+	error |= __put_user(kbuf.f_ffree, &buf->f_ffree);
+	error |= __put_user(kbuf.f_ffree, &buf->f_favail);  /* XXX hackety hack... */
 #ifdef __MIPSEB__
-	__put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
 #else
-	__put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
 #endif
 	for (i = 0; i < 16; i++)
-		__put_user(0, &buf->f_basetype[i]);
-	__put_user(0, &buf->f_flag);
-	__put_user(kbuf.f_namelen, &buf->f_namemax);
+		error |= __put_user(0, &buf->f_basetype[i]);
+	error |= __put_user(0, &buf->f_flag);
+	error |= __put_user(kbuf.f_namelen, &buf->f_namemax);
 	for (i = 0; i < 32; i++)
-		__put_user(0, &buf->f_fstr[i]);
-
-	error = 0;
+		error |= __put_user(0, &buf->f_fstr[i]);
 
 dput_and_out:
 	path_release(&nd);
@@ -1427,7 +1409,7 @@
 	return error;
 }
 
-asmlinkage int irix_fstatvfs(int fd, struct irix_statvfs *buf)
+asmlinkage int irix_fstatvfs(int fd, struct irix_statvfs __user *buf)
 {
 	struct kstatfs kbuf;
 	struct file *file;
@@ -1436,10 +1418,9 @@
 	printk("[%s:%d] Wheee.. irix_fstatvfs(%d,%p)\n",
 	       current->comm, current->pid, fd, buf);
 
-	if (!access_ok(VERIFY_WRITE, buf, sizeof(struct irix_statvfs))) {
-		error = -EFAULT;
-		goto out;
-	}
+	if (!access_ok(VERIFY_WRITE, buf, sizeof(struct irix_statvfs)))
+		return -EFAULT;
+
 	if (!(file = fget(fd))) {
 		error = -EBADF;
 		goto out;
@@ -1448,24 +1429,24 @@
 	if (error)
 		goto out_f;
 
-	__put_user(kbuf.f_bsize, &buf->f_bsize);
-	__put_user(kbuf.f_frsize, &buf->f_frsize);
-	__put_user(kbuf.f_blocks, &buf->f_blocks);
-	__put_user(kbuf.f_bfree, &buf->f_bfree);
-	__put_user(kbuf.f_bfree, &buf->f_bavail); /* XXX hackety hack... */
-	__put_user(kbuf.f_files, &buf->f_files);
-	__put_user(kbuf.f_ffree, &buf->f_ffree);
-	__put_user(kbuf.f_ffree, &buf->f_favail); /* XXX hackety hack... */
+	error = __put_user(kbuf.f_bsize, &buf->f_bsize);
+	error |= __put_user(kbuf.f_frsize, &buf->f_frsize);
+	error |= __put_user(kbuf.f_blocks, &buf->f_blocks);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bfree);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bavail); /* XXX hackety hack... */
+	error |= __put_user(kbuf.f_files, &buf->f_files);
+	error |= __put_user(kbuf.f_ffree, &buf->f_ffree);
+	error |= __put_user(kbuf.f_ffree, &buf->f_favail); /* XXX hackety hack... */
 #ifdef __MIPSEB__
-	__put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
 #else
-	__put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
 #endif
 	for(i = 0; i < 16; i++)
-		__put_user(0, &buf->f_basetype[i]);
-	__put_user(0, &buf->f_flag);
-	__put_user(kbuf.f_namelen, &buf->f_namemax);
-	__clear_user(&buf->f_fstr, sizeof(buf->f_fstr));
+		error |= __put_user(0, &buf->f_basetype[i]);
+	error |= __put_user(0, &buf->f_flag);
+	error |= __put_user(kbuf.f_namelen, &buf->f_namemax);
+	error |= __clear_user(&buf->f_fstr, sizeof(buf->f_fstr)) ? -EFAULT : 0;
 
 out_f:
 	fput(file);
@@ -1489,7 +1470,7 @@
 	return -EINVAL;
 }
 
-asmlinkage int irix_truncate64(char *name, int pad, int size1, int size2)
+asmlinkage int irix_truncate64(char __user *name, int pad, int size1, int size2)
 {
 	int retval;
 
@@ -1522,6 +1503,7 @@
 	int len, prot, flags, fd, off1, off2, error, base = 0;
 	unsigned long addr, pgoff, *sp;
 	struct file *file = NULL;
+	int err;
 
 	if (regs->regs[2] == 1000)
 		base = 1;
@@ -1531,36 +1513,31 @@
 	prot = regs->regs[base + 6];
 	if (!base) {
 		flags = regs->regs[base + 7];
-		if (!access_ok(VERIFY_READ, sp, (4 * sizeof(unsigned long)))) {
-			error = -EFAULT;
-			goto out;
-		}
+		if (!access_ok(VERIFY_READ, sp, (4 * sizeof(unsigned long))))
+			return -EFAULT;
 		fd = sp[0];
-		__get_user(off1, &sp[1]);
-		__get_user(off2, &sp[2]);
+		err = __get_user(off1, &sp[1]);
+		err |= __get_user(off2, &sp[2]);
 	} else {
-		if (!access_ok(VERIFY_READ, sp, (5 * sizeof(unsigned long)))) {
-			error = -EFAULT;
-			goto out;
-		}
-		__get_user(flags, &sp[0]);
-		__get_user(fd, &sp[1]);
-		__get_user(off1, &sp[2]);
-		__get_user(off2, &sp[3]);
+		if (!access_ok(VERIFY_READ, sp, (5 * sizeof(unsigned long))))
+			return -EFAULT;
+		err = __get_user(flags, &sp[0]);
+		err |= __get_user(fd, &sp[1]);
+		err |= __get_user(off1, &sp[2]);
+		err |= __get_user(off2, &sp[3]);
 	}
 
-	if (off1 & PAGE_MASK) {
-		error = -EOVERFLOW;
-		goto out;
-	}
+	if (err)
+		return err;
+
+	if (off1 & PAGE_MASK)
+		return -EOVERFLOW;
 
 	pgoff = (off1 << (32 - PAGE_SHIFT)) | (off2 >> PAGE_SHIFT);
 
 	if (!(flags & MAP_ANONYMOUS)) {
-		if (!(file = fget(fd))) {
-			error = -EBADF;
-			goto out;
-		}
+		if (!(file = fget(fd)))
+			return -EBADF;
 
 		/* Ok, bad taste hack follows, try to think in something else
 		   when reading this */
@@ -1570,7 +1547,7 @@
 
 			if (max_size > file->f_dentry->d_inode->i_size) {
 				old_pos = sys_lseek (fd, max_size - 1, 0);
-				sys_write (fd, "", 1);
+				sys_write (fd, (void __user *) "", 1);
 				sys_lseek (fd, old_pos, 0);
 			}
 		}
@@ -1585,7 +1562,6 @@
 	if (file)
 		fput(file);
 
-out:
 	return error;
 }
 
@@ -1597,7 +1573,7 @@
 	return -EINVAL;
 }
 
-asmlinkage int irix_pread(int fd, char *buf, int cnt, int off64,
+asmlinkage int irix_pread(int fd, char __user *buf, int cnt, int off64,
 			  int off1, int off2)
 {
 	printk("[%s:%d] Wheee.. irix_pread(%d,%p,%d,%d,%d,%d)\n",
@@ -1606,7 +1582,7 @@
 	return -EINVAL;
 }
 
-asmlinkage int irix_pwrite(int fd, char *buf, int cnt, int off64,
+asmlinkage int irix_pwrite(int fd, char __user *buf, int cnt, int off64,
 			   int off1, int off2)
 {
 	printk("[%s:%d] Wheee.. irix_pwrite(%d,%p,%d,%d,%d,%d)\n",
@@ -1638,7 +1614,7 @@
 	u32  f_filler[16];
 };
 
-asmlinkage int irix_statvfs64(char *fname, struct irix_statvfs64 *buf)
+asmlinkage int irix_statvfs64(char __user *fname, struct irix_statvfs64 __user *buf)
 {
 	struct nameidata nd;
 	struct kstatfs kbuf;
@@ -1650,6 +1626,7 @@
 		error = -EFAULT;
 		goto out;
 	}
+
 	error = user_path_walk(fname, &nd);
 	if (error)
 		goto out;
@@ -1657,27 +1634,25 @@
 	if (error)
 		goto dput_and_out;
 
-	__put_user(kbuf.f_bsize, &buf->f_bsize);
-	__put_user(kbuf.f_frsize, &buf->f_frsize);
-	__put_user(kbuf.f_blocks, &buf->f_blocks);
-	__put_user(kbuf.f_bfree, &buf->f_bfree);
-	__put_user(kbuf.f_bfree, &buf->f_bavail);  /* XXX hackety hack... */
-	__put_user(kbuf.f_files, &buf->f_files);
-	__put_user(kbuf.f_ffree, &buf->f_ffree);
-	__put_user(kbuf.f_ffree, &buf->f_favail);  /* XXX hackety hack... */
+	error = __put_user(kbuf.f_bsize, &buf->f_bsize);
+	error |= __put_user(kbuf.f_frsize, &buf->f_frsize);
+	error |= __put_user(kbuf.f_blocks, &buf->f_blocks);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bfree);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bavail);  /* XXX hackety hack... */
+	error |= __put_user(kbuf.f_files, &buf->f_files);
+	error |= __put_user(kbuf.f_ffree, &buf->f_ffree);
+	error |= __put_user(kbuf.f_ffree, &buf->f_favail);  /* XXX hackety hack... */
 #ifdef __MIPSEB__
-	__put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
 #else
-	__put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
 #endif
 	for(i = 0; i < 16; i++)
-		__put_user(0, &buf->f_basetype[i]);
-	__put_user(0, &buf->f_flag);
-	__put_user(kbuf.f_namelen, &buf->f_namemax);
+		error |= __put_user(0, &buf->f_basetype[i]);
+	error |= __put_user(0, &buf->f_flag);
+	error |= __put_user(kbuf.f_namelen, &buf->f_namemax);
 	for(i = 0; i < 32; i++)
-		__put_user(0, &buf->f_fstr[i]);
-
-	error = 0;
+		error |= __put_user(0, &buf->f_fstr[i]);
 
 dput_and_out:
 	path_release(&nd);
@@ -1685,7 +1660,7 @@
 	return error;
 }
 
-asmlinkage int irix_fstatvfs64(int fd, struct irix_statvfs *buf)
+asmlinkage int irix_fstatvfs64(int fd, struct irix_statvfs __user *buf)
 {
 	struct kstatfs kbuf;
 	struct file *file;
@@ -1706,24 +1681,24 @@
 	if (error)
 		goto out_f;
 
-	__put_user(kbuf.f_bsize, &buf->f_bsize);
-	__put_user(kbuf.f_frsize, &buf->f_frsize);
-	__put_user(kbuf.f_blocks, &buf->f_blocks);
-	__put_user(kbuf.f_bfree, &buf->f_bfree);
-	__put_user(kbuf.f_bfree, &buf->f_bavail);  /* XXX hackety hack... */
-	__put_user(kbuf.f_files, &buf->f_files);
-	__put_user(kbuf.f_ffree, &buf->f_ffree);
-	__put_user(kbuf.f_ffree, &buf->f_favail);  /* XXX hackety hack... */
+	error = __put_user(kbuf.f_bsize, &buf->f_bsize);
+	error |= __put_user(kbuf.f_frsize, &buf->f_frsize);
+	error |= __put_user(kbuf.f_blocks, &buf->f_blocks);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bfree);
+	error |= __put_user(kbuf.f_bfree, &buf->f_bavail);  /* XXX hackety hack... */
+	error |= __put_user(kbuf.f_files, &buf->f_files);
+	error |= __put_user(kbuf.f_ffree, &buf->f_ffree);
+	error |= __put_user(kbuf.f_ffree, &buf->f_favail);  /* XXX hackety hack... */
 #ifdef __MIPSEB__
-	__put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[1], &buf->f_fsid);
 #else
-	__put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
+	error |= __put_user(kbuf.f_fsid.val[0], &buf->f_fsid);
 #endif
 	for(i = 0; i < 16; i++)
-		__put_user(0, &buf->f_basetype[i]);
-	__put_user(0, &buf->f_flag);
-	__put_user(kbuf.f_namelen, &buf->f_namemax);
-	__clear_user(buf->f_fstr, sizeof(buf->f_fstr[i]));
+		error |= __put_user(0, &buf->f_basetype[i]);
+	error |= __put_user(0, &buf->f_flag);
+	error |= __put_user(kbuf.f_namelen, &buf->f_namemax);
+	error |= __clear_user(buf->f_fstr, sizeof(buf->f_fstr[i])) ? -EFAULT : 0;
 
 out_f:
 	fput(file);
@@ -1731,9 +1706,9 @@
 	return error;
 }
 
-asmlinkage int irix_getmountid(char *fname, unsigned long *midbuf)
+asmlinkage int irix_getmountid(char __user *fname, unsigned long __user *midbuf)
 {
-	int err = 0;
+	int err;
 
 	printk("[%s:%d] irix_getmountid(%s, %p)\n",
 	       current->comm, current->pid, fname, midbuf);
@@ -1746,7 +1721,7 @@
 	 * fsid of the filesystem to try and make the right decision, but
 	 * we don't have this so for now. XXX
 	 */
-	err |= __put_user(0, &midbuf[0]);
+	err = __put_user(0, &midbuf[0]);
 	err |= __put_user(0, &midbuf[1]);
 	err |= __put_user(0, &midbuf[2]);
 	err |= __put_user(0, &midbuf[3]);
@@ -1773,8 +1748,8 @@
 };
 
 struct irix_dirent32_callback {
-	struct irix_dirent32 *current_dir;
-	struct irix_dirent32 *previous;
+	struct irix_dirent32 __user *current_dir;
+	struct irix_dirent32 __user *previous;
 	int count;
 	int error;
 };
@@ -1782,13 +1757,13 @@
 #define NAME_OFFSET32(de) ((int) ((de)->d_name - (char *) (de)))
 #define ROUND_UP32(x) (((x)+sizeof(u32)-1) & ~(sizeof(u32)-1))
 
-static int irix_filldir32(void *__buf, const char *name, int namlen,
-                          loff_t offset, ino_t ino, unsigned int d_type)
+static int irix_filldir32(void *__buf, const char *name,
+	int namlen, loff_t offset, ino_t ino, unsigned int d_type)
 {
-	struct irix_dirent32 *dirent;
-	struct irix_dirent32_callback *buf =
-		 (struct irix_dirent32_callback *)__buf;
+	struct irix_dirent32 __user *dirent;
+	struct irix_dirent32_callback *buf = __buf;
 	unsigned short reclen = ROUND_UP32(NAME_OFFSET32(dirent) + namlen + 1);
+	int err = 0;
 
 #ifdef DEBUG_GETDENTS
 	printk("\nirix_filldir32[reclen<%d>namlen<%d>count<%d>]",
@@ -1799,25 +1774,26 @@
 		return -EINVAL;
 	dirent = buf->previous;
 	if (dirent)
-		__put_user(offset, &dirent->d_off);
+		err = __put_user(offset, &dirent->d_off);
 	dirent = buf->current_dir;
-	buf->previous = dirent;
-	__put_user(ino, &dirent->d_ino);
-	__put_user(reclen, &dirent->d_reclen);
-	copy_to_user(dirent->d_name, name, namlen);
-	__put_user(0, &dirent->d_name[namlen]);
-	((char *) dirent) += reclen;
+	err |= __put_user(dirent, &buf->previous);
+	err |= __put_user(ino, &dirent->d_ino);
+	err |= __put_user(reclen, &dirent->d_reclen);
+	err |= copy_to_user((char __user *)dirent->d_name, name, namlen) ? -EFAULT : 0;
+	err |= __put_user(0, &dirent->d_name[namlen]);
+	dirent = (struct irix_dirent32 __user *) ((char __user *) dirent + reclen);
+
 	buf->current_dir = dirent;
 	buf->count -= reclen;
 
-	return 0;
+	return err;
 }
 
-asmlinkage int irix_ngetdents(unsigned int fd, void * dirent,
-	unsigned int count, int *eob)
+asmlinkage int irix_ngetdents(unsigned int fd, void __user * dirent,
+	unsigned int count, int __user *eob)
 {
 	struct file *file;
-	struct irix_dirent32 *lastdirent;
+	struct irix_dirent32 __user *lastdirent;
 	struct irix_dirent32_callback buf;
 	int error;
 
@@ -1830,7 +1806,7 @@
 	if (!file)
 		goto out;
 
-	buf.current_dir = (struct irix_dirent32 *) dirent;
+	buf.current_dir = (struct irix_dirent32 __user *) dirent;
 	buf.previous = NULL;
 	buf.count = count;
 	buf.error = 0;
@@ -1870,8 +1846,8 @@
 };
 
 struct irix_dirent64_callback {
-	struct irix_dirent64 *curr;
-	struct irix_dirent64 *previous;
+	struct irix_dirent64 __user *curr;
+	struct irix_dirent64 __user *previous;
 	int count;
 	int error;
 };
@@ -1879,37 +1855,44 @@
 #define NAME_OFFSET64(de) ((int) ((de)->d_name - (char *) (de)))
 #define ROUND_UP64(x) (((x)+sizeof(u64)-1) & ~(sizeof(u64)-1))
 
-static int irix_filldir64(void * __buf, const char * name, int namlen,
-			  loff_t offset, ino_t ino, unsigned int d_type)
+static int irix_filldir64(void *__buf, const char *name,
+	int namlen, loff_t offset, ino_t ino, unsigned int d_type)
 {
-	struct irix_dirent64 *dirent;
-	struct irix_dirent64_callback * buf =
-		(struct irix_dirent64_callback *) __buf;
+	struct irix_dirent64 __user *dirent;
+	struct irix_dirent64_callback * buf = __buf;
 	unsigned short reclen = ROUND_UP64(NAME_OFFSET64(dirent) + namlen + 1);
+	int err = 0;
 
-	buf->error = -EINVAL;	/* only used if we fail.. */
+	if (!access_ok(VERIFY_WRITE, buf, sizeof(*buf)))
+		return -EFAULT;
+
+	if (__put_user(-EINVAL, &buf->error))	/* only used if we fail.. */
+		return -EFAULT;
 	if (reclen > buf->count)
 		return -EINVAL;
 	dirent = buf->previous;
 	if (dirent)
-		__put_user(offset, &dirent->d_off);
+		err = __put_user(offset, &dirent->d_off);
 	dirent = buf->curr;
 	buf->previous = dirent;
-	__put_user(ino, &dirent->d_ino);
-	__put_user(reclen, &dirent->d_reclen);
-	__copy_to_user(dirent->d_name, name, namlen);
-	__put_user(0, &dirent->d_name[namlen]);
-	((char *) dirent) += reclen;
+	err |= __put_user(ino, &dirent->d_ino);
+	err |= __put_user(reclen, &dirent->d_reclen);
+	err |= __copy_to_user((char __user *)dirent->d_name, name, namlen)
+	       ? -EFAULT : 0;
+	err |= __put_user(0, &dirent->d_name[namlen]);
+
+	dirent = (struct irix_dirent64 __user *) ((char __user *) dirent + reclen);
+
 	buf->curr = dirent;
 	buf->count -= reclen;
 
-	return 0;
+	return err;
 }
 
-asmlinkage int irix_getdents64(int fd, void *dirent, int cnt)
+asmlinkage int irix_getdents64(int fd, void __user *dirent, int cnt)
 {
 	struct file *file;
-	struct irix_dirent64 *lastdirent;
+	struct irix_dirent64 __user *lastdirent;
 	struct irix_dirent64_callback buf;
 	int error;
 
@@ -1929,7 +1912,7 @@
 	if (cnt < (sizeof(struct irix_dirent64) + 255))
 		goto out_f;
 
-	buf.curr = (struct irix_dirent64 *) dirent;
+	buf.curr = (struct irix_dirent64 __user *) dirent;
 	buf.previous = NULL;
 	buf.count = cnt;
 	buf.error = 0;
@@ -1941,7 +1924,8 @@
 		error = buf.error;
 		goto out_f;
 	}
-	lastdirent->d_off = (u64) file->f_pos;
+	if (put_user(file->f_pos, &lastdirent->d_off))
+		return -EFAULT;
 #ifdef DEBUG_GETDENTS
 	printk("returning %d\n", cnt - buf.count);
 #endif
@@ -1953,10 +1937,10 @@
 	return error;
 }
 
-asmlinkage int irix_ngetdents64(int fd, void *dirent, int cnt, int *eob)
+asmlinkage int irix_ngetdents64(int fd, void __user *dirent, int cnt, int *eob)
 {
 	struct file *file;
-	struct irix_dirent64 *lastdirent;
+	struct irix_dirent64 __user *lastdirent;
 	struct irix_dirent64_callback buf;
 	int error;
 
@@ -1978,7 +1962,7 @@
 		goto out_f;
 
 	*eob = 0;
-	buf.curr = (struct irix_dirent64 *) dirent;
+	buf.curr = (struct irix_dirent64 __user *) dirent;
 	buf.previous = NULL;
 	buf.count = cnt;
 	buf.error = 0;
@@ -1990,7 +1974,8 @@
 		error = buf.error;
 		goto out_f;
 	}
-	lastdirent->d_off = (u64) file->f_pos;
+	if (put_user(file->f_pos, &lastdirent->d_off))
+		return -EFAULT;
 #ifdef DEBUG_GETDENTS
 	printk("eob=%d returning %d\n", *eob, cnt - buf.count);
 #endif
@@ -2053,14 +2038,14 @@
 	return retval;
 }
 
-asmlinkage int irix_utssys(char *inbuf, int arg, int type, char *outbuf)
+asmlinkage int irix_utssys(char __user *inbuf, int arg, int type, char __user *outbuf)
 {
 	int retval;
 
 	switch(type) {
 	case 0:
 		/* uname() */
-		retval = irix_uname((struct iuname *)inbuf);
+		retval = irix_uname((struct iuname __user *)inbuf);
 		goto out;
 
 	case 2:
diff -Naur linux-2.6.14/arch/mips/kernel/time.c linux-mips-2.6.14.orig/arch/mips/kernel/time.c
--- linux-2.6.14/arch/mips/kernel/time.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/time.c	2005-11-17 11:42:23.000000000 -0800
@@ -11,6 +11,7 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
+#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -25,6 +26,7 @@
 #include <linux/module.h>
 
 #include <asm/bootinfo.h>
+#include <asm/cache.h>
 #include <asm/compiler.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
@@ -76,7 +78,7 @@
 static unsigned int sll32_usecs_per_cycle;
 
 /* how many counter cycles in a jiffy */
-static unsigned long cycles_per_jiffy;
+static unsigned long cycles_per_jiffy __read_mostly;
 
 /* Cycle counter value at the previous timer interrupt.. */
 static unsigned int timerhi, timerlo;
@@ -98,7 +100,10 @@
 	return 0;
 }
 
-static void null_hpt_init(unsigned int count) { /* nothing */ }
+static void null_hpt_init(unsigned int count)
+{
+	/* nothing */
+}
 
 
 /*
@@ -108,8 +113,10 @@
 {
 	unsigned int count;
 
+#ifndef CONFIG_SOC_PNX8550	/* pnx8550 resets to zero */
 	/* Ack this timer interrupt and set the next one.  */
 	expirelo += cycles_per_jiffy;
+#endif
 	write_c0_compare(expirelo);
 
 	/* Check to see if we have missed any timer interrupts.  */
@@ -224,7 +231,6 @@
 	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
 
 	ntp_clear();
-
 	write_sequnlock_irq(&xtime_lock);
 	clock_was_set();
 	return 0;
diff -Naur linux-2.6.14/arch/mips/kernel/traps.c linux-mips-2.6.14.orig/arch/mips/kernel/traps.c
--- linux-2.6.14/arch/mips/kernel/traps.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/traps.c	2005-11-17 11:42:23.000000000 -0800
@@ -9,7 +9,7 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2000, 01 MIPS Technologies, Inc.
- * Copyright (C) 2002, 2003, 2004  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2004, 2005  Maciej W. Rozycki
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -20,12 +20,16 @@
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/kallsyms.h>
+#include <linux/bootmem.h>
 
 #include <asm/bootinfo.h>
 #include <asm/branch.h>
 #include <asm/break.h>
 #include <asm/cpu.h>
+#include <asm/dsp.h>
 #include <asm/fpu.h>
+#include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
 #include <asm/module.h>
 #include <asm/pgtable.h>
 #include <asm/ptrace.h>
@@ -54,14 +58,19 @@
 extern asmlinkage void handle_fpe(void);
 extern asmlinkage void handle_mdmx(void);
 extern asmlinkage void handle_watch(void);
+extern asmlinkage void handle_mt(void);
+extern asmlinkage void handle_dsp(void);
 extern asmlinkage void handle_mcheck(void);
 extern asmlinkage void handle_reserved(void);
 
-extern int fpu_emulator_cop1Handler(int xcptno, struct pt_regs *xcp,
+extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 	struct mips_fpu_soft_struct *ctx);
 
 void (*board_be_init)(void);
 int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
+void (*board_nmi_handler_setup)(void);
+void (*board_ejtag_handler_setup)(void);
+void (*board_bind_eic_interrupt)(int irq, int regset);
 
 /*
  * These constant is for searching for possible module text segments.
@@ -201,32 +210,47 @@
 
 	printk("Status: %08x    ", (uint32_t) regs->cp0_status);
 
-	if (regs->cp0_status & ST0_KX)
-		printk("KX ");
-	if (regs->cp0_status & ST0_SX)
-		printk("SX ");
-	if (regs->cp0_status & ST0_UX)
-		printk("UX ");
-	switch (regs->cp0_status & ST0_KSU) {
-	case KSU_USER:
-		printk("USER ");
-		break;
-	case KSU_SUPERVISOR:
-		printk("SUPERVISOR ");
-		break;
-	case KSU_KERNEL:
-		printk("KERNEL ");
-		break;
-	default:
-		printk("BAD_MODE ");
-		break;
+	if (current_cpu_data.isa_level == MIPS_CPU_ISA_I) {
+		if (regs->cp0_status & ST0_KUO)
+			printk("KUo ");
+		if (regs->cp0_status & ST0_IEO)
+			printk("IEo ");
+		if (regs->cp0_status & ST0_KUP)
+			printk("KUp ");
+		if (regs->cp0_status & ST0_IEP)
+			printk("IEp ");
+		if (regs->cp0_status & ST0_KUC)
+			printk("KUc ");
+		if (regs->cp0_status & ST0_IEC)
+			printk("IEc ");
+	} else {
+		if (regs->cp0_status & ST0_KX)
+			printk("KX ");
+		if (regs->cp0_status & ST0_SX)
+			printk("SX ");
+		if (regs->cp0_status & ST0_UX)
+			printk("UX ");
+		switch (regs->cp0_status & ST0_KSU) {
+		case KSU_USER:
+			printk("USER ");
+			break;
+		case KSU_SUPERVISOR:
+			printk("SUPERVISOR ");
+			break;
+		case KSU_KERNEL:
+			printk("KERNEL ");
+			break;
+		default:
+			printk("BAD_MODE ");
+			break;
+		}
+		if (regs->cp0_status & ST0_ERL)
+			printk("ERL ");
+		if (regs->cp0_status & ST0_EXL)
+			printk("EXL ");
+		if (regs->cp0_status & ST0_IE)
+			printk("IE ");
 	}
-	if (regs->cp0_status & ST0_ERL)
-		printk("ERL ");
-	if (regs->cp0_status & ST0_EXL)
-		printk("EXL ");
-	if (regs->cp0_status & ST0_IE)
-		printk("IE ");
 	printk("\n");
 
 	printk("Cause : %08x\n", cause);
@@ -252,29 +276,18 @@
 
 static DEFINE_SPINLOCK(die_lock);
 
-NORET_TYPE void __die(const char * str, struct pt_regs * regs,
-	const char * file, const char * func, unsigned long line)
+NORET_TYPE void ATTRIB_NORET die(const char * str, struct pt_regs * regs)
 {
 	static int die_counter;
 
 	console_verbose();
 	spin_lock_irq(&die_lock);
-	printk("%s", str);
-	if (file && func)
-		printk(" in %s:%s, line %ld", file, func, line);
-	printk("[#%d]:\n", ++die_counter);
+	printk("%s[#%d]:\n", str, ++die_counter);
 	show_registers(regs);
 	spin_unlock_irq(&die_lock);
 	do_exit(SIGSEGV);
 }
 
-void __die_if_kernel(const char * str, struct pt_regs * regs,
-		     const char * file, const char * func, unsigned long line)
-{
-	if (!user_mode(regs))
-		__die(str, regs, file, func, line);
-}
-
 extern const struct exception_table_entry __start___dbe_table[];
 extern const struct exception_table_entry __stop___dbe_table[];
 
@@ -339,9 +352,9 @@
 
 static inline int get_insn_opcode(struct pt_regs *regs, unsigned int *opcode)
 {
-	unsigned int *epc;
+	unsigned int __user *epc;
 
-	epc = (unsigned int *) regs->cp0_epc +
+	epc = (unsigned int __user *) regs->cp0_epc +
 	      ((regs->cp0_cause & CAUSEF_BD) != 0);
 	if (!get_user(*opcode, epc))
 		return 0;
@@ -360,6 +373,10 @@
 #define OFFSET 0x0000ffff
 #define LL     0xc0000000
 #define SC     0xe0000000
+#define SPEC3  0x7c000000
+#define RD     0x0000f800
+#define FUNC   0x0000003f
+#define RDHWR  0x0000003b
 
 /*
  * The ll_bit is cleared by r*_switch.S
@@ -371,7 +388,7 @@
 
 static inline void simulate_ll(struct pt_regs *regs, unsigned int opcode)
 {
-	unsigned long value, *vaddr;
+	unsigned long value, __user *vaddr;
 	long offset;
 	int signal = 0;
 
@@ -385,7 +402,8 @@
 	offset <<= 16;
 	offset >>= 16;
 
-	vaddr = (unsigned long *)((long)(regs->regs[(opcode & BASE) >> 21]) + offset);
+	vaddr = (unsigned long __user *)
+	        ((unsigned long)(regs->regs[(opcode & BASE) >> 21]) + offset);
 
 	if ((unsigned long)vaddr & 3) {
 		signal = SIGBUS;
@@ -407,9 +425,10 @@
 
 	preempt_enable();
 
+	compute_return_epc(regs);
+
 	regs->regs[(opcode & RT) >> 16] = value;
 
-	compute_return_epc(regs);
 	return;
 
 sig:
@@ -418,7 +437,8 @@
 
 static inline void simulate_sc(struct pt_regs *regs, unsigned int opcode)
 {
-	unsigned long *vaddr, reg;
+	unsigned long __user *vaddr;
+	unsigned long reg;
 	long offset;
 	int signal = 0;
 
@@ -432,7 +452,8 @@
 	offset <<= 16;
 	offset >>= 16;
 
-	vaddr = (unsigned long *)((long)(regs->regs[(opcode & BASE) >> 21]) + offset);
+	vaddr = (unsigned long __user *)
+	        ((unsigned long)(regs->regs[(opcode & BASE) >> 21]) + offset);
 	reg = (opcode & RT) >> 16;
 
 	if ((unsigned long)vaddr & 3) {
@@ -443,9 +464,9 @@
 	preempt_disable();
 
 	if (ll_bit == 0 || ll_task != current) {
+		compute_return_epc(regs);
 		regs->regs[reg] = 0;
 		preempt_enable();
-		compute_return_epc(regs);
 		return;
 	}
 
@@ -456,9 +477,9 @@
 		goto sig;
 	}
 
+	compute_return_epc(regs);
 	regs->regs[reg] = 1;
 
-	compute_return_epc(regs);
 	return;
 
 sig:
@@ -491,6 +512,37 @@
 	return -EFAULT;			/* Strange things going on ... */
 }
 
+/*
+ * Simulate trapping 'rdhwr' instructions to provide user accessible
+ * registers not implemented in hardware.  The only current use of this
+ * is the thread area pointer.
+ */
+static inline int simulate_rdhwr(struct pt_regs *regs)
+{
+	struct thread_info *ti = current->thread_info;
+	unsigned int opcode;
+
+	if (unlikely(get_insn_opcode(regs, &opcode)))
+		return -EFAULT;
+
+	if (unlikely(compute_return_epc(regs)))
+		return -EFAULT;
+
+	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
+		int rd = (opcode & RD) >> 11;
+		int rt = (opcode & RT) >> 16;
+		switch (rd) {
+			case 29:
+				regs->regs[rt] = ti->tp_value;
+				break;
+			default:
+				return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
 asmlinkage void do_ov(struct pt_regs *regs)
 {
 	siginfo_t info;
@@ -498,7 +550,7 @@
 	info.si_code = FPE_INTOVF;
 	info.si_signo = SIGFPE;
 	info.si_errno = 0;
-	info.si_addr = (void *)regs->cp0_epc;
+	info.si_addr = (void __user *) regs->cp0_epc;
 	force_sig_info(SIGFPE, &info, current);
 }
 
@@ -512,6 +564,14 @@
 
 		preempt_disable();
 
+#ifdef CONFIG_PREEMPT
+		if (!is_fpu_owner()) {
+			/* We might lose fpu before disabling preempt... */
+			own_fpu();
+			BUG_ON(!used_math());
+			restore_fp(current);
+		}
+#endif
 		/*
 	 	 * Unimplemented operation exception.  If we've got the full
 		 * software emulator on-board, let's use it...
@@ -523,11 +583,18 @@
 		 * a bit extreme for what should be an infrequent event.
 		 */
 		save_fp(current);
+		/* Ensure 'resume' not overwrite saved fp context again. */
+		lose_fpu();
+
+		preempt_enable();
 
 		/* Run the emulator */
-		sig = fpu_emulator_cop1Handler (0, regs,
+		sig = fpu_emulator_cop1Handler (regs,
 			&current->thread.fpu.soft);
 
+		preempt_disable();
+
+		own_fpu();	/* Using the FPU again.  */
 		/*
 		 * We can't allow the emulated instruction to leave any of
 		 * the cause bit set in $fcr31.
@@ -584,7 +651,7 @@
 			info.si_code = FPE_INTOVF;
 		info.si_signo = SIGFPE;
 		info.si_errno = 0;
-		info.si_addr = (void *)regs->cp0_epc;
+		info.si_addr = (void __user *) regs->cp0_epc;
 		force_sig_info(SIGFPE, &info, current);
 		break;
 	default:
@@ -621,7 +688,7 @@
 			info.si_code = FPE_INTOVF;
 		info.si_signo = SIGFPE;
 		info.si_errno = 0;
-		info.si_addr = (void *)regs->cp0_epc;
+		info.si_addr = (void __user *) regs->cp0_epc;
 		force_sig_info(SIGFPE, &info, current);
 		break;
 	default:
@@ -637,6 +704,9 @@
 		if (!simulate_llsc(regs))
 			return;
 
+	if (!simulate_rdhwr(regs))
+		return;
+
 	force_sig(SIGILL, current);
 }
 
@@ -650,11 +720,13 @@
 
 	switch (cpid) {
 	case 0:
-		if (cpu_has_llsc)
-			break;
+		if (!cpu_has_llsc)
+			if (!simulate_llsc(regs))
+				return;
 
-		if (!simulate_llsc(regs))
+		if (!simulate_rdhwr(regs))
 			return;
+
 		break;
 
 	case 1:
@@ -668,15 +740,15 @@
 			set_used_math();
 		}
 
+		preempt_enable();
+
 		if (!cpu_has_fpu) {
-			int sig = fpu_emulator_cop1Handler(0, regs,
+			int sig = fpu_emulator_cop1Handler(regs,
 						&current->thread.fpu.soft);
 			if (sig)
 				force_sig(sig, current);
 		}
 
-		preempt_enable();
-
 		return;
 
 	case 2:
@@ -716,6 +788,22 @@
 	      (regs->cp0_status & ST0_TS) ? "" : "not ");
 }
 
+asmlinkage void do_mt(struct pt_regs *regs)
+{
+	die_if_kernel("MIPS MT Thread exception in kernel", regs);
+
+	force_sig(SIGILL, current);
+}
+
+
+asmlinkage void do_dsp(struct pt_regs *regs)
+{
+	if (cpu_has_dsp)
+		panic("Unexpected DSP exception\n");
+
+	force_sig(SIGILL, current);
+}
+
 asmlinkage void do_reserved(struct pt_regs *regs)
 {
 	/*
@@ -728,6 +816,12 @@
 	      (regs->cp0_cause & 0x7f) >> 2);
 }
 
+asmlinkage void do_default_vi(struct pt_regs *regs)
+{
+	show_regs(regs);
+	panic("Caught unexpected vectored interrupt.");
+}
+
 /*
  * Some MIPS CPUs can enable/disable for cache parity detection, but do
  * it different ways.
@@ -736,16 +830,12 @@
 {
 	switch (current_cpu_data.cputype) {
 	case CPU_24K:
-		/* 24K cache parity not currently implemented in FPGA */
-		printk(KERN_INFO "Disable cache parity protection for "
-		       "MIPS 24K CPU.\n");
-		write_c0_ecc(read_c0_ecc() & ~0x80000000);
-		break;
 	case CPU_5KC:
-		/* Set the PE bit (bit 31) in the c0_ecc register. */
-		printk(KERN_INFO "Enable cache parity protection for "
-		       "MIPS 5KC/24K CPUs.\n");
-		write_c0_ecc(read_c0_ecc() | 0x80000000);
+		write_c0_ecc(0x80000000);
+		back_to_back_c0_hazard();
+		/* Set the PE bit (bit 31) in the c0_errctl register. */
+		printk(KERN_INFO "Cache parity protection %sabled\n",
+		       (read_c0_ecc() & 0x80000000) ? "en" : "dis");
 		break;
 	case CPU_20KC:
 	case CPU_25KF:
@@ -783,7 +873,7 @@
 	       reg_val & (1<<22) ? "E0 " : "");
 	printk("IDX: 0x%08x\n", reg_val & ((1<<22)-1));
 
-#if defined(CONFIG_CPU_MIPS32) || defined (CONFIG_CPU_MIPS64)
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
 	if (reg_val & (1<<22))
 		printk("DErrAddr0: 0x%0*lx\n", field, read_c0_derraddr0());
 
@@ -840,7 +930,11 @@
 	while(1) ;
 }
 
+#define VECTORSPACING 0x100	/* for EI/VI mode */
+
+unsigned long ebase;
 unsigned long exception_handlers[32];
+unsigned long vi_handlers[64];
 
 /*
  * As a side effect of the way this is implemented we're limited
@@ -854,13 +948,156 @@
 
 	exception_handlers[n] = handler;
 	if (n == 0 && cpu_has_divec) {
-		*(volatile u32 *)(CAC_BASE + 0x200) = 0x08000000 |
+		*(volatile u32 *)(ebase + 0x200) = 0x08000000 |
 		                                 (0x03ffffff & (handler >> 2));
-		flush_icache_range(CAC_BASE + 0x200, CAC_BASE + 0x204);
+		flush_icache_range(ebase + 0x200, ebase + 0x204);
+	}
+	return (void *)old_handler;
+}
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Shadow register allocation
+ * FIXME: SMP...
+ */
+
+/* MIPSR2 shadow register sets */
+struct shadow_registers {
+	spinlock_t sr_lock;	/*  */
+	int sr_supported;	/* Number of shadow register sets supported */
+	int sr_allocated;	/* Bitmap of allocated shadow registers */
+} shadow_registers;
+
+void mips_srs_init(void)
+{
+#ifdef CONFIG_CPU_MIPSR2_SRS
+	shadow_registers.sr_supported = ((read_c0_srsctl() >> 26) & 0x0f) + 1;
+	printk ("%d MIPSR2 register sets available\n", shadow_registers.sr_supported);
+#else
+	shadow_registers.sr_supported = 1;
+#endif
+	shadow_registers.sr_allocated = 1;	/* Set 0 used by kernel */
+	spin_lock_init(&shadow_registers.sr_lock);
+}
+
+int mips_srs_max(void)
+{
+	return shadow_registers.sr_supported;
+}
+
+int mips_srs_alloc (void)
+{
+	struct shadow_registers *sr = &shadow_registers;
+	unsigned long flags;
+	int set;
+
+	spin_lock_irqsave(&sr->sr_lock, flags);
+
+	for (set = 0; set < sr->sr_supported; set++) {
+		if ((sr->sr_allocated & (1 << set)) == 0) {
+			sr->sr_allocated |= 1 << set;
+			spin_unlock_irqrestore(&sr->sr_lock, flags);
+			return set;
+		}
 	}
+
+	/* None available */
+	spin_unlock_irqrestore(&sr->sr_lock, flags);
+	return -1;
+}
+
+void mips_srs_free (int set)
+{
+	struct shadow_registers *sr = &shadow_registers;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sr->sr_lock, flags);
+	sr->sr_allocated &= ~(1 << set);
+	spin_unlock_irqrestore(&sr->sr_lock, flags);
+}
+
+void *set_vi_srs_handler (int n, void *addr, int srs)
+{
+	unsigned long handler;
+	unsigned long old_handler = vi_handlers[n];
+	u32 *w;
+	unsigned char *b;
+
+	if (!cpu_has_veic && !cpu_has_vint)
+		BUG();
+
+	if (addr == NULL) {
+		handler = (unsigned long) do_default_vi;
+		srs = 0;
+	}
+	else
+		handler = (unsigned long) addr;
+	vi_handlers[n] = (unsigned long) addr;
+
+	b = (unsigned char *)(ebase + 0x200 + n*VECTORSPACING);
+
+	if (srs >= mips_srs_max())
+		panic("Shadow register set %d not supported", srs);
+
+	if (cpu_has_veic) {
+		if (board_bind_eic_interrupt)
+			board_bind_eic_interrupt (n, srs);
+	}
+	else if (cpu_has_vint) {
+		/* SRSMap is only defined if shadow sets are implemented */
+		if (mips_srs_max() > 1)
+			change_c0_srsmap (0xf << n*4, srs << n*4);
+	}
+
+	if (srs == 0) {
+		/*
+		 * If no shadow set is selected then use the default handler
+		 * that does normal register saving and a standard interrupt exit
+		 */
+
+		extern char except_vec_vi, except_vec_vi_lui;
+		extern char except_vec_vi_ori, except_vec_vi_end;
+		const int handler_len = &except_vec_vi_end - &except_vec_vi;
+		const int lui_offset = &except_vec_vi_lui - &except_vec_vi;
+		const int ori_offset = &except_vec_vi_ori - &except_vec_vi;
+
+		if (handler_len > VECTORSPACING) {
+			/*
+			 * Sigh... panicing won't help as the console
+			 * is probably not configured :(
+			 */
+			panic ("VECTORSPACING too small");
+		}
+
+		memcpy (b, &except_vec_vi, handler_len);
+		w = (u32 *)(b + lui_offset);
+		*w = (*w & 0xffff0000) | (((u32)handler >> 16) & 0xffff);
+		w = (u32 *)(b + ori_offset);
+		*w = (*w & 0xffff0000) | ((u32)handler & 0xffff);
+		flush_icache_range((unsigned long)b, (unsigned long)(b+handler_len));
+	}
+	else {
+		/*
+		 * In other cases jump directly to the interrupt handler
+		 *
+		 * It is the handlers responsibility to save registers if required
+		 * (eg hi/lo) and return from the exception using "eret"
+		 */
+		w = (u32 *)b;
+		*w++ = 0x08000000 | (((u32)handler >> 2) & 0x03fffff); /* j handler */
+		*w = 0;
+		flush_icache_range((unsigned long)b, (unsigned long)(b+8));
+	}
+
 	return (void *)old_handler;
 }
 
+void *set_vi_handler (int n, void *addr)
+{
+	return set_vi_srs_handler (n, addr, 0);
+}
+#endif
+
 /*
  * This is used by native signal handling
  */
@@ -912,6 +1149,7 @@
 
 extern void cpu_cache_init(void);
 extern void tlb_init(void);
+extern void flush_tlb_handlers(void);
 
 void __init per_cpu_trap_init(void)
 {
@@ -929,15 +1167,32 @@
 #endif
 	if (current_cpu_data.isa_level == MIPS_CPU_ISA_IV)
 		status_set |= ST0_XX;
-	change_c0_status(ST0_CU|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
+	change_c0_status(ST0_CU|ST0_MX|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
+	if (cpu_has_dsp)
+		set_c0_status(ST0_MX);
+
+#ifdef CONFIG_CPU_MIPSR2
+	write_c0_hwrena (0x0000000f); /* Allow rdhwr to all registers */
+#endif
+
 	/*
-	 * Some MIPS CPUs have a dedicated interrupt vector which reduces the
-	 * interrupt processing overhead.  Use it where available.
+	 * Interrupt handling.
 	 */
-	if (cpu_has_divec)
-		set_c0_cause(CAUSEF_IV);
+	if (cpu_has_veic || cpu_has_vint) {
+		write_c0_ebase (ebase);
+		/* Setting vector spacing enables EI/VI mode  */
+		change_c0_intctl (0x3e0, VECTORSPACING);
+	}
+	if (cpu_has_divec) {
+		if (cpu_has_mipsmt) {
+			unsigned int vpflags = dvpe();
+			set_c0_cause(CAUSEF_IV);
+			evpe(vpflags);
+		} else
+			set_c0_cause(CAUSEF_IV);
+	}
 
 	cpu_data[cpu].asid_cache = ASID_FIRST_VERSION;
 	TLBMISS_HANDLER_SETUP();
@@ -951,13 +1206,41 @@
 	tlb_init();
 }
 
+/* Install CPU exception handler */
+void __init set_handler (unsigned long offset, void *addr, unsigned long size)
+{
+	memcpy((void *)(ebase + offset), addr, size);
+	flush_icache_range(ebase + offset, ebase + offset + size);
+}
+
+/* Install uncached CPU exception handler */
+void __init set_uncached_handler (unsigned long offset, void *addr, unsigned long size)
+{
+#ifdef CONFIG_32BIT
+	unsigned long uncached_ebase = KSEG1ADDR(ebase);
+#endif
+#ifdef CONFIG_64BIT
+	unsigned long uncached_ebase = TO_UNCAC(ebase);
+#endif
+
+	memcpy((void *)(uncached_ebase + offset), addr, size);
+}
+
 void __init trap_init(void)
 {
 	extern char except_vec3_generic, except_vec3_r4000;
-	extern char except_vec_ejtag_debug;
 	extern char except_vec4;
 	unsigned long i;
 
+	if (cpu_has_veic || cpu_has_vint)
+		ebase = (unsigned long) alloc_bootmem_low_pages (0x200 + VECTORSPACING*64);
+	else
+		ebase = CAC_BASE;
+
+#ifdef CONFIG_CPU_MIPSR2
+	mips_srs_init();
+#endif
+
 	per_cpu_trap_init();
 
 	/*
@@ -965,7 +1248,7 @@
 	 * This will be overriden later as suitable for a particular
 	 * configuration.
 	 */
-	memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
+	set_handler(0x180, &except_vec3_generic, 0x80);
 
 	/*
 	 * Setup default vectors
@@ -977,8 +1260,8 @@
 	 * Copy the EJTAG debug exception vector handler code to it's final
 	 * destination.
 	 */
-	if (cpu_has_ejtag)
-		memcpy((void *)(CAC_BASE + 0x300), &except_vec_ejtag_debug, 0x80);
+	if (cpu_has_ejtag && board_ejtag_handler_setup)
+		board_ejtag_handler_setup ();
 
 	/*
 	 * Only some CPUs have the watch exceptions.
@@ -987,11 +1270,15 @@
 		set_except_vector(23, handle_watch);
 
 	/*
-	 * Some MIPS CPUs have a dedicated interrupt vector which reduces the
-	 * interrupt processing overhead.  Use it where available.
+	 * Initialise interrupt handlers
 	 */
-	if (cpu_has_divec)
-		memcpy((void *)(CAC_BASE + 0x200), &except_vec4, 0x8);
+	if (cpu_has_veic || cpu_has_vint) {
+		int nvec = cpu_has_veic ? 64 : 8;
+		for (i = 0; i < nvec; i++)
+			set_vi_handler (i, NULL);
+	}
+	else if (cpu_has_divec)
+		set_handler(0x200, &except_vec4, 0x8);
 
 	/*
 	 * Some CPUs can enable/disable for cache parity detection, but does
@@ -1023,21 +1310,6 @@
 	set_except_vector(11, handle_cpu);
 	set_except_vector(12, handle_ov);
 	set_except_vector(13, handle_tr);
-	set_except_vector(22, handle_mdmx);
-
-	if (cpu_has_fpu && !cpu_has_nofpuex)
-		set_except_vector(15, handle_fpe);
-
-	if (cpu_has_mcheck)
-		set_except_vector(24, handle_mcheck);
-
-	if (cpu_has_vce)
-		/* Special exception: R4[04]00 uses also the divec space. */
-		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
-	else if (cpu_has_4kex)
-		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
-	else
-		memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
 
 	if (current_cpu_data.cputype == CPU_R6000 ||
 	    current_cpu_data.cputype == CPU_R6000A) {
@@ -1053,10 +1325,37 @@
 		//set_except_vector(15, handle_ndc);
 	}
 
+
+	if (board_nmi_handler_setup)
+		board_nmi_handler_setup();
+
+	if (cpu_has_fpu && !cpu_has_nofpuex)
+		set_except_vector(15, handle_fpe);
+
+	set_except_vector(22, handle_mdmx);
+
+	if (cpu_has_mcheck)
+		set_except_vector(24, handle_mcheck);
+
+	if (cpu_has_mipsmt)
+		set_except_vector(25, handle_mt);
+
+	if (cpu_has_dsp)
+		set_except_vector(26, handle_dsp);
+
+	if (cpu_has_vce)
+		/* Special exception: R4[04]00 uses also the divec space. */
+		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
+	else if (cpu_has_4kex)
+		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
+	else
+		memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
+
 	signal_init();
 #ifdef CONFIG_MIPS32_COMPAT
 	signal32_init();
 #endif
 
-	flush_icache_range(CAC_BASE, CAC_BASE + 0x400);
+	flush_icache_range(ebase, ebase + 0x400);
+	flush_tlb_handlers();
 }
diff -Naur linux-2.6.14/arch/mips/kernel/unaligned.c linux-mips-2.6.14.orig/arch/mips/kernel/unaligned.c
--- linux-2.6.14/arch/mips/kernel/unaligned.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/unaligned.c	2005-11-17 11:42:23.000000000 -0800
@@ -94,7 +94,7 @@
 #endif
 
 static inline int emulate_load_store_insn(struct pt_regs *regs,
-	void *addr, unsigned long pc,
+	void __user *addr, unsigned int __user *pc,
 	unsigned long **regptr, unsigned long *newvalue)
 {
 	union mips_instruction insn;
@@ -107,7 +107,7 @@
 	/*
 	 * This load never faults.
 	 */
-	__get_user(insn.word, (unsigned int *)pc);
+	__get_user(insn.word, pc);
 
 	switch (insn.i_format.opcode) {
 	/*
@@ -494,8 +494,8 @@
 {
 	unsigned long *regptr, newval;
 	extern int do_dsemulret(struct pt_regs *);
+	unsigned int __user *pc;
 	mm_segment_t seg;
-	unsigned long pc;
 
 	/*
 	 * Address errors may be deliberately induced by the FPU emulator to
@@ -515,7 +515,7 @@
 	if ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))
 		goto sigbus;
 
-	pc = exception_epc(regs);
+	pc = (unsigned int __user *) exception_epc(regs);
 	if ((current->thread.mflags & MF_FIXADE) == 0)
 		goto sigbus;
 
@@ -526,7 +526,7 @@
 	seg = get_fs();
 	if (!user_mode(regs))
 		set_fs(KERNEL_DS);
-	if (!emulate_load_store_insn(regs, (void *)regs->cp0_badvaddr, pc,
+	if (!emulate_load_store_insn(regs, (void __user *)regs->cp0_badvaddr, pc,
 	                             &regptr, &newval)) {
 		compute_return_epc(regs);
 		/*
diff -Naur linux-2.6.14/arch/mips/kernel/vmlinux.lds.S linux-mips-2.6.14.orig/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.14/arch/mips/kernel/vmlinux.lds.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/kernel/vmlinux.lds.S	2005-11-17 11:42:23.000000000 -0800
@@ -54,13 +54,6 @@
 
     *(.data)
 
-   /* Align the initial ramdisk image (INITRD) on page boundaries. */
-   . = ALIGN(4096);
-   __rd_start = .;
-   *(.initrd)
-   . = ALIGN(4096);
-   __rd_end = .;
-
     CONSTRUCTORS
   }
   _gp = . + 0x8000;
@@ -96,12 +89,6 @@
   .init.setup : { *(.init.setup) }
   __setup_end = .;
 
-  .early_initcall.init : {
-  __earlyinitcall_start = .;
-	*(.initcall.early1.init)
-  }
-  __earlyinitcall_end = .;
-
   __initcall_start = .;
   .initcall.init : {
 	*(.initcall1.init)
diff -Naur linux-2.6.14/arch/mips/kernel/vpe.c linux-mips-2.6.14.orig/arch/mips/kernel/vpe.c
--- linux-2.6.14/arch/mips/kernel/vpe.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/kernel/vpe.c	2005-11-17 11:42:23.000000000 -0800
@@ -0,0 +1,1296 @@
+/*
+ * Copyright (C) 2004, 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+/*
+ * VPE support module
+ *
+ * Provides support for loading a MIPS SP program on VPE1.
+ * The SP enviroment is rather simple, no tlb's.  It needs to be relocatable
+ * (or partially linked). You should initialise your stack in the startup
+ * code. This loader looks for the symbol __start and sets up
+ * execution to resume from there. The MIPS SDE kit contains suitable examples.
+ *
+ * To load and run, simply cat a SP 'program file' to /dev/vpe1.
+ * i.e cat spapp >/dev/vpe1.
+ *
+ * You'll need to have the following device files.
+ * mknod /dev/vpe0 c 63 0
+ * mknod /dev/vpe1 c 63 1
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+#include <linux/elf.h>
+#include <linux/seq_file.h>
+#include <linux/syscalls.h>
+#include <linux/moduleloader.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/bootmem.h>
+#include <asm/mipsregs.h>
+#include <asm/mipsmtregs.h>
+#include <asm/cacheflush.h>
+#include <asm/atomic.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+
+typedef void *vpe_handle;
+
+// defined here because the kernel module loader doesn't have
+// anything to do with it.
+#define SHN_MIPS_SCOMMON 0xff03
+
+#ifndef ARCH_SHF_SMALL
+#define ARCH_SHF_SMALL 0
+#endif
+
+/* If this is set, the section belongs in the init part of the module */
+#define INIT_OFFSET_MASK (1UL << (BITS_PER_LONG-1))
+
+// temp number,
+#define VPE_MAJOR 63
+
+static char module_name[] = "vpe";
+static int major = 0;
+
+/* grab the likely amount of memory we will need. */
+#ifdef CONFIG_MIPS_VPE_LOADER_TOM
+#define P_SIZE (2 * 1024 * 1024)
+#else
+/* add an overhead to the max kmalloc size for non-striped symbols/etc */
+#define P_SIZE (256 * 1024)
+#endif
+
+#define MAX_VPES 16
+
+enum vpe_state {
+	VPE_STATE_UNUSED = 0,
+	VPE_STATE_INUSE,
+	VPE_STATE_RUNNING
+};
+
+enum tc_state {
+	TC_STATE_UNUSED = 0,
+	TC_STATE_INUSE,
+	TC_STATE_RUNNING,
+	TC_STATE_DYNAMIC
+};
+
+struct vpe;
+typedef struct tc {
+	enum tc_state state;
+	int index;
+
+	/* parent VPE */
+	struct vpe *pvpe;
+
+	/* The list of TC's with this VPE */
+	struct list_head tc;
+
+	/* The global list of tc's */
+	struct list_head list;
+} tc_t;
+
+typedef struct vpe {
+	enum vpe_state state;
+
+	/* (device) minor associated with this vpe */
+	int minor;
+
+	/* elfloader stuff */
+	void *load_addr;
+	u32 len;
+	char *pbuffer;
+	u32 plen;
+
+	unsigned long __start;
+
+	/* tc's associated with this vpe */
+	struct list_head tc;
+
+	/* The list of vpe's */
+	struct list_head list;
+
+	/* shared symbol address */
+	void *shared_ptr;
+} vpe_t;
+
+struct vpecontrol_ {
+	/* Virtual processing elements */
+	struct list_head vpe_list;
+
+	/* Thread contexts */
+	struct list_head tc_list;
+} vpecontrol;
+
+static void release_progmem(void *ptr);
+static void dump_vpe(vpe_t * v);
+extern void save_gp_address(unsigned int secbase, unsigned int rel);
+
+/* get the vpe associated with this minor */
+struct vpe *get_vpe(int minor)
+{
+	struct vpe *v;
+
+	list_for_each_entry(v, &vpecontrol.vpe_list, list) {
+		if (v->minor == minor)
+			return v;
+	}
+
+	printk(KERN_DEBUG "VPE: get_vpe minor %d not found\n", minor);
+	return NULL;
+}
+
+/* get the vpe associated with this minor */
+struct tc *get_tc(int index)
+{
+	struct tc *t;
+
+	list_for_each_entry(t, &vpecontrol.tc_list, list) {
+		if (t->index == index)
+			return t;
+	}
+
+	printk(KERN_DEBUG "VPE: get_tc index %d not found\n", index);
+
+	return NULL;
+}
+
+struct tc *get_tc_unused(void)
+{
+	struct tc *t;
+
+	list_for_each_entry(t, &vpecontrol.tc_list, list) {
+		if (t->state == TC_STATE_UNUSED)
+			return t;
+	}
+
+	printk(KERN_DEBUG "VPE: All TC's are in use\n");
+
+	return NULL;
+}
+
+/* allocate a vpe and associate it with this minor (or index) */
+struct vpe *alloc_vpe(int minor)
+{
+	struct vpe *v;
+
+	if ((v = kmalloc(sizeof(struct vpe), GFP_KERNEL)) == NULL) {
+		printk(KERN_WARNING "VPE: alloc_vpe no mem\n");
+		return NULL;
+	}
+
+	memset(v, 0, sizeof(struct vpe));
+
+	INIT_LIST_HEAD(&v->tc);
+	list_add_tail(&v->list, &vpecontrol.vpe_list);
+
+	v->minor = minor;
+	return v;
+}
+
+/* allocate a tc. At startup only tc0 is running, all other can be halted. */
+struct tc *alloc_tc(int index)
+{
+	struct tc *t;
+
+	if ((t = kmalloc(sizeof(struct tc), GFP_KERNEL)) == NULL) {
+		printk(KERN_WARNING "VPE: alloc_tc no mem\n");
+		return NULL;
+	}
+
+	memset(t, 0, sizeof(struct tc));
+
+	INIT_LIST_HEAD(&t->tc);
+	list_add_tail(&t->list, &vpecontrol.tc_list);
+
+	t->index = index;
+
+	return t;
+}
+
+/* clean up and free everything */
+void release_vpe(struct vpe *v)
+{
+	list_del(&v->list);
+	if (v->load_addr)
+		release_progmem(v);
+	kfree(v);
+}
+
+void dump_mtregs(void)
+{
+	unsigned long val;
+
+	val = read_c0_config3();
+	printk("config3 0x%lx MT %ld\n", val,
+	       (val & CONFIG3_MT) >> CONFIG3_MT_SHIFT);
+
+	val = read_c0_mvpconf0();
+	printk("mvpconf0 0x%lx, PVPE %ld PTC %ld M %ld\n", val,
+	       (val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT,
+	       val & MVPCONF0_PTC, (val & MVPCONF0_M) >> MVPCONF0_M_SHIFT);
+
+	val = read_c0_mvpcontrol();
+	printk("MVPControl 0x%lx, STLB %ld VPC %ld EVP %ld\n", val,
+	       (val & MVPCONTROL_STLB) >> MVPCONTROL_STLB_SHIFT,
+	       (val & MVPCONTROL_VPC) >> MVPCONTROL_VPC_SHIFT,
+	       (val & MVPCONTROL_EVP));
+
+	val = read_c0_vpeconf0();
+	printk("VPEConf0 0x%lx MVP %ld\n", val,
+	       (val & VPECONF0_MVP) >> VPECONF0_MVP_SHIFT);
+}
+
+/* Find some VPE program space  */
+static void *alloc_progmem(u32 len)
+{
+#ifdef CONFIG_MIPS_VPE_LOADER_TOM
+	/* this means you must tell linux to use less memory than you physically have */
+	return (void *)((max_pfn * PAGE_SIZE) + KSEG0);
+#else
+	// simple grab some mem for now
+	return kmalloc(len, GFP_KERNEL);
+#endif
+}
+
+static void release_progmem(void *ptr)
+{
+#ifndef CONFIG_MIPS_VPE_LOADER_TOM
+	kfree(ptr);
+#endif
+}
+
+/* Update size with this section: return offset. */
+static long get_offset(unsigned long *size, Elf_Shdr * sechdr)
+{
+	long ret;
+
+	ret = ALIGN(*size, sechdr->sh_addralign ? : 1);
+	*size = ret + sechdr->sh_size;
+	return ret;
+}
+
+/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld
+   might -- code, read-only data, read-write data, small data.  Tally
+   sizes, and place the offsets into sh_entsize fields: high bit means it
+   belongs in init. */
+static void layout_sections(struct module *mod, const Elf_Ehdr * hdr,
+			    Elf_Shdr * sechdrs, const char *secstrings)
+{
+	static unsigned long const masks[][2] = {
+		/* NOTE: all executable code must be the first section
+		 * in this array; otherwise modify the text_size
+		 * finder in the two loops below */
+		{SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL},
+		{SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL},
+		{SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL},
+		{ARCH_SHF_SMALL | SHF_ALLOC, 0}
+	};
+	unsigned int m, i;
+
+	for (i = 0; i < hdr->e_shnum; i++)
+		sechdrs[i].sh_entsize = ~0UL;
+
+	for (m = 0; m < ARRAY_SIZE(masks); ++m) {
+		for (i = 0; i < hdr->e_shnum; ++i) {
+			Elf_Shdr *s = &sechdrs[i];
+
+			//  || strncmp(secstrings + s->sh_name, ".init", 5) == 0)
+			if ((s->sh_flags & masks[m][0]) != masks[m][0]
+			    || (s->sh_flags & masks[m][1])
+			    || s->sh_entsize != ~0UL)
+				continue;
+			s->sh_entsize = get_offset(&mod->core_size, s);
+		}
+
+		if (m == 0)
+			mod->core_text_size = mod->core_size;
+
+	}
+}
+
+
+/* from module-elf32.c, but subverted a little */
+
+struct mips_hi16 {
+	struct mips_hi16 *next;
+	Elf32_Addr *addr;
+	Elf32_Addr value;
+};
+
+static struct mips_hi16 *mips_hi16_list;
+static unsigned int gp_offs, gp_addr;
+
+static int apply_r_mips_none(struct module *me, uint32_t *location,
+			     Elf32_Addr v)
+{
+	return 0;
+}
+
+static int apply_r_mips_gprel16(struct module *me, uint32_t *location,
+				Elf32_Addr v)
+{
+	int rel;
+
+	if( !(*location & 0xffff) ) {
+		rel = (int)v - gp_addr;
+	}
+	else {
+		/* .sbss + gp(relative) + offset */
+		/* kludge! */
+		rel =  (int)(short)((int)v + gp_offs +
+				    (int)(short)(*location & 0xffff) - gp_addr);
+	}
+
+	if( (rel > 32768) || (rel < -32768) ) {
+		printk(KERN_ERR
+		       "apply_r_mips_gprel16: relative address out of range 0x%x %d\n",
+		       rel, rel);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & 0xffff0000) | (rel & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_pc16(struct module *me, uint32_t *location,
+			     Elf32_Addr v)
+{
+	int rel;
+	rel = (((unsigned int)v - (unsigned int)location));
+	rel >>= 2;		// because the offset is in _instructions_ not bytes.
+	rel -= 1;		// and one instruction less due to the branch delay slot.
+
+	if( (rel > 32768) || (rel < -32768) ) {
+		printk(KERN_ERR
+		       "apply_r_mips_pc16: relative address out of range 0x%x\n", rel);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & 0xffff0000) | (rel & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_32(struct module *me, uint32_t *location,
+			   Elf32_Addr v)
+{
+	*location += v;
+
+	return 0;
+}
+
+static int apply_r_mips_26(struct module *me, uint32_t *location,
+			   Elf32_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation mod4\n", me->name);
+		return -ENOEXEC;
+	}
+
+/* Not desperately convinced this is a good check of an overflow condition
+   anyway. But it gets in the way of handling undefined weak symbols which
+   we want to set to zero.
+   if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+   printk(KERN_ERR
+   "module %s: relocation overflow\n",
+   me->name);
+   return -ENOEXEC;
+   }
+*/
+
+	*location = (*location & ~0x03ffffff) |
+		((*location + (v >> 2)) & 0x03ffffff);
+	return 0;
+}
+
+static int apply_r_mips_hi16(struct module *me, uint32_t *location,
+			     Elf32_Addr v)
+{
+	struct mips_hi16 *n;
+
+	/*
+	 * We cannot relocate this one now because we don't know the value of
+	 * the carry we need to add.  Save the information, and let LO16 do the
+	 * actual relocation.
+	 */
+	n = kmalloc(sizeof *n, GFP_KERNEL);
+	if (!n)
+		return -ENOMEM;
+
+	n->addr = location;
+	n->value = v;
+	n->next = mips_hi16_list;
+	mips_hi16_list = n;
+
+	return 0;
+}
+
+static int apply_r_mips_lo16(struct module *me, uint32_t *location,
+			     Elf32_Addr v)
+{
+	unsigned long insnlo = *location;
+	Elf32_Addr val, vallo;
+
+	/* Sign extend the addend we extract from the lo insn.  */
+	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
+
+	if (mips_hi16_list != NULL) {
+		struct mips_hi16 *l;
+
+		l = mips_hi16_list;
+		while (l != NULL) {
+			struct mips_hi16 *next;
+			unsigned long insn;
+
+			/*
+			 * The value for the HI16 had best be the same.
+			 */
+			if (v != l->value) {
+				printk("%d != %d\n", v, l->value);
+				goto out_danger;
+			}
+
+
+			/*
+			 * Do the HI16 relocation.  Note that we actually don't
+			 * need to know anything about the LO16 itself, except
+			 * where to find the low 16 bits of the addend needed
+			 * by the LO16.
+			 */
+			insn = *l->addr;
+			val = ((insn & 0xffff) << 16) + vallo;
+			val += v;
+
+			/*
+			 * Account for the sign extension that will happen in
+			 * the low bits.
+			 */
+			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
+
+			insn = (insn & ~0xffff) | val;
+			*l->addr = insn;
+
+			next = l->next;
+			kfree(l);
+			l = next;
+		}
+
+		mips_hi16_list = NULL;
+	}
+
+	/*
+	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
+	 */
+	val = v + vallo;
+	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
+	*location = insnlo;
+
+	return 0;
+
+out_danger:
+	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
+
+	return -ENOEXEC;
+}
+
+static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
+				Elf32_Addr v) = {
+	[R_MIPS_NONE]	= apply_r_mips_none,
+	[R_MIPS_32]	= apply_r_mips_32,
+	[R_MIPS_26]	= apply_r_mips_26,
+	[R_MIPS_HI16]	= apply_r_mips_hi16,
+	[R_MIPS_LO16]	= apply_r_mips_lo16,
+	[R_MIPS_GPREL16] = apply_r_mips_gprel16,
+	[R_MIPS_PC16] = apply_r_mips_pc16
+};
+
+
+int apply_relocations(Elf32_Shdr *sechdrs,
+		      const char *strtab,
+		      unsigned int symindex,
+		      unsigned int relsec,
+		      struct module *me)
+{
+	Elf32_Rel *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	uint32_t *location;
+	unsigned int i;
+	Elf32_Addr v;
+	int res;
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		Elf32_Word r_info = rel[i].r_info;
+
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(r_info);
+
+		if (!sym->st_value) {
+			printk(KERN_DEBUG "%s: undefined weak symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			/* just print the warning, dont barf */
+		}
+
+		v = sym->st_value;
+
+		res = reloc_handlers[ELF32_R_TYPE(r_info)](me, location, v);
+		if( res ) {
+			printk(KERN_DEBUG
+			       "relocation error 0x%x sym refer <%s> value 0x%x "
+			       "type 0x%x r_info 0x%x\n",
+			       (unsigned int)location, strtab + sym->st_name, v,
+			       r_info, ELF32_R_TYPE(r_info));
+		}
+
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
+void save_gp_address(unsigned int secbase, unsigned int rel)
+{
+	gp_addr = secbase + rel;
+	gp_offs = gp_addr - (secbase & 0xffff0000);
+}
+/* end module-elf32.c */
+
+
+
+/* Change all symbols so that sh_value encodes the pointer directly. */
+static int simplify_symbols(Elf_Shdr * sechdrs,
+			    unsigned int symindex,
+			    const char *strtab,
+			    const char *secstrings,
+			    unsigned int nsecs, struct module *mod)
+{
+	Elf_Sym *sym = (void *)sechdrs[symindex].sh_addr;
+	unsigned long secbase, bssbase = 0;
+	unsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
+	int ret = 0, size;
+
+	/* find the .bss section for COMMON symbols */
+	for (i = 0; i < nsecs; i++) {
+		if (strncmp(secstrings + sechdrs[i].sh_name, ".bss", 4) == 0)
+			bssbase = sechdrs[i].sh_addr;
+	}
+
+	for (i = 1; i < n; i++) {
+		switch (sym[i].st_shndx) {
+		case SHN_COMMON:
+			/* Allocate space for the symbol in the .bss section. st_value is currently size.
+			   We want it to have the address of the symbol. */
+
+			size = sym[i].st_value;
+			sym[i].st_value = bssbase;
+
+			bssbase += size;
+			break;
+
+		case SHN_ABS:
+			/* Don't need to do anything */
+			break;
+
+		case SHN_UNDEF:
+			/* ret = -ENOENT; */
+			break;
+
+		case SHN_MIPS_SCOMMON:
+
+			printk(KERN_DEBUG
+			       "simplify_symbols: ignoring SHN_MIPS_SCOMMON symbol <%s> st_shndx %d\n",
+			       strtab + sym[i].st_name, sym[i].st_shndx);
+
+			// .sbss section
+			break;
+
+		default:
+			secbase = sechdrs[sym[i].st_shndx].sh_addr;
+
+			if (strncmp(strtab + sym[i].st_name, "_gp", 3) == 0) {
+				save_gp_address(secbase, sym[i].st_value);
+			}
+
+			sym[i].st_value += secbase;
+			break;
+		}
+
+	}
+
+	return ret;
+}
+
+#ifdef DEBUG_ELFLOADER
+static void dump_elfsymbols(Elf_Shdr * sechdrs, unsigned int symindex,
+			    const char *strtab, struct module *mod)
+{
+	Elf_Sym *sym = (void *)sechdrs[symindex].sh_addr;
+	unsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
+
+	printk(KERN_DEBUG "dump_elfsymbols: n %d\n", n);
+	for (i = 1; i < n; i++) {
+		printk(KERN_DEBUG " i %d name <%s> 0x%x\n", i,
+		       strtab + sym[i].st_name, sym[i].st_value);
+	}
+}
+#endif
+
+static void dump_tc(struct tc *t)
+{
+	printk(KERN_WARNING "VPE: TC index %d TCStatus 0x%lx halt 0x%lx\n",
+	       t->index, read_tc_c0_tcstatus(), read_tc_c0_tchalt());
+	printk(KERN_WARNING "VPE: tcrestart 0x%lx\n", read_tc_c0_tcrestart());
+}
+
+static void dump_tclist(void)
+{
+	struct tc *t;
+
+	list_for_each_entry(t, &vpecontrol.tc_list, list) {
+		dump_tc(t);
+	}
+}
+
+/* We are prepared so configure and start the VPE... */
+int vpe_run(vpe_t * v)
+{
+	unsigned long val;
+	struct tc *t;
+
+	/* check we are the Master VPE */
+	val = read_c0_vpeconf0();
+	if (!(val & VPECONF0_MVP)) {
+		printk(KERN_WARNING
+		       "VPE: only Master VPE's are allowed to configure MT\n");
+		return -1;
+	}
+
+	/* disable MT (using dvpe) */
+	dvpe();
+
+	/* Put MVPE's into 'configuration state' */
+	set_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	if (!list_empty(&v->tc)) {
+		if ((t = list_entry(v->tc.next, struct tc, tc)) == NULL) {
+			printk(KERN_WARNING "VPE: TC %d is already in use.\n",
+			       t->index);
+			return -ENOEXEC;
+		}
+	} else {
+		printk(KERN_WARNING "VPE: No TC's associated with VPE %d\n",
+		       v->minor);
+		return -ENOEXEC;
+	}
+
+	settc(t->index);
+
+	val = read_vpe_c0_vpeconf0();
+
+	/* should check it is halted, and not activated */
+	if ((read_tc_c0_tcstatus() & TCSTATUS_A) || !(read_tc_c0_tchalt() & TCHALT_H)) {
+		printk(KERN_WARNING "VPE: TC %d is already doing something!\n",
+		       t->index);
+
+		dump_tclist();
+		return -ENOEXEC;
+	}
+
+	/* Write the address we want it to start running from in the TCPC register. */
+	write_tc_c0_tcrestart((unsigned long)v->__start);
+
+	/* write the sivc_info address to tccontext */
+	write_tc_c0_tccontext((unsigned long)0);
+
+	/* Set up the XTC bit in vpeconf0 to point at our tc */
+	write_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() | (t->index << VPECONF0_XTC_SHIFT));
+
+	/* mark the TC as activated, not interrupt exempt and not dynamically allocatable */
+	val = read_tc_c0_tcstatus();
+	val = (val & ~(TCSTATUS_DA | TCSTATUS_IXMT)) | TCSTATUS_A;
+	write_tc_c0_tcstatus(val);
+
+	write_tc_c0_tchalt(read_tc_c0_tchalt() & ~TCHALT_H);
+
+	/* set up VPE1 */
+	write_vpe_c0_vpecontrol(read_vpe_c0_vpecontrol() & ~VPECONTROL_TE);	// no multiple TC's
+	write_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() | VPECONF0_VPA);	// enable this VPE
+
+	/*
+	 * The sde-kit passes 'memsize' to __start in $a3, so set something
+	 * here...
+	 * Or set $a3 (register 7) to zero and define DFLT_STACK_SIZE and
+	 * DFLT_HEAP_SIZE when you compile your program
+	 */
+
+	mttgpr(7, 0);
+
+	/* set config to be the same as vpe0, particularly kseg0 coherency alg */
+	write_vpe_c0_config(read_c0_config());
+
+	/* clear out any left overs from a previous program */
+	write_vpe_c0_cause(0);
+
+	/* take system out of configuration state */
+	clear_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	/* clear interrupts enabled IE, ERL, EXL, and KSU from c0 status */
+	write_vpe_c0_status(read_vpe_c0_status() & ~(ST0_ERL | ST0_KSU | ST0_IE | ST0_EXL));
+
+	/* set it running */
+	evpe(EVPE_ENABLE);
+
+	return 0;
+}
+
+static unsigned long find_vpe_symbols(vpe_t * v, Elf_Shdr * sechdrs,
+				      unsigned int symindex, const char *strtab,
+				      struct module *mod)
+{
+	Elf_Sym *sym = (void *)sechdrs[symindex].sh_addr;
+	unsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);
+
+	for (i = 1; i < n; i++) {
+		if (strcmp(strtab + sym[i].st_name, "__start") == 0) {
+			v->__start = sym[i].st_value;
+		}
+
+		if (strcmp(strtab + sym[i].st_name, "vpe_shared") == 0) {
+			v->shared_ptr = (void *)sym[i].st_value;
+		}
+	}
+
+	return 0;
+}
+
+/* Allocates a VPE with some program code space(the load address), copies the contents
+   of the program (p)buffer performing relocatations/etc, free's it when finished.
+*/
+int vpe_elfload(vpe_t * v)
+{
+	Elf_Ehdr *hdr;
+	Elf_Shdr *sechdrs;
+	long err = 0;
+	char *secstrings, *strtab = NULL;
+	unsigned int len, i, symindex = 0, strindex = 0;
+
+	struct module mod;	// so we can re-use the relocations code
+
+	memset(&mod, 0, sizeof(struct module));
+	strcpy(mod.name, "VPE dummy prog module");
+
+	hdr = (Elf_Ehdr *) v->pbuffer;
+	len = v->plen;
+
+	/* Sanity checks against insmoding binaries or wrong arch,
+	   weird elf version */
+	if (memcmp(hdr->e_ident, ELFMAG, 4) != 0
+	    || hdr->e_type != ET_REL || !elf_check_arch(hdr)
+	    || hdr->e_shentsize != sizeof(*sechdrs)) {
+		printk(KERN_WARNING
+		       "VPE program, wrong arch or weird elf version\n");
+
+		return -ENOEXEC;
+	}
+
+	if (len < hdr->e_shoff + hdr->e_shnum * sizeof(Elf_Shdr)) {
+		printk(KERN_ERR "VPE program length %u truncated\n", len);
+		return -ENOEXEC;
+	}
+
+	/* Convenience variables */
+	sechdrs = (void *)hdr + hdr->e_shoff;
+	secstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
+	sechdrs[0].sh_addr = 0;
+
+	/* And these should exist, but gcc whinges if we don't init them */
+	symindex = strindex = 0;
+
+	for (i = 1; i < hdr->e_shnum; i++) {
+
+		if (sechdrs[i].sh_type != SHT_NOBITS
+		    && len < sechdrs[i].sh_offset + sechdrs[i].sh_size) {
+			printk(KERN_ERR "VPE program length %u truncated\n",
+			       len);
+			return -ENOEXEC;
+		}
+
+		/* Mark all sections sh_addr with their address in the
+		   temporary image. */
+		sechdrs[i].sh_addr = (size_t) hdr + sechdrs[i].sh_offset;
+
+		/* Internal symbols and strings. */
+		if (sechdrs[i].sh_type == SHT_SYMTAB) {
+			symindex = i;
+			strindex = sechdrs[i].sh_link;
+			strtab = (char *)hdr + sechdrs[strindex].sh_offset;
+		}
+	}
+
+	layout_sections(&mod, hdr, sechdrs, secstrings);
+
+	v->load_addr = alloc_progmem(mod.core_size);
+	memset(v->load_addr, 0, mod.core_size);
+
+	printk("VPE elf_loader: loading to %p\n", v->load_addr);
+
+	for (i = 0; i < hdr->e_shnum; i++) {
+		void *dest;
+
+		if (!(sechdrs[i].sh_flags & SHF_ALLOC))
+			continue;
+
+		dest = v->load_addr + sechdrs[i].sh_entsize;
+
+		if (sechdrs[i].sh_type != SHT_NOBITS)
+			memcpy(dest, (void *)sechdrs[i].sh_addr,
+			       sechdrs[i].sh_size);
+		/* Update sh_addr to point to copy in image. */
+		sechdrs[i].sh_addr = (unsigned long)dest;
+	}
+
+	/* Fix up syms, so that st_value is a pointer to location. */
+	err =
+		simplify_symbols(sechdrs, symindex, strtab, secstrings,
+				 hdr->e_shnum, &mod);
+	if (err < 0) {
+		printk(KERN_WARNING "VPE: unable to simplify symbols\n");
+		goto cleanup;
+	}
+
+	/* Now do relocations. */
+	for (i = 1; i < hdr->e_shnum; i++) {
+		const char *strtab = (char *)sechdrs[strindex].sh_addr;
+		unsigned int info = sechdrs[i].sh_info;
+
+		/* Not a valid relocation section? */
+		if (info >= hdr->e_shnum)
+			continue;
+
+		/* Don't bother with non-allocated sections */
+		if (!(sechdrs[info].sh_flags & SHF_ALLOC))
+			continue;
+
+		if (sechdrs[i].sh_type == SHT_REL)
+			err =
+				apply_relocations(sechdrs, strtab, symindex, i, &mod);
+		else if (sechdrs[i].sh_type == SHT_RELA)
+			err = apply_relocate_add(sechdrs, strtab, symindex, i,
+						 &mod);
+		if (err < 0) {
+			printk(KERN_WARNING
+			       "vpe_elfload: error in relocations err %ld\n",
+			       err);
+			goto cleanup;
+		}
+	}
+
+	/* make sure it's physically written out */
+	flush_icache_range((unsigned long)v->load_addr,
+			   (unsigned long)v->load_addr + v->len);
+
+	if ((find_vpe_symbols(v, sechdrs, symindex, strtab, &mod)) < 0) {
+
+		printk(KERN_WARNING
+		       "VPE: program doesn't contain __start or vpe_shared symbols\n");
+		err = -ENOEXEC;
+	}
+
+	printk(" elf loaded\n");
+
+cleanup:
+	return err;
+}
+
+static void dump_vpe(vpe_t * v)
+{
+	struct tc *t;
+
+	printk(KERN_DEBUG "VPEControl 0x%lx\n", read_vpe_c0_vpecontrol());
+	printk(KERN_DEBUG "VPEConf0 0x%lx\n", read_vpe_c0_vpeconf0());
+
+	list_for_each_entry(t, &vpecontrol.tc_list, list) {
+		dump_tc(t);
+	}
+}
+
+/* checks for VPE is unused and gets ready to load program	 */
+static int vpe_open(struct inode *inode, struct file *filp)
+{
+	int minor;
+	vpe_t *v;
+
+	/* assume only 1 device at the mo. */
+	if ((minor = MINOR(inode->i_rdev)) != 1) {
+		printk(KERN_WARNING "VPE: only vpe1 is supported\n");
+		return -ENODEV;
+	}
+
+	if ((v = get_vpe(minor)) == NULL) {
+		printk(KERN_WARNING "VPE: unable to get vpe\n");
+		return -ENODEV;
+	}
+
+	if (v->state != VPE_STATE_UNUSED) {
+		unsigned long tmp;
+		struct tc *t;
+
+		printk(KERN_WARNING "VPE: device %d already in use\n", minor);
+
+		dvpe();
+		dump_vpe(v);
+
+		printk(KERN_WARNING "VPE: re-initialising %d\n", minor);
+
+		release_progmem(v->load_addr);
+
+		t = get_tc(minor);
+		settc(minor);
+		tmp = read_tc_c0_tcstatus();
+
+		/* mark not allocated and not dynamically allocatable */
+		tmp &= ~(TCSTATUS_A | TCSTATUS_DA);
+		tmp |= TCSTATUS_IXMT;	/* interrupt exempt */
+		write_tc_c0_tcstatus(tmp);
+
+		write_tc_c0_tchalt(TCHALT_H);
+
+	}
+
+	// allocate it so when we get write ops we know it's expected.
+	v->state = VPE_STATE_INUSE;
+
+	/* this of-course trashes what was there before... */
+	v->pbuffer = vmalloc(P_SIZE);
+	v->plen = P_SIZE;
+	v->load_addr = NULL;
+	v->len = 0;
+
+	return 0;
+}
+
+static int vpe_release(struct inode *inode, struct file *filp)
+{
+	int minor, ret = 0;
+	vpe_t *v;
+	Elf_Ehdr *hdr;
+
+	minor = MINOR(inode->i_rdev);
+	if ((v = get_vpe(minor)) == NULL)
+		return -ENODEV;
+
+	// simple case of fire and forget, so tell the VPE to run...
+
+	hdr = (Elf_Ehdr *) v->pbuffer;
+	if (memcmp(hdr->e_ident, ELFMAG, 4) == 0) {
+		if (vpe_elfload(v) >= 0)
+			vpe_run(v);
+		else {
+			printk(KERN_WARNING "VPE: ELF load failed.\n");
+			ret = -ENOEXEC;
+		}
+	} else {
+		printk(KERN_WARNING "VPE: only elf files are supported\n");
+		ret = -ENOEXEC;
+	}
+
+	// cleanup any temp buffers
+	if (v->pbuffer)
+		vfree(v->pbuffer);
+	v->plen = 0;
+	return ret;
+}
+
+static ssize_t vpe_write(struct file *file, const char __user * buffer,
+			 size_t count, loff_t * ppos)
+{
+	int minor;
+	size_t ret = count;
+	vpe_t *v;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	if ((v = get_vpe(minor)) == NULL)
+		return -ENODEV;
+
+	if (v->pbuffer == NULL) {
+		printk(KERN_ERR "vpe_write: no pbuffer\n");
+		return -ENOMEM;
+	}
+
+	if ((count + v->len) > v->plen) {
+		printk(KERN_WARNING
+		       "VPE Loader: elf size too big. Perhaps strip uneeded symbols\n");
+		return -ENOMEM;
+	}
+
+	count -= copy_from_user(v->pbuffer + v->len, buffer, count);
+	if (!count) {
+		printk("vpe_write: copy_to_user failed\n");
+		return -EFAULT;
+	}
+
+	v->len += count;
+	return ret;
+}
+
+static struct file_operations vpe_fops = {
+	.owner = THIS_MODULE,
+	.open = vpe_open,
+	.release = vpe_release,
+	.write = vpe_write
+};
+
+/* module wrapper entry points */
+/* give me a vpe */
+vpe_handle vpe_alloc(void)
+{
+	int i;
+	struct vpe *v;
+
+	/* find a vpe */
+	for (i = 1; i < MAX_VPES; i++) {
+		if ((v = get_vpe(i)) != NULL) {
+			v->state = VPE_STATE_INUSE;
+			return v;
+		}
+	}
+	return NULL;
+}
+
+EXPORT_SYMBOL(vpe_alloc);
+
+/* start running from here */
+int vpe_start(vpe_handle vpe, unsigned long start)
+{
+	struct vpe *v = vpe;
+
+	v->__start = start;
+	return vpe_run(v);
+}
+
+EXPORT_SYMBOL(vpe_start);
+
+/* halt it for now */
+int vpe_stop(vpe_handle vpe)
+{
+	struct vpe *v = vpe;
+	struct tc *t;
+	unsigned int evpe_flags;
+
+	evpe_flags = dvpe();
+
+	if ((t = list_entry(v->tc.next, struct tc, tc)) != NULL) {
+
+		settc(t->index);
+		write_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~VPECONF0_VPA);
+	}
+
+	evpe(evpe_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(vpe_stop);
+
+/* I've done with it thank you */
+int vpe_free(vpe_handle vpe)
+{
+	struct vpe *v = vpe;
+	struct tc *t;
+	unsigned int evpe_flags;
+
+	if ((t = list_entry(v->tc.next, struct tc, tc)) == NULL) {
+		return -ENOEXEC;
+	}
+
+	evpe_flags = dvpe();
+
+	/* Put MVPE's into 'configuration state' */
+	set_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	settc(t->index);
+	write_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~VPECONF0_VPA);
+
+	/* mark the TC unallocated and halt'ed */
+	write_tc_c0_tcstatus(read_tc_c0_tcstatus() & ~TCSTATUS_A);
+	write_tc_c0_tchalt(TCHALT_H);
+
+	v->state = VPE_STATE_UNUSED;
+
+	clear_c0_mvpcontrol(MVPCONTROL_VPC);
+	evpe(evpe_flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(vpe_free);
+
+void *vpe_get_shared(int index)
+{
+	struct vpe *v;
+
+	if ((v = get_vpe(index)) == NULL) {
+		printk(KERN_WARNING "vpe: invalid vpe index %d\n", index);
+		return NULL;
+	}
+
+	return v->shared_ptr;
+}
+
+EXPORT_SYMBOL(vpe_get_shared);
+
+static int __init vpe_module_init(void)
+{
+	struct vpe *v = NULL;
+	struct tc *t;
+	unsigned long val;
+	int i;
+
+	if (!cpu_has_mipsmt) {
+		printk("VPE loader: not a MIPS MT capable processor\n");
+		return -ENODEV;
+	}
+
+	if ((major = register_chrdev(VPE_MAJOR, module_name, &vpe_fops) < 0)) {
+		printk("VPE loader: unable to register character device\n");
+		return -EBUSY;
+	}
+
+	if (major == 0)
+		major = VPE_MAJOR;
+
+	dmt();
+	dvpe();
+
+	/* Put MVPE's into 'configuration state' */
+	set_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	/* dump_mtregs(); */
+
+	INIT_LIST_HEAD(&vpecontrol.vpe_list);
+	INIT_LIST_HEAD(&vpecontrol.tc_list);
+
+	val = read_c0_mvpconf0();
+	for (i = 0; i < ((val & MVPCONF0_PTC) + 1); i++) {
+		t = alloc_tc(i);
+
+		/* VPE's */
+		if (i < ((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1) {
+			settc(i);
+
+			if ((v = alloc_vpe(i)) == NULL) {
+				printk(KERN_WARNING "VPE: unable to allocate VPE\n");
+				return -ENODEV;
+			}
+
+			list_add(&t->tc, &v->tc);	/* add the tc to the list of this vpe's tc's. */
+
+			/* deactivate all but vpe0 */
+			if (i != 0) {
+				unsigned long tmp = read_vpe_c0_vpeconf0();
+
+				tmp &= ~VPECONF0_VPA;
+
+				/* master VPE */
+				tmp |= VPECONF0_MVP;
+				write_vpe_c0_vpeconf0(tmp);
+			}
+
+			/* disable multi-threading with TC's */
+			write_vpe_c0_vpecontrol(read_vpe_c0_vpecontrol() & ~VPECONTROL_TE);
+
+			if (i != 0) {
+				write_vpe_c0_status((read_c0_status() &
+						     ~(ST0_IM | ST0_IE | ST0_KSU))
+						    | ST0_CU0);
+
+				/* set config to be the same as vpe0, particularly kseg0 coherency alg */
+				write_vpe_c0_config(read_c0_config());
+			}
+
+		}
+
+		/* TC's */
+		t->pvpe = v;	/* set the parent vpe */
+
+		if (i != 0) {
+			unsigned long tmp;
+
+			/* tc 0 will of course be running.... */
+			if (i == 0)
+				t->state = TC_STATE_RUNNING;
+
+			settc(i);
+
+			/* bind a TC to each VPE, May as well put all excess TC's
+			   on the last VPE */
+			if (i >= (((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1))
+				write_tc_c0_tcbind(read_tc_c0_tcbind() |
+						   ((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT));
+			else
+				write_tc_c0_tcbind(read_tc_c0_tcbind() | i);
+
+			tmp = read_tc_c0_tcstatus();
+
+			/* mark not allocated and not dynamically allocatable */
+			tmp &= ~(TCSTATUS_A | TCSTATUS_DA);
+			tmp |= TCSTATUS_IXMT;	/* interrupt exempt */
+			write_tc_c0_tcstatus(tmp);
+
+			write_tc_c0_tchalt(TCHALT_H);
+		}
+	}
+
+	/* release config state */
+	clear_c0_mvpcontrol(MVPCONTROL_VPC);
+
+	return 0;
+}
+
+static void __exit vpe_module_exit(void)
+{
+	struct vpe *v, *n;
+
+	list_for_each_entry_safe(v, n, &vpecontrol.vpe_list, list) {
+		if (v->state != VPE_STATE_UNUSED) {
+			release_vpe(v);
+		}
+	}
+
+	unregister_chrdev(major, module_name);
+}
+
+module_init(vpe_module_init);
+module_exit(vpe_module_exit);
+MODULE_DESCRIPTION("MIPS VPE Loader");
+MODULE_AUTHOR("Elizabeth Clarke, MIPS Technologies, Inc");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/arch/mips/lasat/interrupt.c linux-mips-2.6.14.orig/arch/mips/lasat/interrupt.c
--- linux-2.6.14/arch/mips/lasat/interrupt.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lasat/interrupt.c	2005-11-17 11:42:23.000000000 -0800
@@ -71,14 +71,13 @@
 }
 
 static struct hw_interrupt_type lasat_irq_type = {
-	"Lasat",
-	startup_lasat_irq,
-	shutdown_lasat_irq,
-	enable_lasat_irq,
-	disable_lasat_irq,
-	mask_and_ack_lasat_irq,
-	end_lasat_irq,
-	NULL
+	.typename = "Lasat",
+	.startup = startup_lasat_irq,
+	.shutdown = shutdown_lasat_irq,
+	.enable = enable_lasat_irq,
+	.disable = disable_lasat_irq,
+	.ack = mask_and_ack_lasat_irq,
+	.end = end_lasat_irq,
 };
 
 static inline int ls1bit32(unsigned int x)
diff -Naur linux-2.6.14/arch/mips/lasat/Kconfig linux-mips-2.6.14.orig/arch/mips/lasat/Kconfig
--- linux-2.6.14/arch/mips/lasat/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/lasat/Kconfig	2005-11-17 11:42:23.000000000 -0800
@@ -0,0 +1,15 @@
+config PICVUE
+	tristate "PICVUE LCD display driver"
+	depends on LASAT
+
+config PICVUE_PROC
+	tristate "PICVUE LCD display driver /proc interface"
+	depends on PICVUE
+
+config DS1603
+	bool "DS1603 RTC driver"
+	depends on LASAT
+
+config LASAT_SYSCTL
+	bool "LASAT sysctl interface"
+	depends on LASAT
diff -Naur linux-2.6.14/arch/mips/lasat/setup.c linux-mips-2.6.14.orig/arch/mips/lasat/setup.c
--- linux-2.6.14/arch/mips/lasat/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lasat/setup.c	2005-11-17 11:42:23.000000000 -0800
@@ -155,7 +155,7 @@
 }
 #endif
 
-static int __init lasat_setup(void)
+void __init plat_setup(void)
 {
 	int i;
 	lasat_misc  = &lasat_misc_info[mips_machtype];
@@ -185,8 +185,4 @@
 	change_c0_status(ST0_BEV,0);
 
 	prom_printf("Lasat specific initialization complete\n");
-
-        return 0;
 }
-
-early_initcall(lasat_setup);
diff -Naur linux-2.6.14/arch/mips/lib/csum_partial_copy.c linux-mips-2.6.14.orig/arch/mips/lib/csum_partial_copy.c
--- linux-2.6.14/arch/mips/lib/csum_partial_copy.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib/csum_partial_copy.c	2005-11-17 11:42:23.000000000 -0800
@@ -16,8 +16,8 @@
 /*
  * copy while checksumming, otherwise like csum_partial
  */
-unsigned int csum_partial_copy_nocheck(const unsigned char *src, unsigned char *dst,
-	int len, unsigned int sum)
+unsigned int csum_partial_copy_nocheck(const unsigned char *src,
+	unsigned char *dst, int len, unsigned int sum)
 {
 	/*
 	 * It's 2:30 am and I don't feel like doing it real ...
@@ -33,8 +33,8 @@
  * Copy from userspace and compute checksum.  If we catch an exception
  * then zero the rest of the buffer.
  */
-unsigned int csum_partial_copy_from_user (const unsigned char *src, unsigned char *dst,
-	int len, unsigned int sum, int *err_ptr)
+unsigned int csum_partial_copy_from_user (const unsigned char __user *src,
+	unsigned char *dst, int len, unsigned int sum, int *err_ptr)
 {
 	int missing;
 
diff -Naur linux-2.6.14/arch/mips/lib/iomap.c linux-mips-2.6.14.orig/arch/mips/lib/iomap.c
--- linux-2.6.14/arch/mips/lib/iomap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib/iomap.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,78 +0,0 @@
-/*
- *  iomap.c, Memory Mapped I/O routines for MIPS architecture.
- *
- *  This code is based on lib/iomap.c, by Linus Torvalds.
- *
- *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-
-#include <asm/io.h>
-
-void __iomem *ioport_map(unsigned long port, unsigned int nr)
-{
-	unsigned long end;
-
-	end = port + nr - 1UL;
-	if (ioport_resource.start > port ||
-	    ioport_resource.end < end || port > end)
-		return NULL;
-
-	return (void __iomem *)(mips_io_port_base + port);
-}
-
-void ioport_unmap(void __iomem *addr)
-{
-}
-EXPORT_SYMBOL(ioport_map);
-EXPORT_SYMBOL(ioport_unmap);
-
-void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
-{
-	unsigned long start, len, flags;
-
-	if (dev == NULL)
-		return NULL;
-
-	start = pci_resource_start(dev, bar);
-	len = pci_resource_len(dev, bar);
-	if (!start || !len)
-		return NULL;
-
-	if (maxlen != 0 && len > maxlen)
-		len = maxlen;
-
-	flags = pci_resource_flags(dev, bar);
-	if (flags & IORESOURCE_IO)
-		return ioport_map(start, len);
-	if (flags & IORESOURCE_MEM) {
-		if (flags & IORESOURCE_CACHEABLE)
-			return ioremap_cacheable_cow(start, len);
-		return ioremap_nocache(start, len);
-	}
-
-	return NULL;
-}
-
-void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
-{
-	iounmap(addr);
-}
-EXPORT_SYMBOL(pci_iomap);
-EXPORT_SYMBOL(pci_iounmap);
diff -Naur linux-2.6.14/arch/mips/lib/Makefile linux-mips-2.6.14.orig/arch/mips/lib/Makefile
--- linux-2.6.14/arch/mips/lib/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib/Makefile	2005-11-17 11:42:23.000000000 -0800
@@ -2,9 +2,7 @@
 # Makefile for MIPS-specific library files..
 #
 
-lib-y	+= csum_partial_copy.o memcpy.o promlib.o \
-	   strlen_user.o strncpy_user.o strnlen_user.o
-
-obj-y	+= iomap.o
+lib-y	+= csum_partial_copy.o memcpy.o promlib.o strlen_user.o strncpy_user.o \
+	   strnlen_user.o uncached.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -Naur linux-2.6.14/arch/mips/lib/memcpy.S linux-mips-2.6.14.orig/arch/mips/lib/memcpy.S
--- linux-2.6.14/arch/mips/lib/memcpy.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib/memcpy.S	2005-11-17 11:42:23.000000000 -0800
@@ -13,6 +13,21 @@
  * Mnemonic names for arguments to memcpy/__copy_user
  */
 #include <linux/config.h>
+
+/*
+ * Hack to resolve longstanding prefetch issue
+ *
+ * Prefetching may be fatal on some systems if we're prefetching beyond the
+ * end of memory on some systems.  It's also a seriously bad idea on non
+ * dma-coherent systems.
+ */
+#if !defined(CONFIG_DMA_COHERENT) || !defined(CONFIG_DMA_IP27)
+#undef CONFIG_CPU_HAS_PREFETCH
+#endif
+#ifdef CONFIG_MIPS_MALTA
+#undef CONFIG_CPU_HAS_PREFETCH
+#endif
+
 #include <asm/asm.h>
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
diff -Naur linux-2.6.14/arch/mips/lib/uncached.c linux-mips-2.6.14.orig/arch/mips/lib/uncached.c
--- linux-2.6.14/arch/mips/lib/uncached.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/lib/uncached.c	2005-11-17 11:42:23.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Thiemo Seufer
+ * Copyright (C) 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Author: Maciej W. Rozycki <macro@mips.com>
+ */
+
+#include <linux/init.h>
+
+#include <asm/addrspace.h>
+#include <asm/bug.h>
+
+#ifndef CKSEG2
+#define CKSEG2 CKSSEG
+#endif
+#ifndef TO_PHYS_MASK
+#define TO_PHYS_MASK -1
+#endif
+
+/*
+ * FUNC is executed in one of the uncached segments, depending on its
+ * original address as follows:
+ *
+ * 1. If the original address is in CKSEG0 or CKSEG1, then the uncached
+ *    segment used is CKSEG1.
+ * 2. If the original address is in XKPHYS, then the uncached segment
+ *    used is XKPHYS(2).
+ * 3. Otherwise it's a bug.
+ *
+ * The same remapping is done with the stack pointer.  Stack handling
+ * works because we don't handle stack arguments or more complex return
+ * values, so we can avoid sharing the same stack area between a cached
+ * and the uncached mode.
+ */
+unsigned long __init run_uncached(void *func)
+{
+	register long sp __asm__("$sp");
+	register long ret __asm__("$2");
+	long lfunc = (long)func, ufunc;
+	long usp;
+
+	if (sp >= (long)CKSEG0 && sp < (long)CKSEG2)
+		usp = CKSEG1ADDR(sp);
+	else if ((long long)sp >= (long long)PHYS_TO_XKPHYS(0LL, 0) &&
+		 (long long)sp < (long long)PHYS_TO_XKPHYS(8LL, 0))
+		usp = PHYS_TO_XKPHYS((long long)K_CALG_UNCACHED,
+				     XKPHYS_TO_PHYS((long long)sp));
+	else {
+		BUG();
+		usp = sp;
+	}
+	if (lfunc >= (long)CKSEG0 && lfunc < (long)CKSEG2)
+		ufunc = CKSEG1ADDR(lfunc);
+	else if ((long long)lfunc >= (long long)PHYS_TO_XKPHYS(0LL, 0) &&
+		 (long long)lfunc < (long long)PHYS_TO_XKPHYS(8LL, 0))
+		ufunc = PHYS_TO_XKPHYS((long long)K_CALG_UNCACHED,
+				       XKPHYS_TO_PHYS((long long)lfunc));
+	else {
+		BUG();
+		ufunc = lfunc;
+	}
+
+	__asm__ __volatile__ (
+		"	move	$16, $sp\n"
+		"	move	$sp, %1\n"
+		"	jalr	%2\n"
+		"	move	$sp, $16"
+		: "=r" (ret)
+		: "r" (usp), "r" (ufunc)
+		: "$16", "$31");
+
+	return ret;
+}
diff -Naur linux-2.6.14/arch/mips/lib-32/dump_tlb.c linux-mips-2.6.14.orig/arch/mips/lib-32/dump_tlb.c
--- linux-2.6.14/arch/mips/lib-32/dump_tlb.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib-32/dump_tlb.c	2005-11-17 11:42:23.000000000 -0800
@@ -20,20 +20,27 @@
 static inline const char *msk2str(unsigned int mask)
 {
 	switch (mask) {
-	case PM_4K:	return "4kb";
-	case PM_16K:	return "16kb";
-	case PM_64K:	return "64kb";
-	case PM_256K:	return "256kb";
+	case PM_4K:
+		return "4kb";
+	case PM_16K:
+		return "16kb";
+	case PM_64K:
+		return "64kb";
+	case PM_256K:
+		return "256kb";
 #ifndef CONFIG_CPU_VR41XX
-	case PM_1M:	return "1Mb";
-	case PM_4M:	return "4Mb";
-	case PM_16M:	return "16Mb";
-	case PM_64M:	return "64Mb";
-	case PM_256M:	return "256Mb";
+	case PM_1M:
+		return "1Mb";
+	case PM_4M:
+		return "4Mb";
+	case PM_16M:
+		return "16Mb";
+	case PM_64M:
+		return "64Mb";
+	case PM_256M:
+		return "256Mb";
 #endif
 	}
-
-	return "unknown";
 }
 
 #define BARRIER()					\
@@ -47,7 +54,7 @@
 	unsigned int pagemask, c0, c1, asid;
 	unsigned long long entrylo0, entrylo1;
 	unsigned long entryhi;
-	int	i;
+	int i;
 
 	asid = read_c0_entryhi() & 0xff;
 
@@ -58,7 +65,7 @@
 		tlb_read();
 		BARRIER();
 		pagemask = read_c0_pagemask();
-		entryhi  = read_c0_entryhi();
+		entryhi = read_c0_entryhi();
 		entrylo0 = read_c0_entrylo0();
 		entrylo1 = read_c0_entrylo1();
 
@@ -78,13 +85,11 @@
 			printk("\t\t\t[pa=%08Lx c=%d d=%d v=%d g=%Ld]\n",
 			       (entrylo0 << 6) & PAGE_MASK, c0,
 			       (entrylo0 & 4) ? 1 : 0,
-			       (entrylo0 & 2) ? 1 : 0,
-			       (entrylo0 & 1));
+			       (entrylo0 & 2) ? 1 : 0, (entrylo0 & 1));
 			printk("\t\t\t[pa=%08Lx c=%d d=%d v=%d g=%Ld]\n",
 			       (entrylo1 << 6) & PAGE_MASK, c1,
 			       (entrylo1 & 4) ? 1 : 0,
-			       (entrylo1 & 2) ? 1 : 0,
-			       (entrylo1 & 1));
+			       (entrylo1 & 2) ? 1 : 0, (entrylo1 & 1));
 			printk("\n");
 		}
 	}
@@ -99,7 +104,7 @@
 
 void dump_tlb_wired(void)
 {
-	int	wired;
+	int wired;
 
 	wired = read_c0_wired();
 	printk("Wired: %d", wired);
@@ -138,9 +143,10 @@
 
 void dump_list_process(struct task_struct *t, void *address)
 {
-	pgd_t	*page_dir, *pgd;
-	pmd_t	*pmd;
-	pte_t	*pte, page;
+	pgd_t *page_dir, *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte, page;
 	unsigned long addr, val;
 
 	addr = (unsigned long) address;
@@ -152,21 +158,27 @@
 
 	if (addr > KSEG0)
 		page_dir = pgd_offset_k(0);
-	else
+	else if (t->mm) {
 		page_dir = pgd_offset(t->mm, 0);
-	printk("page_dir == %08x\n", (unsigned int) page_dir);
+		printk("page_dir == %08x\n", (unsigned int) page_dir);
+	} else
+		printk("Current thread has no mm\n");
 
 	if (addr > KSEG0)
 		pgd = pgd_offset_k(addr);
-	else
+	else if (t->mm) {
 		pgd = pgd_offset(t->mm, addr);
-	printk("pgd == %08x, ", (unsigned int) pgd);
-
-	pmd = pmd_offset(pgd, addr);
-	printk("pmd == %08x, ", (unsigned int) pmd);
-
-	pte = pte_offset(pmd, addr);
-	printk("pte == %08x, ", (unsigned int) pte);
+		printk("pgd == %08x, ", (unsigned int) pgd);
+		pud = pud_offset(pgd, addr);
+		printk("pud == %08x, ", (unsigned int) pud);
+
+		pmd = pmd_offset(pud, addr);
+		printk("pmd == %08x, ", (unsigned int) pmd);
+
+		pte = pte_offset(pmd, addr);
+		printk("pte == %08x, ", (unsigned int) pte);
+	} else
+		printk("Current thread has no mm\n");
 
 	page = *pte;
 #ifdef CONFIG_64BIT_PHYS_ADDR
@@ -176,14 +188,22 @@
 #endif
 
 	val = pte_val(page);
-	if (val & _PAGE_PRESENT) printk("present ");
-	if (val & _PAGE_READ) printk("read ");
-	if (val & _PAGE_WRITE) printk("write ");
-	if (val & _PAGE_ACCESSED) printk("accessed ");
-	if (val & _PAGE_MODIFIED) printk("modified ");
-	if (val & _PAGE_R4KBUG) printk("r4kbug ");
-	if (val & _PAGE_GLOBAL) printk("global ");
-	if (val & _PAGE_VALID) printk("valid ");
+	if (val & _PAGE_PRESENT)
+		printk("present ");
+	if (val & _PAGE_READ)
+		printk("read ");
+	if (val & _PAGE_WRITE)
+		printk("write ");
+	if (val & _PAGE_ACCESSED)
+		printk("accessed ");
+	if (val & _PAGE_MODIFIED)
+		printk("modified ");
+	if (val & _PAGE_R4KBUG)
+		printk("r4kbug ");
+	if (val & _PAGE_GLOBAL)
+		printk("global ");
+	if (val & _PAGE_VALID)
+		printk("valid ");
 	printk("\n");
 }
 
@@ -194,14 +214,16 @@
 
 unsigned int vtop(void *address)
 {
-	pgd_t	*pgd;
-	pmd_t	*pmd;
-	pte_t	*pte;
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
 	unsigned int addr, paddr;
 
 	addr = (unsigned long) address;
 	pgd = pgd_offset(current->mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 	paddr = (KSEG1 | (unsigned int) pte_val(*pte)) & PAGE_MASK;
 	paddr |= (addr & ~PAGE_MASK);
@@ -214,9 +236,9 @@
 	int i;
 
 	for (i = 0; i < 8; i++) {
-		printk("*%08lx == %08lx, ", (unsigned long)p, *p);
+		printk("*%08lx == %08lx, ", (unsigned long) p, *p);
 		p++;
-		printk("*%08lx == %08lx\n", (unsigned long)p, *p);
+		printk("*%08lx == %08lx\n", (unsigned long) p, *p);
 		p++;
 	}
 }
diff -Naur linux-2.6.14/arch/mips/lib-32/r3k_dump_tlb.c linux-mips-2.6.14.orig/arch/mips/lib-32/r3k_dump_tlb.c
--- linux-2.6.14/arch/mips/lib-32/r3k_dump_tlb.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib-32/r3k_dump_tlb.c	2005-11-17 11:42:23.000000000 -0800
@@ -105,6 +105,7 @@
 void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte, page;
 	unsigned int addr;
@@ -121,7 +122,10 @@
 	pgd = pgd_offset(t->mm, addr);
 	printk("pgd == %08x, ", (unsigned int) pgd);
 
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	printk("pud == %08x, ", (unsigned int) pud);
+
+	pmd = pmd_offset(pud, addr);
 	printk("pmd == %08x, ", (unsigned int) pmd);
 
 	pte = pte_offset(pmd, addr);
@@ -149,13 +153,15 @@
 unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte;
 	unsigned int addr, paddr;
 
 	addr = (unsigned long) address;
 	pgd = pgd_offset(current->mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 	paddr = (KSEG1 | (unsigned int) pte_val(*pte)) & PAGE_MASK;
 	paddr |= (addr & ~PAGE_MASK);
diff -Naur linux-2.6.14/arch/mips/lib-64/dump_tlb.c linux-mips-2.6.14.orig/arch/mips/lib-64/dump_tlb.c
--- linux-2.6.14/arch/mips/lib-64/dump_tlb.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/lib-64/dump_tlb.c	2005-11-17 11:42:23.000000000 -0800
@@ -32,8 +32,6 @@
 	case PM_256M:	return "256Mb";
 #endif
 	}
-
-	return "unknown";
 }
 
 #define BARRIER()					\
@@ -140,6 +138,7 @@
 void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte, page;
 	unsigned long addr, val;
@@ -155,7 +154,10 @@
 	pgd = pgd_offset(t->mm, addr);
 	printk("pgd == %016lx\n", (unsigned long) pgd);
 
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	printk("pud == %016lx\n", (unsigned long) pud);
+
+	pmd = pmd_offset(pud, addr);
 	printk("pmd == %016lx\n", (unsigned long) pmd);
 
 	pte = pte_offset(pmd, addr);
@@ -184,13 +186,15 @@
 unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte;
 	unsigned int addr, paddr;
 
 	addr = (unsigned long) address;
 	pgd = pgd_offset(current->mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 	paddr = (CKSEG1 | (unsigned int) pte_val(*pte)) & PAGE_MASK;
 	paddr |= (addr & ~PAGE_MASK);
diff -Naur linux-2.6.14/arch/mips/Makefile linux-mips-2.6.14.orig/arch/mips/Makefile
--- linux-2.6.14/arch/mips/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/Makefile	2005-11-17 11:42:18.000000000 -0800
@@ -52,6 +52,21 @@
 CROSS_COMPILE		:= $(tool-prefix)
 endif
 
+CHECKFLAGS-y				+= -D__linux__ -D__mips__ \
+					   -D_ABIO32=1 \
+					   -D_ABIN32=2 \
+					   -D_ABI64=3
+CHECKFLAGS-$(CONFIG_32BIT)		+= -D_MIPS_SIM=_ABIO32 \
+					   -D_MIPS_SZLONG=32 \
+					   -D__PTRDIFF_TYPE__=int
+CHECKFLAGS-$(CONFIG_64BIT)		+= -m64 -D_MIPS_SIM=_ABI64 \
+					   -D_MIPS_SZLONG=64 \
+					   -D__PTRDIFF_TYPE__="long int"
+CHECKFLAGS-$(CONFIG_CPU_BIG_ENDIAN)	+= -D__MIPSEB__
+CHECKFLAGS-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -D__MIPSEL__
+
+CHECKFLAGS				= $(CHECKFLAGS-y)
+
 ifdef CONFIG_BUILD_ELF64
 gas-abi			= 64
 ld-emul			= $(64bit-emul)
@@ -79,10 +94,20 @@
 cflags-y			+= -I $(TOPDIR)/include/asm/gcc
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
 cflags-y			+= $(call cc-option, -finline-limit=100000)
-LDFLAGS_vmlinux			+= -G 0 -static -n
+LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
 MODFLAGS			+= -mlong-calls
 
-cflags-$(CONFIG_SB1XXX_CORELIS)	+= -mno-sched-prolog -fno-omit-frame-pointer
+#
+# We explicitly add the endianness specifier if needed, this allows
+# to compile kernels with a toolchain for the other endianness. We
+# carefully avoid to add it redundantly because gcc 3.3/3.4 complains
+# when fed the toolchain default!
+#
+cflags-$(CONFIG_CPU_BIG_ENDIAN)		+= $(shell $(CC) -dumpmachine |grep -q 'mips.*el-.*' && echo -EB)
+cflags-$(CONFIG_CPU_LITTLE_ENDIAN)	+= $(shell $(CC) -dumpmachine |grep -q 'mips.*el-.*' || echo -EL)
+
+cflags-$(CONFIG_SB1XXX_CORELIS)	+= $(call cc-option,-mno-sched-prolog) \
+				   -fno-omit-frame-pointer
 
 #
 # Use: $(call set_gccflags,<cpu0>,<isa0>,<cpu1>,<isa1>,<isa2>)
@@ -167,14 +192,22 @@
 			$(call set_gccflags,r4600,mips3,r4600,mips3,mips2)  \
 			-Wa,--trap
 
-cflags-$(CONFIG_CPU_MIPS32)	+= \
+cflags-$(CONFIG_CPU_MIPS32_R1)	+= \
 			$(call set_gccflags,mips32,mips32,r4600,mips3,mips2) \
 			-Wa,--trap
 
-cflags-$(CONFIG_CPU_MIPS64)	+= \
+cflags-$(CONFIG_CPU_MIPS32_R2)	+= \
+			$(call set_gccflags,mips32r2,mips32r2,r4600,mips3,mips2) \
+			-Wa,--trap
+
+cflags-$(CONFIG_CPU_MIPS64_R1)	+= \
 			$(call set_gccflags,mips64,mips64,r4600,mips3,mips2) \
 			-Wa,--trap
 
+cflags-$(CONFIG_CPU_MIPS64_R2)	+= \
+			$(call set_gccflags,mips64r2,mips64r2,r4600,mips3,mips2) \
+			-Wa,--trap
+
 cflags-$(CONFIG_CPU_R5000)	+= \
 			$(call set_gccflags,r5000,mips4,r5000,mips4,mips2) \
 			-Wa,--trap
@@ -196,6 +229,7 @@
 			$(call set_gccflags,rm9000,mips4,r5000,mips4,mips2) \
 			-Wa,--trap
 
+
 cflags-$(CONFIG_CPU_SB1)	+= \
 			$(call set_gccflags,sb1,mips64,r5000,mips4,mips2) \
 			-Wa,--trap
@@ -266,6 +300,13 @@
 load-$(CONFIG_MIPS_PB1550)	+= 0xffffffff80100000
 
 #
+# AMD Alchemy Pb1200 eval board
+#
+libs-$(CONFIG_MIPS_PB1200)	+= arch/mips/au1000/pb1200/
+cflags-$(CONFIG_MIPS_PB1200)	+= -Iinclude/asm-mips/mach-pb1x00
+load-$(CONFIG_MIPS_PB1200)	+= 0xffffffff80100000
+
+#
 # AMD Alchemy Db1000 eval board
 #
 libs-$(CONFIG_MIPS_DB1000)	+= arch/mips/au1000/db1x00/
@@ -294,6 +335,13 @@
 load-$(CONFIG_MIPS_DB1550)	+= 0xffffffff80100000
 
 #
+# AMD Alchemy Db1200 eval board
+#
+libs-$(CONFIG_MIPS_DB1200)	+= arch/mips/au1000/pb1200/
+cflags-$(CONFIG_MIPS_DB1200)	+= -Iinclude/asm-mips/mach-db1x00
+load-$(CONFIG_MIPS_DB1200)	+= 0xffffffff80100000
+
+#
 # AMD Alchemy Bosporus eval board
 #
 libs-$(CONFIG_MIPS_BOSPORUS)	+= arch/mips/au1000/db1x00/
@@ -323,6 +371,7 @@
 # Cobalt Server
 #
 core-$(CONFIG_MIPS_COBALT)	+= arch/mips/cobalt/
+cflags-$(CONFIG_MIPS_COBALT)	+= -Iinclude/asm-mips/cobalt
 load-$(CONFIG_MIPS_COBALT)	+= 0xffffffff80080000
 
 #
@@ -389,6 +438,13 @@
 load-$(CONFIG_MIPS_SEAD)	+= 0xffffffff80100000
 
 #
+# MIPS SIM
+#
+core-$(CONFIG_MIPS_SIM)		+= arch/mips/mips-boards/sim/
+cflags-$(CONFIG_MIPS_SIM)	+= -Iinclude/asm-mips/mach-sim
+load-$(CONFIG_MIPS_SIM)		+= 0x80100000
+
+#
 # Momentum Ocelot board
 #
 # The Ocelot setup.o must be linked early - it does the ioremap() for the
@@ -423,6 +479,7 @@
 cflags-$(CONFIG_PMC_YOSEMITE)	+= -Iinclude/asm-mips/mach-yosemite
 load-$(CONFIG_PMC_YOSEMITE)	+= 0xffffffff80100000
 
+#
 # Qemu simulating MIPS32 4Kc
 #
 core-$(CONFIG_QEMU)		+= arch/mips/qemu/
@@ -509,11 +566,24 @@
 load-$(CONFIG_CASIO_E55)	+= 0xffffffff80004000
 
 #
-# TANBAC VR4131 multichip module(TB0225) and TANBAC VR4131DIMM(TB0229) (VR4131)
+# TANBAC TB0225 VR4131 Multi-chip module/TB0229 VR4131DIMM (VR4131)
 #
 load-$(CONFIG_TANBAC_TB022X)	+= 0xffffffff80000000
 
 #
+# Common Philips PNX8550
+#
+core-$(CONFIG_SOC_PNX8550)	+= arch/mips/philips/pnx8550/common/
+cflags-$(CONFIG_SOC_PNX8550)	+= -Iinclude/asm-mips/mach-pnx8550
+
+#
+# Philips PNX8550 JBS board
+#
+libs-$(CONFIG_PNX8550_JBS)	+= arch/mips/philips/pnx8550/jbs/
+#cflags-$(CONFIG_PNX8550_JBS)	+= -Iinclude/asm-mips/mach-pnx8550
+load-$(CONFIG_PNX8550_JBS)	+= 0xffffffff80060000
+
+#
 # SGI IP22 (Indy/Indigo2)
 #
 # Set the load address to >= 0xffffffff88069000 if you want to leave space for
@@ -582,10 +652,20 @@
 # removed (as happens, even if they have __initcall/module_init)
 #
 core-$(CONFIG_SIBYTE_BCM112X)	+= arch/mips/sibyte/sb1250/
-cflags-$(CONFIG_SIBYTE_BCM112X)	+= -Iinclude/asm-mips/mach-sibyte
+cflags-$(CONFIG_SIBYTE_BCM112X)	+= -Iinclude/asm-mips/mach-sibyte \
+			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1250_112x_ALL
 
 core-$(CONFIG_SIBYTE_SB1250)	+= arch/mips/sibyte/sb1250/
-cflags-$(CONFIG_SIBYTE_SB1250)	+= -Iinclude/asm-mips/mach-sibyte
+cflags-$(CONFIG_SIBYTE_SB1250)	+= -Iinclude/asm-mips/mach-sibyte \
+			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1250_112x_ALL
+
+core-$(CONFIG_SIBYTE_BCM1x55)	+= arch/mips/sibyte/bcm1480/
+cflags-$(CONFIG_SIBYTE_BCM1x55)	+= -Iinclude/asm-mips/mach-sibyte \
+			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1480_ALL
+
+core-$(CONFIG_SIBYTE_BCM1x80)	+= arch/mips/sibyte/bcm1480/
+cflags-$(CONFIG_SIBYTE_BCM1x80)	+= -Iinclude/asm-mips/mach-sibyte \
+			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1480_ALL
 
 #
 # Sibyte BCM91120x (Carmel) board
@@ -593,6 +673,7 @@
 # Sibyte BCM91125C (CRhone) board
 # Sibyte BCM91125E (Rhone) board
 # Sibyte SWARM board
+# Sibyte BCM91x80 (BigSur) board
 #
 libs-$(CONFIG_SIBYTE_CARMEL)	+= arch/mips/sibyte/swarm/
 load-$(CONFIG_SIBYTE_CARMEL)	:= 0xffffffff80100000
@@ -606,6 +687,8 @@
 load-$(CONFIG_SIBYTE_SENTOSA)	:= 0xffffffff80100000
 libs-$(CONFIG_SIBYTE_SWARM)	+= arch/mips/sibyte/swarm/
 load-$(CONFIG_SIBYTE_SWARM)	:= 0xffffffff80100000
+libs-$(CONFIG_SIBYTE_BIGSUR)	+= arch/mips/sibyte/swarm/
+load-$(CONFIG_SIBYTE_BIGSUR)	:= 0xffffffff80100000
 
 #
 # SNI RM200 PCI
@@ -629,6 +712,13 @@
 core-$(CONFIG_TOSHIBA_RBTX4927)	+= arch/mips/tx4927/common/
 load-$(CONFIG_TOSHIBA_RBTX4927)	+= 0xffffffff80020000
 
+#
+# Toshiba RBTX4938 board
+#
+core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/tx4938/toshiba_rbtx4938/
+core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/tx4938/common/
+load-$(CONFIG_TOSHIBA_RBTX4938) += 0xffffffff80100000
+
 cflags-y			+= -Iinclude/asm-mips/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
@@ -673,7 +763,7 @@
 
 ifdef CONFIG_LASAT
 rom.bin rom.sw: vmlinux
-	$(Q)$(MAKE) $(build)=arch/mips/lasat/image $@
+	$(call descend,arch/mips/lasat/image,$@)
 endif
 
 #
@@ -701,10 +791,29 @@
 all:	$(vmlinux-64)
 endif
 
+ifdef CONFIG_MIPS_ATLAS
+all:	vmlinux.srec
+endif
+
+ifdef CONFIG_MIPS_MALTA
+all:	vmlinux.srec
+endif
+
+ifdef CONFIG_MIPS_SEAD
+all:	vmlinux.srec
+endif
+
+ifdef CONFIG_QEMU
+all:	vmlinux.bin
+endif
+
 ifdef CONFIG_SNI_RM200_PCI
 all:	vmlinux.ecoff
 endif
 
+vmlinux.bin: $(vmlinux-32)
+	+@$(call makeboot,$@)
+
 vmlinux.ecoff vmlinux.rm200: $(vmlinux-32)
 	+@$(call makeboot,$@)
 
@@ -720,7 +829,6 @@
 	@$(MAKE) $(clean)=arch/mips/boot
 	@$(MAKE) $(clean)=arch/mips/lasat
 
-
 CLEAN_FILES += vmlinux.32 \
 	       vmlinux.64 \
 	       vmlinux.ecoff
diff -Naur linux-2.6.14/arch/mips/math-emu/cp1emu.c linux-mips-2.6.14.orig/arch/mips/math-emu/cp1emu.c
--- linux-2.6.14/arch/mips/math-emu/cp1emu.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/cp1emu.c	2005-11-17 11:42:23.000000000 -0800
@@ -70,7 +70,7 @@
 
 /* Further private data for which no space exists in mips_fpu_soft_struct */
 
-struct mips_fpu_emulator_private fpuemuprivate;
+struct mips_fpu_emulator_stats fpuemustats;
 
 /* Control registers */
 
@@ -79,7 +79,17 @@
 
 /* Convert Mips rounding mode (0..3) to IEEE library modes. */
 static const unsigned char ieee_rm[4] = {
-	IEEE754_RN, IEEE754_RZ, IEEE754_RU, IEEE754_RD
+	[FPU_CSR_RN] = IEEE754_RN,
+	[FPU_CSR_RZ] = IEEE754_RZ,
+	[FPU_CSR_RU] = IEEE754_RU,
+	[FPU_CSR_RD] = IEEE754_RD,
+};
+/* Convert IEEE library modes to Mips rounding mode (0..3). */
+static const unsigned char mips_rm[4] = {
+	[IEEE754_RN] = FPU_CSR_RN,
+	[IEEE754_RZ] = FPU_CSR_RZ,
+	[IEEE754_RD] = FPU_CSR_RD,
+	[IEEE754_RU] = FPU_CSR_RU,
 };
 
 #if __mips >= 4
@@ -196,11 +206,11 @@
 static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_soft_struct *ctx)
 {
 	mips_instruction ir;
-	vaddr_t emulpc, contpc;
+	void * emulpc, *contpc;
 	unsigned int cond;
 
-	if (get_user(ir, (mips_instruction *) xcp->cp0_epc)) {
-		fpuemuprivate.stats.errors++;
+	if (get_user(ir, (mips_instruction __user *) xcp->cp0_epc)) {
+		fpuemustats.errors++;
 		return SIGBUS;
 	}
 
@@ -221,41 +231,39 @@
 		 * Linux MIPS branch emulator operates on context, updating the
 		 * cp0_epc.
 		 */
-		emulpc = REG_TO_VA(xcp->cp0_epc + 4);	/* Snapshot emulation target */
+		emulpc = (void *) (xcp->cp0_epc + 4);	/* Snapshot emulation target */
 
 		if (__compute_return_epc(xcp)) {
 #ifdef CP1DBG
 			printk("failed to emulate branch at %p\n",
-				REG_TO_VA(xcp->cp0_epc));
+				(void *) (xcp->cp0_epc));
 #endif
 			return SIGILL;
 		}
-		if (get_user(ir, (mips_instruction *) emulpc)) {
-			fpuemuprivate.stats.errors++;
+		if (get_user(ir, (mips_instruction __user *) emulpc)) {
+			fpuemustats.errors++;
 			return SIGBUS;
 		}
 		/* __compute_return_epc() will have updated cp0_epc */
-		contpc = REG_TO_VA xcp->cp0_epc;
+		contpc = (void *)  xcp->cp0_epc;
 		/* In order not to confuse ptrace() et al, tweak context */
-		xcp->cp0_epc = VA_TO_REG emulpc - 4;
-	}
-	else {
-		emulpc = REG_TO_VA xcp->cp0_epc;
-		contpc = REG_TO_VA(xcp->cp0_epc + 4);
+		xcp->cp0_epc = (unsigned long) emulpc - 4;
+	} else {
+		emulpc = (void *)  xcp->cp0_epc;
+		contpc = (void *) (xcp->cp0_epc + 4);
 	}
 
       emul:
-	fpuemuprivate.stats.emulated++;
+	fpuemustats.emulated++;
 	switch (MIPSInst_OPCODE(ir)) {
-#ifndef SINGLE_ONLY_FPU
 	case ldc1_op:{
-		u64 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u64 val;
 
-		fpuemuprivate.stats.loads++;
+		fpuemustats.loads++;
 		if (get_user(val, va)) {
-			fpuemuprivate.stats.errors++;
+			fpuemustats.errors++;
 			return SIGBUS;
 		}
 		DITOREG(val, MIPSInst_RT(ir));
@@ -263,55 +271,42 @@
 	}
 
 	case sdc1_op:{
-		u64 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u64 __user *va = (u64 __user *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u64 val;
 
-		fpuemuprivate.stats.stores++;
+		fpuemustats.stores++;
 		DIFROMREG(val, MIPSInst_RT(ir));
 		if (put_user(val, va)) {
-			fpuemuprivate.stats.errors++;
+			fpuemustats.errors++;
 			return SIGBUS;
 		}
 		break;
 	}
-#endif
 
 	case lwc1_op:{
-		u32 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u32 val;
 
-		fpuemuprivate.stats.loads++;
+		fpuemustats.loads++;
 		if (get_user(val, va)) {
-			fpuemuprivate.stats.errors++;
+			fpuemustats.errors++;
 			return SIGBUS;
 		}
-#ifdef SINGLE_ONLY_FPU
-		if (MIPSInst_RT(ir) & 1) {
-			/* illegal register in single-float mode */
-			return SIGILL;
-		}
-#endif
 		SITOREG(val, MIPSInst_RT(ir));
 		break;
 	}
 
 	case swc1_op:{
-		u32 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u32 __user *va = (u32 __user *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u32 val;
 
-		fpuemuprivate.stats.stores++;
-#ifdef SINGLE_ONLY_FPU
-		if (MIPSInst_RT(ir) & 1) {
-			/* illegal register in single-float mode */
-			return SIGILL;
-		}
-#endif
+		fpuemustats.stores++;
 		SIFROMREG(val, MIPSInst_RT(ir));
 		if (put_user(val, va)) {
-			fpuemuprivate.stats.errors++;
+			fpuemustats.errors++;
 			return SIGBUS;
 		}
 		break;
@@ -320,7 +315,7 @@
 	case cop1_op:
 		switch (MIPSInst_RS(ir)) {
 
-#if defined(__mips64) && !defined(SINGLE_ONLY_FPU)
+#if defined(__mips64)
 		case dmfc_op:
 			/* copregister fs -> gpr[rt] */
 			if (MIPSInst_RT(ir) != 0) {
@@ -337,12 +332,6 @@
 
 		case mfc_op:
 			/* copregister rd -> gpr[rt] */
-#ifdef SINGLE_ONLY_FPU
-			if (MIPSInst_RD(ir) & 1) {
-				/* illegal register in single-float mode */
-				return SIGILL;
-			}
-#endif
 			if (MIPSInst_RT(ir) != 0) {
 				SIFROMREG(xcp->regs[MIPSInst_RT(ir)],
 					MIPSInst_RD(ir));
@@ -351,12 +340,6 @@
 
 		case mtc_op:
 			/* copregister rd <- rt */
-#ifdef SINGLE_ONLY_FPU
-			if (MIPSInst_RD(ir) & 1) {
-				/* illegal register in single-float mode */
-				return SIGILL;
-			}
-#endif
 			SITOREG(xcp->regs[MIPSInst_RT(ir)], MIPSInst_RD(ir));
 			break;
 
@@ -369,9 +352,10 @@
 			}
 			if (MIPSInst_RD(ir) == FPCREG_CSR) {
 				value = ctx->fcr31;
+				value = (value & ~0x3) | mips_rm[value & 0x3];
 #ifdef CSRTRACE
 				printk("%p gpr[%d]<-csr=%08x\n",
-					REG_TO_VA(xcp->cp0_epc),
+					(void *) (xcp->cp0_epc),
 					MIPSInst_RT(ir), value);
 #endif
 			}
@@ -398,14 +382,13 @@
 			if (MIPSInst_RD(ir) == FPCREG_CSR) {
 #ifdef CSRTRACE
 				printk("%p gpr[%d]->csr=%08x\n",
-					REG_TO_VA(xcp->cp0_epc),
+					(void *) (xcp->cp0_epc),
 					MIPSInst_RT(ir), value);
 #endif
-				ctx->fcr31 = value;
-				/* copy new rounding mode and
-				   flush bit to ieee library state! */
-				ieee754_csr.nod = (ctx->fcr31 & 0x1000000) != 0;
-				ieee754_csr.rm = ieee_rm[value & 0x3];
+				value &= (FPU_CSR_FLUSH | FPU_CSR_ALL_E | FPU_CSR_ALL_S | 0x03);
+				ctx->fcr31 &= ~(FPU_CSR_FLUSH | FPU_CSR_ALL_E | FPU_CSR_ALL_S | 0x03);
+				/* convert to ieee library modes */
+				ctx->fcr31 |= (value & ~0x3) | ieee_rm[value & 0x3];
 			}
 			if ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {
 				return SIGFPE;
@@ -445,20 +428,20 @@
 				 * instruction
 				 */
 				xcp->cp0_epc += 4;
-				contpc = REG_TO_VA
+				contpc = (void *)
 					(xcp->cp0_epc +
 					(MIPSInst_SIMM(ir) << 2));
 
-				if (get_user(ir, (mips_instruction *)
-						REG_TO_VA xcp->cp0_epc)) {
-					fpuemuprivate.stats.errors++;
+				if (get_user(ir,
+				    (mips_instruction __user *) xcp->cp0_epc)) {
+					fpuemustats.errors++;
 					return SIGBUS;
 				}
 
 				switch (MIPSInst_OPCODE(ir)) {
 				case lwc1_op:
 				case swc1_op:
-#if (__mips >= 2 || __mips64) && !defined(SINGLE_ONLY_FPU)
+#if (__mips >= 2 || defined(__mips64))
 				case ldc1_op:
 				case sdc1_op:
 #endif
@@ -480,7 +463,7 @@
 				 * Single step the non-cp1
 				 * instruction in the dslot
 				 */
-				return mips_dsemul(xcp, ir, VA_TO_REG contpc);
+				return mips_dsemul(xcp, ir, (unsigned long) contpc);
 			}
 			else {
 				/* branch not taken */
@@ -539,8 +522,9 @@
 	}
 
 	/* we did it !! */
-	xcp->cp0_epc = VA_TO_REG(contpc);
+	xcp->cp0_epc = (unsigned long) contpc;
 	xcp->cp0_cause &= ~CAUSEF_BD;
+
 	return 0;
 }
 
@@ -570,7 +554,7 @@
 static ieee754##p fpemu_##p##_##name (ieee754##p r, ieee754##p s, \
     ieee754##p t) \
 { \
-	struct ieee754_csr ieee754_csr_save; \
+	struct _ieee754_csr ieee754_csr_save; \
 	s = f1 (s, t); \
 	ieee754_csr_save = ieee754_csr; \
 	s = f2 (s, r); \
@@ -616,54 +600,38 @@
 {
 	unsigned rcsr = 0;	/* resulting csr */
 
-	fpuemuprivate.stats.cp1xops++;
+	fpuemustats.cp1xops++;
 
 	switch (MIPSInst_FMA_FFMT(ir)) {
 	case s_fmt:{		/* 0 */
 
 		ieee754sp(*handler) (ieee754sp, ieee754sp, ieee754sp);
 		ieee754sp fd, fr, fs, ft;
-		u32 *va;
+		u32 __user *va;
 		u32 val;
 
 		switch (MIPSInst_FUNC(ir)) {
 		case lwxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
-			fpuemuprivate.stats.loads++;
+			fpuemustats.loads++;
 			if (get_user(val, va)) {
-				fpuemuprivate.stats.errors++;
+				fpuemustats.errors++;
 				return SIGBUS;
 			}
-#ifdef SINGLE_ONLY_FPU
-			if (MIPSInst_FD(ir) & 1) {
-				/* illegal register in single-float
-				 * mode
-				 */
-				return SIGILL;
-			}
-#endif
 			SITOREG(val, MIPSInst_FD(ir));
 			break;
 
 		case swxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
-			fpuemuprivate.stats.stores++;
-#ifdef SINGLE_ONLY_FPU
-			if (MIPSInst_FS(ir) & 1) {
-				/* illegal register in single-float
-				 * mode
-				 */
-				return SIGILL;
-			}
-#endif
+			fpuemustats.stores++;
 
 			SIFROMREG(val, MIPSInst_FS(ir));
 			if (put_user(val, va)) {
-				fpuemuprivate.stats.errors++;
+				fpuemustats.errors++;
 				return SIGBUS;
 			}
 			break;
@@ -699,8 +667,6 @@
 				rcsr |= FPU_CSR_INV_X | FPU_CSR_INV_S;
 
 			ctx->fcr31 = (ctx->fcr31 & ~FPU_CSR_ALL_X) | rcsr;
-			if (ieee754_csr.nod)
-				ctx->fcr31 |= 0x1000000;
 			if ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {
 				/*printk ("SIGFPE: fpu csr = %08x\n",
 				   ctx->fcr31); */
@@ -715,34 +681,33 @@
 		break;
 	}
 
-#ifndef SINGLE_ONLY_FPU
 	case d_fmt:{		/* 1 */
 		ieee754dp(*handler) (ieee754dp, ieee754dp, ieee754dp);
 		ieee754dp fd, fr, fs, ft;
-		u64 *va;
+		u64 __user *va;
 		u64 val;
 
 		switch (MIPSInst_FUNC(ir)) {
 		case ldxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
-			fpuemuprivate.stats.loads++;
+			fpuemustats.loads++;
 			if (get_user(val, va)) {
-				fpuemuprivate.stats.errors++;
+				fpuemustats.errors++;
 				return SIGBUS;
 			}
 			DITOREG(val, MIPSInst_FD(ir));
 			break;
 
 		case sdxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void __user *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
-			fpuemuprivate.stats.stores++;
+			fpuemustats.stores++;
 			DIFROMREG(val, MIPSInst_FS(ir));
 			if (put_user(val, va)) {
-				fpuemuprivate.stats.errors++;
+				fpuemustats.errors++;
 				return SIGBUS;
 			}
 			break;
@@ -773,7 +738,6 @@
 		}
 		break;
 	}
-#endif
 
 	case 0x7:		/* 7 */
 		if (MIPSInst_FUNC(ir) != pfetch_op) {
@@ -810,7 +774,7 @@
 #endif
 	} rv;			/* resulting value */
 
-	fpuemuprivate.stats.cp1ops++;
+	fpuemustats.cp1ops++;
 	switch (rfmt = (MIPSInst_FFMT(ir) & 0xf)) {
 	case s_fmt:{		/* 0 */
 		union {
@@ -834,7 +798,7 @@
 			goto scopbop;
 
 			/* unary  ops */
-#if __mips >= 2 || __mips64
+#if __mips >= 2 || defined(__mips64)
 		case fsqrt_op:
 			handler.u = ieee754sp_sqrt;
 			goto scopuop;
@@ -913,9 +877,6 @@
 		case fcvts_op:
 			return SIGILL;	/* not defined */
 		case fcvtd_op:{
-#ifdef SINGLE_ONLY_FPU
-			return SIGILL;	/* not defined */
-#else
 			ieee754sp fs;
 
 			SPFROMREG(fs, MIPSInst_FS(ir));
@@ -923,7 +884,6 @@
 			rfmt = d_fmt;
 			goto copcsr;
 		}
-#endif
 		case fcvtw_op:{
 			ieee754sp fs;
 
@@ -933,7 +893,7 @@
 			goto copcsr;
 		}
 
-#if __mips >= 2 || __mips64
+#if __mips >= 2 || defined(__mips64)
 		case fround_op:
 		case ftrunc_op:
 		case fceil_op:
@@ -950,7 +910,7 @@
 		}
 #endif /* __mips >= 2 */
 
-#if defined(__mips64) && !defined(SINGLE_ONLY_FPU)
+#if defined(__mips64)
 		case fcvtl_op:{
 			ieee754sp fs;
 
@@ -974,7 +934,7 @@
 			rfmt = l_fmt;
 			goto copcsr;
 		}
-#endif /* __mips64 && !fpu(single) */
+#endif /* defined(__mips64) */
 
 		default:
 			if (MIPSInst_FUNC(ir) >= fcmp_op) {
@@ -1001,7 +961,6 @@
 		break;
 	}
 
-#ifndef SINGLE_ONLY_FPU
 	case d_fmt:{
 		union {
 			ieee754dp(*b) (ieee754dp, ieee754dp);
@@ -1024,7 +983,7 @@
 			goto dcopbop;
 
 			/* unary  ops */
-#if __mips >= 2 || __mips64
+#if __mips >= 2 || defined(__mips64)
 		case fsqrt_op:
 			handler.u = ieee754dp_sqrt;
 			goto dcopuop;
@@ -1108,7 +1067,7 @@
 			goto copcsr;
 		}
 
-#if __mips >= 2 || __mips64
+#if __mips >= 2 || defined(__mips64)
 		case fround_op:
 		case ftrunc_op:
 		case fceil_op:
@@ -1125,7 +1084,7 @@
 		}
 #endif
 
-#if defined(__mips64) && !defined(SINGLE_ONLY_FPU)
+#if defined(__mips64)
 		case fcvtl_op:{
 			ieee754dp fs;
 
@@ -1149,7 +1108,7 @@
 			rfmt = l_fmt;
 			goto copcsr;
 		}
-#endif /* __mips >= 3 && !fpu(single) */
+#endif /* __mips >= 3 */
 
 		default:
 			if (MIPSInst_FUNC(ir) >= fcmp_op) {
@@ -1177,7 +1136,6 @@
 		}
 		break;
 	}
-#endif /* ifndef SINGLE_ONLY_FPU */
 
 	case w_fmt:{
 		ieee754sp fs;
@@ -1189,21 +1147,19 @@
 			rv.s = ieee754sp_fint(fs.bits);
 			rfmt = s_fmt;
 			goto copcsr;
-#ifndef SINGLE_ONLY_FPU
 		case fcvtd_op:
 			/* convert word to double precision real */
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fint(fs.bits);
 			rfmt = d_fmt;
 			goto copcsr;
-#endif
 		default:
 			return SIGILL;
 		}
 		break;
 	}
 
-#if defined(__mips64) && !defined(SINGLE_ONLY_FPU)
+#if defined(__mips64)
 	case l_fmt:{
 		switch (MIPSInst_FUNC(ir)) {
 		case fcvts_op:
@@ -1256,18 +1212,16 @@
 			ctx->fcr31 &= ~cond;
 		break;
 	}
-#ifndef SINGLE_ONLY_FPU
 	case d_fmt:
 		DPTOREG(rv.d, MIPSInst_FD(ir));
 		break;
-#endif
 	case s_fmt:
 		SPTOREG(rv.s, MIPSInst_FD(ir));
 		break;
 	case w_fmt:
 		SITOREG(rv.w, MIPSInst_FD(ir));
 		break;
-#if defined(__mips64) && !defined(SINGLE_ONLY_FPU)
+#if defined(__mips64)
 	case l_fmt:
 		DITOREG(rv.l, MIPSInst_FD(ir));
 		break;
@@ -1279,10 +1233,10 @@
 	return 0;
 }
 
-int fpu_emulator_cop1Handler(int xcptno, struct pt_regs *xcp,
+int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 	struct mips_fpu_soft_struct *ctx)
 {
-	gpreg_t oldepc, prevepc;
+	unsigned long oldepc, prevepc;
 	mips_instruction insn;
 	int sig = 0;
 
@@ -1290,19 +1244,24 @@
 	do {
 		prevepc = xcp->cp0_epc;
 
-		if (get_user(insn, (mips_instruction *) xcp->cp0_epc)) {
-			fpuemuprivate.stats.errors++;
+		if (get_user(insn, (mips_instruction __user *) xcp->cp0_epc)) {
+			fpuemustats.errors++;
 			return SIGBUS;
 		}
 		if (insn == 0)
 			xcp->cp0_epc += 4;	/* skip nops */
 		else {
-			/* Update ieee754_csr. Only relevant if we have a
-			   h/w FPU */
-			ieee754_csr.nod = (ctx->fcr31 & 0x1000000) != 0;
-			ieee754_csr.rm = ieee_rm[ctx->fcr31 & 0x3];
-			ieee754_csr.cx = (ctx->fcr31 >> 12) & 0x1f;
+			/*
+			 * The 'ieee754_csr' is an alias of
+			 * ctx->fcr31.  No need to copy ctx->fcr31 to
+			 * ieee754_csr.  But ieee754_csr.rm is ieee
+			 * library modes. (not mips rounding mode)
+			 */
+			/* convert to ieee library modes */
+			ieee754_csr.rm = ieee_rm[ieee754_csr.rm];
 			sig = cop1Emulate(xcp, ctx);
+			/* revert to mips rounding mode */
+			ieee754_csr.rm = mips_rm[ieee754_csr.rm];
 		}
 
 		if (cpu_has_fpu)
diff -Naur linux-2.6.14/arch/mips/math-emu/dp_sqrt.c linux-mips-2.6.14.orig/arch/mips/math-emu/dp_sqrt.c
--- linux-2.6.14/arch/mips/math-emu/dp_sqrt.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/dp_sqrt.c	2005-11-17 11:42:23.000000000 -0800
@@ -37,7 +37,7 @@
 
 ieee754dp ieee754dp_sqrt(ieee754dp x)
 {
-	struct ieee754_csr oldcsr;
+	struct _ieee754_csr oldcsr;
 	ieee754dp y, z, t;
 	unsigned scalx, yh;
 	COMPXDP;
diff -Naur linux-2.6.14/arch/mips/math-emu/dsemul.c linux-mips-2.6.14.orig/arch/mips/math-emu/dsemul.c
--- linux-2.6.14/arch/mips/math-emu/dsemul.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/dsemul.c	2005-11-17 11:42:24.000000000 -0800
@@ -28,9 +28,6 @@
 #endif
 #define __mips 4
 
-extern struct mips_fpu_emulator_private fpuemuprivate;
-
-
 /*
  * Emulate the arbritrary instruction ir at xcp->cp0_epc.  Required when
  * we have to emulate the instruction in a COP1 branch delay slot.  Do
@@ -52,10 +49,10 @@
 	mips_instruction	emul;
 	mips_instruction	badinst;
 	mips_instruction	cookie;
-	gpreg_t			epc;
+	unsigned long		epc;
 };
 
-int mips_dsemul(struct pt_regs *regs, mips_instruction ir, gpreg_t cpc)
+int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)
 {
 	extern asmlinkage void handle_dsemulret(void);
 	mips_instruction *dsemul_insns;
@@ -91,7 +88,7 @@
 	 */
 
 	/* Ensure that the two instructions are in the same cache line */
-	dsemul_insns = (mips_instruction *) REG_TO_VA ((regs->regs[29] - sizeof(struct emuframe)) & ~0x7);
+	dsemul_insns = (mips_instruction *) ((regs->regs[29] - sizeof(struct emuframe)) & ~0x7);
 	fr = (struct emuframe *) dsemul_insns;
 
 	/* Verify that the stack pointer is not competely insane */
@@ -104,11 +101,11 @@
 	err |= __put_user(cpc, &fr->epc);
 
 	if (unlikely(err)) {
-		fpuemuprivate.stats.errors++;
+		fpuemustats.errors++;
 		return SIGBUS;
 	}
 
-	regs->cp0_epc = VA_TO_REG & fr->emul;
+	regs->cp0_epc = (unsigned long) &fr->emul;
 
 	flush_cache_sigtramp((unsigned long)&fr->badinst);
 
@@ -118,7 +115,7 @@
 int do_dsemulret(struct pt_regs *xcp)
 {
 	struct emuframe *fr;
-	gpreg_t epc;
+	unsigned long epc;
 	u32 insn, cookie;
 	int err = 0;
 
@@ -141,7 +138,7 @@
 	err |= __get_user(cookie, &fr->cookie);
 
 	if (unlikely(err || (insn != BADINST) || (cookie != BD_COOKIE))) {
-		fpuemuprivate.stats.errors++;
+		fpuemustats.errors++;
 		return 0;
 	}
 
diff -Naur linux-2.6.14/arch/mips/math-emu/dsemul.h linux-mips-2.6.14.orig/arch/mips/math-emu/dsemul.h
--- linux-2.6.14/arch/mips/math-emu/dsemul.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/dsemul.h	2005-11-17 11:42:24.000000000 -0800
@@ -1,11 +1,5 @@
-typedef long gpreg_t;
-typedef void *vaddr_t;
-
-#define REG_TO_VA (vaddr_t)
-#define VA_TO_REG (gpreg_t)
-
-int mips_dsemul(struct pt_regs *regs, mips_instruction ir, gpreg_t cpc);
-int do_dsemulret(struct pt_regs *xcp);
+extern int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc);
+extern int do_dsemulret(struct pt_regs *xcp);
 
 /* Instruction which will always cause an address error */
 #define AdELOAD 0x8c000001	/* lw $0,1($0) */
diff -Naur linux-2.6.14/arch/mips/math-emu/ieee754.c linux-mips-2.6.14.orig/arch/mips/math-emu/ieee754.c
--- linux-2.6.14/arch/mips/math-emu/ieee754.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/ieee754.c	2005-11-17 11:42:24.000000000 -0800
@@ -31,6 +31,8 @@
 
 
 #include "ieee754int.h"
+#include "ieee754sp.h"
+#include "ieee754dp.h"
 
 #define DP_EBIAS	1023
 #define DP_EMIN		(-1022)
@@ -40,20 +42,6 @@
 #define SP_EMIN		(-126)
 #define SP_EMAX		127
 
-/* indexed by class */
-const char *const ieee754_cname[] = {
-	"Normal",
-	"Zero",
-	"Denormal",
-	"Infinity",
-	"QNaN",
-	"SNaN",
-};
-
-/* the control status register
-*/
-struct ieee754_csr ieee754_csr;
-
 /* special constants
 */
 
diff -Naur linux-2.6.14/arch/mips/math-emu/ieee754.h linux-mips-2.6.14.orig/arch/mips/math-emu/ieee754.h
--- linux-2.6.14/arch/mips/math-emu/ieee754.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/ieee754.h	2005-11-17 11:42:24.000000000 -0800
@@ -1,13 +1,8 @@
-/* single and double precision fp ops
- * missing extended precision.
-*/
 /*
  * MIPS floating point support
  * Copyright (C) 1994-2000 Algorithmics Ltd.
  * http://www.algor.co.uk
  *
- * ########################################################################
- *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
  *  published by the Free Software Foundation.
@@ -21,20 +16,18 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
  *
- * ########################################################################
- */
-
-/**************************************************************************
  *  Nov 7, 2000
  *  Modification to allow integration with Linux kernel
  *
  *  Kevin D. Kissell, kevink@mips.com and Carsten Langgard, carstenl@mips.com
  *  Copyright (C) 2000 MIPS Technologies, Inc. All rights reserved.
- *************************************************************************/
+ */
+#ifndef __ARCH_MIPS_MATH_EMU_IEEE754_H
+#define __ARCH_MIPS_MATH_EMU_IEEE754_H
 
-#ifdef __KERNEL__
-/* Going from Algorithmics to Linux native environment, add this */
+#include <asm/byteorder.h>
 #include <linux/types.h>
+#include <linux/sched.h>
 
 /*
  * Not very pretty, but the Linux kernel's normal va_list definition
@@ -44,18 +37,7 @@
 #include <stdarg.h>
 #endif
 
-#else
-
-/* Note that __KERNEL__ is taken to mean Linux kernel */
-
-#if #system(OpenBSD)
-#include <machine/types.h>
-#endif
-#include <machine/endian.h>
-
-#endif				/* __KERNEL__ */
-
-#if (defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN) || defined(__MIPSEL__)
+#ifdef __LITTLE_ENDIAN
 struct ieee754dp_konst {
 	unsigned mantlo:32;
 	unsigned manthi:20;
@@ -86,13 +68,14 @@
 } ieee754sp;
 #endif
 
-#if (defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN) || defined(__MIPSEB__)
+#ifdef __BIG_ENDIAN
 struct ieee754dp_konst {
 	unsigned sign:1;
 	unsigned bexp:11;
 	unsigned manthi:20;
 	unsigned mantlo:32;
 };
+
 typedef union _ieee754dp {
 	struct ieee754dp_konst oparts;
 	struct {
@@ -222,7 +205,6 @@
 #define IEEE754_CLASS_INF	0x03
 #define IEEE754_CLASS_SNAN	0x04
 #define IEEE754_CLASS_QNAN	0x05
-extern const char *const ieee754_cname[];
 
 /* exception numbers */
 #define IEEE754_INEXACT			0x01
@@ -251,93 +233,109 @@
 
 /* "normal" comparisons
 */
-static __inline int ieee754sp_eq(ieee754sp x, ieee754sp y)
+static inline int ieee754sp_eq(ieee754sp x, ieee754sp y)
 {
 	return ieee754sp_cmp(x, y, IEEE754_CEQ, 0);
 }
 
-static __inline int ieee754sp_ne(ieee754sp x, ieee754sp y)
+static inline int ieee754sp_ne(ieee754sp x, ieee754sp y)
 {
 	return ieee754sp_cmp(x, y,
 			     IEEE754_CLT | IEEE754_CGT | IEEE754_CUN, 0);
 }
 
-static __inline int ieee754sp_lt(ieee754sp x, ieee754sp y)
+static inline int ieee754sp_lt(ieee754sp x, ieee754sp y)
 {
 	return ieee754sp_cmp(x, y, IEEE754_CLT, 0);
 }
 
-static __inline int ieee754sp_le(ieee754sp x, ieee754sp y)
+static inline int ieee754sp_le(ieee754sp x, ieee754sp y)
 {
 	return ieee754sp_cmp(x, y, IEEE754_CLT | IEEE754_CEQ, 0);
 }
 
-static __inline int ieee754sp_gt(ieee754sp x, ieee754sp y)
+static inline int ieee754sp_gt(ieee754sp x, ieee754sp y)
 {
 	return ieee754sp_cmp(x, y, IEEE754_CGT, 0);
 }
 
 
-static __inline int ieee754sp_ge(ieee754sp x, ieee754sp y)
+static inline int ieee754sp_ge(ieee754sp x, ieee754sp y)
 {
 	return ieee754sp_cmp(x, y, IEEE754_CGT | IEEE754_CEQ, 0);
 }
 
-static __inline int ieee754dp_eq(ieee754dp x, ieee754dp y)
+static inline int ieee754dp_eq(ieee754dp x, ieee754dp y)
 {
 	return ieee754dp_cmp(x, y, IEEE754_CEQ, 0);
 }
 
-static __inline int ieee754dp_ne(ieee754dp x, ieee754dp y)
+static inline int ieee754dp_ne(ieee754dp x, ieee754dp y)
 {
 	return ieee754dp_cmp(x, y,
 			     IEEE754_CLT | IEEE754_CGT | IEEE754_CUN, 0);
 }
 
-static __inline int ieee754dp_lt(ieee754dp x, ieee754dp y)
+static inline int ieee754dp_lt(ieee754dp x, ieee754dp y)
 {
 	return ieee754dp_cmp(x, y, IEEE754_CLT, 0);
 }
 
-static __inline int ieee754dp_le(ieee754dp x, ieee754dp y)
+static inline int ieee754dp_le(ieee754dp x, ieee754dp y)
 {
 	return ieee754dp_cmp(x, y, IEEE754_CLT | IEEE754_CEQ, 0);
 }
 
-static __inline int ieee754dp_gt(ieee754dp x, ieee754dp y)
+static inline int ieee754dp_gt(ieee754dp x, ieee754dp y)
 {
 	return ieee754dp_cmp(x, y, IEEE754_CGT, 0);
 }
 
-static __inline int ieee754dp_ge(ieee754dp x, ieee754dp y)
+static inline int ieee754dp_ge(ieee754dp x, ieee754dp y)
 {
 	return ieee754dp_cmp(x, y, IEEE754_CGT | IEEE754_CEQ, 0);
 }
 
 
-/* like strtod
-*/
+/*
+ * Like strtod
+ */
 ieee754dp ieee754dp_fstr(const char *s, char **endp);
 char *ieee754dp_tstr(ieee754dp x, int prec, int fmt, int af);
 
 
-/* the control status register
-*/
-struct ieee754_csr {
-	unsigned pad:13;
+/*
+ * The control status register
+ */
+struct _ieee754_csr {
+#ifdef __BIG_ENDIAN
+	unsigned pad0:7;
 	unsigned nod:1;		/* set 1 for no denormalised numbers */
-	unsigned cx:5;		/* exceptions this operation */
+	unsigned c:1;		/* condition */
+	unsigned pad1:5;
+	unsigned cx:6;		/* exceptions this operation */
 	unsigned mx:5;		/* exception enable  mask */
 	unsigned sx:5;		/* exceptions total */
 	unsigned rm:2;		/* current rounding mode */
+#endif
+#ifdef __LITTLE_ENDIAN
+	unsigned rm:2;		/* current rounding mode */
+	unsigned sx:5;		/* exceptions total */
+	unsigned mx:5;		/* exception enable  mask */
+	unsigned cx:6;		/* exceptions this operation */
+	unsigned pad1:5;
+	unsigned c:1;		/* condition */
+	unsigned nod:1;		/* set 1 for no denormalised numbers */
+	unsigned pad0:7;
+#endif
 };
-extern struct ieee754_csr ieee754_csr;
+#define ieee754_csr (*(struct _ieee754_csr *)(&current->thread.fpu.soft.fcr31))
 
-static __inline unsigned ieee754_getrm(void)
+static inline unsigned ieee754_getrm(void)
 {
 	return (ieee754_csr.rm);
 }
-static __inline unsigned ieee754_setrm(unsigned rm)
+static inline unsigned ieee754_setrm(unsigned rm)
 {
 	return (ieee754_csr.rm = rm);
 }
@@ -345,14 +343,14 @@
 /*
  * get current exceptions
  */
-static __inline unsigned ieee754_getcx(void)
+static inline unsigned ieee754_getcx(void)
 {
 	return (ieee754_csr.cx);
 }
 
 /* test for current exception condition
  */
-static __inline int ieee754_cxtest(unsigned n)
+static inline int ieee754_cxtest(unsigned n)
 {
 	return (ieee754_csr.cx & n);
 }
@@ -360,21 +358,21 @@
 /*
  * get sticky exceptions
  */
-static __inline unsigned ieee754_getsx(void)
+static inline unsigned ieee754_getsx(void)
 {
 	return (ieee754_csr.sx);
 }
 
 /* clear sticky conditions
 */
-static __inline unsigned ieee754_clrsx(void)
+static inline unsigned ieee754_clrsx(void)
 {
 	return (ieee754_csr.sx = 0);
 }
 
 /* test for sticky exception condition
  */
-static __inline int ieee754_sxtest(unsigned n)
+static inline int ieee754_sxtest(unsigned n)
 {
 	return (ieee754_csr.sx & n);
 }
@@ -406,52 +404,34 @@
 #define ieee754dp_spcvals ((const ieee754dp *)__ieee754dp_spcvals)
 #define ieee754sp_spcvals ((const ieee754sp *)__ieee754sp_spcvals)
 
-/* return infinity with given sign
-*/
-#define ieee754dp_inf(sn)	\
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PINFINITY+(sn)])
-#define ieee754dp_zero(sn) \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PZERO+(sn)])
-#define ieee754dp_one(sn) \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PONE+(sn)])
-#define ieee754dp_ten(sn) \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PTEN+(sn)])
-#define ieee754dp_indef() \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_INDEF])
-#define ieee754dp_max(sn) \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PMAX+(sn)])
-#define ieee754dp_min(sn) \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PMIN+(sn)])
-#define ieee754dp_mind(sn) \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_PMIND+(sn)])
-#define ieee754dp_1e31() \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_P1E31])
-#define ieee754dp_1e63() \
-  (ieee754dp_spcvals[IEEE754_SPCVAL_P1E63])
-
-#define ieee754sp_inf(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PINFINITY+(sn)])
-#define ieee754sp_zero(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PZERO+(sn)])
-#define ieee754sp_one(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PONE+(sn)])
-#define ieee754sp_ten(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PTEN+(sn)])
-#define ieee754sp_indef() \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_INDEF])
-#define ieee754sp_max(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PMAX+(sn)])
-#define ieee754sp_min(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PMIN+(sn)])
-#define ieee754sp_mind(sn) \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_PMIND+(sn)])
-#define ieee754sp_1e31() \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_P1E31])
-#define ieee754sp_1e63() \
-  (ieee754sp_spcvals[IEEE754_SPCVAL_P1E63])
+/*
+ * Return infinity with given sign
+ */
+#define ieee754dp_inf(sn)     (ieee754dp_spcvals[IEEE754_SPCVAL_PINFINITY+(sn)])
+#define ieee754dp_zero(sn)	(ieee754dp_spcvals[IEEE754_SPCVAL_PZERO+(sn)])
+#define ieee754dp_one(sn)	(ieee754dp_spcvals[IEEE754_SPCVAL_PONE+(sn)])
+#define ieee754dp_ten(sn)	(ieee754dp_spcvals[IEEE754_SPCVAL_PTEN+(sn)])
+#define ieee754dp_indef()	(ieee754dp_spcvals[IEEE754_SPCVAL_INDEF])
+#define ieee754dp_max(sn)	(ieee754dp_spcvals[IEEE754_SPCVAL_PMAX+(sn)])
+#define ieee754dp_min(sn)	(ieee754dp_spcvals[IEEE754_SPCVAL_PMIN+(sn)])
+#define ieee754dp_mind(sn)	(ieee754dp_spcvals[IEEE754_SPCVAL_PMIND+(sn)])
+#define ieee754dp_1e31()	(ieee754dp_spcvals[IEEE754_SPCVAL_P1E31])
+#define ieee754dp_1e63()	(ieee754dp_spcvals[IEEE754_SPCVAL_P1E63])
+
+#define ieee754sp_inf(sn)     (ieee754sp_spcvals[IEEE754_SPCVAL_PINFINITY+(sn)])
+#define ieee754sp_zero(sn)	(ieee754sp_spcvals[IEEE754_SPCVAL_PZERO+(sn)])
+#define ieee754sp_one(sn)	(ieee754sp_spcvals[IEEE754_SPCVAL_PONE+(sn)])
+#define ieee754sp_ten(sn)	(ieee754sp_spcvals[IEEE754_SPCVAL_PTEN+(sn)])
+#define ieee754sp_indef()	(ieee754sp_spcvals[IEEE754_SPCVAL_INDEF])
+#define ieee754sp_max(sn)	(ieee754sp_spcvals[IEEE754_SPCVAL_PMAX+(sn)])
+#define ieee754sp_min(sn)	(ieee754sp_spcvals[IEEE754_SPCVAL_PMIN+(sn)])
+#define ieee754sp_mind(sn)	(ieee754sp_spcvals[IEEE754_SPCVAL_PMIND+(sn)])
+#define ieee754sp_1e31()	(ieee754sp_spcvals[IEEE754_SPCVAL_P1E31])
+#define ieee754sp_1e63()	(ieee754sp_spcvals[IEEE754_SPCVAL_P1E63])
 
-/* indefinite integer value
-*/
+/*
+ * Indefinite integer value
+ */
 #define ieee754si_indef()	INT_MAX
 #ifdef LONG_LONG_MAX
 #define ieee754di_indef()	LONG_LONG_MAX
@@ -487,3 +467,5 @@
 /* compat */
 #define ieee754dp_fix(x)	ieee754dp_tint(x)
 #define ieee754sp_fix(x)	ieee754sp_tint(x)
+
+#endif /* __ARCH_MIPS_MATH_EMU_IEEE754_H */
diff -Naur linux-2.6.14/arch/mips/math-emu/kernel_linkage.c linux-mips-2.6.14.orig/arch/mips/math-emu/kernel_linkage.c
--- linux-2.6.14/arch/mips/math-emu/kernel_linkage.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/math-emu/kernel_linkage.c	2005-11-17 11:42:24.000000000 -0800
@@ -27,8 +27,6 @@
 
 #include <asm/fpu_emulator.h>
 
-extern struct mips_fpu_emulator_private fpuemuprivate;
-
 #define SIGNALLING_NAN 0x7ff800007ff80000LL
 
 void fpu_emulator_init_fpu(void)
@@ -65,7 +63,6 @@
 			       &sc->sc_fpregs[i]);
 	}
 	err |= __put_user(current->thread.fpu.soft.fcr31, &sc->sc_fpc_csr);
-	err |= __put_user(fpuemuprivate.eir, &sc->sc_fpc_eir);
 
 	return err;
 }
@@ -81,7 +78,6 @@
 			       &sc->sc_fpregs[i]);
 	}
 	err |= __get_user(current->thread.fpu.soft.fcr31, &sc->sc_fpc_csr);
-	err |= __get_user(fpuemuprivate.eir, &sc->sc_fpc_eir);
 
 	return err;
 }
@@ -102,7 +98,6 @@
 			       &sc->sc_fpregs[i]);
 	}
 	err |= __put_user(current->thread.fpu.soft.fcr31, &sc->sc_fpc_csr);
-	err |= __put_user(fpuemuprivate.eir, &sc->sc_fpc_eir);
 
 	return err;
 }
@@ -118,7 +113,6 @@
 			       &sc->sc_fpregs[i]);
 	}
 	err |= __get_user(current->thread.fpu.soft.fcr31, &sc->sc_fpc_csr);
-	err |= __get_user(fpuemuprivate.eir, &sc->sc_fpc_eir);
 
 	return err;
 }
diff -Naur linux-2.6.14/arch/mips/mips-boards/atlas/atlas_int.c linux-mips-2.6.14.orig/arch/mips/mips-boards/atlas/atlas_int.c
--- linux-2.6.14/arch/mips/mips-boards/atlas/atlas_int.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/atlas/atlas_int.c	2005-11-17 11:42:24.000000000 -0800
@@ -76,14 +76,13 @@
 }
 
 static struct hw_interrupt_type atlas_irq_type = {
-	"Atlas",
-	startup_atlas_irq,
-	shutdown_atlas_irq,
-	enable_atlas_irq,
-	disable_atlas_irq,
-	mask_and_ack_atlas_irq,
-	end_atlas_irq,
-	NULL
+	.typename = "Atlas",
+	.startup = startup_atlas_irq,
+	.shutdown = shutdown_atlas_irq,
+	.enable = enable_atlas_irq,
+	.disable = disable_atlas_irq,
+	.ack = mask_and_ack_atlas_irq,
+	.end = end_atlas_irq,
 };
 
 static inline int ls1bit32(unsigned int x)
diff -Naur linux-2.6.14/arch/mips/mips-boards/atlas/atlas_setup.c linux-mips-2.6.14.orig/arch/mips/mips-boards/atlas/atlas_setup.c
--- linux-2.6.14/arch/mips/mips-boards/atlas/atlas_setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/atlas/atlas_setup.c	2005-11-17 11:42:24.000000000 -0800
@@ -50,8 +50,10 @@
 	return "MIPS Atlas";
 }
 
-static int __init atlas_setup(void)
+void __init plat_setup(void)
 {
+	mips_pcibios_init();
+
 	ioport_resource.end = 0x7fffffff;
 
 	serial_init ();
@@ -64,12 +66,8 @@
 	board_time_init = mips_time_init;
 	board_timer_setup = mips_timer_setup;
 	rtc_get_time = mips_rtc_get_time;
-
-	return 0;
 }
 
-early_initcall(atlas_setup);
-
 static void __init serial_init(void)
 {
 #ifdef CONFIG_SERIAL_8250
diff -Naur linux-2.6.14/arch/mips/mips-boards/generic/init.c linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/init.c
--- linux-2.6.14/arch/mips/mips-boards/generic/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/init.c	2005-11-17 11:42:24.000000000 -0800
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004, 2005  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -22,18 +24,19 @@
 #include <linux/string.h>
 #include <linux/kernel.h>
 
-#include <asm/io.h>
 #include <asm/bootinfo.h>
+#include <asm/gt64120.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/cacheflush.h>
+#include <asm/traps.h>
+
 #include <asm/mips-boards/prom.h>
 #include <asm/mips-boards/generic.h>
-#ifdef CONFIG_MIPS_GT64120
-#include <asm/gt64120.h>
-#endif
-#include <asm/mips-boards/msc01_pci.h>
 #include <asm/mips-boards/bonito64.h>
-#ifdef CONFIG_MIPS_MALTA
+#include <asm/mips-boards/msc01_pci.h>
+
 #include <asm/mips-boards/malta.h>
-#endif
 
 #ifdef CONFIG_KGDB
 extern int rs_kgdb_hook(int, int);
@@ -223,8 +226,34 @@
 }
 #endif
 
+void __init mips_nmi_setup (void)
+{
+	void *base;
+	extern char except_vec_nmi;
+
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa80) :
+		(void *)(CAC_BASE + 0x380);
+	memcpy(base, &except_vec_nmi, 0x80);
+	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+}
+
+void __init mips_ejtag_setup (void)
+{
+	void *base;
+	extern char except_vec_ejtag_debug;
+
+	base = cpu_has_veic ?
+		(void *)(CAC_BASE + 0xa00) :
+		(void *)(CAC_BASE + 0x300);
+	memcpy(base, &except_vec_ejtag_debug, 0x80);
+	flush_icache_range((unsigned long)base, (unsigned long)base + 0x80);
+}
+
 void __init prom_init(void)
 {
+	u32 start, map, mask, data;
+
 	prom_argc = fw_arg0;
 	_prom_argv = (int *) fw_arg1;
 	_prom_envp = (int *) fw_arg2;
@@ -266,12 +295,15 @@
 #else
 		GT_WRITE(GT_PCI0_CMD_OFS, 0);
 #endif
+		/* Fix up PCI I/O mapping if necessary (for Atlas).  */
+		start = GT_READ(GT_PCI0IOLD_OFS);
+		map = GT_READ(GT_PCI0IOREMAP_OFS);
+		if ((start & map) != 0) {
+			map &= ~start;
+			GT_WRITE(GT_PCI0IOREMAP_OFS, map);
+		}
 
-#ifdef CONFIG_MIPS_MALTA
 		set_io_port_base(MALTA_GT_PORT_BASE);
-#else
-		set_io_port_base((unsigned long)ioremap(0, 0x20000000));
-#endif
 		break;
 
 	case MIPS_REVISION_CORID_CORE_EMUL_BON:
@@ -300,18 +332,21 @@
 			BONITO_BONGENCFG_BYTESWAP;
 #endif
 
-#ifdef CONFIG_MIPS_MALTA
 		set_io_port_base(MALTA_BONITO_PORT_BASE);
-#else
-		set_io_port_base((unsigned long)ioremap(0, 0x20000000));
-#endif
 		break;
 
 	case MIPS_REVISION_CORID_CORE_MSC:
 	case MIPS_REVISION_CORID_CORE_FPGA2:
+	case MIPS_REVISION_CORID_CORE_FPGA3:
 	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
 		_pcictrl_msc = (unsigned long)ioremap(MIPS_MSC01_PCI_REG_BASE, 0x2000);
 
+		mb();
+		MSC_READ(MSC01_PCI_CFG, data);
+		MSC_WRITE(MSC01_PCI_CFG, data & ~MSC01_PCI_CFG_EN_BIT);
+		wmb();
+
+		/* Fix up lane swapping.  */
 #ifdef CONFIG_CPU_LITTLE_ENDIAN
 		MSC_WRITE(MSC01_PCI_SWAP, MSC01_PCI_SWAP_NOSWAP);
 #else
@@ -320,12 +355,23 @@
 			  MSC01_PCI_SWAP_BYTESWAP << MSC01_PCI_SWAP_MEM_SHF |
 			  MSC01_PCI_SWAP_BYTESWAP << MSC01_PCI_SWAP_BAR0_SHF);
 #endif
+		/* Fix up target memory mapping.  */
+		MSC_READ(MSC01_PCI_BAR0, mask);
+		MSC_WRITE(MSC01_PCI_P2SCMSKL, mask & MSC01_PCI_BAR0_SIZE_MSK);
+
+		/* Don't handle target retries indefinitely.  */
+		if ((data & MSC01_PCI_CFG_MAXRTRY_MSK) ==
+		    MSC01_PCI_CFG_MAXRTRY_MSK)
+			data = (data & ~(MSC01_PCI_CFG_MAXRTRY_MSK <<
+					 MSC01_PCI_CFG_MAXRTRY_SHF)) |
+			       ((MSC01_PCI_CFG_MAXRTRY_MSK - 1) <<
+				MSC01_PCI_CFG_MAXRTRY_SHF);
+
+		wmb();
+		MSC_WRITE(MSC01_PCI_CFG, data);
+		mb();
 
-#ifdef CONFIG_MIPS_MALTA
 		set_io_port_base(MALTA_MSC_PORT_BASE);
-#else
-		set_io_port_base((unsigned long)ioremap(0, 0x20000000));
-#endif
 		break;
 
 	default:
@@ -334,6 +380,9 @@
 		while(1);   /* We die here... */
 	}
 #endif
+	board_nmi_handler_setup = mips_nmi_setup;
+	board_ejtag_handler_setup = mips_ejtag_setup;
+
 	prom_printf("\nLINUX started...\n");
 	prom_init_cmdline();
 	prom_meminit();
diff -Naur linux-2.6.14/arch/mips/mips-boards/generic/memory.c linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/memory.c
--- linux-2.6.14/arch/mips/mips-boards/generic/memory.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/memory.c	2005-11-17 11:42:25.000000000 -0800
@@ -22,6 +22,7 @@
 #include <linux/init.h>
 #include <linux/mm.h>
 #include <linux/bootmem.h>
+#include <linux/string.h>
 
 #include <asm/bootinfo.h>
 #include <asm/page.h>
@@ -55,18 +56,30 @@
 {
 	char *memsize_str;
 	unsigned int memsize;
+	char cmdline[CL_SIZE], *ptr;
 
-	memsize_str = prom_getenv("memsize");
-	if (!memsize_str) {
-		prom_printf("memsize not set in boot prom, set to default (32Mb)\n");
-		memsize = 0x02000000;
-	} else {
+	/* Check the command line first for a memsize directive */
+	strcpy(cmdline, arcs_cmdline);
+	ptr = strstr(cmdline, "memsize=");
+	if (ptr && (ptr != cmdline) && (*(ptr - 1) != ' '))
+		ptr = strstr(ptr, " memsize=");
+
+	if (ptr) {
+		memsize = memparse(ptr + 8, &ptr);
+	}
+	else {
+		/* otherwise look in the environment */
+		memsize_str = prom_getenv("memsize");
+		if (!memsize_str) {
+			prom_printf("memsize not set in boot prom, set to default (32Mb)\n");
+			memsize = 0x02000000;
+		} else {
 #ifdef DEBUG
-		prom_printf("prom_memsize = %s\n", memsize_str);
+			prom_printf("prom_memsize = %s\n", memsize_str);
 #endif
-		memsize = simple_strtol(memsize_str, NULL, 0);
+			memsize = simple_strtol(memsize_str, NULL, 0);
+		}
 	}
-
 	memset(mdesc, 0, sizeof(mdesc));
 
 	mdesc[0].type = yamon_dontuse;
diff -Naur linux-2.6.14/arch/mips/mips-boards/generic/mipsIRQ.S linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/mipsIRQ.S
--- linux-2.6.14/arch/mips/mips-boards/generic/mipsIRQ.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/mipsIRQ.S	2005-11-17 11:42:25.000000000 -0800
@@ -29,6 +29,20 @@
 #include <asm/regdef.h>
 #include <asm/stackframe.h>
 
+#ifdef CONFIG_MIPS_ATLAS
+#include <asm/mips-boards/atlasint.h>
+#define CASCADE_IRQ		MIPSCPU_INT_ATLAS
+#define CASCADE_DISPATCH	atlas_hw0_irqdispatch
+#endif
+#ifdef CONFIG_MIPS_MALTA
+#include <asm/mips-boards/maltaint.h>
+#define CASCADE_IRQ		MIPSCPU_INT_I8259A
+#define CASCADE_DISPATCH	malta_hw0_irqdispatch
+#endif
+#ifdef CONFIG_MIPS_SEAD
+#include <asm/mips-boards/seadint.h>
+#endif
+
 /* A lot of complication here is taken away because:
  *
  * 1) We handle one interrupt and return, sitting in a loop and moving across
@@ -80,74 +94,62 @@
 
 	mfc0	s0, CP0_CAUSE		# get irq bits
 	mfc0	s1, CP0_STATUS		# get irq mask
+	andi	s0, ST0_IM		# CAUSE.CE may be non-zero!
 	and	s0, s1
 
-	/* First we check for r4k counter/timer IRQ. */
-	andi	a0, s0, CAUSEF_IP7
-	beq	a0, zero, 1f
-	 andi	a0, s0, CAUSEF_IP2	# delay slot, check hw0 interrupt
-
-	/* Wheee, a timer interrupt. */
-	move	a0, sp
-	jal	mips_timer_interrupt
-	 nop
-
-	j	ret_from_irq
-	 nop
-
-1:
-#if defined(CONFIG_MIPS_SEAD)
-	beq	a0, zero, 1f
-	 andi	a0, s0, CAUSEF_IP3	# delay slot, check hw1 interrupt
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
+ 	.set	mips32
+	clz	a0, s0
+	.set	mips0
+	negu	a0
+	addu	a0, 31-CAUSEB_IP
+	bltz	a0, spurious
 #else
-	beq	a0, zero, 1f		# delay slot, check hw3 interrupt
- 	 andi	a0, s0, CAUSEF_IP5
-#endif
+	beqz	s0, spurious
+	 li	a0, 7
 
-	/* Wheee, combined hardware level zero interrupt. */
-#if defined(CONFIG_MIPS_ATLAS)
-	jal	atlas_hw0_irqdispatch
-#elif defined(CONFIG_MIPS_MALTA)
-	jal	malta_hw0_irqdispatch
-#elif defined(CONFIG_MIPS_SEAD)
-	jal	sead_hw0_irqdispatch
-#else
-#error "MIPS board not supported\n"
+	and	t0, s0, 0xf000
+	sltiu	t0, t0, 1
+	sll	t0, 2
+	subu	a0, t0
+	sll	s0, t0
+
+	and	t0, s0, 0xc000
+	sltiu	t0, t0, 1
+	sll	t0, 1
+	subu	a0, t0
+	sll	s0, t0
+
+	and	t0, s0, 0x8000
+	sltiu	t0, t0, 1
+	# sll	t0, 0
+	subu	a0, t0
+	# sll	s0, t0
 #endif
-	 move	a0, sp			# delay slot
 
-	j	ret_from_irq
-	 nop				# delay slot
+#ifdef CASCADE_IRQ
+	 li	a1, CASCADE_IRQ
+	bne	a0, a1, 1f
+	 addu	a0, MIPSCPU_INT_BASE
+
+	jal	CASCADE_DISPATCH
+	 move	 a0, sp
 
-1:
-#if defined(CONFIG_MIPS_SEAD)
-	beq	a0, zero, 1f
-	 andi	a0, s0, CAUSEF_IP5	# delay slot, check hw3 interrupt
-	jal	sead_hw1_irqdispatch
-	 move	a0, sp			# delay slot
-	j	ret_from_irq
-	 nop				# delay slot
-1:
-#endif
-#if defined(CONFIG_MIPS_MALTA)
-	beq	a0, zero, 1f            # check hw3 (coreHI) interrupt
-	 nop
-	jal	corehi_irqdispatch
-	 move	a0, sp
 	j	ret_from_irq
 	 nop
 1:
+#else
+	 addu	a0, MIPSCPU_INT_BASE
 #endif
-	/*
-	 * Here by mistake?  This is possible, what can happen is that by the
-	 * time we take the exception the IRQ pin goes low, so just leave if
-	 * this is the case.
-	 */
-	move	a1,s0
-	PRINT("Got interrupt: c0_cause = %08x\n")
-	mfc0	a1, CP0_EPC
-	PRINT("c0_epc = %08x\n")
+
+	jal	do_IRQ
+	 move	a1, sp
 
 	j	ret_from_irq
 	 nop
+
+
+spurious:
+	j	spurious_interrupt
+	 nop
 	END(mipsIRQ)
diff -Naur linux-2.6.14/arch/mips/mips-boards/generic/pci.c linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/pci.c
--- linux-2.6.14/arch/mips/mips-boards/generic/pci.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/pci.c	2005-11-17 11:42:25.000000000 -0800
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004, 2005  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
@@ -19,65 +21,46 @@
  *
  * MIPS boards specific PCI support.
  */
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 
-#include <asm/mips-boards/generic.h>
 #include <asm/gt64120.h>
+
+#include <asm/mips-boards/generic.h>
 #include <asm/mips-boards/bonito64.h>
 #include <asm/mips-boards/msc01_pci.h>
-#ifdef CONFIG_MIPS_MALTA
-#include <asm/mips-boards/malta.h>
-#endif
 
 static struct resource bonito64_mem_resource = {
 	.name	= "Bonito PCI MEM",
-	.start	= 0x10000000UL,
-	.end	= 0x1bffffffUL,
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource bonito64_io_resource = {
-	.name	= "Bonito IO MEM",
-	.start	= 0x00002000UL,	/* avoid conflicts with YAMON allocated I/O addresses */
+	.name	= "Bonito PCI I/O",
+	.start	= 0x00000000UL,
 	.end	= 0x000fffffUL,
 	.flags	= IORESOURCE_IO,
 };
 
 static struct resource gt64120_mem_resource = {
-	.name	= "GT64120 PCI MEM",
-	.start	= 0x10000000UL,
-	.end	= 0x1bdfffffUL,
+	.name	= "GT-64120 PCI MEM",
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource gt64120_io_resource = {
-	.name	= "GT64120 IO MEM",
-#ifdef CONFIG_MIPS_ATLAS
-	.start	= 0x18000000UL,
-	.end	= 0x181fffffUL,
-#endif
-#ifdef CONFIG_MIPS_MALTA
-	.start	= 0x00002000UL,
-	.end	= 0x001fffffUL,
-#endif
+	.name	= "GT-64120 PCI I/O",
 	.flags	= IORESOURCE_IO,
 };
 
 static struct resource msc_mem_resource = {
 	.name	= "MSC PCI MEM",
-	.start	= 0x10000000UL,
-	.end	= 0x1fffffffUL,
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource msc_io_resource = {
-	.name	= "MSC IO MEM",
-	.start	= 0x00002000UL,
-	.end	= 0x007fffffUL,
+	.name	= "MSC PCI I/O",
 	.flags	= IORESOURCE_IO,
 };
 
@@ -89,7 +72,6 @@
 	.pci_ops	= &bonito64_pci_ops,
 	.io_resource	= &bonito64_io_resource,
 	.mem_resource	= &bonito64_mem_resource,
-	.mem_offset	= 0x10000000UL,
 	.io_offset	= 0x00000000UL,
 };
 
@@ -97,21 +79,18 @@
 	.pci_ops	= &gt64120_pci_ops,
 	.io_resource	= &gt64120_io_resource,
 	.mem_resource	= &gt64120_mem_resource,
-	.mem_offset	= 0x00000000UL,
-	.io_offset	= 0x00000000UL,
 };
 
-static struct pci_controller  msc_controller = {
+static struct pci_controller msc_controller = {
 	.pci_ops	= &msc_pci_ops,
 	.io_resource	= &msc_io_resource,
 	.mem_resource	= &msc_mem_resource,
-	.mem_offset	= 0x10000000UL,
-	.io_offset	= 0x00000000UL,
 };
 
-static int __init pcibios_init(void)
+void __init mips_pcibios_init(void)
 {
 	struct pci_controller *controller;
+	unsigned long start, end, map, start1, end1, map1, map2, map3, mask;
 
 	switch (mips_revision_corid) {
 	case MIPS_REVISION_CORID_QED_RM5261:
@@ -130,34 +109,140 @@
 			 (0 << GT_PCI0_CFGADDR_DEVNUM_SHF) | /* GT64120 dev */
 			 (0 << GT_PCI0_CFGADDR_FUNCTNUM_SHF) | /* Function 0*/
 			 ((0x20/4) << GT_PCI0_CFGADDR_REGNUM_SHF) | /* BAR 4*/
-			 GT_PCI0_CFGADDR_CONFIGEN_BIT );
+			 GT_PCI0_CFGADDR_CONFIGEN_BIT);
 
 		/* Perform the write */
 		GT_WRITE(GT_PCI0_CFGDATA_OFS, CPHYSADDR(MIPS_GT_BASE));
 
+		/* Set up resource ranges from the controller's registers.  */
+		start = GT_READ(GT_PCI0M0LD_OFS);
+		end = GT_READ(GT_PCI0M0HD_OFS);
+		map = GT_READ(GT_PCI0M0REMAP_OFS);
+		end = (end & GT_PCI_HD_MSK) | (start & ~GT_PCI_HD_MSK);
+		start1 = GT_READ(GT_PCI0M1LD_OFS);
+		end1 = GT_READ(GT_PCI0M1HD_OFS);
+		map1 = GT_READ(GT_PCI0M1REMAP_OFS);
+		end1 = (end1 & GT_PCI_HD_MSK) | (start1 & ~GT_PCI_HD_MSK);
+		/* Cannot support multiple windows, use the wider.  */
+		if (end1 - start1 > end - start) {
+			start = start1;
+			end = end1;
+			map = map1;
+		}
+		mask = ~(start ^ end);
+                /* We don't support remapping with a discontiguous mask.  */
+		BUG_ON((start & GT_PCI_HD_MSK) != (map & GT_PCI_HD_MSK) &&
+		       mask != ~((mask & -mask) - 1));
+		gt64120_mem_resource.start = start;
+		gt64120_mem_resource.end = end;
+		gt64120_controller.mem_offset = (start & mask) - (map & mask);
+		/* Addresses are 36-bit, so do shifts in the destinations.  */
+		gt64120_mem_resource.start <<= GT_PCI_DCRM_SHF;
+		gt64120_mem_resource.end <<= GT_PCI_DCRM_SHF;
+		gt64120_mem_resource.end |= (1 << GT_PCI_DCRM_SHF) - 1;
+		gt64120_controller.mem_offset <<= GT_PCI_DCRM_SHF;
+
+		start = GT_READ(GT_PCI0IOLD_OFS);
+		end = GT_READ(GT_PCI0IOHD_OFS);
+		map = GT_READ(GT_PCI0IOREMAP_OFS);
+		end = (end & GT_PCI_HD_MSK) | (start & ~GT_PCI_HD_MSK);
+		mask = ~(start ^ end);
+                /* We don't support remapping with a discontiguous mask.  */
+		BUG_ON((start & GT_PCI_HD_MSK) != (map & GT_PCI_HD_MSK) &&
+		       mask != ~((mask & -mask) - 1));
+		gt64120_io_resource.start = map & mask;
+		gt64120_io_resource.end = (map & mask) | ~mask;
+		gt64120_controller.io_offset = 0;
+		/* Addresses are 36-bit, so do shifts in the destinations.  */
+		gt64120_io_resource.start <<= GT_PCI_DCRM_SHF;
+		gt64120_io_resource.end <<= GT_PCI_DCRM_SHF;
+		gt64120_io_resource.end |= (1 << GT_PCI_DCRM_SHF) - 1;
+
 		controller = &gt64120_controller;
 		break;
 
 	case MIPS_REVISION_CORID_BONITO64:
 	case MIPS_REVISION_CORID_CORE_20K:
 	case MIPS_REVISION_CORID_CORE_EMUL_BON:
+		/* Set up resource ranges from the controller's registers.  */
+		map = BONITO_PCIMAP;
+		map1 = (BONITO_PCIMAP & BONITO_PCIMAP_PCIMAP_LO0) >>
+		       BONITO_PCIMAP_PCIMAP_LO0_SHIFT;
+		map2 = (BONITO_PCIMAP & BONITO_PCIMAP_PCIMAP_LO1) >>
+		       BONITO_PCIMAP_PCIMAP_LO1_SHIFT;
+		map3 = (BONITO_PCIMAP & BONITO_PCIMAP_PCIMAP_LO2) >>
+		       BONITO_PCIMAP_PCIMAP_LO2_SHIFT;
+		/* Combine as many adjacent windows as possible.  */
+		map = map1;
+		start = BONITO_PCILO0_BASE;
+		end = 1;
+		if (map3 == map2 + 1) {
+			map = map2;
+			start = BONITO_PCILO1_BASE;
+			end++;
+		}
+		if (map2 == map1 + 1) {
+			map = map1;
+			start = BONITO_PCILO0_BASE;
+			end++;
+		}
+		bonito64_mem_resource.start = start;
+		bonito64_mem_resource.end = start +
+					    BONITO_PCIMAP_WINBASE(end) - 1;
+		bonito64_controller.mem_offset = start -
+						 BONITO_PCIMAP_WINBASE(map);
+
 		controller = &bonito64_controller;
 		break;
 
 	case MIPS_REVISION_CORID_CORE_MSC:
 	case MIPS_REVISION_CORID_CORE_FPGA2:
+	case MIPS_REVISION_CORID_CORE_FPGA3:
 	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
+		/* Set up resource ranges from the controller's registers.  */
+		MSC_READ(MSC01_PCI_SC2PMBASL, start);
+		MSC_READ(MSC01_PCI_SC2PMMSKL, mask);
+		MSC_READ(MSC01_PCI_SC2PMMAPL, map);
+		msc_mem_resource.start = start & mask;
+		msc_mem_resource.end = (start & mask) | ~mask;
+		msc_controller.mem_offset = (start & mask) - (map & mask);
+
+		MSC_READ(MSC01_PCI_SC2PIOBASL, start);
+		MSC_READ(MSC01_PCI_SC2PIOMSKL, mask);
+		MSC_READ(MSC01_PCI_SC2PIOMAPL, map);
+		msc_io_resource.start = map & mask;
+		msc_io_resource.end = (map & mask) | ~mask;
+		msc_controller.io_offset = 0;
+		ioport_resource.end = ~mask;
+
+		/* If ranges overlap I/O takes precedence.  */
+		start = start & mask;
+		end = start | ~mask;
+		if ((start >= msc_mem_resource.start &&
+		     start <= msc_mem_resource.end) ||
+		    (end >= msc_mem_resource.start &&
+		     end <= msc_mem_resource.end)) {
+			/* Use the larger space.  */
+			start = max(start, msc_mem_resource.start);
+			end = min(end, msc_mem_resource.end);
+			if (start - msc_mem_resource.start >=
+			    msc_mem_resource.end - end)
+				msc_mem_resource.end = start - 1;
+			else
+				msc_mem_resource.start = end + 1;
+		}
+
 		controller = &msc_controller;
 		break;
 	default:
-		return 1;
+		return;
 	}
 
+	if (controller->io_resource->start < 0x00001000UL)	/* FIXME */
+		controller->io_resource->start = 0x00001000UL;
+
+	iomem_resource.end &= 0xfffffffffULL;			/* 64 GB */
 	ioport_resource.end = controller->io_resource->end;
 
 	register_pci_controller (controller);
-
-	return 0;
 }
-
-early_initcall(pcibios_init);
diff -Naur linux-2.6.14/arch/mips/mips-boards/generic/time.c linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/time.c
--- linux-2.6.14/arch/mips/mips-boards/generic/time.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/generic/time.c	2005-11-17 11:42:25.000000000 -0800
@@ -31,22 +31,21 @@
 
 #include <asm/mipsregs.h>
 #include <asm/ptrace.h>
+#include <asm/hardirq.h>
+#include <asm/irq.h>
 #include <asm/div64.h>
 #include <asm/cpu.h>
 #include <asm/time.h>
 #include <asm/mc146818-time.h>
+#include <asm/msc01_ic.h>
 
 #include <asm/mips-boards/generic.h>
 #include <asm/mips-boards/prom.h>
+#include <asm/mips-boards/maltaint.h>
+#include <asm/mc146818-time.h>
 
 unsigned long cpu_khz;
 
-#if defined(CONFIG_MIPS_SEAD)
-#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ5)
-#else
-#define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
-#endif
-
 #if defined(CONFIG_MIPS_ATLAS)
 static char display_string[] = "        LINUX ON ATLAS       ";
 #endif
@@ -59,20 +58,61 @@
 static unsigned int display_count = 0;
 #define MAX_DISPLAY_COUNT (sizeof(display_string) - 8)
 
-#define MIPS_CPU_TIMER_IRQ (NR_IRQS-1)
-
 static unsigned int timer_tick_count=0;
+static int mips_cpu_timer_irq;
 
-void mips_timer_interrupt(struct pt_regs *regs)
+static inline void scroll_display_message(void)
 {
 	if ((timer_tick_count++ % HZ) == 0) {
 		mips_display_message(&display_string[display_count++]);
 		if (display_count == MAX_DISPLAY_COUNT)
-		        display_count = 0;
+			display_count = 0;
+	}
+}
+
+static void mips_timer_dispatch (struct pt_regs *regs)
+{
+	do_IRQ (mips_cpu_timer_irq, regs);
+}
 
+irqreturn_t mips_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+#ifdef CONFIG_SMP
+	int cpu = smp_processor_id();
+
+	if (cpu == 0) {
+		/*
+		 * CPU 0 handles the global timer interrupt job and process accounting
+		 * resets count/compare registers to trigger next timer int.
+		 */
+		(void) timer_interrupt(irq, dev_id, regs);
+		scroll_display_message();
+	}
+	else {
+		/* Everyone else needs to reset the timer int here as
+		   ll_local_timer_interrupt doesn't */
+		/*
+		 * FIXME: need to cope with counter underflow.
+		 * More support needs to be added to kernel/time for
+		 * counter/timer interrupts on multiple CPU's
+		 */
+		write_c0_compare (read_c0_count() + (mips_hpt_frequency/HZ));
+		/*
+		 * other CPUs should do profiling and process accounting
+		 */
+		local_timer_interrupt (irq, dev_id, regs);
 	}
 
-	ll_timer_interrupt(MIPS_CPU_TIMER_IRQ, regs);
+	return IRQ_HANDLED;
+#else
+	irqreturn_t r;
+
+	r = timer_interrupt(irq, dev_id, regs);
+
+	scroll_display_message();
+
+	return r;
+#endif
 }
 
 /*
@@ -140,10 +180,8 @@
 
 	local_irq_save(flags);
 
-#if defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_MALTA)
         /* Set Data mode - binary. */
         CMOS_WRITE(CMOS_READ(RTC_CONTROL) | RTC_DM_BINARY, RTC_CONTROL);
-#endif
 
 	est_freq = estimate_cpu_frequency ();
 
@@ -157,11 +195,29 @@
 
 void __init mips_timer_setup(struct irqaction *irq)
 {
+	if (cpu_has_veic) {
+		set_vi_handler (MSC01E_INT_CPUCTR, mips_timer_dispatch);
+		mips_cpu_timer_irq = MSC01E_INT_BASE + MSC01E_INT_CPUCTR;
+	}
+	else {
+		if (cpu_has_vint)
+			set_vi_handler (MIPSCPU_INT_CPUCTR, mips_timer_dispatch);
+		mips_cpu_timer_irq = MIPSCPU_INT_BASE + MIPSCPU_INT_CPUCTR;
+	}
+
+
 	/* we are using the cpu counter for timer interrupts */
-	irq->handler = no_action;     /* we use our own handler */
-	setup_irq(MIPS_CPU_TIMER_IRQ, irq);
+	irq->handler = mips_timer_interrupt;	/* we use our own handler */
+	setup_irq(mips_cpu_timer_irq, irq);
+
+#ifdef CONFIG_SMP
+	/* irq_desc(riptor) is a global resource, when the interrupt overlaps
+	   on seperate cpu's the first one tries to handle the second interrupt.
+	   The effect is that the int remains disabled on the second cpu.
+	   Mark the interrupt with IRQ_PER_CPU to avoid any confusion */
+	irq_desc[mips_cpu_timer_irq].status |= IRQ_PER_CPU;
+#endif
 
         /* to generate the first timer interrupt */
 	write_c0_compare (read_c0_count() + mips_hpt_frequency/HZ);
-	set_c0_status(ALLINTS);
 }
diff -Naur linux-2.6.14/arch/mips/mips-boards/malta/malta_int.c linux-mips-2.6.14.orig/arch/mips/mips-boards/malta/malta_int.c
--- linux-2.6.14/arch/mips/mips-boards/malta/malta_int.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/malta/malta_int.c	2005-11-17 11:42:25.000000000 -0800
@@ -30,6 +30,7 @@
 #include <linux/random.h>
 
 #include <asm/i8259.h>
+#include <asm/irq_cpu.h>
 #include <asm/io.h>
 #include <asm/mips-boards/malta.h>
 #include <asm/mips-boards/maltaint.h>
@@ -37,8 +38,10 @@
 #include <asm/gt64120.h>
 #include <asm/mips-boards/generic.h>
 #include <asm/mips-boards/msc01_pci.h>
+#include <asm/msc01_ic.h>
 
 extern asmlinkage void mipsIRQ(void);
+extern void mips_timer_interrupt(void);
 
 static DEFINE_SPINLOCK(mips_irq_lock);
 
@@ -54,6 +57,7 @@
 	switch(mips_revision_corid) {
 	case MIPS_REVISION_CORID_CORE_MSC:
 	case MIPS_REVISION_CORID_CORE_FPGA2:
+	case MIPS_REVISION_CORID_CORE_FPGA3:
 	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
 	        MSC_READ(MSC01_PCI_IACK, irq);
 		irq &= 0xff;
@@ -91,88 +95,86 @@
 	return irq;
 }
 
-static inline int get_int(int *irq)
+static inline int get_int(void)
 {
 	unsigned long flags;
-
+	int irq;
 	spin_lock_irqsave(&mips_irq_lock, flags);
 
-	*irq = mips_pcibios_iack();
+	irq = mips_pcibios_iack();
 
 	/*
-	 * IRQ7 is used to detect spurious interrupts.
-	 * The interrupt acknowledge cycle returns IRQ7, if no
-	 * interrupts is requested.
-	 * We can differentiate between this situation and a
-	 * "Normal" IRQ7 by reading the ISR.
+	 * The only way we can decide if an interrupt is spurious
+	 * is by checking the 8259 registers.  This needs a spinlock
+	 * on an SMP system,  so leave it up to the generic code...
 	 */
-	if (*irq == 7)
-	{
-		outb(PIIX4_OCW3_SEL | PIIX4_OCW3_ISR,
-		     PIIX4_ICTLR1_OCW3);
-		if (!(inb(PIIX4_ICTLR1_OCW3) & (1 << 7))) {
-			spin_unlock_irqrestore(&mips_irq_lock, flags);
-			printk("We got a spurious interrupt from PIIX4.\n");
-			atomic_inc(&irq_err_count);
-			return -1;    /* Spurious interrupt. */
-		}
-	}
 
 	spin_unlock_irqrestore(&mips_irq_lock, flags);
 
-	return 0;
+	return irq;
 }
 
 void malta_hw0_irqdispatch(struct pt_regs *regs)
 {
 	int irq;
 
-	if (get_int(&irq))
-	        return;  /* interrupt has already been cleared */
+	irq = get_int();
+	if (irq < 0)
+		return;  /* interrupt has already been cleared */
 
-	do_IRQ(irq, regs);
+	do_IRQ(MALTA_INT_BASE+irq, regs);
 }
 
 void corehi_irqdispatch(struct pt_regs *regs)
 {
-        unsigned int data,datahi;
-
-	/* Mask out corehi interrupt. */
-	clear_c0_status(IE_IRQ3);
+	unsigned int intrcause,datalo,datahi;
+        unsigned int pcimstat, intisr, inten, intpol, intedge, intsteer, pcicmd, pcibadaddr;
 
         printk("CoreHI interrupt, shouldn't happen, so we die here!!!\n");
         printk("epc   : %08lx\nStatus: %08lx\nCause : %08lx\nbadVaddr : %08lx\n"
 , regs->cp0_epc, regs->cp0_status, regs->cp0_cause, regs->cp0_badvaddr);
+
+	/* Read all the registers and then print them as there is a
+	   problem with interspersed printk's upsetting the Bonito controller.
+	   Do it for the others too.
+	*/
+
         switch(mips_revision_corid) {
         case MIPS_REVISION_CORID_CORE_MSC:
         case MIPS_REVISION_CORID_CORE_FPGA2:
-	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
+        case MIPS_REVISION_CORID_CORE_FPGA3:
+        case MIPS_REVISION_CORID_CORE_EMUL_MSC:
+                ll_msc_irq(regs);
                 break;
         case MIPS_REVISION_CORID_QED_RM5261:
         case MIPS_REVISION_CORID_CORE_LV:
         case MIPS_REVISION_CORID_CORE_FPGA:
         case MIPS_REVISION_CORID_CORE_FPGAR2:
-                data = GT_READ(GT_INTRCAUSE_OFS);
-                printk("GT_INTRCAUSE = %08x\n", data);
-                data = GT_READ(GT_CPUERR_ADDRLO_OFS);
+                intrcause = GT_READ(GT_INTRCAUSE_OFS);
+                datalo = GT_READ(GT_CPUERR_ADDRLO_OFS);
                 datahi = GT_READ(GT_CPUERR_ADDRHI_OFS);
-                printk("GT_CPUERR_ADDR = %02x%08x\n", datahi, data);
+                printk("GT_INTRCAUSE = %08x\n", intrcause);
+                printk("GT_CPUERR_ADDR = %02x%08x\n", datahi, datalo);
                 break;
         case MIPS_REVISION_CORID_BONITO64:
         case MIPS_REVISION_CORID_CORE_20K:
         case MIPS_REVISION_CORID_CORE_EMUL_BON:
-                data = BONITO_INTISR;
-                printk("BONITO_INTISR = %08x\n", data);
-                data = BONITO_INTEN;
-                printk("BONITO_INTEN = %08x\n", data);
-                data = BONITO_INTPOL;
-                printk("BONITO_INTPOL = %08x\n", data);
-                data = BONITO_INTEDGE;
-                printk("BONITO_INTEDGE = %08x\n", data);
-                data = BONITO_INTSTEER;
-                printk("BONITO_INTSTEER = %08x\n", data);
-                data = BONITO_PCICMD;
-                printk("BONITO_PCICMD = %08x\n", data);
+                pcibadaddr = BONITO_PCIBADADDR;
+                pcimstat = BONITO_PCIMSTAT;
+                intisr = BONITO_INTISR;
+                inten = BONITO_INTEN;
+                intpol = BONITO_INTPOL;
+                intedge = BONITO_INTEDGE;
+                intsteer = BONITO_INTSTEER;
+                pcicmd = BONITO_PCICMD;
+                printk("BONITO_INTISR = %08x\n", intisr);
+                printk("BONITO_INTEN = %08x\n", inten);
+                printk("BONITO_INTPOL = %08x\n", intpol);
+                printk("BONITO_INTEDGE = %08x\n", intedge);
+                printk("BONITO_INTSTEER = %08x\n", intsteer);
+                printk("BONITO_PCICMD = %08x\n", pcicmd);
+                printk("BONITO_PCIBADADDR = %08x\n", pcibadaddr);
+                printk("BONITO_PCIMSTAT = %08x\n", pcimstat);
                 break;
         }
 
@@ -180,8 +182,71 @@
         die("CoreHi interrupt", regs);
 }
 
+static struct irqaction i8259irq = {
+	.handler = no_action,
+	.name = "XT-PIC cascade"
+};
+
+static struct irqaction corehi_irqaction = {
+	.handler = no_action,
+	.name = "CoreHi"
+};
+
+msc_irqmap_t __initdata msc_irqmap[] = {
+	{MSC01C_INT_TMR,		MSC01_IRQ_EDGE, 0},
+	{MSC01C_INT_PCI,		MSC01_IRQ_LEVEL, 0},
+};
+int __initdata msc_nr_irqs = sizeof(msc_irqmap)/sizeof(msc_irqmap_t);
+
+msc_irqmap_t __initdata msc_eicirqmap[] = {
+	{MSC01E_INT_SW0,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_SW1,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_I8259A,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_SMI,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_COREHI,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_CORELO,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_TMR,		MSC01_IRQ_EDGE, 0},
+	{MSC01E_INT_PCI,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_PERFCTR,		MSC01_IRQ_LEVEL, 0},
+	{MSC01E_INT_CPUCTR,		MSC01_IRQ_LEVEL, 0}
+};
+int __initdata msc_nr_eicirqs = sizeof(msc_eicirqmap)/sizeof(msc_irqmap_t);
+
 void __init arch_init_irq(void)
 {
 	set_except_vector(0, mipsIRQ);
 	init_i8259_irqs();
+
+	if (!cpu_has_veic)
+		mips_cpu_irq_init (MIPSCPU_INT_BASE);
+
+        switch(mips_revision_corid) {
+        case MIPS_REVISION_CORID_CORE_MSC:
+        case MIPS_REVISION_CORID_CORE_FPGA2:
+        case MIPS_REVISION_CORID_CORE_FPGA3:
+        case MIPS_REVISION_CORID_CORE_EMUL_MSC:
+		if (cpu_has_veic)
+			init_msc_irqs (MSC01E_INT_BASE, msc_eicirqmap, msc_nr_eicirqs);
+		else
+			init_msc_irqs (MSC01C_INT_BASE, msc_irqmap, msc_nr_irqs);
+	}
+
+	if (cpu_has_veic) {
+		set_vi_handler (MSC01E_INT_I8259A, malta_hw0_irqdispatch);
+		set_vi_handler (MSC01E_INT_COREHI, corehi_irqdispatch);
+		setup_irq (MSC01E_INT_BASE+MSC01E_INT_I8259A, &i8259irq);
+		setup_irq (MSC01E_INT_BASE+MSC01E_INT_COREHI, &corehi_irqaction);
+	}
+	else if (cpu_has_vint) {
+		set_vi_handler (MIPSCPU_INT_I8259A, malta_hw0_irqdispatch);
+		set_vi_handler (MIPSCPU_INT_COREHI, corehi_irqdispatch);
+
+		setup_irq (MIPSCPU_INT_BASE+MIPSCPU_INT_I8259A, &i8259irq);
+		setup_irq (MIPSCPU_INT_BASE+MIPSCPU_INT_COREHI, &corehi_irqaction);
+	}
+	else {
+		set_except_vector(0, mipsIRQ);
+		setup_irq (MIPSCPU_INT_BASE+MIPSCPU_INT_I8259A, &i8259irq);
+		setup_irq (MIPSCPU_INT_BASE+MIPSCPU_INT_COREHI, &corehi_irqaction);
+	}
 }
diff -Naur linux-2.6.14/arch/mips/mips-boards/malta/malta_setup.c linux-mips-2.6.14.orig/arch/mips/mips-boards/malta/malta_setup.c
--- linux-2.6.14/arch/mips/mips-boards/malta/malta_setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/malta/malta_setup.c	2005-11-17 11:42:25.000000000 -0800
@@ -111,10 +111,12 @@
 }
 #endif
 
-static int __init malta_setup(void)
+void __init plat_setup(void)
 {
 	unsigned int i;
 
+	mips_pcibios_init();
+
 	/* Request I/O space for devices used on the Malta board. */
 	for (i = 0; i < ARRAY_SIZE(standard_io_resources); i++)
 		request_resource(&ioport_resource, standard_io_resources+i);
@@ -224,8 +226,4 @@
 	board_time_init = mips_time_init;
 	board_timer_setup = mips_timer_setup;
 	rtc_get_time = mips_rtc_get_time;
-
-	return 0;
 }
-
-early_initcall(malta_setup);
diff -Naur linux-2.6.14/arch/mips/mips-boards/sead/sead_int.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sead/sead_int.c
--- linux-2.6.14/arch/mips/mips-boards/sead/sead_int.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sead/sead_int.c	2005-11-17 11:42:25.000000000 -0800
@@ -2,6 +2,7 @@
  * Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
  * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -21,7 +22,9 @@
  */
 #include <linux/init.h>
 #include <linux/irq.h>
-#include <linux/interrupt.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/system.h>
 
 #include <asm/mips-boards/seadint.h>
 
@@ -39,13 +42,8 @@
 
 void __init arch_init_irq(void)
 {
-        /*
-         * Mask out all interrupt
-	 */
-	clear_c0_status(0x0000ff00);
+	mips_cpu_irq_init(0);
 
 	/* Now safe to set the exception vector. */
 	set_except_vector(0, mipsIRQ);
-
-	mips_cpu_irq_init(0);
 }
diff -Naur linux-2.6.14/arch/mips/mips-boards/sead/sead_setup.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sead/sead_setup.c
--- linux-2.6.14/arch/mips/mips-boards/sead/sead_setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sead/sead_setup.c	2005-11-17 11:42:25.000000000 -0800
@@ -57,8 +57,6 @@
 	mips_reboot_setup();
 }
 
-early_initcall(sead_setup);
-
 static void __init serial_init(void)
 {
 #ifdef CONFIG_SERIAL_8250
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/cmdline.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/cmdline.c
--- linux-2.6.14/arch/mips/mips-boards/sim/cmdline.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/cmdline.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,59 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Kernel command line creation using the prom monitor (YAMON) argc/argv.
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+
+extern int prom_argc;
+extern int *_prom_argv;
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension.
+ */
+#define prom_argv(index) ((char *)(((int *)(int)_prom_argv)[(index)]))
+
+char arcs_cmdline[CL_SIZE];
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+
+void  __init prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv(actr));
+		cp += strlen(prom_argv(actr));
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	*cp = '\0';
+}
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/Makefile linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/Makefile
--- linux-2.6.14/arch/mips/mips-boards/sim/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/Makefile	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,20 @@
+#
+# Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+#
+# This program is free software; you can distribute it and/or modify it
+# under the terms of the GNU General Public License (Version 2) as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+#
+
+obj-y := sim_setup.o sim_mem.o sim_time.o sim_printf.o sim_int.o sim_irq.o \
+	sim_cmdline.o
+obj-$(CONFIG_SMP) += sim_smp.o
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_cmdline.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_cmdline.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_cmdline.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_cmdline.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <asm/bootinfo.h>
+
+extern char arcs_cmdline[];
+
+char * __init prom_getcmdline(void)
+{
+	return arcs_cmdline;
+}
+
+
+void  __init prom_init_cmdline(void)
+{
+    /* nothing to do */
+}
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_int.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_int.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_int.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_int.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 1999, 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <asm/mips-boards/simint.h>
+
+
+extern void mips_cpu_irq_init(int);
+
+extern asmlinkage void simIRQ(void);
+
+asmlinkage void sim_hw0_irqdispatch(struct pt_regs *regs)
+{
+	do_IRQ(2, regs);
+}
+
+void __init arch_init_irq(void)
+{
+	/* Now safe to set the exception vector. */
+	set_except_vector(0, simIRQ);
+
+	mips_cpu_irq_init(MIPSCPU_INT_BASE);
+}
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_IRQ.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_IRQ.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_IRQ.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_IRQ.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,148 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Interrupt exception dispatch code.
+ */
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/* A lot of complication here is taken away because:
+ *
+ * 1) We handle one interrupt and return, sitting in a loop and moving across
+ *    all the pending IRQ bits in the cause register is _NOT_ the answer, the
+ *    common case is one pending IRQ so optimize in that direction.
+ *
+ * 2) We need not check against bits in the status register IRQ mask, that
+ *    would make this routine slow as hell.
+ *
+ * 3) Linux only thinks in terms of all IRQs on or all IRQs off, nothing in
+ *    between like BSD spl() brain-damage.
+ *
+ * Furthermore, the IRQs on the MIPS board look basically (barring software
+ * IRQs which we don't use at all and all external interrupt sources are
+ * combined together on hardware interrupt 0 (MIPS IRQ 2)) like:
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware (ignored)
+ *             4        Hardware (ignored)
+ *             5        Hardware (ignored)
+ *             6        Hardware (ignored)
+ *             7        R4k timer (what we use)
+ *
+ * Note: On the SEAD board thing are a little bit different.
+ *       Here IRQ 2 (hw0) is wired to the UART0 and IRQ 3 (hw1) is wired
+ *       wired to UART1.
+ *
+ * We handle the IRQ according to _our_ priority which is:
+ *
+ * Highest ----     R4k Timer
+ * Lowest  ----     Combined hardware interrupt
+ *
+ * then we just return, if multiple IRQs are pending then we will just take
+ * another exception, big deal.
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(mipsIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE		# get irq bits
+	mfc0	s1, CP0_STATUS		# get irq mask
+	and	s0, s1
+
+	/* First we check for r4k counter/timer IRQ. */
+	andi	a0, s0, CAUSEF_IP7
+	beq	a0, zero, 1f
+	 andi	a0, s0, CAUSEF_IP2	# delay slot, check hw0 interrupt
+
+	/* Wheee, a timer interrupt. */
+	move	a0, sp
+	jal	mips_timer_interrupt
+	 nop
+
+	j	ret_from_irq
+	 nop
+
+1:
+#if defined(CONFIG_MIPS_SEAD)
+	beq	a0, zero, 1f
+	 andi	a0, s0, CAUSEF_IP3	# delay slot, check hw1 interrupt
+#else
+	beq	a0, zero, 1f		# delay slot, check hw3 interrupt
+ 	 andi	a0, s0, CAUSEF_IP5
+#endif
+
+	/* Wheee, combined hardware level zero interrupt. */
+#if defined(CONFIG_MIPS_ATLAS)
+	jal	atlas_hw0_irqdispatch
+#elif defined(CONFIG_MIPS_MALTA)
+	jal	malta_hw0_irqdispatch
+#elif defined(CONFIG_MIPS_SEAD)
+	jal	sead_hw0_irqdispatch
+#else
+#error "MIPS board not supported\n"
+#endif
+	 move	a0, sp			# delay slot
+
+	j	ret_from_irq
+	 nop				# delay slot
+
+1:
+#if defined(CONFIG_MIPS_SEAD)
+	beq	a0, zero, 1f
+	 andi	a0, s0, CAUSEF_IP5	# delay slot, check hw3 interrupt
+	jal	sead_hw1_irqdispatch
+	 move	a0, sp			# delay slot
+	j	ret_from_irq
+	 nop				# delay slot
+1:
+#endif
+#if defined(CONFIG_MIPS_MALTA)
+	beq	a0, zero, 1f            # check hw3 (coreHI) interrupt
+	 nop
+	jal	corehi_irqdispatch
+	 move	a0, sp
+	j	ret_from_irq
+	 nop
+1:
+#endif
+	/*
+	 * Here by mistake?  This is possible, what can happen is that by the
+	 * time we take the exception the IRQ pin goes low, so just leave if
+	 * this is the case.
+	 */
+	move	a1,s0
+	PRINT("Got interrupt: c0_cause = %08x\n")
+	mfc0	a1, CP0_EPC
+	PRINT("c0_epc = %08x\n")
+
+	j	ret_from_irq
+	 nop
+	END(mipsIRQ)
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_irq.S linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_irq.S
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_irq.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_irq.S	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 1999, 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Interrupt exception dispatch code.
+ *
+ */
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+#include <asm/mips-boards/simint.h>
+
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(simIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE		# get irq bits
+	mfc0	s1, CP0_STATUS		# get irq mask
+	andi	s0, ST0_IM		# CAUSE.CE may be non-zero!
+	and	s0, s1
+
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
+ 	.set	mips32
+	clz	a0, s0
+	.set	mips0
+	negu	a0
+	addu	a0, 31-CAUSEB_IP
+	bltz	a0, spurious
+#else
+	beqz	s0, spurious
+	 li	a0, 7
+
+	and	t0, s0, 0xf000
+	sltiu	t0, t0, 1
+	sll	t0, 2
+	subu	a0, t0
+	sll	s0, t0
+
+	and	t0, s0, 0xc000
+	sltiu	t0, t0, 1
+	sll	t0, 1
+	subu	a0, t0
+	sll	s0, t0
+
+	and	t0, s0, 0x8000
+	sltiu	t0, t0, 1
+	# sll	t0, 0
+	subu	a0, t0
+	# sll	s0, t0
+#endif
+
+#ifdef CASCADE_IRQ
+	 li	a1, CASCADE_IRQ
+	bne	a0, a1, 1f
+	 addu	a0, MIPSCPU_INT_BASE
+
+	jal	CASCADE_DISPATCH
+	 move	 a0, sp
+
+	j	ret_from_irq
+	 nop
+1:
+#else
+	 addu	a0, MIPSCPU_INT_BASE
+#endif
+
+	jal	do_IRQ
+	 move	a1, sp
+
+	j	ret_from_irq
+	 nop
+
+
+spurious:
+	j	spurious_interrupt
+	 nop
+	END(simIRQ)
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_mem.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_mem.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_mem.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_mem.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+
+#include <asm/mips-boards/prom.h>
+
+/*#define DEBUG*/
+
+enum simmem_memtypes {
+	simmem_reserved = 0,
+	simmem_free,
+};
+struct prom_pmemblock mdesc[PROM_MAX_PMEMBLOCKS];
+
+#ifdef DEBUG
+static char *mtypes[3] = {
+	"SIM reserved memory",
+	"SIM free memory",
+};
+#endif
+
+/* References to section boundaries */
+extern char _end;
+
+#define PFN_ALIGN(x)    (((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+
+
+struct prom_pmemblock * __init prom_getmdesc(void)
+{
+	unsigned int memsize;
+
+	memsize = 0x02000000;
+	prom_printf("Setting default memory size 0x%08x\n", memsize);
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[0].type = simmem_reserved;
+	mdesc[0].base = 0x00000000;
+	mdesc[0].size = 0x00001000;
+
+	mdesc[1].type = simmem_free;
+	mdesc[1].base = 0x00001000;
+	mdesc[1].size = 0x000ff000;
+
+	mdesc[2].type = simmem_reserved;
+	mdesc[2].base = 0x00100000;
+	mdesc[2].size = CPHYSADDR(PFN_ALIGN(&_end)) - mdesc[2].base;
+
+	mdesc[3].type = simmem_free;
+	mdesc[3].base = CPHYSADDR(PFN_ALIGN(&_end));
+	mdesc[3].size = memsize - mdesc[3].base;
+
+	return &mdesc[0];
+}
+
+static int __init prom_memtype_classify (unsigned int type)
+{
+	switch (type) {
+	case simmem_free:
+		return BOOT_MEM_RAM;
+	case simmem_reserved:
+	default:
+		return BOOT_MEM_RESERVED;
+	}
+}
+
+void __init prom_meminit(void)
+{
+	struct prom_pmemblock *p;
+
+	p = prom_getmdesc();
+
+	while (p->size) {
+		long type;
+		unsigned long base, size;
+
+		type = prom_memtype_classify (p->type);
+		base = p->base;
+		size = p->size;
+
+		add_memory_region(base, size, type);
+                p++;
+	}
+}
+
+unsigned long __init prom_free_prom_memory(void)
+{
+	int i;
+	unsigned long freed = 0;
+	unsigned long addr;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+			continue;
+
+		addr = boot_mem_map.map[i].addr;
+		while (addr < boot_mem_map.map[i].addr
+			      + boot_mem_map.map[i].size) {
+			ClearPageReserved(virt_to_page(__va(addr)));
+			set_page_count(virt_to_page(__va(addr)), 1);
+			free_page((unsigned long)__va(addr));
+			addr += PAGE_SIZE;
+			freed += PAGE_SIZE;
+		}
+	}
+	printk("Freeing prom memory: %ldkb freed\n", freed >> 10);
+
+	return freed;
+}
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_printf.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_printf.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_printf.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_printf.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,74 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Putting things on the screen/serial line using YAMONs facilities.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/serial_reg.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+static inline unsigned int serial_in(int offset)
+{
+	return inb(0x3f8 + offset);
+}
+
+static inline void serial_out(int offset, int value)
+{
+	outb(value, 0x3f8 + offset);
+}
+
+int putPromChar(char c)
+{
+	while ((serial_in(UART_LSR) & UART_LSR_THRE) == 0)
+		;
+
+	serial_out(UART_TX, c);
+
+	return 1;
+}
+
+char getPromChar(void)
+{
+	while (!(serial_in(UART_LSR) & 1))
+		;
+
+	return serial_in(UART_RX);
+}
+
+void prom_printf(char *fmt, ...)
+{
+	va_list args;
+	int l;
+	char *p, *buf_end;
+	char buf[1024];
+
+	va_start(args, fmt);
+	l = vsprintf(buf, fmt, args); /* hopefully i < sizeof(buf) */
+	va_end(args);
+
+	buf_end = buf + l;
+
+	for (p = buf; p < buf_end; p++) {
+		/* Crude cr/nl handling is better than none */
+		if (*p == '\n')
+			putPromChar('\r');
+		putPromChar(*p);
+	}
+}
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_setup.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_setup.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_setup.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mips-boards/generic.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/mips-boards/sim.h>
+#include <asm/mips-boards/simint.h>
+
+
+extern void sim_time_init(void);
+extern void sim_timer_setup(struct irqaction *irq);
+static void __init serial_init(void);
+unsigned int _isbonito = 0;
+
+extern void __init sanitize_tlb_entries(void);
+
+
+const char *get_system_type(void)
+{
+	return "MIPSsim";
+}
+
+void __init plat_setup(void)
+{
+	set_io_port_base(0xbfd00000);
+
+	serial_init();
+
+	board_time_init = sim_time_init;
+	board_timer_setup = sim_timer_setup;
+	prom_printf("Linux started...\n");
+
+#ifdef CONFIG_MT_SMP
+	sanitize_tlb_entries();
+#endif
+}
+
+void prom_init(void)
+{
+	set_io_port_base(0xbfd00000);
+
+	prom_printf("\nLINUX started...\n");
+	prom_init_cmdline();
+	prom_meminit();
+}
+
+
+static void __init serial_init(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	struct uart_port s;
+
+	memset(&s, 0, sizeof(s));
+
+	s.iobase = 0x3f8;
+
+	/* hardware int 4 - the serial int, is CPU int 6
+	 but poll for now */
+	s.irq =  0;
+	s.uartclk = BASE_BAUD * 16;
+	s.flags = ASYNC_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = SERIAL_IO_PORT | ASYNC_SKIP_TEST;
+	s.regshift = 0;
+	s.timeout = 4;
+
+	if (early_serial_setup(&s) != 0) {
+		prom_printf(KERN_ERR "Serial setup failed!\n");
+	}
+
+#endif
+}
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_smp.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_smp.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_smp.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_smp.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+/*
+ * Simulator Platform-specific hooks for SMP operation
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cpumask.h>
+#include <linux/interrupt.h>
+#include <asm/atomic.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/hardirq.h>
+#include <asm/mmu_context.h>
+#include <asm/smp.h>
+#ifdef CONFIG_MIPS_MT_SMTC
+#include <asm/smtc_ipi.h>
+#endif /* CONFIG_MIPS_MT_SMTC */
+
+/* VPE/SMP Prototype implements platform interfaces directly */
+#if !defined(CONFIG_MIPS_MT_SMP)
+
+/*
+ * Cause the specified action to be performed on a targeted "CPU"
+ */
+
+void core_send_ipi(int cpu, unsigned int action)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	void smtc_send_ipi(int, int, unsigned int);
+
+	smtc_send_ipi(cpu, LINUX_SMP_IPI, action);
+#endif /* CONFIG_MIPS_MT_SMTC */
+/* "CPU" may be TC of same VPE, VPE of same CPU, or different CPU */
+
+}
+
+/*
+ * Detect available CPUs/VPEs/TCs and populate phys_cpu_present_map
+ */
+
+void __init prom_build_cpu_map(void)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	extern int mipsmt_build_cpu_map(int startslot);
+	int nextslot;
+
+	cpus_clear(phys_cpu_present_map);
+
+	/* Register the boot CPU */
+
+	smp_prepare_boot_cpu();
+
+	/*
+	 * As of November, 2004, MIPSsim only simulates one core
+	 * at a time.  However, that core may be a MIPS MT core
+	 * with multiple virtual processors and thread contexts.
+	 */
+
+	if (read_c0_config3() & (1<<2)) {
+		nextslot = mipsmt_build_cpu_map(1);
+	}
+#endif /* CONFIG_MIPS_MT_SMTC */
+}
+
+/*
+ * Platform "CPU" startup hook
+ */
+
+void prom_boot_secondary(int cpu, struct task_struct *idle)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	extern void smtc_boot_secondary(int cpu, struct task_struct *t);
+
+	smtc_boot_secondary(cpu, idle);
+#endif /* CONFIG_MIPS_MT_SMTC */
+}
+
+/*
+ * Post-config but pre-boot cleanup entry point
+ */
+
+void prom_init_secondary(void)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	void smtc_init_secondary(void);
+
+	smtc_init_secondary();
+#endif /* CONFIG_MIPS_MT_SMTC */
+}
+
+/*
+ * Platform SMP pre-initialization
+ */
+
+void prom_prepare_cpus(unsigned int max_cpus)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	void mipsmt_prepare_cpus(int c);
+	/*
+ 	 * As noted above, we can assume a single CPU for now
+	 * but it may be multithreaded.
+	 */
+
+	if (read_c0_config3() & (1<<2)) {
+		mipsmt_prepare_cpus(max_cpus);
+	}
+#endif /* CONFIG_MIPS_MT_SMTC */
+}
+
+/*
+ * SMP initialization finalization entry point
+ */
+
+void prom_smp_finish(void)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	void smtc_smp_finish(void);
+
+	smtc_smp_finish();
+#endif /* CONFIG_MIPS_MT_SMTC */
+}
+
+/*
+ * Hook for after all CPUs are online
+ */
+
+void prom_cpus_done(void)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+
+#endif /* CONFIG_MIPS_MT_SMTC */
+}
+#endif /* CONFIG_MIPS32R2_MT_SMP */
diff -Naur linux-2.6.14/arch/mips/mips-boards/sim/sim_time.c linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_time.c
--- linux-2.6.14/arch/mips/mips-boards/sim/sim_time.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/mips-boards/sim/sim_time.c	2005-11-17 11:42:25.000000000 -0800
@@ -0,0 +1,215 @@
+#include <linux/types.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/hardirq.h>
+#include <asm/div64.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+
+#include <linux/interrupt.h>
+#include <linux/mc146818rtc.h>
+#include <linux/timex.h>
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/hardirq.h>
+#include <asm/irq.h>
+#include <asm/div64.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+#include <asm/mc146818-time.h>
+#include <asm/msc01_ic.h>
+
+#include <asm/mips-boards/generic.h>
+#include <asm/mips-boards/prom.h>
+#include <asm/mips-boards/simint.h>
+#include <asm/mc146818-time.h>
+#include <asm/smp.h>
+
+
+unsigned long cpu_khz;
+
+extern asmlinkage void ll_local_timer_interrupt(int irq, struct pt_regs *regs);
+
+irqreturn_t sim_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+#ifdef CONFIG_SMP
+	int cpu = smp_processor_id();
+
+	/*
+	 * CPU 0 handles the global timer interrupt job
+	 * resets count/compare registers to trigger next timer int.
+	 */
+#ifndef CONFIG_MIPS_MT_SMTC
+	if (cpu == 0) {
+		timer_interrupt(irq, dev_id, regs);
+	}
+	else {
+		/* Everyone else needs to reset the timer int here as
+		   ll_local_timer_interrupt doesn't */
+		/*
+		 * FIXME: need to cope with counter underflow.
+		 * More support needs to be added to kernel/time for
+		 * counter/timer interrupts on multiple CPU's
+		 */
+		write_c0_compare (read_c0_count() + ( mips_hpt_frequency/HZ));
+	}
+#else /* SMTC */
+	/*
+	 *  In SMTC system, one Count/Compare set exists per VPE.
+	 *  Which TC within a VPE gets the interrupt is essentially
+	 *  random - we only know that it shouldn't be one with
+	 *  IXMT set. Whichever TC gets the interrupt needs to
+	 *  send special interprocessor interrupts to the other
+	 *  TCs to make sure that they schedule, etc.
+	 *
+	 *  That code is specific to the SMTC kernel, not to
+	 *  the simulation platform, so it's invoked from
+	 *  the general MIPS timer_interrupt routine.
+	 *
+	 * We have a problem in that the interrupt vector code
+	 * had to turn off the timer IM bit to avoid redundant
+	 * entries, but we may never get to mips_cpu_irq_end
+	 * to turn it back on again if the scheduler gets
+	 * involved.  So we clear the pending timer here,
+	 * and re-enable the mask...
+	 */
+
+	int vpflags = dvpe();
+	write_c0_compare (read_c0_count() - 1);
+	clear_c0_cause(0x100 << MIPSCPU_INT_CPUCTR);
+	set_c0_status(0x100 << MIPSCPU_INT_CPUCTR);
+	irq_enable_hazard();
+	evpe(vpflags);
+
+	if(cpu_data[cpu].vpe_id == 0) timer_interrupt(irq, dev_id, regs);
+	else write_c0_compare (read_c0_count() + ( mips_hpt_frequency/HZ));
+	smtc_timer_broadcast(cpu_data[cpu].vpe_id);
+
+#endif /* CONFIG_MIPS_MT_SMTC */
+
+	/*
+	 * every CPU should do profiling and process accounting
+	 */
+ 	local_timer_interrupt (irq, dev_id, regs);
+	return IRQ_HANDLED;
+#else
+	return timer_interrupt (irq, dev_id, regs);
+#endif
+}
+
+
+
+/*
+ * Estimate CPU frequency.  Sets mips_counter_frequency as a side-effect
+ */
+static unsigned int __init estimate_cpu_frequency(void)
+{
+	unsigned int prid = read_c0_prid() & 0xffff00;
+	unsigned int count;
+
+#if 1
+	/*
+	 * hardwire the board frequency to 12MHz.
+	 */
+
+	if ((prid == (PRID_COMP_MIPS | PRID_IMP_20KC)) ||
+	    (prid == (PRID_COMP_MIPS | PRID_IMP_25KF)))
+		count = 12000000;
+	else
+		count =  6000000;
+#else
+	unsigned int flags;
+
+	local_irq_save(flags);
+
+	/* Start counter exactly on falling edge of update flag */
+	while (CMOS_READ(RTC_REG_A) & RTC_UIP);
+	while (!(CMOS_READ(RTC_REG_A) & RTC_UIP));
+
+	/* Start r4k counter. */
+	write_c0_count(0);
+
+	/* Read counter exactly on falling edge of update flag */
+	while (CMOS_READ(RTC_REG_A) & RTC_UIP);
+	while (!(CMOS_READ(RTC_REG_A) & RTC_UIP));
+
+	count = read_c0_count();
+
+	/* restore interrupts */
+	local_irq_restore(flags);
+#endif
+
+	mips_hpt_frequency = count;
+
+	if ((prid != (PRID_COMP_MIPS | PRID_IMP_20KC)) &&
+	    (prid != (PRID_COMP_MIPS | PRID_IMP_25KF)))
+		count *= 2;
+
+	count += 5000;    /* round */
+	count -= count%10000;
+
+	return count;
+}
+
+void __init sim_time_init(void)
+{
+	unsigned int est_freq, flags;
+
+	local_irq_save(flags);
+
+
+        /* Set Data mode - binary. */
+	CMOS_WRITE(CMOS_READ(RTC_CONTROL) | RTC_DM_BINARY, RTC_CONTROL);
+
+
+	est_freq = estimate_cpu_frequency ();
+
+	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000,
+	       (est_freq%1000000)*100/1000000);
+
+        cpu_khz = est_freq / 1000;
+
+	local_irq_restore(flags);
+}
+
+static int mips_cpu_timer_irq;
+
+static void mips_timer_dispatch (struct pt_regs *regs)
+{
+	do_IRQ (mips_cpu_timer_irq, regs);
+}
+
+
+void __init sim_timer_setup(struct irqaction *irq)
+{
+	if (cpu_has_veic) {
+		set_vi_handler(MSC01E_INT_CPUCTR, mips_timer_dispatch);
+		mips_cpu_timer_irq = MSC01E_INT_BASE + MSC01E_INT_CPUCTR;
+	}
+	else {
+		if (cpu_has_vint)
+			set_vi_handler(MIPSCPU_INT_CPUCTR, mips_timer_dispatch);
+		mips_cpu_timer_irq = MIPSCPU_INT_BASE + MIPSCPU_INT_CPUCTR;
+	}
+
+	/* we are using the cpu counter for timer interrupts */
+	irq->handler = sim_timer_interrupt;
+	setup_irq(mips_cpu_timer_irq, irq);
+
+#ifdef CONFIG_SMP
+	/* irq_desc(riptor) is a global resource, when the interrupt overlaps
+	   on seperate cpu's the first one tries to handle the second interrupt.
+	   The effect is that the int remains disabled on the second cpu.
+	   Mark the interrupt with IRQ_PER_CPU to avoid any confusion */
+	irq_desc[mips_cpu_timer_irq].status |= IRQ_PER_CPU;
+#endif
+
+	/* to generate the first timer interrupt */
+	write_c0_compare(read_c0_count() + (mips_hpt_frequency/HZ));
+}
diff -Naur linux-2.6.14/arch/mips/mm/cache.c linux-mips-2.6.14.orig/arch/mips/mm/cache.c
--- linux-2.6.14/arch/mips/mm/cache.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/cache.c	2005-11-17 11:42:25.000000000 -0800
@@ -23,8 +23,10 @@
 void (*flush_cache_mm)(struct mm_struct *mm);
 void (*flush_cache_range)(struct vm_area_struct *vma, unsigned long start,
 	unsigned long end);
-void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
-void (*flush_icache_range)(unsigned long start, unsigned long end);
+void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page,
+	unsigned long pfn);
+void (*flush_icache_range)(unsigned long __user start,
+	unsigned long __user end);
 void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
 
 /* MIPS specific cache operations */
@@ -32,6 +34,8 @@
 void (*flush_data_cache_page)(unsigned long addr);
 void (*flush_icache_all)(void);
 
+EXPORT_SYMBOL(flush_data_cache_page);
+
 #ifdef CONFIG_DMA_NONCOHERENT
 
 /* DMA cache operations. */
@@ -49,10 +53,12 @@
  * We could optimize the case where the cache argument is not BCACHE but
  * that seems very atypical use ...
  */
-asmlinkage int sys_cacheflush(unsigned long addr, unsigned long int bytes,
-	unsigned int cache)
+asmlinkage int sys_cacheflush(unsigned long __user addr,
+	unsigned long bytes, unsigned int cache)
 {
-	if (!access_ok(VERIFY_WRITE, (void *) addr, bytes))
+	if (bytes == 0)
+		return 0;
+	if (!access_ok(VERIFY_WRITE, (void __user *) addr, bytes))
 		return -EFAULT;
 
 	flush_icache_range(addr, addr + bytes);
@@ -100,58 +106,48 @@
 	}
 }
 
-extern void ld_mmu_r23000(void);
-extern void ld_mmu_r4xx0(void);
-extern void ld_mmu_tx39(void);
-extern void ld_mmu_r6000(void);
-extern void ld_mmu_tfp(void);
-extern void ld_mmu_andes(void);
-extern void ld_mmu_sb1(void);
+#define __weak __attribute__((weak))
+
+static char cache_panic[] __initdata = "Yeee, unsupported cache architecture.";
 
 void __init cpu_cache_init(void)
 {
-	if (cpu_has_4ktlb) {
-#if defined(CONFIG_CPU_R4X00)  || defined(CONFIG_CPU_VR41XX) || \
-    defined(CONFIG_CPU_R4300)  || defined(CONFIG_CPU_R5000)  || \
-    defined(CONFIG_CPU_NEVADA) || defined(CONFIG_CPU_R5432)  || \
-    defined(CONFIG_CPU_R5500)  || defined(CONFIG_CPU_MIPS32) || \
-    defined(CONFIG_CPU_MIPS64) || defined(CONFIG_CPU_TX49XX) || \
-    defined(CONFIG_CPU_RM7000) || defined(CONFIG_CPU_RM9000)
-		ld_mmu_r4xx0();
-#endif
-	} else switch (current_cpu_data.cputype) {
-#ifdef CONFIG_CPU_R3000
-	case CPU_R2000:
-	case CPU_R3000:
-	case CPU_R3000A:
-	case CPU_R3081E:
-		ld_mmu_r23000();
-		break;
-#endif
-#ifdef CONFIG_CPU_TX39XX
-	case CPU_TX3912:
-	case CPU_TX3922:
-	case CPU_TX3927:
-		ld_mmu_tx39();
-		break;
-#endif
-#ifdef CONFIG_CPU_R10000
-	case CPU_R10000:
-	case CPU_R12000:
-		ld_mmu_r4xx0();
-		break;
-#endif
-#ifdef CONFIG_CPU_SB1
-	case CPU_SB1:
-		ld_mmu_sb1();
-		break;
-#endif
-
-	case CPU_R8000:
-		panic("R8000 is unsupported");
-		break;
+	if (cpu_has_3k_cache) {
+		extern void __weak r3k_cache_init(void);
+
+		r3k_cache_init();
+		return;
+	}
+	if (cpu_has_6k_cache) {
+		extern void __weak r6k_cache_init(void);
 
-	default:
-		panic("Yeee, unsupported cache architecture.");
+		r6k_cache_init();
+		return;
 	}
+	if (cpu_has_4k_cache) {
+		extern void __weak r4k_cache_init(void);
+
+		r4k_cache_init();
+		return;
+	}
+	if (cpu_has_8k_cache) {
+		extern void __weak r8k_cache_init(void);
+
+		r8k_cache_init();
+		return;
+	}
+	if (cpu_has_tx39_cache) {
+		extern void __weak tx39_cache_init(void);
+
+		tx39_cache_init();
+		return;
+	}
+	if (cpu_has_sb1_cache) {
+		extern void __weak sb1_cache_init(void);
+
+		sb1_cache_init();
+		return;
+	}
+
+	panic(cache_panic);
 }
diff -Naur linux-2.6.14/arch/mips/mm/cerr-sb1.c linux-mips-2.6.14.orig/arch/mips/mm/cerr-sb1.c
--- linux-2.6.14/arch/mips/mm/cerr-sb1.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/cerr-sb1.c	2005-11-17 11:42:25.000000000 -0800
@@ -19,13 +19,19 @@
 #include <linux/sched.h>
 #include <asm/mipsregs.h>
 #include <asm/sibyte/sb1250.h>
+#include <asm/sibyte/sb1250_regs.h>
 
-#ifndef CONFIG_SIBYTE_BUS_WATCHER
+#if !defined(CONFIG_SIBYTE_BUS_WATCHER) || defined(CONFIG_SIBYTE_BW_TRACE)
 #include <asm/io.h>
-#include <asm/sibyte/sb1250_regs.h>
 #include <asm/sibyte/sb1250_scd.h>
 #endif
 
+/*
+ * We'd like to dump the L2_ECC_TAG register on errors, but errata make
+ * that unsafe... So for now we don't.  (BCM1250/BCM112x erratum SOC-48.)
+ */
+#undef DUMP_L2_ECC_TAG_ON_ERROR
+
 /* SB1 definitions */
 
 /* XXX should come from config1 XXX */
@@ -139,12 +145,18 @@
 static void check_bus_watcher(void)
 {
 	uint32_t status, l2_err, memio_err;
+#ifdef DUMP_L2_ECC_TAG_ON_ERROR
+	uint64_t l2_tag;
+#endif
 
 	/* Destructive read, clears register and interrupt */
 	status = csr_in32(IOADDR(A_SCD_BUS_ERR_STATUS));
 	/* Bit 31 is always on, but there's no #define for that */
 	if (status & ~(1UL << 31)) {
 		l2_err = csr_in32(IOADDR(A_BUS_L2_ERRORS));
+#ifdef DUMP_L2_ECC_TAG_ON_ERROR
+		l2_tag = in64(IO_SPACE_BASE | A_L2_ECC_TAG);
+#endif
 		memio_err = csr_in32(IOADDR(A_BUS_MEM_IO_ERRORS));
 		prom_printf("Bus watcher error counters: %08x %08x\n", l2_err, memio_err);
 		prom_printf("\nLast recorded signature:\n");
@@ -153,6 +165,9 @@
 		       (int)(G_SCD_BERR_TID(status) >> 6),
 		       (int)G_SCD_BERR_RID(status),
 		       (int)G_SCD_BERR_DCODE(status));
+#ifdef DUMP_L2_ECC_TAG_ON_ERROR
+		prom_printf("Last L2 tag w/ bad ECC: %016llx\n", l2_tag);
+#endif
 	} else {
 		prom_printf("Bus watcher indicates no error\n");
 	}
@@ -166,6 +181,16 @@
 	uint64_t cerr_dpa;
 	uint32_t errctl, cerr_i, cerr_d, dpalo, dpahi, eepc, res;
 
+#ifdef CONFIG_SIBYTE_BW_TRACE
+	/* Freeze the trace buffer now */
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+	csr_out32(M_BCM1480_SCD_TRACE_CFG_FREEZE, IO_SPACE_BASE | A_SCD_TRACE_CFG);
+#else
+	csr_out32(M_SCD_TRACE_CFG_FREEZE, IO_SPACE_BASE | A_SCD_TRACE_CFG);
+#endif
+	prom_printf("Trace buffer frozen\n");
+#endif
+
 	prom_printf("Cache error exception on CPU %x:\n",
 		    (read_c0_prid() >> 25) & 0x7);
 
@@ -229,11 +254,19 @@
 
 	check_bus_watcher();
 
-	while (1);
 	/*
-	 * This tends to make things get really ugly; let's just stall instead.
-	 *    panic("Can't handle the cache error!");
+	 * Calling panic() when a fatal cache error occurs scrambles the
+	 * state of the system (and the cache), making it difficult to
+	 * investigate after the fact.  However, if you just stall the CPU,
+	 * the other CPU may keep on running, which is typically very
+	 * undesirable.
 	 */
+#ifdef CONFIG_SB1_CERR_STALL
+	while (1)
+		;
+#else
+	panic("unhandled cache error");
+#endif
 }
 
 
@@ -434,7 +467,8 @@
 };
 
 #define DC_TAG_VALID(state) \
-    (((state) == 0xf) || ((state) == 0x13) || ((state) == 0x19) || ((state == 0x16)) || ((state) == 0x1c))
+    (((state) == 0x0) || ((state) == 0xf) || ((state) == 0x13) || \
+     ((state) == 0x19) || ((state) == 0x16) || ((state) == 0x1c))
 
 static char *dc_state_str(unsigned char state)
 {
@@ -505,6 +539,7 @@
 			uint64_t datalo;
 			uint32_t datalohi, datalolo, datahi;
 			int offset;
+			char bad_ecc = 0;
 
 			for (offset = 0; offset < 4; offset++) {
 				/* Index-load-data-D */
@@ -525,8 +560,7 @@
 				ecc = dc_ecc(datalo);
 				if (ecc != datahi) {
 					int bits = 0;
-					prom_printf("  ** bad ECC (%02x %02x) ->",
-						    datahi, ecc);
+					bad_ecc |= 1 << (3-offset);
 					ecc ^= datahi;
 					while (ecc) {
 						if (ecc & 1) bits++;
@@ -537,6 +571,10 @@
 				prom_printf("  %02X-%016llX", datahi, datalo);
 			}
 			prom_printf("\n");
+			if (bad_ecc)
+				prom_printf("  dwords w/ bad ECC: %d %d %d %d\n",
+					    !!(bad_ecc & 8), !!(bad_ecc & 4),
+					    !!(bad_ecc & 2), !!(bad_ecc & 1));
 		}
 	}
 	return res;
diff -Naur linux-2.6.14/arch/mips/mm/cex-sb1.S linux-mips-2.6.14.orig/arch/mips/mm/cex-sb1.S
--- linux-2.6.14/arch/mips/mm/cex-sb1.S	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/cex-sb1.S	2005-11-17 11:42:26.000000000 -0800
@@ -64,6 +64,10 @@
 	sd	k0,0x170($0)
 	sd	k1,0x178($0)
 
+#if CONFIG_SB1_CEX_ALWAYS_FATAL
+	j	handle_vec2_sb1
+	 nop
+#else
 	/*
 	 * M_ERRCTL_RECOVERABLE is bit 31, which makes it easy to tell
 	 * if we can fast-path out of here for a h/w-recovered error.
@@ -134,6 +138,7 @@
 	/* Unrecoverable Icache or Dcache error; log it and/or fail */
 	j	handle_vec2_sb1
 	 nop
+#endif
 
 END(except_vec2_sb1)
 
diff -Naur linux-2.6.14/arch/mips/mm/c-r3k.c linux-mips-2.6.14.orig/arch/mips/mm/c-r3k.c
--- linux-2.6.14/arch/mips/mm/c-r3k.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/c-r3k.c	2005-11-17 11:42:25.000000000 -0800
@@ -221,12 +221,14 @@
 					   struct mm_struct *mm)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 	unsigned long physpage;
 
 	pgd = pgd_offset(mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 
 	if ((physpage = pte_val(*pte)) & _PAGE_VALID)
@@ -317,7 +319,7 @@
 	r3k_flush_dcache_range(start, start + size);
 }
 
-void __init ld_mmu_r23000(void)
+void __init r3k_cache_init(void)
 {
 	extern void build_clear_page(void);
 	extern void build_copy_page(void);
diff -Naur linux-2.6.14/arch/mips/mm/c-r4k.c linux-mips-2.6.14.orig/arch/mips/mm/c-r4k.c
--- linux-2.6.14/arch/mips/mm/c-r4k.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/c-r4k.c	2005-11-17 11:42:25.000000000 -0800
@@ -16,6 +16,7 @@
 
 #include <asm/bcache.h>
 #include <asm/bootinfo.h>
+#include <asm/cache.h>
 #include <asm/cacheops.h>
 #include <asm/cpu.h>
 #include <asm/cpu-features.h>
@@ -26,8 +27,14 @@
 #include <asm/system.h>
 #include <asm/mmu_context.h>
 #include <asm/war.h>
+#include <asm/cacheflush.h> /* for run_uncached() */
 
-static unsigned long icache_size, dcache_size, scache_size;
+/*
+ * Must die.
+ */
+static unsigned long icache_size __read_mostly;
+static unsigned long dcache_size __read_mostly;
+static unsigned long scache_size __read_mostly;
 
 /*
  * Dummy cache handling routines for machines without boardcaches
@@ -43,8 +50,8 @@
 
 struct bcache_ops *bcops = &no_sc_ops;
 
-#define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x2010)
-#define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x2020)
+#define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x00002010)
+#define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x00002020)
 
 #define R4600_HIT_CACHEOP_WAR_IMPL					\
 do {									\
@@ -190,12 +197,12 @@
 	if (ic_lsize == 16)
 		r4k_blast_icache_page_indexed = blast_icache16_page_indexed;
 	else if (ic_lsize == 32) {
-		if (TX49XX_ICACHE_INDEX_INV_WAR)
-			r4k_blast_icache_page_indexed =
-				tx49_blast_icache32_page_indexed;
-		else if (R4600_V1_INDEX_ICACHEOP_WAR && cpu_is_r4600_v1_x())
+		if (R4600_V1_INDEX_ICACHEOP_WAR && cpu_is_r4600_v1_x())
 			r4k_blast_icache_page_indexed =
 				blast_icache32_r4600_v1_page_indexed;
+		else if (TX49XX_ICACHE_INDEX_INV_WAR)
+			r4k_blast_icache_page_indexed =
+				tx49_blast_icache32_page_indexed;
 		else
 			r4k_blast_icache_page_indexed =
 				blast_icache32_page_indexed;
@@ -361,24 +368,33 @@
 
 struct flush_cache_page_args {
 	struct vm_area_struct *vma;
-	unsigned long page;
+	unsigned long addr;
 };
 
 static inline void local_r4k_flush_cache_page(void *args)
 {
 	struct flush_cache_page_args *fcp_args = args;
 	struct vm_area_struct *vma = fcp_args->vma;
-	unsigned long page = fcp_args->page;
+	unsigned long addr = fcp_args->addr;
 	int exec = vma->vm_flags & VM_EXEC;
 	struct mm_struct *mm = vma->vm_mm;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 
-	page &= PAGE_MASK;
-	pgdp = pgd_offset(mm, page);
-	pmdp = pmd_offset(pgdp, page);
-	ptep = pte_offset(pmdp, page);
+	/*
+	 * If ownes no valid ASID yet, cannot possibly have gotten
+	 * this page into the cache.
+	 */
+	if (cpu_context(smp_processor_id(), mm) == 0)
+		return;
+
+	addr &= PAGE_MASK;
+	pgdp = pgd_offset(mm, addr);
+	pudp = pud_offset(pgdp, addr);
+	pmdp = pmd_offset(pudp, addr);
+	ptep = pte_offset(pmdp, addr);
 
 	/*
 	 * If the page isn't marked valid, the page cannot possibly be
@@ -395,12 +411,12 @@
 	 */
 	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
 		if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
-			r4k_blast_dcache_page(page);
+			r4k_blast_dcache_page(addr);
 			if (exec && !cpu_icache_snoops_remote_store)
-				r4k_blast_scache_page(page);
+				r4k_blast_scache_page(addr);
 		}
 		if (exec)
-			r4k_blast_icache_page(page);
+			r4k_blast_icache_page(addr);
 
 		return;
 	}
@@ -409,36 +425,30 @@
 	 * Do indexed flush, too much work to get the (possible) TLB refills
 	 * to work correctly.
 	 */
-	page = INDEX_BASE + (page & (dcache_size - 1));
+	addr = INDEX_BASE + (addr & (dcache_size - 1));
 	if (cpu_has_dc_aliases || (exec && !cpu_has_ic_fills_f_dc)) {
-		r4k_blast_dcache_page_indexed(page);
+		r4k_blast_dcache_page_indexed(addr);
 		if (exec && !cpu_icache_snoops_remote_store)
-			r4k_blast_scache_page_indexed(page);
+			r4k_blast_scache_page_indexed(addr);
 	}
 	if (exec) {
 		if (cpu_has_vtag_icache) {
 			int cpu = smp_processor_id();
 
-			if (cpu_context(cpu, vma->vm_mm) != 0)
-				drop_mmu_context(vma->vm_mm, cpu);
+			if (cpu_context(cpu, mm) != 0)
+				drop_mmu_context(mm, cpu);
 		} else
-			r4k_blast_icache_page_indexed(page);
+			r4k_blast_icache_page_indexed(addr);
 	}
 }
 
-static void r4k_flush_cache_page(struct vm_area_struct *vma, unsigned long page, unsigned long pfn)
+static void r4k_flush_cache_page(struct vm_area_struct *vma,
+	unsigned long addr, unsigned long pfn)
 {
 	struct flush_cache_page_args args;
 
-	/*
-	 * If ownes no valid ASID yet, cannot possibly have gotten
-	 * this page into the cache.
-	 */
-	if (cpu_context(smp_processor_id(), vma->vm_mm) == 0)
-		return;
-
 	args.vma = vma;
-	args.page = page;
+	args.addr = addr;
 
 	on_each_cpu(local_r4k_flush_cache_page, &args, 1, 1);
 }
@@ -454,16 +464,16 @@
 }
 
 struct flush_icache_range_args {
-	unsigned long start;
-	unsigned long end;
+	unsigned long __user start;
+	unsigned long __user end;
 };
 
 static inline void local_r4k_flush_icache_range(void *args)
 {
 	struct flush_icache_range_args *fir_args = args;
-	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
-	unsigned long ic_lsize = current_cpu_data.icache.linesz;
-	unsigned long sc_lsize = current_cpu_data.scache.linesz;
+	unsigned long dc_lsize = cpu_dcache_line_size();
+	unsigned long ic_lsize = cpu_icache_line_size();
+	unsigned long sc_lsize = cpu_scache_line_size();
 	unsigned long start = fir_args->start;
 	unsigned long end = fir_args->end;
 	unsigned long addr, aend;
@@ -472,6 +482,7 @@
 		if (end - start > dcache_size) {
 			r4k_blast_dcache();
 		} else {
+			R4600_HIT_CACHEOP_WAR_IMPL;
 			addr = start & ~(dc_lsize - 1);
 			aend = (end - 1) & ~(dc_lsize - 1);
 
@@ -492,7 +503,7 @@
 				aend = (end - 1) & ~(sc_lsize - 1);
 
 				while (1) {
-					/* Hit_Writeback_Inv_D */
+					/* Hit_Writeback_Inv_SD */
 					protected_writeback_scache_line(addr);
 					if (addr == aend)
 						break;
@@ -517,7 +528,8 @@
 	}
 }
 
-static void r4k_flush_icache_range(unsigned long start, unsigned long end)
+static void r4k_flush_icache_range(unsigned long __user start,
+	unsigned long __user end)
 {
 	struct flush_icache_range_args args;
 
@@ -525,6 +537,7 @@
 	args.end = end;
 
 	on_each_cpu(local_r4k_flush_icache_range, &args, 1, 1);
+	instruction_hazard();
 }
 
 /*
@@ -613,7 +626,7 @@
 	BUG_ON(size == 0);
 
 	if (cpu_has_subset_pcaches) {
-		unsigned long sc_lsize = current_cpu_data.scache.linesz;
+		unsigned long sc_lsize = cpu_scache_line_size();
 
 		if (size >= scache_size) {
 			r4k_blast_scache();
@@ -639,7 +652,7 @@
 	if (size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
-		unsigned long dc_lsize = current_cpu_data.dcache.linesz;
+		unsigned long dc_lsize = cpu_dcache_line_size();
 
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		a = addr & ~(dc_lsize - 1);
@@ -663,7 +676,7 @@
 	BUG_ON(size == 0);
 
 	if (cpu_has_subset_pcaches) {
-		unsigned long sc_lsize = current_cpu_data.scache.linesz;
+		unsigned long sc_lsize = cpu_scache_line_size();
 
 		if (size >= scache_size) {
 			r4k_blast_scache();
@@ -684,7 +697,7 @@
 	if (size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
-		unsigned long dc_lsize = current_cpu_data.dcache.linesz;
+		unsigned long dc_lsize = cpu_dcache_line_size();
 
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		a = addr & ~(dc_lsize - 1);
@@ -708,9 +721,9 @@
  */
 static void local_r4k_flush_cache_sigtramp(void * arg)
 {
-	unsigned long ic_lsize = current_cpu_data.icache.linesz;
-	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
-	unsigned long sc_lsize = current_cpu_data.scache.linesz;
+	unsigned long ic_lsize = cpu_icache_line_size();
+	unsigned long dc_lsize = cpu_dcache_line_size();
+	unsigned long sc_lsize = cpu_scache_line_size();
 	unsigned long addr = (unsigned long) arg;
 
 	R4600_HIT_CACHEOP_WAR_IMPL;
@@ -762,6 +775,7 @@
 
 	for (addr = INDEX_BASE; addr <= INDEX_BASE + 4096; addr += ic_lsize) {
 		__asm__ __volatile__ (
+			".set push\n\t"
 			".set noreorder\n\t"
 			".set mips3\n\t"
 			"cache\t%1, 0(%0)\n\t"
@@ -776,8 +790,7 @@
 			"cache\t%1, 0x1000(%0)\n\t"
 			"cache\t%1, 0x2000(%0)\n\t"
 			"cache\t%1, 0x3000(%0)\n\t"
-			".set\tmips0\n\t"
-			".set\treorder\n\t"
+			".set pop\n"
 			:
 			: "r" (addr), "i" (Index_Store_Tag_I), "i" (Fill));
 	}
@@ -1011,9 +1024,19 @@
 	 * normally they'd suffer from aliases but magic in the hardware deals
 	 * with that for us so we don't need to take care ourselves.
 	 */
-	if (c->cputype != CPU_R10000 && c->cputype != CPU_R12000)
-		if (c->dcache.waysize > PAGE_SIZE)
-		        c->dcache.flags |= MIPS_CACHE_ALIASES;
+	switch (c->cputype) {
+	case CPU_20KC:
+	case CPU_25KF:
+	case CPU_R10000:
+	case CPU_R12000:
+	case CPU_SB1:
+		break;
+	case CPU_24K:
+		if (!(read_c0_config7() & (1 << 16)))
+	default:
+			if (c->dcache.waysize > PAGE_SIZE)
+				c->dcache.flags |= MIPS_CACHE_ALIASES;
+	}
 
 	switch (c->cputype) {
 	case CPU_20KC:
@@ -1024,7 +1047,11 @@
 		c->icache.flags |= MIPS_CACHE_VTAG;
 		break;
 
+	case CPU_AU1000:
 	case CPU_AU1500:
+	case CPU_AU1100:
+	case CPU_AU1550:
+	case CPU_AU1200:
 		c->icache.flags |= MIPS_CACHE_IC_F_DC;
 		break;
 	}
@@ -1102,7 +1129,6 @@
 	return 1;
 }
 
-typedef int (*probe_func_t)(unsigned long);
 extern int r5k_sc_init(void);
 extern int rm7k_sc_init(void);
 
@@ -1110,7 +1136,6 @@
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int config = read_c0_config();
-	probe_func_t probe_scache_kseg1;
 	int sc_present = 0;
 
 	/*
@@ -1123,8 +1148,7 @@
 	case CPU_R4000MC:
 	case CPU_R4400SC:
 	case CPU_R4400MC:
-		probe_scache_kseg1 = (probe_func_t) (CKSEG1ADDR(&probe_scache));
-		sc_present = probe_scache_kseg1(config);
+		sc_present = run_uncached(probe_scache);
 		if (sc_present)
 			c->options |= MIPS_CPU_CACHE_CDEX_S;
 		break;
@@ -1198,7 +1222,7 @@
 	}
 }
 
-void __init ld_mmu_r4xx0(void)
+void __init r4k_cache_init(void)
 {
 	extern void build_clear_page(void);
 	extern void build_copy_page(void);
@@ -1206,15 +1230,11 @@
 	struct cpuinfo_mips *c = &current_cpu_data;
 
 	/* Default cache error handler for R4000 and R5000 family */
-	memcpy((void *)(CAC_BASE   + 0x100), &except_vec2_generic, 0x80);
-	memcpy((void *)(UNCAC_BASE + 0x100), &except_vec2_generic, 0x80);
+	set_uncached_handler (0x100, &except_vec2_generic, 0x80);
 
 	probe_pcache();
 	setup_scache();
 
-	if (c->dcache.sets * c->dcache.ways > PAGE_SIZE)
-		c->dcache.flags |= MIPS_CACHE_ALIASES;
-
 	r4k_blast_dcache_page_setup();
 	r4k_blast_dcache_page_indexed_setup();
 	r4k_blast_dcache_setup();
@@ -1252,9 +1272,8 @@
 	_dma_cache_inv		= r4k_dma_cache_inv;
 #endif
 
-	__flush_cache_all();
-	coherency_setup();
-
 	build_clear_page();
 	build_copy_page();
+	local_r4k___flush_cache_all(NULL);
+	coherency_setup();
 }
diff -Naur linux-2.6.14/arch/mips/mm/c-sb1.c linux-mips-2.6.14.orig/arch/mips/mm/c-sb1.c
--- linux-2.6.14/arch/mips/mm/c-sb1.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/c-sb1.c	2005-11-17 11:42:25.000000000 -0800
@@ -235,7 +235,7 @@
 /*
  * Invalidate all caches on this CPU
  */
-static void local_sb1___flush_cache_all(void)
+static void __attribute_used__ local_sb1___flush_cache_all(void)
 {
 	__sb1_writeback_inv_dcache_all();
 	__sb1_flush_icache_all();
@@ -492,19 +492,17 @@
 }
 
 /*
- * This is called from loadmmu.c.  We have to set up all the
+ * This is called from cache.c.  We have to set up all the
  * memory management function pointers, as well as initialize
  * the caches and tlbs
  */
-void ld_mmu_sb1(void)
+void sb1_cache_init(void)
 {
 	extern char except_vec2_sb1;
 	extern char handle_vec2_sb1;
 
 	/* Special cache error handler for SB1 */
-	memcpy((void *)(CAC_BASE   + 0x100), &except_vec2_sb1, 0x80);
-	memcpy((void *)(UNCAC_BASE + 0x100), &except_vec2_sb1, 0x80);
-	memcpy((void *)CKSEG1ADDR(&handle_vec2_sb1), &handle_vec2_sb1, 0x80);
+	set_uncached_handler (0x100, &except_vec2_sb1, 0x80);
 
 	probe_cache_sizes();
 
diff -Naur linux-2.6.14/arch/mips/mm/c-tx39.c linux-mips-2.6.14.orig/arch/mips/mm/c-tx39.c
--- linux-2.6.14/arch/mips/mm/c-tx39.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/c-tx39.c	2005-11-17 11:42:25.000000000 -0800
@@ -167,15 +167,16 @@
 static void tx39_flush_cache_range(struct vm_area_struct *vma,
 	unsigned long start, unsigned long end)
 {
-	struct mm_struct *mm = vma->vm_mm;
+	int exec;
 
-	if (!cpu_has_dc_aliases)
+	if (!(cpu_context(smp_processor_id(), vma->vm_mm)))
 		return;
 
-	if (cpu_context(smp_processor_id(), mm) != 0) {
+	exec = vma->vm_flags & VM_EXEC;
+	if (cpu_has_dc_aliases || exec)
 		tx39_blast_dcache();
+	if (exec)
 		tx39_blast_icache();
-	}
 }
 
 static void tx39_flush_cache_page(struct vm_area_struct *vma, unsigned long page, unsigned long pfn)
@@ -183,6 +184,7 @@
 	int exec = vma->vm_flags & VM_EXEC;
 	struct mm_struct *mm = vma->vm_mm;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 
@@ -195,7 +197,8 @@
 
 	page &= PAGE_MASK;
 	pgdp = pgd_offset(mm, page);
-	pmdp = pmd_offset(pgdp, page);
+	pudp = pud_offset(pgdp, page);
+	pmdp = pmd_offset(pudp, page);
 	ptep = pte_offset(pmdp, page);
 
 	/*
@@ -407,7 +410,7 @@
 	}
 }
 
-void __init ld_mmu_tx39(void)
+void __init tx39_cache_init(void)
 {
 	extern void build_clear_page(void);
 	extern void build_copy_page(void);
@@ -490,4 +493,5 @@
 
 	build_clear_page();
 	build_copy_page();
+	tx39h_flush_icache_all();
 }
diff -Naur linux-2.6.14/arch/mips/mm/dma-coherent.c linux-mips-2.6.14.orig/arch/mips/mm/dma-coherent.c
--- linux-2.6.14/arch/mips/mm/dma-coherent.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/dma-coherent.c	2005-11-17 11:42:26.000000000 -0800
@@ -9,16 +9,16 @@
  */
 #include <linux/config.h>
 #include <linux/types.h>
+#include <linux/dma-mapping.h>
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/string.h>
-#include <linux/pci.h>
 
 #include <asm/cache.h>
 #include <asm/io.h>
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 	/* ignore region specifiers */
@@ -39,7 +39,7 @@
 EXPORT_SYMBOL(dma_alloc_noncoherent);
 
 void *dma_alloc_coherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 	__attribute__((alias("dma_alloc_noncoherent")));
 
 EXPORT_SYMBOL(dma_alloc_coherent);
diff -Naur linux-2.6.14/arch/mips/mm/dma-ip27.c linux-mips-2.6.14.orig/arch/mips/mm/dma-ip27.c
--- linux-2.6.14/arch/mips/mm/dma-ip27.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/dma-ip27.c	2005-11-17 11:42:26.000000000 -0800
@@ -22,7 +22,7 @@
 	pdev_to_baddr(to_pci_dev(dev), (addr))
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 
@@ -44,7 +44,7 @@
 EXPORT_SYMBOL(dma_alloc_noncoherent);
 
 void *dma_alloc_coherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 	__attribute__((alias("dma_alloc_noncoherent")));
 
 EXPORT_SYMBOL(dma_alloc_coherent);
diff -Naur linux-2.6.14/arch/mips/mm/dma-ip32.c linux-mips-2.6.14.orig/arch/mips/mm/dma-ip32.c
--- linux-2.6.14/arch/mips/mm/dma-ip32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/dma-ip32.c	2005-11-17 11:42:26.000000000 -0800
@@ -37,7 +37,7 @@
 #define RAM_OFFSET_MASK	0x3fffffff
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 	/* ignore region specifiers */
@@ -61,7 +61,7 @@
 EXPORT_SYMBOL(dma_alloc_noncoherent);
 
 void *dma_alloc_coherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 
diff -Naur linux-2.6.14/arch/mips/mm/dma-noncoherent.c linux-mips-2.6.14.orig/arch/mips/mm/dma-noncoherent.c
--- linux-2.6.14/arch/mips/mm/dma-noncoherent.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/dma-noncoherent.c	2005-11-17 11:42:26.000000000 -0800
@@ -24,7 +24,7 @@
  */
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 	/* ignore region specifiers */
@@ -45,7 +45,7 @@
 EXPORT_SYMBOL(dma_alloc_noncoherent);
 
 void *dma_alloc_coherent(struct device *dev, size_t size,
-	dma_addr_t * dma_handle, int gfp)
+	dma_addr_t * dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 
@@ -105,22 +105,7 @@
 {
 	unsigned long addr = (unsigned long) ptr;
 
-	switch (direction) {
-	case DMA_TO_DEVICE:
-		dma_cache_wback(addr, size);
-		break;
-
-	case DMA_FROM_DEVICE:
-		dma_cache_inv(addr, size);
-		break;
-
-	case DMA_BIDIRECTIONAL:
-		dma_cache_wback_inv(addr, size);
-		break;
-
-	default:
-		BUG();
-	}
+	__dma_sync(addr, size, direction);
 
 	return virt_to_phys(ptr);
 }
@@ -133,22 +118,7 @@
 	unsigned long addr;
 	addr = dma_addr + PAGE_OFFSET;
 
-	switch (direction) {
-	case DMA_TO_DEVICE:
-		//dma_cache_wback(addr, size);
-		break;
-
-	case DMA_FROM_DEVICE:
-		//dma_cache_inv(addr, size);
-		break;
-
-	case DMA_BIDIRECTIONAL:
-		//dma_cache_wback_inv(addr, size);
-		break;
-
-	default:
-		BUG();
-	}
+	//__dma_sync(addr, size, direction);
 }
 
 EXPORT_SYMBOL(dma_unmap_single);
@@ -164,10 +134,11 @@
 		unsigned long addr;
 
 		addr = (unsigned long) page_address(sg->page);
-		if (addr)
+		if (addr) {
 			__dma_sync(addr + sg->offset, sg->length, direction);
-		sg->dma_address = (dma_addr_t)
-			(page_to_phys(sg->page) + sg->offset);
+			sg->dma_address = (dma_addr_t)page_to_phys(sg->page)
+					  + sg->offset;
+		}
 	}
 
 	return nents;
@@ -218,9 +189,8 @@
 
 	for (i = 0; i < nhwentries; i++, sg++) {
 		addr = (unsigned long) page_address(sg->page);
-		if (!addr)
-			continue;
-		dma_cache_wback_inv(addr + sg->offset, sg->length);
+		if (addr)
+			__dma_sync(addr + sg->offset, sg->length, direction);
 	}
 }
 
diff -Naur linux-2.6.14/arch/mips/mm/fault.c linux-mips-2.6.14.orig/arch/mips/mm/fault.c
--- linux-2.6.14/arch/mips/mm/fault.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/fault.c	2005-11-17 11:42:26.000000000 -0800
@@ -25,6 +25,7 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -57,7 +58,7 @@
 	 * only copy the information from the master page table,
 	 * nothing more.
 	 */
-	if (unlikely(address >= VMALLOC_START))
+	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))
 		goto vmalloc_fault;
 
 	/*
@@ -140,7 +141,7 @@
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		/* info.si_code has been set above */
-		info.si_addr = (void *) address;
+		info.si_addr = (void __user *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
 		return;
 	}
@@ -196,7 +197,7 @@
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
 	info.si_code = BUS_ADRERR;
-	info.si_addr = (void *) address;
+	info.si_addr = (void __user *) address;
 	force_sig_info(SIGBUS, &info, tsk);
 
 	return;
@@ -212,6 +213,7 @@
 		 */
 		int offset = __pgd_offset(address);
 		pgd_t *pgd, *pgd_k;
+		pud_t *pud, *pud_k;
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
@@ -222,8 +224,13 @@
 			goto no_context;
 		set_pgd(pgd, *pgd_k);
 
-		pmd = pmd_offset(pgd, address);
-		pmd_k = pmd_offset(pgd_k, address);
+		pud = pud_offset(pgd, address);
+		pud_k = pud_offset(pgd_k, address);
+		if (!pud_present(*pud_k))
+			goto no_context;
+
+		pmd = pmd_offset(pud, address);
+		pmd_k = pmd_offset(pud_k, address);
 		if (!pmd_present(*pmd_k))
 			goto no_context;
 		set_pmd(pmd, *pmd_k);
diff -Naur linux-2.6.14/arch/mips/mm/highmem.c linux-mips-2.6.14.orig/arch/mips/mm/highmem.c
--- linux-2.6.14/arch/mips/mm/highmem.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/highmem.c	2005-11-17 11:42:26.000000000 -0800
@@ -83,6 +83,25 @@
 	preempt_check_resched();
 }
 
+/*
+ * This is the same as kmap_atomic() but can map memory that doesn't
+ * have a struct page associated with it.
+ */
+void *kmap_atomic_pfn(unsigned long pfn, enum km_type type)
+{
+	enum fixed_addresses idx;
+	unsigned long vaddr;
+
+	inc_preempt_count();
+
+	idx = type + KM_TYPE_NR*smp_processor_id();
+	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+	set_pte(kmap_pte-idx, pfn_pte(pfn, kmap_prot));
+	flush_tlb_one(vaddr);
+
+	return (void*) vaddr;
+}
+
 struct page *__kmap_atomic_to_page(void *ptr)
 {
 	unsigned long idx, vaddr = (unsigned long)ptr;
diff -Naur linux-2.6.14/arch/mips/mm/init.c linux-mips-2.6.14.orig/arch/mips/mm/init.c
--- linux-2.6.14/arch/mips/mm/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/init.c	2005-11-17 11:42:26.000000000 -0800
@@ -83,7 +83,7 @@
 pgprot_t kmap_prot;
 
 #define kmap_get_fixmap_pte(vaddr)					\
-	pte_offset_kernel(pmd_offset(pgd_offset_k(vaddr), (vaddr)), (vaddr))
+	pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr), (vaddr)), (vaddr)), (vaddr))
 
 static void __init kmap_init(void)
 {
@@ -96,36 +96,42 @@
 	kmap_prot = PAGE_KERNEL;
 }
 
-#ifdef CONFIG_64BIT
-static void __init fixrange_init(unsigned long start, unsigned long end,
+#ifdef CONFIG_32BIT
+void __init fixrange_init(unsigned long start, unsigned long end,
 	pgd_t *pgd_base)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
-	int i, j;
+	int i, j, k;
 	unsigned long vaddr;
 
 	vaddr = start;
 	i = __pgd_offset(vaddr);
-	j = __pmd_offset(vaddr);
+	j = __pud_offset(vaddr);
+	k = __pmd_offset(vaddr);
 	pgd = pgd_base + i;
 
 	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-		pmd = (pmd_t *)pgd;
-		for (; (j < PTRS_PER_PMD) && (vaddr != end); pmd++, j++) {
-			if (pmd_none(*pmd)) {
-				pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-				set_pmd(pmd, __pmd(pte));
-				if (pte != pte_offset_kernel(pmd, 0))
-					BUG();
+		pud = (pud_t *)pgd;
+		for ( ; (j < PTRS_PER_PUD) && (vaddr != end); pud++, j++) {
+			pmd = (pmd_t *)pud;
+			for (; (k < PTRS_PER_PMD) && (vaddr != end); pmd++, k++) {
+				if (pmd_none(*pmd)) {
+					pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
+					set_pmd(pmd, __pmd(pte));
+					if (pte != pte_offset_kernel(pmd, 0))
+						BUG();
+				}
+				vaddr += PMD_SIZE;
 			}
-			vaddr += PMD_SIZE;
+			k = 0;
 		}
 		j = 0;
 	}
 }
-#endif /* CONFIG_64BIT */
+#endif /* CONFIG_32BIT */
 #endif /* CONFIG_HIGHMEM */
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES
diff -Naur linux-2.6.14/arch/mips/mm/ioremap.c linux-mips-2.6.14.orig/arch/mips/mm/ioremap.c
--- linux-2.6.14/arch/mips/mm/ioremap.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/ioremap.c	2005-11-17 11:42:26.000000000 -0800
@@ -79,9 +79,14 @@
 		BUG();
 	spin_lock(&init_mm.page_table_lock);
 	do {
+		pud_t *pud;
 		pmd_t *pmd;
-		pmd = pmd_alloc(&init_mm, dir, address);
+
 		error = -ENOMEM;
+		pud = pud_alloc(&init_mm, dir, address);
+		if (!pud)
+			break;
+		pmd = pmd_alloc(&init_mm, pud, address);
 		if (!pmd)
 			break;
 		if (remap_area_pmd(pmd, address, end - address,
@@ -97,15 +102,6 @@
 }
 
 /*
- * Allow physical addresses to be fixed up to help 36 bit peripherals.
- */
-phys_t __attribute__ ((weak))
-fixup_bigphys_addr(phys_t phys_addr, phys_t size)
-{
-	return phys_addr;
-}
-
-/*
  * Generic mapping function (not visible outside):
  */
 
@@ -121,7 +117,7 @@
 
 #define IS_LOW512(addr) (!((phys_t)(addr) & (phys_t) ~0x1fffffffULL))
 
-void * __ioremap(phys_t phys_addr, phys_t size, unsigned long flags)
+void __iomem * __ioremap(phys_t phys_addr, phys_t size, unsigned long flags)
 {
 	struct vm_struct * area;
 	unsigned long offset;
@@ -141,7 +137,7 @@
 	 */
 	if (IS_LOW512(phys_addr) && IS_LOW512(last_addr) &&
 	    flags == _CACHE_UNCACHED)
-		return (void *) KSEG1ADDR(phys_addr);
+		return (void __iomem *) CKSEG1ADDR(phys_addr);
 
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
@@ -177,10 +173,10 @@
 		return NULL;
 	}
 
-	return (void *) (offset + (char *)addr);
+	return (void __iomem *) (offset + (char *)addr);
 }
 
-#define IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == KSEG1)
+#define IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == CKSEG1)
 
 void __iounmap(volatile void __iomem *addr)
 {
@@ -190,10 +186,8 @@
 		return;
 
 	p = remove_vm_area((void *) (PAGE_MASK & (unsigned long __force) addr));
-	if (!p) {
+	if (!p)
 		printk(KERN_ERR "iounmap: bad address %p\n", addr);
-		return;
-	}
 
         kfree(p);
 }
diff -Naur linux-2.6.14/arch/mips/mm/Makefile linux-mips-2.6.14.orig/arch/mips/mm/Makefile
--- linux-2.6.14/arch/mips/mm/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/Makefile	2005-11-17 11:42:25.000000000 -0800
@@ -22,7 +22,7 @@
 obj-$(CONFIG_CPU_RM7000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_RM9000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_SB1)		+= c-sb1.o cerr-sb1.o cex-sb1.o pg-sb1.o \
-				   tlb-sb1.o
+				   tlb-r4k.o
 obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o pg-r4k.o tlb-r3k.o
 obj-$(CONFIG_CPU_TX49XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_VR41XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
diff -Naur linux-2.6.14/arch/mips/mm/pg-r4k.c linux-mips-2.6.14.orig/arch/mips/mm/pg-r4k.c
--- linux-2.6.14/arch/mips/mm/pg-r4k.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/pg-r4k.c	2005-11-17 11:42:26.000000000 -0800
@@ -25,7 +25,10 @@
 #include <asm/cpu.h>
 #include <asm/war.h>
 
-#define half_scache_line_size()		(cpu_scache_line_size() >> 1)
+#define half_scache_line_size()	(cpu_scache_line_size() >> 1)
+#define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x00002010)
+#define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x00002020)
+
 
 /*
  * Maximum sizes:
@@ -198,15 +201,15 @@
 	if (store_offset & (cpu_dcache_line_size() - 1))
 		return;
 
-	if (R4600_V1_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2010)) {
+	if (R4600_V1_HIT_CACHEOP_WAR && cpu_is_r4600_v1_x()) {
 		build_nop();
 		build_nop();
 		build_nop();
 		build_nop();
 	}
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
-		build_insn_word(0x8c200000);	/* lw      $zero, ($at) */
+	if (R4600_V2_HIT_CACHEOP_WAR && cpu_is_r4600_v2_x())
+		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
 	mi.c_format.opcode     = cache_op;
 	mi.c_format.rs         = 4;		/* $a0 */
@@ -361,7 +364,7 @@
 
 	build_addiu_a2_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_clear : 0));
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+	if (R4600_V2_HIT_CACHEOP_WAR && cpu_is_r4600_v2_x())
 		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
 dest = label();
@@ -404,9 +407,6 @@
 
 	build_jr_ra();
 
-	flush_icache_range((unsigned long)&clear_page_array,
-	                   (unsigned long) epc);
-
 	BUG_ON(epc > clear_page_array + ARRAY_SIZE(clear_page_array));
 }
 
@@ -420,7 +420,7 @@
 
 	build_addiu_a2_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_copy : 0));
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+	if (R4600_V2_HIT_CACHEOP_WAR && cpu_is_r4600_v2_x())
 		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
 dest = label();
@@ -482,8 +482,5 @@
 
 	build_jr_ra();
 
-	flush_icache_range((unsigned long)&copy_page_array,
-	                   (unsigned long) epc);
-
 	BUG_ON(epc > copy_page_array + ARRAY_SIZE(copy_page_array));
 }
diff -Naur linux-2.6.14/arch/mips/mm/pg-sb1.c linux-mips-2.6.14.orig/arch/mips/mm/pg-sb1.c
--- linux-2.6.14/arch/mips/mm/pg-sb1.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/pg-sb1.c	2005-11-17 11:42:26.000000000 -0800
@@ -60,7 +60,8 @@
 	"	.set	noreorder	\n"
 #ifdef CONFIG_CPU_HAS_PREFETCH
 	"	daddiu	%0, %0, 128	\n"
-	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%0)  \n"  /* Prefetch the first 4 lines */
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%0)  \n"
+					     /* Prefetch the first 4 lines */
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -96(%0)  \n"
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -64(%0)  \n"
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -32(%0)  \n"
@@ -106,7 +107,8 @@
 #ifdef CONFIG_CPU_HAS_PREFETCH
 	"	daddiu	%0, %0, 128	\n"
 	"	daddiu	%1, %1, 128	\n"
-	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ", -128(%0)\n"  /* Prefetch the first 4 lines */
+	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ", -128(%0)\n"
+					     /* Prefetch the first 4 lines */
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%1)\n"
 	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  -96(%0)\n"
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -96(%1)\n"
@@ -207,66 +209,73 @@
 	u64 pad_b;
 } dmadscr_t;
 
-static dmadscr_t page_descr[NR_CPUS] __attribute__((aligned(SMP_CACHE_BYTES)));
+static dmadscr_t page_descr[DM_NUM_CHANNELS]
+	__attribute__((aligned(SMP_CACHE_BYTES)));
 
 void sb1_dma_init(void)
 {
-	int cpu = smp_processor_id();
-	u64 base_val = CPHYSADDR(&page_descr[cpu]) | V_DM_DSCR_BASE_RINGSZ(1);
+	int i;
 
-	bus_writeq(base_val,
-		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
-	bus_writeq(base_val | M_DM_DSCR_BASE_RESET,
-		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
-	bus_writeq(base_val | M_DM_DSCR_BASE_ENABL,
-		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	for (i = 0; i < DM_NUM_CHANNELS; i++) {
+		const u64 base_val = CPHYSADDR(&page_descr[i]) |
+				     V_DM_DSCR_BASE_RINGSZ(1);
+		volatile void *base_reg =
+			IOADDR(A_DM_REGISTER(i, R_DM_DSCR_BASE));
+
+		__raw_writeq(base_val, base_reg);
+		__raw_writeq(base_val | M_DM_DSCR_BASE_RESET, base_reg);
+		__raw_writeq(base_val | M_DM_DSCR_BASE_ENABL, base_reg);
+	}
 }
 
 void clear_page(void *page)
 {
-	int cpu = smp_processor_id();
+	u64 to_phys = CPHYSADDR(page);
+	unsigned int cpu = smp_processor_id();
 
-	/* if the page is above Kseg0, use old way */
+	/* if the page is not in KSEG0, use old way */
 	if ((long)KSEGX(page) != (long)CKSEG0)
 		return clear_page_cpu(page);
 
-	page_descr[cpu].dscr_a = CPHYSADDR(page) | M_DM_DSCRA_ZERO_MEM | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
+	page_descr[cpu].dscr_a = to_phys | M_DM_DSCRA_ZERO_MEM |
+				 M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
 	page_descr[cpu].dscr_b = V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
-	bus_writeq(1, (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
+	__raw_writeq(1, IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
 
 	/*
 	 * Don't really want to do it this way, but there's no
 	 * reliable way to delay completion detection.
 	 */
-	while (!(bus_readq((void *)(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) &
-			   M_DM_DSCR_BASE_INTERRUPT))))
+	while (!(__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)))
+		 & M_DM_DSCR_BASE_INTERRUPT))
 		;
-	bus_readq((void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
 void copy_page(void *to, void *from)
 {
-	unsigned long from_phys = CPHYSADDR(from);
-	unsigned long to_phys = CPHYSADDR(to);
-	int cpu = smp_processor_id();
+	u64 from_phys = CPHYSADDR(from);
+	u64 to_phys = CPHYSADDR(to);
+	unsigned int cpu = smp_processor_id();
 
-	/* if either page is above Kseg0, use old way */
+	/* if any page is not in KSEG0, use old way */
 	if ((long)KSEGX(to) != (long)CKSEG0
 	    || (long)KSEGX(from) != (long)CKSEG0)
 		return copy_page_cpu(to, from);
 
-	page_descr[cpu].dscr_a = CPHYSADDR(to_phys) | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
-	page_descr[cpu].dscr_b = CPHYSADDR(from_phys) | V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
-	bus_writeq(1, (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
+	page_descr[cpu].dscr_a = to_phys | M_DM_DSCRA_L2C_DEST |
+				 M_DM_DSCRA_INTERRUPT;
+	page_descr[cpu].dscr_b = from_phys | V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
+	__raw_writeq(1, IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
 
 	/*
 	 * Don't really want to do it this way, but there's no
 	 * reliable way to delay completion detection.
 	 */
-	while (!(bus_readq((void *)(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) &
-				    M_DM_DSCR_BASE_INTERRUPT))))
+	while (!(__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)))
+		 & M_DM_DSCR_BASE_INTERRUPT))
 		;
-	bus_readq((void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
 #else /* !CONFIG_SIBYTE_DMA_PAGEOPS */
diff -Naur linux-2.6.14/arch/mips/mm/pgtable-32.c linux-mips-2.6.14.orig/arch/mips/mm/pgtable-32.c
--- linux-2.6.14/arch/mips/mm/pgtable-32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/pgtable-32.c	2005-11-17 11:42:26.000000000 -0800
@@ -10,6 +10,7 @@
 #include <linux/mm.h>
 #include <linux/bootmem.h>
 #include <linux/highmem.h>
+#include <asm/fixmap.h>
 #include <asm/pgtable.h>
 
 void pgd_init(unsigned long page)
@@ -29,42 +30,12 @@
 	}
 }
 
-#ifdef CONFIG_HIGHMEM
-static void __init fixrange_init (unsigned long start, unsigned long end,
-	pgd_t *pgd_base)
-{
-	pgd_t *pgd;
-	pmd_t *pmd;
-	pte_t *pte;
-	int i, j;
-	unsigned long vaddr;
-
-	vaddr = start;
-	i = __pgd_offset(vaddr);
-	j = __pmd_offset(vaddr);
-	pgd = pgd_base + i;
-
-	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-		pmd = (pmd_t *)pgd;
-		for (; (j < PTRS_PER_PMD) && (vaddr != end); pmd++, j++) {
-			if (pmd_none(*pmd)) {
-				pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-				set_pmd(pmd, __pmd((unsigned long)pte));
-				if (pte != pte_offset_kernel(pmd, 0))
-					BUG();
-			}
-			vaddr += PMD_SIZE;
-		}
-		j = 0;
-	}
-}
-#endif
-
 void __init pagetable_init(void)
 {
 #ifdef CONFIG_HIGHMEM
 	unsigned long vaddr;
 	pgd_t *pgd, *pgd_base;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 #endif
@@ -90,7 +61,8 @@
 	fixrange_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);
 
 	pgd = swapper_pg_dir + __pgd_offset(vaddr);
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	pmd = pmd_offset(pud, vaddr);
 	pte = pte_offset_kernel(pmd, vaddr);
 	pkmap_page_table = pte;
 #endif
diff -Naur linux-2.6.14/arch/mips/mm/sc-rm7k.c linux-mips-2.6.14.orig/arch/mips/mm/sc-rm7k.c
--- linux-2.6.14/arch/mips/mm/sc-rm7k.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/sc-rm7k.c	2005-11-17 11:42:26.000000000 -0800
@@ -15,6 +15,7 @@
 #include <asm/cacheops.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
+#include <asm/cacheflush.h> /* for run_uncached() */
 
 /* Primary cache parameters. */
 #define sc_lsize	32
@@ -96,25 +97,13 @@
 }
 
 /*
- * This function is executed in the uncached segment CKSEG1.
- * It must not touch the stack, because the stack pointer still points
- * into CKSEG0.
- *
- * Three options:
- *	- Write it in assembly and guarantee that we don't use the stack.
- *	- Disable caching for CKSEG0 before calling it.
- *	- Pray that GCC doesn't randomly start using the stack.
- *
- * This being Linux, we obviously take the least sane of those options -
- * following DaveM's lead in c-r4k.c
- *
- * It seems we get our kicks from relying on unguaranteed behaviour in GCC
+ * This function is executed in uncached address space.
  */
 static __init void __rm7k_sc_enable(void)
 {
 	int i;
 
-	set_c0_config(1 << 3);				/* CONF_SE */
+	set_c0_config(RM7K_CONF_SE);
 
 	write_c0_taglo(0);
 	write_c0_taghi(0);
@@ -127,24 +116,22 @@
 		      ".set mips0\n\t"
 		      ".set reorder"
 		      :
-		      : "r" (KSEG0ADDR(i)), "i" (Index_Store_Tag_SD));
+		      : "r" (CKSEG0ADDR(i)), "i" (Index_Store_Tag_SD));
 	}
 }
 
 static __init void rm7k_sc_enable(void)
 {
-	void (*func)(void) = (void *) KSEG1ADDR(&__rm7k_sc_enable);
-
-	if (read_c0_config() & 0x08)			/* CONF_SE */
+	if (read_c0_config() & RM7K_CONF_SE)
 		return;
 
-	printk(KERN_INFO "Enabling secondary cache...");
-	func();
+	printk(KERN_INFO "Enabling secondary cache...\n");
+	run_uncached(__rm7k_sc_enable);
 }
 
 static void rm7k_sc_disable(void)
 {
-	clear_c0_config(1<<3);				/* CONF_SE */
+	clear_c0_config(RM7K_CONF_SE);
 }
 
 struct bcache_ops rm7k_sc_ops = {
@@ -158,19 +145,19 @@
 {
 	unsigned int config = read_c0_config();
 
-	if ((config >> 31) & 1)		/* Bit 31 set -> no S-Cache */
+	if ((config & RM7K_CONF_SC))
 		return;
 
 	printk(KERN_INFO "Secondary cache size %dK, linesize %d bytes.\n",
 	       (scache_size >> 10), sc_lsize);
 
-	if (!((config >> 3) & 1))	/* CONF_SE */
+	if (!(config & RM7K_CONF_SE))
 		rm7k_sc_enable();
 
 	/*
 	 * While we're at it let's deal with the tertiary cache.
 	 */
-	if (!((config >> 17) & 1)) {
+	if (!(config & RM7K_CONF_TC)) {
 
 		/*
 		 * We can't enable the L3 cache yet. There may be board-specific
@@ -183,9 +170,9 @@
 		 * to probe it.
 		 */
 		printk(KERN_INFO "Tertiary cache present, %s enabled\n",
-		       config&(1<<12) ? "already" : "not (yet)");
+		       (config & RM7K_CONF_TE) ? "already" : "not (yet)");
 
-		if ((config >> 12) & 1)
+		if ((config & RM7K_CONF_TE))
 			rm7k_tcache_enabled = 1;
 	}
 
diff -Naur linux-2.6.14/arch/mips/mm/tlb-andes.c linux-mips-2.6.14.orig/arch/mips/mm/tlb-andes.c
--- linux-2.6.14/arch/mips/mm/tlb-andes.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/tlb-andes.c	2005-11-17 11:42:26.000000000 -0800
@@ -195,6 +195,7 @@
 {
 	unsigned long flags;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 	int idx, pid;
@@ -220,7 +221,8 @@
 	write_c0_entryhi(address | (pid));
 	pgdp = pgd_offset(vma->vm_mm, address);
 	tlb_probe();
-	pmdp = pmd_offset(pgdp, address);
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
 	idx = read_c0_index();
 	ptep = pte_offset_map(pmdp, address);
 	write_c0_entrylo0(pte_val(*ptep++) >> 6);
diff -Naur linux-2.6.14/arch/mips/mm/tlbex.c linux-mips-2.6.14.orig/arch/mips/mm/tlbex.c
--- linux-2.6.14/arch/mips/mm/tlbex.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/tlbex.c	2005-11-17 11:42:27.000000000 -0800
@@ -6,6 +6,7 @@
  * Synthesize TLB refill handlers at runtime.
  *
  * Copyright (C) 2004,2005 by Thiemo Seufer
+ * Copyright (C) 2005  Maciej W. Rozycki
  */
 
 #include <stdarg.h>
@@ -91,7 +92,7 @@
 	insn_addu, insn_addiu, insn_and, insn_andi, insn_beq,
 	insn_beql, insn_bgez, insn_bgezl, insn_bltz, insn_bltzl,
 	insn_bne, insn_daddu, insn_daddiu, insn_dmfc0, insn_dmtc0,
-	insn_dsll, insn_dsll32, insn_dsra, insn_dsrl, insn_dsrl32,
+	insn_dsll, insn_dsll32, insn_dsra, insn_dsrl,
 	insn_dsubu, insn_eret, insn_j, insn_jal, insn_jr, insn_ld,
 	insn_ll, insn_lld, insn_lui, insn_lw, insn_mfc0, insn_mtc0,
 	insn_ori, insn_rfe, insn_sc, insn_scd, insn_sd, insn_sll,
@@ -134,7 +135,6 @@
 	{ insn_dsll32, M(spec_op,0,0,0,0,dsll32_op), RT | RD | RE },
 	{ insn_dsra, M(spec_op,0,0,0,0,dsra_op), RT | RD | RE },
 	{ insn_dsrl, M(spec_op,0,0,0,0,dsrl_op), RT | RD | RE },
-	{ insn_dsrl32, M(spec_op,0,0,0,0,dsrl32_op), RT | RD | RE },
 	{ insn_dsubu, M(spec_op,0,0,0,0,dsubu_op), RS | RT | RD },
 	{ insn_eret, M(cop0_op,cop_op,0,0,0,eret_op), 0 },
 	{ insn_j, M(j_op,0,0,0,0,0), JIMM },
@@ -366,7 +366,6 @@
 I_u2u1u3(_dsll32);
 I_u2u1u3(_dsra);
 I_u2u1u3(_dsrl);
-I_u2u1u3(_dsrl32);
 I_u3u1u2(_dsubu);
 I_0(_eret);
 I_u1(_j);
@@ -412,7 +411,6 @@
 	label_nopage_tlbm,
 	label_smp_pgtable_change,
 	label_r3000_write_probe_fail,
-	label_r3000_write_probe_ok
 };
 
 struct label {
@@ -445,7 +443,6 @@
 L_LA(_nopage_tlbm)
 L_LA(_smp_pgtable_change)
 L_LA(_r3000_write_probe_fail)
-L_LA(_r3000_write_probe_ok)
 
 /* convenience macros for instructions */
 #ifdef CONFIG_64BIT
@@ -490,7 +487,7 @@
 static __init int __attribute__((unused)) in_compat_space_p(long addr)
 {
 	/* Is this address in 32bit compat space? */
-	return (((addr) & 0xffffffff00000000) == 0xffffffff00000000);
+	return (((addr) & 0xffffffff00000000L) == 0xffffffff00000000L);
 }
 
 static __init int __attribute__((unused)) rel_highest(long val)
@@ -734,7 +731,7 @@
 	if (p > tlb_handler + 32)
 		panic("TLB refill handler space exceeded");
 
-	printk("Synthesized TLB handler (%u instructions).\n",
+	printk("Synthesized TLB refill handler (%u instructions).\n",
 	       (unsigned int)(p - tlb_handler));
 #ifdef DEBUG_TLB
 	{
@@ -746,7 +743,6 @@
 #endif
 
 	memcpy((void *)CAC_BASE, tlb_handler, 0x80);
-	flush_icache_range(CAC_BASE, CAC_BASE + 0x80);
 }
 
 /*
@@ -783,6 +779,8 @@
 static __init void __attribute__((unused)) build_tlb_probe_entry(u32 **p)
 {
 	switch (current_cpu_data.cputype) {
+	/* Found by experiment: R4600 v2.0 needs this, too.  */
+	case CPU_R4600:
 	case CPU_R5000:
 	case CPU_R5000A:
 	case CPU_NEVADA:
@@ -834,12 +832,20 @@
 	case CPU_R4700:
 	case CPU_R5000:
 	case CPU_R5000A:
+		i_nop(p);
+		tlbw(p);
+		i_nop(p);
+		break;
+
+	case CPU_R4300:
 	case CPU_5KC:
 	case CPU_TX49XX:
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
 	case CPU_AU1550:
+	case CPU_AU1200:
+	case CPU_PR4450:
 		i_nop(p);
 		tlbw(p);
 		break;
@@ -848,6 +854,7 @@
 	case CPU_R12000:
 	case CPU_4KC:
 	case CPU_SB1:
+	case CPU_SB1A:
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
@@ -875,6 +882,7 @@
 
 	case CPU_4KEC:
 	case CPU_24K:
+	case CPU_34K:
 		i_ehb(p);
 		tlbw(p);
 		break;
@@ -911,6 +919,7 @@
 
 	case CPU_VR4131:
 	case CPU_VR4133:
+	case CPU_R5432:
 		i_nop(p);
 		i_nop(p);
 		tlbw(p);
@@ -942,34 +951,29 @@
 	/* No i_nop needed here, since the next insn doesn't touch TMP. */
 
 #ifdef CONFIG_SMP
+# ifdef CONFIG_BUILD_ELF64
 	/*
-	 * 64 bit SMP has the lower part of &pgd_current[smp_processor_id()]
+	 * 64 bit SMP running in XKPHYS has smp_processor_id() << 3
 	 * stored in CONTEXT.
 	 */
-	if (in_compat_space_p(pgdc)) {
-		i_dmfc0(p, ptr, C0_CONTEXT);
-		i_dsra(p, ptr, ptr, 23);
-		i_ld(p, ptr, 0, ptr);
-	} else {
-#ifdef CONFIG_BUILD_ELF64
-		i_dmfc0(p, ptr, C0_CONTEXT);
-		i_dsrl(p, ptr, ptr, 23);
-		i_dsll(p, ptr, ptr, 3);
-		i_LA_mostly(p, tmp, pgdc);
-		i_daddu(p, ptr, ptr, tmp);
-		i_dmfc0(p, tmp, C0_BADVADDR);
-		i_ld(p, ptr, rel_lo(pgdc), ptr);
-#else
-		i_dmfc0(p, ptr, C0_CONTEXT);
-		i_lui(p, tmp, rel_highest(pgdc));
-		i_dsll(p, ptr, ptr, 9);
-		i_daddiu(p, tmp, tmp, rel_higher(pgdc));
-		i_dsrl32(p, ptr, ptr, 0);
-		i_and(p, ptr, ptr, tmp);
-		i_dmfc0(p, tmp, C0_BADVADDR);
-		i_ld(p, ptr, 0, ptr);
-#endif
-	}
+	i_dmfc0(p, ptr, C0_CONTEXT);
+	i_dsrl(p, ptr, ptr, 23);
+	i_LA_mostly(p, tmp, pgdc);
+	i_daddu(p, ptr, ptr, tmp);
+	i_dmfc0(p, tmp, C0_BADVADDR);
+	i_ld(p, ptr, rel_lo(pgdc), ptr);
+# else
+	/*
+	 * 64 bit SMP running in compat space has the lower part of
+	 * &pgd_current[smp_processor_id()] stored in CONTEXT.
+	 */
+	if (!in_compat_space_p(pgdc))
+		panic("Invalid page directory address!");
+
+	i_dmfc0(p, ptr, C0_CONTEXT);
+	i_dsra(p, ptr, ptr, 23);
+	i_ld(p, ptr, 0, ptr);
+# endif
 #else
 	i_LA_mostly(p, ptr, pgdc);
 	i_ld(p, ptr, rel_lo(pgdc), ptr);
@@ -1026,7 +1030,6 @@
 	i_mfc0(p, ptr, C0_CONTEXT);
 	i_LA_mostly(p, tmp, pgdc);
 	i_srl(p, ptr, ptr, 23);
-	i_sll(p, ptr, ptr, 2);
 	i_addu(p, ptr, tmp, ptr);
 #else
 	i_LA_mostly(p, ptr, pgdc);
@@ -1245,13 +1248,19 @@
 	{
 		int i;
 
-		for (i = 0; i < 64; i++)
-			printk("%08x\n", final_handler[i]);
+		f = final_handler;
+#ifdef CONFIG_64BIT
+		if (final_len > 32)
+			final_len = 64;
+		else
+			f = final_handler + 32;
+#endif /* CONFIG_64BIT */
+		for (i = 0; i < final_len; i++)
+			printk("%08x\n", f[i]);
 	}
 #endif
 
 	memcpy((void *)CAC_BASE, final_handler, 0x100);
-	flush_icache_range(CAC_BASE, CAC_BASE + 0x100);
 }
 
 /*
@@ -1277,37 +1286,41 @@
 u32 __tlb_handler_align handle_tlbm[FASTPATH_SIZE];
 
 static void __init
-iPTE_LW(u32 **p, struct label **l, unsigned int pte, int offset,
-	unsigned int ptr)
+iPTE_LW(u32 **p, struct label **l, unsigned int pte, unsigned int ptr)
 {
 #ifdef CONFIG_SMP
 # ifdef CONFIG_64BIT_PHYS_ADDR
 	if (cpu_has_64bits)
-		i_lld(p, pte, offset, ptr);
+		i_lld(p, pte, 0, ptr);
 	else
 # endif
-		i_LL(p, pte, offset, ptr);
+		i_LL(p, pte, 0, ptr);
 #else
 # ifdef CONFIG_64BIT_PHYS_ADDR
 	if (cpu_has_64bits)
-		i_ld(p, pte, offset, ptr);
+		i_ld(p, pte, 0, ptr);
 	else
 # endif
-		i_LW(p, pte, offset, ptr);
+		i_LW(p, pte, 0, ptr);
 #endif
 }
 
 static void __init
-iPTE_SW(u32 **p, struct reloc **r, unsigned int pte, int offset,
-	unsigned int ptr)
+iPTE_SW(u32 **p, struct reloc **r, unsigned int pte, unsigned int ptr,
+	unsigned int mode)
 {
+#ifdef CONFIG_64BIT_PHYS_ADDR
+	unsigned int hwmode = mode & (_PAGE_VALID | _PAGE_DIRTY);
+#endif
+
+	i_ori(p, pte, pte, mode);
 #ifdef CONFIG_SMP
 # ifdef CONFIG_64BIT_PHYS_ADDR
 	if (cpu_has_64bits)
-		i_scd(p, pte, offset, ptr);
+		i_scd(p, pte, 0, ptr);
 	else
 # endif
-		i_SC(p, pte, offset, ptr);
+		i_SC(p, pte, 0, ptr);
 
 	if (r10000_llsc_war())
 		il_beqzl(p, r, pte, label_smp_pgtable_change);
@@ -1318,7 +1331,7 @@
 	if (!cpu_has_64bits) {
 		/* no i_nop needed */
 		i_ll(p, pte, sizeof(pte_t) / 2, ptr);
-		i_ori(p, pte, pte, _PAGE_VALID);
+		i_ori(p, pte, pte, hwmode);
 		i_sc(p, pte, sizeof(pte_t) / 2, ptr);
 		il_beqz(p, r, pte, label_smp_pgtable_change);
 		/* no i_nop needed */
@@ -1331,15 +1344,15 @@
 #else
 # ifdef CONFIG_64BIT_PHYS_ADDR
 	if (cpu_has_64bits)
-		i_sd(p, pte, offset, ptr);
+		i_sd(p, pte, 0, ptr);
 	else
 # endif
-		i_SW(p, pte, offset, ptr);
+		i_SW(p, pte, 0, ptr);
 
 # ifdef CONFIG_64BIT_PHYS_ADDR
 	if (!cpu_has_64bits) {
 		i_lw(p, pte, sizeof(pte_t) / 2, ptr);
-		i_ori(p, pte, pte, _PAGE_VALID);
+		i_ori(p, pte, pte, hwmode);
 		i_sw(p, pte, sizeof(pte_t) / 2, ptr);
 		i_lw(p, pte, 0, ptr);
 	}
@@ -1359,7 +1372,7 @@
 	i_andi(p, pte, pte, _PAGE_PRESENT | _PAGE_READ);
 	i_xori(p, pte, pte, _PAGE_PRESENT | _PAGE_READ);
 	il_bnez(p, r, pte, lid);
-	iPTE_LW(p, l, pte, 0, ptr);
+	iPTE_LW(p, l, pte, ptr);
 }
 
 /* Make PTE valid, store result in PTR. */
@@ -1367,8 +1380,9 @@
 build_make_valid(u32 **p, struct reloc **r, unsigned int pte,
 		 unsigned int ptr)
 {
-	i_ori(p, pte, pte, _PAGE_VALID | _PAGE_ACCESSED);
-	iPTE_SW(p, r, pte, 0, ptr);
+	unsigned int mode = _PAGE_VALID | _PAGE_ACCESSED;
+
+	iPTE_SW(p, r, pte, ptr, mode);
 }
 
 /*
@@ -1382,7 +1396,7 @@
 	i_andi(p, pte, pte, _PAGE_PRESENT | _PAGE_WRITE);
 	i_xori(p, pte, pte, _PAGE_PRESENT | _PAGE_WRITE);
 	il_bnez(p, r, pte, lid);
-	iPTE_LW(p, l, pte, 0, ptr);
+	iPTE_LW(p, l, pte, ptr);
 }
 
 /* Make PTE writable, update software status bits as well, then store
@@ -1392,9 +1406,10 @@
 build_make_write(u32 **p, struct reloc **r, unsigned int pte,
 		 unsigned int ptr)
 {
-	i_ori(p, pte, pte,
-	      _PAGE_ACCESSED | _PAGE_MODIFIED | _PAGE_VALID | _PAGE_DIRTY);
-	iPTE_SW(p, r, pte, 0, ptr);
+	unsigned int mode = (_PAGE_ACCESSED | _PAGE_MODIFIED | _PAGE_VALID
+			     | _PAGE_DIRTY);
+
+	iPTE_SW(p, r, pte, ptr, mode);
 }
 
 /*
@@ -1407,41 +1422,48 @@
 {
 	i_andi(p, pte, pte, _PAGE_WRITE);
 	il_beqz(p, r, pte, lid);
-	iPTE_LW(p, l, pte, 0, ptr);
+	iPTE_LW(p, l, pte, ptr);
 }
 
 /*
  * R3000 style TLB load/store/modify handlers.
  */
 
-/* This places the pte in the page table at PTR into ENTRYLO0. */
+/*
+ * This places the pte into ENTRYLO0 and writes it with tlbwi.
+ * Then it returns.
+ */
 static void __init
-build_r3000_pte_reload(u32 **p, unsigned int ptr)
+build_r3000_pte_reload_tlbwi(u32 **p, unsigned int pte, unsigned int tmp)
 {
-	i_lw(p, ptr, 0, ptr);
-	i_nop(p); /* load delay */
-	i_mtc0(p, ptr, C0_ENTRYLO0);
-	i_nop(p); /* cp0 delay */
+	i_mtc0(p, pte, C0_ENTRYLO0); /* cp0 delay */
+	i_mfc0(p, tmp, C0_EPC); /* cp0 delay */
+	i_tlbwi(p);
+	i_jr(p, tmp);
+	i_rfe(p); /* branch delay */
 }
 
 /*
- * The index register may have the probe fail bit set,
- * because we would trap on access kseg2, i.e. without refill.
+ * This places the pte into ENTRYLO0 and writes it with tlbwi
+ * or tlbwr as appropriate.  This is because the index register
+ * may have the probe fail bit set as a result of a trap on a
+ * kseg2 access, i.e. without refill.  Then it returns.
  */
 static void __init
-build_r3000_tlb_write(u32 **p, struct label **l, struct reloc **r,
-		      unsigned int tmp)
+build_r3000_tlb_reload_write(u32 **p, struct label **l, struct reloc **r,
+			     unsigned int pte, unsigned int tmp)
 {
 	i_mfc0(p, tmp, C0_INDEX);
-	i_nop(p); /* cp0 delay */
-	il_bltz(p, r, tmp, label_r3000_write_probe_fail);
-	i_nop(p); /* branch delay */
-	i_tlbwi(p);
-	il_b(p, r, label_r3000_write_probe_ok);
-	i_nop(p); /* branch delay */
+	i_mtc0(p, pte, C0_ENTRYLO0); /* cp0 delay */
+	il_bltz(p, r, tmp, label_r3000_write_probe_fail); /* cp0 delay */
+	i_mfc0(p, tmp, C0_EPC); /* branch delay */
+	i_tlbwi(p); /* cp0 delay */
+	i_jr(p, tmp);
+	i_rfe(p); /* branch delay */
 	l_r3000_write_probe_fail(l, *p);
-	i_tlbwr(p);
-	l_r3000_write_probe_ok(l, *p);
+	i_tlbwr(p); /* cp0 delay */
+	i_jr(p, tmp);
+	i_rfe(p); /* branch delay */
 }
 
 static void __init
@@ -1461,17 +1483,7 @@
 	i_andi(p, pte, pte, 0xffc); /* load delay */
 	i_addu(p, ptr, ptr, pte);
 	i_lw(p, pte, 0, ptr);
-	i_nop(p); /* load delay */
-	i_tlbp(p);
-}
-
-static void __init
-build_r3000_tlbchange_handler_tail(u32 **p, unsigned int tmp)
-{
-	i_mfc0(p, tmp, C0_EPC);
-	i_nop(p); /* cp0 delay */
-	i_jr(p, tmp);
-	i_rfe(p); /* branch delay */
+	i_tlbp(p); /* load delay */
 }
 
 static void __init build_r3000_tlb_load_handler(void)
@@ -1486,10 +1498,9 @@
 
 	build_r3000_tlbchange_handler_head(&p, K0, K1);
 	build_pte_present(&p, &l, &r, K0, K1, label_nopage_tlbl);
+	i_nop(&p); /* load delay */
 	build_make_valid(&p, &r, K0, K1);
-	build_r3000_pte_reload(&p, K1);
-	build_r3000_tlb_write(&p, &l, &r, K0);
-	build_r3000_tlbchange_handler_tail(&p, K0);
+	build_r3000_tlb_reload_write(&p, &l, &r, K0, K1);
 
 	l_nopage_tlbl(&l, p);
 	i_j(&p, (unsigned long)tlb_do_page_fault_0 & 0x0fffffff);
@@ -1506,13 +1517,10 @@
 	{
 		int i;
 
-		for (i = 0; i < FASTPATH_SIZE; i++)
+		for (i = 0; i < (p - handle_tlbl); i++)
 			printk("%08x\n", handle_tlbl[i]);
 	}
 #endif
-
-	flush_icache_range((unsigned long)handle_tlbl,
-			   (unsigned long)handle_tlbl + FASTPATH_SIZE * sizeof(u32));
 }
 
 static void __init build_r3000_tlb_store_handler(void)
@@ -1527,10 +1535,9 @@
 
 	build_r3000_tlbchange_handler_head(&p, K0, K1);
 	build_pte_writable(&p, &l, &r, K0, K1, label_nopage_tlbs);
+	i_nop(&p); /* load delay */
 	build_make_write(&p, &r, K0, K1);
-	build_r3000_pte_reload(&p, K1);
-	build_r3000_tlb_write(&p, &l, &r, K0);
-	build_r3000_tlbchange_handler_tail(&p, K0);
+	build_r3000_tlb_reload_write(&p, &l, &r, K0, K1);
 
 	l_nopage_tlbs(&l, p);
 	i_j(&p, (unsigned long)tlb_do_page_fault_1 & 0x0fffffff);
@@ -1547,13 +1554,10 @@
 	{
 		int i;
 
-		for (i = 0; i < FASTPATH_SIZE; i++)
+		for (i = 0; i < (p - handle_tlbs); i++)
 			printk("%08x\n", handle_tlbs[i]);
 	}
 #endif
-
-	flush_icache_range((unsigned long)handle_tlbs,
-			   (unsigned long)handle_tlbs + FASTPATH_SIZE * sizeof(u32));
 }
 
 static void __init build_r3000_tlb_modify_handler(void)
@@ -1568,10 +1572,9 @@
 
 	build_r3000_tlbchange_handler_head(&p, K0, K1);
 	build_pte_modifiable(&p, &l, &r, K0, K1, label_nopage_tlbm);
+	i_nop(&p); /* load delay */
 	build_make_write(&p, &r, K0, K1);
-	build_r3000_pte_reload(&p, K1);
-	i_tlbwi(&p);
-	build_r3000_tlbchange_handler_tail(&p, K0);
+	build_r3000_pte_reload_tlbwi(&p, K0, K1);
 
 	l_nopage_tlbm(&l, p);
 	i_j(&p, (unsigned long)tlb_do_page_fault_1 & 0x0fffffff);
@@ -1588,13 +1591,10 @@
 	{
 		int i;
 
-		for (i = 0; i < FASTPATH_SIZE; i++)
+		for (i = 0; i < (p - handle_tlbm); i++)
 			printk("%08x\n", handle_tlbm[i]);
 	}
 #endif
-
-	flush_icache_range((unsigned long)handle_tlbm,
-			   (unsigned long)handle_tlbm + FASTPATH_SIZE * sizeof(u32));
 }
 
 /*
@@ -1620,7 +1620,7 @@
 #ifdef CONFIG_SMP
 	l_smp_pgtable_change(l, *p);
 # endif
-	iPTE_LW(p, l, pte, 0, ptr); /* get even pte */
+	iPTE_LW(p, l, pte, ptr); /* get even pte */
 	build_tlb_probe_entry(p);
 }
 
@@ -1680,13 +1680,10 @@
 	{
 		int i;
 
-		for (i = 0; i < FASTPATH_SIZE; i++)
+		for (i = 0; i < (p - handle_tlbl); i++)
 			printk("%08x\n", handle_tlbl[i]);
 	}
 #endif
-
-	flush_icache_range((unsigned long)handle_tlbl,
-			   (unsigned long)handle_tlbl + FASTPATH_SIZE * sizeof(u32));
 }
 
 static void __init build_r4000_tlb_store_handler(void)
@@ -1719,13 +1716,10 @@
 	{
 		int i;
 
-		for (i = 0; i < FASTPATH_SIZE; i++)
+		for (i = 0; i < (p - handle_tlbs); i++)
 			printk("%08x\n", handle_tlbs[i]);
 	}
 #endif
-
-	flush_icache_range((unsigned long)handle_tlbs,
-			   (unsigned long)handle_tlbs + FASTPATH_SIZE * sizeof(u32));
 }
 
 static void __init build_r4000_tlb_modify_handler(void)
@@ -1759,13 +1753,10 @@
 	{
 		int i;
 
-		for (i = 0; i < FASTPATH_SIZE; i++)
+		for (i = 0; i < (p - handle_tlbm); i++)
 			printk("%08x\n", handle_tlbm[i]);
 	}
 #endif
-
-	flush_icache_range((unsigned long)handle_tlbm,
-			   (unsigned long)handle_tlbm + FASTPATH_SIZE * sizeof(u32));
 }
 
 void __init build_tlb_refill_handler(void)
@@ -1813,3 +1804,13 @@
 		}
 	}
 }
+
+void __init flush_tlb_handlers(void)
+{
+	flush_icache_range((unsigned long)handle_tlbl,
+			   (unsigned long)handle_tlbl + sizeof(handle_tlbl));
+	flush_icache_range((unsigned long)handle_tlbs,
+			   (unsigned long)handle_tlbs + sizeof(handle_tlbs));
+	flush_icache_range((unsigned long)handle_tlbm,
+			   (unsigned long)handle_tlbm + sizeof(handle_tlbm));
+}
diff -Naur linux-2.6.14/arch/mips/mm/tlb-r4k.c linux-mips-2.6.14.orig/arch/mips/mm/tlb-r4k.c
--- linux-2.6.14/arch/mips/mm/tlb-r4k.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/tlb-r4k.c	2005-11-17 11:42:26.000000000 -0800
@@ -21,6 +21,12 @@
 
 extern void build_tlb_refill_handler(void);
 
+/*
+ * Make sure all entries differ.  If they're not different
+ * MIPS32 will take revenge ...
+ */
+#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+
 /* CP0 hazard avoidance. */
 #define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
 				     "nop; nop; nop; nop; nop; nop;\n\t" \
@@ -42,11 +48,8 @@
 
 	/* Blast 'em all away. */
 	while (entry < current_cpu_data.tlbsize) {
-		/*
-		 * Make sure all entries differ.  If they're not different
-		 * MIPS32 will take revenge ...
-		 */
-		write_c0_entryhi(CKSEG0 + (entry << (PAGE_SHIFT + 1)));
+		/* Make sure all entries differ. */
+		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
 		write_c0_index(entry);
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
@@ -57,12 +60,21 @@
 	local_irq_restore(flags);
 }
 
+/* All entries common to a mm share an asid.  To effectively flush
+   these entries, we just bump the asid. */
 void local_flush_tlb_mm(struct mm_struct *mm)
 {
-	int cpu = smp_processor_id();
+	int cpu;
+
+	preempt_disable();
 
-	if (cpu_context(cpu, mm) != 0)
-		drop_mmu_context(mm,cpu);
+	cpu = smp_processor_id();
+
+	if (cpu_context(cpu, mm) != 0) {
+		drop_mmu_context(mm, cpu);
+	}
+
+	preempt_enable();
 }
 
 void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
@@ -75,9 +87,9 @@
 		unsigned long flags;
 		int size;
 
-		local_irq_save(flags);
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
+		local_irq_save(flags);
 		if (size <= current_cpu_data.tlbsize/2) {
 			int oldpid = read_c0_entryhi();
 			int newpid = cpu_asid(cpu, mm);
@@ -99,8 +111,7 @@
 				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
-				write_c0_entryhi(CKSEG0 +
-				                 (idx << (PAGE_SHIFT + 1)));
+				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 				mtc0_tlbw_hazard();
 				tlb_write_indexed();
 			}
@@ -118,9 +129,9 @@
 	unsigned long flags;
 	int size;
 
-	local_irq_save(flags);
 	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	size = (size + 1) >> 1;
+	local_irq_save(flags);
 	if (size <= current_cpu_data.tlbsize / 2) {
 		int pid = read_c0_entryhi();
 
@@ -142,7 +153,7 @@
 			if (idx < 0)
 				continue;
 			/* Make sure all entries differ. */
-			write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 		}
@@ -176,7 +187,7 @@
 		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
-		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -197,8 +208,8 @@
 	int oldpid, idx;
 
 	local_irq_save(flags);
-	page &= (PAGE_MASK << 1);
 	oldpid = read_c0_entryhi();
+	page &= (PAGE_MASK << 1);
 	write_c0_entryhi(page);
 	mtc0_tlbw_hazard();
 	tlb_probe();
@@ -208,7 +219,7 @@
 	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
-		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -227,6 +238,7 @@
 {
 	unsigned long flags;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 	int idx, pid;
@@ -237,35 +249,34 @@
 	if (current->active_mm != vma->vm_mm)
 		return;
 
-	pid = read_c0_entryhi() & ASID_MASK;
-
 	local_irq_save(flags);
+
+	pid = read_c0_entryhi() & ASID_MASK;
 	address &= (PAGE_MASK << 1);
 	write_c0_entryhi(address | pid);
 	pgdp = pgd_offset(vma->vm_mm, address);
 	mtc0_tlbw_hazard();
 	tlb_probe();
 	BARRIER;
-	pmdp = pmd_offset(pgdp, address);
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
 	idx = read_c0_index();
 	ptep = pte_offset_map(pmdp, address);
 
- #if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
- 	write_c0_entrylo0(ptep->pte_high);
- 	ptep++;
- 	write_c0_entrylo1(ptep->pte_high);
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
+	write_c0_entrylo0(ptep->pte_high);
+	ptep++;
+	write_c0_entrylo1(ptep->pte_high);
 #else
-  	write_c0_entrylo0(pte_val(*ptep++) >> 6);
-  	write_c0_entrylo1(pte_val(*ptep) >> 6);
+	write_c0_entrylo0(pte_val(*ptep++) >> 6);
+	write_c0_entrylo1(pte_val(*ptep) >> 6);
 #endif
-	write_c0_entryhi(address | pid);
 	mtc0_tlbw_hazard();
 	if (idx < 0)
 		tlb_write_random();
 	else
 		tlb_write_indexed();
 	tlbw_use_hazard();
-	write_c0_entryhi(pid);
 	local_irq_restore(flags);
 }
 
@@ -357,7 +368,8 @@
 	old_pagemask = read_c0_pagemask();
 	wired = read_c0_wired();
 	if (--temp_tlb_entry < wired) {
-		printk(KERN_WARNING "No TLB space left for add_temporary_entry\n");
+		printk(KERN_WARNING
+		       "No TLB space left for add_temporary_entry\n");
 		ret = -ENOSPC;
 		goto out;
 	}
@@ -388,7 +400,7 @@
 	 * is not supported, we assume R4k style.  Cpu probing already figured
 	 * out the number of tlb entries.
 	 */
-	if ((c->processor_id  & 0xff0000) == PRID_COMP_LEGACY)
+	if ((c->processor_id & 0xff0000) == PRID_COMP_LEGACY)
 		return;
 
 	reg = read_c0_config1();
diff -Naur linux-2.6.14/arch/mips/mm/tlb-sb1.c linux-mips-2.6.14.orig/arch/mips/mm/tlb-sb1.c
--- linux-2.6.14/arch/mips/mm/tlb-sb1.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/mm/tlb-sb1.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,376 +0,0 @@
-/*
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
- * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-#include <linux/init.h>
-#include <asm/mmu_context.h>
-#include <asm/bootinfo.h>
-#include <asm/cpu.h>
-
-extern void build_tlb_refill_handler(void);
-
-#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
-
-/* Dump the current entry* and pagemask registers */
-static inline void dump_cur_tlb_regs(void)
-{
-	unsigned int entryhihi, entryhilo, entrylo0hi, entrylo0lo, entrylo1hi;
-	unsigned int entrylo1lo, pagemask;
-
-	__asm__ __volatile__ (
-		".set push             \n"
-		".set noreorder        \n"
-		".set mips64           \n"
-		".set noat             \n"
-		"     tlbr             \n"
-		"     dmfc0  $1, $10   \n"
-		"     dsrl32 %0, $1, 0 \n"
-		"     sll    %1, $1, 0 \n"
-		"     dmfc0  $1, $2    \n"
-		"     dsrl32 %2, $1, 0 \n"
-		"     sll    %3, $1, 0 \n"
-		"     dmfc0  $1, $3    \n"
-		"     dsrl32 %4, $1, 0 \n"
-		"     sll    %5, $1, 0 \n"
-		"     mfc0   %6, $5    \n"
-		".set pop              \n"
-		: "=r" (entryhihi), "=r" (entryhilo),
-		  "=r" (entrylo0hi), "=r" (entrylo0lo),
-		  "=r" (entrylo1hi), "=r" (entrylo1lo),
-		  "=r" (pagemask));
-
-	printk("%08X%08X %08X%08X %08X%08X %08X",
-	       entryhihi, entryhilo,
-	       entrylo0hi, entrylo0lo,
-	       entrylo1hi, entrylo1lo,
-	       pagemask);
-}
-
-void sb1_dump_tlb(void)
-{
-	unsigned long old_ctx;
-	unsigned long flags;
-	int entry;
-	local_irq_save(flags);
-	old_ctx = read_c0_entryhi();
-	printk("Current TLB registers state:\n"
-	       "      EntryHi       EntryLo0          EntryLo1     PageMask  Index\n"
-	       "--------------------------------------------------------------------\n");
-	dump_cur_tlb_regs();
-	printk(" %08X\n", read_c0_index());
-	printk("\n\nFull TLB Dump:\n"
-	       "Idx      EntryHi       EntryLo0          EntryLo1     PageMask\n"
-	       "--------------------------------------------------------------\n");
-	for (entry = 0; entry < current_cpu_data.tlbsize; entry++) {
-		write_c0_index(entry);
-		printk("\n%02i ", entry);
-		dump_cur_tlb_regs();
-	}
-	printk("\n");
-	write_c0_entryhi(old_ctx);
-	local_irq_restore(flags);
-}
-
-void local_flush_tlb_all(void)
-{
-	unsigned long flags;
-	unsigned long old_ctx;
-	int entry;
-
-	local_irq_save(flags);
-	/* Save old context and create impossible VPN2 value */
-	old_ctx = read_c0_entryhi() & ASID_MASK;
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-
-	entry = read_c0_wired();
-	while (entry < current_cpu_data.tlbsize) {
-		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
-		write_c0_index(entry);
-		tlb_write_indexed();
-		entry++;
-	}
-	write_c0_entryhi(old_ctx);
-	local_irq_restore(flags);
-}
-
-
-/*
- * Use a bogus region of memory (starting at 0) to sanitize the TLB's.
- * Use increments of the maximum page size (16MB), and check for duplicate
- * entries before doing a given write.  Then, when we're safe from collisions
- * with the firmware, go back and give all the entries invalid addresses with
- * the normal flush routine.  Wired entries will be killed as well!
- */
-static void __init sb1_sanitize_tlb(void)
-{
-	int entry;
-	long addr = 0;
-
-	long inc = 1<<24;  /* 16MB */
-	/* Save old context and create impossible VPN2 value */
-	write_c0_entrylo0(0);
-	write_c0_entrylo1(0);
-	for (entry = 0; entry < current_cpu_data.tlbsize; entry++) {
-		do {
-			addr += inc;
-			write_c0_entryhi(addr);
-			tlb_probe();
-		} while ((int)(read_c0_index()) >= 0);
-		write_c0_index(entry);
-		tlb_write_indexed();
-	}
-	/* Now that we know we're safe from collisions, we can safely flush
-	   the TLB with the "normal" routine. */
-	local_flush_tlb_all();
-}
-
-void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
-	unsigned long end)
-{
-	struct mm_struct *mm = vma->vm_mm;
-	unsigned long flags;
-	int cpu;
-
-	local_irq_save(flags);
-	cpu = smp_processor_id();
-	if (cpu_context(cpu, mm) != 0) {
-		int size;
-		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-		size = (size + 1) >> 1;
-		if (size <= (current_cpu_data.tlbsize/2)) {
-			int oldpid = read_c0_entryhi() & ASID_MASK;
-			int newpid = cpu_asid(cpu, mm);
-
-			start &= (PAGE_MASK << 1);
-			end += ((PAGE_SIZE << 1) - 1);
-			end &= (PAGE_MASK << 1);
-			while (start < end) {
-				int idx;
-
-				write_c0_entryhi(start | newpid);
-				start += (PAGE_SIZE << 1);
-				tlb_probe();
-				idx = read_c0_index();
-				write_c0_entrylo0(0);
-				write_c0_entrylo1(0);
-				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-				if (idx < 0)
-					continue;
-				tlb_write_indexed();
-			}
-			write_c0_entryhi(oldpid);
-		} else {
-			drop_mmu_context(mm, cpu);
-		}
-	}
-	local_irq_restore(flags);
-}
-
-void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	unsigned long flags;
-	int size;
-
-	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-	size = (size + 1) >> 1;
-
-	local_irq_save(flags);
-	if (size <= (current_cpu_data.tlbsize/2)) {
-		int pid = read_c0_entryhi();
-
-		start &= (PAGE_MASK << 1);
-		end += ((PAGE_SIZE << 1) - 1);
-		end &= (PAGE_MASK << 1);
-
-		while (start < end) {
-			int idx;
-
-			write_c0_entryhi(start);
-			start += (PAGE_SIZE << 1);
-			tlb_probe();
-			idx = read_c0_index();
-			write_c0_entrylo0(0);
-			write_c0_entrylo1(0);
-			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-			if (idx < 0)
-				continue;
-			tlb_write_indexed();
-		}
-		write_c0_entryhi(pid);
-	} else {
-		local_flush_tlb_all();
-	}
-	local_irq_restore(flags);
-}
-
-void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
-{
-	unsigned long flags;
-	int cpu = smp_processor_id();
-
-	local_irq_save(flags);
-	if (cpu_context(cpu, vma->vm_mm) != 0) {
-		int oldpid, newpid, idx;
-		newpid = cpu_asid(cpu, vma->vm_mm);
-		page &= (PAGE_MASK << 1);
-		oldpid = read_c0_entryhi() & ASID_MASK;
-		write_c0_entryhi(page | newpid);
-		tlb_probe();
-		idx = read_c0_index();
-		write_c0_entrylo0(0);
-		write_c0_entrylo1(0);
-		if (idx < 0)
-			goto finish;
-		/* Make sure all entries differ. */
-		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-		tlb_write_indexed();
-	finish:
-		write_c0_entryhi(oldpid);
-	}
-	local_irq_restore(flags);
-}
-
-/*
- * Remove one kernel space TLB entry.  This entry is assumed to be marked
- * global so we don't do the ASID thing.
- */
-void local_flush_tlb_one(unsigned long page)
-{
-	unsigned long flags;
-	int oldpid, idx;
-
-	page &= (PAGE_MASK << 1);
-	oldpid = read_c0_entryhi() & ASID_MASK;
-
-	local_irq_save(flags);
-	write_c0_entryhi(page);
-	tlb_probe();
-	idx = read_c0_index();
-	if (idx >= 0) {
-		/* Make sure all entries differ. */
-		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-		write_c0_entrylo0(0);
-		write_c0_entrylo1(0);
-		tlb_write_indexed();
-	}
-
-	write_c0_entryhi(oldpid);
-	local_irq_restore(flags);
-}
-
-/* All entries common to a mm share an asid.  To effectively flush
-   these entries, we just bump the asid. */
-void local_flush_tlb_mm(struct mm_struct *mm)
-{
-	int cpu;
-
-	preempt_disable();
-
-	cpu = smp_processor_id();
-
-	if (cpu_context(cpu, mm) != 0) {
-		drop_mmu_context(mm, cpu);
-	}
-
-	preempt_enable();
-}
-
-/* Stolen from mips32 routines */
-
-void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
-{
-	unsigned long flags;
-	pgd_t *pgdp;
-	pmd_t *pmdp;
-	pte_t *ptep;
-	int idx, pid;
-
-	/*
-	 * Handle debugger faulting in for debugee.
-	 */
-	if (current->active_mm != vma->vm_mm)
-		return;
-
-	local_irq_save(flags);
-
-	pid = read_c0_entryhi() & ASID_MASK;
-	address &= (PAGE_MASK << 1);
-	write_c0_entryhi(address | (pid));
-	pgdp = pgd_offset(vma->vm_mm, address);
-	tlb_probe();
-	pmdp = pmd_offset(pgdp, address);
-	idx = read_c0_index();
-	ptep = pte_offset_map(pmdp, address);
-	write_c0_entrylo0(pte_val(*ptep++) >> 6);
-	write_c0_entrylo1(pte_val(*ptep) >> 6);
-	if (idx < 0) {
-		tlb_write_random();
-	} else {
-		tlb_write_indexed();
-	}
-	local_irq_restore(flags);
-}
-
-void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
-	unsigned long entryhi, unsigned long pagemask)
-{
-	unsigned long flags;
-	unsigned long wired;
-	unsigned long old_pagemask;
-	unsigned long old_ctx;
-
-	local_irq_save(flags);
-	old_ctx = read_c0_entryhi() & 0xff;
-	old_pagemask = read_c0_pagemask();
-	wired = read_c0_wired();
-	write_c0_wired(wired + 1);
-	write_c0_index(wired);
-
-	write_c0_pagemask(pagemask);
-	write_c0_entryhi(entryhi);
-	write_c0_entrylo0(entrylo0);
-	write_c0_entrylo1(entrylo1);
-	tlb_write_indexed();
-
-	write_c0_entryhi(old_ctx);
-	write_c0_pagemask(old_pagemask);
-
-	local_flush_tlb_all();
-	local_irq_restore(flags);
-}
-
-/*
- * This is called from loadmmu.c.  We have to set up all the
- * memory management function pointers, as well as initialize
- * the caches and tlbs
- */
-void tlb_init(void)
-{
-	write_c0_pagemask(PM_DEFAULT_MASK);
-	write_c0_wired(0);
-
-	/*
-	 * We don't know what state the firmware left the TLB's in, so this is
-	 * the ultra-conservative way to flush the TLB's and avoid machine
-	 * check exceptions due to duplicate TLB entries
-	 */
-	sb1_sanitize_tlb();
-
-	build_tlb_refill_handler();
-}
diff -Naur linux-2.6.14/arch/mips/momentum/jaguar_atx/prom.c linux-mips-2.6.14.orig/arch/mips/momentum/jaguar_atx/prom.c
--- linux-2.6.14/arch/mips/momentum/jaguar_atx/prom.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/jaguar_atx/prom.c	2005-11-17 11:42:27.000000000 -0800
@@ -236,8 +236,9 @@
 #endif
 }
 
-void __init prom_free_prom_memory(void)
+unsigned long __init prom_free_prom_memory(void)
 {
+	return 0;
 }
 
 void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
diff -Naur linux-2.6.14/arch/mips/momentum/jaguar_atx/setup.c linux-mips-2.6.14.orig/arch/mips/momentum/jaguar_atx/setup.c
--- linux-2.6.14/arch/mips/momentum/jaguar_atx/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/jaguar_atx/setup.c	2005-11-17 11:42:27.000000000 -0800
@@ -351,7 +351,7 @@
 
 arch_initcall(ja_pci_init);
 
-static int  __init momenco_jaguar_atx_setup(void)
+void __init plat_setup(void)
 {
 	unsigned int tmpword;
 
@@ -467,8 +467,4 @@
 
 	}
 #endif
-
-	return 0;
 }
-
-early_initcall(momenco_jaguar_atx_setup);
diff -Naur linux-2.6.14/arch/mips/momentum/Kconfig linux-mips-2.6.14.orig/arch/mips/momentum/Kconfig
--- linux-2.6.14/arch/mips/momentum/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/momentum/Kconfig	2005-11-17 11:42:27.000000000 -0800
@@ -0,0 +1,6 @@
+config JAGUAR_DMALOW
+	bool "Low DMA Mode"
+	depends on MOMENCO_JAGUAR_ATX
+	help
+	  Select to Y if jump JP5 is set on your board, N otherwise.  Normally
+	  the jumper is set, so if you feel unsafe, just say Y.
diff -Naur linux-2.6.14/arch/mips/momentum/ocelot_3/prom.c linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_3/prom.c
--- linux-2.6.14/arch/mips/momentum/ocelot_3/prom.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_3/prom.c	2005-11-17 11:42:27.000000000 -0800
@@ -239,8 +239,9 @@
 #endif
 }
 
-void __init prom_free_prom_memory(void)
+unsigned long __init prom_free_prom_memory(void)
 {
+	return 0;
 }
 
 void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
diff -Naur linux-2.6.14/arch/mips/momentum/ocelot_3/setup.c linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_3/setup.c
--- linux-2.6.14/arch/mips/momentum/ocelot_3/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_3/setup.c	2005-11-17 11:42:27.000000000 -0800
@@ -307,7 +307,7 @@
 
 arch_initcall(ja_pci_init);
 
-static int __init momenco_ocelot_3_setup(void)
+void __init plat_setup(void)
 {
 	unsigned int tmpword;
 
@@ -391,8 +391,4 @@
 
 	/* Support for 128 MB memory */
 	add_memory_region(0x0, 0x08000000, BOOT_MEM_RAM);
-
-	return 0;
 }
-
-early_initcall(momenco_ocelot_3_setup);
diff -Naur linux-2.6.14/arch/mips/momentum/ocelot_c/cpci-irq.c linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_c/cpci-irq.c
--- linux-2.6.14/arch/mips/momentum/ocelot_c/cpci-irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_c/cpci-irq.c	2005-11-17 11:42:27.000000000 -0800
@@ -129,14 +129,13 @@
 #define shutdown_cpci_irq	disable_cpci_irq
 
 struct hw_interrupt_type cpci_irq_type = {
-	"CPCI/FPGA",
-	startup_cpci_irq,
-	shutdown_cpci_irq,
-	enable_cpci_irq,
-	disable_cpci_irq,
-	mask_and_ack_cpci_irq,
-	end_cpci_irq,
-	NULL
+	.typename = "CPCI/FPGA",
+	.startup = startup_cpci_irq,
+	.shutdown = shutdown_cpci_irq,
+	.enable = enable_cpci_irq,
+	.disable = disable_cpci_irq,
+	.ack = mask_and_ack_cpci_irq,
+	.end = end_cpci_irq,
 };
 
 void cpci_irq_init(void)
diff -Naur linux-2.6.14/arch/mips/momentum/ocelot_c/setup.c linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_c/setup.c
--- linux-2.6.14/arch/mips/momentum/ocelot_c/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_c/setup.c	2005-11-17 11:42:27.000000000 -0800
@@ -222,7 +222,7 @@
 	rtc_set_time = m48t37y_set_time;
 }
 
-static void __init momenco_ocelot_c_setup(void)
+void __init plat_setup(void)
 {
 	unsigned int tmpword;
 
@@ -340,8 +340,6 @@
 	}
 }
 
-early_initcall(momenco_ocelot_c_setup);
-
 #ifndef CONFIG_64BIT
 /* This needs to be one of the first initcalls, because no I/O port access
    can work before this */
diff -Naur linux-2.6.14/arch/mips/momentum/ocelot_c/uart-irq.c linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_c/uart-irq.c
--- linux-2.6.14/arch/mips/momentum/ocelot_c/uart-irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_c/uart-irq.c	2005-11-17 11:42:27.000000000 -0800
@@ -122,14 +122,13 @@
 #define shutdown_uart_irq	disable_uart_irq
 
 struct hw_interrupt_type uart_irq_type = {
-	"UART/FPGA",
-	startup_uart_irq,
-	shutdown_uart_irq,
-	enable_uart_irq,
-	disable_uart_irq,
-	mask_and_ack_uart_irq,
-	end_uart_irq,
-	NULL
+	.typename = "UART/FPGA",
+	.startup = startup_uart_irq,
+	.shutdown = shutdown_uart_irq,
+	.enable = enable_uart_irq,
+	.disable = disable_uart_irq,
+	.ack = mask_and_ack_uart_irq,
+	.end = end_uart_irq,
 };
 
 void uart_irq_init(void)
diff -Naur linux-2.6.14/arch/mips/momentum/ocelot_g/setup.c linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_g/setup.c
--- linux-2.6.14/arch/mips/momentum/ocelot_g/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/momentum/ocelot_g/setup.c	2005-11-17 11:42:27.000000000 -0800
@@ -160,7 +160,7 @@
 	printk("Done\n");
 }
 
-static int  __init momenco_ocelot_g_setup(void)
+void __init plat_setup(void)
 {
 	void (*l3func)(unsigned long) = (void *) KSEG1ADDR(setup_l3cache);
 	unsigned int tmpword;
@@ -240,12 +240,8 @@
 
 	/* FIXME: Fix up the DiskOnChip mapping */
 	MV_WRITE(0x468, 0xfef73);
-
-	return 0;
 }
 
-early_initcall(momenco_ocelot_g_setup);
-
 /* This needs to be one of the first initcalls, because no I/O port access
    can work before this */
 
diff -Naur linux-2.6.14/arch/mips/oprofile/common.c linux-mips-2.6.14.orig/arch/mips/oprofile/common.c
--- linux-2.6.14/arch/mips/oprofile/common.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/oprofile/common.c	2005-11-17 11:42:27.000000000 -0800
@@ -3,7 +3,8 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004 by Ralf Baechle
+ * Copyright (C) 2004, 2005 Ralf Baechle
+ * Copyright (C) 2005 MIPS Technologies, Inc.
  */
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -45,10 +46,10 @@
 		oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
 		oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
 		oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
-		/* Dummies.  */
 		oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
 		oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
 		oprofilefs_create_ulong(sb, dir, "exl", &ctr[i].exl);
+		/* Dummy.  */
 		oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
 	}
 
@@ -68,9 +69,10 @@
 	on_each_cpu(model->cpu_stop, NULL, 0, 1);
 }
 
-void __init oprofile_arch_init(struct oprofile_operations *ops)
+int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 	struct op_mips_model *lmodel = NULL;
+	int res;
 
 	switch (current_cpu_data.cputype) {
 	case CPU_24K:
@@ -83,21 +85,25 @@
 	};
 
 	if (!lmodel)
-		return;
+		return -ENODEV;
 
-	if (lmodel->init())
-		return;
+	res = lmodel->init();
+	if (res)
+		return res;
 
 	model = lmodel;
 
-	ops->create_files = op_mips_create_files;
-	ops->setup = op_mips_setup;
-	ops->start = op_mips_start;
-	ops->stop = op_mips_stop;
-	ops->cpu_type = lmodel->cpu_type;
+	ops->create_files	= op_mips_create_files;
+	ops->setup		= op_mips_setup;
+	//ops->shutdown         = op_mips_shutdown;
+	ops->start		= op_mips_start;
+	ops->stop		= op_mips_stop;
+	ops->cpu_type		= lmodel->cpu_type;
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       lmodel->cpu_type);
+
+	return 0;
 }
 
 void oprofile_arch_exit(void)
diff -Naur linux-2.6.14/arch/mips/oprofile/Kconfig linux-mips-2.6.14.orig/arch/mips/oprofile/Kconfig
--- linux-2.6.14/arch/mips/oprofile/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/oprofile/Kconfig	2005-11-17 11:42:27.000000000 -0800
@@ -11,7 +11,7 @@
 
 config OPROFILE
 	tristate "OProfile system profiling (EXPERIMENTAL)"
-	depends on PROFILING
+	depends on PROFILING && EXPERIMENTAL
 	help
 	  OProfile is a profiling system capable of profiling the
 	  whole system, include the kernel, kernel modules, libraries,
diff -Naur linux-2.6.14/arch/mips/oprofile/op_impl.h linux-mips-2.6.14.orig/arch/mips/oprofile/op_impl.h
--- linux-2.6.14/arch/mips/oprofile/op_impl.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/oprofile/op_impl.h	2005-11-17 11:42:27.000000000 -0800
@@ -10,6 +10,11 @@
 #ifndef OP_IMPL_H
 #define OP_IMPL_H 1
 
+struct pt_regs;
+
+extern void null_perf_irq(struct pt_regs *regs);
+extern void (*perf_irq)(struct pt_regs *regs);
+
 /* Per-counter configuration as set via oprofilefs.  */
 struct op_counter_config {
 	unsigned long enabled;
diff -Naur linux-2.6.14/arch/mips/oprofile/op_model_mipsxx.c linux-mips-2.6.14.orig/arch/mips/oprofile/op_model_mipsxx.c
--- linux-2.6.14/arch/mips/oprofile/op_model_mipsxx.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/oprofile/op_model_mipsxx.c	2005-11-17 11:42:27.000000000 -0800
@@ -0,0 +1,215 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005 by Ralf Baechle
+ * Copyright (C) 2005 by MIPS Technologies, Inc.
+ */
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+
+#include "op_impl.h"
+
+#define M_PERFCTL_EXL			(1UL    <<  0)
+#define M_PERFCTL_KERNEL		(1UL    <<  1)
+#define M_PERFCTL_SUPERVISOR		(1UL    <<  2)
+#define M_PERFCTL_USER			(1UL    <<  3)
+#define M_PERFCTL_INTERRUPT_ENABLE	(1UL    <<  4)
+#define M_PERFCTL_EVENT(event)		((event) << 5)
+#define M_PERFCTL_WIDE			(1UL    << 30)
+#define M_PERFCTL_MORE			(1UL    << 31)
+
+#define M_COUNTER_OVERFLOW		(1UL    << 31)
+
+struct op_mips_model op_model_mipsxx;
+
+static struct mipsxx_register_config {
+	unsigned int control[4];
+	unsigned int counter[4];
+} reg;
+
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void mipsxx_reg_setup(struct op_counter_config *ctr)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+	int i;
+
+	/* Compute the performance counter control word.  */
+	/* For now count kernel and user mode */
+	for (i = 0; i < counters; i++) {
+		reg.control[i] = 0;
+		reg.counter[i] = 0;
+
+		if (!ctr[i].enabled)
+			continue;
+
+		reg.control[i] = M_PERFCTL_EVENT(ctr[i].event) |
+		                 M_PERFCTL_INTERRUPT_ENABLE;
+		if (ctr[i].kernel)
+			reg.control[i] |= M_PERFCTL_KERNEL;
+		if (ctr[i].user)
+			reg.control[i] |= M_PERFCTL_USER;
+		if (ctr[i].exl)
+			reg.control[i] |= M_PERFCTL_EXL;
+		reg.counter[i] = 0x80000000 - ctr[i].count;
+	}
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void mipsxx_cpu_setup (void *args)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(0);
+		write_c0_perfcntr3(reg.counter[3]);
+	case 3:
+		write_c0_perfctrl2(0);
+		write_c0_perfcntr2(reg.counter[2]);
+	case 2:
+		write_c0_perfctrl1(0);
+		write_c0_perfcntr1(reg.counter[1]);
+	case 1:
+		write_c0_perfctrl0(0);
+		write_c0_perfcntr0(reg.counter[0]);
+	}
+}
+
+/* Start all counters on current CPU */
+static void mipsxx_cpu_start(void *args)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(reg.control[3]);
+	case 3:
+		write_c0_perfctrl2(reg.control[2]);
+	case 2:
+		write_c0_perfctrl1(reg.control[1]);
+	case 1:
+		write_c0_perfctrl0(reg.control[0]);
+	}
+}
+
+/* Stop all counters on current CPU */
+static void mipsxx_cpu_stop(void *args)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(0);
+	case 3:
+		write_c0_perfctrl2(0);
+	case 2:
+		write_c0_perfctrl1(0);
+	case 1:
+		write_c0_perfctrl0(0);
+	}
+}
+
+static void mipsxx_perfcount_handler(struct pt_regs *regs)
+{
+	unsigned int counters = op_model_mipsxx.num_counters;
+	unsigned int control;
+	unsigned int counter;
+
+	switch (counters) {
+#define HANDLE_COUNTER(n)						\
+	case n + 1:							\
+		control = read_c0_perfctrl ## n();			\
+		counter = read_c0_perfcntr ## n();			\
+		if ((control & M_PERFCTL_INTERRUPT_ENABLE) &&		\
+		    (counter & M_COUNTER_OVERFLOW)) {			\
+			oprofile_add_sample(regs, n);			\
+			write_c0_perfcntr ## n(reg.counter[n]);		\
+		}
+	HANDLE_COUNTER(3)
+	HANDLE_COUNTER(2)
+	HANDLE_COUNTER(1)
+	HANDLE_COUNTER(0)
+	}
+}
+
+#define M_CONFIG1_PC	(1 << 4)
+
+static inline int n_counters(void)
+{
+	if (!(read_c0_config1() & M_CONFIG1_PC))
+		return 0;
+	if (!(read_c0_perfctrl0() & M_PERFCTL_MORE))
+		return 1;
+	if (!(read_c0_perfctrl1() & M_PERFCTL_MORE))
+		return 2;
+	if (!(read_c0_perfctrl2() & M_PERFCTL_MORE))
+		return 3;
+
+	return 4;
+}
+
+static inline void reset_counters(int counters)
+{
+	switch (counters) {
+	case 4:
+		write_c0_perfctrl3(0);
+		write_c0_perfcntr3(0);
+	case 3:
+		write_c0_perfctrl2(0);
+		write_c0_perfcntr2(0);
+	case 2:
+		write_c0_perfctrl1(0);
+		write_c0_perfcntr1(0);
+	case 1:
+		write_c0_perfctrl0(0);
+		write_c0_perfcntr0(0);
+	}
+}
+
+static int __init mipsxx_init(void)
+{
+	int counters;
+
+	counters = n_counters();
+	if (counters == 0)
+		return -ENODEV;
+
+	reset_counters(counters);
+
+	op_model_mipsxx.num_counters = counters;
+	switch (current_cpu_data.cputype) {
+	case CPU_24K:
+		op_model_mipsxx.cpu_type = "mips/24K";
+		break;
+
+	default:
+		printk(KERN_ERR "Profiling unsupported for this CPU\n");
+
+		return -ENODEV;
+	}
+
+	perf_irq = mipsxx_perfcount_handler;
+
+	return 0;
+}
+
+static void mipsxx_exit(void)
+{
+	reset_counters(op_model_mipsxx.num_counters);
+
+	perf_irq = null_perf_irq;
+}
+
+struct op_mips_model op_model_mipsxx = {
+	.reg_setup	= mipsxx_reg_setup,
+	.cpu_setup	= mipsxx_cpu_setup,
+	.init		= mipsxx_init,
+	.exit		= mipsxx_exit,
+	.cpu_start	= mipsxx_cpu_start,
+	.cpu_stop	= mipsxx_cpu_stop,
+};
diff -Naur linux-2.6.14/arch/mips/oprofile/op_model_rm9000.c linux-mips-2.6.14.orig/arch/mips/oprofile/op_model_rm9000.c
--- linux-2.6.14/arch/mips/oprofile/op_model_rm9000.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/oprofile/op_model_rm9000.c	2005-11-17 11:42:27.000000000 -0800
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 2004 by Ralf Baechle
  */
+#include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
@@ -114,7 +115,7 @@
 	return IRQ_HANDLED;
 }
 
-static int rm9000_init(void)
+static int __init rm9000_init(void)
 {
 	return request_irq(rm9000_perfcount_irq, rm9000_perfcount_handler,
 	                   0, "Perfcounter", NULL);
diff -Naur linux-2.6.14/arch/mips/pci/fixup-atlas.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-atlas.c
--- linux-2.6.14/arch/mips/pci/fixup-atlas.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-atlas.c	2005-11-17 11:42:28.000000000 -0800
@@ -1,14 +1,37 @@
+/*
+ * Copyright (C) 2003, 2004  Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Author:	 Maciej W. Rozycki <macro@mips.com>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+
 #include <asm/mips-boards/atlasint.h>
 
-#define INTD		ATLASINT_INTD
-#define INTC		ATLASINT_INTC
-#define INTB		ATLASINT_INTB
+#define PCIA		ATLASINT_PCIA
+#define PCIB		ATLASINT_PCIB
+#define PCIC		ATLASINT_PCIC
+#define PCID		ATLASINT_PCID
 #define INTA		ATLASINT_INTA
-#define SCSI		ATLASINT_SCSI
+#define INTB		ATLASINT_INTB
 #define ETH		ATLASINT_ETH
+#define INTC		ATLASINT_INTC
+#define SCSI		ATLASINT_SCSI
+#define INTD		ATLASINT_INTD
 
 static char irq_tab[][5] __initdata = {
 	/*      INTA    INTB    INTC    INTD */
@@ -27,13 +50,13 @@
 	{0,	0,	0,	0,	0 },	/* 12: Unused */
 	{0,	0,	0,	0,	0 },	/* 13: Unused */
 	{0,	0,	0,	0,	0 },	/* 14: Unused */
-	{0,	0,	0,	0,	0 },	/* 15: Unused */
+	{0,	PCIA,	PCIB,	PCIC,	PCID },	/* 15: cPCI (behind 21150) */
 	{0,	SCSI,	0,	0,	0 },	/* 16: SYM53C810A SCSI */
 	{0,	0,	0,	0,	0 },	/* 17: Core */
-	{0,	INTA,	INTB,	INTC,	INTD },	/* 18: PCI Slot 1 */
-	{0,	ETH,	0,	0,	0 },	/* 19: SAA9730 Ethernet */
-	{0,	0,	0,	0,	0 },	/* 20: PCI Slot 3 */
-	{0,	0,	0,	0,	0 }	/* 21: PCI Slot 4 */
+	{0,	INTA,	INTB,	INTC,	INTD },	/* 18: PCI Slot */
+	{0,	ETH,	0,	0,	0 },	/* 19: SAA9730 Eth. et al. */
+	{0,	0,	0,	0,	0 },	/* 20: Unused */
+	{0,	0,	0,	0,	0 }	/* 21: Unused */
 };
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
diff -Naur linux-2.6.14/arch/mips/pci/fixup-au1000.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-au1000.c
--- linux-2.6.14/arch/mips/pci/fixup-au1000.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-au1000.c	2005-11-17 11:42:28.000000000 -0800
@@ -26,7 +26,6 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -34,82 +33,7 @@
 
 #include <asm/mach-au1x00/au1000.h>
 
-/*
- * Shortcut
- */
-#ifdef CONFIG_SOC_AU1500
-#define INTA AU1000_PCI_INTA
-#define INTB AU1000_PCI_INTB
-#define INTC AU1000_PCI_INTC
-#define INTD AU1000_PCI_INTD
-#endif
-
-#ifdef CONFIG_SOC_AU1550
-#define INTA AU1550_PCI_INTA
-#define INTB AU1550_PCI_INTB
-#define INTC AU1550_PCI_INTC
-#define INTD AU1550_PCI_INTD
-#endif
-
-#define INTX    0xFF /* not valid */
-
-#ifdef CONFIG_MIPS_DB1500
-static char irq_tab_alchemy[][5] __initdata = {
- [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT371   */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
-};
-#endif
-
-#ifdef CONFIG_MIPS_BOSPORUS
-static char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 11 - miniPCI  */
- [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - SN1741   */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
-};
-#endif
-
-#ifdef CONFIG_MIPS_MIRAGE
-static char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTD, INTX, INTX, INTX},   /* IDSEL 11 - SMI VGX */
- [12] =	{ -1, INTX, INTX, INTC, INTX},   /* IDSEL 12 - PNX1300 */
- [13] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 13 - miniPCI */
-};
-#endif
-
-#ifdef CONFIG_MIPS_DB1550
-static char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTC, INTX, INTX, INTX},   /* IDSEL 11 - on-board HPT371    */
- [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
-};
-#endif
-
-#ifdef CONFIG_MIPS_PB1500
-static char irq_tab_alchemy[][5] __initdata = {
- [12] = { -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT370   */
- [13] = { -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
-};
-#endif
-
-#ifdef CONFIG_MIPS_PB1550
-static char irq_tab_alchemy[][5] __initdata = {
- [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
-};
-#endif
-
-#ifdef CONFIG_MIPS_MTX1
-static char irq_tab_alchemy[][5] __initdata = {
- [0] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 00 - AdapterA-Slot0 (top)    */
- [1] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 01 - AdapterA-Slot1 (bottom) */
- [2] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 02 - AdapterB-Slot0 (top)    */
- [3] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 03 - AdapterB-Slot1 (bottom) */
- [4] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 04 - AdapterC-Slot0 (top)    */
- [5] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 05 - AdapterC-Slot1 (bottom) */
- [6] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 06 - AdapterD-Slot0 (top)    */
- [7] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 07 - AdapterD-Slot1 (bottom) */
-};
-#endif
+extern char irq_tab_alchemy[][5];
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
diff -Naur linux-2.6.14/arch/mips/pci/fixup-cobalt.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-cobalt.c
--- linux-2.6.14/arch/mips/pci/fixup-cobalt.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-cobalt.c	2005-11-17 11:42:28.000000000 -0800
@@ -21,6 +21,20 @@
 
 extern int cobalt_board_id;
 
+static void qube_raq_galileo_early_fixup(struct pci_dev *dev)
+{
+	if (dev->devfn == PCI_DEVFN(0, 0) &&
+		(dev->class >> 8) == PCI_CLASS_MEMORY_OTHER) {
+
+		dev->class = (PCI_CLASS_BRIDGE_HOST << 8) | (dev->class & 0xff);
+
+		printk(KERN_INFO "Galileo: fixed bridge class\n");
+	}
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_GT64111,
+	 qube_raq_galileo_early_fixup);
+
 static void qube_raq_via_bmIDE_fixup(struct pci_dev *dev)
 {
 	unsigned short cfgword;
@@ -48,6 +62,9 @@
 {
 	unsigned short galileo_id;
 
+	if (dev->devfn != PCI_DEVFN(0, 0))
+		return;
+
 	/* Fix PCI latency-timer and cache-line-size values in Galileo
 	 * host bridge.
 	 */
@@ -55,6 +72,13 @@
 	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 7);
 
 	/*
+	 * The code described by the comment below has been removed
+	 * as it causes bus mastering by the Ethernet controllers
+	 * to break under any kind of network load. We always set
+	 * the retry timeouts to their maximum.
+	 *
+	 * --x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--
+	 *
 	 * On all machines prior to Q2, we had the STOP line disconnected
 	 * from Galileo to VIA on PCI.  The new Galileo does not function
 	 * correctly unless we have it connected.
@@ -64,21 +88,43 @@
 	 */
 	pci_read_config_word(dev, PCI_REVISION_ID, &galileo_id);
 	galileo_id &= 0xff;	/* mask off class info */
+
+ 	printk(KERN_INFO "Galileo: revision %u\n", galileo_id);
+
+#if 0
 	if (galileo_id >= 0x10) {
 		/* New Galileo, assumes PCI stop line to VIA is connected. */
 		GALILEO_OUTL(0x4020, GT_PCI0_TOR_OFS);
-	} else if (galileo_id == 0x1 || galileo_id == 0x2) {
+	} else if (galileo_id == 0x1 || galileo_id == 0x2)
+#endif
+	{
 		signed int timeo;
 		/* XXX WE MUST DO THIS ELSE GALILEO LOCKS UP! -DaveM */
 		timeo = GALILEO_INL(GT_PCI0_TOR_OFS);
 		/* Old Galileo, assumes PCI STOP line to VIA is disconnected. */
-		GALILEO_OUTL(0xffff, GT_PCI0_TOR_OFS);
+		GALILEO_OUTL(
+			(0xff << 16) |		/* retry count */
+			(0xff << 8) |		/* timeout 1   */
+			0xff,			/* timeout 0   */
+			GT_PCI0_TOR_OFS);
+
+		/* enable PCI retry exceeded interrupt */
+		GALILEO_OUTL(GALILEO_INTR_RETRY_CTR | GALILEO_INL(GT_INTRMASK_OFS), GT_INTRMASK_OFS);
 	}
 }
 
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_GALILEO, PCI_ANY_ID,
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_GT64111,
 	 qube_raq_galileo_fixup);
 
+static char irq_tab_qube1[] __initdata = {
+  [COBALT_PCICONF_CPU]     = 0,
+  [COBALT_PCICONF_ETH0]    = COBALT_QUBE1_ETH0_IRQ,
+  [COBALT_PCICONF_RAQSCSI] = COBALT_SCSI_IRQ,
+  [COBALT_PCICONF_VIA]     = 0,
+  [COBALT_PCICONF_PCISLOT] = COBALT_QUBE_SLOT_IRQ,
+  [COBALT_PCICONF_ETH1]    = 0
+};
+
 static char irq_tab_cobalt[] __initdata = {
   [COBALT_PCICONF_CPU]     = 0,
   [COBALT_PCICONF_ETH0]    = COBALT_ETH0_IRQ,
@@ -99,6 +145,9 @@
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
+	if (cobalt_board_id < COBALT_BRD_ID_QUBE2)
+		return irq_tab_qube1[slot];
+
 	if (cobalt_board_id == COBALT_BRD_ID_RAQ2)
 		return irq_tab_raq2[slot];
 
diff -Naur linux-2.6.14/arch/mips/pci/fixup-pnx8550.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-pnx8550.c
--- linux-2.6.14/arch/mips/pci/fixup-pnx8550.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-pnx8550.c	2005-11-17 11:42:28.000000000 -0800
@@ -0,0 +1,57 @@
+/*
+ *  Philips PNX8550 pci fixups.
+ *
+ *  Copyright 2005 Embedded Alley Solutions, Inc
+ *  source@embeddealley.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/mach-pnx8550/pci.h>
+#include <asm/mach-pnx8550/int.h>
+
+
+#undef	DEBUG
+#ifdef 	DEBUG
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)
+#endif
+
+extern char irq_tab_jbs[][5];
+
+void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+	/* no need to fixup IO resources */
+}
+
+void __init pcibios_fixup(void)
+{
+	/* nothing to do here */
+}
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return irq_tab_jbs[slot][pin];
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
diff -Naur linux-2.6.14/arch/mips/pci/fixup-tb0219.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-tb0219.c
--- linux-2.6.14/arch/mips/pci/fixup-tb0219.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-tb0219.c	2005-11-17 11:42:28.000000000 -0800
@@ -2,7 +2,7 @@
  *  fixup-tb0219.c, The TANBAC TB0219 specific PCI fixups.
  *
  *  Copyright (C) 2003  Megasolution Inc. <matsu@megasolution.jp>
- *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
diff -Naur linux-2.6.14/arch/mips/pci/fixup-tb0287.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-tb0287.c
--- linux-2.6.14/arch/mips/pci/fixup-tb0287.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-tb0287.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,65 +0,0 @@
-/*
- *  fixup-tb0287.c, The TANBAC TB0287 specific PCI fixups.
- *
- *  Copyright (C) 2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/init.h>
-#include <linux/pci.h>
-
-#include <asm/vr41xx/tb0287.h>
-
-int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	unsigned char bus;
-	int irq = -1;
-
-	bus = dev->bus->number;
-	if (bus == 0) {
-		switch (slot) {
-		case 16:
-			irq = TB0287_SM501_IRQ;
-			break;
-		case 17:
-			irq = TB0287_SIL680A_IRQ;
-			break;
-		default:
-			break;
-		}
-	} else if (bus == 1) {
-		switch (PCI_SLOT(dev->devfn)) {
-		case 0:
-			irq = TB0287_PCI_SLOT_IRQ;
-			break;
-		case 2:
-		case 3:
-			irq = TB0287_RTL8110_IRQ;
-			break;
-		default:
-			break;
-		}
-	} else if (bus > 1) {
-		irq = TB0287_PCI_SLOT_IRQ;
-	}
-
-	return irq;
-}
-
-/* Do platform specific device initialization at pci_enable_device() time */
-int pcibios_plat_dev_init(struct pci_dev *dev)
-{
-	return 0;
-}
diff -Naur linux-2.6.14/arch/mips/pci/fixup-tx4938.c linux-mips-2.6.14.orig/arch/mips/pci/fixup-tx4938.c
--- linux-2.6.14/arch/mips/pci/fixup-tx4938.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pci/fixup-tx4938.c	2005-11-17 11:42:28.000000000 -0800
@@ -0,0 +1,92 @@
+/*
+ * Toshiba rbtx4938 pci routines
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/tx4938/rbtx4938.h>
+
+extern struct pci_controller tx4938_pci_controller[];
+
+int pci_get_irq(struct pci_dev *dev, int pin)
+{
+	int irq = pin;
+	u8 slot = PCI_SLOT(dev->devfn);
+	struct pci_controller *controller = (struct pci_controller *)dev->sysdata;
+
+	if (controller == &tx4938_pci_controller[1]) {
+		/* TX4938 PCIC1 */
+		switch (slot) {
+		case TX4938_PCIC_IDSEL_AD_TO_SLOT(31):
+			if (tx4938_ccfgptr->pcfg & TX4938_PCFG_ETH0_SEL)
+				return RBTX4938_IRQ_IRC + TX4938_IR_ETH0;
+			break;
+		case TX4938_PCIC_IDSEL_AD_TO_SLOT(30):
+			if (tx4938_ccfgptr->pcfg & TX4938_PCFG_ETH1_SEL)
+				return RBTX4938_IRQ_IRC + TX4938_IR_ETH1;
+			break;
+		}
+		return 0;
+	}
+
+	/* IRQ rotation */
+	irq--;	/* 0-3 */
+	if (dev->bus->parent == NULL &&
+	    (slot == TX4938_PCIC_IDSEL_AD_TO_SLOT(23))) {
+		/* PCI CardSlot (IDSEL=A23) */
+		/* PCIA => PCIA (IDSEL=A23) */
+		irq = (irq + 0 + slot) % 4;
+	} else {
+		/* PCI Backplane */
+		irq = (irq + 33 - slot) % 4;
+	}
+	irq++;	/* 1-4 */
+
+	switch (irq) {
+	case 1:
+		irq = RBTX4938_IRQ_IOC_PCIA;
+		break;
+	case 2:
+		irq = RBTX4938_IRQ_IOC_PCIB;
+		break;
+	case 3:
+		irq = RBTX4938_IRQ_IOC_PCIC;
+		break;
+	case 4:
+		irq = RBTX4938_IRQ_IOC_PCID;
+		break;
+	}
+	return irq;
+}
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	unsigned char irq = 0;
+
+	irq = pci_get_irq(dev, pin);
+
+	printk(KERN_INFO "PCI: 0x%02x:0x%02x(0x%02x,0x%02x) IRQ=%d\n",
+	       dev->bus->number, dev->devfn, PCI_SLOT(dev->devfn),
+	       PCI_FUNC(dev->devfn), irq);
+
+	return irq;
+}
+
+/*
+ * Do platform specific device initialization at pci_enable_device() time
+ */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
diff -Naur linux-2.6.14/arch/mips/pci/Makefile linux-mips-2.6.14.orig/arch/mips/pci/Makefile
--- linux-2.6.14/arch/mips/pci/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/Makefile	2005-11-17 11:42:28.000000000 -0800
@@ -34,6 +34,7 @@
 obj-$(CONFIG_MIPS_IVR)		+= fixup-ivr.o
 obj-$(CONFIG_SOC_AU1500)	+= fixup-au1000.o ops-au1000.o
 obj-$(CONFIG_SOC_AU1550)	+= fixup-au1000.o ops-au1000.o
+obj-$(CONFIG_SOC_PNX8550)	+= fixup-pnx8550.o ops-pnx8550.o
 obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o
 obj-$(CONFIG_MOMENCO_JAGUAR_ATX)+= fixup-jaguar.o
 obj-$(CONFIG_MOMENCO_OCELOT)	+= fixup-ocelot.o pci-ocelot.o
@@ -45,11 +46,12 @@
 obj-$(CONFIG_SGI_IP27)		+= pci-ip27.o
 obj-$(CONFIG_SGI_IP32)		+= fixup-ip32.o ops-mace.o pci-ip32.o
 obj-$(CONFIG_SIBYTE_SB1250)	+= fixup-sb1250.o pci-sb1250.o
+obj-$(CONFIG_SIBYTE_BCM1x80)	+= pci-bcm1480.o pci-bcm1480ht.o
 obj-$(CONFIG_SNI_RM200_PCI)	+= fixup-sni.o ops-sni.o
 obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
-obj-$(CONFIG_TANBAC_TB0287)	+= fixup-tb0287.o
 obj-$(CONFIG_TOSHIBA_JMR3927)	+= fixup-jmr3927.o pci-jmr3927.o
 obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o ops-tx4927.o
+obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-tx4938.o ops-tx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
diff -Naur linux-2.6.14/arch/mips/pci/ops-au1000.c linux-mips-2.6.14.orig/arch/mips/pci/ops-au1000.c
--- linux-2.6.14/arch/mips/pci/ops-au1000.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-au1000.c	2005-11-17 11:42:28.000000000 -0800
@@ -50,11 +50,6 @@
 
 int (*board_pci_idsel)(unsigned int devsel, int assert);
 
-/* CP0 hazard avoidance. */
-#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
-				     "nop; nop; nop; nop;\t" \
-				     ".set reorder\n\t")
-
 void mod_wired_entry(int entry, unsigned long entrylo0,
 		unsigned long entrylo1, unsigned long entryhi,
 		unsigned long pagemask)
@@ -66,16 +61,12 @@
 	old_ctx = read_c0_entryhi() & 0xff;
 	old_pagemask = read_c0_pagemask();
 	write_c0_index(entry);
-	BARRIER;
 	write_c0_pagemask(pagemask);
 	write_c0_entryhi(entryhi);
 	write_c0_entrylo0(entrylo0);
 	write_c0_entrylo1(entrylo1);
-	BARRIER;
 	tlb_write_indexed();
-	BARRIER;
 	write_c0_entryhi(old_ctx);
-	BARRIER;
 	write_c0_pagemask(old_pagemask);
 }
 
@@ -128,9 +119,8 @@
 		last_entryLo0  = last_entryLo1 = 0xffffffff;
 	}
 
-	/* Since the Au1xxx doesn't do the idsel timing exactly to spec,
-	 * many board vendors implement their own off-chip idsel, so call
-	 * it now.  If it doesn't succeed, may as well bail out at this point.
+	/* Allow board vendors to implement their own off-chip idsel.
+	 * If it doesn't succeed, may as well bail out at this point.
 	 */
 	if (board_pci_idsel) {
 		if (board_pci_idsel(device, 1) == 0) {
diff -Naur linux-2.6.14/arch/mips/pci/ops-bonito64.c linux-mips-2.6.14.orig/arch/mips/pci/ops-bonito64.c
--- linux-2.6.14/arch/mips/pci/ops-bonito64.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-bonito64.c	2005-11-17 11:42:28.000000000 -0800
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -17,7 +19,6 @@
  *
  * MIPS boards specific PCI support.
  */
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -57,13 +58,6 @@
 		return -1;
 	}
 
-#ifdef CONFIG_MIPS_BOARDS_GEN
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 17)) {
-		/* MIPS Core boards have Bonito connected as device 17 */
-		return -1;
-	}
-#endif
-
 	/* Clear cause register bits */
 	BONITO_PCICMD |= (BONITO_PCICMD_MABORT_CLR |
 			  BONITO_PCICMD_MTABORT_CLR);
diff -Naur linux-2.6.14/arch/mips/pci/ops-gt64111.c linux-mips-2.6.14.orig/arch/mips/pci/ops-gt64111.c
--- linux-2.6.14/arch/mips/pci/ops-gt64111.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-gt64111.c	2005-11-17 11:42:28.000000000 -0800
@@ -18,15 +18,15 @@
 #include <asm/cobalt/cobalt.h>
 
 /*
- * Accessing device 31 hangs the GT64120.  Not sure if this will also hang
- * the GT64111, let's be paranoid for now.
+ * Device 31 on the GT64111 is used to generate PCI special
+ * cycles, so we shouldn't expected to find a device there ...
  */
 static inline int pci_range_ck(struct pci_bus *bus, unsigned int devfn)
 {
-	if (bus->number == 0 && devfn == PCI_DEVFN(31, 0))
-		return -1;
+	if (bus->number == 0 && PCI_SLOT(devfn) < 31)
+		return 0;
 
-	return 0;
+	return -1;
 }
 
 static int gt64111_pci_read_config(struct pci_bus *bus, unsigned int devfn,
diff -Naur linux-2.6.14/arch/mips/pci/ops-gt64120.c linux-mips-2.6.14.orig/arch/mips/pci/ops-gt64120.c
--- linux-2.6.14/arch/mips/pci/ops-gt64120.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-gt64120.c	2005-11-17 11:42:28.000000000 -0800
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -43,10 +45,6 @@
 	unsigned char busnum = bus->number;
 	u32 intr;
 
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 0))
-		/* Galileo itself is devfn 0, don't move it around */
-		return -1;
-
 	if ((busnum == 0) && (devfn >= PCI_DEVFN(31, 0)))
 		return -1;	/* Because of a bug in the galileo (for slot 31). */
 
diff -Naur linux-2.6.14/arch/mips/pci/ops-msc.c linux-mips-2.6.14.orig/arch/mips/pci/ops-msc.c
--- linux-2.6.14/arch/mips/pci/ops-msc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-msc.c	2005-11-17 11:42:28.000000000 -0800
@@ -21,7 +21,6 @@
  * MIPS boards specific PCI support.
  *
  */
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -49,34 +48,17 @@
 	struct pci_bus *bus, unsigned int devfn, int where, u32 * data)
 {
 	unsigned char busnum = bus->number;
-	unsigned char type;
 	u32 intr;
 
-#ifdef CONFIG_MIPS_BOARDS_GEN
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 17)) {
-		/* MIPS Core boards have SOCit connected as device 17 */
-		return -1;
-	}
-#endif
-
 	/* Clear status register bits. */
 	MSC_WRITE(MSC01_PCI_INTSTAT,
 		  (MSC01_PCI_INTCFG_MA_BIT | MSC01_PCI_INTCFG_TA_BIT));
 
-	/* Setup address */
-	if (busnum == 0)
-		type = 0;	/* Type 0 */
-	else
-		type = 1;	/* Type 1 */
-
 	MSC_WRITE(MSC01_PCI_CFGADDR,
 		  ((busnum << MSC01_PCI_CFGADDR_BNUM_SHF) |
-		   (PCI_SLOT(devfn) << MSC01_PCI_CFGADDR_DNUM_SHF)
-		   | (PCI_FUNC(devfn) <<
-		      MSC01_PCI_CFGADDR_FNUM_SHF) | ((where /
-						      4) <<
-						     MSC01_PCI_CFGADDR_RNUM_SHF)
-		   | (type)));
+		   (PCI_SLOT(devfn) << MSC01_PCI_CFGADDR_DNUM_SHF) |
+		   (PCI_FUNC(devfn) << MSC01_PCI_CFGADDR_FNUM_SHF) |
+		   ((where / 4) << MSC01_PCI_CFGADDR_RNUM_SHF)));
 
 	/* Perform access */
 	if (access_type == PCI_ACCESS_WRITE)
@@ -86,15 +68,12 @@
 
 	/* Detect Master/Target abort */
 	MSC_READ(MSC01_PCI_INTSTAT, intr);
-	if (intr & (MSC01_PCI_INTCFG_MA_BIT |
-		    MSC01_PCI_INTCFG_TA_BIT)) {
+	if (intr & (MSC01_PCI_INTCFG_MA_BIT | MSC01_PCI_INTCFG_TA_BIT)) {
 		/* Error occurred */
 
 		/* Clear bits */
-		MSC_READ(MSC01_PCI_INTSTAT, intr);
 		MSC_WRITE(MSC01_PCI_INTSTAT,
-			  (MSC01_PCI_INTCFG_MA_BIT |
-			   MSC01_PCI_INTCFG_TA_BIT));
+			  (MSC01_PCI_INTCFG_MA_BIT | MSC01_PCI_INTCFG_TA_BIT));
 
 		return -1;
 	}
diff -Naur linux-2.6.14/arch/mips/pci/ops-nile4.c linux-mips-2.6.14.orig/arch/mips/pci/ops-nile4.c
--- linux-2.6.14/arch/mips/pci/ops-nile4.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-nile4.c	2005-11-17 11:42:28.000000000 -0800
@@ -15,7 +15,7 @@
 
 volatile unsigned long *const vrc_pciregs = (void *) Vrc5074_BASE;
 
-static spinlock_t nile4_pci_lock;
+static DEFINE_SPINLOCK(nile4_pci_lock);
 
 static int nile4_pcibios_config_access(unsigned char access_type,
 	struct pci_bus *bus, unsigned int devfn, int where, u32 * val)
diff -Naur linux-2.6.14/arch/mips/pci/ops-pnx8550.c linux-mips-2.6.14.orig/arch/mips/pci/ops-pnx8550.c
--- linux-2.6.14/arch/mips/pci/ops-pnx8550.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-pnx8550.c	2005-11-17 11:42:28.000000000 -0800
@@ -0,0 +1,284 @@
+/*
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *
+ *  2.6 port, Embedded Alley Solutions, Inc
+ *
+ *  Based on:
+ *  Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+
+#include <asm/mach-pnx8550/pci.h>
+#include <asm/mach-pnx8550/glb.h>
+#include <asm/debug.h>
+
+
+static inline void clear_status(void)
+{
+	unsigned long pci_stat;
+
+	pci_stat = inl(PCI_BASE | PCI_GPPM_STATUS);
+	outl(pci_stat, PCI_BASE | PCI_GPPM_ICLR);
+}
+
+static inline unsigned int
+calc_cfg_addr(struct pci_bus *bus, unsigned int devfn, int where)
+{
+	unsigned int addr;
+
+	addr = ((bus->number > 0) ? (((bus->number & 0xff) << PCI_CFG_BUS_SHIFT) | 1) : 0);
+	addr |= ((devfn & 0xff) << PCI_CFG_FUNC_SHIFT) | (where & 0xfc);
+
+	return addr;
+}
+
+static int
+config_access(unsigned int pci_cmd, struct pci_bus *bus, unsigned int devfn, int where, unsigned int pci_mode, unsigned int *val)
+{
+	unsigned int flags;
+	unsigned long loops = 0;
+	unsigned long ioaddr = calc_cfg_addr(bus, devfn, where);
+
+	local_irq_save(flags);
+	/*Clear pending interrupt status */
+	if (inl(PCI_BASE | PCI_GPPM_STATUS)) {
+		clear_status();
+		while (!(inl(PCI_BASE | PCI_GPPM_STATUS) == 0)) ;
+	}
+
+	outl(ioaddr, PCI_BASE | PCI_GPPM_ADDR);
+
+	if ((pci_cmd == PCI_CMD_IOW) || (pci_cmd == PCI_CMD_CONFIG_WRITE))
+		outl(*val, PCI_BASE | PCI_GPPM_WDAT);
+
+	outl(INIT_PCI_CYCLE | pci_cmd | (pci_mode & PCI_BYTE_ENABLE_MASK),
+	     PCI_BASE | PCI_GPPM_CTRL);
+
+	loops =
+	    ((loops_per_jiffy *
+	      PCI_IO_JIFFIES_TIMEOUT) >> (PCI_IO_JIFFIES_SHIFT));
+	while (1) {
+		if (inl(PCI_BASE | PCI_GPPM_STATUS) & GPPM_DONE) {
+			if ((pci_cmd == PCI_CMD_IOR) ||
+			    (pci_cmd == PCI_CMD_CONFIG_READ))
+				*val = inl(PCI_BASE | PCI_GPPM_RDAT);
+			clear_status();
+			local_irq_restore(flags);
+			return PCIBIOS_SUCCESSFUL;
+		} else if (inl(PCI_BASE | PCI_GPPM_STATUS) & GPPM_R_MABORT) {
+			break;
+		}
+
+		loops--;
+		if (loops == 0) {
+			printk("%s : Arbiter Locked.\n", __FUNCTION__);
+		}
+	}
+
+	clear_status();
+	if ((pci_cmd == PCI_CMD_IOR) || (pci_cmd == PCI_CMD_IOW)) {
+		printk("%s timeout (GPPM_CTRL=%X) ioaddr %lX pci_cmd %X\n",
+		       __FUNCTION__, inl(PCI_BASE | PCI_GPPM_CTRL), ioaddr,
+		       pci_cmd);
+	}
+
+	if ((pci_cmd == PCI_CMD_IOR) || (pci_cmd == PCI_CMD_CONFIG_READ))
+		*val = 0xffffffff;
+	local_irq_restore(flags);
+	return PCIBIOS_DEVICE_NOT_FOUND;
+}
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int
+read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 * val)
+{
+	unsigned int data = 0;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(1 << (where & 3)), &data);
+	switch (where & 0x03) {
+	case 0:
+		*val = (unsigned char)(data & 0x000000ff);
+		break;
+	case 1:
+		*val = (unsigned char)((data & 0x0000ff00) >> 8);
+		break;
+	case 2:
+		*val = (unsigned char)((data & 0x00ff0000) >> 16);
+		break;
+	case 3:
+		*val = (unsigned char)((data & 0xff000000) >> 24);
+		break;
+	}
+
+	return err;
+}
+
+static int
+read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 * val)
+{
+	unsigned int data = 0;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x01)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(3 << (where & 3)), &data);
+	switch (where & 0x02) {
+	case 0:
+		*val = (unsigned short)(data & 0x0000ffff);
+		break;
+	case 2:
+		*val = (unsigned short)((data & 0xffff0000) >> 16);
+		break;
+	}
+
+	return err;
+}
+
+static int
+read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 * val)
+{
+	int err;
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x03)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, 0, val);
+
+	return err;
+}
+
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 val)
+{
+	unsigned int data = (unsigned int)val;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	switch (where & 0x03) {
+	case 1:
+		data = (data << 8);
+		break;
+	case 2:
+		data = (data << 16);
+		break;
+	case 3:
+		data = (data << 24);
+		break;
+	default:
+		break;
+	}
+
+	err = config_access(PCI_CMD_CONFIG_READ, bus, devfn, where, ~(1 << (where & 3)), &data);
+
+	return err;
+}
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 val)
+{
+	unsigned int data = (unsigned int)val;
+	int err;
+
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x01)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	switch (where & 0x02) {
+	case 2:
+		data = (data << 16);
+		break;
+	default:
+		break;
+	}
+	err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, ~(3 << (where & 3)), &data);
+
+	return err;
+}
+
+static int
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
+{
+	int err;
+	if (bus == 0)
+		return -1;
+
+	if (where & 0x03)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	err = config_access(PCI_CMD_CONFIG_WRITE, bus, devfn, where, 0, &val);
+
+	return err;
+}
+
+static int config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1: {
+			u8 _val;
+			int rc = read_config_byte(bus, devfn, where, &_val);
+			*val = _val;
+			return rc;
+		}
+       case 2: {
+			u16 _val;
+			int rc = read_config_word(bus, devfn, where, &_val);
+			*val = _val;
+			return rc;
+		}
+	default:
+		return read_config_dword(bus, devfn, where, val);
+	}
+}
+
+static int config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+{
+	switch (size) {
+	case 1:
+		return write_config_byte(bus, devfn, where, (u8) val);
+	case 2:
+		return write_config_word(bus, devfn, where, (u16) val);
+	default:
+		return write_config_dword(bus, devfn, where, val);
+	}
+}
+
+struct pci_ops pnx8550_pci_ops = {
+	config_read,
+	config_write
+};
diff -Naur linux-2.6.14/arch/mips/pci/ops-tx4938.c linux-mips-2.6.14.orig/arch/mips/pci/ops-tx4938.c
--- linux-2.6.14/arch/mips/pci/ops-tx4938.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pci/ops-tx4938.c	2005-11-17 11:42:28.000000000 -0800
@@ -0,0 +1,198 @@
+/*
+ * Define the pci_ops for the Toshiba rbtx4938
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/addrspace.h>
+#include <asm/tx4938/rbtx4938.h>
+
+/* initialize in setup */
+struct resource pci_io_resource = {
+	.name	= "pci IO space",
+	.start	= 0,
+	.end	= 0,
+	.flags	= IORESOURCE_IO
+};
+
+/* initialize in setup */
+struct resource pci_mem_resource = {
+	.name	= "pci memory space",
+	.start	= 0,
+	.end	= 0,
+	.flags	= IORESOURCE_MEM
+};
+
+struct resource tx4938_pcic1_pci_io_resource = {
+       	.name	= "PCI1 IO",
+       	.start	= 0,
+       	.end	= 0,
+       	.flags	= IORESOURCE_IO
+};
+struct resource tx4938_pcic1_pci_mem_resource = {
+       	.name	= "PCI1 mem",
+       	.start	= 0,
+       	.end	= 0,
+       	.flags	= IORESOURCE_MEM
+};
+
+static int mkaddr(int bus, int dev_fn, int where, int *flagsp)
+{
+	if (bus > 0) {
+		/* Type 1 configuration */
+		tx4938_pcicptr->g2pcfgadrs = ((bus & 0xff) << 0x10) |
+		    ((dev_fn & 0xff) << 0x08) | (where & 0xfc) | 1;
+	} else {
+		if (dev_fn >= PCI_DEVFN(TX4938_PCIC_MAX_DEVNU, 0))
+			return -1;
+
+		/* Type 0 configuration */
+		tx4938_pcicptr->g2pcfgadrs = ((bus & 0xff) << 0x10) |
+		    ((dev_fn & 0xff) << 0x08) | (where & 0xfc);
+	}
+	/* clear M_ABORT and Disable M_ABORT Int. */
+	tx4938_pcicptr->pcistatus =
+	    (tx4938_pcicptr->pcistatus & 0x0000ffff) |
+	    (PCI_STATUS_REC_MASTER_ABORT << 16);
+	tx4938_pcicptr->pcimask &= ~PCI_STATUS_REC_MASTER_ABORT;
+
+	return 0;
+}
+
+static int check_abort(int flags)
+{
+	int code = PCIBIOS_SUCCESSFUL;
+	/* wait write cycle completion before checking error status */
+	while (tx4938_pcicptr->pcicstatus & TX4938_PCIC_PCICSTATUS_IWB)
+				;
+	if (tx4938_pcicptr->pcistatus & (PCI_STATUS_REC_MASTER_ABORT << 16)) {
+		tx4938_pcicptr->pcistatus =
+		    (tx4938_pcicptr->
+		     pcistatus & 0x0000ffff) | (PCI_STATUS_REC_MASTER_ABORT
+						<< 16);
+		tx4938_pcicptr->pcimask |= PCI_STATUS_REC_MASTER_ABORT;
+		code = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	return code;
+}
+
+static int tx4938_pcibios_read_config(struct pci_bus *bus, unsigned int devfn,
+					int where, int size, u32 * val)
+{
+	int flags, retval, dev, busno, func;
+
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL)
+		busno = bus->number;
+	else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*val = *(volatile u8 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+			      ((where & 3) ^ 3));
+#else
+			      (where & 3));
+#endif
+		break;
+	case 2:
+		*val = *(volatile u16 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+				((where & 3) ^ 2));
+#else
+				(where & 3));
+#endif
+		break;
+	case 4:
+		*val = tx4938_pcicptr->g2pcfgdata;
+		break;
+	}
+
+	retval = check_abort(flags);
+	if (retval == PCIBIOS_DEVICE_NOT_FOUND)
+		*val = 0xffffffff;
+
+	return retval;
+}
+
+static int tx4938_pcibios_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+						int size, u32 val)
+{
+	int flags, dev, busno, func;
+
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) {
+		busno = bus->number;
+	} else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*(volatile u8 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+			  ((where & 3) ^ 3)) = val;
+#else
+			  (where & 3)) = val;
+#endif
+		break;
+	case 2:
+		*(volatile u16 *) ((ulong) & tx4938_pcicptr->g2pcfgdata |
+#ifdef __BIG_ENDIAN
+			((where & 0x3) ^ 0x2)) = val;
+#else
+			(where & 3)) = val;
+#endif
+		break;
+	case 4:
+		tx4938_pcicptr->g2pcfgdata = val;
+		break;
+	}
+
+	return check_abort(flags);
+}
+
+struct pci_ops tx4938_pci_ops = {
+	tx4938_pcibios_read_config,
+	tx4938_pcibios_write_config
+};
+
+struct pci_controller tx4938_pci_controller[] = {
+	/* h/w only supports devices 0x00 to 0x14 */
+	{
+		.pci_ops        = &tx4938_pci_ops,
+		.io_resource    = &pci_io_resource,
+		.mem_resource   = &pci_mem_resource,
+	},
+	/* h/w only supports devices 0x00 to 0x14 */
+	{
+		.pci_ops        = &tx4938_pci_ops,
+		.io_resource    = &tx4938_pcic1_pci_io_resource,
+		.mem_resource   = &tx4938_pcic1_pci_mem_resource,
+        }
+};
diff -Naur linux-2.6.14/arch/mips/pci/pci-bcm1480.c linux-mips-2.6.14.orig/arch/mips/pci/pci-bcm1480.c
--- linux-2.6.14/arch/mips/pci/pci-bcm1480.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci-bcm1480.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2001,2002,2005 Broadcom Corporation
+ * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * BCM1x80/1x55-specific PCI support
+ *
+ * This module provides the glue between Linux's PCI subsystem
+ * and the hardware.  We basically provide glue for accessing
+ * configuration space, and set up the translation for I/O
+ * space accesses.
+ *
+ * To access configuration space, we use ioremap.  In the 32-bit
+ * kernel, this consumes either 4 or 8 page table pages, and 16MB of
+ * kernel mapped memory.  Hopefully neither of these should be a huge
+ * problem.
+ *
+ * XXX: AT THIS TIME, ONLY the NATIVE PCI-X INTERFACE IS SUPPORTED.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_scd.h>
+#include <asm/sibyte/board.h>
+#include <asm/io.h>
+
+/*
+ * Macros for calculating offsets into config space given a device
+ * structure or dev/fun/reg
+ */
+#define CFGOFFSET(bus,devfn,where) (((bus)<<16)+((devfn)<<8)+(where))
+#define CFGADDR(bus,devfn,where)   CFGOFFSET((bus)->number,(devfn),where)
+
+static void *cfg_space;
+
+#define PCI_BUS_ENABLED	1
+#define PCI_DEVICE_MODE	2
+
+static int bcm1480_bus_status = 0;
+
+#define PCI_BRIDGE_DEVICE  0
+
+/*
+ * Read/write 32-bit values in config space.
+ */
+static inline u32 READCFG32(u32 addr)
+{
+	return *(u32 *)(cfg_space + (addr&~3));
+}
+
+static inline void WRITECFG32(u32 addr, u32 data)
+{
+	*(u32 *)(cfg_space + (addr & ~3)) = data;
+}
+
+int pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return dev->irq;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+/*
+ * Some checks before doing config cycles:
+ * In PCI Device Mode, hide everything on bus 0 except the LDT host
+ * bridge.  Otherwise, access is controlled by bridge MasterEn bits.
+ */
+static int bcm1480_pci_can_access(struct pci_bus *bus, int devfn)
+{
+	u32 devno;
+
+	if (!(bcm1480_bus_status & (PCI_BUS_ENABLED | PCI_DEVICE_MODE)))
+		return 0;
+
+	if (bus->number == 0) {
+		devno = PCI_SLOT(devfn);
+ 		if (bcm1480_bus_status & PCI_DEVICE_MODE)
+			return 0;
+		else
+			return 1;
+	} else
+		return 1;
+}
+
+/*
+ * Read/write access functions for various sizes of values
+ * in config space.  Return all 1's for disallowed accesses
+ * for a kludgy but adequate simulation of master aborts.
+ */
+
+static int bcm1480_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 * val)
+{
+	u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (bcm1480_pci_can_access(bus, devfn))
+		data = READCFG32(CFGADDR(bus, devfn, where));
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm1480_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 val)
+{
+	u32 cfgaddr = CFGADDR(bus, devfn, where);
+	u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!bcm1480_pci_can_access(bus, devfn))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = READCFG32(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else
+		data = val;
+
+	WRITECFG32(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops bcm1480_pci_ops = {
+	bcm1480_pcibios_read,
+	bcm1480_pcibios_write,
+};
+
+static struct resource bcm1480_mem_resource = {
+	.name	= "BCM1480 PCI MEM",
+	.start	= 0x30000000UL,
+	.end	= 0x3fffffffUL,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource bcm1480_io_resource = {
+	.name	= "BCM1480 PCI I/O",
+	.start	= 0x2c000000UL,
+	.end	= 0x2dffffffUL,
+	.flags	= IORESOURCE_IO,
+};
+
+struct pci_controller bcm1480_controller = {
+	.pci_ops	= &bcm1480_pci_ops,
+	.mem_resource	= &bcm1480_mem_resource,
+	.io_resource	= &bcm1480_io_resource,
+};
+
+
+static int __init bcm1480_pcibios_init(void)
+{
+	uint32_t cmdreg;
+	uint64_t reg;
+	extern int pci_probe_only;
+
+	/* CFE will assign PCI resources */
+	pci_probe_only = 1;
+
+	/* Avoid ISA compat ranges.  */
+	PCIBIOS_MIN_IO = 0x00008000UL;
+	PCIBIOS_MIN_MEM = 0x01000000UL;
+
+	/* Set I/O resource limits. - unlimited for now to accomodate HT */
+	ioport_resource.end = 0xffffffffUL;
+	iomem_resource.end = 0xffffffffUL;
+
+	cfg_space = ioremap(A_BCM1480_PHYS_PCI_CFG_MATCH_BITS, 16*1024*1024);
+
+	/*
+	 * See if the PCI bus has been configured by the firmware.
+	 */
+	reg = *((volatile uint64_t *) IOADDR(A_SCD_SYSTEM_CFG));
+	if (!(reg & M_BCM1480_SYS_PCI_HOST)) {
+		bcm1480_bus_status |= PCI_DEVICE_MODE;
+	} else {
+		cmdreg = READCFG32(CFGOFFSET(0, PCI_DEVFN(PCI_BRIDGE_DEVICE, 0),
+					     PCI_COMMAND));
+		if (!(cmdreg & PCI_COMMAND_MASTER)) {
+			printk
+			    ("PCI: Skipping PCI probe.  Bus is not initialized.\n");
+			iounmap(cfg_space);
+			return 1; /* XXX */
+		}
+		bcm1480_bus_status |= PCI_BUS_ENABLED;
+	}
+
+	/* turn on ExpMemEn */
+	cmdreg = READCFG32(CFGOFFSET(0, PCI_DEVFN(PCI_BRIDGE_DEVICE, 0), 0x40));
+	printk("PCIFeatureCtrl = %x\n", cmdreg);
+	WRITECFG32(CFGOFFSET(0, PCI_DEVFN(PCI_BRIDGE_DEVICE, 0), 0x40),
+			cmdreg | 0x10);
+	cmdreg = READCFG32(CFGOFFSET(0, PCI_DEVFN(PCI_BRIDGE_DEVICE, 0), 0x40));
+	printk("PCIFeatureCtrl = %x\n", cmdreg);
+
+	/*
+	 * Establish mappings in KSEG2 (kernel virtual) to PCI I/O
+	 * space.  Use "match bytes" policy to make everything look
+	 * little-endian.  So, you need to also set
+	 * CONFIG_SWAP_IO_SPACE, but this is the combination that
+	 * works correctly with most of Linux's drivers.
+	 * XXX ehs: Should this happen in PCI Device mode?
+	 */
+
+	set_io_port_base((unsigned long)
+		ioremap(A_BCM1480_PHYS_PCI_IO_MATCH_BYTES, 65536));
+	isa_slot_offset = (unsigned long)
+		ioremap(A_BCM1480_PHYS_PCI_MEM_MATCH_BYTES, 1024*1024);
+
+	register_pci_controller(&bcm1480_controller);
+
+#ifdef CONFIG_VGA_CONSOLE
+	take_over_console(&vga_con,0,MAX_NR_CONSOLES-1,1);
+#endif
+	return 0;
+}
+
+arch_initcall(bcm1480_pcibios_init);
diff -Naur linux-2.6.14/arch/mips/pci/pci-bcm1480ht.c linux-mips-2.6.14.orig/arch/mips/pci/pci-bcm1480ht.c
--- linux-2.6.14/arch/mips/pci/pci-bcm1480ht.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci-bcm1480ht.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2001,2002,2005 Broadcom Corporation
+ * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * BCM1480/1455-specific HT support (looking like PCI)
+ *
+ * This module provides the glue between Linux's PCI subsystem
+ * and the hardware.  We basically provide glue for accessing
+ * configuration space, and set up the translation for I/O
+ * space accesses.
+ *
+ * To access configuration space, we use ioremap.  In the 32-bit
+ * kernel, this consumes either 4 or 8 page table pages, and 16MB of
+ * kernel mapped memory.  Hopefully neither of these should be a huge
+ * problem.
+ *
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_scd.h>
+#include <asm/sibyte/board.h>
+#include <asm/io.h>
+
+/*
+ * Macros for calculating offsets into config space given a device
+ * structure or dev/fun/reg
+ */
+#define CFGOFFSET(bus,devfn,where) (((bus)<<16)+((devfn)<<8)+(where))
+#define CFGADDR(bus,devfn,where)   CFGOFFSET((bus)->number,(devfn),where)
+
+static void *ht_cfg_space;
+
+#define PCI_BUS_ENABLED	1
+#define PCI_DEVICE_MODE	2
+
+static int bcm1480ht_bus_status = 0;
+
+#define PCI_BRIDGE_DEVICE  0
+#define HT_BRIDGE_DEVICE   1
+
+/*
+ * HT's level-sensitive interrupts require EOI, which is generated
+ * through a 4MB memory-mapped region
+ */
+unsigned long ht_eoi_space;
+
+/*
+ * Read/write 32-bit values in config space.
+ */
+static inline u32 READCFG32(u32 addr)
+{
+	return *(u32 *)(ht_cfg_space + (addr&~3));
+}
+
+static inline void WRITECFG32(u32 addr, u32 data)
+{
+	*(u32 *)(ht_cfg_space + (addr & ~3)) = data;
+}
+
+/*
+ * Some checks before doing config cycles:
+ * In PCI Device Mode, hide everything on bus 0 except the LDT host
+ * bridge.  Otherwise, access is controlled by bridge MasterEn bits.
+ */
+static int bcm1480ht_can_access(struct pci_bus *bus, int devfn)
+{
+	u32 devno;
+
+	if (!(bcm1480ht_bus_status & (PCI_BUS_ENABLED | PCI_DEVICE_MODE)))
+		return 0;
+
+	if (bus->number == 0) {
+		devno = PCI_SLOT(devfn);
+ 		if (bcm1480ht_bus_status & PCI_DEVICE_MODE)
+			return 0;
+	}
+	return 1;
+}
+
+/*
+ * Read/write access functions for various sizes of values
+ * in config space.  Return all 1's for disallowed accesses
+ * for a kludgy but adequate simulation of master aborts.
+ */
+
+static int bcm1480ht_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 * val)
+{
+	u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (bcm1480ht_can_access(bus, devfn))
+		data = READCFG32(CFGADDR(bus, devfn, where));
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm1480ht_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 val)
+{
+	u32 cfgaddr = CFGADDR(bus, devfn, where);
+	u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!bcm1480ht_can_access(bus, devfn))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = READCFG32(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+		    (val << ((where & 3) << 3));
+	else
+		data = val;
+
+	WRITECFG32(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm1480ht_pcibios_get_busno(void)
+{
+	return 0;
+}
+
+struct pci_ops bcm1480ht_pci_ops = {
+	.read	= bcm1480ht_pcibios_read,
+	.write	= bcm1480ht_pcibios_write,
+};
+
+static struct resource bcm1480ht_mem_resource = {
+	.name	= "BCM1480 HT MEM",
+	.start	= 0x40000000UL,
+	.end	= 0x5fffffffUL,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource bcm1480ht_io_resource = {
+	.name	= "BCM1480 HT I/O",
+	.start	= 0x00000000UL,
+	.end	= 0x01ffffffUL,
+	.flags	= IORESOURCE_IO,
+};
+
+struct pci_controller bcm1480ht_controller = {
+	.pci_ops	= &bcm1480ht_pci_ops,
+	.mem_resource	= &bcm1480ht_mem_resource,
+	.io_resource	= &bcm1480ht_io_resource,
+	.index		= 1,
+	.get_busno	= bcm1480ht_pcibios_get_busno,
+};
+
+static int __init bcm1480ht_pcibios_init(void)
+{
+	uint32_t cmdreg;
+
+	ht_cfg_space = ioremap(A_BCM1480_PHYS_HT_CFG_MATCH_BITS, 16*1024*1024);
+
+	/*
+	 * See if the PCI bus has been configured by the firmware.
+	 */
+	cmdreg = READCFG32(CFGOFFSET(0, PCI_DEVFN(PCI_BRIDGE_DEVICE, 0),
+				     PCI_COMMAND));
+	if (!(cmdreg & PCI_COMMAND_MASTER)) {
+		printk("HT: Skipping HT probe. Bus is not initialized.\n");
+		iounmap(ht_cfg_space);
+		return 1; /* XXX */
+	}
+	bcm1480ht_bus_status |= PCI_BUS_ENABLED;
+
+	ht_eoi_space = (unsigned long)
+		ioremap(A_BCM1480_PHYS_HT_SPECIAL_MATCH_BYTES,
+			4 * 1024 * 1024);
+
+	register_pci_controller(&bcm1480ht_controller);
+
+	return 0;
+}
+
+arch_initcall(bcm1480ht_pcibios_init);
diff -Naur linux-2.6.14/arch/mips/pci/pci.c linux-mips-2.6.14.orig/arch/mips/pci/pci.c
--- linux-2.6.14/arch/mips/pci/pci.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci.c	2005-11-17 11:42:29.000000000 -0800
@@ -127,15 +127,20 @@
 		if (!hose->iommu)
 			PCI_DMA_BUS_IS_PHYS = 1;
 
+		if (hose->get_busno && pci_probe_only)
+			next_busno = (*hose->get_busno)();
+
 		bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
 		hose->bus = bus;
 		hose->need_domain_info = need_domain_info;
-		next_busno = bus->subordinate + 1;
-		/* Don't allow 8-bit bus number overflow inside the hose -
-		   reserve some space for bridges. */
-		if (next_busno > 224) {
-			next_busno = 0;
-			need_domain_info = 1;
+		if (bus) {
+			next_busno = bus->subordinate + 1;
+			/* Don't allow 8-bit bus number overflow inside the hose -
+			   reserve some space for bridges. */
+			if (next_busno > 224) {
+				next_busno = 0;
+				need_domain_info = 1;
+			}
 		}
 		continue;
 
@@ -164,7 +169,7 @@
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	old_cmd = cmd;
-	for(idx=0; idx<6; idx++) {
+	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
 		/* Only set up the requested stuff */
 		if (!(mask & (1<<idx)))
 			continue;
diff -Naur linux-2.6.14/arch/mips/pci/pci-ip27.c linux-mips-2.6.14.orig/arch/mips/pci/pci-ip27.c
--- linux-2.6.14/arch/mips/pci/pci-ip27.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci-ip27.c	2005-11-17 11:42:29.000000000 -0800
@@ -485,5 +485,12 @@
 	pci_disable_swapping(d);
 }
 
+int pcibus_to_node(struct pci_bus *bus)
+{
+	struct bridge_controller *bc = BRIDGE_CONTROLLER(bus);
+
+	return bc->nasid;
+}
+
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SGI, PCI_DEVICE_ID_SGI_IOC3,
 	pci_fixup_ioc3);
diff -Naur linux-2.6.14/arch/mips/pci/pci-ip32.c linux-mips-2.6.14.orig/arch/mips/pci/pci-ip32.c
--- linux-2.6.14/arch/mips/pci/pci-ip32.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci-ip32.c	2005-11-17 11:42:29.000000000 -0800
@@ -136,7 +136,9 @@
 	BUG_ON(request_irq(MACE_PCI_BRIDGE_IRQ, macepci_error, 0,
 			   "MACE PCI error", NULL));
 
-	ioport_resource.end = mace_pci_io_resource.end;
+	iomem_resource = mace_pci_mem_resource;
+	ioport_resource = mace_pci_io_resource;
+
 	register_pci_controller(&mace_pci_controller);
 
 	return 0;
diff -Naur linux-2.6.14/arch/mips/pci/pci-lasat.c linux-mips-2.6.14.orig/arch/mips/pci/pci-lasat.c
--- linux-2.6.14/arch/mips/pci/pci-lasat.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci-lasat.c	2005-11-17 11:42:29.000000000 -0800
@@ -7,12 +7,8 @@
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/types.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/delay.h>
 #include <asm/bootinfo.h>
 
 extern struct pci_ops nile4_pci_ops;
@@ -20,14 +16,14 @@
 static struct resource lasat_pci_mem_resource = {
 	.name	= "LASAT PCI MEM",
 	.start	= 0x18000000,
-	.end	= 0x19FFFFFF,
+	.end	= 0x19ffffff,
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource lasat_pci_io_resource = {
 	.name	= "LASAT PCI IO",
 	.start	= 0x1a000000,
-	.end	= 0x1bFFFFFF,
+	.end	= 0x1bffffff,
 	.flags	= IORESOURCE_IO,
 };
 
@@ -38,23 +34,25 @@
 
 static int __init lasat_pci_setup(void)
 {
- 	printk("PCI: starting\n");
+	printk("PCI: starting\n");
 
-        switch (mips_machtype) {
-            case MACH_LASAT_100:
+	switch (mips_machtype) {
+	case MACH_LASAT_100:
                 lasat_pci_controller.pci_ops = &gt64120_pci_ops;
                 break;
-            case MACH_LASAT_200:
+	case MACH_LASAT_200:
                 lasat_pci_controller.pci_ops = &nile4_pci_ops;
                 break;
-            default:
+	default:
                 panic("pcibios_init: mips_machtype incorrect");
         }
 
 	register_pci_controller(&lasat_pci_controller);
-        return 0;
+
+	return 0;
 }
-early_initcall(lasat_pci_setup);
+
+arch_initcall(lasat_pci_setup);
 
 #define LASATINT_ETH1   0
 #define LASATINT_ETH0   1
@@ -68,24 +66,22 @@
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
-    switch (slot) {
-        case 1:
-            return LASATINT_PCIA;   /* Expansion Module 0 */
-        case 2:
-            return LASATINT_PCIB;   /* Expansion Module 1 */
-        case 3:
-            return LASATINT_PCIC;   /* Expansion Module 2 */
-        case 4:
-            return LASATINT_ETH1;   /* Ethernet 1 (LAN 2) */
-        case 5:
-            return LASATINT_ETH0;   /* Ethernet 0 (LAN 1) */
-        case 6:
-            return LASATINT_HDC;    /* IDE controller */
-        default:
-            return 0xff;            /* Illegal */
-    }
+	switch (slot) {
+	case 1:
+	case 2:
+	case 3:
+		return LASATINT_PCIA + (((slot-1) + (pin-1)) % 4);
+	case 4:
+		return LASATINT_ETH1;   /* Ethernet 1 (LAN 2) */
+	case 5:
+		return LASATINT_ETH0;   /* Ethernet 0 (LAN 1) */
+	case 6:
+		return LASATINT_HDC;    /* IDE controller */
+	default:
+		return 0xff;            /* Illegal */
+	}
 
-    return -1;
+	return -1;
 }
 
 /* Do platform specific device initialization at pci_enable_device() time */
diff -Naur linux-2.6.14/arch/mips/pci/pci-vr41xx.c linux-mips-2.6.14.orig/arch/mips/pci/pci-vr41xx.c
--- linux-2.6.14/arch/mips/pci/pci-vr41xx.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pci/pci-vr41xx.c	2005-11-17 11:42:29.000000000 -0800
@@ -123,10 +123,8 @@
 		return -EBUSY;
 
 	pciu_base = ioremap(PCIU_BASE, PCIU_SIZE);
-	if (pciu_base == NULL) {
-		release_mem_region(PCIU_BASE, PCIU_SIZE);
+	if (pciu_base == NULL)
 		return -EBUSY;
-	}
 
 	/* Disable PCI interrupt */
 	vr41xx_disable_pciint();
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/gdb_hook.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/gdb_hook.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/gdb_hook.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/gdb_hook.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,109 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * This is the interface to the remote debugger stub.
+ *
+ */
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/serial.h>
+#include <asm/io.h>
+
+#include <uart.h>
+
+static struct serial_state rs_table[IP3106_NR_PORTS] = {
+};
+static struct async_struct kdb_port_info = {0};
+
+void rs_kgdb_hook(int tty_no)
+{
+	struct serial_state *ser = &rs_table[tty_no];
+
+	kdb_port_info.state = ser;
+	kdb_port_info.magic = SERIAL_MAGIC;
+	kdb_port_info.port  = tty_no;
+	kdb_port_info.flags = ser->flags;
+
+	/*
+	 * Clear all interrupts
+	 */
+	/* Clear all the transmitter FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, tty_no) |= IP3106_UART_LCR_TX_RST;
+	/* Clear all the receiver FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, tty_no) |= IP3106_UART_LCR_RX_RST;
+	/* Clear all interrupts */
+	ip3106_iclr(UART_BASE, tty_no) = IP3106_UART_INT_ALLRX |
+		IP3106_UART_INT_ALLTX;
+
+	/*
+	 * Now, initialize the UART
+	 */
+	ip3106_lcr(UART_BASE, tty_no) = IP3106_UART_LCR_8BIT;
+	ip3106_baud(UART_BASE, tty_no) = 5; // 38400 Baud
+}
+
+int putDebugChar(char c)
+{
+	/* Wait until FIFO not full */
+	while (((ip3106_fifo(UART_BASE, kdb_port_info.port) & IP3106_UART_FIFO_TXFIFO) >> 16) >= 16)
+		;
+	/* Send one char */
+	ip3106_fifo(UART_BASE, kdb_port_info.port) = c;
+
+	return 1;
+}
+
+char getDebugChar(void)
+{
+	char ch;
+
+	/* Wait until there is a char in the FIFO */
+	while (!((ip3106_fifo(UART_BASE, kdb_port_info.port) &
+					IP3106_UART_FIFO_RXFIFO) >> 8))
+		;
+	/* Read one char */
+	ch = ip3106_fifo(UART_BASE, kdb_port_info.port) &
+		IP3106_UART_FIFO_RBRTHR;
+	/* Advance the RX FIFO read pointer */
+	ip3106_lcr(UART_BASE, kdb_port_info.port) |= IP3106_UART_LCR_RX_NEXT;
+	return (ch);
+}
+
+void rs_disable_debug_interrupts(void)
+{
+	ip3106_ien(UART_BASE, kdb_port_info.port) = 0; /* Disable all interrupts */
+}
+
+void rs_enable_debug_interrupts(void)
+{
+	/* Clear all the transmitter FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, kdb_port_info.port) |= IP3106_UART_LCR_TX_RST;
+	/* Clear all the receiver FIFO counters (pointer and status) */
+	ip3106_lcr(UART_BASE, kdb_port_info.port) |= IP3106_UART_LCR_RX_RST;
+	/* Clear all interrupts */
+	ip3106_iclr(UART_BASE, kdb_port_info.port) = IP3106_UART_INT_ALLRX |
+		IP3106_UART_INT_ALLTX;
+	ip3106_ien(UART_BASE, kdb_port_info.port)  = IP3106_UART_INT_ALLRX; /* Enable RX interrupts */
+}
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/int.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/int.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/int.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/int.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,293 @@
+/*
+ *
+ * Copyright (C) 2005 Embedded Alley Solutions, Inc
+ * Ported to 2.6.
+ *
+ * Per Hallsmark, per.hallsmark@mvista.com
+ * Copyright (C) 2000, 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2001 Ralf Baechle
+ *
+ * Cleaned up and bug fixing: Pete Popov, ppopov@embeddedalley.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/random.h>
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/gdb-stub.h>
+#include <int.h>
+#include <uart.h>
+
+extern asmlinkage void cp0_irqdispatch(void);
+
+static DEFINE_SPINLOCK(irq_lock);
+
+/* default prio for interrupts */
+/* first one is a no-no so therefore always prio 0 (disabled) */
+static char gic_prio[PNX8550_INT_GIC_TOTINT] = {
+	0, 1, 1, 1, 1, 15, 1, 1, 1, 1,	//   0 -  9
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  10 - 19
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  20 - 29
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  30 - 39
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  40 - 49
+	1, 1, 1, 1, 1, 1, 1, 1, 2, 1,	//  50 - 59
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,	//  60 - 69
+	1			//  70
+};
+
+void hw0_irqdispatch(int irq, struct pt_regs *regs)
+{
+	/* find out which interrupt */
+	irq = PNX8550_GIC_VECTOR_0 >> 3;
+
+	if (irq == 0) {
+		printk("hw0_irqdispatch: irq 0, spurious interrupt?\n");
+		return;
+	}
+	do_IRQ(PNX8550_INT_GIC_MIN + irq, regs);
+}
+
+
+void timer_irqdispatch(int irq, struct pt_regs *regs)
+{
+	irq = (0x01c0 & read_c0_config7()) >> 6;
+
+	if (irq == 0) {
+		printk("timer_irqdispatch: irq 0, spurious interrupt?\n");
+		return;
+	}
+
+	if (irq & 0x1) {
+		do_IRQ(PNX8550_INT_TIMER1, regs);
+	}
+	if (irq & 0x2) {
+		do_IRQ(PNX8550_INT_TIMER2, regs);
+	}
+	if (irq & 0x4) {
+		do_IRQ(PNX8550_INT_TIMER3, regs);
+	}
+}
+
+static inline void modify_cp0_intmask(unsigned clr_mask, unsigned set_mask)
+{
+	unsigned long status = read_c0_status();
+
+	status &= ~((clr_mask & 0xFF) << 8);
+	status |= (set_mask & 0xFF) << 8;
+
+	write_c0_status(status);
+}
+
+static inline void mask_gic_int(unsigned int irq_nr)
+{
+	/* interrupt disabled, bit 26(WE_ENABLE)=1 and bit 16(enable)=0 */
+	PNX8550_GIC_REQ(irq_nr) = 1<<28; /* set priority to 0 */
+}
+
+static inline void unmask_gic_int(unsigned int irq_nr)
+{
+	/* set prio mask to lower four bits and enable interrupt */
+	PNX8550_GIC_REQ(irq_nr) = (1<<26 | 1<<16) | (1<<28) | gic_prio[irq_nr];
+}
+
+static inline void mask_irq(unsigned int irq_nr)
+{
+	if ((PNX8550_INT_CP0_MIN <= irq_nr) && (irq_nr <= PNX8550_INT_CP0_MAX)) {
+		modify_cp0_intmask(1 << irq_nr, 0);
+	} else if ((PNX8550_INT_GIC_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_GIC_MAX)) {
+		mask_gic_int(irq_nr - PNX8550_INT_GIC_MIN);
+	} else if ((PNX8550_INT_TIMER_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_TIMER_MAX)) {
+		modify_cp0_intmask(1 << 7, 0);
+	} else {
+		printk("mask_irq: irq %d doesn't exist!\n", irq_nr);
+	}
+}
+
+static inline void unmask_irq(unsigned int irq_nr)
+{
+	if ((PNX8550_INT_CP0_MIN <= irq_nr) && (irq_nr <= PNX8550_INT_CP0_MAX)) {
+		modify_cp0_intmask(0, 1 << irq_nr);
+	} else if ((PNX8550_INT_GIC_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_GIC_MAX)) {
+		unmask_gic_int(irq_nr - PNX8550_INT_GIC_MIN);
+	} else if ((PNX8550_INT_TIMER_MIN <= irq_nr) &&
+		(irq_nr <= PNX8550_INT_TIMER_MAX)) {
+		modify_cp0_intmask(0, 1 << 7);
+	} else {
+		printk("mask_irq: irq %d doesn't exist!\n", irq_nr);
+	}
+}
+
+#define pnx8550_disable pnx8550_ack
+static void pnx8550_ack(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_lock, flags);
+	mask_irq(irq);
+	spin_unlock_irqrestore(&irq_lock, flags);
+}
+
+#define pnx8550_enable pnx8550_unmask
+static void pnx8550_unmask(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&irq_lock, flags);
+	unmask_irq(irq);
+	spin_unlock_irqrestore(&irq_lock, flags);
+}
+
+static unsigned int startup_irq(unsigned int irq_nr)
+{
+	pnx8550_unmask(irq_nr);
+	return 0;
+}
+
+static void shutdown_irq(unsigned int irq_nr)
+{
+	pnx8550_ack(irq_nr);
+	return;
+}
+
+int pnx8550_set_gic_priority(int irq, int priority)
+{
+	int gic_irq = irq-PNX8550_INT_GIC_MIN;
+	int prev_priority = PNX8550_GIC_REQ(gic_irq) & 0xf;
+
+        gic_prio[gic_irq] = priority;
+	PNX8550_GIC_REQ(gic_irq) |= (0x10000000 | gic_prio[gic_irq]);
+
+	return prev_priority;
+}
+
+static inline void mask_and_ack_level_irq(unsigned int irq)
+{
+	pnx8550_disable(irq);
+	return;
+}
+
+static void end_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		pnx8550_enable(irq);
+	}
+}
+
+static struct hw_interrupt_type level_irq_type = {
+	.typename =	"PNX Level IRQ",
+	.startup =	startup_irq,
+	.shutdown =	shutdown_irq,
+	.enable =	pnx8550_enable,
+	.disable =	pnx8550_disable,
+	.ack =		mask_and_ack_level_irq,
+	.end =		end_irq,
+};
+
+static struct irqaction gic_action = {
+	.handler =	no_action,
+	.flags =	SA_INTERRUPT,
+	.name =		"GIC",
+};
+
+static struct irqaction timer_action = {
+	.handler =	no_action,
+	.flags =	SA_INTERRUPT,
+	.name =		"Timer",
+};
+
+void __init arch_init_irq(void)
+{
+	int i;
+	int configPR;
+
+	/* init of cp0 interrupts */
+	set_except_vector(0, cp0_irqdispatch);
+
+	for (i = 0; i < PNX8550_INT_CP0_TOTINT; i++) {
+		irq_desc[i].handler = &level_irq_type;
+		pnx8550_ack(i);	/* mask the irq just in case  */
+	}
+
+	/* init of GIC/IPC interrupts */
+	/* should be done before cp0 since cp0 init enables the GIC int */
+	for (i = PNX8550_INT_GIC_MIN; i <= PNX8550_INT_GIC_MAX; i++) {
+		int gic_int_line = i - PNX8550_INT_GIC_MIN;
+		if (gic_int_line == 0 )
+			continue;	// don't fiddle with int 0
+		/*
+		 * enable change of TARGET, ENABLE and ACTIVE_LOW bits
+		 * set TARGET        0 to route through hw0 interrupt
+		 * set ACTIVE_LOW    0 active high  (correct?)
+		 *
+		 * We really should setup an interrupt description table
+		 * to do this nicely.
+		 * Note, PCI INTA is active low on the bus, but inverted
+		 * in the GIC, so to us it's active high.
+		 */
+#ifdef CONFIG_PNX8550_V2PCI
+		if (gic_int_line == (PNX8550_INT_GPIO0 - PNX8550_INT_GIC_MIN)) {
+			/* PCI INT through gpio 8, which is setup in
+			 * pnx8550_setup.c and routed to GPIO
+ 			 * Interrupt Level 0 (GPIO Connection 58).
+			 * Set it active low. */
+
+			PNX8550_GIC_REQ(gic_int_line) = 0x1E020000;
+		} else
+#endif
+		{
+			PNX8550_GIC_REQ(i - PNX8550_INT_GIC_MIN) = 0x1E000000;
+		}
+
+		/* mask/priority is still 0 so we will not get any
+		 * interrupts until it is unmasked */
+
+		irq_desc[i].handler = &level_irq_type;
+	}
+
+	/* Priority level 0 */
+	PNX8550_GIC_PRIMASK_0 = PNX8550_GIC_PRIMASK_1 = 0;
+
+	/* Set int vector table address */
+	PNX8550_GIC_VECTOR_0 = PNX8550_GIC_VECTOR_1 = 0;
+
+	irq_desc[MIPS_CPU_GIC_IRQ].handler = &level_irq_type;
+	setup_irq(MIPS_CPU_GIC_IRQ, &gic_action);
+
+	/* init of Timer interrupts */
+	for (i = PNX8550_INT_TIMER_MIN; i <= PNX8550_INT_TIMER_MAX; i++) {
+		irq_desc[i].handler = &level_irq_type;
+	}
+
+	/* Stop Timer 1-3 */
+	configPR = read_c0_config7();
+	configPR |= 0x00000038;
+	write_c0_config7(configPR);
+
+	irq_desc[MIPS_CPU_TIMER_IRQ].handler = &level_irq_type;
+	setup_irq(MIPS_CPU_TIMER_IRQ, &timer_action);
+}
+
+EXPORT_SYMBOL(pnx8550_set_gic_priority);
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/Kconfig linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/Kconfig
--- linux-2.6.14/arch/mips/philips/pnx8550/common/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1 @@
+# Place holder
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/Makefile linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/Makefile
--- linux-2.6.14/arch/mips/philips/pnx8550/common/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/Makefile	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,27 @@
+#
+# Per Hallsmark, per.hallsmark@mvista.com
+#
+# ########################################################################
+#
+# This program is free software; you can distribute it and/or modify it
+# under the terms of the GNU General Public License (Version 2) as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+#
+# #######################################################################
+#
+# Makefile for the PNX8550 specific kernel interface routines
+# under Linux.
+#
+
+obj-y := setup.o prom.o mipsIRQ.o int.o reset.o time.o proc.o platform.o
+obj-$(CONFIG_PCI) += pci.o
+obj-$(CONFIG_KGDB) += gdb_hook.o
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/mipsIRQ.S linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/mipsIRQ.S
--- linux-2.6.14/arch/mips/philips/pnx8550/common/mipsIRQ.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/mipsIRQ.S	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2002 Philips, Inc. All rights.
+ * Copyright (c) 2002 Red Hat, Inc. All rights.
+ *
+ * This software may be freely redistributed under the terms of the
+ * GNU General Public License.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Based upon arch/mips/galileo-boards/ev64240/int-handler.S
+ *
+ */
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ * cp0_irqdispatch
+ *
+ *    Code to handle in-core interrupt exception.
+ */
+
+		.align	5
+		.set	reorder
+		.set	noat
+		NESTED(cp0_irqdispatch, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+		mfc0	t0,CP0_CAUSE
+		mfc0	t2,CP0_STATUS
+
+		and	t0,t2
+
+		andi	t1,t0,STATUSF_IP2 /* int0 hardware line */
+		bnez	t1,ll_hw0_irq
+		nop
+
+		andi	t1,t0,STATUSF_IP7 /* int5 hardware line */
+		bnez	t1,ll_timer_irq
+		nop
+
+		/* wrong alarm or masked ... */
+
+		j	spurious_interrupt
+		nop
+		END(cp0_irqdispatch)
+
+		.align	5
+		.set	reorder
+ll_hw0_irq:
+		li	a0,2
+		move	a1,sp
+		jal	hw0_irqdispatch
+		nop
+		j	ret_from_irq
+		nop
+
+		.align	5
+		.set	reorder
+ll_timer_irq:
+		mfc0	t3,CP0_CONFIG,7
+		andi	t4,t3,0x01c0
+		beqz	t4,ll_timer_out
+		nop
+		li	a0,7
+		move	a1,sp
+		jal	timer_irqdispatch
+		nop
+
+ll_timer_out:	j	ret_from_irq
+		nop
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/pci.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/pci.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/pci.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/pci.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,133 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <pci.h>
+#include <glb.h>
+#include <nand.h>
+
+static struct resource pci_io_resource = {
+	"pci IO space",
+	(u32)(PNX8550_PCIIO + 0x1000),	/* reserve regacy I/O space */
+	(u32)(PNX8550_PCIIO + PNX8550_PCIIO_SIZE),
+	IORESOURCE_IO
+};
+
+static struct resource pci_mem_resource = {
+	"pci memory space",
+	(u32)(PNX8550_PCIMEM),
+	(u32)(PNX8550_PCIMEM + PNX8550_PCIMEM_SIZE - 1),
+	IORESOURCE_MEM
+};
+
+extern struct pci_ops pnx8550_pci_ops;
+
+static struct pci_controller pnx8550_controller = {
+	.pci_ops	= &pnx8550_pci_ops,
+	.io_resource	= &pci_io_resource,
+	.mem_resource	= &pci_mem_resource,
+};
+
+/* Return the total size of DRAM-memory, (RANK0 + RANK1) */
+static inline unsigned long get_system_mem_size(void)
+{
+	/* Read IP2031_RANK0_ADDR_LO */
+	unsigned long dram_r0_lo = inl(PCI_BASE | 0x65010);
+	/* Read IP2031_RANK1_ADDR_HI */
+	unsigned long dram_r1_hi = inl(PCI_BASE | 0x65018);
+
+	return dram_r1_hi - dram_r0_lo + 1;
+}
+
+static int __init pnx8550_pci_setup(void)
+{
+	int pci_mem_code;
+	int mem_size = get_system_mem_size() >> 20;
+
+	/* Clear the Global 2 Register, PCI Inta Output Enable Registers
+	   Bit 1:Enable DAC Powerdown
+	  -> 0:DACs are enabled and are working normally
+	     1:DACs are powerdown
+	   Bit 0:Enable of PCI inta output
+	  -> 0 = Disable PCI inta output
+	     1 = Enable PCI inta output
+	*/
+	PNX8550_GLB2_ENAB_INTA_O = 0;
+
+	/* Calc the PCI mem size code */
+	if (mem_size >= 128)
+		pci_mem_code = SIZE_128M;
+	else if (mem_size >= 64)
+		pci_mem_code = SIZE_64M;
+	else if (mem_size >= 32)
+		pci_mem_code = SIZE_32M;
+	else
+		pci_mem_code = SIZE_16M;
+
+	/* Set PCI_XIO registers */
+	outl(pci_mem_resource.start, PCI_BASE | PCI_BASE1_LO);
+	outl(pci_mem_resource.end + 1, PCI_BASE | PCI_BASE1_HI);
+	outl(pci_io_resource.start, PCI_BASE | PCI_BASE2_LO);
+	outl(pci_io_resource.end, PCI_BASE | PCI_BASE2_HI);
+
+	/* Send memory transaction via PCI_BASE2 */
+	outl(0x00000001, PCI_BASE | PCI_IO);
+
+	/* Unlock the setup register */
+	outl(0xca, PCI_BASE | PCI_UNLOCKREG);
+
+	/*
+	 * BAR0 of PNX8550 (pci base 10) must be zero in order for ide
+	 * to work, and in order for bus_to_baddr to work without any
+	 * hacks.
+	 */
+	outl(0x00000000, PCI_BASE | PCI_BASE10);
+
+	/*
+	 *These two bars are set by default or the boot code.
+	 * However, it's safer to set them here so we're not boot
+	 * code dependent.
+	 */
+	outl(0x1be00000, PCI_BASE | PCI_BASE14);  /* PNX MMIO */
+	outl(PNX8550_NAND_BASE_ADDR, PCI_BASE | PCI_BASE18);  /* XIO      */
+
+	outl(PCI_EN_TA |
+	     PCI_EN_PCI2MMI |
+	     PCI_EN_XIO |
+	     PCI_SETUP_BASE18_SIZE(SIZE_32M) |
+	     PCI_SETUP_BASE18_EN |
+	     PCI_SETUP_BASE14_EN |
+	     PCI_SETUP_BASE10_PREF |
+	     PCI_SETUP_BASE10_SIZE(pci_mem_code) |
+	     PCI_SETUP_CFGMANAGE_EN |
+	     PCI_SETUP_PCIARB_EN,
+	     PCI_BASE |
+	     PCI_SETUP);	/* PCI_SETUP */
+	outl(0x00000000, PCI_BASE | PCI_CTRL);	/* PCI_CONTROL */
+
+	register_pci_controller(&pnx8550_controller);
+
+	return 0;
+}
+
+arch_initcall(pnx8550_pci_setup);
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/platform.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/platform.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/platform.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/platform.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,135 @@
+/*
+ * Platform device support for Philips PNX8550 SoCs
+ *
+ * Copyright 2005, Embedded Alley Solutions, Inc
+ *
+ * Based on arch/mips/au1000/common/platform.c
+ * Platform device support for Au1x00 SoCs.
+ *
+ * Copyright 2004, Matt Porter <mporter@kernel.crashing.org>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+#include <linux/serial.h>
+#include <linux/serial_ip3106.h>
+
+#include <int.h>
+#include <usb.h>
+#include <uart.h>
+
+extern struct uart_ops ip3106_pops;
+
+static struct resource pnx8550_usb_ohci_resources[] = {
+	[0] = {
+		.start		= PNX8550_USB_OHCI_OP_BASE,
+		.end		= PNX8550_USB_OHCI_OP_BASE +
+				  PNX8550_USB_OHCI_OP_LEN,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= PNX8550_INT_USB,
+		.end		= PNX8550_INT_USB,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource pnx8550_uart_resources[] = {
+	[0] = {
+		.start		= PNX8550_UART_PORT0,
+		.end		= PNX8550_UART_PORT0 + 0xfff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= PNX8550_UART_INT(0),
+		.end		= PNX8550_UART_INT(0),
+		.flags		= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start		= PNX8550_UART_PORT1,
+		.end		= PNX8550_UART_PORT1 + 0xfff,
+		.flags		= IORESOURCE_MEM,
+	},
+	[3] = {
+		.start		= PNX8550_UART_INT(1),
+		.end		= PNX8550_UART_INT(1),
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct ip3106_port ip3106_ports[] = {
+	[0] = {
+		.port   = {
+			.type		= PORT_IP3106,
+			.iotype		= SERIAL_IO_MEM,
+			.membase	= (void __iomem *)PNX8550_UART_PORT0,
+			.mapbase	= PNX8550_UART_PORT0,
+			.irq		= PNX8550_UART_INT(0),
+			.uartclk	= 3692300,
+			.fifosize	= 16,
+			.ops		= &ip3106_pops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 0,
+		},
+	},
+	[1] = {
+		.port   = {
+			.type		= PORT_IP3106,
+			.iotype		= SERIAL_IO_MEM,
+			.membase	= (void __iomem *)PNX8550_UART_PORT1,
+			.mapbase	= PNX8550_UART_PORT1,
+			.irq		= PNX8550_UART_INT(1),
+			.uartclk	= 3692300,
+			.fifosize	= 16,
+			.ops		= &ip3106_pops,
+			.flags		= ASYNC_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static u64 uart_dmamask = ~(u32)0;
+
+static struct platform_device pnx8550_usb_ohci_device = {
+	.name		= "pnx8550-ohci",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(pnx8550_usb_ohci_resources),
+	.resource	= pnx8550_usb_ohci_resources,
+};
+
+static struct platform_device pnx8550_uart_device = {
+	.name		= "ip3106-uart",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &uart_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data = ip3106_ports,
+	},
+	.num_resources	= ARRAY_SIZE(pnx8550_uart_resources),
+	.resource	= pnx8550_uart_resources,
+};
+
+static struct platform_device *pnx8550_platform_devices[] __initdata = {
+	&pnx8550_usb_ohci_device,
+	&pnx8550_uart_device,
+};
+
+int pnx8550_platform_init(void)
+{
+	return platform_add_devices(pnx8550_platform_devices,
+			            ARRAY_SIZE(pnx8550_platform_devices));
+}
+
+arch_initcall(pnx8550_platform_init);
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/proc.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/proc.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/proc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/proc.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,113 @@
+/*
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/random.h>
+
+#include <asm/io.h>
+#include <asm/gdb-stub.h>
+#include <int.h>
+#include <uart.h>
+
+
+static int pnx8550_timers_read (char* page, char** start, off_t offset, int count, int* eof, void* data)
+{
+        int len = 0;
+	int configPR = read_c0_config7();
+
+        if (offset==0) {
+		len += sprintf(&page[len],"Timer:       count,  compare, tc, status\n");
+                len += sprintf(&page[len],"    1: %11i, %8i,  %1i, %s\n",
+			       read_c0_count(), read_c0_compare(),
+			      (configPR>>6)&0x1, ((configPR>>3)&0x1)? "off":"on");
+                len += sprintf(&page[len],"    2: %11i, %8i,  %1i, %s\n",
+			       read_c0_count2(), read_c0_compare2(),
+			      (configPR>>7)&0x1, ((configPR>>4)&0x1)? "off":"on");
+                len += sprintf(&page[len],"    3: %11i, %8i,  %1i, %s\n",
+			       read_c0_count3(), read_c0_compare3(),
+			      (configPR>>8)&0x1, ((configPR>>5)&0x1)? "off":"on");
+        }
+
+        return len;
+}
+
+static int pnx8550_registers_read (char* page, char** start, off_t offset, int count, int* eof, void* data)
+{
+        int len = 0;
+
+        if (offset==0) {
+                len += sprintf(&page[len],"config1:   %#10.8x\n",read_c0_config1());
+                len += sprintf(&page[len],"config2:   %#10.8x\n",read_c0_config2());
+                len += sprintf(&page[len],"config3:   %#10.8x\n",read_c0_config3());
+                len += sprintf(&page[len],"configPR:  %#10.8x\n",read_c0_config7());
+                len += sprintf(&page[len],"status:    %#10.8x\n",read_c0_status());
+                len += sprintf(&page[len],"cause:     %#10.8x\n",read_c0_cause());
+                len += sprintf(&page[len],"count:     %#10.8x\n",read_c0_count());
+                len += sprintf(&page[len],"count_2:   %#10.8x\n",read_c0_count2());
+                len += sprintf(&page[len],"count_3:   %#10.8x\n",read_c0_count3());
+                len += sprintf(&page[len],"compare:   %#10.8x\n",read_c0_compare());
+                len += sprintf(&page[len],"compare_2: %#10.8x\n",read_c0_compare2());
+                len += sprintf(&page[len],"compare_3: %#10.8x\n",read_c0_compare3());
+        }
+
+        return len;
+}
+
+static struct proc_dir_entry* pnx8550_dir        = NULL;
+static struct proc_dir_entry* pnx8550_timers     = NULL;
+static struct proc_dir_entry* pnx8550_registers  = NULL;
+
+static int pnx8550_proc_init( void )
+{
+
+	// Create /proc/pnx8550
+        pnx8550_dir = create_proc_entry("pnx8550", S_IFDIR|S_IRUGO, NULL);
+        if (pnx8550_dir){
+                pnx8550_dir->nlink = 1;
+        }
+        else {
+                printk(KERN_ERR "Can't create pnx8550 proc dir\n");
+                return -1;
+        }
+
+	// Create /proc/pnx8550/timers
+        pnx8550_timers = create_proc_entry("timers", S_IFREG|S_IRUGO, pnx8550_dir );
+        if (pnx8550_timers){
+                pnx8550_timers->nlink = 1;
+                pnx8550_timers->read_proc = pnx8550_timers_read;
+        }
+        else {
+                printk(KERN_ERR "Can't create pnx8550 timers proc file\n");
+        }
+
+	// Create /proc/pnx8550/registers
+        pnx8550_registers = create_proc_entry("registers", S_IFREG|S_IRUGO, pnx8550_dir );
+        if (pnx8550_registers){
+                pnx8550_registers->nlink = 1;
+                pnx8550_registers->read_proc = pnx8550_registers_read;
+        }
+        else {
+                printk(KERN_ERR "Can't create pnx8550 registers proc file\n");
+        }
+
+	return 0;
+}
+
+__initcall(pnx8550_proc_init);
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/prom.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/prom.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/prom.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/prom.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,138 @@
+/*
+ *
+ * Per Hallsmark, per.hallsmark@mvista.com
+ *
+ * Based on jmr3927/common/prom.c
+ *
+ * 2004 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/bootinfo.h>
+#include <uart.h>
+
+/* #define DEBUG_CMDLINE */
+
+extern int prom_argc;
+extern char **prom_argv, **prom_envp;
+
+typedef struct
+{
+    char *name;
+/*    char *val; */
+}t_env_var;
+
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	*cp = '\0';
+}
+
+char *prom_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * Environment variables are stored in the form of "memsize=64".
+	 */
+
+	t_env_var *env = (t_env_var *)prom_envp;
+	int i;
+
+	i = strlen(envname);
+
+	while(env->name) {
+		if(strncmp(envname, env->name, i) == 0) {
+			return(env->name + strlen(envname) + 1);
+		}
+		env++;
+	}
+	return(NULL);
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+	return 0;
+}
+
+unsigned long __init prom_free_prom_memory(void)
+{
+	return 0;
+}
+
+extern int pnx8550_console_port;
+
+/* used by prom_printf */
+void prom_putchar(char c)
+{
+	if (pnx8550_console_port != -1) {
+		/* Wait until FIFO not full */
+		while( ((ip3106_fifo(UART_BASE, pnx8550_console_port) & IP3106_UART_FIFO_TXFIFO) >> 16) >= 16)
+			;
+		/* Send one char */
+		ip3106_fifo(UART_BASE, pnx8550_console_port) = c;
+	}
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/reset.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/reset.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/reset.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/reset.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,49 @@
+/*.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Reset the PNX8550 board.
+ *
+ */
+#include <linux/slab.h>
+#include <asm/reboot.h>
+#include <glb.h>
+
+void pnx8550_machine_restart(char *command)
+{
+	char head[] = "************* Machine restart *************";
+	char foot[] = "*******************************************";
+
+	printk("\n\n");
+	printk("%s\n", head);
+	if (command != NULL)
+		printk("* %s\n", command);
+	printk("%s\n", foot);
+
+	PNX8550_RST_CTL = PNX8550_RST_DO_SW_RST;
+}
+
+void pnx8550_machine_halt(void)
+{
+	printk("*** Machine halt. (Not implemented) ***\n");
+}
+
+void pnx8550_machine_power_off(void)
+{
+	printk("*** Machine power off.  (Not implemented) ***\n");
+}
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/setup.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/setup.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,149 @@
+/*
+ *
+ * 2.6 port, Embedded Alley Solutions, Inc
+ *
+ *  Based on Per Hallsmark, per.hallsmark@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+
+#include <glb.h>
+#include <int.h>
+#include <pci.h>
+#include <uart.h>
+#include <nand.h>
+
+extern void prom_printf(char *fmt, ...);
+
+extern void __init board_setup(void);
+extern void pnx8550_machine_restart(char *);
+extern void pnx8550_machine_halt(void);
+extern void pnx8550_machine_power_off(void);
+extern struct resource ioport_resource;
+extern struct resource iomem_resource;
+extern void (*board_time_init)(void);
+extern void pnx8550_time_init(void);
+extern void (*board_timer_setup)(struct irqaction *irq);
+extern void pnx8550_timer_setup(struct irqaction *irq);
+extern void rs_kgdb_hook(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern char *prom_getcmdline(void);
+
+struct resource standard_io_resources[] = {
+	{"dma1", 0x00, 0x1f, IORESOURCE_BUSY},
+	{"timer", 0x40, 0x5f, IORESOURCE_BUSY},
+	{"dma page reg", 0x80, 0x8f, IORESOURCE_BUSY},
+	{"dma2", 0xc0, 0xdf, IORESOURCE_BUSY},
+};
+
+#define STANDARD_IO_RESOURCES (sizeof(standard_io_resources)/sizeof(struct resource))
+
+extern struct resource pci_io_resource;
+extern struct resource pci_mem_resource;
+
+/* Return the total size of DRAM-memory, (RANK0 + RANK1) */
+unsigned long get_system_mem_size(void)
+{
+	/* Read IP2031_RANK0_ADDR_LO */
+	unsigned long dram_r0_lo = inl(PCI_BASE | 0x65010);
+	/* Read IP2031_RANK1_ADDR_HI */
+	unsigned long dram_r1_hi = inl(PCI_BASE | 0x65018);
+
+	return dram_r1_hi - dram_r0_lo + 1;
+}
+
+int pnx8550_console_port = -1;
+
+void __init plat_setup(void)
+{
+	int i;
+	char* argptr;
+
+	board_setup();  /* board specific setup */
+
+        _machine_restart = pnx8550_machine_restart;
+        _machine_halt = pnx8550_machine_halt;
+        _machine_power_off = pnx8550_machine_power_off;
+
+	board_time_init = pnx8550_time_init;
+	board_timer_setup = pnx8550_timer_setup;
+
+	/* Clear the Global 2 Register, PCI Inta Output Enable Registers
+	   Bit 1:Enable DAC Powerdown
+	  -> 0:DACs are enabled and are working normally
+	     1:DACs are powerdown
+	   Bit 0:Enable of PCI inta output
+	  -> 0 = Disable PCI inta output
+	     1 = Enable PCI inta output
+	*/
+	PNX8550_GLB2_ENAB_INTA_O = 0;
+
+	/* IO/MEM resources. */
+	set_io_port_base(KSEG1);
+	ioport_resource.start = 0;
+	ioport_resource.end = ~0;
+	iomem_resource.start = 0;
+	iomem_resource.end = ~0;
+
+	/* Request I/O space for devices on this board */
+	for (i = 0; i < STANDARD_IO_RESOURCES; i++)
+		request_resource(&ioport_resource, standard_io_resources + i);
+
+	/* Place the Mode Control bit for GPIO pin 16 in primary function */
+	/* Pin 16 is used by UART1, UA1_TX                                */
+	outl((PNX8550_GPIO_MODE_PRIMOP << PNX8550_GPIO_MC_16_BIT) |
+			(PNX8550_GPIO_MODE_PRIMOP << PNX8550_GPIO_MC_17_BIT),
+			PNX8550_GPIO_MC1);
+
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "console=ttyS")) != NULL) {
+		argptr += strlen("console=ttyS");
+		pnx8550_console_port = *argptr == '0' ? 0 : 1;
+
+		/* We must initialize the UART (console) before prom_printf */
+		/* Set LCR to 8-bit and BAUD to 38400 (no 5)                */
+		ip3106_lcr(UART_BASE, pnx8550_console_port) =
+			IP3106_UART_LCR_8BIT;
+		ip3106_baud(UART_BASE, pnx8550_console_port) = 5;
+	}
+
+#ifdef CONFIG_KGDB
+	argptr = prom_getcmdline();
+	if ((argptr = strstr(argptr, "kgdb=ttyS")) != NULL) {
+		int line;
+		argptr += strlen("kgdb=ttyS");
+		line = *argptr == '0' ? 0 : 1;
+		rs_kgdb_hook(line);
+		prom_printf("KGDB: Using ttyS%i for session, "
+				"please connect your debugger\n", line ? 1 : 0);
+	}
+#endif
+	return;
+}
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/common/time.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/time.c
--- linux-2.6.14/arch/mips/philips/pnx8550/common/time.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/common/time.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2001, 2002, 2003 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Common time service routines for MIPS machines. See
+ * Documents/MIPS/README.txt.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/smp.h>
+#include <linux/kernel_stat.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+#include <asm/hardirq.h>
+#include <asm/div64.h>
+#include <asm/debug.h>
+
+#include <int.h>
+#include <cm.h>
+
+extern unsigned int mips_hpt_frequency;
+
+/*
+ * pnx8550_time_init() - it does the following things:
+ *
+ * 1) board_time_init() -
+ * 	a) (optional) set up RTC routines,
+ *      b) (optional) calibrate and set the mips_hpt_frequency
+ *	    (only needed if you intended to use fixed_rate_gettimeoffset
+ *	     or use cpu counter as timer interrupt source)
+ */
+
+void pnx8550_time_init(void)
+{
+	unsigned int             n;
+	unsigned int             m;
+	unsigned int             p;
+	unsigned int             pow2p;
+
+        /* PLL0 sets MIPS clock (PLL1 <=> TM1, PLL6 <=> TM2, PLL5 <=> mem) */
+        /* (but only if CLK_MIPS_CTL select value [bits 3:1] is 1:  FIXME) */
+
+        n = (PNX8550_CM_PLL0_CTL & PNX8550_CM_PLL_N_MASK) >> 16;
+        m = (PNX8550_CM_PLL0_CTL & PNX8550_CM_PLL_M_MASK) >> 8;
+        p = (PNX8550_CM_PLL0_CTL & PNX8550_CM_PLL_P_MASK) >> 2;
+	pow2p = (1 << p);
+
+	db_assert(m != 0 && pow2p != 0);
+
+        /*
+	 * Compute the frequency as in the PNX8550 User Manual 1.0, p.186
+	 * (a.k.a. 8-10).  Divide by HZ for a timer offset that results in
+	 * HZ timer interrupts per second.
+	 */
+	mips_hpt_frequency = 27UL * ((1000000UL * n)/(m * pow2p));
+}
+
+/*
+ * pnx8550_timer_setup() - it does the following things:
+ *
+ * 5) board_timer_setup() -
+ *	a) (optional) over-write any choices made above by time_init().
+ *	b) machine specific code should setup the timer irqaction.
+ *	c) enable the timer interrupt
+ */
+
+void __init pnx8550_timer_setup(struct irqaction *irq)
+{
+	int configPR;
+
+	setup_irq(PNX8550_INT_TIMER1, irq);
+
+	/* Start timer1 */
+	configPR = read_c0_config7();
+	configPR &= ~0x00000008;
+	write_c0_config7(configPR);
+
+	/* Timer 2 stop */
+	configPR = read_c0_config7();
+	configPR |= 0x00000010;
+	write_c0_config7(configPR);
+
+	write_c0_count2(0);
+	write_c0_compare2(0xffffffff);
+
+	/* Timer 3 stop */
+	configPR = read_c0_config7();
+	configPR |= 0x00000020;
+	write_c0_config7(configPR);
+}
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/jbs/board_setup.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/board_setup.c
--- linux-2.6.14/arch/mips/philips/pnx8550/jbs/board_setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/board_setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,65 @@
+/*
+ *  JBS Specific board startup routines.
+ *
+ *  Copyright 2005, Embedded Alley Solutions, Inc
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+
+#include <glb.h>
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+
+void __init board_setup(void)
+{
+	unsigned long config0, configpr;
+
+	config0 = read_c0_config();
+
+	/* clear all three cache coherency fields */
+	config0 &= ~(0x7 | (7<<25) | (7<<28));
+	config0 |= (CONF_CM_DEFAULT | (CONF_CM_DEFAULT<<25) |
+			(CONF_CM_DEFAULT<<28));
+	write_c0_config(config0);
+	BARRIER;
+
+	configpr = read_c0_config7();
+	configpr |= (1<<19); /* enable tlb */
+	write_c0_config7(configpr);
+	BARRIER;
+}
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/jbs/init.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/init.c
--- linux-2.6.14/arch/mips/philips/pnx8550/jbs/init.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/init.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,57 @@
+/*
+ *
+ *  Copyright 2005 Embedded Alley Solutions, Inc
+ *  source@embeddedalley.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "Philips PNX8550/JBS";
+}
+
+void __init prom_init(void)
+{
+
+	unsigned long memsize;
+
+	mips_machgroup = MACH_GROUP_PHILIPS;
+	mips_machtype = MACH_PHILIPS_JBS;
+
+	//memsize = 0x02800000; /* Trimedia uses memory above */
+	memsize = 0x08000000; /* Trimedia uses memory above */
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/jbs/irqmap.c linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/irqmap.c
--- linux-2.6.14/arch/mips/philips/pnx8550/jbs/irqmap.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/irqmap.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,36 @@
+/*
+ *  Philips JBS board irqmap.
+ *
+ *  Copyright 2005 Embedded Alley Solutions, Inc
+ *  source@embeddealley.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <int.h>
+
+char irq_tab_jbs[][5] __initdata = {
+ [8] =	{ -1, PNX8550_INT_PCI_INTA, 0xff, 0xff, 0xff},
+ [9] =	{ -1, PNX8550_INT_PCI_INTA, 0xff, 0xff, 0xff},
+ [17] =	{ -1, PNX8550_INT_PCI_INTA, 0xff, 0xff, 0xff},
+};
+
diff -Naur linux-2.6.14/arch/mips/philips/pnx8550/jbs/Makefile linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/Makefile
--- linux-2.6.14/arch/mips/philips/pnx8550/jbs/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/philips/pnx8550/jbs/Makefile	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,4 @@
+
+# Makefile for the Philips JBS Board.
+
+lib-y := init.o board_setup.o irqmap.o
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/Kconfig linux-mips-2.6.14.orig/arch/mips/pmc-sierra/Kconfig
--- linux-2.6.14/arch/mips/pmc-sierra/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,3 @@
+config HYPERTRANSPORT
+	bool "Hypertransport Support for PMC-Sierra Yosemite"
+	depends on PMC_YOSEMITE
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h
--- linux-2.6.14/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/atmel_read_eeprom.h	2005-11-17 11:42:29.000000000 -0800
@@ -34,7 +34,6 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/version.h>
 #include <asm/pci.h>
 #include <asm/io.h>
 #include <linux/init.h>
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/yosemite/ht.c linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/ht.c
--- linux-2.6.14/arch/mips/pmc-sierra/yosemite/ht.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/ht.c	2005-11-17 11:42:29.000000000 -0800
@@ -28,7 +28,6 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/version.h>
 #include <asm/pci.h>
 #include <asm/io.h>
 
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/yosemite/ht-irq.c linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/ht-irq.c
--- linux-2.6.14/arch/mips/pmc-sierra/yosemite/ht-irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/ht-irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -26,7 +26,6 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
-#include <linux/version.h>
 #include <linux/init.h>
 #include <asm/pci.h>
 
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/yosemite/prom.c linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/prom.c
--- linux-2.6.14/arch/mips/pmc-sierra/yosemite/prom.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/prom.c	2005-11-17 11:42:29.000000000 -0800
@@ -132,8 +132,9 @@
 	prom_grab_secondary();
 }
 
-void __init prom_free_prom_memory(void)
+unsigned long __init prom_free_prom_memory(void)
 {
+	return 0;
 }
 
 void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/yosemite/setup.c linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/setup.c
--- linux-2.6.14/arch/mips/pmc-sierra/yosemite/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -212,7 +212,7 @@
 	py_rtc_setup();
 }
 
-static int __init pmc_yosemite_setup(void)
+void __init plat_setup(void)
 {
 	board_time_init = yosemite_time_init;
 	late_time_init = py_late_time_init;
@@ -228,8 +228,4 @@
 	OCD_WRITE(RM9000x2_OCD_HTBAR0, HYPERTRANSPORT_BAR0_ADDR);
 	OCD_WRITE(RM9000x2_OCD_HTMASK0, HYPERTRANSPORT_SIZE0);
 #endif
-
-	return 0;
 }
-
-early_initcall(pmc_yosemite_setup);
diff -Naur linux-2.6.14/arch/mips/pmc-sierra/yosemite/smp.c linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/smp.c
--- linux-2.6.14/arch/mips/pmc-sierra/yosemite/smp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/pmc-sierra/yosemite/smp.c	2005-11-17 11:42:29.000000000 -0800
@@ -9,7 +9,7 @@
 
 #define LAUNCHSTACK_SIZE 256
 
-static spinlock_t launch_lock __initdata;
+static __initdata DEFINE_SPINLOCK(launch_lock);
 
 static unsigned long secondary_sp __initdata;
 static unsigned long secondary_gp __initdata;
diff -Naur linux-2.6.14/arch/mips/qemu/Makefile linux-mips-2.6.14.orig/arch/mips/qemu/Makefile
--- linux-2.6.14/arch/mips/qemu/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/qemu/Makefile	2005-11-17 11:42:29.000000000 -0800
@@ -2,4 +2,4 @@
 # Makefile for Qemu specific kernel interface routines under Linux.
 #
 
-obj-y		= q-firmware.o q-int.o q-irq.o q-mem.o q-setup.o
+obj-y		= q-firmware.o q-int.o q-irq.o q-mem.o q-setup.o q-vga.o
diff -Naur linux-2.6.14/arch/mips/qemu/q-setup.c linux-mips-2.6.14.orig/arch/mips/qemu/q-setup.c
--- linux-2.6.14/arch/mips/qemu/q-setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/qemu/q-setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -2,8 +2,15 @@
 #include <asm/io.h>
 #include <asm/time.h>
 
+extern void qvga_init(void);
+
 #define QEMU_PORT_BASE 0xb4000000
 
+const char *get_system_type(void)
+{
+	return "Qemu";
+}
+
 static void __init qemu_timer_setup(struct irqaction *irq)
 {
 	/* set the clock to 100 Hz */
@@ -16,5 +23,6 @@
 void __init plat_setup(void)
 {
 	set_io_port_base(QEMU_PORT_BASE);
+	qvga_init();
 	board_timer_setup = qemu_timer_setup;
 }
diff -Naur linux-2.6.14/arch/mips/qemu/q-vga.c linux-mips-2.6.14.orig/arch/mips/qemu/q-vga.c
--- linux-2.6.14/arch/mips/qemu/q-vga.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/qemu/q-vga.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,188 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 by Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This will eventually go into the qemu firmware.
+ */
+#include <linux/init.h>
+#include <linux/tty.h>
+#include <asm/io.h>
+#include <video/vga.h>
+
+/*
+ * This will eventually be done by the firmware; right now Linux assumes to
+ * run on the uninitialized hardware.
+ */
+#undef LOAD_VGA_FONT
+
+static unsigned char sr[8] __initdata = {	/* Sequencer */
+	0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x00, 0x00
+};
+
+static unsigned char gr[16] __initdata= {	/* Graphics Controller */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0e, 0x00,
+	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static unsigned char ar[21] __initdata= {	/* Attribute Controller */
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x0c, 0x01, 0x07, 0x13, 0x00
+};
+
+static unsigned char cr[32] __initdata= {	/* CRT Controller */
+	0x91, 0x4f, 0x4f, 0x95, 0x57, 0x4f, 0xc0, 0x1f,
+	0x00, 0x4f, 0x0d, 0x0e, 0x02, 0x30, 0x09, 0xb0,
+	0x90, 0x83, 0x8f, 0x28, 0x1f, 0x8f, 0xc1, 0xa3,
+	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static struct rgb {
+	unsigned char r;
+	unsigned char g;
+	unsigned char b;
+} palette[16] __initdata= {
+	[ 0] = {0x00, 0x00, 0x00},
+	[ 1] = {0x00, 0x00, 0x2a},
+	[ 2] = {0x00, 0x2a, 0x00},
+	[ 3] = {0x00, 0x2a, 0x2a},
+	[ 4] = {0x2a, 0x00, 0x00},
+	[ 5] = {0x2a, 0x00, 0x2a},
+	[ 6] = {0x2a, 0x15, 0x00},
+	[ 7] = {0x2a, 0x2a, 0x2a},
+	[ 8] = {0x15, 0x15, 0x15},
+	[ 9] = {0x15, 0x15, 0x3f},
+	[10] = {0x15, 0x3f, 0x15},
+	[11] = {0x15, 0x3f, 0x3f},
+	[12] = {0x3f, 0x15, 0x15},
+	[13] = {0x3f, 0x15, 0x3f},
+	[14] = {0x3f, 0x3f, 0x15},
+	[15] = {0x3f, 0x3f, 0x3f}
+
+};
+
+void __init qvga_init_ibm(void)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {	/* Sequencer registers */
+		outb(i, 0x3c4);
+		outb(sr[i], 0x3c5);
+	}
+
+	for (i = 0; i < 16; i++) {	/* Graphics Controller registers */
+		outb(i, 0x3ce);
+		outb(gr[i], 0x3cf);
+	}
+
+	for (i = 0; i < 21; i++) {	/* Attribute Controller registers */
+		outb(i, 0x3c0);
+		outb(ar[i], 0x3c1);
+	}
+	outb(0x20, 0x3c0);		/* enable bit in *index* register */
+
+	for (i = 0; i < 32; i++) {	/* CRT Controller registers */
+		outb(i, 0x3d4);
+		outb(cr[i], 0x3d5);
+	}
+
+	for (i = 0; i < 16; i++) {	/* palette */
+		outb(i, 0x3c8);
+		outb(palette[i].r, 0x3c9);
+		outb(palette[i].g, 0x3c9);
+		outb(palette[i].b, 0x3c9);
+	}
+
+#if 1
+	 for (i = 0; i < 0x20000; i += 2)
+		*(volatile unsigned short *) (0xb00a0000 + i) = 0xaaaa;
+#endif
+}
+
+#ifdef LOAD_VGA_FONT
+#include "/home/ralf/src/qemu/qemu-mips/vgafont.h"
+
+static void __init
+qvga_load_font(unsigned char *def, unsigned int c)
+{
+	volatile void *w = (volatile void *) 0xb00a0000;
+
+	vga_wseq(NULL, 0, 1);
+	vga_wseq(NULL, 2, 4);
+	vga_wseq(NULL, 4, 7);
+	vga_wseq(NULL, 0, 3);
+	vga_wgfx(NULL, 4, 2);
+	vga_wgfx(NULL, 5, 0);
+	vga_wgfx(NULL, 6, 0);
+
+	memcpy(w, def, c);
+
+	vga_wseq(NULL, 0, 1);
+	vga_wseq(NULL, 2, 3);
+	vga_wseq(NULL, 4, 3);
+	vga_wseq(NULL, 0, 3);
+	vga_wgfx(NULL, 4, 0);
+	vga_wgfx(NULL, 5, 0x10);
+	vga_wgfx(NULL, 6, 0xe);
+}
+#endif
+
+void __init qvga_init(void)
+{
+	struct screen_info *si = &screen_info;
+	unsigned int h;
+	int i;
+
+#if LOAD_VGA_FONT
+	qvga_load_font(vgafont16, 4096);
+#endif
+
+	vga_wgfx(NULL, 5, 0x10);	/* Set odd/even mode */
+	vga_wgfx(NULL, 6, 0x0c);	/* map to offset 0xb8000, text mode */
+	vga_wseq(NULL, 2, 3);		/* Planes 0 & 1 */
+	vga_wseq(NULL, 3, 4);		/* Font offset */
+	outb(1, VGA_MIS_W);		/* set msr to MSR_COLOR_EMULATION */
+	vga_wcrt(NULL, 1, 79);		/* 80 columns */
+	vga_wcrt(NULL, 9, 15);		/* 16 pixels per character */
+	vga_wcrt(NULL, 0x0c, 0);	/* start address high 8 bit */
+	vga_wcrt(NULL, 0x0d, 0);	/* start address low 8 bit */
+	vga_wcrt(NULL, 0x13, 0x28);	/* line offset */
+	vga_wcrt(NULL, 0x07, 0x1f);	/* line compare bit 8 */
+	vga_wcrt(NULL, 0x09, 0x4f);	/* line compare bit 9 */
+	vga_wcrt(NULL, 0x18, 0xff);	/* line compare low 8 bit */
+
+	h = (25 * 16);
+	vga_wcrt(NULL, 0x12, h);
+
+	outb(7, 0x3d4);
+	outb((inb(0x3d5) & ~0x42) | ((h >> 7) & 2) | ((h >> 3) & 0x40), 0x3d5);
+
+	for (i = 0; i < 21; i++)	/* Attribute Controller */
+		vga_wattr(NULL, i, ar[i]);
+	outb(0x20, 0x3c0);		/* Set bit 5 in Attribute Controller */
+					/* index ...  VGA is so stupid I want */
+					/* to cry all day ... */
+	outb(0, VGA_PEL_IW);
+	for (i = 0; i < 16; i++) {	/* palette */
+		outb(palette[i].r, VGA_PEL_D);
+		outb(palette[i].g, VGA_PEL_D);
+		outb(palette[i].b, VGA_PEL_D);
+	}
+
+	si->orig_x		= 0; 			/* Cursor x position */
+	si->orig_y		= 0;			/* Cursor y position */
+	si->orig_video_cols	= 80;			/* Columns */
+	si->orig_video_lines	= 25;			/* Lines */
+	si->orig_video_isVGA	= VIDEO_TYPE_VGAC;	/* Card type */
+	si->orig_video_points	= 16;
+
+#if 0
+	for (i = 0; i < 80; i += 2)
+		//*(volatile unsigned short *) (0xb00b8000 + i) = 0x0100 | 'A';
+		scr_writew(0x0100 | 'A', (volatile unsigned short *) (0xb00b8000 + i));
+	while (1);
+#endif
+}
diff -Naur linux-2.6.14/arch/mips/sgi-ip22/ip22-eisa.c linux-mips-2.6.14.orig/arch/mips/sgi-ip22/ip22-eisa.c
--- linux-2.6.14/arch/mips/sgi-ip22/ip22-eisa.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip22/ip22-eisa.c	2005-11-17 11:42:29.000000000 -0800
@@ -29,6 +29,7 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/mipsregs.h>
 #include <asm/addrspace.h>
@@ -37,42 +38,29 @@
 #include <asm/sgi/mc.h>
 #include <asm/sgi/ip22.h>
 
-#define EISA_MAX_SLOTS		  4
+/* I2 has four EISA slots. */
+#define IP22_EISA_MAX_SLOTS	  4
 #define EISA_MAX_IRQ             16
 
-#define EISA_TO_PHYS(x)  (0x00080000 | (x))
-#define EISA_TO_KSEG1(x) ((void *) KSEG1ADDR(EISA_TO_PHYS((x))))
+#define EIU_MODE_REG     0x0001ffc0
+#define EIU_STAT_REG     0x0001ffc4
+#define EIU_PREMPT_REG   0x0001ffc8
+#define EIU_QUIET_REG    0x0001ffcc
+#define EIU_INTRPT_ACK   0x00010004
+
+static char __init *decode_eisa_sig(unsigned long addr)
+{
+        static char sig_str[EISA_SIG_LEN];
+	u8 sig[4];
+        u16 rev;
+	int i;
 
-#define EIU_MODE_REG     0x0009ffc0
-#define EIU_STAT_REG     0x0009ffc4
-#define EIU_PREMPT_REG   0x0009ffc8
-#define EIU_QUIET_REG    0x0009ffcc
-#define EIU_INTRPT_ACK   0x00090004
-
-#define EISA_DMA1_STATUS            8
-#define EISA_INT1_CTRL           0x20
-#define EISA_INT1_MASK           0x21
-#define EISA_INT2_CTRL           0xA0
-#define EISA_INT2_MASK           0xA1
-#define EISA_DMA2_STATUS         0xD0
-#define EISA_DMA2_WRITE_SINGLE   0xD4
-#define EISA_EXT_NMI_RESET_CTRL 0x461
-#define EISA_INT1_EDGE_LEVEL    0x4D0
-#define EISA_INT2_EDGE_LEVEL    0x4D1
-#define EISA_VENDOR_ID_OFFSET   0xC80
-
-#define EIU_WRITE_32(x,y) { *((u32 *) KSEG1ADDR(x)) = (u32) (y); mb(); }
-#define EIU_READ_8(x) *((u8 *) KSEG1ADDR(x))
-#define EISA_WRITE_8(x,y) { *((u8 *) EISA_TO_KSEG1(x)) = (u8) (y); mb(); }
-#define EISA_READ_8(x) *((u8 *) EISA_TO_KSEG1(x))
+	for (i = 0; i < 4; i++) {
+		sig[i] = inb (addr + i);
 
-static char *decode_eisa_sig(u8 * sig)
-{
-	static char sig_str[8];
-	u16 rev;
-
-	if (sig[0] & 0x80)
-		return NULL;
+		if (!i && (sig[0] & 0x80))
+			return NULL;
+	}
 
 	sig_str[0] = ((sig[0] >> 2) & 0x1f) + ('A' - 1);
 	sig_str[1] = (((sig[0] & 3) << 3) | (sig[1] >> 5)) + ('A' - 1);
@@ -83,23 +71,26 @@
 	return sig_str;
 }
 
-static void ip22_eisa_intr(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t ip22_eisa_intr(int irq, void *dev_id, struct pt_regs *regs)
 {
 	u8 eisa_irq;
 	u8 dma1, dma2;
 
-	eisa_irq = EIU_READ_8(EIU_INTRPT_ACK);
-	dma1 = EISA_READ_8(EISA_DMA1_STATUS);
-	dma2 = EISA_READ_8(EISA_DMA2_STATUS);
-
-	if (eisa_irq >= EISA_MAX_IRQ) {
-		/* Oops, Bad Stuff Happened... */
-		printk(KERN_ERR "eisa_irq %d out of bound\n", eisa_irq);
-
-		EISA_WRITE_8(EISA_INT2_CTRL, 0x20);
-		EISA_WRITE_8(EISA_INT1_CTRL, 0x20);
-	} else
+	eisa_irq = inb(EIU_INTRPT_ACK);
+	dma1 = inb(EISA_DMA1_STATUS);
+	dma2 = inb(EISA_DMA2_STATUS);
+
+	if (eisa_irq < EISA_MAX_IRQ) {
 		do_IRQ(eisa_irq, regs);
+		return IRQ_HANDLED;
+	}
+
+	/* Oops, Bad Stuff Happened... */
+	printk(KERN_ERR "eisa_irq %d out of bound\n", eisa_irq);
+
+	outb(0x20, EISA_INT2_CTRL);
+	outb(0x20, EISA_INT1_CTRL);
+	return IRQ_NONE;
 }
 
 static void enable_eisa1_irq(unsigned int irq)
@@ -109,9 +100,9 @@
 
 	local_irq_save(flags);
 
-	mask = EISA_READ_8(EISA_INT1_MASK);
+	mask = inb(EISA_INT1_MASK);
 	mask &= ~((u8) (1 << irq));
-	EISA_WRITE_8(EISA_INT1_MASK, mask);
+	outb(mask, EISA_INT1_MASK);
 
 	local_irq_restore(flags);
 }
@@ -122,9 +113,9 @@
 
 	/* Only use edge interrupts for EISA */
 
-	edge = EISA_READ_8(EISA_INT1_EDGE_LEVEL);
+	edge = inb(EISA_INT1_EDGE_LEVEL);
 	edge &= ~((u8) (1 << irq));
-	EISA_WRITE_8(EISA_INT1_EDGE_LEVEL, edge);
+	outb(edge, EISA_INT1_EDGE_LEVEL);
 
 	enable_eisa1_irq(irq);
 	return 0;
@@ -134,9 +125,9 @@
 {
 	u8 mask;
 
-	mask = EISA_READ_8(EISA_INT1_MASK);
+	mask = inb(EISA_INT1_MASK);
 	mask |= ((u8) (1 << irq));
-	EISA_WRITE_8(EISA_INT1_MASK, mask);
+	outb(mask, EISA_INT1_MASK);
 }
 
 #define shutdown_eisa1_irq	disable_eisa1_irq
@@ -145,7 +136,7 @@
 {
 	disable_eisa1_irq(irq);
 
-	EISA_WRITE_8(EISA_INT1_CTRL, 0x20);
+	outb(0x20, EISA_INT1_CTRL);
 }
 
 static void end_eisa1_irq(unsigned int irq)
@@ -171,9 +162,9 @@
 
 	local_irq_save(flags);
 
-	mask = EISA_READ_8(EISA_INT2_MASK);
+	mask = inb(EISA_INT2_MASK);
 	mask &= ~((u8) (1 << (irq - 8)));
-	EISA_WRITE_8(EISA_INT2_MASK, mask);
+	outb(mask, EISA_INT2_MASK);
 
 	local_irq_restore(flags);
 }
@@ -184,9 +175,9 @@
 
 	/* Only use edge interrupts for EISA */
 
-	edge = EISA_READ_8(EISA_INT2_EDGE_LEVEL);
+	edge = inb(EISA_INT2_EDGE_LEVEL);
 	edge &= ~((u8) (1 << (irq - 8)));
-	EISA_WRITE_8(EISA_INT2_EDGE_LEVEL, edge);
+	outb(edge, EISA_INT2_EDGE_LEVEL);
 
 	enable_eisa2_irq(irq);
 	return 0;
@@ -196,9 +187,9 @@
 {
 	u8 mask;
 
-	mask = EISA_READ_8(EISA_INT2_MASK);
+	mask = inb(EISA_INT2_MASK);
 	mask |= ((u8) (1 << (irq - 8)));
-	EISA_WRITE_8(EISA_INT2_MASK, mask);
+	outb(mask, EISA_INT2_MASK);
 }
 
 #define shutdown_eisa2_irq	disable_eisa2_irq
@@ -207,8 +198,7 @@
 {
 	disable_eisa2_irq(irq);
 
-	EISA_WRITE_8(EISA_INT2_CTRL, 0x20);
-	EISA_WRITE_8(EISA_INT1_CTRL, 0x20);
+	outb(0x20, EISA_INT2_CTRL);
 }
 
 static void end_eisa2_irq(unsigned int irq)
@@ -241,7 +231,6 @@
 {
 	int i, c;
 	char *str;
-	u8 *slot_addr;
 
 	if (!(sgimc->systemid & SGIMC_SYSID_EPRESENT)) {
 		printk(KERN_INFO "EISA: bus not present.\n");
@@ -249,11 +238,8 @@
 	}
 
 	printk(KERN_INFO "EISA: Probing bus...\n");
-	for (c = 0, i = 1; i <= EISA_MAX_SLOTS; i++) {
-		slot_addr =
-		    (u8 *) EISA_TO_KSEG1((0x1000 * i) +
-					 EISA_VENDOR_ID_OFFSET);
-		if ((str = decode_eisa_sig(slot_addr))) {
+	for (c = 0, i = 1; i <= IP22_EISA_MAX_SLOTS; i++) {
+		if ((str = decode_eisa_sig(0x1000 * i + EISA_VENDOR_ID_OFFSET))) {
 			printk(KERN_INFO "EISA: slot %d : %s detected.\n",
 			       i, str);
 			c++;
@@ -268,25 +254,25 @@
 	   Please wave your favorite dead chicken over the busses */
 
 	/* First say hello to the EIU */
-	EIU_WRITE_32(EIU_PREMPT_REG, 0x0000FFFF);
-	EIU_WRITE_32(EIU_QUIET_REG, 1);
-	EIU_WRITE_32(EIU_MODE_REG, 0x40f3c07F);
+	outl(0x0000FFFF, EIU_PREMPT_REG);
+	outl(1, EIU_QUIET_REG);
+	outl(0x40f3c07F, EIU_MODE_REG);
 
 	/* Now be nice to the EISA chipset */
-	EISA_WRITE_8(EISA_EXT_NMI_RESET_CTRL, 1);
-	for (i = 0; i < 10000; i++);	/* Wait long enough for the dust to settle */
-	EISA_WRITE_8(EISA_EXT_NMI_RESET_CTRL, 0);
-	EISA_WRITE_8(EISA_INT1_CTRL, 0x11);
-	EISA_WRITE_8(EISA_INT2_CTRL, 0x11);
-	EISA_WRITE_8(EISA_INT1_MASK, 0);
-	EISA_WRITE_8(EISA_INT2_MASK, 8);
-	EISA_WRITE_8(EISA_INT1_MASK, 4);
-	EISA_WRITE_8(EISA_INT2_MASK, 2);
-	EISA_WRITE_8(EISA_INT1_MASK, 1);
-	EISA_WRITE_8(EISA_INT2_MASK, 1);
-	EISA_WRITE_8(EISA_INT1_MASK, 0xfb);
-	EISA_WRITE_8(EISA_INT2_MASK, 0xff);
-	EISA_WRITE_8(EISA_DMA2_WRITE_SINGLE, 0);
+	outb(1, EISA_EXT_NMI_RESET_CTRL);
+	udelay(50);	/* Wait long enough for the dust to settle */
+	outb(0, EISA_EXT_NMI_RESET_CTRL);
+	outb(0x11, EISA_INT1_CTRL);
+	outb(0x11, EISA_INT2_CTRL);
+	outb(0, EISA_INT1_MASK);
+	outb(8, EISA_INT2_MASK);
+	outb(4, EISA_INT1_MASK);
+	outb(2, EISA_INT2_MASK);
+	outb(1, EISA_INT1_MASK);
+	outb(1, EISA_INT2_MASK);
+	outb(0xfb, EISA_INT1_MASK);
+	outb(0xff, EISA_INT2_MASK);
+	outb(0, EISA_DMA2_WRITE_SINGLE);
 
 	for (i = SGINT_EISA; i < (SGINT_EISA + EISA_MAX_IRQ); i++) {
 		irq_desc[i].status = IRQ_DISABLED;
diff -Naur linux-2.6.14/arch/mips/sgi-ip22/ip22-setup.c linux-mips-2.6.14.orig/arch/mips/sgi-ip22/ip22-setup.c
--- linux-2.6.14/arch/mips/sgi-ip22/ip22-setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip22/ip22-setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -53,7 +53,7 @@
 extern void ip22_be_init(void) __init;
 extern void ip22_time_init(void) __init;
 
-static int __init ip22_setup(void)
+void __init plat_setup(void)
 {
 	char *ctype;
 
@@ -137,8 +137,4 @@
 		}
 	}
 #endif
-
-	return 0;
 }
-
-early_initcall(ip22_setup);
diff -Naur linux-2.6.14/arch/mips/sgi-ip27/ip27-console.c linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-console.c
--- linux-2.6.14/arch/mips/sgi-ip27/ip27-console.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-console.c	2005-11-17 11:42:29.000000000 -0800
@@ -30,8 +30,10 @@
 static inline struct ioc3_uartregs *console_uart(void)
 {
 	struct ioc3 *ioc3;
+	nasid_t nasid;
 
-	ioc3 = (struct ioc3 *)KL_CONFIG_CH_CONS_INFO(get_nasid())->memory_base;
+	nasid = (master_nasid == INVALID_NASID) ? get_nasid() : master_nasid;
+	ioc3 = (struct ioc3 *)KL_CONFIG_CH_CONS_INFO(nasid)->memory_base;
 
 	return &ioc3->sregs.uarta;
 }
diff -Naur linux-2.6.14/arch/mips/sgi-ip27/ip27-init.c linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-init.c
--- linux-2.6.14/arch/mips/sgi-ip27/ip27-init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-init.c	2005-11-17 11:42:29.000000000 -0800
@@ -56,12 +56,12 @@
 {
 	struct hub_data *hub = hub_data(cnode);
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cnode);
+	int i;
 
 	cpu_set(smp_processor_id(), hub->h_cpus);
 
 	if (test_and_set_bit(cnode, hub_init_mask))
 		return;
-
 	/*
 	 * Set CRB timeout at 5ms, (< PI timeout of 10ms)
 	 */
@@ -88,6 +88,24 @@
 		__flush_cache_all();
 	}
 #endif
+
+	/*
+	 * Some interrupts are reserved by hardware or by software convention.
+	 * Mark these as reserved right away so they won't be used accidently
+	 * later.
+	 */
+	for (i = 0; i <= BASE_PCI_IRQ; i++) {
+		__set_bit(i, hub->irq_alloc_mask);
+		LOCAL_HUB_CLR_INTR(INT_PEND0_BASELVL + i);
+	}
+
+	__set_bit(IP_PEND0_6_63, hub->irq_alloc_mask);
+	LOCAL_HUB_S(PI_INT_PEND_MOD, IP_PEND0_6_63);
+
+	for (i = NI_BRDCAST_ERR_A; i <= MSC_PANIC_INTR; i++) {
+		__set_bit(i, hub->irq_alloc_mask);
+		LOCAL_HUB_CLR_INTR(INT_PEND1_BASELVL + i);
+	}
 }
 
 void __init per_cpu_init(void)
@@ -104,30 +122,12 @@
 
 	clear_c0_status(ST0_IM);
 
+	per_hub_init(cnode);
+
 	for (i = 0; i < LEVELS_PER_SLICE; i++)
 		si->level_to_irq[i] = -1;
 
 	/*
-	 * Some interrupts are reserved by hardware or by software convention.
-	 * Mark these as reserved right away so they won't be used accidently
-	 * later.
-	 */
-	for (i = 0; i <= BASE_PCI_IRQ; i++) {
-		__set_bit(i, si->irq_alloc_mask);
-		LOCAL_HUB_S(PI_INT_PEND_MOD, i);
-	}
-
-	__set_bit(IP_PEND0_6_63, si->irq_alloc_mask);
-	LOCAL_HUB_S(PI_INT_PEND_MOD, IP_PEND0_6_63);
-
-	for (i = NI_BRDCAST_ERR_A; i <= MSC_PANIC_INTR; i++) {
-		__set_bit(i, si->irq_alloc_mask + 1);
-		LOCAL_HUB_S(PI_INT_PEND_MOD, i);
-	}
-
-	LOCAL_HUB_L(PI_INT_PEND0);
-
-	/*
 	 * We use this so we can find the local hub's data as fast as only
 	 * possible.
 	 */
@@ -140,8 +140,6 @@
 	install_cpu_nmi_handler(cputoslice(cpu));
 
 	set_c0_status(SRB_DEV0 | SRB_DEV1);
-
-	per_hub_init(cnode);
 }
 
 /*
@@ -198,7 +196,7 @@
 extern void ip27_time_init(void);
 extern void ip27_reboot_setup(void);
 
-static int __init ip27_setup(void)
+void __init plat_setup(void)
 {
 	hubreg_t p, e, n_mode;
 	nasid_t nid;
@@ -245,8 +243,4 @@
 	set_io_port_base(IO_BASE);
 
 	board_time_init = ip27_time_init;
-
-	return 0;
 }
-
-early_initcall(ip27_setup);
diff -Naur linux-2.6.14/arch/mips/sgi-ip27/ip27-irq.c linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-irq.c
--- linux-2.6.14/arch/mips/sgi-ip27/ip27-irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -5,6 +5,9 @@
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 1999 - 2001 Kanoj Sarcar
  */
+
+#undef DEBUG
+
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/irq.h>
@@ -14,11 +17,11 @@
 #include <linux/types.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
-#include <linux/irq.h>
 #include <linux/timex.h>
 #include <linux/slab.h>
 #include <linux/random.h>
 #include <linux/smp_lock.h>
+#include <linux/kernel.h>
 #include <linux/kernel_stat.h>
 #include <linux/delay.h>
 #include <linux/bitops.h>
@@ -37,13 +40,6 @@
 #include <asm/sn/hub.h>
 #include <asm/sn/intr.h>
 
-#undef DEBUG_IRQ
-#ifdef DEBUG_IRQ
-#define DBG(x...) printk(x)
-#else
-#define DBG(x...)
-#endif
-
 /*
  * Linux has a controller-independent x86 interrupt architecture.
  * every controller has a 'controller-template', that is used
@@ -74,14 +70,15 @@
 
 static inline int alloc_level(int cpu, int irq)
 {
+	struct hub_data *hub = hub_data(cpu_to_node(cpu));
 	struct slice_data *si = cpu_data[cpu].data;
-	int level;				/* pre-allocated entries */
+	int level;
 
-	level = find_first_zero_bit(si->irq_alloc_mask, LEVELS_PER_SLICE);
+	level = find_first_zero_bit(hub->irq_alloc_mask, LEVELS_PER_SLICE);
 	if (level >= LEVELS_PER_SLICE)
 		panic("Cpu %d flooded with devices\n", cpu);
 
-	__set_bit(level, si->irq_alloc_mask);
+	__set_bit(level, hub->irq_alloc_mask);
 	si->level_to_irq[level] = irq;
 
 	return level;
@@ -216,9 +213,11 @@
 {
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));
 	struct slice_data *si = cpu_data[cpu].data;
+	unsigned long flags;
 
-	__set_bit(bit, si->irq_enable_mask);
+	set_bit(bit, si->irq_enable_mask);
 
+	local_irq_save(flags);
 	if (!cputoslice(cpu)) {
 		REMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);
 		REMOTE_HUB_S(nasid, PI_INT_MASK1_A, si->irq_enable_mask[1]);
@@ -226,6 +225,7 @@
 		REMOTE_HUB_S(nasid, PI_INT_MASK0_B, si->irq_enable_mask[0]);
 		REMOTE_HUB_S(nasid, PI_INT_MASK1_B, si->irq_enable_mask[1]);
 	}
+	local_irq_restore(flags);
 
 	return 0;
 }
@@ -235,7 +235,7 @@
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));
 	struct slice_data *si = cpu_data[cpu].data;
 
-	__clear_bit(bit, si->irq_enable_mask);
+	clear_bit(bit, si->irq_enable_mask);
 
 	if (!cputoslice(cpu)) {
 		REMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);
@@ -261,7 +261,7 @@
 	bc = IRQ_TO_BRIDGE(irq);
 	bridge = bc->base;
 
-	DBG("bridge_startup(): irq= 0x%x  pin=%d\n", irq, pin);
+	pr_debug("bridge_startup(): irq= 0x%x  pin=%d\n", irq, pin);
 	/*
 	 * "map" irq to a swlevel greater than 6 since the first 6 bits
 	 * of INT_PEND0 are taken
@@ -298,12 +298,13 @@
 static void shutdown_bridge_irq(unsigned int irq)
 {
 	struct bridge_controller *bc = IRQ_TO_BRIDGE(irq);
+	struct hub_data *hub = hub_data(cpu_to_node(bc->irq_cpu));
 	bridge_t *bridge = bc->base;
 	struct slice_data *si = cpu_data[bc->irq_cpu].data;
 	int pin, swlevel;
 	cpuid_t cpu;
 
-	DBG("bridge_shutdown: irq 0x%x\n", irq);
+	pr_debug("bridge_shutdown: irq 0x%x\n", irq);
 	pin = SLOT_FROM_PCI_IRQ(irq);
 
 	/*
@@ -313,7 +314,7 @@
 	swlevel = find_level(&cpu, irq);
 	intr_disconnect_level(cpu, swlevel);
 
-	__clear_bit(swlevel, si->irq_alloc_mask);
+	__clear_bit(swlevel, hub->irq_alloc_mask);
 	si->level_to_irq[swlevel] = -1;
 
 	bridge->b_int_enable &= ~(1 << pin);
@@ -433,25 +434,24 @@
 	int slice = LOCAL_HUB_L(PI_CPU_NUM);
 	int cpu = smp_processor_id();
 	struct slice_data *si = cpu_data[cpu].data;
-	hubreg_t mask, set;
+	struct hub_data *hub = hub_data(cpu_to_node(cpu));
+	int resched, call;
+
+	resched = CPU_RESCHED_A_IRQ + slice;
+	__set_bit(resched, hub->irq_alloc_mask);
+	__set_bit(resched, si->irq_enable_mask);
+	LOCAL_HUB_CLR_INTR(resched);
+
+	call = CPU_CALL_A_IRQ + slice;
+	__set_bit(call, hub->irq_alloc_mask);
+	__set_bit(call, si->irq_enable_mask);
+	LOCAL_HUB_CLR_INTR(call);
 
 	if (slice == 0) {
-		LOCAL_HUB_CLR_INTR(CPU_RESCHED_A_IRQ);
-		LOCAL_HUB_CLR_INTR(CPU_CALL_A_IRQ);
-		mask = LOCAL_HUB_L(PI_INT_MASK0_A);	/* Slice A */
-		set = (1UL << CPU_RESCHED_A_IRQ) | (1UL << CPU_CALL_A_IRQ);
-		mask |= set;
-		si->irq_enable_mask[0] |= set;
-		si->irq_alloc_mask[0] |= set;
-		LOCAL_HUB_S(PI_INT_MASK0_A, mask);
+		LOCAL_HUB_S(PI_INT_MASK0_A, si->irq_enable_mask[0]);
+		LOCAL_HUB_S(PI_INT_MASK1_A, si->irq_enable_mask[1]);
 	} else {
-		LOCAL_HUB_CLR_INTR(CPU_RESCHED_B_IRQ);
-		LOCAL_HUB_CLR_INTR(CPU_CALL_B_IRQ);
-		mask = LOCAL_HUB_L(PI_INT_MASK0_B);	/* Slice B */
-		set = (1UL << CPU_RESCHED_B_IRQ) | (1UL << CPU_CALL_B_IRQ);
-		mask |= set;
-		si->irq_enable_mask[1] |= set;
-		si->irq_alloc_mask[1] |= set;
-		LOCAL_HUB_S(PI_INT_MASK0_B, mask);
+		LOCAL_HUB_S(PI_INT_MASK0_B, si->irq_enable_mask[0]);
+		LOCAL_HUB_S(PI_INT_MASK1_B, si->irq_enable_mask[1]);
 	}
 }
diff -Naur linux-2.6.14/arch/mips/sgi-ip27/ip27-smp.c linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-smp.c
--- linux-2.6.14/arch/mips/sgi-ip27/ip27-smp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip27/ip27-smp.c	2005-11-17 11:42:29.000000000 -0800
@@ -127,37 +127,28 @@
 	printk("Discovered %d cpus on %d nodes\n", highest + 1, num_online_nodes());
 }
 
-static void intr_clear_bits(nasid_t nasid, volatile hubreg_t *pend,
-	int base_level)
+static __init void intr_clear_all(nasid_t nasid)
 {
-	volatile hubreg_t bits;
 	int i;
 
-	/* Check pending interrupts */
-	if ((bits = HUB_L(pend)) != 0)
-		for (i = 0; i < N_INTPEND_BITS; i++)
-			if (bits & (1 << i))
-				LOCAL_HUB_CLR_INTR(base_level + i);
-}
-
-static void intr_clear_all(nasid_t nasid)
-{
 	REMOTE_HUB_S(nasid, PI_INT_MASK0_A, 0);
 	REMOTE_HUB_S(nasid, PI_INT_MASK0_B, 0);
 	REMOTE_HUB_S(nasid, PI_INT_MASK1_A, 0);
 	REMOTE_HUB_S(nasid, PI_INT_MASK1_B, 0);
-	intr_clear_bits(nasid, REMOTE_HUB_ADDR(nasid, PI_INT_PEND0),
-	                INT_PEND0_BASELVL);
-	intr_clear_bits(nasid, REMOTE_HUB_ADDR(nasid, PI_INT_PEND1),
-	                INT_PEND1_BASELVL);
+
+	for (i = 0; i < 128; i++)
+		REMOTE_HUB_CLR_INTR(nasid, i);
 }
 
 void __init prom_prepare_cpus(unsigned int max_cpus)
 {
 	cnodeid_t	cnode;
 
-	for_each_online_node(cnode)
+	for_each_online_node(cnode) {
+		if (cnode == 0)
+			continue;
 		intr_clear_all(COMPACT_TO_NASID_NODEID(cnode));
+	}
 
 	replicate_kernel_text();
 
diff -Naur linux-2.6.14/arch/mips/sgi-ip27/Kconfig linux-mips-2.6.14.orig/arch/mips/sgi-ip27/Kconfig
--- linux-2.6.14/arch/mips/sgi-ip27/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip27/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,54 @@
+#config SGI_SN0_XXL
+#	bool "IP27 XXL"
+#	depends on SGI_IP27
+#	  This options adds support for userspace processes upto 16TB size.
+#	  Normally the limit is just .5TB.
+
+config SGI_SN0_N_MODE
+	bool "IP27 N-Mode"
+	depends on SGI_IP27
+	help
+	  The nodes of Origin 200, Origin 2000 and Onyx 2 systems can be
+	  configured in either N-Modes which allows for more nodes or M-Mode
+	  which allows for more memory.  Your system is most probably
+	  running in M-Mode, so you should say N here.
+
+config ARCH_DISCONTIGMEM_ENABLE
+	bool
+	default y if SGI_IP27
+	help
+	  Say Y to upport efficient handling of discontiguous physical memory,
+	  for architectures which are either NUMA (Non-Uniform Memory Access)
+	  or have huge holes in the physical address space for other reasons.
+	  See <file:Documentation/vm/numa> for more.
+
+config NUMA
+	bool "NUMA Support"
+	depends on SGI_IP27
+	help
+	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
+	  Access).  This option is for configuring high-end multiprocessor
+	  server machines.  If in doubt, say N.
+
+config MAPPED_KERNEL
+	bool "Mapped kernel support"
+	depends on SGI_IP27
+	help
+	  Change the way a Linux kernel is loaded into memory on a MIPS64
+	  machine.  This is required in order to support text replication and
+	  NUMA.  If you need to understand it, read the source code.
+
+config REPLICATE_KTEXT
+	bool "Kernel text replication support"
+	depends on SGI_IP27
+	help
+	  Say Y here to enable replicating the kernel text across multiple
+	  nodes in a NUMA cluster.  This trades memory for speed.
+
+config REPLICATE_EXHANDLERS
+	bool "Exception handler replication support"
+	depends on SGI_IP27
+	help
+	  Say Y here to enable replicating the kernel exception handlers
+	  across multiple nodes in a NUMA cluster. This trades memory for
+	  speed.
diff -Naur linux-2.6.14/arch/mips/sgi-ip32/ip32-irq.c linux-mips-2.6.14.orig/arch/mips/sgi-ip32/ip32-irq.c
--- linux-2.6.14/arch/mips/sgi-ip32/ip32-irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip32/ip32-irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -163,14 +163,13 @@
 #define mask_and_ack_cpu_irq disable_cpu_irq
 
 static struct hw_interrupt_type ip32_cpu_interrupt = {
-	"IP32 CPU",
-	startup_cpu_irq,
-	shutdown_cpu_irq,
-	enable_cpu_irq,
-	disable_cpu_irq,
-	mask_and_ack_cpu_irq,
-	end_cpu_irq,
-	NULL
+	.typename = "IP32 CPU",
+	.startup = startup_cpu_irq,
+	.shutdown = shutdown_cpu_irq,
+	.enable = enable_cpu_irq,
+	.disable = disable_cpu_irq,
+	.ack = mask_and_ack_cpu_irq,
+	.end = end_cpu_irq,
 };
 
 /*
@@ -234,14 +233,13 @@
 #define shutdown_crime_irq disable_crime_irq
 
 static struct hw_interrupt_type ip32_crime_interrupt = {
-	"IP32 CRIME",
-	startup_crime_irq,
-	shutdown_crime_irq,
-	enable_crime_irq,
-	disable_crime_irq,
-	mask_and_ack_crime_irq,
-	end_crime_irq,
-	NULL
+	.typename = "IP32 CRIME",
+	.startup = startup_crime_irq,
+	.shutdown = shutdown_crime_irq,
+	.enable = enable_crime_irq,
+	.disable = disable_crime_irq,
+	.ack = mask_and_ack_crime_irq,
+	.end = end_crime_irq,
 };
 
 /*
@@ -294,14 +292,13 @@
 #define mask_and_ack_macepci_irq disable_macepci_irq
 
 static struct hw_interrupt_type ip32_macepci_interrupt = {
-	"IP32 MACE PCI",
-	startup_macepci_irq,
-	shutdown_macepci_irq,
-	enable_macepci_irq,
-	disable_macepci_irq,
-	mask_and_ack_macepci_irq,
-	end_macepci_irq,
-	NULL
+	.typename = "IP32 MACE PCI",
+	.startup = startup_macepci_irq,
+	.shutdown = shutdown_macepci_irq,
+	.enable = enable_macepci_irq,
+	.disable = disable_macepci_irq,
+	.ack = mask_and_ack_macepci_irq,
+	.end = end_macepci_irq,
 };
 
 /* This is used for MACE ISA interrupts.  That means bits 4-6 in the
@@ -425,14 +422,13 @@
 #define shutdown_maceisa_irq disable_maceisa_irq
 
 static struct hw_interrupt_type ip32_maceisa_interrupt = {
-	"IP32 MACE ISA",
-	startup_maceisa_irq,
-	shutdown_maceisa_irq,
-	enable_maceisa_irq,
-	disable_maceisa_irq,
-	mask_and_ack_maceisa_irq,
-	end_maceisa_irq,
-	NULL
+	.typename = "IP32 MACE ISA",
+	.startup = startup_maceisa_irq,
+	.shutdown = shutdown_maceisa_irq,
+	.enable = enable_maceisa_irq,
+	.disable = disable_maceisa_irq,
+	.ack = mask_and_ack_maceisa_irq,
+	.end = end_maceisa_irq,
 };
 
 /* This is used for regular non-ISA, non-PCI MACE interrupts.  That means
@@ -476,14 +472,13 @@
 #define mask_and_ack_mace_irq disable_mace_irq
 
 static struct hw_interrupt_type ip32_mace_interrupt = {
-	"IP32 MACE",
-	startup_mace_irq,
-	shutdown_mace_irq,
-	enable_mace_irq,
-	disable_mace_irq,
-	mask_and_ack_mace_irq,
-	end_mace_irq,
-	NULL
+	.typename = "IP32 MACE",
+	.startup = startup_mace_irq,
+	.shutdown = shutdown_mace_irq,
+	.enable = enable_mace_irq,
+	.disable = disable_mace_irq,
+	.ack = mask_and_ack_mace_irq,
+	.end = end_mace_irq,
 };
 
 static void ip32_unknown_interrupt(struct pt_regs *regs)
diff -Naur linux-2.6.14/arch/mips/sgi-ip32/ip32-memory.c linux-mips-2.6.14.orig/arch/mips/sgi-ip32/ip32-memory.c
--- linux-2.6.14/arch/mips/sgi-ip32/ip32-memory.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip32/ip32-memory.c	2005-11-17 11:42:29.000000000 -0800
@@ -36,8 +36,8 @@
 		if (base + size > (256 << 20))
 			base += CRIME_HI_MEM_BASE;
 
-		printk("CRIME MC: bank %u base 0x%016lx size %luMB\n",
-			bank, base, size);
+		printk("CRIME MC: bank %u base 0x%016lx size %luMiB\n",
+			bank, base, size >> 20);
 		add_memory_region (base, size, BOOT_MEM_RAM);
 	}
 }
diff -Naur linux-2.6.14/arch/mips/sgi-ip32/ip32-setup.c linux-mips-2.6.14.orig/arch/mips/sgi-ip32/ip32-setup.c
--- linux-2.6.14/arch/mips/sgi-ip32/ip32-setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sgi-ip32/ip32-setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -92,7 +92,7 @@
 	setup_irq(IP32_R4K_TIMER_IRQ, irq);
 }
 
-static int __init ip32_setup(void)
+void __init plat_setup(void)
 {
 	board_be_init = ip32_be_init;
 
@@ -152,8 +152,4 @@
 		}
 	}
 #endif
-
-	return 0;
 }
-
-early_initcall(ip32_setup);
diff -Naur linux-2.6.14/arch/mips/sibyte/bcm1480/irq.c linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/irq.c
--- linux-2.6.14/arch/mips/sibyte/bcm1480/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,476 @@
+/*
+ * Copyright (C) 2000,2001,2002,2003,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/errno.h>
+#include <asm/signal.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/io.h>
+
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+#include <asm/sibyte/bcm1480_scd.h>
+
+#include <asm/sibyte/sb1250_uart.h>
+#include <asm/sibyte/sb1250.h>
+
+/*
+ * These are the routines that handle all the low level interrupt stuff.
+ * Actions handled here are: initialization of the interrupt map, requesting of
+ * interrupt lines by handlers, dispatching if interrupts to handlers, probing
+ * for interrupt lines
+ */
+
+
+#define shutdown_bcm1480_irq	disable_bcm1480_irq
+static void end_bcm1480_irq(unsigned int irq);
+static void enable_bcm1480_irq(unsigned int irq);
+static void disable_bcm1480_irq(unsigned int irq);
+static unsigned int startup_bcm1480_irq(unsigned int irq);
+static void ack_bcm1480_irq(unsigned int irq);
+#ifdef CONFIG_SMP
+static void bcm1480_set_affinity(unsigned int irq, cpumask_t mask);
+#endif
+
+#ifdef CONFIG_PCI
+extern unsigned long ht_eoi_space;
+#endif
+
+#ifdef CONFIG_KGDB
+#include <asm/gdb-stub.h>
+extern void breakpoint(void);
+static int kgdb_irq;
+#ifdef CONFIG_GDB_CONSOLE
+extern void register_gdb_console(void);
+#endif
+
+/* kgdb is on when configured.  Pass "nokgdb" kernel arg to turn it off */
+static int kgdb_flag = 1;
+static int __init nokgdb(char *str)
+{
+	kgdb_flag = 0;
+	return 1;
+}
+__setup("nokgdb", nokgdb);
+
+/* Default to UART1 */
+int kgdb_port = 1;
+#ifdef CONFIG_SIBYTE_SB1250_DUART
+extern char sb1250_duart_present[];
+#endif
+#endif
+
+static struct hw_interrupt_type bcm1480_irq_type = {
+	.typename = "BCM1480-IMR",
+	.startup = startup_bcm1480_irq,
+	.shutdown = shutdown_bcm1480_irq,
+	.enable = enable_bcm1480_irq,
+	.disable = disable_bcm1480_irq,
+	.ack = ack_bcm1480_irq,
+	.end = end_bcm1480_irq,
+#ifdef CONFIG_SMP
+	.set_affinity = bcm1480_set_affinity
+#endif
+};
+
+/* Store the CPU id (not the logical number) */
+int bcm1480_irq_owner[BCM1480_NR_IRQS];
+
+DEFINE_SPINLOCK(bcm1480_imr_lock);
+
+void bcm1480_mask_irq(int cpu, int irq)
+{
+	unsigned long flags;
+	u64 cur_ints,hl_spacing;
+
+	spin_lock_irqsave(&bcm1480_imr_lock, flags);
+	hl_spacing = 0;
+	if ((irq >= BCM1480_NR_IRQS_HALF) && (irq <= BCM1480_NR_IRQS)) {
+		hl_spacing = BCM1480_IMR_HL_SPACING;
+		irq -= BCM1480_NR_IRQS_HALF;
+	}
+	cur_ints = ____raw_readq(IOADDR(A_BCM1480_IMR_MAPPER(cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + hl_spacing));
+	cur_ints |= (((u64) 1) << irq);
+	____raw_writeq(cur_ints, IOADDR(A_BCM1480_IMR_MAPPER(cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + hl_spacing));
+	spin_unlock_irqrestore(&bcm1480_imr_lock, flags);
+}
+
+void bcm1480_unmask_irq(int cpu, int irq)
+{
+	unsigned long flags;
+	u64 cur_ints,hl_spacing;
+
+	spin_lock_irqsave(&bcm1480_imr_lock, flags);
+	hl_spacing = 0;
+	if ((irq >= BCM1480_NR_IRQS_HALF) && (irq <= BCM1480_NR_IRQS)) {
+		hl_spacing = BCM1480_IMR_HL_SPACING;
+		irq -= BCM1480_NR_IRQS_HALF;
+	}
+	cur_ints = ____raw_readq(IOADDR(A_BCM1480_IMR_MAPPER(cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + hl_spacing));
+	cur_ints &= ~(((u64) 1) << irq);
+	____raw_writeq(cur_ints, IOADDR(A_BCM1480_IMR_MAPPER(cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + hl_spacing));
+	spin_unlock_irqrestore(&bcm1480_imr_lock, flags);
+}
+
+#ifdef CONFIG_SMP
+static void bcm1480_set_affinity(unsigned int irq, cpumask_t mask)
+{
+	int i = 0, old_cpu, cpu, int_on;
+	u64 cur_ints;
+	irq_desc_t *desc = irq_desc + irq;
+	unsigned long flags;
+	unsigned int irq_dirty;
+
+	i = first_cpu(mask);
+	if (next_cpu(i, mask) <= NR_CPUS) {
+		printk("attempted to set irq affinity for irq %d to multiple CPUs\n", irq);
+		return;
+	}
+
+	/* Convert logical CPU to physical CPU */
+	cpu = cpu_logical_map(i);
+
+	/* Protect against other affinity changers and IMR manipulation */
+	spin_lock_irqsave(&desc->lock, flags);
+	spin_lock(&bcm1480_imr_lock);
+
+	/* Swizzle each CPU's IMR (but leave the IP selection alone) */
+	old_cpu = bcm1480_irq_owner[irq];
+	irq_dirty = irq;
+	if ((irq_dirty >= BCM1480_NR_IRQS_HALF) && (irq_dirty <= BCM1480_NR_IRQS)) {
+		irq_dirty -= BCM1480_NR_IRQS_HALF;
+	}
+
+	int k;
+	for (k=0; k<2; k++) { /* Loop through high and low interrupt mask register */
+		cur_ints = ____raw_readq(IOADDR(A_BCM1480_IMR_MAPPER(old_cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + (k*BCM1480_IMR_HL_SPACING)));
+		int_on = !(cur_ints & (((u64) 1) << irq_dirty));
+		if (int_on) {
+			/* If it was on, mask it */
+			cur_ints |= (((u64) 1) << irq_dirty);
+			____raw_writeq(cur_ints, IOADDR(A_BCM1480_IMR_MAPPER(old_cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + (k*BCM1480_IMR_HL_SPACING)));
+		}
+		bcm1480_irq_owner[irq] = cpu;
+		if (int_on) {
+			/* unmask for the new CPU */
+			cur_ints = ____raw_readq(IOADDR(A_BCM1480_IMR_MAPPER(cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + (k*BCM1480_IMR_HL_SPACING)));
+			cur_ints &= ~(((u64) 1) << irq_dirty);
+			____raw_writeq(cur_ints, IOADDR(A_BCM1480_IMR_MAPPER(cpu) + R_BCM1480_IMR_INTERRUPT_MASK_H + (k*BCM1480_IMR_HL_SPACING)));
+		}
+	}
+	spin_unlock(&bcm1480_imr_lock);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+#endif
+
+
+/* Defined in arch/mips/sibyte/bcm1480/irq_handler.S */
+extern void bcm1480_irq_handler(void);
+
+/*****************************************************************************/
+
+static unsigned int startup_bcm1480_irq(unsigned int irq)
+{
+	bcm1480_unmask_irq(bcm1480_irq_owner[irq], irq);
+
+	return 0;		/* never anything pending */
+}
+
+
+static void disable_bcm1480_irq(unsigned int irq)
+{
+	bcm1480_mask_irq(bcm1480_irq_owner[irq], irq);
+}
+
+static void enable_bcm1480_irq(unsigned int irq)
+{
+	bcm1480_unmask_irq(bcm1480_irq_owner[irq], irq);
+}
+
+
+static void ack_bcm1480_irq(unsigned int irq)
+{
+	u64 pending;
+	unsigned int irq_dirty;
+
+	/*
+	 * If the interrupt was an HT interrupt, now is the time to
+	 * clear it.  NOTE: we assume the HT bridge was set up to
+	 * deliver the interrupts to all CPUs (which makes affinity
+	 * changing easier for us)
+	 */
+	irq_dirty = irq;
+	if ((irq_dirty >= BCM1480_NR_IRQS_HALF) && (irq_dirty <= BCM1480_NR_IRQS)) {
+		irq_dirty -= BCM1480_NR_IRQS_HALF;
+	}
+	int k;
+	for (k=0; k<2; k++) { /* Loop through high and low LDT interrupts */
+		pending = __raw_readq(IOADDR(A_BCM1480_IMR_REGISTER(bcm1480_irq_owner[irq],
+						R_BCM1480_IMR_LDT_INTERRUPT_H + (k*BCM1480_IMR_HL_SPACING))));
+		pending &= ((u64)1 << (irq_dirty));
+		if (pending) {
+#ifdef CONFIG_SMP
+			int i;
+			for (i=0; i<NR_CPUS; i++) {
+				/*
+				 * Clear for all CPUs so an affinity switch
+				 * doesn't find an old status
+				 */
+				__raw_writeq(pending, IOADDR(A_BCM1480_IMR_REGISTER(cpu_logical_map(i),
+								R_BCM1480_IMR_LDT_INTERRUPT_CLR_H + (k*BCM1480_IMR_HL_SPACING))));
+			}
+#else
+			__raw_writeq(pending, IOADDR(A_BCM1480_IMR_REGISTER(0, R_BCM1480_IMR_LDT_INTERRUPT_CLR_H + (k*BCM1480_IMR_HL_SPACING))));
+#endif
+
+			/*
+			 * Generate EOI.  For Pass 1 parts, EOI is a nop.  For
+			 * Pass 2, the LDT world may be edge-triggered, but
+			 * this EOI shouldn't hurt.  If they are
+			 * level-sensitive, the EOI is required.
+			 */
+#ifdef CONFIG_PCI
+			if (ht_eoi_space)
+				*(uint32_t *)(ht_eoi_space+(irq<<16)+(7<<2)) = 0;
+#endif
+		}
+	}
+	bcm1480_mask_irq(bcm1480_irq_owner[irq], irq);
+}
+
+
+static void end_bcm1480_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		bcm1480_unmask_irq(bcm1480_irq_owner[irq], irq);
+	}
+}
+
+
+void __init init_bcm1480_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		if (i < BCM1480_NR_IRQS) {
+			irq_desc[i].handler = &bcm1480_irq_type;
+			bcm1480_irq_owner[i] = 0;
+		} else {
+			irq_desc[i].handler = &no_irq_type;
+		}
+	}
+}
+
+
+static irqreturn_t bcm1480_dummy_handler(int irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	return IRQ_NONE;
+}
+
+static struct irqaction bcm1480_dummy_action = {
+	.handler = bcm1480_dummy_handler,
+	.flags   = 0,
+	.mask    = CPU_MASK_NONE,
+	.name    = "bcm1480-private",
+	.next    = NULL,
+	.dev_id  = 0
+};
+
+int bcm1480_steal_irq(int irq)
+{
+	irq_desc_t *desc = irq_desc + irq;
+	unsigned long flags;
+	int retval = 0;
+
+	if (irq >= BCM1480_NR_IRQS)
+		return -EINVAL;
+
+	spin_lock_irqsave(&desc->lock,flags);
+	/* Don't allow sharing at all for these */
+	if (desc->action != NULL)
+		retval = -EBUSY;
+	else {
+		desc->action = &bcm1480_dummy_action;
+		desc->depth = 0;
+	}
+	spin_unlock_irqrestore(&desc->lock,flags);
+	return 0;
+}
+
+/*
+ *  init_IRQ is called early in the boot sequence from init/main.c.  It
+ *  is responsible for setting up the interrupt mapper and installing the
+ *  handler that will be responsible for dispatching interrupts to the
+ *  "right" place.
+ */
+/*
+ * For now, map all interrupts to IP[2].  We could save
+ * some cycles by parceling out system interrupts to different
+ * IP lines, but keep it simple for bringup.  We'll also direct
+ * all interrupts to a single CPU; we should probably route
+ * PCI and LDT to one cpu and everything else to the other
+ * to balance the load a bit.
+ *
+ * On the second cpu, everything is set to IP5, which is
+ * ignored, EXCEPT the mailbox interrupt.  That one is
+ * set to IP[2] so it is handled.  This is needed so we
+ * can do cross-cpu function calls, as requred by SMP
+ */
+
+#define IMR_IP2_VAL	K_BCM1480_INT_MAP_I0
+#define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
+#define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
+#define IMR_IP5_VAL	K_BCM1480_INT_MAP_I3
+#define IMR_IP6_VAL	K_BCM1480_INT_MAP_I4
+
+void __init arch_init_irq(void)
+{
+
+	unsigned int i, cpu;
+	u64 tmp;
+	unsigned int imask = STATUSF_IP4 | STATUSF_IP3 | STATUSF_IP2 |
+		STATUSF_IP1 | STATUSF_IP0;
+
+	/* Default everything to IP2 */
+	/* Start with _high registers which has no bit 0 interrupt source */
+	for (i = 1; i < BCM1480_NR_IRQS_HALF; i++) {	/* was I0 */
+		for (cpu = 0; cpu < 4; cpu++) {
+			__raw_writeq(IMR_IP2_VAL,
+				     IOADDR(A_BCM1480_IMR_REGISTER(cpu,
+								   R_BCM1480_IMR_INTERRUPT_MAP_BASE_H) + (i << 3)));
+		}
+	}
+
+	/* Now do _low registers */
+	for (i = 0; i < BCM1480_NR_IRQS_HALF; i++) {
+		for (cpu = 0; cpu < 4; cpu++) {
+			__raw_writeq(IMR_IP2_VAL,
+				     IOADDR(A_BCM1480_IMR_REGISTER(cpu,
+								   R_BCM1480_IMR_INTERRUPT_MAP_BASE_L) + (i << 3)));
+		}
+	}
+
+	init_bcm1480_irqs();
+
+	/*
+	 * Map the high 16 bits of mailbox_0 registers to IP[3], for
+	 * inter-cpu messages
+	 */
+	/* Was I1 */
+	for (cpu = 0; cpu < 4; cpu++) {
+		__raw_writeq(IMR_IP3_VAL, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MAP_BASE_H) +
+						 (K_BCM1480_INT_MBOX_0_0 << 3)));
+        }
+
+
+	/* Clear the mailboxes.  The firmware may leave them dirty */
+	for (cpu = 0; cpu < 4; cpu++) {
+		__raw_writeq(0xffffffffffffffffULL,
+			     IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_MAILBOX_0_CLR_CPU)));
+		__raw_writeq(0xffffffffffffffffULL,
+			     IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_MAILBOX_1_CLR_CPU)));
+	}
+
+
+	/* Mask everything except the high 16 bit of mailbox_0 registers for all cpus */
+	tmp = ~((u64) 0) ^ ( (((u64) 1) << K_BCM1480_INT_MBOX_0_0));
+	for (cpu = 0; cpu < 4; cpu++) {
+		__raw_writeq(tmp, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MASK_H)));
+	}
+	tmp = ~((u64) 0);
+	for (cpu = 0; cpu < 4; cpu++) {
+		__raw_writeq(tmp, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MASK_L)));
+	}
+
+	bcm1480_steal_irq(K_BCM1480_INT_MBOX_0_0);
+
+	/*
+	 * Note that the timer interrupts are also mapped, but this is
+	 * done in bcm1480_time_init().  Also, the profiling driver
+	 * does its own management of IP7.
+	 */
+
+#ifdef CONFIG_KGDB
+	imask |= STATUSF_IP6;
+#endif
+	/* Enable necessary IPs, disable the rest */
+	change_c0_status(ST0_IM, imask);
+	set_except_vector(0, bcm1480_irq_handler);
+
+#ifdef CONFIG_KGDB
+	if (kgdb_flag) {
+		kgdb_irq = K_BCM1480_INT_UART_0 + kgdb_port;
+
+#ifdef CONFIG_SIBYTE_SB1250_DUART
+		sb1250_duart_present[kgdb_port] = 0;
+#endif
+		/* Setup uart 1 settings, mapper */
+		/* QQQ FIXME */
+		__raw_writeq(M_DUART_IMR_BRK, IO_SPACE_BASE + A_DUART_IMRREG(kgdb_port));
+
+		bcm1480_steal_irq(kgdb_irq);
+		__raw_writeq(IMR_IP6_VAL,
+			     IO_SPACE_BASE + A_BCM1480_IMR_REGISTER(0, R_BCM1480_IMR_INTERRUPT_MAP_BASE_H) +
+			     (kgdb_irq<<3));
+		bcm1480_unmask_irq(0, kgdb_irq);
+
+#ifdef CONFIG_GDB_CONSOLE
+		register_gdb_console();
+#endif
+		prom_printf("Waiting for GDB on UART port %d\n", kgdb_port);
+		set_debug_traps();
+		breakpoint();
+	}
+#endif
+}
+
+#ifdef CONFIG_KGDB
+
+#include <linux/delay.h>
+
+#define duart_out(reg, val)     csr_out32(val, IOADDR(A_DUART_CHANREG(kgdb_port,reg)))
+#define duart_in(reg)           csr_in32(IOADDR(A_DUART_CHANREG(kgdb_port,reg)))
+
+void bcm1480_kgdb_interrupt(struct pt_regs *regs)
+{
+	/*
+	 * Clear break-change status (allow some time for the remote
+	 * host to stop the break, since we would see another
+	 * interrupt on the end-of-break too)
+	 */
+	kstat.irqs[smp_processor_id()][kgdb_irq]++;
+	mdelay(500);
+	duart_out(R_DUART_CMD, V_DUART_MISC_CMD_RESET_BREAK_INT |
+				M_DUART_RX_EN | M_DUART_TX_EN);
+	set_async_breakpoint(&regs->cp0_epc);
+}
+
+#endif 	/* CONFIG_KGDB */
diff -Naur linux-2.6.14/arch/mips/sibyte/bcm1480/irq_handler.S linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/irq_handler.S
--- linux-2.6.14/arch/mips/sibyte/bcm1480/irq_handler.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/irq_handler.S	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2000,2001,2002,2003,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * bcm1480_irq_handler() is the routine that is actually called when an
+ * interrupt occurs.  It is installed as the exception vector handler in
+ * init_IRQ() in arch/mips/sibyte/bcm1480/irq.c
+ *
+ * In the handle we figure out which interrupts need handling, and use that
+ * to call the dispatcher, which will take care of actually calling
+ * registered handlers
+ *
+ * Note that we take care of all raised interrupts in one go at the handler.
+ * This is more BSDish than the Indy code, and also, IMHO, more sane.
+ */
+#include <linux/config.h>
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/sibyte/sb1250_defs.h>
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+
+/*
+ * What a pain. We have to be really careful saving the upper 32 bits of any
+ * register across function calls if we don't want them trashed--since were
+ * running in -o32, the calling routing never saves the full 64 bits of a
+ * register across a function call.  Being the interrupt handler, we're
+ * guaranteed that interrupts are disabled during this code so we don't have
+ * to worry about random interrupts blasting the high 32 bits.
+ */
+
+	.text
+	.set	push
+	.set	noreorder
+	.set	noat
+	.set	mips64
+	#.set	mips4
+	.align	5
+	NESTED(bcm1480_irq_handler, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+
+#ifdef CONFIG_SIBYTE_BCM1480_PROF
+	/* Set compare to count to silence count/compare timer interrupts */
+	mfc0	t1, CP0_COUNT
+	mtc0	t1, CP0_COMPARE /* pause to clear IP[7] bit of cause ? */
+#endif
+	/* Read cause */
+	mfc0	s0, CP0_CAUSE
+
+#ifdef CONFIG_SIBYTE_BCM1480_PROF
+	/* Cpu performance counter interrupt is routed to IP[7] */
+	andi	t1, s0, CAUSEF_IP7
+	beqz	t1, 0f
+	 srl	t1, s0, (CAUSEB_BD-2)	/* Shift BD bit to bit 2 */
+	and	t1, t1, 0x4		/* mask to get just BD bit */
+#ifdef CONFIG_MIPS64
+	dmfc0	a0, CP0_EPC
+	daddu	a0, a0, t1		/* a0 = EPC + (BD ? 4 :	0) */
+#else
+	mfc0	a0, CP0_EPC
+	addu	a0, a0, t1		/* a0 = EPC + (BD ? 4 :	0) */
+#endif
+	jal	sbprof_cpu_intr
+	 nop
+	j	ret_from_irq
+	 nop
+0:
+#endif
+
+	/* Timer interrupt is routed to IP[4] */
+	andi	t1, s0, CAUSEF_IP4
+	beqz	t1, 1f
+	 nop
+	jal	bcm1480_timer_interrupt
+	 move	a0, sp			/* Pass the registers along */
+	j	ret_from_irq
+	 nop				/* delay slot  */
+1:
+
+#ifdef CONFIG_SMP
+	/* Mailbox interrupt is routed to IP[3] */
+	andi	 t1, s0, CAUSEF_IP3
+	beqz	 t1, 2f
+	 nop
+	jal	 bcm1480_mailbox_interrupt
+	 move	 a0, sp
+	j	 ret_from_irq
+	 nop				/* delay slot  */
+2:
+#endif
+
+#ifdef CONFIG_KGDB
+	/* KGDB (uart 1) interrupt is routed to IP[6] */
+	andi	 t1, s0, CAUSEF_IP6
+	beqz	 t1, 3f
+	 nop				/* delay slot  */
+	jal	 bcm1480_kgdb_interrupt
+	 move	 a0, sp
+	j	 ret_from_irq
+	 nop				/* delay slot  */
+3:
+#endif
+
+	and	 t1, s0, CAUSEF_IP2
+	beqz	 t1, 9f
+	 nop
+
+	/*
+	 * Default...we've hit an IP[2] interrupt, which means we've got
+	 * to check the 1480 interrupt registers to figure out what to do
+	 * Need to detect which CPU we're on, now that smp_affinity is
+	 * supported.
+	 */
+	PTR_LA	 v0, CKSEG1 + A_BCM1480_IMR_CPU0_BASE
+#ifdef CONFIG_SMP
+	lw	 t1, TI_CPU($28)
+	sll	 t1, t1, BCM1480_IMR_REGISTER_SPACING_SHIFT
+	addu	 v0, v0, t1
+#endif
+
+	/* Read IP[2] status (get both high and low halves of status) */
+	ld	 s0, R_BCM1480_IMR_INTERRUPT_STATUS_BASE_H(v0)
+	ld	 s1, R_BCM1480_IMR_INTERRUPT_STATUS_BASE_L(v0)
+
+	move	 s2, zero	/* intr number  */
+	li	 s3, 64
+
+	beqz	 s0, 9f		/* No interrupts.  Return.  */
+	 move	 a1, sp
+
+	xori	 s4, s0, 1	/* if s0 (_H) == 1, it's a low intr, so...  */
+	movz	 s2, s3, s4	/* start the intr number at 64, and  */
+	movz	 s0, s1, s4	/* look at the low status value.  */
+
+	dclz	 s1, s0		/* Find the next interrupt.  */
+	dsubu	 a0, zero, s1
+	daddiu	 a0, a0, 63
+	jal	 do_IRQ
+	 daddu	 a0, a0, s2
+
+9:	j	 ret_from_irq
+	 nop
+
+	.set pop
+	END(bcm1480_irq_handler)
diff -Naur linux-2.6.14/arch/mips/sibyte/bcm1480/Makefile linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/Makefile
--- linux-2.6.14/arch/mips/sibyte/bcm1480/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/Makefile	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,5 @@
+obj-y := setup.o irq.o irq_handler.o time.o
+
+obj-$(CONFIG_SMP)			+= smp.o
+
+EXTRA_AFLAGS := $(CFLAGS)
diff -Naur linux-2.6.14/arch/mips/sibyte/bcm1480/setup.c linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/setup.c
--- linux-2.6.14/arch/mips/sibyte/bcm1480/setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2000,2001,2002,2003,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/reboot.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/io.h>
+#include <asm/sibyte/sb1250.h>
+
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_scd.h>
+#include <asm/sibyte/sb1250_scd.h>
+
+unsigned int sb1_pass;
+unsigned int soc_pass;
+unsigned int soc_type;
+unsigned int periph_rev;
+unsigned int zbbus_mhz;
+
+static unsigned int part_type;
+
+static char *soc_str;
+static char *pass_str;
+
+static inline int setup_bcm1x80_bcm1x55(void);
+
+/* Setup code likely to be common to all SiByte platforms */
+
+static inline int sys_rev_decode(void)
+{
+	int ret = 0;
+
+	switch (soc_type) {
+	    case K_SYS_SOC_TYPE_BCM1x80:
+		if (part_type == K_SYS_PART_BCM1480)
+		    soc_str = "BCM1480";
+		else if (part_type == K_SYS_PART_BCM1280)
+		    soc_str = "BCM1280";
+		else
+		    soc_str = "BCM1x80";
+		ret = setup_bcm1x80_bcm1x55();
+		break;
+
+	    case K_SYS_SOC_TYPE_BCM1x55:
+		if (part_type == K_SYS_PART_BCM1455)
+		    soc_str = "BCM1455";
+		else if (part_type == K_SYS_PART_BCM1255)
+		    soc_str = "BCM1255";
+		else
+		    soc_str = "BCM1x55";
+		ret = setup_bcm1x80_bcm1x55();
+		break;
+
+	    default:
+		prom_printf("Unknown part type %x\n", part_type);
+		ret = 1;
+		break;
+	}
+	return ret;
+}
+
+static inline int setup_bcm1x80_bcm1x55(void)
+{
+	int ret = 0;
+
+	switch (soc_pass) {
+	    case K_SYS_REVISION_BCM1480_S0:
+		periph_rev = 1;
+		pass_str = "S0 (pass1)";
+		break;
+	    case K_SYS_REVISION_BCM1480_A1:
+		periph_rev = 1;
+		pass_str = "A1 (pass1)";
+		break;
+	    case K_SYS_REVISION_BCM1480_A2:
+		periph_rev = 1;
+		pass_str = "A2 (pass1)";
+		break;
+	    case K_SYS_REVISION_BCM1480_A3:
+		periph_rev = 1;
+		pass_str = "A3 (pass1)";
+		break;
+	    case K_SYS_REVISION_BCM1480_B0:
+		periph_rev = 1;
+		pass_str = "B0 (pass2)";
+		break;
+	    default:
+		prom_printf("Unknown %s rev %x\n", soc_str, soc_pass);
+		periph_rev = 1;
+		pass_str = "Unknown Revision";
+		break;
+	}
+	return ret;
+}
+
+void bcm1480_setup(void)
+{
+	uint64_t sys_rev;
+	int plldiv;
+
+	sb1_pass = read_c0_prid() & 0xff;
+	sys_rev = __raw_readq(IOADDR(A_SCD_SYSTEM_REVISION));
+	soc_type = SYS_SOC_TYPE(sys_rev);
+	part_type = G_SYS_PART(sys_rev);
+	soc_pass = G_SYS_REVISION(sys_rev);
+
+	if (sys_rev_decode()) {
+		prom_printf("Restart after failure to identify SiByte chip\n");
+		machine_restart(NULL);
+	}
+
+	plldiv = G_BCM1480_SYS_PLL_DIV(__raw_readq(IOADDR(A_SCD_SYSTEM_CFG)));
+	zbbus_mhz = ((plldiv >> 1) * 50) + ((plldiv & 1) * 25);
+
+	prom_printf("Broadcom SiByte %s %s @ %d MHz (SB-1A rev %d)\n",
+		    soc_str, pass_str, zbbus_mhz * 2, sb1_pass);
+	prom_printf("Board type: %s\n", get_system_type());
+}
diff -Naur linux-2.6.14/arch/mips/sibyte/bcm1480/smp.c linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/smp.c
--- linux-2.6.14/arch/mips/sibyte/bcm1480/smp.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/smp.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2001,2002,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/smp.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/mmu_context.h>
+#include <asm/io.h>
+#include <asm/sibyte/sb1250.h>
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+
+extern void smp_call_function_interrupt(void);
+
+/*
+ * These are routines for dealing with the bcm1480 smp capabilities
+ * independent of board/firmware
+ */
+
+static void *mailbox_0_set_regs[] = {
+	IOADDR(A_BCM1480_IMR_CPU0_BASE + R_BCM1480_IMR_MAILBOX_0_SET_CPU),
+	IOADDR(A_BCM1480_IMR_CPU1_BASE + R_BCM1480_IMR_MAILBOX_0_SET_CPU),
+	IOADDR(A_BCM1480_IMR_CPU2_BASE + R_BCM1480_IMR_MAILBOX_0_SET_CPU),
+	IOADDR(A_BCM1480_IMR_CPU3_BASE + R_BCM1480_IMR_MAILBOX_0_SET_CPU),
+};
+
+static void *mailbox_0_clear_regs[] = {
+	IOADDR(A_BCM1480_IMR_CPU0_BASE + R_BCM1480_IMR_MAILBOX_0_CLR_CPU),
+	IOADDR(A_BCM1480_IMR_CPU1_BASE + R_BCM1480_IMR_MAILBOX_0_CLR_CPU),
+	IOADDR(A_BCM1480_IMR_CPU2_BASE + R_BCM1480_IMR_MAILBOX_0_CLR_CPU),
+	IOADDR(A_BCM1480_IMR_CPU3_BASE + R_BCM1480_IMR_MAILBOX_0_CLR_CPU),
+};
+
+static void *mailbox_0_regs[] = {
+	IOADDR(A_BCM1480_IMR_CPU0_BASE + R_BCM1480_IMR_MAILBOX_0_CPU),
+	IOADDR(A_BCM1480_IMR_CPU1_BASE + R_BCM1480_IMR_MAILBOX_0_CPU),
+	IOADDR(A_BCM1480_IMR_CPU2_BASE + R_BCM1480_IMR_MAILBOX_0_CPU),
+	IOADDR(A_BCM1480_IMR_CPU3_BASE + R_BCM1480_IMR_MAILBOX_0_CPU),
+};
+
+/*
+ * SMP init and finish on secondary CPUs
+ */
+void bcm1480_smp_init(void)
+{
+	unsigned int imask = STATUSF_IP4 | STATUSF_IP3 | STATUSF_IP2 |
+		STATUSF_IP1 | STATUSF_IP0;
+
+	/* Set interrupt mask, but don't enable */
+	change_c0_status(ST0_IM, imask);
+}
+
+void bcm1480_smp_finish(void)
+{
+	extern void bcm1480_time_init(void);
+	bcm1480_time_init();
+	local_irq_enable();
+}
+
+/*
+ * These are routines for dealing with the sb1250 smp capabilities
+ * independent of board/firmware
+ */
+
+/*
+ * Simple enough; everything is set up, so just poke the appropriate mailbox
+ * register, and we should be set
+ */
+void core_send_ipi(int cpu, unsigned int action)
+{
+	__raw_writeq((((u64)action)<< 48), mailbox_0_set_regs[cpu]);
+}
+
+void bcm1480_mailbox_interrupt(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+	unsigned int action;
+
+	kstat_this_cpu.irqs[K_BCM1480_INT_MBOX_0_0]++;
+	/* Load the mailbox register to figure out what we're supposed to do */
+	action = (__raw_readq(mailbox_0_regs[cpu]) >> 48) & 0xffff;
+
+	/* Clear the mailbox to clear the interrupt */
+	__raw_writeq(((u64)action)<<48, mailbox_0_clear_regs[cpu]);
+
+	/*
+	 * Nothing to do for SMP_RESCHEDULE_YOURSELF; returning from the
+	 * interrupt will do the reschedule for us
+	 */
+
+	if (action & SMP_CALL_FUNCTION)
+		smp_call_function_interrupt();
+}
diff -Naur linux-2.6.14/arch/mips/sibyte/bcm1480/time.c linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/time.c
--- linux-2.6.14/arch/mips/sibyte/bcm1480/time.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/bcm1480/time.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2000,2001,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * These are routines to set up and handle interrupts from the
+ * bcm1480 general purpose timer 0.  We're using the timer as a
+ * system clock, so we set it up to run at 100 Hz.  On every
+ * interrupt, we update our idea of what the time of day is,
+ * then call do_timer() in the architecture-independent kernel
+ * code to do general bookkeeping (e.g. update jiffies, run
+ * bottom halves, etc.)
+ */
+#include <linux/config.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/kernel_stat.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/io.h>
+
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+#include <asm/sibyte/bcm1480_scd.h>
+
+#include <asm/sibyte/sb1250.h>
+
+
+#define IMR_IP2_VAL	K_BCM1480_INT_MAP_I0
+#define IMR_IP3_VAL	K_BCM1480_INT_MAP_I1
+#define IMR_IP4_VAL	K_BCM1480_INT_MAP_I2
+
+extern int bcm1480_steal_irq(int irq);
+
+void bcm1480_time_init(void)
+{
+	int cpu = smp_processor_id();
+	int irq = K_BCM1480_INT_TIMER_0+cpu;
+
+	/* Only have 4 general purpose timers */
+	if (cpu > 3) {
+		BUG();
+	}
+
+	if (!cpu) {
+		/* Use our own gettimeoffset() routine */
+		do_gettimeoffset = bcm1480_gettimeoffset;
+	}
+
+	bcm1480_mask_irq(cpu, irq);
+
+	/* Map the timer interrupt to ip[4] of this cpu */
+	__raw_writeq(IMR_IP4_VAL, IOADDR(A_BCM1480_IMR_REGISTER(cpu, R_BCM1480_IMR_INTERRUPT_MAP_BASE_H)
+	      + (irq<<3)));
+
+	/* the general purpose timer ticks at 1 Mhz independent of the rest of the system */
+	/* Disable the timer and set up the count */
+	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__raw_writeq(
+#ifndef CONFIG_SIMULATION
+		1000000/HZ
+#else
+		50000/HZ
+#endif
+		, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+
+	/* Set the timer running */
+	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
+	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+
+	bcm1480_unmask_irq(cpu, irq);
+	bcm1480_steal_irq(irq);
+	/*
+	 * This interrupt is "special" in that it doesn't use the request_irq
+	 * way to hook the irq line.  The timer interrupt is initialized early
+	 * enough to make this a major pain, and it's also firing enough to
+	 * warrant a bit of special case code.  bcm1480_timer_interrupt is
+	 * called directly from irq_handler.S when IP[4] is set during an
+	 * interrupt
+	 */
+}
+
+#include <asm/sibyte/sb1250.h>
+
+void bcm1480_timer_interrupt(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+	int irq = K_BCM1480_INT_TIMER_0+cpu;
+
+	/* Reset the timer */
+	__raw_writeq(M_SCD_TIMER_ENABLE|M_SCD_TIMER_MODE_CONTINUOUS,
+	      IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+
+	/*
+	 * CPU 0 handles the global timer interrupt job
+	 */
+	if (cpu == 0) {
+		ll_timer_interrupt(irq, regs);
+	}
+
+	/*
+	 * every CPU should do profiling and process accouting
+	 */
+	ll_local_timer_interrupt(irq, regs);
+}
+
+/*
+ * We use our own do_gettimeoffset() instead of the generic one,
+ * because the generic one does not work for SMP case.
+ * In addition, since we use general timer 0 for system time,
+ * we can get accurate intra-jiffy offset without calibration.
+ */
+unsigned long bcm1480_gettimeoffset(void)
+{
+	unsigned long count =
+		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
+
+	return 1000000/HZ - count;
+}
diff -Naur linux-2.6.14/arch/mips/sibyte/cfe/smp.c linux-mips-2.6.14.orig/arch/mips/sibyte/cfe/smp.c
--- linux-2.6.14/arch/mips/sibyte/cfe/smp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/cfe/smp.c	2005-11-17 11:42:29.000000000 -0800
@@ -70,8 +70,15 @@
  */
 void prom_init_secondary(void)
 {
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+	extern void bcm1480_smp_init(void);
+	bcm1480_smp_init();
+#elif defined(CONFIG_SIBYTE_SB1250)
 	extern void sb1250_smp_init(void);
 	sb1250_smp_init();
+#else
+#error invalid SMP configuration
+#endif
 }
 
 /*
@@ -80,8 +87,15 @@
  */
 void prom_smp_finish(void)
 {
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+	extern void bcm1480_smp_finish(void);
+	bcm1480_smp_finish();
+#elif defined(CONFIG_SIBYTE_SB1250)
 	extern void sb1250_smp_finish(void);
 	sb1250_smp_finish();
+#else
+#error invalid SMP configuration
+#endif
 }
 
 /*
diff -Naur linux-2.6.14/arch/mips/sibyte/Kconfig linux-mips-2.6.14.orig/arch/mips/sibyte/Kconfig
--- linux-2.6.14/arch/mips/sibyte/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,161 @@
+config SIBYTE_SB1250
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_HAS_LDT
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1120
+	bool
+	select SIBYTE_BCM112X
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1125
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_BCM112X
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1125H
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_BCM112X
+	select SIBYTE_HAS_LDT
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM112X
+	bool
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1x80
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1x55
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_SB1xxx_SOC
+	bool
+	depends on EXPERIMENTAL
+	select DMA_COHERENT
+	select SIBYTE_CFE
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+
+choice
+	prompt "SiByte SOC Stepping"
+	depends on SIBYTE_SB1xxx_SOC
+
+config CPU_SB1_PASS_1
+	bool "1250 Pass1"
+	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
+
+config CPU_SB1_PASS_2_1250
+	bool "1250 An"
+	depends on SIBYTE_SB1250
+	select CPU_SB1_PASS_2
+	help
+	  Also called BCM1250 Pass 2
+
+config CPU_SB1_PASS_2_2
+	bool "1250 Bn"
+	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
+	help
+	  Also called BCM1250 Pass 2.2
+
+config CPU_SB1_PASS_4
+	bool "1250 Cn"
+	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
+	help
+	  Also called BCM1250 Pass 3
+
+config CPU_SB1_PASS_2_112x
+	bool "112x Hybrid"
+	depends on SIBYTE_BCM112X
+	select CPU_SB1_PASS_2
+
+config CPU_SB1_PASS_3
+	bool "112x An"
+	depends on SIBYTE_BCM112X
+	select CPU_HAS_PREFETCH
+
+endchoice
+
+config CPU_SB1_PASS_2
+	bool
+
+config SIBYTE_HAS_LDT
+	bool
+	depends on PCI && (SIBYTE_SB1250 || SIBYTE_BCM1125H)
+	default y
+
+config SIMULATION
+	bool "Running under simulation"
+	depends on SIBYTE_SB1xxx_SOC
+	help
+	  Build a kernel suitable for running under the GDB simulator.
+	  Primarily adjusts the kernel's notion of time.
+
+config CONFIG_SB1_CEX_ALWAYS_FATAL
+	bool "All cache exceptions considered fatal (no recovery attempted)"
+	depends on SIBYTE_SB1xxx_SOC
+
+config CONFIG_SB1_CERR_STALL
+	bool "Stall (rather than panic) on fatal cache error"
+	depends on SIBYTE_SB1xxx_SOC
+
+config SIBYTE_CFE
+	bool "Booting from CFE"
+	depends on SIBYTE_SB1xxx_SOC
+	help
+	  Make use of the CFE API for enumerating available memory,
+	  controlling secondary CPUs, and possibly console output.
+
+config SIBYTE_CFE_CONSOLE
+	bool "Use firmware console"
+	depends on SIBYTE_CFE
+	help
+	  Use the CFE API's console write routines during boot.  Other console
+	  options (VT console, sb1250 duart console, etc.) should not be
+	  configured.
+
+config SIBYTE_STANDALONE
+	bool
+	depends on SIBYTE_SB1xxx_SOC && !SIBYTE_CFE
+	default y
+
+config SIBYTE_STANDALONE_RAM_SIZE
+	int "Memory size (in megabytes)"
+	depends on SIBYTE_STANDALONE
+	default "32"
+
+config SIBYTE_BUS_WATCHER
+	bool "Support for Bus Watcher statistics"
+	depends on SIBYTE_SB1xxx_SOC
+	help
+	  Handle and keep statistics on the bus error interrupts (COR_ECC,
+	  BAD_ECC, IO_BUS).
+
+config SIBYTE_BW_TRACE
+	bool "Capture bus trace before bus error"
+	depends on SIBYTE_BUS_WATCHER
+	help
+	  Run a continuous bus trace, dumping the raw data as soon as
+	  a ZBbus error is detected.  Cannot work if ZBbus profiling
+	  is turned on, and also will interfere with JTAG-based trace
+	  buffer activity.  Raw buffer data is dumped to console, and
+	  must be processed off-line.
+
+config SIBYTE_SB1250_PROF
+	bool "Support for SB1/SOC profiling - SB1/SCD perf counters"
+	depends on SIBYTE_SB1xxx_SOC
+
+config SIBYTE_TBPROF
+	bool "Support for ZBbus profiling"
+	depends on SIBYTE_SB1xxx_SOC
diff -Naur linux-2.6.14/arch/mips/sibyte/sb1250/bcm1250_tbprof.c linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/bcm1250_tbprof.c
--- linux-2.6.14/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2005-11-17 11:42:29.000000000 -0800
@@ -28,6 +28,8 @@
 #include <linux/fs.h>
 #include <linux/errno.h>
 #include <linux/reboot.h>
+#include <linux/smp_lock.h>
+#include <linux/wait.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sibyte/sb1250.h>
@@ -64,24 +66,25 @@
 	u_int64_t tb_options = M_SCD_TRACE_CFG_FREEZE_FULL;
 	/* Generate an SCD_PERFCNT interrupt in TB_PERIOD Zclks to
 	   trigger start of trace.  XXX vary sampling period */
-	bus_writeq(0, IOADDR(A_SCD_PERF_CNT_1));
-	scdperfcnt = bus_readq(IOADDR(A_SCD_PERF_CNT_CFG));
+	__raw_writeq(0, IOADDR(A_SCD_PERF_CNT_1));
+	scdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));
 	/* Unfortunately, in Pass 2 we must clear all counters to knock down
 	   a previous interrupt request.  This means that bus profiling
 	   requires ALL of the SCD perf counters. */
-	bus_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) | // keep counters 0,2,3 as is
-		   M_SPC_CFG_ENABLE |		 // enable counting
-		   M_SPC_CFG_CLEAR |		 // clear all counters
-		   V_SPC_CFG_SRC1(1),		 // counter 1 counts cycles
-		   IOADDR(A_SCD_PERF_CNT_CFG));
-	bus_writeq(next, IOADDR(A_SCD_PERF_CNT_1));
+	__raw_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) |
+						// keep counters 0,2,3 as is
+		     M_SPC_CFG_ENABLE |		// enable counting
+		     M_SPC_CFG_CLEAR |		// clear all counters
+		     V_SPC_CFG_SRC1(1),		// counter 1 counts cycles
+		     IOADDR(A_SCD_PERF_CNT_CFG));
+	__raw_writeq(next, IOADDR(A_SCD_PERF_CNT_1));
 	/* Reset the trace buffer */
-	bus_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+	__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 #if 0 && defined(M_SCD_TRACE_CFG_FORCECNT)
 	/* XXXKW may want to expose control to the data-collector */
 	tb_options |= M_SCD_TRACE_CFG_FORCECNT;
 #endif
-	bus_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));
+	__raw_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));
 	sbp.tb_armed = 1;
 }
 
@@ -93,23 +96,30 @@
 		/* XXX should use XKPHYS to make writes bypass L2 */
 		u_int64_t *p = sbp.sbprof_tbbuf[sbp.next_tb_sample++];
 		/* Read out trace */
-		bus_writeq(M_SCD_TRACE_CFG_START_READ, IOADDR(A_SCD_TRACE_CFG));
+		__raw_writeq(M_SCD_TRACE_CFG_START_READ,
+			     IOADDR(A_SCD_TRACE_CFG));
 		__asm__ __volatile__ ("sync" : : : "memory");
 		/* Loop runs backwards because bundles are read out in reverse order */
 		for (i = 256 * 6; i > 0; i -= 6) {
 			// Subscripts decrease to put bundle in the order
 			//   t0 lo, t0 hi, t1 lo, t1 hi, t2 lo, t2 hi
-			p[i-1] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 hi
-			p[i-2] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 lo
-			p[i-3] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 hi
-			p[i-4] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 lo
-			p[i-5] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 hi
-			p[i-6] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 lo
+			p[i - 1] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t2 hi
+			p[i - 2] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t2 lo
+			p[i - 3] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t1 hi
+			p[i - 4] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t1 lo
+			p[i - 5] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t0 hi
+			p[i - 6] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t0 lo
 		}
 		if (!sbp.tb_enable) {
 			DBG(printk(DEVNAME ": tb_intr shutdown\n"));
-			bus_writeq(M_SCD_TRACE_CFG_RESET,
-				   IOADDR(A_SCD_TRACE_CFG));
+			__raw_writeq(M_SCD_TRACE_CFG_RESET,
+				     IOADDR(A_SCD_TRACE_CFG));
 			sbp.tb_armed = 0;
 			wake_up(&sbp.tb_sync);
 		} else {
@@ -118,7 +128,7 @@
 	} else {
 		/* No more trace buffer samples */
 		DBG(printk(DEVNAME ": tb_intr full\n"));
-		bus_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+		__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 		sbp.tb_armed = 0;
 		if (!sbp.tb_enable) {
 			wake_up(&sbp.tb_sync);
@@ -152,13 +162,11 @@
 		return -EBUSY;
 	}
 	/* Make sure there isn't a perf-cnt interrupt waiting */
-	scdperfcnt = bus_readq(IOADDR(A_SCD_PERF_CNT_CFG));
+	scdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));
 	/* Disable and clear counters, override SRC_1 */
-	bus_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |
-		   M_SPC_CFG_ENABLE |
-		   M_SPC_CFG_CLEAR |
-		   V_SPC_CFG_SRC1(1),
-		   IOADDR(A_SCD_PERF_CNT_CFG));
+	__raw_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |
+		     M_SPC_CFG_ENABLE | M_SPC_CFG_CLEAR | V_SPC_CFG_SRC1(1),
+		     IOADDR(A_SCD_PERF_CNT_CFG));
 
 	/* We grab this interrupt to prevent others from trying to use
            it, even though we don't want to service the interrupts
@@ -172,55 +180,55 @@
 	/* I need the core to mask these, but the interrupt mapper to
 	   pass them through.  I am exploiting my knowledge that
 	   cp0_status masks out IP[5]. krw */
-	bus_writeq(K_INT_MAP_I3,
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-			  (K_INT_PERF_CNT << 3)));
+	__raw_writeq(K_INT_MAP_I3,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+			    (K_INT_PERF_CNT << 3)));
 
 	/* Initialize address traps */
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));
-
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));
-
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));
+
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));
+
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));
 
 	/* Initialize Trace Event 0-7 */
 	//				when interrupt
-	bus_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));
+	__raw_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));
 
 	/* Initialize Trace Sequence 0-7 */
 	//				     Start on event 0 (interrupt)
-	bus_writeq(V_SCD_TRSEQ_FUNC_START | 0x0fff,
-		   IOADDR(A_SCD_TRACE_SEQUENCE_0));
+	__raw_writeq(V_SCD_TRSEQ_FUNC_START | 0x0fff,
+		     IOADDR(A_SCD_TRACE_SEQUENCE_0));
 	//			  dsamp when d used | asamp when a used
-	bus_writeq(M_SCD_TRSEQ_ASAMPLE | M_SCD_TRSEQ_DSAMPLE |
-		   K_SCD_TRSEQ_TRIGGER_ALL,
-		   IOADDR(A_SCD_TRACE_SEQUENCE_1));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));
+	__raw_writeq(M_SCD_TRSEQ_ASAMPLE | M_SCD_TRSEQ_DSAMPLE |
+		     K_SCD_TRSEQ_TRIGGER_ALL,
+		     IOADDR(A_SCD_TRACE_SEQUENCE_1));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));
 
 	/* Now indicate the PERF_CNT interrupt as a trace-relevant interrupt */
-	bus_writeq((1ULL << K_INT_PERF_CNT),
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));
+	__raw_writeq(1ULL << K_INT_PERF_CNT,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));
 
 	arm_tb();
 
@@ -231,6 +239,7 @@
 
 int sbprof_zbprof_stop(void)
 {
+	DEFINE_WAIT(wait);
 	DBG(printk(DEVNAME ": stopping\n"));
 
 	if (sbp.tb_enable) {
@@ -240,7 +249,9 @@
 		   this sleep happens. */
 		if (sbp.tb_armed) {
 			DBG(printk(DEVNAME ": wait for disarm\n"));
-			interruptible_sleep_on(&sbp.tb_sync);
+			prepare_to_wait(&sbp.tb_sync, &wait, TASK_INTERRUPTIBLE);
+			schedule();
+			finish_wait(&sbp.tb_sync, &wait);
 			DBG(printk(DEVNAME ": disarm complete\n"));
 		}
 		free_irq(K_INT_TRACE_FREEZE, &sbp);
@@ -333,13 +344,13 @@
 	return count;
 }
 
-static int sbprof_tb_ioctl(struct inode *inode,
-			   struct file *filp,
-			   unsigned int command,
-			   unsigned long arg)
+static long sbprof_tb_ioctl(struct file *filp,
+			    unsigned int command,
+			    unsigned long arg)
 {
 	int error = 0;
 
+	lock_kernel();
 	switch (command) {
 	case SBPROF_ZBSTART:
 		error = sbprof_zbprof_start(filp);
@@ -348,13 +359,17 @@
 		error = sbprof_zbprof_stop();
 		break;
 	case SBPROF_ZBWAITFULL:
-		interruptible_sleep_on(&sbp.tb_read);
+		DEFINE_WAIT(wait);
+		prepare_to_wait(&sbp.tb_read, &wait, TASK_INTERRUPTIBLE);
+		schedule();
+		finish_wait(&sbp.tb_read, &wait);
 		/* XXXKW check if interrupted? */
 		return put_user(TB_FULL, (int *) arg);
 	default:
 		error = -EINVAL;
 		break;
 	}
+	unlock_kernel();
 
 	return error;
 }
@@ -364,7 +379,8 @@
 	.open		= sbprof_tb_open,
 	.release	= sbprof_tb_release,
 	.read		= sbprof_tb_read,
-	.ioctl		= sbprof_tb_ioctl,
+	.unlocked_ioctl	= sbprof_tb_ioctl,
+	.compat_ioctl	= sbprof_tb_ioctl,
 	.mmap		= NULL,
 };
 
diff -Naur linux-2.6.14/arch/mips/sibyte/sb1250/bus_watcher.c linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/bus_watcher.c
--- linux-2.6.14/arch/mips/sibyte/sb1250/bus_watcher.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/bus_watcher.c	2005-11-17 11:42:29.000000000 -0800
@@ -189,7 +189,7 @@
 
 	for (i=0; i<256*6; i++)
 		printk("%016llx\n",
-		       (unsigned long long)bus_readq(IOADDR(A_SCD_TRACE_READ)));
+		       (long long)__raw_readq(IOADDR(A_SCD_TRACE_READ)));
 
 	csr_out32(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 	csr_out32(M_SCD_TRACE_CFG_START, IOADDR(A_SCD_TRACE_CFG));
diff -Naur linux-2.6.14/arch/mips/sibyte/sb1250/irq.c linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/irq.c
--- linux-2.6.14/arch/mips/sibyte/sb1250/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -53,7 +53,7 @@
 static unsigned int startup_sb1250_irq(unsigned int irq);
 static void ack_sb1250_irq(unsigned int irq);
 #ifdef CONFIG_SMP
-static void sb1250_set_affinity(unsigned int irq, unsigned long mask);
+static void sb1250_set_affinity(unsigned int irq, cpumask_t mask);
 #endif
 
 #ifdef CONFIG_SIBYTE_HAS_LDT
@@ -71,17 +71,15 @@
 #endif
 
 static struct hw_interrupt_type sb1250_irq_type = {
-	"SB1250-IMR",
-	startup_sb1250_irq,
-	shutdown_sb1250_irq,
-	enable_sb1250_irq,
-	disable_sb1250_irq,
-	ack_sb1250_irq,
-	end_sb1250_irq,
+	.typename = "SB1250-IMR",
+	.startup = startup_sb1250_irq,
+	.shutdown = shutdown_sb1250_irq,
+	.enable = enable_sb1250_irq,
+	.disable = disable_sb1250_irq,
+	.ack = ack_sb1250_irq,
+	.end = end_sb1250_irq,
 #ifdef CONFIG_SMP
-	sb1250_set_affinity
-#else
-	NULL
+	.set_affinity = sb1250_set_affinity
 #endif
 };
 
@@ -96,11 +94,11 @@
 	u64 cur_ints;
 
 	spin_lock_irqsave(&sb1250_imr_lock, flags);
-	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	cur_ints |= (((u64) 1) << irq);
-	__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	spin_unlock_irqrestore(&sb1250_imr_lock, flags);
 }
 
@@ -110,32 +108,25 @@
 	u64 cur_ints;
 
 	spin_lock_irqsave(&sb1250_imr_lock, flags);
-	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	cur_ints &= ~(((u64) 1) << irq);
-	__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	spin_unlock_irqrestore(&sb1250_imr_lock, flags);
 }
 
 #ifdef CONFIG_SMP
-static void sb1250_set_affinity(unsigned int irq, unsigned long mask)
+static void sb1250_set_affinity(unsigned int irq, cpumask_t mask)
 {
 	int i = 0, old_cpu, cpu, int_on;
 	u64 cur_ints;
 	irq_desc_t *desc = irq_desc + irq;
 	unsigned long flags;
 
-	while (mask) {
-		if (mask & 1) {
-			mask >>= 1;
-			break;
-		}
-		mask >>= 1;
-		i++;
-	}
+	i = first_cpu(mask);
 
-	if (mask) {
+	if (cpus_weight(mask) > 1) {
 		printk("attempted to set irq affinity for irq %d to multiple CPUs\n", irq);
 		return;
 	}
@@ -149,23 +140,23 @@
 
 	/* Swizzle each CPU's IMR (but leave the IP selection alone) */
 	old_cpu = sb1250_irq_owner[irq];
-	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(old_cpu) +
-			       R_IMR_INTERRUPT_MASK));
+	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(old_cpu) +
+					R_IMR_INTERRUPT_MASK));
 	int_on = !(cur_ints & (((u64) 1) << irq));
 	if (int_on) {
 		/* If it was on, mask it */
 		cur_ints |= (((u64) 1) << irq);
-		__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(old_cpu) +
-					      R_IMR_INTERRUPT_MASK));
+		____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(old_cpu) +
+					R_IMR_INTERRUPT_MASK));
 	}
 	sb1250_irq_owner[irq] = cpu;
 	if (int_on) {
 		/* unmask for the new CPU */
-		cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
-				       R_IMR_INTERRUPT_MASK));
+		cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 		cur_ints &= ~(((u64) 1) << irq);
-		__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
-					      R_IMR_INTERRUPT_MASK));
+		____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	}
 	spin_unlock(&sb1250_imr_lock);
 	spin_unlock_irqrestore(&desc->lock, flags);
@@ -208,8 +199,8 @@
 	 * deliver the interrupts to all CPUs (which makes affinity
 	 * changing easier for us)
 	 */
-	pending = bus_readq(IOADDR(A_IMR_REGISTER(sb1250_irq_owner[irq],
-						  R_IMR_LDT_INTERRUPT)));
+	pending = __raw_readq(IOADDR(A_IMR_REGISTER(sb1250_irq_owner[irq],
+						    R_IMR_LDT_INTERRUPT)));
 	pending &= ((u64)1 << (irq));
 	if (pending) {
 		int i;
@@ -224,8 +215,8 @@
 			 * Clear for all CPUs so an affinity switch
 			 * doesn't find an old status
 			 */
-			bus_writeq(pending,
-				   IOADDR(A_IMR_REGISTER(cpu,
+			__raw_writeq(pending,
+				     IOADDR(A_IMR_REGISTER(cpu,
 						R_IMR_LDT_INTERRUPT_CLR)));
 		}
 
@@ -340,12 +331,14 @@
 
 	/* Default everything to IP2 */
 	for (i = 0; i < SB1250_NR_IRQS; i++) {	/* was I0 */
-		bus_writeq(IMR_IP2_VAL,
-			   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-				  (i << 3)));
-		bus_writeq(IMR_IP2_VAL,
-			   IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
-				  (i << 3)));
+		__raw_writeq(IMR_IP2_VAL,
+			     IOADDR(A_IMR_REGISTER(0,
+						   R_IMR_INTERRUPT_MAP_BASE) +
+				    (i << 3)));
+		__raw_writeq(IMR_IP2_VAL,
+			     IOADDR(A_IMR_REGISTER(1,
+						   R_IMR_INTERRUPT_MAP_BASE) +
+				    (i << 3)));
 	}
 
 	init_sb1250_irqs();
@@ -355,23 +348,23 @@
 	 * inter-cpu messages
 	 */
 	/* Was I1 */
-	bus_writeq(IMR_IP3_VAL,
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-			  (K_INT_MBOX_0 << 3)));
-	bus_writeq(IMR_IP3_VAL,
-		   IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
-			  (K_INT_MBOX_0 << 3)));
+	__raw_writeq(IMR_IP3_VAL,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+			    (K_INT_MBOX_0 << 3)));
+	__raw_writeq(IMR_IP3_VAL,
+		     IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
+			    (K_INT_MBOX_0 << 3)));
 
 	/* Clear the mailboxes.  The firmware may leave them dirty */
-	bus_writeq(0xffffffffffffffffULL,
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_MAILBOX_CLR_CPU)));
-	bus_writeq(0xffffffffffffffffULL,
-		   IOADDR(A_IMR_REGISTER(1, R_IMR_MAILBOX_CLR_CPU)));
+	__raw_writeq(0xffffffffffffffffULL,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_MAILBOX_CLR_CPU)));
+	__raw_writeq(0xffffffffffffffffULL,
+		     IOADDR(A_IMR_REGISTER(1, R_IMR_MAILBOX_CLR_CPU)));
 
 	/* Mask everything except the mailbox registers for both cpus */
 	tmp = ~((u64) 0) ^ (((u64) 1) << K_INT_MBOX_0);
-	bus_writeq(tmp, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MASK)));
-	bus_writeq(tmp, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MASK)));
+	__raw_writeq(tmp, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MASK)));
+	__raw_writeq(tmp, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MASK)));
 
 	sb1250_steal_irq(K_INT_MBOX_0);
 
@@ -396,12 +389,14 @@
 		sb1250_duart_present[kgdb_port] = 0;
 #endif
 		/* Setup uart 1 settings, mapper */
-		bus_writeq(M_DUART_IMR_BRK, IOADDR(A_DUART_IMRREG(kgdb_port)));
+		__raw_writeq(M_DUART_IMR_BRK,
+			     IOADDR(A_DUART_IMRREG(kgdb_port)));
 
 		sb1250_steal_irq(kgdb_irq);
-		bus_writeq(IMR_IP6_VAL,
-			   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-				  (kgdb_irq<<3)));
+		__raw_writeq(IMR_IP6_VAL,
+			     IOADDR(A_IMR_REGISTER(0,
+						   R_IMR_INTERRUPT_MAP_BASE) +
+				    (kgdb_irq << 3)));
 		sb1250_unmask_irq(0, kgdb_irq);
 	}
 #endif
diff -Naur linux-2.6.14/arch/mips/sibyte/sb1250/setup.c linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/setup.c
--- linux-2.6.14/arch/mips/sibyte/sb1250/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -153,7 +153,7 @@
 	int bad_config = 0;
 
 	sb1_pass = read_c0_prid() & 0xff;
-	sys_rev = bus_readq(IOADDR(A_SCD_SYSTEM_REVISION));
+	sys_rev = __raw_readq(IOADDR(A_SCD_SYSTEM_REVISION));
 	soc_type = SYS_SOC_TYPE(sys_rev);
 	soc_pass = G_SYS_REVISION(sys_rev);
 
@@ -162,7 +162,7 @@
 		machine_restart(NULL);
 	}
 
-	plldiv = G_SYS_PLL_DIV(bus_readq(IOADDR(A_SCD_SYSTEM_CFG)));
+	plldiv = G_SYS_PLL_DIV(__raw_readq(IOADDR(A_SCD_SYSTEM_CFG)));
 	zbbus_mhz = ((plldiv >> 1) * 50) + ((plldiv & 1) * 25);
 
 	prom_printf("Broadcom SiByte %s %s @ %d MHz (SB1 rev %d)\n",
diff -Naur linux-2.6.14/arch/mips/sibyte/sb1250/smp.c linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/smp.c
--- linux-2.6.14/arch/mips/sibyte/sb1250/smp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/smp.c	2005-11-17 11:42:29.000000000 -0800
@@ -29,18 +29,18 @@
 #include <asm/sibyte/sb1250_int.h>
 
 static void *mailbox_set_regs[] = {
-	(void *)IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_SET_CPU),
-	(void *)IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_SET_CPU)
+	IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_SET_CPU),
+	IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_SET_CPU)
 };
 
 static void *mailbox_clear_regs[] = {
-	(void *)IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CLR_CPU),
-	(void *)IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CLR_CPU)
+	IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CLR_CPU),
+	IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CLR_CPU)
 };
 
 static void *mailbox_regs[] = {
-	(void *)IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CPU),
-	(void *)IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CPU)
+	IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CPU),
+	IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CPU)
 };
 
 /*
@@ -73,7 +73,7 @@
  */
 void core_send_ipi(int cpu, unsigned int action)
 {
-	bus_writeq((((u64)action) << 48), mailbox_set_regs[cpu]);
+	__raw_writeq((((u64)action) << 48), mailbox_set_regs[cpu]);
 }
 
 void sb1250_mailbox_interrupt(struct pt_regs *regs)
@@ -83,10 +83,10 @@
 
 	kstat_this_cpu.irqs[K_INT_MBOX_0]++;
 	/* Load the mailbox register to figure out what we're supposed to do */
-	action = (__bus_readq(mailbox_regs[cpu]) >> 48) & 0xffff;
+	action = (____raw_readq(mailbox_regs[cpu]) >> 48) & 0xffff;
 
 	/* Clear the mailbox to clear the interrupt */
-	__bus_writeq(((u64)action) << 48, mailbox_clear_regs[cpu]);
+	____raw_writeq(((u64)action) << 48, mailbox_clear_regs[cpu]);
 
 	/*
 	 * Nothing to do for SMP_RESCHEDULE_YOURSELF; returning from the
diff -Naur linux-2.6.14/arch/mips/sibyte/sb1250/time.c linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/time.c
--- linux-2.6.14/arch/mips/sibyte/sb1250/time.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/sb1250/time.c	2005-11-17 11:42:29.000000000 -0800
@@ -67,24 +67,24 @@
 	sb1250_mask_irq(cpu, irq);
 
 	/* Map the timer interrupt to ip[4] of this cpu */
-	bus_writeq(IMR_IP4_VAL,
-		   IOADDR(A_IMR_REGISTER(cpu, R_IMR_INTERRUPT_MAP_BASE) +
-			  (irq << 3)));
+	__raw_writeq(IMR_IP4_VAL,
+		     IOADDR(A_IMR_REGISTER(cpu, R_IMR_INTERRUPT_MAP_BASE) +
+			    (irq << 3)));
 
 	/* the general purpose timer ticks at 1 Mhz independent if the rest of the system */
 	/* Disable the timer and set up the count */
-	bus_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 #ifdef CONFIG_SIMULATION
-	bus_writeq(50000 / HZ,
-		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	__raw_writeq(50000 / HZ,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 #else
-	bus_writeq(1000000/HZ,
-		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	__raw_writeq(1000000 / HZ,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 #endif
 
 	/* Set the timer running */
-	bus_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
 	sb1250_unmask_irq(cpu, irq);
 	sb1250_steal_irq(irq);
@@ -100,25 +100,25 @@
 
 void sb1250_timer_interrupt(struct pt_regs *regs)
 {
-	extern asmlinkage void ll_local_timer_interrupt(int irq, struct pt_regs *regs);
 	int cpu = smp_processor_id();
 	int irq = K_INT_TIMER_0 + cpu;
 
 	/* Reset the timer */
-	__bus_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	____raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+		       IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
-	/*
-	 * CPU 0 handles the global timer interrupt job
-	 */
 	if (cpu == 0) {
+		/*
+		 * CPU 0 handles the global timer interrupt job
+		 */
 		ll_timer_interrupt(irq, regs);
 	}
-
-	/*
-	 * every CPU should do profiling and process accouting
-	 */
-	ll_local_timer_interrupt(irq, regs);
+	else {
+		/*
+		 * other CPUs should just do profiling and process accounting
+		 */
+		ll_local_timer_interrupt(irq, regs);
+	}
 }
 
 /*
@@ -130,7 +130,7 @@
 unsigned long sb1250_gettimeoffset(void)
 {
 	unsigned long count =
-		bus_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
+		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
 
 	return 1000000/HZ - count;
  }
diff -Naur linux-2.6.14/arch/mips/sibyte/swarm/rtc_m41t81.c linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/rtc_m41t81.c
--- linux-2.6.14/arch/mips/sibyte/swarm/rtc_m41t81.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/rtc_m41t81.c	2005-11-17 11:42:29.000000000 -0800
@@ -82,59 +82,60 @@
 #define M41T81REG_SQW	0x13		/* square wave register */
 
 #define M41T81_CCR_ADDRESS	0x68
-#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+
+#define SMB_CSR(reg)	IOADDR(A_SMB_REGISTER(1, reg))
 
 static int m41t81_read(uint8_t addr)
 {
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
-	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	}
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int m41t81_write(uint8_t addr, int b)
 {
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq((addr & 0xFF), SMB_CSR(R_SMB_CMD));
-	bus_writeq((b & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(b & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	}
 
 	/* read the same byte again to make sure it is written */
-	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
 	return 0;
diff -Naur linux-2.6.14/arch/mips/sibyte/swarm/rtc_xicor1241.c linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/rtc_xicor1241.c
--- linux-2.6.14/arch/mips/sibyte/swarm/rtc_xicor1241.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/rtc_xicor1241.c	2005-11-17 11:42:29.000000000 -0800
@@ -57,52 +57,52 @@
 
 #define X1241_CCR_ADDRESS	0x6F
 
-#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+#define SMB_CSR(reg)	IOADDR(A_SMB_REGISTER(1, reg))
 
 static int xicor_read(uint8_t addr)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
+	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;
diff -Naur linux-2.6.14/arch/mips/sibyte/swarm/setup.c linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/setup.c
--- linux-2.6.14/arch/mips/sibyte/swarm/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
+ * Copyright (C) 2000, 2001, 2002, 2003, 2004 Broadcom Corporation
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  * This program is free software; you can redistribute it and/or
@@ -39,11 +39,23 @@
 #include <asm/time.h>
 #include <asm/traps.h>
 #include <asm/sibyte/sb1250.h>
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+#include <asm/sibyte/bcm1480_regs.h>
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
 #include <asm/sibyte/sb1250_regs.h>
+#else
+#error invalid SiByte board configuation
+#endif
 #include <asm/sibyte/sb1250_genbus.h>
 #include <asm/sibyte/board.h>
 
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+extern void bcm1480_setup(void);
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
 extern void sb1250_setup(void);
+#else
+#error invalid SiByte board configuation
+#endif
 
 extern int xicor_probe(void);
 extern int xicor_set_time(unsigned long);
@@ -66,27 +78,34 @@
          */
 
         /* We only need to setup the generic timer */
-        sb1250_time_init();
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+	bcm1480_time_init();
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
+	sb1250_time_init();
+#else
+#error invalid SiByte board configuation
+#endif
 }
 
 int swarm_be_handler(struct pt_regs *regs, int is_fixup)
 {
 	if (!is_fixup && (regs->cp0_cause & 4)) {
 		/* Data bus error - print PA */
-#ifdef CONFIG_64BIT
-		printk("DBE physical address: %010lx\n",
+		printk("DBE physical address: %010Lx\n",
 		       __read_64bit_c0_register($26, 1));
-#else
-		printk("DBE physical address: %010llx\n",
-		       __read_64bit_c0_split($26, 1));
-#endif
 	}
 	return (is_fixup ? MIPS_BE_FIXUP : MIPS_BE_FATAL);
 }
 
-static int __init swarm_setup(void)
+void __init plat_setup(void)
 {
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+	bcm1480_setup();
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
 	sb1250_setup();
+#else
+#error invalid SiByte board configuation
+#endif
 
 	panic_timeout = 5;  /* For debug.  */
 
@@ -133,12 +152,8 @@
        };
        /* XXXKW for CFE, get lines/cols from environment */
 #endif
-
-	return 0;
 }
 
-early_initcall(swarm_setup);
-
 #ifdef LEDS_PHYS
 
 #ifdef CONFIG_SIBYTE_CARMEL
diff -Naur linux-2.6.14/arch/mips/sibyte/swarm/time.c linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/time.c
--- linux-2.6.14/arch/mips/sibyte/swarm/time.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sibyte/swarm/time.c	2005-11-17 11:42:29.000000000 -0800
@@ -79,48 +79,48 @@
 
 static int xicor_read(uint8_t addr)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
+	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;
@@ -228,8 +228,8 @@
 	/* Establish communication with the Xicor 1241 RTC */
 	/* XXXKW how do I share the SMBus with the I2C subsystem? */
 
-	bus_writeq(K_SMB_FREQ_400KHZ, SMB_CSR(R_SMB_FREQ));
-	bus_writeq(0, SMB_CSR(R_SMB_CONTROL));
+	__raw_writeq(K_SMB_FREQ_400KHZ, SMB_CSR(R_SMB_FREQ));
+	__raw_writeq(0, SMB_CSR(R_SMB_CONTROL));
 
 	if ((status = xicor_read(X1241REG_SR_RTCF)) < 0) {
 		printk("x1241: couldn't detect on SWARM SMBus 1\n");
diff -Naur linux-2.6.14/arch/mips/sni/irq.c linux-mips-2.6.14.orig/arch/mips/sni/irq.c
--- linux-2.6.14/arch/mips/sni/irq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sni/irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -58,14 +58,13 @@
 }
 
 static struct hw_interrupt_type pciasic_irq_type = {
-	"ASIC-PCI",
-	startup_pciasic_irq,
-	shutdown_pciasic_irq,
-	enable_pciasic_irq,
-	disable_pciasic_irq,
-	mask_and_ack_pciasic_irq,
-	end_pciasic_irq,
-	NULL
+	.typename = "ASIC-PCI",
+	.startup = startup_pciasic_irq,
+	.shutdown = shutdown_pciasic_irq,
+	.enable = enable_pciasic_irq,
+	.disable = disable_pciasic_irq,
+	.ack = mask_and_ack_pciasic_irq,
+	.end = end_pciasic_irq,
 };
 
 /*
diff -Naur linux-2.6.14/arch/mips/sni/setup.c linux-mips-2.6.14.orig/arch/mips/sni/setup.c
--- linux-2.6.14/arch/mips/sni/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/sni/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -167,7 +167,7 @@
 	rtc_set_time = mc146818_set_rtc_mmss;
 }
 
-static int __init sni_rm200_pci_setup(void)
+void __init plat_setup(void)
 {
 	sni_pcimt_detect();
 	sni_pcimt_sc_init();
@@ -196,8 +196,4 @@
 #ifdef CONFIG_PCI
 	register_pci_controller(&sni_controller);
 #endif
-
-	return 0;
 }
-
-early_initcall(sni_rm200_pci_setup);
diff -Naur linux-2.6.14/arch/mips/tx4927/common/tx4927_setup.c linux-mips-2.6.14.orig/arch/mips/tx4927/common/tx4927_setup.c
--- linux-2.6.14/arch/mips/tx4927/common/tx4927_setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/tx4927/common/tx4927_setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -64,7 +64,7 @@
 }
 
 
-static void __init tx4927_setup(void)
+void __init plat_setup(void)
 {
 	board_time_init = tx4927_time_init;
 	board_timer_setup = tx4927_timer_setup;
@@ -76,12 +76,8 @@
 		toshiba_rbtx4927_setup();
 	}
 #endif
-
-	return;
 }
 
-early_initcall(tx4927_setup);
-
 void __init tx4927_time_init(void)
 {
 
diff -Naur linux-2.6.14/arch/mips/tx4927/Kconfig linux-mips-2.6.14.orig/arch/mips/tx4927/Kconfig
--- linux-2.6.14/arch/mips/tx4927/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4927/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,3 @@
+config TOSHIBA_FPCIB0
+	bool "FPCIB0 Backplane Support"
+	depends on TOSHIBA_RBTX4927
diff -Naur linux-2.6.14/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c linux-mips-2.6.14.orig/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c
--- linux-2.6.14/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -77,6 +77,11 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #endif
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
 
 #undef TOSHIBA_RBTX4927_SETUP_DEBUG
 
@@ -920,12 +925,30 @@
 
 #endif /* CONFIG_PCI */
 
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)(0xff1ff300 + i * 0x100);
+			req.mapbase = 0xff1ff300 + i * 0x100;
+			req.irq = 32 + i;
+			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = 50000000;
+			early_serial_txx9_setup(&req);
+		}
+	}
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
         argptr = prom_getcmdline();
         if (strstr(argptr, "console=") == NULL) {
                 strcat(argptr, " console=ttyS0,38400");
         }
 #endif
+#endif
 
 #ifdef CONFIG_ROOT_NFS
         argptr = prom_getcmdline();
diff -Naur linux-2.6.14/arch/mips/tx4938/common/dbgio.c linux-mips-2.6.14.orig/arch/mips/tx4938/common/dbgio.c
--- linux-2.6.14/arch/mips/tx4938/common/dbgio.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/dbgio.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,50 @@
+/*
+ * linux/arch/mips/tx4938/common/dbgio.c
+ *
+ * kgdb interface for gdb
+ *
+ * Author: MontaVista Software, Inc.
+ *         source@mvista.com
+ *
+ * Copyright 2005 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Support for TX4938 in 2.6 - Hiroshi DOYU <Hiroshi_DOYU@montavista.co.jp>
+ */
+
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/tx4938/tx4938_mips.h>
+
+extern u8 txx9_sio_kdbg_rd(void);
+extern int txx9_sio_kdbg_wr( u8 ch );
+
+u8 getDebugChar(void)
+{
+	return (txx9_sio_kdbg_rd());
+}
+
+int putDebugChar(u8 byte)
+{
+	return (txx9_sio_kdbg_wr(byte));
+}
+
diff -Naur linux-2.6.14/arch/mips/tx4938/common/irq.c linux-mips-2.6.14.orig/arch/mips/tx4938/common/irq.c
--- linux-2.6.14/arch/mips/tx4938/common/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,424 @@
+/*
+ * linux/arch/mps/tx4938/common/irq.c
+ *
+ * Common tx4938 irq handler
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/irq.h>
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/tx4938/rbtx4938.h>
+
+/**********************************************************************************/
+/* Forwad definitions for all pic's                                               */
+/**********************************************************************************/
+
+static unsigned int tx4938_irq_cp0_startup(unsigned int irq);
+static void tx4938_irq_cp0_shutdown(unsigned int irq);
+static void tx4938_irq_cp0_enable(unsigned int irq);
+static void tx4938_irq_cp0_disable(unsigned int irq);
+static void tx4938_irq_cp0_mask_and_ack(unsigned int irq);
+static void tx4938_irq_cp0_end(unsigned int irq);
+
+static unsigned int tx4938_irq_pic_startup(unsigned int irq);
+static void tx4938_irq_pic_shutdown(unsigned int irq);
+static void tx4938_irq_pic_enable(unsigned int irq);
+static void tx4938_irq_pic_disable(unsigned int irq);
+static void tx4938_irq_pic_mask_and_ack(unsigned int irq);
+static void tx4938_irq_pic_end(unsigned int irq);
+
+/**********************************************************************************/
+/* Kernel structs for all pic's                                                   */
+/**********************************************************************************/
+DEFINE_SPINLOCK(tx4938_cp0_lock);
+DEFINE_SPINLOCK(tx4938_pic_lock);
+
+#define TX4938_CP0_NAME "TX4938-CP0"
+static struct hw_interrupt_type tx4938_irq_cp0_type = {
+	.typename = TX4938_CP0_NAME,
+	.startup = tx4938_irq_cp0_startup,
+	.shutdown = tx4938_irq_cp0_shutdown,
+	.enable = tx4938_irq_cp0_enable,
+	.disable = tx4938_irq_cp0_disable,
+	.ack = tx4938_irq_cp0_mask_and_ack,
+	.end = tx4938_irq_cp0_end,
+	.set_affinity = NULL
+};
+
+#define TX4938_PIC_NAME "TX4938-PIC"
+static struct hw_interrupt_type tx4938_irq_pic_type = {
+	.typename = TX4938_PIC_NAME,
+	.startup = tx4938_irq_pic_startup,
+	.shutdown = tx4938_irq_pic_shutdown,
+	.enable = tx4938_irq_pic_enable,
+	.disable = tx4938_irq_pic_disable,
+	.ack = tx4938_irq_pic_mask_and_ack,
+	.end = tx4938_irq_pic_end,
+	.set_affinity = NULL
+};
+
+static struct irqaction tx4938_irq_pic_action = {
+	.handler = no_action,
+	.flags = 0,
+	.mask = CPU_MASK_NONE,
+	.name = TX4938_PIC_NAME
+};
+
+/**********************************************************************************/
+/* Functions for cp0                                                              */
+/**********************************************************************************/
+
+#define tx4938_irq_cp0_mask(irq) ( 1 << ( irq-TX4938_IRQ_CP0_BEG+8 ) )
+
+static void __init
+tx4938_irq_cp0_init(void)
+{
+	int i;
+
+	for (i = TX4938_IRQ_CP0_BEG; i <= TX4938_IRQ_CP0_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &tx4938_irq_cp0_type;
+	}
+
+	return;
+}
+
+static unsigned int
+tx4938_irq_cp0_startup(unsigned int irq)
+{
+	tx4938_irq_cp0_enable(irq);
+
+	return (0);
+}
+
+static void
+tx4938_irq_cp0_shutdown(unsigned int irq)
+{
+	tx4938_irq_cp0_disable(irq);
+}
+
+static void
+tx4938_irq_cp0_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_cp0_lock, flags);
+
+	set_c0_status(tx4938_irq_cp0_mask(irq));
+
+	spin_unlock_irqrestore(&tx4938_cp0_lock, flags);
+}
+
+static void
+tx4938_irq_cp0_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_cp0_lock, flags);
+
+	clear_c0_status(tx4938_irq_cp0_mask(irq));
+
+	spin_unlock_irqrestore(&tx4938_cp0_lock, flags);
+
+	return;
+}
+
+static void
+tx4938_irq_cp0_mask_and_ack(unsigned int irq)
+{
+	tx4938_irq_cp0_disable(irq);
+
+	return;
+}
+
+static void
+tx4938_irq_cp0_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		tx4938_irq_cp0_enable(irq);
+	}
+
+	return;
+}
+
+/**********************************************************************************/
+/* Functions for pic                                                              */
+/**********************************************************************************/
+
+u32
+tx4938_irq_pic_addr(int irq)
+{
+	/* MVMCP -- need to formulize this */
+	irq -= TX4938_IRQ_PIC_BEG;
+
+	switch (irq) {
+	case 17:
+	case 16:
+	case 1:
+	case 0:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL0));
+		}
+	case 19:
+	case 18:
+	case 3:
+	case 2:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL1));
+		}
+	case 21:
+	case 20:
+	case 5:
+	case 4:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL2));
+		}
+	case 23:
+	case 22:
+	case 7:
+	case 6:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL3));
+		}
+	case 25:
+	case 24:
+	case 9:
+	case 8:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL4));
+		}
+	case 27:
+	case 26:
+	case 11:
+	case 10:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL5));
+		}
+	case 29:
+	case 28:
+	case 13:
+	case 12:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL6));
+		}
+	case 31:
+	case 30:
+	case 15:
+	case 14:{
+			return (TX4938_MKA(TX4938_IRC_IRLVL7));
+		}
+	}
+
+	return (0);
+}
+
+u32
+tx4938_irq_pic_mask(int irq)
+{
+	/* MVMCP -- need to formulize this */
+	irq -= TX4938_IRQ_PIC_BEG;
+
+	switch (irq) {
+	case 31:
+	case 29:
+	case 27:
+	case 25:
+	case 23:
+	case 21:
+	case 19:
+	case 17:{
+			return (0x07000000);
+		}
+	case 30:
+	case 28:
+	case 26:
+	case 24:
+	case 22:
+	case 20:
+	case 18:
+	case 16:{
+			return (0x00070000);
+		}
+	case 15:
+	case 13:
+	case 11:
+	case 9:
+	case 7:
+	case 5:
+	case 3:
+	case 1:{
+			return (0x00000700);
+		}
+	case 14:
+	case 12:
+	case 10:
+	case 8:
+	case 6:
+	case 4:
+	case 2:
+	case 0:{
+			return (0x00000007);
+		}
+	}
+	return (0x00000000);
+}
+
+static void
+tx4938_irq_pic_modify(unsigned pic_reg, unsigned clr_bits, unsigned set_bits)
+{
+	unsigned long val = 0;
+
+	val = TX4938_RD(pic_reg);
+	val &= (~clr_bits);
+	val |= (set_bits);
+	TX4938_WR(pic_reg, val);
+	mmiowb();
+	TX4938_RD(pic_reg);
+
+	return;
+}
+
+static void __init
+tx4938_irq_pic_init(void)
+{
+	unsigned long flags;
+	int i;
+
+	for (i = TX4938_IRQ_PIC_BEG; i <= TX4938_IRQ_PIC_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 2;
+		irq_desc[i].handler = &tx4938_irq_pic_type;
+	}
+
+	setup_irq(TX4938_IRQ_NEST_PIC_ON_CP0, &tx4938_irq_pic_action);
+
+	spin_lock_irqsave(&tx4938_pic_lock, flags);
+
+	TX4938_WR(0xff1ff640, 0x6);	/* irq level mask -- only accept hightest */
+	TX4938_WR(0xff1ff600, TX4938_RD(0xff1ff600) | 0x1);	/* irq enable */
+
+	spin_unlock_irqrestore(&tx4938_pic_lock, flags);
+
+	return;
+}
+
+static unsigned int
+tx4938_irq_pic_startup(unsigned int irq)
+{
+	tx4938_irq_pic_enable(irq);
+
+	return (0);
+}
+
+static void
+tx4938_irq_pic_shutdown(unsigned int irq)
+{
+	tx4938_irq_pic_disable(irq);
+
+	return;
+}
+
+static void
+tx4938_irq_pic_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_pic_lock, flags);
+
+	tx4938_irq_pic_modify(tx4938_irq_pic_addr(irq), 0,
+			      tx4938_irq_pic_mask(irq));
+
+	spin_unlock_irqrestore(&tx4938_pic_lock, flags);
+
+	return;
+}
+
+static void
+tx4938_irq_pic_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tx4938_pic_lock, flags);
+
+	tx4938_irq_pic_modify(tx4938_irq_pic_addr(irq),
+			      tx4938_irq_pic_mask(irq), 0);
+
+	spin_unlock_irqrestore(&tx4938_pic_lock, flags);
+
+	return;
+}
+
+static void
+tx4938_irq_pic_mask_and_ack(unsigned int irq)
+{
+	tx4938_irq_pic_disable(irq);
+
+	return;
+}
+
+static void
+tx4938_irq_pic_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		tx4938_irq_pic_enable(irq);
+	}
+
+	return;
+}
+
+/**********************************************************************************/
+/* Main init functions                                                            */
+/**********************************************************************************/
+
+void __init
+tx4938_irq_init(void)
+{
+	extern asmlinkage void tx4938_irq_handler(void);
+
+	tx4938_irq_cp0_init();
+	tx4938_irq_pic_init();
+	set_except_vector(0, tx4938_irq_handler);
+
+	return;
+}
+
+int
+tx4938_irq_nested(void)
+{
+	int sw_irq = 0;
+	u32 level2;
+
+	level2 = TX4938_RD(0xff1ff6a0);
+	if ((level2 & 0x10000) == 0) {
+		level2 &= 0x1f;
+		sw_irq = TX4938_IRQ_PIC_BEG + level2;
+		if (sw_irq == 26) {
+			{
+				extern int toshiba_rbtx4938_irq_nested(int sw_irq);
+				sw_irq = toshiba_rbtx4938_irq_nested(sw_irq);
+			}
+		}
+	}
+
+	wbflush();
+	return (sw_irq);
+}
diff -Naur linux-2.6.14/arch/mips/tx4938/common/irq_handler.S linux-mips-2.6.14.orig/arch/mips/tx4938/common/irq_handler.S
--- linux-2.6.14/arch/mips/tx4938/common/irq_handler.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/irq_handler.S	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,84 @@
+/*
+ * linux/arch/mips/tx4938/common/handler.S
+ *
+ * Primary interrupt handler for tx4938 based systems
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/tx4938/rbtx4938.h>
+
+
+		.align	5
+		NESTED(tx4938_irq_handler, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+
+		mfc0	t0, CP0_CAUSE
+		mfc0	t1, CP0_STATUS
+		and	t0, t1
+
+		andi	t1, t0, STATUSF_IP7	/* cpu timer */
+		bnez	t1, ll_ip7
+
+		/* IP6..IP3 multiplexed -- do not use */
+
+		andi	t1, t0, STATUSF_IP2	/* tx4938 pic */
+		bnez	t1, ll_ip2
+
+		andi	t1, t0, STATUSF_IP1	/* user line 1 */
+		bnez	t1, ll_ip1
+
+		andi	t1, t0, STATUSF_IP0	/* user line 0 */
+		bnez	t1, ll_ip0
+
+		.set	reorder
+
+		nop
+		END(tx4938_irq_handler)
+
+		.align	5
+
+
+ll_ip7:
+		li	a0, TX4938_IRQ_CPU_TIMER
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+
+ll_ip2:
+		jal	tx4938_irq_nested
+		nop
+		beqz	v0, goto_spurious_interrupt
+		nop
+		move	a0, v0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+goto_spurious_interrupt:
+		j	ret_from_irq
+
+ll_ip1:
+		li	a0, TX4938_IRQ_USER1
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+
+ll_ip0:
+		li	a0, TX4938_IRQ_USER0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
diff -Naur linux-2.6.14/arch/mips/tx4938/common/Makefile linux-mips-2.6.14.orig/arch/mips/tx4938/common/Makefile
--- linux-2.6.14/arch/mips/tx4938/common/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/Makefile	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,11 @@
+#
+# Makefile for common code for Toshiba TX4927 based systems
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	+= prom.o setup.o irq.o irq_handler.o rtc_rx5c348.o
+obj-$(CONFIG_KGDB) += dbgio.o
+
diff -Naur linux-2.6.14/arch/mips/tx4938/common/prom.c linux-mips-2.6.14.orig/arch/mips/tx4938/common/prom.c
--- linux-2.6.14/arch/mips/tx4938/common/prom.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/prom.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,129 @@
+/*
+ * linux/arch/mips/tx4938/common/prom.c
+ *
+ * common tx4938 memory interface
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4938/tx4938.h>
+
+static unsigned int __init
+tx4938_process_sdccr(u64 * addr)
+{
+	u64 val;
+	unsigned int sdccr_ce;
+	unsigned int sdccr_rs;
+	unsigned int sdccr_cs;
+	unsigned int sdccr_mw;
+	unsigned int rs = 0;
+	unsigned int cs = 0;
+	unsigned int mw = 0;
+	unsigned int bc = 4;
+	unsigned int msize = 0;
+
+	val = (*((vu64 *) (addr)));
+
+	/* MVMCP -- need #defs for these bits masks */
+	sdccr_ce = ((val & (1 << 10)) >> 10);
+	sdccr_rs = ((val & (3 << 5)) >> 5);
+	sdccr_cs = ((val & (7 << 2)) >> 2);
+	sdccr_mw = ((val & (1 << 0)) >> 0);
+
+	if (sdccr_ce) {
+		switch (sdccr_rs) {
+		case 0:{
+				rs = 2048;
+				break;
+			}
+		case 1:{
+				rs = 4096;
+				break;
+			}
+		case 2:{
+				rs = 8192;
+				break;
+			}
+		default:{
+				rs = 0;
+				break;
+			}
+		}
+		switch (sdccr_cs) {
+		case 0:{
+				cs = 256;
+				break;
+			}
+		case 1:{
+				cs = 512;
+				break;
+			}
+		case 2:{
+				cs = 1024;
+				break;
+			}
+		case 3:{
+				cs = 2048;
+				break;
+			}
+		case 4:{
+				cs = 4096;
+				break;
+			}
+		default:{
+				cs = 0;
+				break;
+			}
+		}
+		switch (sdccr_mw) {
+		case 0:{
+				mw = 8;
+				break;
+			}	/* 8 bytes = 64 bits */
+		case 1:{
+				mw = 4;
+				break;
+			}	/* 4 bytes = 32 bits */
+		}
+	}
+
+	/*           bytes per chip    MB per chip          bank count */
+	msize = (((rs * cs * mw) / (1024 * 1024)) * (bc));
+
+	/* MVMCP -- bc hard coded to 4 from table 9.3.1     */
+	/*          boad supports bc=2 but no way to detect */
+
+	return (msize);
+}
+
+unsigned int __init
+tx4938_get_mem_size(void)
+{
+	unsigned int c0;
+	unsigned int c1;
+	unsigned int c2;
+	unsigned int c3;
+	unsigned int total;
+
+	/* MVMCP -- need #defs for these registers */
+	c0 = tx4938_process_sdccr((u64 *) 0xff1f8000);
+	c1 = tx4938_process_sdccr((u64 *) 0xff1f8008);
+	c2 = tx4938_process_sdccr((u64 *) 0xff1f8010);
+	c3 = tx4938_process_sdccr((u64 *) 0xff1f8018);
+	total = c0 + c1 + c2 + c3;
+
+	return (total);
+}
diff -Naur linux-2.6.14/arch/mips/tx4938/common/rtc_rx5c348.c linux-mips-2.6.14.orig/arch/mips/tx4938/common/rtc_rx5c348.c
--- linux-2.6.14/arch/mips/tx4938/common/rtc_rx5c348.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/rtc_rx5c348.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,202 @@
+/*
+ * RTC routines for RICOH Rx5C348 SPI chip.
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/rtc.h>
+#include <linux/time.h>
+#include <asm/time.h>
+#include <asm/tx4938/spi.h>
+
+#define	EPOCH		2000
+
+/* registers */
+#define Rx5C348_REG_SECOND	0
+#define Rx5C348_REG_MINUTE	1
+#define Rx5C348_REG_HOUR	2
+#define Rx5C348_REG_WEEK	3
+#define Rx5C348_REG_DAY	4
+#define Rx5C348_REG_MONTH	5
+#define Rx5C348_REG_YEAR	6
+#define Rx5C348_REG_ADJUST	7
+#define Rx5C348_REG_ALARM_W_MIN	8
+#define Rx5C348_REG_ALARM_W_HOUR	9
+#define Rx5C348_REG_ALARM_W_WEEK	10
+#define Rx5C348_REG_ALARM_D_MIN	11
+#define Rx5C348_REG_ALARM_D_HOUR	12
+#define Rx5C348_REG_CTL1	14
+#define Rx5C348_REG_CTL2	15
+
+/* register bits */
+#define Rx5C348_BIT_PM	0x20	/* REG_HOUR */
+#define Rx5C348_BIT_Y2K	0x80	/* REG_MONTH */
+#define Rx5C348_BIT_24H	0x20	/* REG_CTL1 */
+#define Rx5C348_BIT_XSTP	0x10	/* REG_CTL2 */
+
+/* commands */
+#define Rx5C348_CMD_W(addr)	(((addr) << 4) | 0x08)	/* single write */
+#define Rx5C348_CMD_R(addr)	(((addr) << 4) | 0x0c)	/* single read */
+#define Rx5C348_CMD_MW(addr)	(((addr) << 4) | 0x00)	/* burst write */
+#define Rx5C348_CMD_MR(addr)	(((addr) << 4) | 0x04)	/* burst read */
+
+static struct spi_dev_desc srtc_dev_desc = {
+	.baud 		= 1000000,	/* 1.0Mbps @ Vdd 2.0V */
+	.tcss		= 31,
+	.tcsh		= 1,
+	.tcsr		= 62,
+	/* 31us for Tcss (62us for Tcsr) is required for carry operation) */
+	.byteorder	= 1,		/* MSB-First */
+	.polarity	= 0,		/* High-Active */
+	.phase		= 1,		/* Shift-Then-Sample */
+
+};
+static int srtc_chipid;
+static int srtc_24h;
+
+static inline int
+spi_rtc_io(unsigned char *inbuf, unsigned char *outbuf, unsigned int count)
+{
+	unsigned char *inbufs[1], *outbufs[1];
+	unsigned int incounts[2], outcounts[2];
+	inbufs[0] = inbuf;
+	incounts[0] = count;
+	incounts[1] = 0;
+	outbufs[0] = outbuf;
+	outcounts[0] = count;
+	outcounts[1] = 0;
+	return txx9_spi_io(srtc_chipid, &srtc_dev_desc,
+			   inbufs, incounts, outbufs, outcounts, 0);
+}
+
+/*
+ * Conversion between binary and BCD.
+ */
+#ifndef BCD_TO_BIN
+#define BCD_TO_BIN(val) ((val)=((val)&15) + ((val)>>4)*10)
+#endif
+
+#ifndef BIN_TO_BCD
+#define BIN_TO_BCD(val) ((val)=(((val)/10)<<4) + (val)%10)
+#endif
+
+/* RTC-dependent code for time.c */
+
+static int
+rtc_rx5c348_set_time(unsigned long t)
+{
+	unsigned char inbuf[8];
+	struct rtc_time tm;
+	u8 year, month, day, hour, minute, second, century;
+
+	/* convert */
+	to_tm(t, &tm);
+
+	year = tm.tm_year % 100;
+	month = tm.tm_mon+1;	/* tm_mon starts from 0 to 11 */
+	day = tm.tm_mday;
+	hour = tm.tm_hour;
+	minute = tm.tm_min;
+	second = tm.tm_sec;
+	century = tm.tm_year / 100;
+
+	inbuf[0] = Rx5C348_CMD_MW(Rx5C348_REG_SECOND);
+	BIN_TO_BCD(second);
+	inbuf[1] = second;
+	BIN_TO_BCD(minute);
+	inbuf[2] = minute;
+
+	if (srtc_24h) {
+		BIN_TO_BCD(hour);
+		inbuf[3] = hour;
+	} else {
+		/* hour 0 is AM12, noon is PM12 */
+		inbuf[3] = 0;
+		if (hour >= 12)
+			inbuf[3] = Rx5C348_BIT_PM;
+		hour = (hour + 11) % 12 + 1;
+		BIN_TO_BCD(hour);
+		inbuf[3] |= hour;
+	}
+	inbuf[4] = 0;	/* ignore week */
+	BIN_TO_BCD(day);
+	inbuf[5] = day;
+	BIN_TO_BCD(month);
+	inbuf[6] = month;
+	if (century >= 20)
+		inbuf[6] |= Rx5C348_BIT_Y2K;
+	BIN_TO_BCD(year);
+	inbuf[7] = year;
+	/* write in one transfer to avoid data inconsistency */
+	return spi_rtc_io(inbuf, NULL, 8);
+}
+
+static unsigned long
+rtc_rx5c348_get_time(void)
+{
+	unsigned char inbuf[8], outbuf[8];
+	unsigned int year, month, day, hour, minute, second;
+
+	inbuf[0] = Rx5C348_CMD_MR(Rx5C348_REG_SECOND);
+	memset(inbuf + 1, 0, 7);
+	/* read in one transfer to avoid data inconsistency */
+	if (spi_rtc_io(inbuf, outbuf, 8))
+		return 0;
+	second = outbuf[1];
+	BCD_TO_BIN(second);
+	minute = outbuf[2];
+	BCD_TO_BIN(minute);
+	if (srtc_24h) {
+		hour = outbuf[3];
+		BCD_TO_BIN(hour);
+	} else {
+		hour = outbuf[3] & ~Rx5C348_BIT_PM;
+		BCD_TO_BIN(hour);
+		hour %= 12;
+		if (outbuf[3] & Rx5C348_BIT_PM)
+			hour += 12;
+	}
+	day = outbuf[5];
+	BCD_TO_BIN(day);
+	month = outbuf[6] & ~Rx5C348_BIT_Y2K;
+	BCD_TO_BIN(month);
+	year = outbuf[7];
+	BCD_TO_BIN(year);
+	year += EPOCH;
+
+	return mktime(year, month, day, hour, minute, second);
+}
+
+void __init
+rtc_rx5c348_init(int chipid)
+{
+	unsigned char inbuf[2], outbuf[2];
+	srtc_chipid = chipid;
+	/* turn on RTC if it is not on */
+	inbuf[0] = Rx5C348_CMD_R(Rx5C348_REG_CTL2);
+	inbuf[1] = 0;
+	spi_rtc_io(inbuf, outbuf, 2);
+	if (outbuf[1] & Rx5C348_BIT_XSTP) {
+		inbuf[0] = Rx5C348_CMD_W(Rx5C348_REG_CTL2);
+		inbuf[1] = 0;
+		spi_rtc_io(inbuf, NULL, 2);
+	}
+
+	inbuf[0] = Rx5C348_CMD_R(Rx5C348_REG_CTL1);
+	inbuf[1] = 0;
+	spi_rtc_io(inbuf, outbuf, 2);
+	if (outbuf[1] & Rx5C348_BIT_24H)
+		srtc_24h = 1;
+
+	/* set the function pointers */
+	rtc_get_time = rtc_rx5c348_get_time;
+	rtc_set_time = rtc_rx5c348_set_time;
+}
diff -Naur linux-2.6.14/arch/mips/tx4938/common/setup.c linux-mips-2.6.14.orig/arch/mips/tx4938/common/setup.c
--- linux-2.6.14/arch/mips/tx4938/common/setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/common/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,91 @@
+/*
+ * linux/arch/mips/tx4938/common/setup.c
+ *
+ * common tx4938 setup routines
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/irq.h>
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/time.h>
+#include <asm/time.h>
+#include <asm/tx4938/rbtx4938.h>
+
+extern void toshiba_rbtx4938_setup(void);
+extern void rbtx4938_time_init(void);
+
+void __init tx4938_setup(void);
+void __init tx4938_time_init(void);
+void __init tx4938_timer_setup(struct irqaction *irq);
+void dump_cp0(char *key);
+
+void (*__wbflush) (void);
+
+static void
+tx4938_write_buffer_flush(void)
+{
+	mmiowb();
+
+	__asm__ __volatile__(
+		".set	push\n\t"
+		".set	noreorder\n\t"
+		"lw	$0,%0\n\t"
+		"nop\n\t"
+		".set	pop"
+		: /* no output */
+		: "m" (*(int *)KSEG1)
+		: "memory");
+}
+
+void __init
+plat_setup(void)
+{
+	board_time_init = tx4938_time_init;
+	board_timer_setup = tx4938_timer_setup;
+	__wbflush = tx4938_write_buffer_flush;
+	toshiba_rbtx4938_setup();
+}
+
+void __init
+tx4938_time_init(void)
+{
+	rbtx4938_time_init();
+}
+
+void __init
+tx4938_timer_setup(struct irqaction *irq)
+{
+	u32 count;
+	u32 c1;
+	u32 c2;
+
+	setup_irq(TX4938_IRQ_CPU_TIMER, irq);
+
+	c1 = read_c0_count();
+	count = c1 + (mips_hpt_frequency / HZ);
+	write_c0_compare(count);
+	c2 = read_c0_count();
+}
diff -Naur linux-2.6.14/arch/mips/tx4938/Kconfig linux-mips-2.6.14.orig/arch/mips/tx4938/Kconfig
--- linux-2.6.14/arch/mips/tx4938/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,24 @@
+if TOSHIBA_RBTX4938
+
+comment "Multiplex Pin Select"
+choice
+	prompt "PIO[58:61]"
+	default TOSHIBA_RBTX4938_MPLEX_PIO58_61
+
+config TOSHIBA_RBTX4938_MPLEX_PIO58_61
+	bool "PIO"
+config TOSHIBA_RBTX4938_MPLEX_NAND
+	bool "NAND"
+config TOSHIBA_RBTX4938_MPLEX_ATA
+	bool "ATA"
+
+endchoice
+
+config TX4938_NAND_BOOT
+	depends on EXPERIMENTAL && TOSHIBA_RBTX4938_MPLEX_NAND
+	bool "NAND Boot Support (EXPERIMENTAL)"
+	help
+	  This is only for Toshiba RBTX4938 reference board, which has NAND IPL.
+	  Select this option if you need to use NAND boot.
+
+endif
diff -Naur linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/irq.c linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/irq.c
--- linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/irq.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,244 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/irq.c
+ *
+ * Toshiba RBTX4938 specific interrupt handlers
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+/*
+IRQ  Device
+
+16   TX4938-CP0/00 Software 0
+17   TX4938-CP0/01 Software 1
+18   TX4938-CP0/02 Cascade TX4938-CP0
+19   TX4938-CP0/03 Multiplexed -- do not use
+20   TX4938-CP0/04 Multiplexed -- do not use
+21   TX4938-CP0/05 Multiplexed -- do not use
+22   TX4938-CP0/06 Multiplexed -- do not use
+23   TX4938-CP0/07 CPU TIMER
+
+24   TX4938-PIC/00
+25   TX4938-PIC/01
+26   TX4938-PIC/02 Cascade RBTX4938-IOC
+27   TX4938-PIC/03 RBTX4938 RTL-8019AS Ethernet
+28   TX4938-PIC/04
+29   TX4938-PIC/05 TX4938 ETH1
+30   TX4938-PIC/06 TX4938 ETH0
+31   TX4938-PIC/07
+32   TX4938-PIC/08 TX4938 SIO 0
+33   TX4938-PIC/09 TX4938 SIO 1
+34   TX4938-PIC/10 TX4938 DMA0
+35   TX4938-PIC/11 TX4938 DMA1
+36   TX4938-PIC/12 TX4938 DMA2
+37   TX4938-PIC/13 TX4938 DMA3
+38   TX4938-PIC/14
+39   TX4938-PIC/15
+40   TX4938-PIC/16 TX4938 PCIC
+41   TX4938-PIC/17 TX4938 TMR0
+42   TX4938-PIC/18 TX4938 TMR1
+43   TX4938-PIC/19 TX4938 TMR2
+44   TX4938-PIC/20
+45   TX4938-PIC/21
+46   TX4938-PIC/22 TX4938 PCIERR
+47   TX4938-PIC/23
+48   TX4938-PIC/24
+49   TX4938-PIC/25
+50   TX4938-PIC/26
+51   TX4938-PIC/27
+52   TX4938-PIC/28
+53   TX4938-PIC/29
+54   TX4938-PIC/30
+55   TX4938-PIC/31 TX4938 SPI
+
+56 RBTX4938-IOC/00 PCI-D
+57 RBTX4938-IOC/01 PCI-C
+58 RBTX4938-IOC/02 PCI-B
+59 RBTX4938-IOC/03 PCI-A
+60 RBTX4938-IOC/04 RTC
+61 RBTX4938-IOC/05 ATA
+62 RBTX4938-IOC/06 MODEM
+63 RBTX4938-IOC/07 SWINT
+*/
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/swap.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/timex.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/processor.h>
+#include <asm/ptrace.h>
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <linux/version.h>
+#include <linux/bootmem.h>
+#include <asm/tx4938/rbtx4938.h>
+
+static unsigned int toshiba_rbtx4938_irq_ioc_startup(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_shutdown(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_enable(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_disable(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_mask_and_ack(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_end(unsigned int irq);
+
+DEFINE_SPINLOCK(toshiba_rbtx4938_ioc_lock);
+
+#define TOSHIBA_RBTX4938_IOC_NAME "RBTX4938-IOC"
+static struct hw_interrupt_type toshiba_rbtx4938_irq_ioc_type = {
+	.typename = TOSHIBA_RBTX4938_IOC_NAME,
+	.startup = toshiba_rbtx4938_irq_ioc_startup,
+	.shutdown = toshiba_rbtx4938_irq_ioc_shutdown,
+	.enable = toshiba_rbtx4938_irq_ioc_enable,
+	.disable = toshiba_rbtx4938_irq_ioc_disable,
+	.ack = toshiba_rbtx4938_irq_ioc_mask_and_ack,
+	.end = toshiba_rbtx4938_irq_ioc_end,
+	.set_affinity = NULL
+};
+
+#define TOSHIBA_RBTX4938_IOC_INTR_ENAB 0xb7f02000
+#define TOSHIBA_RBTX4938_IOC_INTR_STAT 0xb7f0200a
+
+int
+toshiba_rbtx4938_irq_nested(int sw_irq)
+{
+	u8 level3;
+
+	level3 = reg_rd08(TOSHIBA_RBTX4938_IOC_INTR_STAT) & 0xff;
+	if (level3) {
+		/* must use fls so onboard ATA has priority */
+		sw_irq = TOSHIBA_RBTX4938_IRQ_IOC_BEG + fls(level3) - 1;
+	}
+
+	wbflush();
+	return sw_irq;
+}
+
+static struct irqaction toshiba_rbtx4938_irq_ioc_action = {
+	.handler = no_action,
+	.flags = 0,
+	.mask = CPU_MASK_NONE,
+	.name = TOSHIBA_RBTX4938_IOC_NAME,
+};
+
+/**********************************************************************************/
+/* Functions for ioc                                                              */
+/**********************************************************************************/
+static void __init
+toshiba_rbtx4938_irq_ioc_init(void)
+{
+	int i;
+
+	for (i = TOSHIBA_RBTX4938_IRQ_IOC_BEG;
+	     i <= TOSHIBA_RBTX4938_IRQ_IOC_END; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 3;
+		irq_desc[i].handler = &toshiba_rbtx4938_irq_ioc_type;
+	}
+
+	setup_irq(RBTX4938_IRQ_IOCINT,
+		  &toshiba_rbtx4938_irq_ioc_action);
+}
+
+static unsigned int
+toshiba_rbtx4938_irq_ioc_startup(unsigned int irq)
+{
+	toshiba_rbtx4938_irq_ioc_enable(irq);
+
+	return 0;
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_shutdown(unsigned int irq)
+{
+	toshiba_rbtx4938_irq_ioc_disable(irq);
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_enable(unsigned int irq)
+{
+	unsigned long flags;
+	volatile unsigned char v;
+
+	spin_lock_irqsave(&toshiba_rbtx4938_ioc_lock, flags);
+
+	v = TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+	v |= (1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	TX4938_WR08(TOSHIBA_RBTX4938_IOC_INTR_ENAB, v);
+	mmiowb();
+	TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+
+	spin_unlock_irqrestore(&toshiba_rbtx4938_ioc_lock, flags);
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_disable(unsigned int irq)
+{
+	unsigned long flags;
+	volatile unsigned char v;
+
+	spin_lock_irqsave(&toshiba_rbtx4938_ioc_lock, flags);
+
+	v = TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+	v &= ~(1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	TX4938_WR08(TOSHIBA_RBTX4938_IOC_INTR_ENAB, v);
+	mmiowb();
+	TX4938_RD08(TOSHIBA_RBTX4938_IOC_INTR_ENAB);
+
+	spin_unlock_irqrestore(&toshiba_rbtx4938_ioc_lock, flags);
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_mask_and_ack(unsigned int irq)
+{
+	toshiba_rbtx4938_irq_ioc_disable(irq);
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS))) {
+		toshiba_rbtx4938_irq_ioc_enable(irq);
+	}
+}
+
+extern void __init txx9_spi_irqinit(int irc_irq);
+
+void __init arch_init_irq(void)
+{
+	extern void tx4938_irq_init(void);
+
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+	/* mask all IOC interrupts */
+	*rbtx4938_imask_ptr = 0;
+
+	/* clear SoftInt interrupts */
+	*rbtx4938_softint_ptr = 0;
+	tx4938_irq_init();
+	toshiba_rbtx4938_irq_ioc_init();
+	/* Onboard 10M Ether: High Active */
+	TX4938_WR(TX4938_MKA(TX4938_IRC_IRDM0), 0x00000040);
+
+	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_SPI_SEL) {
+		txx9_spi_irqinit(RBTX4938_IRQ_IRC_SPI);
+        }
+
+	wbflush();
+}
diff -Naur linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/Makefile linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/Makefile
--- linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/Makefile	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,9 @@
+#
+# Makefile for common code for Toshiba TX4927 based systems
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	+= prom.o setup.o irq.o spi_eeprom.o spi_txx9.o
diff -Naur linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/prom.c linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/prom.c
--- linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/prom.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/prom.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,78 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/prom.c
+ *
+ * rbtx4938 specific prom routines
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4938/tx4938.h>
+
+void __init prom_init_cmdline(void)
+{
+	int argc = (int) fw_arg0;
+	char **argv = (char **) fw_arg1;
+	int i;
+
+	/* ignore all built-in args if any f/w args given */
+	if (argc > 1) {
+		*arcs_cmdline = '\0';
+	}
+
+	for (i = 1; i < argc; i++) {
+		if (i != 1) {
+			strcat(arcs_cmdline, " ");
+		}
+		strcat(arcs_cmdline, argv[i]);
+	}
+}
+
+void __init prom_init(void)
+{
+	extern int tx4938_get_mem_size(void);
+	int msize;
+#ifndef CONFIG_TX4938_NAND_BOOT
+	prom_init_cmdline();
+#endif
+	mips_machgroup = MACH_GROUP_TOSHIBA;
+	mips_machtype = MACH_TOSHIBA_RBTX4938;
+
+	msize = tx4938_get_mem_size();
+	add_memory_region(0, msize << 20, BOOT_MEM_RAM);
+
+	return;
+}
+
+unsigned long  __init prom_free_prom_memory(void)
+{
+	return 0;
+}
+
+void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
+{
+	return;
+}
+
+const char *get_system_type(void)
+{
+	return "Toshiba RBTX4938";
+}
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
diff -Naur linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/setup.c linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/setup.c
--- linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,1035 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/setup.c
+ *
+ * Setup pointers to hardware-dependent routines.
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/pci.h>
+#include <asm/wbflush.h>
+#include <asm/reboot.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <asm/tx4938/rbtx4938.h>
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
+
+extern void rbtx4938_time_init(void) __init;
+extern char * __init prom_getcmdline(void);
+static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr);
+
+/* These functions are used for rebooting or halting the machine*/
+extern void rbtx4938_machine_restart(char *command);
+extern void rbtx4938_machine_halt(void);
+extern void rbtx4938_machine_power_off(void);
+
+/* clocks */
+unsigned int txx9_master_clock;
+unsigned int txx9_cpu_clock;
+unsigned int txx9_gbus_clock;
+
+unsigned long rbtx4938_ce_base[8];
+unsigned long rbtx4938_ce_size[8];
+int txboard_pci66_mode;
+static int tx4938_pcic_trdyto;	/* default: disabled */
+static int tx4938_pcic_retryto;	/* default: disabled */
+static int tx4938_ccfg_toeon = 1;
+
+struct tx4938_pcic_reg *pcicptrs[4] = {
+       tx4938_pcicptr  /* default setting for TX4938 */
+};
+
+static struct {
+	unsigned long base;
+	unsigned long size;
+} phys_regions[16] __initdata;
+static int num_phys_regions  __initdata;
+
+#define PHYS_REGION_MINSIZE	0x10000
+
+void rbtx4938_machine_halt(void)
+{
+        printk(KERN_NOTICE "System Halted\n");
+	local_irq_disable();
+
+	while (1)
+		__asm__(".set\tmips3\n\t"
+			"wait\n\t"
+			".set\tmips0");
+}
+
+void rbtx4938_machine_power_off(void)
+{
+        rbtx4938_machine_halt();
+        /* no return */
+}
+
+void rbtx4938_machine_restart(char *command)
+{
+	local_irq_disable();
+
+	printk("Rebooting...");
+	*rbtx4938_softresetlock_ptr = 1;
+	*rbtx4938_sfvol_ptr = 1;
+	*rbtx4938_softreset_ptr = 1;
+	wbflush();
+
+	while(1);
+}
+
+void __init
+txboard_add_phys_region(unsigned long base, unsigned long size)
+{
+	if (num_phys_regions >= ARRAY_SIZE(phys_regions)) {
+		printk("phys_region overflow\n");
+		return;
+	}
+	phys_regions[num_phys_regions].base = base;
+	phys_regions[num_phys_regions].size = size;
+	num_phys_regions++;
+}
+unsigned long __init
+txboard_find_free_phys_region(unsigned long begin, unsigned long end,
+			      unsigned long size)
+{
+	unsigned long base;
+	int i;
+
+	for (base = begin / size * size; base < end; base += size) {
+		for (i = 0; i < num_phys_regions; i++) {
+			if (phys_regions[i].size &&
+			    base <= phys_regions[i].base + (phys_regions[i].size - 1) &&
+			    base + (size - 1) >= phys_regions[i].base)
+				break;
+		}
+		if (i == num_phys_regions)
+			return base;
+	}
+	return 0;
+}
+unsigned long __init
+txboard_find_free_phys_region_shrink(unsigned long begin, unsigned long end,
+				     unsigned long *size)
+{
+	unsigned long sz, base;
+	for (sz = *size; sz >= PHYS_REGION_MINSIZE; sz /= 2) {
+		base = txboard_find_free_phys_region(begin, end, sz);
+		if (base) {
+			*size = sz;
+			return base;
+		}
+	}
+	return 0;
+}
+unsigned long __init
+txboard_request_phys_region_range(unsigned long begin, unsigned long end,
+				  unsigned long size)
+{
+	unsigned long base;
+	base = txboard_find_free_phys_region(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, size);
+	return base;
+}
+unsigned long __init
+txboard_request_phys_region(unsigned long size)
+{
+	unsigned long base;
+	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
+	base = txboard_find_free_phys_region(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, size);
+	return base;
+}
+unsigned long __init
+txboard_request_phys_region_shrink(unsigned long *size)
+{
+	unsigned long base;
+	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
+	base = txboard_find_free_phys_region_shrink(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, *size);
+	return base;
+}
+
+#ifdef CONFIG_PCI
+void __init
+tx4938_pcic_setup(struct tx4938_pcic_reg *pcicptr,
+		  struct pci_controller *channel,
+		  unsigned long pci_io_base,
+		  int extarb)
+{
+	int i;
+
+	/* Disable All Initiator Space */
+	pcicptr->pciccfg &= ~(TX4938_PCIC_PCICCFG_G2PMEN(0)|
+			      TX4938_PCIC_PCICCFG_G2PMEN(1)|
+			      TX4938_PCIC_PCICCFG_G2PMEN(2)|
+			      TX4938_PCIC_PCICCFG_G2PIOEN);
+
+	/* GB->PCI mappings */
+	pcicptr->g2piomask = (channel->io_resource->end - channel->io_resource->start) >> 4;
+	pcicptr->g2piogbase = pci_io_base |
+#ifdef __BIG_ENDIAN
+		TX4938_PCIC_G2PIOGBASE_ECHG
+#else
+		TX4938_PCIC_G2PIOGBASE_BSDIS
+#endif
+		;
+	pcicptr->g2piopbase = 0;
+	for (i = 0; i < 3; i++) {
+		pcicptr->g2pmmask[i] = 0;
+		pcicptr->g2pmgbase[i] = 0;
+		pcicptr->g2pmpbase[i] = 0;
+	}
+	if (channel->mem_resource->end) {
+		pcicptr->g2pmmask[0] = (channel->mem_resource->end - channel->mem_resource->start) >> 4;
+		pcicptr->g2pmgbase[0] = channel->mem_resource->start |
+#ifdef __BIG_ENDIAN
+			TX4938_PCIC_G2PMnGBASE_ECHG
+#else
+			TX4938_PCIC_G2PMnGBASE_BSDIS
+#endif
+			;
+		pcicptr->g2pmpbase[0] = channel->mem_resource->start;
+	}
+	/* PCI->GB mappings (I/O 256B) */
+	pcicptr->p2giopbase = 0; /* 256B */
+	pcicptr->p2giogbase = 0;
+	/* PCI->GB mappings (MEM 512MB (64MB on R1.x)) */
+	pcicptr->p2gm0plbase = 0;
+	pcicptr->p2gm0pubase = 0;
+	pcicptr->p2gmgbase[0] = 0 |
+		TX4938_PCIC_P2GMnGBASE_TMEMEN |
+#ifdef __BIG_ENDIAN
+		TX4938_PCIC_P2GMnGBASE_TECHG
+#else
+		TX4938_PCIC_P2GMnGBASE_TBSDIS
+#endif
+		;
+	/* PCI->GB mappings (MEM 16MB) */
+	pcicptr->p2gm1plbase = 0xffffffff;
+	pcicptr->p2gm1pubase = 0xffffffff;
+	pcicptr->p2gmgbase[1] = 0;
+	/* PCI->GB mappings (MEM 1MB) */
+	pcicptr->p2gm2pbase = 0xffffffff; /* 1MB */
+	pcicptr->p2gmgbase[2] = 0;
+
+	pcicptr->pciccfg &= TX4938_PCIC_PCICCFG_GBWC_MASK;
+	/* Enable Initiator Memory Space */
+	if (channel->mem_resource->end)
+		pcicptr->pciccfg |= TX4938_PCIC_PCICCFG_G2PMEN(0);
+	/* Enable Initiator I/O Space */
+	if (channel->io_resource->end)
+		pcicptr->pciccfg |= TX4938_PCIC_PCICCFG_G2PIOEN;
+	/* Enable Initiator Config */
+	pcicptr->pciccfg |=
+		TX4938_PCIC_PCICCFG_ICAEN |
+		TX4938_PCIC_PCICCFG_TCAR;
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	pcicptr->pcicfg1 = 0;
+
+	pcicptr->g2ptocnt &= ~0xffff;
+
+	if (tx4938_pcic_trdyto >= 0) {
+		pcicptr->g2ptocnt &= ~0xff;
+		pcicptr->g2ptocnt |= (tx4938_pcic_trdyto & 0xff);
+	}
+
+	if (tx4938_pcic_retryto >= 0) {
+		pcicptr->g2ptocnt &= ~0xff00;
+		pcicptr->g2ptocnt |= ((tx4938_pcic_retryto<<8) & 0xff00);
+	}
+
+	/* Clear All Local Bus Status */
+	pcicptr->pcicstatus = TX4938_PCIC_PCICSTATUS_ALL;
+	/* Enable All Local Bus Interrupts */
+	pcicptr->pcicmask = TX4938_PCIC_PCICSTATUS_ALL;
+	/* Clear All Initiator Status */
+	pcicptr->g2pstatus = TX4938_PCIC_G2PSTATUS_ALL;
+	/* Enable All Initiator Interrupts */
+	pcicptr->g2pmask = TX4938_PCIC_G2PSTATUS_ALL;
+	/* Clear All PCI Status Error */
+	pcicptr->pcistatus =
+		(pcicptr->pcistatus & 0x0000ffff) |
+		(TX4938_PCIC_PCISTATUS_ALL << 16);
+	/* Enable All PCI Status Error Interrupts */
+	pcicptr->pcimask = TX4938_PCIC_PCISTATUS_ALL;
+
+	if (!extarb) {
+		/* Reset Bus Arbiter */
+		pcicptr->pbacfg = TX4938_PCIC_PBACFG_RPBA;
+		pcicptr->pbabm = 0;
+		/* Enable Bus Arbiter */
+		pcicptr->pbacfg = TX4938_PCIC_PBACFG_PBAEN;
+	}
+
+      /* PCIC Int => IRC IRQ16 */
+	pcicptr->pcicfg2 =
+		    (pcicptr->pcicfg2 & 0xffffff00) | TX4938_IR_PCIC;
+
+	pcicptr->pcistatus = PCI_COMMAND_MASTER |
+		PCI_COMMAND_MEMORY |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+}
+
+int __init
+tx4938_report_pciclk(void)
+{
+	unsigned long pcode = TX4938_REV_PCODE();
+	int pciclk = 0;
+	printk("TX%lx PCIC --%s PCICLK:",
+	       pcode,
+	       (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI66) ? " PCI66" : "");
+	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_PCICLKEN_ALL) {
+
+		switch ((unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIDIVMODE_MASK) {
+		case TX4938_CCFG_PCIDIVMODE_4:
+			pciclk = txx9_cpu_clock / 4; break;
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			pciclk = txx9_cpu_clock * 2 / 9; break;
+		case TX4938_CCFG_PCIDIVMODE_5:
+			pciclk = txx9_cpu_clock / 5; break;
+		case TX4938_CCFG_PCIDIVMODE_5_5:
+			pciclk = txx9_cpu_clock * 2 / 11; break;
+		case TX4938_CCFG_PCIDIVMODE_8:
+			pciclk = txx9_cpu_clock / 8; break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+			pciclk = txx9_cpu_clock / 9; break;
+		case TX4938_CCFG_PCIDIVMODE_10:
+			pciclk = txx9_cpu_clock / 10; break;
+		case TX4938_CCFG_PCIDIVMODE_11:
+			pciclk = txx9_cpu_clock / 11; break;
+		}
+		printk("Internal(%dMHz)", pciclk / 1000000);
+	} else {
+		printk("External");
+		pciclk = -1;
+	}
+	printk("\n");
+	return pciclk;
+}
+
+void __init set_tx4938_pcicptr(int ch, struct tx4938_pcic_reg *pcicptr)
+{
+	pcicptrs[ch] = pcicptr;
+}
+
+struct tx4938_pcic_reg *get_tx4938_pcicptr(int ch)
+{
+       return pcicptrs[ch];
+}
+
+static struct pci_dev *fake_pci_dev(struct pci_controller *hose,
+                                    int top_bus, int busnr, int devfn)
+{
+	static struct pci_dev dev;
+	static struct pci_bus bus;
+
+	dev.sysdata = (void *)hose;
+	dev.devfn = devfn;
+	bus.number = busnr;
+	bus.ops = hose->pci_ops;
+	bus.parent = NULL;
+	dev.bus = &bus;
+
+	return &dev;
+}
+
+#define EARLY_PCI_OP(rw, size, type)                                    \
+static int early_##rw##_config_##size(struct pci_controller *hose,      \
+        int top_bus, int bus, int devfn, int offset, type value)        \
+{                                                                       \
+        return pci_##rw##_config_##size(                                \
+                fake_pci_dev(hose, top_bus, bus, devfn),                \
+                offset, value);                                         \
+}
+
+EARLY_PCI_OP(read, word, u16 *)
+
+int txboard_pci66_check(struct pci_controller *hose, int top_bus, int current_bus)
+{
+	u32 pci_devfn;
+	unsigned short vid;
+	int devfn_start = 0;
+	int devfn_stop = 0xff;
+	int cap66 = -1;
+	u16 stat;
+
+	printk("PCI: Checking 66MHz capabilities...\n");
+
+	for (pci_devfn=devfn_start; pci_devfn<devfn_stop; pci_devfn++) {
+		early_read_config_word(hose, top_bus, current_bus, pci_devfn,
+				       PCI_VENDOR_ID, &vid);
+
+		if (vid == 0xffff) continue;
+
+		/* check 66MHz capability */
+		if (cap66 < 0)
+			cap66 = 1;
+		if (cap66) {
+			early_read_config_word(hose, top_bus, current_bus, pci_devfn,
+					       PCI_STATUS, &stat);
+			if (!(stat & PCI_STATUS_66MHZ)) {
+				printk(KERN_DEBUG "PCI: %02x:%02x not 66MHz capable.\n",
+				       current_bus, pci_devfn);
+				cap66 = 0;
+				break;
+			}
+		}
+	}
+	return cap66 > 0;
+}
+
+int __init
+tx4938_pciclk66_setup(void)
+{
+	int pciclk;
+
+	/* Assert M66EN */
+	tx4938_ccfgptr->ccfg |= TX4938_CCFG_PCI66;
+	/* Double PCICLK (if possible) */
+	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_PCICLKEN_ALL) {
+		unsigned int pcidivmode =
+			tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIDIVMODE_MASK;
+		switch (pcidivmode) {
+		case TX4938_CCFG_PCIDIVMODE_8:
+		case TX4938_CCFG_PCIDIVMODE_4:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_4;
+			pciclk = txx9_cpu_clock / 4;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_4_5;
+			pciclk = txx9_cpu_clock * 2 / 9;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_10:
+		case TX4938_CCFG_PCIDIVMODE_5:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_5;
+			pciclk = txx9_cpu_clock / 5;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_11:
+		case TX4938_CCFG_PCIDIVMODE_5_5:
+		default:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_5_5;
+			pciclk = txx9_cpu_clock * 2 / 11;
+			break;
+		}
+		tx4938_ccfgptr->ccfg =
+			(tx4938_ccfgptr->ccfg & ~TX4938_CCFG_PCIDIVMODE_MASK)
+			| pcidivmode;
+		printk(KERN_DEBUG "PCICLK: ccfg:%08lx\n",
+		       (unsigned long)tx4938_ccfgptr->ccfg);
+	} else {
+		pciclk = -1;
+	}
+	return pciclk;
+}
+
+extern struct pci_controller tx4938_pci_controller[];
+static int __init tx4938_pcibios_init(void)
+{
+	unsigned long mem_base[2];
+	unsigned long mem_size[2] = {TX4938_PCIMEM_SIZE_0,TX4938_PCIMEM_SIZE_1}; /* MAX 128M,64K */
+	unsigned long io_base[2];
+	unsigned long io_size[2] = {TX4938_PCIIO_SIZE_0,TX4938_PCIIO_SIZE_1}; /* MAX 16M,64K */
+	/* TX4938 PCIC1: 64K MEM/IO is enough for ETH0,ETH1 */
+	int extarb = !(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIXARB);
+
+	PCIBIOS_MIN_IO = 0x00001000UL;
+	PCIBIOS_MIN_MEM = 0x01000000UL;
+
+	mem_base[0] = txboard_request_phys_region_shrink(&mem_size[0]);
+	io_base[0] = txboard_request_phys_region_shrink(&io_size[0]);
+
+	printk("TX4938 PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
+	       (unsigned short)(tx4938_pcicptr->pciid >> 16),
+	       (unsigned short)(tx4938_pcicptr->pciid & 0xffff),
+	       (unsigned short)(tx4938_pcicptr->pciccrev & 0xff),
+	       extarb ? "External" : "Internal");
+
+	/* setup PCI area */
+	tx4938_pci_controller[0].io_resource->start = io_base[0];
+	tx4938_pci_controller[0].io_resource->end = (io_base[0] + io_size[0]) - 1;
+	tx4938_pci_controller[0].mem_resource->start = mem_base[0];
+	tx4938_pci_controller[0].mem_resource->end = mem_base[0] + mem_size[0] - 1;
+
+	set_tx4938_pcicptr(0, tx4938_pcicptr);
+
+	register_pci_controller(&tx4938_pci_controller[0]);
+
+	if (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI66) {
+		printk("TX4938_CCFG_PCI66 already configured\n");
+		txboard_pci66_mode = -1; /* already configured */
+	}
+
+	/* Reset PCI Bus */
+	*rbtx4938_pcireset_ptr = 0;
+	/* Reset PCIC */
+	tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIRST;
+	if (txboard_pci66_mode > 0)
+		tx4938_pciclk66_setup();
+	mdelay(10);
+	/* clear PCIC reset */
+	tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIRST;
+	*rbtx4938_pcireset_ptr = 1;
+	wbflush();
+	tx4938_report_pcic_status1(tx4938_pcicptr);
+
+	tx4938_report_pciclk();
+	tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0], extarb);
+	if (txboard_pci66_mode == 0 &&
+	    txboard_pci66_check(&tx4938_pci_controller[0], 0, 0)) {
+		/* Reset PCI Bus */
+		*rbtx4938_pcireset_ptr = 0;
+		/* Reset PCIC */
+		tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIRST;
+		tx4938_pciclk66_setup();
+		mdelay(10);
+		/* clear PCIC reset */
+		tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIRST;
+		*rbtx4938_pcireset_ptr = 1;
+		wbflush();
+		/* Reinitialize PCIC */
+		tx4938_report_pciclk();
+		tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0], extarb);
+	}
+
+	mem_base[1] = txboard_request_phys_region_shrink(&mem_size[1]);
+	io_base[1] = txboard_request_phys_region_shrink(&io_size[1]);
+	/* Reset PCIC1 */
+	tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIC1RST;
+	/* PCI1DMD==0 => PCI1CLK==GBUSCLK/2 => PCI66 */
+	if (!(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1DMD))
+		tx4938_ccfgptr->ccfg |= TX4938_CCFG_PCI1_66;
+	else
+		tx4938_ccfgptr->ccfg &= ~TX4938_CCFG_PCI1_66;
+	mdelay(10);
+	/* clear PCIC1 reset */
+	tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIC1RST;
+	tx4938_report_pcic_status1(tx4938_pcic1ptr);
+
+	printk("TX4938 PCIC1 -- DID:%04x VID:%04x RID:%02x",
+	       (unsigned short)(tx4938_pcic1ptr->pciid >> 16),
+	       (unsigned short)(tx4938_pcic1ptr->pciid & 0xffff),
+	       (unsigned short)(tx4938_pcic1ptr->pciccrev & 0xff));
+	printk("%s PCICLK:%dMHz\n",
+	       (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1_66) ? " PCI66" : "",
+	       txx9_gbus_clock /
+	       ((tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1DMD) ? 4 : 2) /
+	       1000000);
+
+	/* assumption: CPHYSADDR(mips_io_port_base) == io_base[0] */
+	tx4938_pci_controller[1].io_resource->start =
+		io_base[1] - io_base[0];
+	tx4938_pci_controller[1].io_resource->end =
+		io_base[1] - io_base[0] + io_size[1] - 1;
+	tx4938_pci_controller[1].mem_resource->start = mem_base[1];
+	tx4938_pci_controller[1].mem_resource->end =
+		mem_base[1] + mem_size[1] - 1;
+	set_tx4938_pcicptr(1, tx4938_pcic1ptr);
+
+	register_pci_controller(&tx4938_pci_controller[1]);
+
+	tx4938_pcic_setup(tx4938_pcic1ptr, &tx4938_pci_controller[1], io_base[1], extarb);
+
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1 + io_base[0]);
+
+	return 0;
+}
+
+arch_initcall(tx4938_pcibios_init);
+
+#endif /* CONFIG_PCI */
+
+/* SPI support */
+
+/* chip select for SPI devices */
+#define	SEEPROM1_CS	7	/* PIO7 */
+#define	SEEPROM2_CS	0	/* IOC */
+#define	SEEPROM3_CS	1	/* IOC */
+#define	SRTC_CS	2	/* IOC */
+
+static int rbtx4938_spi_cs_func(int chipid, int on)
+{
+	unsigned char bit;
+	switch (chipid) {
+	case RBTX4938_SEEPROM1_CHIPID:
+		if (on)
+			tx4938_pioptr->dout &= ~(1 << SEEPROM1_CS);
+		else
+			tx4938_pioptr->dout |= (1 << SEEPROM1_CS);
+		return 0;
+		break;
+	case RBTX4938_SEEPROM2_CHIPID:
+		bit = (1 << SEEPROM2_CS);
+		break;
+	case RBTX4938_SEEPROM3_CHIPID:
+		bit = (1 << SEEPROM3_CS);
+		break;
+	case RBTX4938_SRTC_CHIPID:
+		bit = (1 << SRTC_CS);
+		break;
+	default:
+		return -ENODEV;
+	}
+	/* bit1,2,4 are low active, bit3 is high active */
+	*rbtx4938_spics_ptr =
+		(*rbtx4938_spics_ptr & ~bit) |
+		((on ? (bit ^ 0x0b) : ~(bit ^ 0x0b)) & bit);
+	return 0;
+}
+
+#ifdef CONFIG_PCI
+extern int spi_eeprom_read(int chipid, int address, unsigned char *buf, int len);
+
+int rbtx4938_get_tx4938_ethaddr(struct pci_dev *dev, unsigned char *addr)
+{
+	struct pci_controller *channel = (struct pci_controller *)dev->bus->sysdata;
+	static unsigned char dat[17];
+	static int read_dat = 0;
+	int ch = 0;
+
+	if (channel != &tx4938_pci_controller[1])
+		return -ENODEV;
+	/* TX4938 PCIC1 */
+	switch (PCI_SLOT(dev->devfn)) {
+	case TX4938_PCIC_IDSEL_AD_TO_SLOT(31):
+		ch = 0;
+		break;
+	case TX4938_PCIC_IDSEL_AD_TO_SLOT(30):
+		ch = 1;
+		break;
+	default:
+		return -ENODEV;
+	}
+	if (!read_dat) {
+		unsigned char sum;
+		int i;
+		read_dat = 1;
+		/* 0-3: "MAC\0", 4-9:eth0, 10-15:eth1, 16:sum */
+		if (spi_eeprom_read(RBTX4938_SEEPROM1_CHIPID,
+				    0, dat, sizeof(dat))) {
+			printk(KERN_ERR "seeprom: read error.\n");
+		} else {
+			if (strcmp(dat, "MAC") != 0)
+				printk(KERN_WARNING "seeprom: bad signature.\n");
+			for (i = 0, sum = 0; i < sizeof(dat); i++)
+				sum += dat[i];
+			if (sum)
+				printk(KERN_WARNING "seeprom: bad checksum.\n");
+		}
+	}
+	memcpy(addr, &dat[4 + 6 * ch], 6);
+	return 0;
+}
+#endif /* CONFIG_PCI */
+
+extern void __init txx9_spi_init(unsigned long base, int (*cs_func)(int chipid, int on));
+static void __init rbtx4938_spi_setup(void)
+{
+	/* set SPI_SEL */
+	tx4938_ccfgptr->pcfg |= TX4938_PCFG_SPI_SEL;
+	/* chip selects for SPI devices */
+	tx4938_pioptr->dout |= (1 << SEEPROM1_CS);
+	tx4938_pioptr->dir |= (1 << SEEPROM1_CS);
+	txx9_spi_init(TX4938_SPI_REG, rbtx4938_spi_cs_func);
+}
+
+static struct resource rbtx4938_fpga_resource;
+
+static char pcode_str[8];
+static struct resource tx4938_reg_resource = {
+	pcode_str, TX4938_REG_BASE, TX4938_REG_BASE+TX4938_REG_SIZE, IORESOURCE_MEM
+};
+
+void __init tx4938_board_setup(void)
+{
+	int i;
+	unsigned long divmode;
+	int cpuclk = 0;
+	unsigned long pcode = TX4938_REV_PCODE();
+
+	ioport_resource.start = 0x1000;
+	ioport_resource.end = 0xffffffff;
+	iomem_resource.start = 0x1000;
+	iomem_resource.end = 0xffffffff;	/* expand to 4GB */
+
+	sprintf(pcode_str, "TX%lx", pcode);
+	/* SDRAMC,EBUSC are configured by PROM */
+	for (i = 0; i < 8; i++) {
+		if (!(tx4938_ebuscptr->cr[i] & 0x8))
+			continue;	/* disabled */
+ 		rbtx4938_ce_base[i] = (unsigned long)TX4938_EBUSC_BA(i);
+		txboard_add_phys_region(rbtx4938_ce_base[i], TX4938_EBUSC_SIZE(i));
+	}
+
+	/* clocks */
+	if (txx9_master_clock) {
+		/* calculate gbus_clock and cpu_clock from master_clock */
+		divmode = (unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_DIVMODE_MASK;
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_8:
+		case TX4938_CCFG_DIVMODE_10:
+		case TX4938_CCFG_DIVMODE_12:
+		case TX4938_CCFG_DIVMODE_16:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_gbus_clock = txx9_master_clock * 4; break;
+		default:
+			txx9_gbus_clock = txx9_master_clock;
+		}
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_2:
+		case TX4938_CCFG_DIVMODE_8:
+			cpuclk = txx9_gbus_clock * 2; break;
+		case TX4938_CCFG_DIVMODE_2_5:
+		case TX4938_CCFG_DIVMODE_10:
+			cpuclk = txx9_gbus_clock * 5 / 2; break;
+		case TX4938_CCFG_DIVMODE_3:
+		case TX4938_CCFG_DIVMODE_12:
+			cpuclk = txx9_gbus_clock * 3; break;
+		case TX4938_CCFG_DIVMODE_4:
+		case TX4938_CCFG_DIVMODE_16:
+			cpuclk = txx9_gbus_clock * 4; break;
+		case TX4938_CCFG_DIVMODE_4_5:
+		case TX4938_CCFG_DIVMODE_18:
+			cpuclk = txx9_gbus_clock * 9 / 2; break;
+		}
+		txx9_cpu_clock = cpuclk;
+	} else {
+		if (txx9_cpu_clock == 0) {
+			txx9_cpu_clock = 300000000;	/* 300MHz */
+		}
+		/* calculate gbus_clock and master_clock from cpu_clock */
+		cpuclk = txx9_cpu_clock;
+		divmode = (unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_DIVMODE_MASK;
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_2:
+		case TX4938_CCFG_DIVMODE_8:
+			txx9_gbus_clock = cpuclk / 2; break;
+		case TX4938_CCFG_DIVMODE_2_5:
+		case TX4938_CCFG_DIVMODE_10:
+			txx9_gbus_clock = cpuclk * 2 / 5; break;
+		case TX4938_CCFG_DIVMODE_3:
+		case TX4938_CCFG_DIVMODE_12:
+			txx9_gbus_clock = cpuclk / 3; break;
+		case TX4938_CCFG_DIVMODE_4:
+		case TX4938_CCFG_DIVMODE_16:
+			txx9_gbus_clock = cpuclk / 4; break;
+		case TX4938_CCFG_DIVMODE_4_5:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_gbus_clock = cpuclk * 2 / 9; break;
+		}
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_8:
+		case TX4938_CCFG_DIVMODE_10:
+		case TX4938_CCFG_DIVMODE_12:
+		case TX4938_CCFG_DIVMODE_16:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_master_clock = txx9_gbus_clock / 4; break;
+		default:
+			txx9_master_clock = txx9_gbus_clock;
+		}
+	}
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+
+	/* CCFG */
+	/* clear WatchDogReset,BusErrorOnWrite flag (W1C) */
+	tx4938_ccfgptr->ccfg |= TX4938_CCFG_WDRST | TX4938_CCFG_BEOW;
+	/* clear PCIC1 reset */
+	if (tx4938_ccfgptr->clkctr & TX4938_CLKCTR_PCIC1RST)
+		tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIC1RST;
+
+	/* enable Timeout BusError */
+	if (tx4938_ccfg_toeon)
+		tx4938_ccfgptr->ccfg |= TX4938_CCFG_TOE;
+
+	/* DMA selection */
+	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_DMASEL_ALL;
+
+	/* Use external clock for external arbiter */
+	if (!(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIXARB))
+		tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_PCICLKEN_ALL;
+
+	printk("%s -- %dMHz(M%dMHz) CRIR:%08lx CCFG:%Lx PCFG:%Lx\n",
+	       pcode_str,
+	       cpuclk / 1000000, txx9_master_clock / 1000000,
+	       (unsigned long)tx4938_ccfgptr->crir,
+	       tx4938_ccfgptr->ccfg,
+	       tx4938_ccfgptr->pcfg);
+
+	printk("%s SDRAMC --", pcode_str);
+	for (i = 0; i < 4; i++) {
+		unsigned long long cr = tx4938_sdramcptr->cr[i];
+		unsigned long ram_base, ram_size;
+		if (!((unsigned long)cr & 0x00000400))
+			continue;	/* disabled */
+		ram_base = (unsigned long)(cr >> 49) << 21;
+		ram_size = ((unsigned long)(cr >> 33) + 1) << 21;
+		if (ram_base >= 0x20000000)
+			continue;	/* high memory (ignore) */
+		printk(" CR%d:%016Lx", i, cr);
+		txboard_add_phys_region(ram_base, ram_size);
+	}
+	printk(" TR:%09Lx\n", tx4938_sdramcptr->tr);
+
+	/* SRAM */
+	if (pcode == 0x4938 && tx4938_sramcptr->cr & 1) {
+		unsigned int size = 0x800;
+		unsigned long base =
+			(tx4938_sramcptr->cr >> (39-11)) & ~(size - 1);
+		 txboard_add_phys_region(base, size);
+	}
+
+	/* IRC */
+	/* disable interrupt control */
+	tx4938_ircptr->cer = 0;
+
+	/* TMR */
+	/* disable all timers */
+	for (i = 0; i < TX4938_NR_TMR; i++) {
+		tx4938_tmrptr(i)->tcr  = 0x00000020;
+		tx4938_tmrptr(i)->tisr = 0;
+		tx4938_tmrptr(i)->cpra = 0xffffffff;
+		tx4938_tmrptr(i)->itmr = 0;
+		tx4938_tmrptr(i)->ccdr = 0;
+		tx4938_tmrptr(i)->pgmr = 0;
+	}
+
+	/* enable DMA */
+	TX4938_WR64(0xff1fb150, TX4938_DMA_MCR_MSTEN);
+	TX4938_WR64(0xff1fb950, TX4938_DMA_MCR_MSTEN);
+
+	/* PIO */
+	tx4938_pioptr->maskcpu = 0;
+	tx4938_pioptr->maskext = 0;
+
+	/* TX4938 internal registers */
+	if (request_resource(&iomem_resource, &tx4938_reg_resource))
+		printk("request resource for internal registers failed\n");
+}
+
+#ifdef CONFIG_PCI
+static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr)
+{
+	unsigned short pcistatus = (unsigned short)(pcicptr->pcistatus >> 16);
+	unsigned long g2pstatus = pcicptr->g2pstatus;
+	unsigned long pcicstatus = pcicptr->pcicstatus;
+	static struct {
+		unsigned long flag;
+		const char *str;
+	} pcistat_tbl[] = {
+		{ PCI_STATUS_DETECTED_PARITY,	"DetectedParityError" },
+		{ PCI_STATUS_SIG_SYSTEM_ERROR,	"SignaledSystemError" },
+		{ PCI_STATUS_REC_MASTER_ABORT,	"ReceivedMasterAbort" },
+		{ PCI_STATUS_REC_TARGET_ABORT,	"ReceivedTargetAbort" },
+		{ PCI_STATUS_SIG_TARGET_ABORT,	"SignaledTargetAbort" },
+		{ PCI_STATUS_PARITY,	"MasterParityError" },
+	}, g2pstat_tbl[] = {
+		{ TX4938_PCIC_G2PSTATUS_TTOE,	"TIOE" },
+		{ TX4938_PCIC_G2PSTATUS_RTOE,	"RTOE" },
+	}, pcicstat_tbl[] = {
+		{ TX4938_PCIC_PCICSTATUS_PME,	"PME" },
+		{ TX4938_PCIC_PCICSTATUS_TLB,	"TLB" },
+		{ TX4938_PCIC_PCICSTATUS_NIB,	"NIB" },
+		{ TX4938_PCIC_PCICSTATUS_ZIB,	"ZIB" },
+		{ TX4938_PCIC_PCICSTATUS_PERR,	"PERR" },
+		{ TX4938_PCIC_PCICSTATUS_SERR,	"SERR" },
+		{ TX4938_PCIC_PCICSTATUS_GBE,	"GBE" },
+		{ TX4938_PCIC_PCICSTATUS_IWB,	"IWB" },
+	};
+	int i;
+
+	printk("pcistat:%04x(", pcistatus);
+	for (i = 0; i < ARRAY_SIZE(pcistat_tbl); i++)
+		if (pcistatus & pcistat_tbl[i].flag)
+			printk("%s ", pcistat_tbl[i].str);
+	printk("), g2pstatus:%08lx(", g2pstatus);
+	for (i = 0; i < ARRAY_SIZE(g2pstat_tbl); i++)
+		if (g2pstatus & g2pstat_tbl[i].flag)
+			printk("%s ", g2pstat_tbl[i].str);
+	printk("), pcicstatus:%08lx(", pcicstatus);
+	for (i = 0; i < ARRAY_SIZE(pcicstat_tbl); i++)
+		if (pcicstatus & pcicstat_tbl[i].flag)
+			printk("%s ", pcicstat_tbl[i].str);
+	printk(")\n");
+}
+
+void tx4938_report_pcic_status(void)
+{
+	int i;
+	struct tx4938_pcic_reg *pcicptr;
+	for (i = 0; (pcicptr = get_tx4938_pcicptr(i)) != NULL; i++)
+		tx4938_report_pcic_status1(pcicptr);
+}
+
+#endif /* CONFIG_PCI */
+
+/* We use onchip r4k counter or TMR timer as our system wide timer
+ * interrupt running at 100HZ. */
+
+extern void __init rtc_rx5c348_init(int chipid);
+void __init rbtx4938_time_init(void)
+{
+	rtc_rx5c348_init(RBTX4938_SRTC_CHIPID);
+	mips_hpt_frequency = txx9_cpu_clock / 2;
+}
+
+void __init toshiba_rbtx4938_setup(void)
+{
+	unsigned long long pcfg;
+	char *argptr;
+
+	iomem_resource.end = 0xffffffff;	/* 4GB */
+
+	if (txx9_master_clock == 0)
+		txx9_master_clock = 25000000; /* 25MHz */
+	tx4938_board_setup();
+	/* setup irq stuff */
+	TX4938_WR(TX4938_MKA(TX4938_IRC_IRDM0), 0x00000000);	/* irq trigger */
+	TX4938_WR(TX4938_MKA(TX4938_IRC_IRDM1), 0x00000000);	/* irq trigger */
+	/* setup serial stuff */
+	TX4938_WR(0xff1ff314, 0x00000000);	/* h/w flow control off */
+	TX4938_WR(0xff1ff414, 0x00000000);	/* h/w flow control off */
+
+#ifndef CONFIG_PCI
+	set_io_port_base(RBTX4938_ETHER_BASE);
+#endif
+
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)(0xff1ff300 + i * 0x100);
+			req.mapbase = 0xff1ff300 + i * 0x100;
+			req.irq = 32 + i;
+			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = 50000000;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+        argptr = prom_getcmdline();
+        if (strstr(argptr, "console=") == NULL) {
+                strcat(argptr, " console=ttyS0,38400");
+        }
+#endif
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
+	printk("PIOSEL: disabling both ata and nand selection\n");
+	local_irq_disable();
+	tx4938_ccfgptr->pcfg &= ~(TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL);
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND
+	printk("PIOSEL: enabling nand selection\n");
+	tx4938_ccfgptr->pcfg |= TX4938_PCFG_NDF_SEL;
+	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_ATA_SEL;
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA
+	printk("PIOSEL: enabling ata selection\n");
+	tx4938_ccfgptr->pcfg |= TX4938_PCFG_ATA_SEL;
+	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_NDF_SEL;
+#endif
+
+#ifdef CONFIG_IP_PNP
+	argptr = prom_getcmdline();
+	if (strstr(argptr, "ip=") == NULL) {
+		strcat(argptr, " ip=any");
+	}
+#endif
+
+
+#ifdef CONFIG_FB
+	{
+		conswitchp = &dummy_con;
+	}
+#endif
+
+	rbtx4938_spi_setup();
+	pcfg = tx4938_ccfgptr->pcfg;	/* updated */
+	/* fixup piosel */
+	if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
+	    TX4938_PCFG_ATA_SEL) {
+		*rbtx4938_piosel_ptr = (*rbtx4938_piosel_ptr & 0x03) | 0x04;
+	}
+	else if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
+	    TX4938_PCFG_NDF_SEL) {
+		*rbtx4938_piosel_ptr = (*rbtx4938_piosel_ptr & 0x03) | 0x08;
+	}
+	else {
+		*rbtx4938_piosel_ptr &= ~(0x08 | 0x04);
+	}
+
+	rbtx4938_fpga_resource.name = "FPGA Registers";
+	rbtx4938_fpga_resource.start = CPHYSADDR(RBTX4938_FPGA_REG_ADDR);
+	rbtx4938_fpga_resource.end = CPHYSADDR(RBTX4938_FPGA_REG_ADDR) + 0xffff;
+	rbtx4938_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, &rbtx4938_fpga_resource))
+		printk("request resource for fpga failed\n");
+
+	/* disable all OnBoard I/O interrupts */
+	*rbtx4938_imask_ptr = 0;
+
+	_machine_restart = rbtx4938_machine_restart;
+	_machine_halt = rbtx4938_machine_halt;
+	_machine_power_off = rbtx4938_machine_power_off;
+
+	*rbtx4938_led_ptr = 0xff;
+	printk("RBTX4938 --- FPGA(Rev %02x)", *rbtx4938_fpga_rev_ptr);
+	printk(" DIPSW:%02x,%02x\n",
+	       *rbtx4938_dipsw_ptr, *rbtx4938_bdipsw_ptr);
+}
+
+#ifdef CONFIG_PROC_FS
+extern void spi_eeprom_proc_create(struct proc_dir_entry *dir, int chipid);
+static int __init tx4938_spi_proc_setup(void)
+{
+	struct proc_dir_entry *tx4938_spi_eeprom_dir;
+
+	tx4938_spi_eeprom_dir = proc_mkdir("spi_eeprom", 0);
+
+	if (!tx4938_spi_eeprom_dir)
+		return -ENOMEM;
+
+	/* don't allow user access to RBTX4938_SEEPROM1_CHIPID
+	 * as it contains eth0 and eth1 MAC addresses
+	 */
+	spi_eeprom_proc_create(tx4938_spi_eeprom_dir, RBTX4938_SEEPROM2_CHIPID);
+	spi_eeprom_proc_create(tx4938_spi_eeprom_dir, RBTX4938_SEEPROM3_CHIPID);
+
+	return 0;
+}
+
+__initcall(tx4938_spi_proc_setup);
+#endif
diff -Naur linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c
--- linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,219 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/spi_eeprom.c
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <asm/tx4938/spi.h>
+#include <asm/tx4938/tx4938.h>
+
+/* ATMEL 250x0 instructions */
+#define	ATMEL_WREN	0x06
+#define	ATMEL_WRDI	0x04
+#define ATMEL_RDSR	0x05
+#define ATMEL_WRSR	0x01
+#define	ATMEL_READ	0x03
+#define	ATMEL_WRITE	0x02
+
+#define ATMEL_SR_BSY	0x01
+#define ATMEL_SR_WEN	0x02
+#define ATMEL_SR_BP0	0x04
+#define ATMEL_SR_BP1	0x08
+
+DEFINE_SPINLOCK(spi_eeprom_lock);
+
+static struct spi_dev_desc seeprom_dev_desc = {
+	.baud 		= 1500000,	/* 1.5Mbps */
+	.tcss		= 1,
+	.tcsh		= 1,
+	.tcsr		= 1,
+	.byteorder	= 1,		/* MSB-First */
+	.polarity	= 0,		/* High-Active */
+	.phase		= 0,		/* Sample-Then-Shift */
+
+};
+static inline int
+spi_eeprom_io(int chipid,
+	      unsigned char **inbufs, unsigned int *incounts,
+	      unsigned char **outbufs, unsigned int *outcounts)
+{
+	return txx9_spi_io(chipid, &seeprom_dev_desc,
+			   inbufs, incounts, outbufs, outcounts, 0);
+}
+
+int spi_eeprom_write_enable(int chipid, int enable)
+{
+	unsigned char inbuf[1];
+	unsigned char *inbufs[1];
+	unsigned int incounts[2];
+	unsigned long flags;
+	int stat;
+	inbuf[0] = enable ? ATMEL_WREN : ATMEL_WRDI;
+	inbufs[0] = inbuf;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = 0;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_io(chipid, inbufs, incounts, NULL, NULL);
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+static int spi_eeprom_read_status_nolock(int chipid)
+{
+	unsigned char inbuf[2], outbuf[2];
+	unsigned char *inbufs[1], *outbufs[1];
+	unsigned int incounts[2], outcounts[2];
+	int stat;
+	inbuf[0] = ATMEL_RDSR;
+	inbuf[1] = 0;
+	inbufs[0] = inbuf;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = 0;
+	outbufs[0] = outbuf;
+	outcounts[0] = sizeof(outbuf);
+	outcounts[1] = 0;
+	stat = spi_eeprom_io(chipid, inbufs, incounts, outbufs, outcounts);
+	if (stat < 0)
+		return stat;
+	return outbuf[1];
+}
+
+int spi_eeprom_read_status(int chipid)
+{
+	unsigned long flags;
+	int stat;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_read_status_nolock(chipid);
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+int spi_eeprom_read(int chipid, int address, unsigned char *buf, int len)
+{
+	unsigned char inbuf[2];
+	unsigned char *inbufs[2], *outbufs[2];
+	unsigned int incounts[2], outcounts[3];
+	unsigned long flags;
+	int stat;
+	inbuf[0] = ATMEL_READ;
+	inbuf[1] = address;
+	inbufs[0] = inbuf;
+	inbufs[1] = NULL;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = 0;
+	outbufs[0] = NULL;
+	outbufs[1] = buf;
+	outcounts[0] = 2;
+	outcounts[1] = len;
+	outcounts[2] = 0;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_io(chipid, inbufs, incounts, outbufs, outcounts);
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+int spi_eeprom_write(int chipid, int address, unsigned char *buf, int len)
+{
+	unsigned char inbuf[2];
+	unsigned char *inbufs[2];
+	unsigned int incounts[3];
+	unsigned long flags;
+	int i, stat;
+
+	if (address / 8 != (address + len - 1) / 8)
+		return -EINVAL;
+	stat = spi_eeprom_write_enable(chipid, 1);
+	if (stat < 0)
+		return stat;
+	stat = spi_eeprom_read_status(chipid);
+	if (stat < 0)
+		return stat;
+	if (!(stat & ATMEL_SR_WEN))
+		return -EPERM;
+
+	inbuf[0] = ATMEL_WRITE;
+	inbuf[1] = address;
+	inbufs[0] = inbuf;
+	inbufs[1] = buf;
+	incounts[0] = sizeof(inbuf);
+	incounts[1] = len;
+	incounts[2] = 0;
+	spin_lock_irqsave(&spi_eeprom_lock, flags);
+	stat = spi_eeprom_io(chipid, inbufs, incounts, NULL, NULL);
+	if (stat < 0)
+		goto unlock_return;
+
+	/* write start.  max 10ms */
+	for (i = 10; i > 0; i--) {
+		int stat = spi_eeprom_read_status_nolock(chipid);
+		if (stat < 0)
+			goto unlock_return;
+		if (!(stat & ATMEL_SR_BSY))
+			break;
+		mdelay(1);
+	}
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	if (i == 0)
+		return -EIO;
+	return len;
+ unlock_return:
+	spin_unlock_irqrestore(&spi_eeprom_lock, flags);
+	return stat;
+}
+
+#ifdef CONFIG_PROC_FS
+#define MAX_SIZE	0x80	/* for ATMEL 25010 */
+static int spi_eeprom_read_proc(char *page, char **start, off_t off,
+				int count, int *eof, void *data)
+{
+	unsigned int size = MAX_SIZE;
+	if (spi_eeprom_read((int)data, 0, (unsigned char *)page, size) < 0)
+		size = 0;
+	return size;
+}
+
+static int spi_eeprom_write_proc(struct file *file, const char *buffer,
+				 unsigned long count, void *data)
+{
+	unsigned int size = MAX_SIZE;
+	int i;
+	if (file->f_pos >= size)
+		return -EIO;
+	if (file->f_pos + count > size)
+		count = size - file->f_pos;
+	for (i = 0; i < count; i += 8) {
+		int len = count - i < 8 ? count - i : 8;
+		if (spi_eeprom_write((int)data, file->f_pos,
+				     (unsigned char *)buffer, len) < 0) {
+			count = -EIO;
+			break;
+		}
+		buffer += len;
+		file->f_pos += len;
+	}
+	return count;
+}
+
+__init void spi_eeprom_proc_create(struct proc_dir_entry *dir, int chipid)
+{
+	struct proc_dir_entry *entry;
+	char name[128];
+	sprintf(name, "seeprom-%d", chipid);
+	entry = create_proc_entry(name, 0600, dir);
+	if (entry) {
+		entry->read_proc = spi_eeprom_read_proc;
+		entry->write_proc = spi_eeprom_write_proc;
+		entry->data = (void *)chipid;
+	}
+}
+#endif /* CONFIG_PROC_FS */
diff -Naur linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c
--- linux-2.6.14/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,159 @@
+/*
+ * linux/arch/mips/tx4938/toshiba_rbtx4938/spi_txx9.c
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <asm/tx4938/spi.h>
+#include <asm/tx4938/tx4938.h>
+
+static int (*txx9_spi_cs_func)(int chipid, int on);
+static DEFINE_SPINLOCK(txx9_spi_lock);
+
+extern unsigned int txx9_gbus_clock;
+
+#define SPI_FIFO_SIZE	4
+
+void __init txx9_spi_init(unsigned long base, int (*cs_func)(int chipid, int on))
+{
+	txx9_spi_cs_func = cs_func;
+	/* enter config mode */
+	tx4938_spiptr->mcr = TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR;
+}
+
+static DECLARE_WAIT_QUEUE_HEAD(txx9_spi_wait);
+static void txx9_spi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/* disable rx intr */
+	tx4938_spiptr->cr0 &= ~TXx9_SPCR0_RBSIE;
+	wake_up(&txx9_spi_wait);
+}
+static struct irqaction txx9_spi_action = {
+	txx9_spi_interrupt, 0, 0, "spi", NULL, NULL,
+};
+
+void __init txx9_spi_irqinit(int irc_irq)
+{
+	setup_irq(irc_irq, &txx9_spi_action);
+}
+
+int txx9_spi_io(int chipid, struct spi_dev_desc *desc,
+		unsigned char **inbufs, unsigned int *incounts,
+		unsigned char **outbufs, unsigned int *outcounts,
+		int cansleep)
+{
+	unsigned int incount, outcount;
+	unsigned char *inp, *outp;
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&txx9_spi_lock, flags);
+	if ((tx4938_spiptr->mcr & TXx9_SPMCR_OPMODE) == TXx9_SPMCR_ACTIVE) {
+		spin_unlock_irqrestore(&txx9_spi_lock, flags);
+		return -EBUSY;
+	}
+	/* enter config mode */
+	tx4938_spiptr->mcr = TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR;
+	tx4938_spiptr->cr0 =
+		(desc->byteorder ? TXx9_SPCR0_SBOS : 0) |
+		(desc->polarity ? TXx9_SPCR0_SPOL : 0) |
+		(desc->phase ? TXx9_SPCR0_SPHA : 0) |
+		0x08;
+	tx4938_spiptr->cr1 =
+		(((TXX9_IMCLK + desc->baud) / (2 * desc->baud) - 1) << 8) |
+		0x08 /* 8 bit only */;
+	/* enter active mode */
+	tx4938_spiptr->mcr = TXx9_SPMCR_ACTIVE;
+	spin_unlock_irqrestore(&txx9_spi_lock, flags);
+
+	/* CS ON */
+	if ((ret = txx9_spi_cs_func(chipid, 1)) < 0) {
+		spin_unlock_irqrestore(&txx9_spi_lock, flags);
+		return ret;
+	}
+	udelay(desc->tcss);
+
+	/* do scatter IO */
+	inp = inbufs ? *inbufs : NULL;
+	outp = outbufs ? *outbufs : NULL;
+	incount = 0;
+	outcount = 0;
+	while (1) {
+		unsigned char data;
+		unsigned int count;
+		int i;
+		if (!incount) {
+			incount = incounts ? *incounts++ : 0;
+			inp = (incount && inbufs) ? *inbufs++ : NULL;
+		}
+		if (!outcount) {
+			outcount = outcounts ? *outcounts++ : 0;
+			outp = (outcount && outbufs) ? *outbufs++ : NULL;
+		}
+		if (!inp && !outp)
+			break;
+		count = SPI_FIFO_SIZE;
+		if (incount)
+			count = min(count, incount);
+		if (outcount)
+			count = min(count, outcount);
+
+		/* now tx must be idle... */
+		while (!(tx4938_spiptr->sr & TXx9_SPSR_SIDLE))
+			;
+
+		tx4938_spiptr->cr0 =
+			(tx4938_spiptr->cr0 & ~TXx9_SPCR0_RXIFL_MASK) |
+			((count - 1) << 12);
+		if (cansleep) {
+			/* enable rx intr */
+			tx4938_spiptr->cr0 |= TXx9_SPCR0_RBSIE;
+		}
+		/* send */
+		for (i = 0; i < count; i++)
+			tx4938_spiptr->dr = inp ? *inp++ : 0;
+		/* wait all rx data */
+		if (cansleep) {
+			wait_event(txx9_spi_wait,
+				   tx4938_spiptr->sr & TXx9_SPSR_SRRDY);
+		} else {
+			while (!(tx4938_spiptr->sr & TXx9_SPSR_RBSI))
+				;
+		}
+		/* receive */
+		for (i = 0; i < count; i++) {
+			data = tx4938_spiptr->dr;
+			if (outp)
+				*outp++ = data;
+		}
+		if (incount)
+			incount -= count;
+		if (outcount)
+			outcount -= count;
+	}
+
+	/* CS OFF */
+	udelay(desc->tcsh);
+	txx9_spi_cs_func(chipid, 0);
+	udelay(desc->tcsr);
+
+	spin_lock_irqsave(&txx9_spi_lock, flags);
+	/* enter config mode */
+	tx4938_spiptr->mcr = TXx9_SPMCR_CONFIG | TXx9_SPMCR_BCLR;
+	spin_unlock_irqrestore(&txx9_spi_lock, flags);
+
+	return 0;
+}
diff -Naur linux-2.6.14/arch/mips/vr41xx/common/cmu.c linux-mips-2.6.14.orig/arch/mips/vr41xx/common/cmu.c
--- linux-2.6.14/arch/mips/vr41xx/common/cmu.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/vr41xx/common/cmu.c	2005-11-17 11:42:29.000000000 -0800
@@ -69,7 +69,7 @@
 
 static void __iomem *cmu_base;
 static uint16_t cmuclkmsk, cmuclkmsk2;
-static spinlock_t cmu_lock;
+static DEFINE_SPINLOCK(cmu_lock);
 
 #define cmu_read(offset)		readw(cmu_base + (offset))
 #define cmu_write(offset, value)	writew((value), cmu_base + (offset))
diff -Naur linux-2.6.14/arch/mips/vr41xx/common/init.c linux-mips-2.6.14.orig/arch/mips/vr41xx/common/init.c
--- linux-2.6.14/arch/mips/vr41xx/common/init.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/vr41xx/common/init.c	2005-11-17 11:42:29.000000000 -0800
@@ -58,6 +58,14 @@
 	board_timer_setup = setup_timer_irq;
 }
 
+void __init plat_setup(void)
+{
+	vr41xx_calculate_clock_frequency();
+
+	timer_init();
+	iomem_resource_init();
+}
+
 void __init prom_init(void)
 {
 	int argc, i;
@@ -71,12 +79,6 @@
 		if (i < (argc - 1))
 			strcat(arcs_cmdline, " ");
 	}
-
-	vr41xx_calculate_clock_frequency();
-
-	timer_init();
-
-	iomem_resource_init();
 }
 
 unsigned long __init prom_free_prom_memory (void)
diff -Naur linux-2.6.14/arch/mips/vr41xx/common/vrc4173.c linux-mips-2.6.14.orig/arch/mips/vr41xx/common/vrc4173.c
--- linux-2.6.14/arch/mips/vr41xx/common/vrc4173.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/vr41xx/common/vrc4173.c	2005-11-17 11:42:29.000000000 -0800
@@ -81,8 +81,8 @@
 static int vrc4173_initialized;
 static uint16_t vrc4173_cmuclkmsk;
 static uint16_t vrc4173_selectreg;
-static spinlock_t vrc4173_cmu_lock;
-static spinlock_t vrc4173_giu_lock;
+static DEFINE_SPINLOCK(vrc4173_cmu_lock);
+static DEFINE_SPINLOCK(vrc4173_giu_lock);
 
 static inline void set_cmusrst(uint16_t val)
 {
diff -Naur linux-2.6.14/arch/mips/vr41xx/Kconfig linux-mips-2.6.14.orig/arch/mips/vr41xx/Kconfig
--- linux-2.6.14/arch/mips/vr41xx/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/arch/mips/vr41xx/Kconfig	2005-11-17 11:42:29.000000000 -0800
@@ -0,0 +1,102 @@
+config NEC_CMBVR4133
+	bool "Support for NEC CMB-VR4133"
+	depends on MACH_VR41XX
+	select CPU_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select PCI_VR41XX
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config ROCKHOPPER
+	bool "Support for Rockhopper baseboard"
+	depends on NEC_CMBVR4133
+	select I8259
+	select HAVE_STD_PC_SERIAL_PORT
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+
+config CASIO_E55
+	bool "Support for CASIO CASSIOPEIA E-10/15/55/65"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ISA
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config IBM_WORKPAD
+	bool "Support for IBM WorkPad z50"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ISA
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config TANBAC_TB022X
+	bool "Support for TANBAC TB0225 (VR4131 multichip module) and TB0229 (VR4131DIMM)"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  The TANBAC TB0225 (VR4131 multichip module) and TB0229 (VR4131DIMM)
+	  are MIPS-based platforms manufactured by TANBAC.
+	  Please refer to <http://www.tanbac.co.jp/> about
+	  VR4131 Multi-chip module and VR4131DIMM.
+
+config TANBAC_TB0226
+	bool "Support for TANBAC TB0226 (Mbase)"
+	depends on TANBAC_TB022X
+	select PCI
+	select PCI_VR41XX
+	select GPIO_VR41XX
+	help
+	  The TANBAC TB0226 (Mbase) is a MIPS-based platform manufactured by
+	  TANBAC.  Please refer to <http://www.tanbac.co.jp/> about Mbase.
+
+config VICTOR_MPC30X
+	bool "Support for Victor MP-C303/304"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	depends on MACH_VR41XX
+
+config ZAO_CAPCELLA
+	bool "Support for ZAO Networks Capcella"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_HAS_CPU_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PCI_VR41XX
+	bool "Add PCI control unit support of NEC VR4100 series"
+	depends on MACH_VR41XX && PCI
+
+config VRC4173
+	tristate "Add NEC VRC4173 companion chip support"
+	depends on MACH_VR41XX && PCI_VR41XX
+	help
+	  The NEC VRC4173 is a companion chip for NEC VR4122/VR4131.
diff -Naur linux-2.6.14/arch/mips/vr41xx/nec-cmbvr4133/setup.c linux-mips-2.6.14.orig/arch/mips/vr41xx/nec-cmbvr4133/setup.c
--- linux-2.6.14/arch/mips/vr41xx/nec-cmbvr4133/setup.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/arch/mips/vr41xx/nec-cmbvr4133/setup.c	2005-11-17 11:42:29.000000000 -0800
@@ -16,6 +16,7 @@
  */
 #include <linux/config.h>
 #include <linux/init.h>
+#include <linux/console.h>
 #include <linux/ide.h>
 #include <linux/ioport.h>
 
@@ -56,7 +57,7 @@
 
 extern void i8259_init(void);
 
-static int __init nec_cmbvr4133_setup(void)
+static void __init nec_cmbvr4133_setup(void)
 {
 #ifdef CONFIG_ROCKHOPPER
 	extern void disable_pcnet(void);
@@ -90,7 +91,4 @@
 #ifdef CONFIG_ROCKHOPPER
 	i8259_init();
 #endif
-	return 0;
 }
-
-early_initcall(nec_cmbvr4133_setup);
diff -Naur linux-2.6.14/Documentation/mips/AU1xxx_IDE.README linux-mips-2.6.14.orig/Documentation/mips/AU1xxx_IDE.README
--- linux-2.6.14/Documentation/mips/AU1xxx_IDE.README	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/Documentation/mips/AU1xxx_IDE.README	2005-11-17 11:42:02.000000000 -0800
@@ -0,0 +1,168 @@
+README for MIPS AU1XXX IDE driver - Released 2005-07-15
+
+ABOUT
+-----
+This file describes the 'drivers/ide/mips/au1xxx-ide.c', related files and the
+services they provide. 
+
+If you are short in patience and just want to know how to add your hard disc to
+the white or black list, go to the 'ADD NEW HARD DISC TO WHITE OR BLACK LIST'
+section.
+
+
+LICENSE
+-------
+
+Copyright (c) 2003-2005 AMD, Personal Connectivity Solutions
+
+This program is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free Software
+Foundation; either version 2 of the License, or (at your option) any later
+version.
+
+THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+You should have received a copy of the GNU General Public License along with
+this program; if not, write to the Free Software Foundation, Inc.,
+675 Mass Ave, Cambridge, MA 02139, USA.
+    
+Note: for more information, please refer "AMD Alchemy Au1200/Au1550 IDE
+      Interface and Linux Device Driver" Application Note.
+
+
+FILES, CONFIGS AND COMPATABILITY
+--------------------------------
+
+Two files are introduced:
+
+  a) 'include/asm-mips/mach-au1x00/au1xxx_ide.h'
+     containes : struct _auide_hwif
+                 struct drive_list_entry dma_white_list
+                 struct drive_list_entry dma_black_list
+                 timing parameters for PIO mode 0/1/2/3/4
+                 timing parameters for MWDMA 0/1/2
+
+  b) 'drivers/ide/mips/au1xxx-ide.c'
+     contains the functionality of the AU1XXX IDE driver
+
+Four configs variables are introduced:
+
+  CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA    - enable the PIO+DBDMA mode
+  CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA  - enable the MWDMA mode 
+  CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON - set Burstable FIFO in DBDMA
+                                           controler
+  CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ - maximum transfer size
+                                           per descriptor
+
+If MWDMA is enabled and the connected hard disc is not on the white list, the
+kernel switches to a "safe mwdma mode" at boot time. In this mode the IDE
+performance is substantial slower then in full speed mwdma. In this case
+please add your hard disc to the white list (follow instruction from 'ADD NEW 
+HARD DISC TO WHITE OR BLACK LIST' section).
+
+
+SUPPORTED IDE MODES
+------------------- 
+
+The AU1XXX IDE driver supported all PIO modes - PIO mode 0/1/2/3/4 - and all
+MWDMA modes - MWDMA 0/1/2 -. There is no support for SWDMA and UDMA mode.
+
+To change the PIO mode use the program hdparm with option -p, e.g.
+'hdparm -p0 [device]' for PIO mode 0. To enable the MWDMA mode use the option 
+-X, e.g. 'hdparm -X32 [device]' for MWDMA mode 0.
+
+
+PERFORMANCE CONFIGURATIONS
+--------------------------
+
+If the used system doesn't need USB support enable the following kernel configs:
+
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_BLK_DEV_GENERIC=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+CONFIG_IDEDMA_PCI_AUTO=y
+CONFIG_BLK_DEV_IDE_AU1XXX=y
+CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA=y
+CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON=y
+CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ=128
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
+
+If the used system need the USB support enable the following kernel configs for
+high IDE to USB throughput.
+
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_BLK_DEV_GENERIC=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+CONFIG_IDEDMA_PCI_AUTO=y
+CONFIG_BLK_DEV_IDE_AU1XXX=y
+CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA=y
+CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ=128
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
+
+
+ADD NEW HARD DISC TO WHITE OR BLACK LIST
+----------------------------------------
+
+Step 1 : detect the model name of your hard disc
+ 
+  a) connect your hard disc to the AU1XXX
+
+  b) boot your kernel and get the hard disc model.
+     
+     Example boot log:
+
+     --snipped--
+     Uniform Multi-Platform E-IDE driver Revision: 7.00alpha2
+     ide: Assuming 50MHz system bus speed for PIO modes; override with idebus=xx
+     Au1xxx IDE(builtin) configured for MWDMA2
+     Probing IDE interface ide0...
+     hda: Maxtor 6E040L0, ATA DISK drive
+     ide0 at 0xac800000-0xac800007,0xac8001c0 on irq 64
+     hda: max request size: 64KiB
+     hda: 80293248 sectors (41110 MB) w/2048KiB Cache, CHS=65535/16/63, (U)DMA
+     --snipped--
+
+     In this example 'Maxtor 6E040L0'.
+
+Step  2 : edit 'include/asm-mips/mach-au1x00/au1xxx_ide.h'
+
+  Add your hard disc to the dma_white_list or dma_black_list structur.
+
+Step 3 : Recompile the kernel
+
+  Enable MWDMA support in the kernel configuration. Recompile the kernel and
+  reboot. 
+
+Step 4 : Tests
+
+  If you have add a hard disc to the white list, please run some stress tests 
+  for verification.
+
+
+ACKNOWLEDGMENTS
+---------------
+
+These drivers wouldn't have been done without the base of kernel 2.4.x AU1XXX 
+IDE driver from AMD.
+
+Additional input also from:
+Matthias Lenk <matthias.lenk@amd.com>
+
+Happy hacking!
+Enrico Walther <enrico.walther@amd.com>
diff -Naur linux-2.6.14/drivers/char/au1000_gpio.c linux-mips-2.6.14.orig/drivers/char/au1000_gpio.c
--- linux-2.6.14/drivers/char/au1000_gpio.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/char/au1000_gpio.c	2005-11-17 11:42:45.000000000 -0800
@@ -0,0 +1,266 @@
+/*
+ * FILE NAME au1000_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Driver for Alchemy Au1000 GPIO.
+ *
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Steve Longerbeam <stevel@mvista.com>
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/au1000_gpio.h>
+
+#define VERSION "0.01"
+
+static const struct {
+	u32 active_hi;
+	u32 avail_mask;
+} pinfunc_to_avail[15] = {
+	{1,  0x7<<16},   // 0  = SSI0     / GPIO[18:16]
+	{-1, 0},         // 1  = AC97     / SSI1
+	{1,  1<<19},     // 2  = IRDA     / GPIO19
+	{1,  1<<20},     // 3  = UART0    / GPIO20
+	{1,  0x1f<<24},  // 4  = NIC2     / GPIO[28:24]
+	{1,  0x7<<29},   // 5  = I2S      / GPIO[31:29]
+	{0,  1<<8},      // 6  = I2SDI    / GPIO8
+	{0,  0x3f<<9},   // 7  = UART3    / GPIO[14:9]
+	{0,  1<<15},     // 8  = IRFIRSEL / GPIO15
+	{0,  1<<2},      // 9  = EXTCLK0 or OSC / GPIO2
+	{0,  1<<3},      // 10 = EXTCLK1  / GPIO3
+	{0,  1<<6},      // 11 = SMROMCKE / GPIO6
+	{1,  1<<21},     // 12 = UART1    / GPIO21
+	{1,  1<<22},     // 13 = UART2    / GPIO22
+	{1,  1<<23}      // 14 = UART3    / GPIO23
+};
+
+	
+u32 get_au1000_avail_gpio_mask(void)
+{
+	int i;
+	u32 pinfunc = inl(SYS_PINFUNC);
+	u32 avail_mask = 0; // start with no gpio available
+
+	// first, check for GPIO's reprogrammed as peripheral pins
+	for (i=0; i<15; i++) {
+		if (pinfunc_to_avail[i].active_hi < 0)
+			continue;
+		if (!(pinfunc_to_avail[i].active_hi ^
+		      ((pinfunc & (1<<i)) ? 1:0)))
+			avail_mask |= pinfunc_to_avail[i].avail_mask;
+	}
+
+	// check for GPIO's used as interrupt sources
+	avail_mask &= ~(inl(IC1_MASKRD) &
+			(inl(IC1_CFG0RD) | inl(IC1_CFG1RD)));
+
+#ifdef CONFIG_USB_OHCI
+	avail_mask &= ~((1<<4) | (1<<11));
+#ifndef CONFIG_AU1X00_USB_DEVICE
+	avail_mask &= ~((1<<5) | (1<<13));
+#endif
+#endif
+	
+	return avail_mask;
+}
+
+
+/*
+ * Tristate the requested GPIO pins specified in data.
+ * Only available GPIOs will be tristated.
+ */
+int au1000gpio_tristate(u32 data)
+{
+	data &= get_au1000_avail_gpio_mask();
+
+	if (data)
+		outl(data, SYS_TRIOUTCLR);
+
+	return 0;
+}
+
+
+/*
+ * Return the pin state. Pins configured as outputs will return
+ * the output state, and pins configured as inputs (tri-stated)
+ * will return input pin state.
+ */
+int au1000gpio_in(u32 *data)
+{
+	*data = inl(SYS_PINSTATERD);
+	return 0;
+}
+
+
+/*
+ * Set/clear GPIO pins. Only available GPIOs will be affected.
+ */
+int au1000gpio_set(u32 data)
+{
+	data &= get_au1000_avail_gpio_mask();
+
+	if (data)
+		outl(data, SYS_OUTPUTSET);
+	return 0;
+}
+
+int au1000gpio_clear(u32 data)
+{
+	data &= get_au1000_avail_gpio_mask();
+
+	if (data)
+		outl(data, SYS_OUTPUTCLR);
+	return 0;
+}
+
+/*
+ * Output data to GPIO pins. Only available GPIOs will be affected.
+ */
+int au1000gpio_out(u32 data)
+{
+	au1000gpio_set(data);
+	au1000gpio_clear(~data);
+	return 0;
+}
+
+
+EXPORT_SYMBOL(get_au1000_avail_gpio_mask);
+EXPORT_SYMBOL(au1000gpio_tristate);
+EXPORT_SYMBOL(au1000gpio_in);
+EXPORT_SYMBOL(au1000gpio_set);
+EXPORT_SYMBOL(au1000gpio_clear);
+EXPORT_SYMBOL(au1000gpio_out);
+
+
+static int au1000gpio_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static int au1000gpio_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static int au1000gpio_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int status;
+	u32 val;
+	
+	switch(cmd) {
+	case AU1000GPIO_IN:
+		
+		status = au1000gpio_in(&val);
+		if (status != 0)
+			return status;
+
+		return put_user(val, (u32 *)arg);
+
+	case AU1000GPIO_OUT:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_out(val);
+
+	case AU1000GPIO_SET:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_set(val);
+		
+	case AU1000GPIO_CLEAR:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_clear(val);
+
+	case AU1000GPIO_TRISTATE:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_tristate(val);
+
+	case AU1000GPIO_AVAIL_MASK:
+		
+		return put_user(get_au1000_avail_gpio_mask(),
+				(u32 *)arg);
+		
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+
+	return 0;
+}
+
+
+static struct file_operations au1000gpio_fops =
+{
+	.owner		= THIS_MODULE,
+	.ioctl		= au1000gpio_ioctl,
+	.open		= au1000gpio_open,
+	.release	= au1000gpio_release,
+};
+
+
+static struct miscdevice au1000gpio_miscdev =
+{
+	MISC_DYNAMIC_MINOR,
+	"au1000_gpio",
+	&au1000gpio_fops
+};
+
+
+int __init au1000gpio_init(void)
+{
+	misc_register(&au1000gpio_miscdev);
+	printk("Au1000 gpio driver, version %s\n", VERSION);
+	return 0;
+}	
+
+
+void __exit au1000gpio_exit(void)
+{
+	misc_deregister(&au1000gpio_miscdev);
+}
+
+
+module_init(au1000gpio_init);
+module_exit(au1000gpio_exit);
diff -Naur linux-2.6.14/drivers/char/au1000_ts.c linux-mips-2.6.14.orig/drivers/char/au1000_ts.c
--- linux-2.6.14/drivers/char/au1000_ts.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/char/au1000_ts.c	2005-11-17 11:42:45.000000000 -0800
@@ -0,0 +1,677 @@
+/*
+ *      au1000_ts.c  --  Touch screen driver for the Alchemy Au1000's
+ *                       SSI Port 0 talking to the ADS7846 touch screen
+ *                       controller.
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Notes:
+ *
+ *  Revision history
+ *    06.27.2001  Initial version
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/string.h>
+#include <linux/ioport.h>       /* request_region */
+#include <linux/interrupt.h>    /* mark_bh */
+#include <asm/uaccess.h>        /* get_user,copy_to_user */
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#define TS_NAME "au1000-ts"
+#define TS_MAJOR 11
+
+#define PFX TS_NAME
+#define AU1000_TS_DEBUG 1
+
+#ifdef AU1000_TS_DEBUG
+#define dbg(format, arg...) printk(KERN_DEBUG PFX ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
+
+
+// SSI Status register bit defines
+#define SSISTAT_BF    (1<<4)
+#define SSISTAT_OF    (1<<3)
+#define SSISTAT_UF    (1<<2)
+#define SSISTAT_DONE  (1<<1)
+#define SSISTAT_BUSY  (1<<0)
+
+// SSI Interrupt Pending and Enable register bit defines
+#define SSIINT_OI     (1<<3)
+#define SSIINT_UI     (1<<2)
+#define SSIINT_DI     (1<<1)
+
+// SSI Address/Data register bit defines
+#define SSIADAT_D         (1<<24)
+#define SSIADAT_ADDR_BIT  16
+#define SSIADAT_ADDR_MASK (0xff<<SSIADAT_ADDR_BIT)
+#define SSIADAT_DATA_BIT  0
+#define SSIADAT_DATA_MASK (0xfff<<SSIADAT_DATA_BIT)
+
+// SSI Enable register bit defines
+#define SSIEN_CD (1<<1)
+#define SSIEN_E  (1<<0)
+
+// SSI Config register bit defines
+#define SSICFG_AO (1<<24)
+#define SSICFG_DO (1<<23)
+#define SSICFG_ALEN_BIT 20
+#define SSICFG_ALEN_MASK (0x7<<SSICFG_ALEN_BIT)
+#define SSICFG_DLEN_BIT 16
+#define SSICFG_DLEN_MASK (0xf<<SSICFG_DLEN_BIT)
+#define SSICFG_DD (1<<11)
+#define SSICFG_AD (1<<10)
+#define SSICFG_BM_BIT 8
+#define SSICFG_BM_MASK (0x3<<SSICFG_BM_BIT)
+#define SSICFG_CE (1<<7)
+#define SSICFG_DP (1<<6)
+#define SSICFG_DL (1<<5)
+#define SSICFG_EP (1<<4)
+
+// Bus Turnaround Selection
+#define SCLK_HOLD_HIGH 0
+#define SCLK_HOLD_LOW  1
+#define SCLK_CYCLE     2
+
+/*
+ * Default config for SSI0:
+ *
+ *   - transmit MSBit first
+ *   - expect MSBit first on data receive
+ *   - address length 7 bits
+ *   - expect data length 12 bits
+ *   - do not disable Direction bit
+ *   - do not disable Address bits
+ *   - SCLK held low during bus turnaround
+ *   - Address and Data bits clocked out on falling edge of SCLK
+ *   - Direction bit high is a read, low is a write
+ *   - Direction bit precedes Address bits
+ *   - Active low enable signal
+ */
+
+#define DEFAULT_SSI_CONFIG \
+    (SSICFG_AO | SSICFG_DO | (6<<SSICFG_ALEN_BIT) | (11<<SSICFG_DLEN_BIT) |\
+    (SCLK_HOLD_LOW<<SSICFG_BM_BIT) | SSICFG_DP | SSICFG_EP)
+
+
+// ADS7846 Control Byte bit defines
+#define ADS7846_ADDR_BIT  4
+#define ADS7846_ADDR_MASK (0x7<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_X  (0x5<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_Y  (0x1<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_Z1 (0x3<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_Z2 (0x4<<ADS7846_ADDR_BIT)
+#define ADS7846_8BITS     (1<<3)
+#define ADS7846_12BITS    0
+#define ADS7846_SER       (1<<2)
+#define ADS7846_DFR       0
+#define ADS7846_PWR_BIT   0
+#define   ADS7846_PD      0
+#define   ADS7846_ADC_ON  (0x1<<ADS7846_PWR_BIT)
+#define   ADS7846_REF_ON  (0x2<<ADS7846_PWR_BIT)
+#define   ADS7846_REF_ADC_ON (0x3<<ADS7846_PWR_BIT)
+
+#define MEASURE_12BIT_X \
+    (ADS7846_MEASURE_X | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+#define MEASURE_12BIT_Y \
+    (ADS7846_MEASURE_Y | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+#define MEASURE_12BIT_Z1 \
+    (ADS7846_MEASURE_Z1 | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+#define MEASURE_12BIT_Z2 \
+    (ADS7846_MEASURE_Z2 | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+
+typedef enum {
+	IDLE = 0,
+	ACQ_X,
+	ACQ_Y,
+	ACQ_Z1,
+	ACQ_Z2
+} acq_state_t;
+
+/* +++++++++++++ Lifted from include/linux/h3600_ts.h ++++++++++++++*/
+typedef struct {
+	unsigned short pressure;  // touch pressure
+	unsigned short x;         // calibrated X
+	unsigned short y;         // calibrated Y
+	unsigned short millisecs; // timestamp of this event
+} TS_EVENT;
+
+typedef struct {
+	int xscale;
+	int xtrans;
+	int yscale;
+	int ytrans;
+	int xyswap;
+} TS_CAL;
+
+/* Use 'f' as magic number */
+#define IOC_MAGIC  'f'
+
+#define TS_GET_RATE             _IO(IOC_MAGIC, 8)
+#define TS_SET_RATE             _IO(IOC_MAGIC, 9)
+#define TS_GET_CAL              _IOR(IOC_MAGIC, 10, TS_CAL)
+#define TS_SET_CAL              _IOW(IOC_MAGIC, 11, TS_CAL)
+
+/* +++++++++++++ Done lifted from include/linux/h3600_ts.h +++++++++*/
+
+
+#define EVENT_BUFSIZE 128
+
+/*
+ * Which pressure equation to use from ADS7846 datasheet.
+ * The first equation requires knowing only the X plate
+ * resistance, but needs 4 measurements (X, Y, Z1, Z2).
+ * The second equation requires knowing both X and Y plate
+ * resistance, but only needs 3 measurements (X, Y, Z1).
+ * The second equation is preferred because of the shorter
+ * acquisition time required.
+ */
+enum {
+	PRESSURE_EQN_1 = 0,
+	PRESSURE_EQN_2
+};
+
+
+/*
+ * The touch screen's X and Y plate resistances, used by
+ * pressure equations.
+ */
+#define DEFAULT_X_PLATE_OHMS 580
+#define DEFAULT_Y_PLATE_OHMS 580
+
+/*
+ * Pen up/down pressure resistance thresholds.
+ *
+ * FIXME: these are bogus and will have to be found empirically.
+ *
+ * These are hysteresis points. If pen state is up and pressure
+ * is greater than pen-down threshold, pen transitions to down.
+ * If pen state is down and pressure is less than pen-up threshold,
+ * pen transitions to up. If pressure is in-between, pen status
+ * doesn't change.
+ *
+ * This wouldn't be needed if PENIRQ* from the ADS7846 were
+ * routed to an interrupt line on the Au1000. This would issue
+ * an interrupt when the panel is touched.
+ */
+#define DEFAULT_PENDOWN_THRESH_OHMS 100
+#define DEFAULT_PENUP_THRESH_OHMS    80
+
+typedef struct {
+	int baudrate;
+	u32 clkdiv;
+	acq_state_t acq_state;            // State of acquisition state machine
+	int x_raw, y_raw, z1_raw, z2_raw; // The current raw acquisition values
+	TS_CAL cal;                       // Calibration values
+	// The X and Y plate resistance, needed to calculate pressure
+	int x_plate_ohms, y_plate_ohms;
+	// pressure resistance at which pen is considered down/up
+	int pendown_thresh_ohms;
+	int penup_thresh_ohms;
+	int pressure_eqn;                 // eqn to use for pressure calc
+	int pendown;                      // 1 = pen is down, 0 = pen is up
+	TS_EVENT event_buf[EVENT_BUFSIZE];// The event queue
+	int nextIn, nextOut;
+	int event_count;
+	struct fasync_struct *fasync;     // asynch notification
+	struct timer_list acq_timer;      // Timer for triggering acquisitions
+	wait_queue_head_t wait;           // read wait queue
+	spinlock_t lock;
+	struct tq_struct chug_tq;
+} au1000_ts_t;
+
+static au1000_ts_t au1000_ts;
+
+
+static inline u32
+calc_clkdiv(int baud)
+{
+	u32 sys_busclk =
+		(get_au1000_speed() / (int)(inl(PM_POWERUP_CONTROL)&0x03) + 2);
+	return (sys_busclk / (2 * baud)) - 1;
+}
+
+static inline int
+calc_baudrate(u32 clkdiv)
+{
+	u32 sys_busclk =
+		(get_au1000_speed() / (int)(inl(PM_POWERUP_CONTROL)&0x03) + 2);
+	return sys_busclk / (2 * (clkdiv + 1));
+}
+
+
+/*
+ * This is a bottom-half handler that is scheduled after
+ * raw X,Y,Z1,Z2 coordinates have been acquired, and does
+ * the following:
+ *
+ *   - computes touch screen pressure resistance
+ *   - if pressure is above a threshold considered to be pen-down:
+ *         - compute calibrated X and Y coordinates
+ *         - queue a new TS_EVENT
+ *         - signal asynchronously and wake up any read
+ */
+static void
+chug_raw_data(void* private)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)private;
+	TS_EVENT event;
+	int Rt, Xcal, Ycal;
+	unsigned long flags;
+
+	// timestamp this new event.
+	event.millisecs = jiffies;
+
+	// Calculate touch pressure resistance
+	if (ts->pressure_eqn == PRESSURE_EQN_2) {
+		Rt = (ts->x_plate_ohms * ts->x_raw *
+		      (4096 - ts->z1_raw)) / ts->z1_raw;
+		Rt -= (ts->y_plate_ohms * ts->y_raw);
+		Rt = (Rt + 2048) >> 12; // round up to nearest ohm
+	} else {
+		Rt = (ts->x_plate_ohms * ts->x_raw *
+		      (ts->z2_raw - ts->z1_raw)) / ts->z1_raw;
+		Rt = (Rt + 2048) >> 12; // round up to nearest ohm
+	}
+
+	// hysteresis
+	if (!ts->pendown && Rt > ts->pendown_thresh_ohms)
+		ts->pendown = 1;
+	else if (ts->pendown && Rt < ts->penup_thresh_ohms)
+		ts->pendown = 0;
+
+	if (ts->pendown) {
+		// Pen is down
+		// Calculate calibrated X,Y
+		Xcal = ((ts->cal.xscale * ts->x_raw) >> 8) + ts->cal.xtrans;
+		Ycal = ((ts->cal.yscale * ts->y_raw) >> 8) + ts->cal.ytrans;
+
+		event.x = (unsigned short)Xcal;
+		event.y = (unsigned short)Ycal;
+		event.pressure = (unsigned short)Rt;
+
+		// add this event to the event queue
+		spin_lock_irqsave(&ts->lock, flags);
+		ts->event_buf[ts->nextIn++] = event;
+		if (ts->nextIn == EVENT_BUFSIZE)
+			ts->nextIn = 0;
+		if (ts->event_count < EVENT_BUFSIZE) {
+			ts->event_count++;
+		} else {
+			// throw out the oldest event
+			if (++ts->nextOut == EVENT_BUFSIZE)
+				ts->nextOut = 0;
+		}
+		spin_unlock_irqrestore(&ts->lock, flags);
+
+		// async notify
+		if (ts->fasync)
+			kill_fasync(&ts->fasync, SIGIO, POLL_IN);
+		// wake up any read call
+		if (waitqueue_active(&ts->wait))
+			wake_up_interruptible(&ts->wait);
+	}
+}
+
+
+/*
+ * Raw X,Y,pressure acquisition timer function. This triggers
+ * the start of a new acquisition. Its duration between calls
+ * is the touch screen polling rate.
+ */
+static void
+au1000_acq_timer(unsigned long data)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	// start acquisition with X coordinate
+	ts->acq_state = ACQ_X;
+	// start me up
+	outl(SSIADAT_D | (MEASURE_12BIT_X << SSIADAT_ADDR_BIT), SSI0_ADATA);
+
+	// schedule next acquire
+	ts->acq_timer.expires = jiffies + HZ / 100;
+	add_timer(&ts->acq_timer);
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+}
+
+static void
+ssi0_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	au1000_ts_t *ts = (au1000_ts_t*)dev_id;
+	u32 stat, int_stat, data;
+
+	spin_lock(&ts->lock);
+
+	stat = inl(SSI0_STATUS);
+	// clear sticky status bits
+	outl(stat & (SSISTAT_OF|SSISTAT_UF|SSISTAT_DONE), SSI0_STATUS);
+
+	int_stat = inl(SSI0_INT);
+	// clear sticky intr status bits
+	outl(int_stat & (SSIINT_OI|SSIINT_UI|SSIINT_DI), SSI0_INT);
+
+	if ((int_stat & (SSIINT_OI|SSIINT_UI|SSIINT_DI)) != SSIINT_DI) {
+		if (int_stat & SSIINT_OI)
+			err("overflow");
+		if (int_stat & SSIINT_UI)
+			err("underflow");
+		spin_unlock(&ts->lock);
+		return;
+	}
+
+	data = inl(SSI0_ADATA) & SSIADAT_DATA_MASK;
+
+	switch (ts->acq_state) {
+	case IDLE:
+		break;
+	case ACQ_X:
+		ts->x_raw = data;
+		ts->acq_state = ACQ_Y;
+		// trigger Y acq
+		outl(SSIADAT_D | (MEASURE_12BIT_Y << SSIADAT_ADDR_BIT),
+		     SSI0_ADATA);
+		break;
+	case ACQ_Y:
+		ts->y_raw = data;
+		ts->acq_state = ACQ_Z1;
+		// trigger Z1 acq
+		outl(SSIADAT_D | (MEASURE_12BIT_Z1 << SSIADAT_ADDR_BIT),
+		     SSI0_ADATA);
+		break;
+	case ACQ_Z1:
+		ts->z1_raw = data;
+		if (ts->pressure_eqn == PRESSURE_EQN_2) {
+			// don't acq Z2, using 2nd eqn for touch pressure
+			ts->acq_state = IDLE;
+			// got the raw stuff, now mark BH
+			queue_task(&ts->chug_tq, &tq_immediate);
+			mark_bh(IMMEDIATE_BH);
+		} else {
+			ts->acq_state = ACQ_Z2;
+			// trigger Z2 acq
+			outl(SSIADAT_D | (MEASURE_12BIT_Z2<<SSIADAT_ADDR_BIT),
+			     SSI0_ADATA);
+		}
+		break;
+	case ACQ_Z2:
+		ts->z2_raw = data;
+		ts->acq_state = IDLE;
+		// got the raw stuff, now mark BH
+		queue_task(&ts->chug_tq, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+		break;
+	}
+
+	spin_unlock(&ts->lock);
+}
+
+
+/* +++++++++++++ File operations ++++++++++++++*/
+
+static int
+au1000_fasync(int fd, struct file *filp, int mode)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	return fasync_helper(fd, filp, mode, &ts->fasync);
+}
+
+static int
+au1000_ioctl(struct inode * inode, struct file *filp,
+	     unsigned int cmd, unsigned long arg)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+
+	switch(cmd) {
+	case TS_GET_RATE:       /* TODO: what is this? */
+		break;
+	case TS_SET_RATE:       /* TODO: what is this? */
+		break;
+	case TS_GET_CAL:
+		copy_to_user((char *)arg, (char *)&ts->cal, sizeof(TS_CAL));
+		break;
+	case TS_SET_CAL:
+		copy_from_user((char *)&ts->cal, (char *)arg, sizeof(TS_CAL));
+		break;
+	default:
+		err("unknown cmd %04x", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int
+au1000_poll(struct file * filp, poll_table * wait)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	poll_wait(filp, &ts->wait, wait);
+	if (ts->event_count)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t
+au1000_read(struct file * filp, char * buf, size_t count, loff_t * l)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	unsigned long flags;
+	TS_EVENT event;
+	int i;
+
+	if (ts->event_count == 0) {
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		interruptible_sleep_on(&ts->wait);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
+
+	for (i = count;
+	     i >= sizeof(TS_EVENT);
+	     i -= sizeof(TS_EVENT), buf += sizeof(TS_EVENT)) {
+		if (ts->event_count == 0)
+			break;
+		spin_lock_irqsave(&ts->lock, flags);
+		event = ts->event_buf[ts->nextOut++];
+		if (ts->nextOut == EVENT_BUFSIZE)
+			ts->nextOut = 0;
+		if (ts->event_count)
+			ts->event_count--;
+		spin_unlock_irqrestore(&ts->lock, flags);
+		copy_to_user(buf, &event, sizeof(TS_EVENT));
+	}
+
+	return count - i;
+}
+
+
+static int
+au1000_open(struct inode * inode, struct file * filp)
+{
+	au1000_ts_t* ts;
+	unsigned long flags;
+
+	filp->private_data = ts = &au1000_ts;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	// setup SSI0 config
+	outl(DEFAULT_SSI_CONFIG, SSI0_CONFIG);
+
+	// clear out SSI0 status bits
+	outl(SSISTAT_OF|SSISTAT_UF|SSISTAT_DONE, SSI0_STATUS);
+	// clear out SSI0 interrupt pending bits
+	outl(SSIINT_OI|SSIINT_UI|SSIINT_DI, SSI0_INT);
+
+	// enable SSI0 interrupts
+	outl(SSIINT_OI|SSIINT_UI|SSIINT_DI, SSI0_INT_ENABLE);
+
+	/*
+	 * init bh handler that chugs the raw data (calibrates and
+	 * calculates touch pressure).
+	 */
+	ts->chug_tq.routine = chug_raw_data;
+	ts->chug_tq.data = ts;
+	ts->pendown = 0; // pen up
+	
+	// flush event queue
+	ts->nextIn = ts->nextOut = ts->event_count = 0;
+	
+	// Start acquisition timer function
+	init_timer(&ts->acq_timer);
+	ts->acq_timer.function = au1000_acq_timer;
+	ts->acq_timer.data = (unsigned long)ts;
+	ts->acq_timer.expires = jiffies + HZ / 100;
+	add_timer(&ts->acq_timer);
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return 0;
+}
+
+static int
+au1000_release(struct inode * inode, struct file * filp)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	unsigned long flags;
+	
+	au1000_fasync(-1, filp, 0);
+	del_timer_sync(&ts->acq_timer);
+
+	spin_lock_irqsave(&ts->lock, flags);
+	// disable SSI0 interrupts
+	outl(0, SSI0_INT_ENABLE);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return 0;
+}
+
+
+static struct file_operations ts_fops = {
+	.read           = au1000_read,
+	.poll           = au1000_poll,
+	.ioctl		= au1000_ioctl,
+	.fasync         = au1000_fasync,
+	.open		= au1000_open,
+	.release	= au1000_release,
+};
+
+/* +++++++++++++ End File operations ++++++++++++++*/
+
+
+int __init
+au1000ts_init_module(void)
+{
+	au1000_ts_t* ts = &au1000_ts;
+	int ret;
+
+	/* register our character device */
+	if ((ret = register_chrdev(TS_MAJOR, TS_NAME, &ts_fops)) < 0) {
+		err("can't get major number");
+		return ret;
+	}
+	info("registered");
+
+	memset(ts, 0, sizeof(au1000_ts_t));
+	init_waitqueue_head(&ts->wait);
+	spin_lock_init(&ts->lock);
+
+	if (!request_region(virt_to_phys((void*)SSI0_STATUS), 0x100, TS_NAME)) {
+		err("SSI0 ports in use");
+		return -ENXIO;
+	}
+
+	if ((ret = request_irq(AU1000_SSI0_INT, ssi0_interrupt,
+			       SA_SHIRQ | SA_INTERRUPT, TS_NAME, ts))) {
+		err("could not get IRQ");
+		return ret;
+	}
+
+	// initial calibration values
+	ts->cal.xscale = -93;
+	ts->cal.xtrans = 346;
+	ts->cal.yscale = -64;
+	ts->cal.ytrans = 251;
+
+	// init pen up/down hysteresis points
+	ts->pendown_thresh_ohms = DEFAULT_PENDOWN_THRESH_OHMS;
+	ts->penup_thresh_ohms = DEFAULT_PENUP_THRESH_OHMS;
+	ts->pressure_eqn = PRESSURE_EQN_2;
+	// init X and Y plate resistances
+	ts->x_plate_ohms = DEFAULT_X_PLATE_OHMS;
+	ts->y_plate_ohms = DEFAULT_Y_PLATE_OHMS;
+
+	// set GPIO to SSI0 function
+	outl(inl(PIN_FUNCTION) & ~1, PIN_FUNCTION);
+	
+	// enable SSI0 clock and bring SSI0 out of reset
+	outl(0, SSI0_CONTROL);
+	udelay(1000);
+	outl(SSIEN_E, SSI0_CONTROL);
+	udelay(100);
+	
+	// FIXME: is this a working baudrate?
+	ts->clkdiv = 0;
+	ts->baudrate = calc_baudrate(ts->clkdiv);
+	outl(ts->clkdiv, SSI0_CLKDIV);
+
+	info("baudrate = %d Hz", ts->baudrate);
+	
+	return 0;
+}
+
+void
+au1000ts_cleanup_module(void)
+{
+	// disable clocks and hold in reset
+	outl(SSIEN_CD, SSI0_CONTROL);
+	free_irq(AU1000_SSI0_INT, &au1000_ts);
+	release_region(virt_to_phys((void*)SSI0_STATUS), 0x100);
+	unregister_chrdev(TS_MAJOR, TS_NAME);
+}
+
+/* Module information */
+MODULE_AUTHOR("Steve Longerbeam, stevel@mvista.com, www.mvista.com");
+MODULE_DESCRIPTION("Au1000/ADS7846 Touch Screen Driver");
+
+module_init(au1000ts_init_module);
+module_exit(au1000ts_cleanup_module);
diff -Naur linux-2.6.14/drivers/char/au1000_usbraw.c linux-mips-2.6.14.orig/drivers/char/au1000_usbraw.c
--- linux-2.6.14/drivers/char/au1000_usbraw.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/char/au1000_usbraw.c	2005-11-17 11:42:45.000000000 -0800
@@ -0,0 +1,573 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1x00 USB Device-Side Raw Block Driver (function layer)
+ *
+ * Copyright 2001-2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#undef DEBUG
+#include <linux/usb.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1000_usbdev.h>
+
+#define USBRAW_MAJOR 190 // FIXME: need a legal major
+#define USBRAW_NAME "usbraw"
+
+#define MAX_NUM_PORTS 2
+
+#define IN_MAX_PACKET_SIZE  64
+#define OUT_MAX_PACKET_SIZE 64
+
+// FIXME: when Au1x00 endpoints 3 and 5 are fixed, make NUM_PORTS=2
+#define NUM_PORTS 1
+#define NUM_EP 2*NUM_PORTS
+
+#define CONFIG_DESC_LEN \
+ USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE + NUM_EP*USB_DT_ENDPOINT_SIZE
+
+/* must be power of two */
+#define READ_BUF_SIZE (1<<12)
+
+struct usb_raw_port {
+	unsigned char number;
+	spinlock_t port_lock;
+
+	struct usb_endpoint_descriptor* out_desc;
+	struct usb_endpoint_descriptor* in_desc;
+
+	int out_ep_addr; /* endpoint address of OUT endpoint */
+	int in_ep_addr;  /* endpoint address of IN endpoint */
+	
+	__u8 read_buf[READ_BUF_SIZE]; // FIXME: allocate with get_free_pages
+	int read_nextin, read_nextout;
+	int read_count;
+
+	wait_queue_head_t wait;
+	struct fasync_struct *fasync;     // asynch notification
+
+	int active;	/* someone has this device open */
+	int open_count;	/* number of times this port has been opened */
+};
+
+static struct usb_serial {
+	struct usb_device_descriptor* dev_desc;
+	struct usb_config_descriptor* config_desc;
+	struct usb_interface_descriptor* if_desc;
+	struct usb_string_descriptor * str_desc[6];
+	void* str_desc_buf;
+
+	usbdev_state_t dev_state;
+
+	struct usb_raw_port port[NUM_PORTS];
+} usbraw;
+
+static struct usb_device_descriptor dev_desc = {
+	bLength:USB_DT_DEVICE_SIZE,
+	bDescriptorType:USB_DT_DEVICE,
+	bcdUSB:USBDEV_REV,		//usb rev
+	bDeviceClass:USB_CLASS_PER_INTERFACE,	//class    (none)
+	bDeviceSubClass:0x00,	//subclass (none)
+	bDeviceProtocol:0x00,	//protocol (none)
+	bMaxPacketSize0:USBDEV_EP0_MAX_PACKET_SIZE, //max packet size for ep0
+	idVendor:0x6d04,	//vendor  id
+	idProduct:0x0bc0,	//product id
+	bcdDevice:0x0001,	//BCD rev 0.1
+	iManufacturer:0x01,	//manufactuer string index
+	iProduct:0x02,		//product string index
+	iSerialNumber:0x03,	//serial# string index
+	bNumConfigurations:0x01	//num configurations
+};
+
+static struct usb_endpoint_descriptor ep_desc[] = {
+	{
+		// Bulk IN for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk IN for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	}
+};
+
+static struct usb_interface_descriptor if_desc = {
+	bLength:USB_DT_INTERFACE_SIZE,
+	bDescriptorType:USB_DT_INTERFACE,
+	bInterfaceNumber:0x00,
+	bAlternateSetting:0x00,
+	bNumEndpoints:NUM_EP,
+	bInterfaceClass:0xff,
+	bInterfaceSubClass:0xab,
+	bInterfaceProtocol:0x00,
+	iInterface:0x05
+};
+
+static struct usb_config_descriptor config_desc = {
+	bLength:USB_DT_CONFIG_SIZE,
+	bDescriptorType:USB_DT_CONFIG,
+	wTotalLength:CONFIG_DESC_LEN,
+	bNumInterfaces:0x01,
+	bConfigurationValue:0x01,
+	iConfiguration:0x04,	// configuration string
+	bmAttributes:0xc0,	// self-powered
+	MaxPower:20		// 40 mA
+};
+
+// String[0] is a list of Language IDs supported by this device
+static struct usb_string_descriptor string_desc0 = {
+	bLength:4,
+	bDescriptorType:USB_DT_STRING,
+	wData:{0x0409} // English, US
+};
+
+// These strings will be converted to Unicode in string_desc[]
+static char *strings[5] = {
+	"Alchemy Semiconductor",  // iManufacturer
+	"USB Raw Block Device",   // iProduct
+	"0.1",                    // iSerialNumber
+	"USB Raw Config",         // iConfiguration
+	"USB Raw Interface"       // iInterface
+};
+
+
+static void
+receive_callback(struct usb_raw_port *port)
+{
+	int i, pkt_size;
+	usbdev_pkt_t* pkt;
+	
+	if ((pkt_size = usbdev_receive_packet(port->out_ep_addr,
+					      &pkt)) <= 0) {
+		dbg(__FUNCTION__ ": usbdev_receive_packet returns %d",
+		    pkt_size);
+		return;
+	}
+
+	dbg(__FUNCTION__ ": ep%d, size=%d", port->out_ep_addr, pkt_size);
+
+	spin_lock(&port->port_lock);
+	for (i=0; i < pkt_size; i++) {
+		port->read_buf[port->read_nextin++] = pkt->payload[i];
+		port->read_nextin &= (READ_BUF_SIZE - 1);
+		if (++port->read_count == READ_BUF_SIZE)
+			break;
+	}
+	spin_unlock(&port->port_lock);
+
+	/* free the packet */
+	kfree(pkt);
+	
+	// async notify
+	if (port->fasync)
+		kill_fasync(&port->fasync, SIGIO, POLL_IN);
+	// wake up any read call
+	if (waitqueue_active(&port->wait))
+		wake_up_interruptible(&port->wait);
+}
+
+static void
+transmit_callback(struct usb_raw_port *port, usbdev_pkt_t* pkt)
+{
+	dbg(__FUNCTION__ ": ep%d", port->in_ep_addr);
+	/* just free the returned packet */
+	kfree(pkt);
+}
+
+
+static void
+usbraw_callback(usbdev_cb_type_t cb_type, unsigned long arg, void* data)
+{
+	usbdev_pkt_t* pkt;
+	int i;
+	
+	switch (cb_type) {
+	case CB_NEW_STATE:
+		usbraw.dev_state = (usbdev_state_t)arg;
+		break;
+	case CB_PKT_COMPLETE:
+		pkt = (usbdev_pkt_t*)arg;
+		for (i=0; i<NUM_PORTS; i++) {
+			struct usb_raw_port *port = &usbraw.port[i];
+			if (pkt->ep_addr == port->in_ep_addr) {
+				transmit_callback(port, pkt);
+				break;
+			} else if (pkt->ep_addr == port->out_ep_addr) {
+				receive_callback(port);
+				break;
+			}
+		}
+		break;
+	}
+}
+
+/*****************************************************************************
+ * Here begins the driver interface functions
+ *****************************************************************************/
+
+static unsigned int usbraw_poll(struct file * filp, poll_table * wait)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	unsigned long flags;
+	int count;
+	
+	poll_wait(filp, &port->wait, wait);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	count = port->read_count;
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	if (count > 0) {
+		dbg(__FUNCTION__ ": count=%d", count);
+		return POLLIN | POLLRDNORM;
+	}
+	
+	return 0;
+}
+
+static int usbraw_fasync(int fd, struct file *filp, int mode)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	return fasync_helper(fd, filp, mode, &port->fasync);
+}
+
+static int usbraw_open(struct inode * inode, struct file *filp)
+{
+	int portNumber;
+	struct usb_raw_port *port;
+	unsigned long flags;
+
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbraw.dev_state != CONFIGURED)
+		return -ENODEV;
+	
+	/* set up our port structure making the tty driver remember
+	   our port object, and us it */
+	portNumber = MINOR(inode->i_rdev);
+	port = &usbraw.port[portNumber];
+	filp->private_data = port;
+
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	++port->open_count;
+
+	if (!port->active) {
+		port->active = 1;
+	}
+
+	/* flush read buffer */
+	port->read_nextin = port->read_nextout = port->read_count = 0;
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+}
+
+static int usbraw_release(struct inode * inode, struct file * filp)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	unsigned long flags;
+
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not opened");
+		return -ENODEV;
+	}
+
+	usbraw_fasync(-1, filp, 0);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	--port->open_count;
+
+	if (port->open_count <= 0) {
+		port->active = 0;
+		port->open_count = 0;
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+}
+
+
+static ssize_t usbraw_read(struct file * filp, char * buf,
+			   size_t count, loff_t * l)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	unsigned long flags;
+	int i, cnt;
+
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbraw.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	do { 
+		spin_lock_irqsave(&port->port_lock, flags);
+		cnt = port->read_count;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		if (cnt == 0) {
+			if (filp->f_flags & O_NONBLOCK)
+				return -EAGAIN;
+			interruptible_sleep_on(&port->wait);
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		}
+	} while (cnt == 0);
+
+	count = (count > cnt) ? cnt : count;
+
+	for (i=0; i<count; i++) {
+		put_user(port->read_buf[port->read_nextout++], &buf[i]);
+		port->read_nextout &= (READ_BUF_SIZE - 1);
+		spin_lock_irqsave(&port->port_lock, flags);
+		port->read_count--;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		if (port->read_count == 0)
+			break;
+	}
+
+	return i+1;
+}
+
+static ssize_t usbraw_write(struct file * filp, const char * buf,
+			    size_t count, loff_t *ppos)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	usbdev_pkt_t* pkt;
+	int ret, max_pkt_sz;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbraw.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not opened");
+		return -EINVAL;
+	}
+
+	if (count == 0) {
+		dbg(__FUNCTION__ ": write request of 0 bytes");
+		return (0);
+	}
+
+	max_pkt_sz = port->in_desc->wMaxPacketSize;
+	count = (count > max_pkt_sz) ? max_pkt_sz : count;
+
+	if ((ret = usbdev_alloc_packet(port->in_ep_addr, count, &pkt)) < 0)
+		return ret;
+
+	copy_from_user(pkt->payload, buf, count);
+	
+	return usbdev_send_packet(port->in_ep_addr, pkt);
+}
+
+static int usbraw_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -ENODEV;
+	}
+	// FIXME: need any IOCTLs?
+
+	return -ENOIOCTLCMD;
+}
+
+
+static struct file_operations usbraw_fops = {
+        .owner          = THIS_MODULE,
+        .write          = usbraw_write,
+	.read           = usbraw_read,
+	.poll           = usbraw_poll,
+	.ioctl		= usbraw_ioctl,
+	.fasync         = usbraw_fasync,
+	.open		= usbraw_open,
+	.release	= usbraw_release,
+};
+
+void usbfn_raw_exit(void)
+{
+	/* kill the device layer */
+	usbdev_exit();
+
+	unregister_chrdev(USBRAW_MAJOR, USBRAW_NAME);
+
+	if (usbraw.str_desc_buf)
+		kfree(usbraw.str_desc_buf);
+}
+
+
+int usbfn_raw_init(void)
+{
+	int ret = 0, i, str_desc_len;
+
+	/* register our character device */
+	if ((ret = register_chrdev(USBRAW_MAJOR, USBRAW_NAME,
+				   &usbraw_fops)) < 0) {
+		err("can't get major number");
+		return ret;
+	}
+	info("registered");
+
+	/*
+	 * initialize pointers to descriptors
+	 */
+	usbraw.dev_desc = &dev_desc;
+	usbraw.config_desc = &config_desc;
+	usbraw.if_desc = &if_desc;
+
+	/*
+	 * initialize the string descriptors
+	 */
+
+	/* alloc buffer big enough for all string descriptors */
+	str_desc_len = string_desc0.bLength;
+	for (i = 0; i < 5; i++)
+		str_desc_len += 2 + 2 * strlen(strings[i]);
+	usbraw.str_desc_buf = (void *) kmalloc(str_desc_len, GFP_KERNEL);
+	if (!usbraw.str_desc_buf) {
+		err(__FUNCTION__ ": failed to alloc string descriptors");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	usbraw.str_desc[0] =
+		(struct usb_string_descriptor *)usbraw.str_desc_buf;
+	memcpy(usbraw.str_desc[0], &string_desc0, string_desc0.bLength);
+	usbraw.str_desc[1] = (struct usb_string_descriptor *)
+		(usbraw.str_desc_buf + string_desc0.bLength);
+	for (i = 1; i < 6; i++) {
+		struct usb_string_descriptor *desc = usbraw.str_desc[i];
+		char *str = strings[i - 1];
+		int j, str_len = strlen(str);
+
+		desc->bLength = 2 + 2 * str_len;
+		desc->bDescriptorType = USB_DT_STRING;
+		for (j = 0; j < str_len; j++) {
+			desc->wData[j] = (u16) str[j];
+		}
+		if (i < 5)
+			usbraw.str_desc[i + 1] =
+				(struct usb_string_descriptor *)
+				((u8 *) desc + desc->bLength);
+	}
+
+	/*
+	 * start the device layer. The device layer assigns us
+	 * our endpoint addresses
+	 */
+	if ((ret = usbdev_init(&dev_desc, &config_desc, &if_desc, ep_desc,
+			       usbraw.str_desc, usbraw_callback, NULL))) {
+		err(__FUNCTION__ ": device-layer init failed");
+		goto out;
+	}
+	
+	/* initialize the devfs nodes for this device and let the user
+	   know what ports we are bound to */
+	for (i = 0; i < NUM_PORTS; ++i) {
+		struct usb_raw_port *port = &usbraw.port[i];
+
+		port->number = i;
+		port->in_desc = &ep_desc[NUM_PORTS*i];
+		port->out_desc = &ep_desc[NUM_PORTS*i + 1];
+		port->in_ep_addr = port->in_desc->bEndpointAddress & 0x0f;
+		port->out_ep_addr = port->out_desc->bEndpointAddress & 0x0f;
+		init_waitqueue_head(&port->wait);
+		spin_lock_init(&port->port_lock);
+	}
+
+ out:
+	if (ret)
+		usbfn_raw_exit();
+	return ret;
+}
+
+
+/* Module information */
+MODULE_AUTHOR("Steve Longerbeam, stevel@mvista.com, www.mvista.com");
+MODULE_DESCRIPTION("Au1x00 USB Device-Side Raw Block Driver");
+MODULE_LICENSE("GPL");
+
+module_init(usbfn_raw_init);
+module_exit(usbfn_raw_exit);
diff -Naur linux-2.6.14/drivers/char/au1000_usbtty.c linux-mips-2.6.14.orig/drivers/char/au1000_usbtty.c
--- linux-2.6.14/drivers/char/au1000_usbtty.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/char/au1000_usbtty.c	2005-11-17 11:42:45.000000000 -0800
@@ -0,0 +1,761 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1x00 USB Device-Side Serial TTY Driver (function layer)
+ *
+ * Copyright 2001-2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *  Derived from drivers/usb/serial/usbserial.c:
+ *
+ *  Copyright (C) 1999 - 2001 Greg Kroah-Hartman (greg@kroah.com)
+ *  Copyright (c) 2000 Peter Berger (pberger@brimson.com)
+ *  Copyright (c) 2000 Al Borchers (borchers@steinerpoint.com)
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#undef DEBUG
+#include <linux/usb.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1000_usbdev.h>
+
+
+/* local function prototypes */
+static int serial_open(struct tty_struct *tty, struct file *filp);
+static void serial_close(struct tty_struct *tty, struct file *filp);
+static int serial_write(struct tty_struct *tty, int from_user,
+			const unsigned char *buf, int count);
+static int serial_write_room(struct tty_struct *tty);
+static int serial_chars_in_buffer(struct tty_struct *tty);
+static void serial_throttle(struct tty_struct *tty);
+static void serial_unthrottle(struct tty_struct *tty);
+static int serial_ioctl(struct tty_struct *tty, struct file *file,
+			unsigned int cmd, unsigned long arg);
+static void serial_set_termios (struct tty_struct *tty, struct termios * old);
+
+#define SERIAL_TTY_MAJOR 189 // FIXME: need a legal major
+
+#define MAX_NUM_PORTS 2
+
+#define IN_MAX_PACKET_SIZE  32
+#define OUT_MAX_PACKET_SIZE 32
+
+// FIXME: when Au1x00 endpoints 3 and 5 are fixed, make NUM_PORTS=2
+#define NUM_PORTS 2
+#define NUM_EP 2*NUM_PORTS
+
+#define CONFIG_DESC_LEN \
+ USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE + NUM_EP*USB_DT_ENDPOINT_SIZE
+
+struct usb_serial_port {
+	struct tty_struct *tty;	   /* the coresponding tty for this port */
+	unsigned char number;
+	spinlock_t port_lock;
+
+	struct usb_endpoint_descriptor* out_desc;
+	struct usb_endpoint_descriptor* in_desc;
+
+	int out_ep_addr; /* endpoint address of OUT endpoint */
+	int in_ep_addr;  /* endpoint address of IN endpoint */
+	
+	/* task queue for line discipline waking up on send packet complete */
+	struct tq_struct send_complete_tq;
+	/* task queue for line discipline wakeup on receive packet complete */
+	struct tq_struct receive_complete_tq;
+
+	int active;	/* someone has this device open */
+	int writing;    /* a packet write is in progress */
+	int open_count;	/* number of times this port has been opened */
+
+};
+
+static struct usb_serial {
+	usbdev_state_t dev_state; // current state of device layer
+	struct usb_device_descriptor* dev_desc;
+	struct usb_config_descriptor* config_desc;
+	struct usb_interface_descriptor* if_desc;
+	struct usb_string_descriptor * str_desc[6];
+	void* str_desc_buf;
+
+	struct usb_serial_port port[NUM_PORTS];
+} usbtty;
+
+static int                 serial_refcount;
+static struct tty_driver   serial_tty_driver;
+static struct tty_struct * serial_tty[NUM_PORTS];
+static struct termios *    serial_termios[NUM_PORTS];
+static struct termios *    serial_termios_locked[NUM_PORTS];
+
+static struct usb_device_descriptor dev_desc = {
+	bLength:USB_DT_DEVICE_SIZE,
+	bDescriptorType:USB_DT_DEVICE,
+	bcdUSB:USBDEV_REV,		//usb rev
+	bDeviceClass:USB_CLASS_PER_INTERFACE,	//class    (none)
+	bDeviceSubClass:0x00,	//subclass (none)
+	bDeviceProtocol:0x00,	//protocol (none)
+	bMaxPacketSize0:USBDEV_EP0_MAX_PACKET_SIZE, //max packet size for ep0
+	idVendor:0x6d04,	//vendor  id
+	idProduct:0x0bc0,	//product id
+	bcdDevice:0x0001,	//BCD rev 0.1
+	iManufacturer:0x01,	//manufactuer string index
+	iProduct:0x02,		//product string index
+	iSerialNumber:0x03,	//serial# string index
+	bNumConfigurations:0x01	//num configurations
+};
+
+static struct usb_endpoint_descriptor ep_desc[] = {
+	{
+		// Bulk IN for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk IN for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	}
+};
+
+static struct usb_interface_descriptor if_desc = {
+	bLength:USB_DT_INTERFACE_SIZE,
+	bDescriptorType:USB_DT_INTERFACE,
+	bInterfaceNumber:0x00,
+	bAlternateSetting:0x00,
+	bNumEndpoints:NUM_EP,
+	bInterfaceClass:0xff,
+	bInterfaceSubClass:0xab,
+	bInterfaceProtocol:0x00,
+	iInterface:0x05
+};
+
+static struct usb_config_descriptor config_desc = {
+	bLength:USB_DT_CONFIG_SIZE,
+	bDescriptorType:USB_DT_CONFIG,
+	wTotalLength:CONFIG_DESC_LEN,
+	bNumInterfaces:0x01,
+	bConfigurationValue:0x01,
+	iConfiguration:0x04,	// configuration string
+	bmAttributes:0xc0,	// self-powered
+	MaxPower:20		// 40 mA
+};
+
+// String[0] is a list of Language IDs supported by this device
+static struct usb_string_descriptor string_desc0 = {
+	bLength:4,
+	bDescriptorType:USB_DT_STRING,
+	wData:{0x0409} // English, US
+};
+
+// These strings will be converted to Unicode in string_desc[]
+static char *strings[5] = {
+	"Alchemy Semiconductor",  // iManufacturer
+	"WutzAMattaU",            // iProduct
+	"1.0.doh!",               // iSerialNumber
+	"Au1000 TTY Config",      // iConfiguration
+	"Au1000 TTY Interface"    // iInterface
+};
+
+static inline int
+port_paranoia_check(struct usb_serial_port *port, const char *function)
+{
+	if (!port) {
+		err("%s: port is NULL", function);
+		return -1;
+	}
+	if (!port->tty) {
+		err("%s: port->tty is NULL", function);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static void
+port_rx_callback(struct usb_serial_port *port)
+{
+	dbg(__FUNCTION__ ": ep%d", port->out_ep_addr);
+	// mark a bh to push this data up to the tty
+	queue_task(&port->receive_complete_tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static void
+port_tx_callback(struct usb_serial_port *port, usbdev_pkt_t* pkt)
+{
+	dbg(__FUNCTION__ ": ep%d", port->in_ep_addr);
+	// mark a bh to wakeup any tty write system call on the port.
+	queue_task(&port->send_complete_tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+
+	/* free the returned packet */
+	kfree(pkt);
+}
+
+static void
+usbtty_callback(usbdev_cb_type_t cb_type, unsigned long arg, void* data)
+{
+	usbdev_pkt_t* pkt;
+	int i;
+	
+	switch (cb_type) {
+	case CB_NEW_STATE:
+		dbg(__FUNCTION__ ": new dev_state=%d", (int)arg);
+		usbtty.dev_state = (usbdev_state_t)arg;
+		break;
+	case CB_PKT_COMPLETE:
+		pkt = (usbdev_pkt_t*)arg;
+		for (i=0; i<NUM_PORTS; i++) {
+			struct usb_serial_port *port = &usbtty.port[i];
+			if (pkt->ep_addr == port->in_ep_addr) {
+				port_tx_callback(port, pkt);
+				break;
+			} else if (pkt->ep_addr == port->out_ep_addr) {
+				port_rx_callback(port);
+				break;
+			}
+		}
+		break;
+	}
+}
+
+
+/*****************************************************************************
+ * Here begins the tty driver interface functions
+ *****************************************************************************/
+
+static int serial_open(struct tty_struct *tty, struct file *filp)
+{
+	int portNumber;
+	struct usb_serial_port *port;
+	unsigned long flags;
+
+	/* initialize the pointer incase something fails */
+	tty->driver_data = NULL;
+
+	/* set up our port structure making the tty driver remember
+	   our port object, and us it */
+	portNumber = MINOR(tty->device);
+	port = &usbtty.port[portNumber];
+	tty->driver_data = port;
+	port->tty = tty;
+
+	if (usbtty.dev_state != CONFIGURED ||
+	    port_paranoia_check(port, __FUNCTION__)) {
+		/*
+		 * the device-layer must be in the configured state before
+		 * the function layer can operate.
+		 */
+		return -ENODEV;
+	}
+	
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	++port->open_count;
+
+	if (!port->active) {
+		port->active = 1;
+
+		/*
+		 * force low_latency on so that our tty_push actually forces
+		 * the data through, otherwise it is scheduled, and with high
+		 * data rates (like with OHCI) data can get lost.
+		 */
+		port->tty->low_latency = 1;
+
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+}
+
+
+static void serial_close(struct tty_struct *tty, struct file *filp)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	unsigned long flags;
+
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not opened");
+		return;
+	}
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	--port->open_count;
+
+	if (port->open_count <= 0) {
+		port->active = 0;
+		port->open_count = 0;
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+	MOD_DEC_USE_COUNT;
+}
+
+
+static int serial_write(struct tty_struct *tty, int from_user,
+			const unsigned char *buf, int count)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	usbdev_pkt_t* pkt;
+	int max_pkt_sz, ret;
+	unsigned long flags;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbtty.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -EINVAL;
+	}
+
+	if (count == 0) {
+		dbg(__FUNCTION__ ": request of 0 bytes");
+		return (0);
+	}
+
+#if 0
+	if (port->writing) {
+		dbg(__FUNCTION__ ": already writing");
+		return 0;
+	}
+#endif
+	
+	max_pkt_sz = port->in_desc->wMaxPacketSize;
+	count = (count > max_pkt_sz) ? max_pkt_sz : count;
+
+	if ((ret = usbdev_alloc_packet(port->in_ep_addr, count, &pkt)))
+		return ret;
+
+	if (from_user)
+		copy_from_user(pkt->payload, buf, count);
+	else
+		memcpy(pkt->payload, buf, count);
+	
+	ret = usbdev_send_packet(port->in_ep_addr, pkt);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	port->writing = 1;
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return ret;
+}
+
+
+static int serial_write_room(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	int room = 0;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbtty.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -EINVAL;
+	}
+
+	//room = port->writing ? 0 : port->in_desc->wMaxPacketSize;
+	room = port->in_desc->wMaxPacketSize;
+	
+	dbg(__FUNCTION__ ": %d", room);
+	return room;
+}
+
+
+static int serial_chars_in_buffer(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	int chars = 0;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbtty.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -EINVAL;
+	}
+
+	//chars = port->writing ? usbdev_get_byte_count(port->in_ep_addr) : 0;
+	chars = usbdev_get_byte_count(port->in_ep_addr);
+
+	dbg(__FUNCTION__ ": %d", chars);
+	return chars;
+}
+
+
+static void serial_throttle(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED) {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	// FIXME: anything to do?
+	dbg(__FUNCTION__);
+}
+
+
+static void serial_unthrottle(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED) {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	// FIXME: anything to do?
+	dbg(__FUNCTION__);
+}
+
+
+static int serial_ioctl(struct tty_struct *tty, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -ENODEV;
+	}
+	// FIXME: need any IOCTLs?
+	dbg(__FUNCTION__);
+
+	return -ENOIOCTLCMD;
+}
+
+
+static void serial_set_termios(struct tty_struct *tty, struct termios *old)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED)  {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	dbg(__FUNCTION__);
+	// FIXME: anything to do?
+}
+
+
+static void serial_break(struct tty_struct *tty, int break_state)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED)  {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	dbg(__FUNCTION__);
+	// FIXME: anything to do?
+}
+
+
+static void port_send_complete(void *private)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) private;
+	struct tty_struct *tty;
+	unsigned long flags;
+
+	dbg(__FUNCTION__ ": port %d, ep%d", port->number, port->in_ep_addr);
+
+	tty = port->tty;
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup) {
+		dbg(__FUNCTION__ ": write wakeup call.");
+		(tty->ldisc.write_wakeup) (tty);
+	}
+
+	wake_up_interruptible(&tty->write_wait);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	port->writing = usbdev_get_byte_count(port->in_ep_addr) <= 0 ? 0 : 1;
+	spin_unlock_irqrestore(&port->port_lock, flags);
+}
+
+
+static void port_receive_complete(void *private)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) private;
+	struct tty_struct *tty = port->tty;
+	usbdev_pkt_t* pkt = NULL;
+	int i, count;
+
+	/* while there is a packet available */
+	while ((count = usbdev_receive_packet(port->out_ep_addr,
+					      &pkt)) != -ENODATA) {
+		if (count < 0) {
+			if (pkt)
+				kfree(pkt);
+			break; /* exit if error other than ENODATA */
+		}
+		
+		dbg(__FUNCTION__ ": port %d, ep%d, size=%d",
+		    port->number, port->out_ep_addr, count);
+
+		for (i = 0; i < count; i++) {
+			/* if we insert more than TTY_FLIPBUF_SIZE characters,
+			   we drop them. */
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				tty_flip_buffer_push(tty);
+			}
+			/* this doesn't actually push the data through
+			   unless tty->low_latency is set */
+			tty_insert_flip_char(tty, pkt->payload[i], 0);
+		}
+		tty_flip_buffer_push(tty);
+
+		kfree(pkt); /* make sure we free the packet */
+	}
+
+}
+
+
+static struct tty_driver serial_tty_driver = {
+	.magic= TTY_DRIVER_MAGIC,
+	.driver_name= "usbfn-tty",
+	.name= "usb/ttsdev/%d",
+	.major= SERIAL_TTY_MAJOR,
+	.minor_start= 0,
+	.num= NUM_PORTS,
+	.type= TTY_DRIVER_TYPE_SERIAL,
+	.subtype= SERIAL_TYPE_NORMAL,
+	.flags= TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
+	.refcount= &serial_refcount,
+	.table= serial_tty,
+	.termios= serial_termios,
+	.termios_locked= serial_termios_locked,
+
+	.open= serial_open,
+	.close= serial_close,
+	.write= serial_write,
+	.write_room= serial_write_room,
+	.ioctl= serial_ioctl,
+	.set_termios= serial_set_termios,
+	.throttle= serial_throttle,
+	.unthrottle= serial_unthrottle,
+	.break_ctl= serial_break,
+	.chars_in_buffer= serial_chars_in_buffer,
+};
+
+
+void usbfn_tty_exit(void)
+{
+	int i;
+	
+	/* kill the device layer */
+	usbdev_exit();
+
+	for (i=0; i < NUM_PORTS; i++) {
+		tty_unregister_devfs(&serial_tty_driver, i);
+		info("usb serial converter now disconnected from ttyUSBdev%d",
+		     i);
+	}
+
+	tty_unregister_driver(&serial_tty_driver);
+
+	if (usbtty.str_desc_buf)
+		kfree(usbtty.str_desc_buf);
+}
+
+
+int usbfn_tty_init(void)
+{
+	int ret = 0, i, str_desc_len;
+
+	/* register the tty driver */
+	serial_tty_driver.init_termios = tty_std_termios;
+	serial_tty_driver.init_termios.c_cflag =
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	
+	if (tty_register_driver(&serial_tty_driver)) {
+		err(__FUNCTION__ ": failed to register tty driver");
+		ret = -ENXIO;
+		goto out;
+	}
+
+	/*
+	 * initialize pointers to descriptors
+	 */
+	usbtty.dev_desc = &dev_desc;
+	usbtty.config_desc = &config_desc;
+	usbtty.if_desc = &if_desc;
+
+	/*
+	 * initialize the string descriptors
+	 */
+
+	/* alloc buffer big enough for all string descriptors */
+	str_desc_len = string_desc0.bLength;
+	for (i = 0; i < 5; i++)
+		str_desc_len += 2 + 2 * strlen(strings[i]);
+	usbtty.str_desc_buf = (void *) kmalloc(str_desc_len, GFP_KERNEL);
+	if (!usbtty.str_desc_buf) {
+		err(__FUNCTION__ ": failed to alloc string descriptors");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	usbtty.str_desc[0] =
+		(struct usb_string_descriptor *)usbtty.str_desc_buf;
+	memcpy(usbtty.str_desc[0], &string_desc0, string_desc0.bLength);
+	usbtty.str_desc[1] = (struct usb_string_descriptor *)
+		(usbtty.str_desc_buf + string_desc0.bLength);
+	for (i = 1; i < 6; i++) {
+		struct usb_string_descriptor *desc = usbtty.str_desc[i];
+		char *str = strings[i - 1];
+		int j, str_len = strlen(str);
+
+		desc->bLength = 2 + 2 * str_len;
+		desc->bDescriptorType = USB_DT_STRING;
+		for (j = 0; j < str_len; j++) {
+			desc->wData[j] = (u16) str[j];
+		}
+		if (i < 5)
+			usbtty.str_desc[i + 1] =
+				(struct usb_string_descriptor *)
+				((u8 *) desc + desc->bLength);
+	}
+
+	/*
+	 * start the device layer. The device layer assigns us
+	 * our endpoint addresses
+	 */
+	if ((ret = usbdev_init(&dev_desc, &config_desc, &if_desc, ep_desc,
+			       usbtty.str_desc, usbtty_callback, NULL))) {
+		err(__FUNCTION__ ": device-layer init failed");
+		goto out;
+	}
+	
+	/* initialize the devfs nodes for this device and let the user
+	   know what ports we are bound to */
+	for (i = 0; i < NUM_PORTS; ++i) {
+		struct usb_serial_port *port;
+		tty_register_devfs(&serial_tty_driver, 0, i);
+		info("usbdev serial attached to ttyUSBdev%d "
+		     "(or devfs usb/ttsdev/%d)", i, i);
+		port = &usbtty.port[i];
+		port->number = i;
+		port->in_desc = &ep_desc[NUM_PORTS*i];
+		port->out_desc = &ep_desc[NUM_PORTS*i + 1];
+		port->in_ep_addr = port->in_desc->bEndpointAddress & 0x0f;
+		port->out_ep_addr = port->out_desc->bEndpointAddress & 0x0f;
+		port->send_complete_tq.routine = port_send_complete;
+		port->send_complete_tq.data = port;
+		port->receive_complete_tq.routine = port_receive_complete;
+		port->receive_complete_tq.data = port;
+		spin_lock_init(&port->port_lock);
+	}
+
+ out:
+	if (ret)
+		usbfn_tty_exit();
+	return ret;
+}
+
+
+/* Module information */
+MODULE_AUTHOR("Steve Longerbeam, stevel@mvista.com, www.mvista.com");
+MODULE_DESCRIPTION("Au1x00 USB Device-Side Serial TTY Driver");
+MODULE_LICENSE("GPL");
+
+module_init(usbfn_tty_init);
+module_exit(usbfn_tty_exit);
diff -Naur linux-2.6.14/drivers/char/decserial.c linux-mips-2.6.14.orig/drivers/char/decserial.c
--- linux-2.6.14/drivers/char/decserial.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/decserial.c	2005-11-17 11:42:45.000000000 -0800
@@ -14,87 +14,85 @@
  *      device. Added support for PROM console in drivers/char/tty_io.c
  *      instead. Although it may work to enable more than one 
  *      console device I strongly recommend to use only one.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
  */
 
 #include <linux/config.h>
+#include <linux/errno.h>
 #include <linux/init.h>
-#include <asm/dec/machtype.h>
-
-#ifdef CONFIG_ZS
-extern int zs_init(void);
-#endif
 
-#ifdef CONFIG_DZ
-extern int dz_init(void);
-#endif
+#include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
 
-#ifdef CONFIG_SERIAL_CONSOLE
+extern int register_zs_hook(unsigned int channel,
+			    struct dec_serial_hook *hook);
+extern int unregister_zs_hook(unsigned int channel);
 
+int register_dec_serial_hook(unsigned int channel,
+			     struct dec_serial_hook *hook)
+{
 #ifdef CONFIG_ZS
-extern void zs_serial_console_init(void);
-#endif
-
-#ifdef CONFIG_DZ
-extern void dz_serial_console_init(void);
+	if (IOASIC)
+		return register_zs_hook(channel, hook);
 #endif
+	return 0;
+}
 
+int unregister_dec_serial_hook(unsigned int channel)
+{
+#ifdef CONFIG_ZS
+	if (IOASIC)
+		return unregister_zs_hook(channel);
 #endif
+	return 0;
+}
 
-/* rs_init - starts up the serial interface -
-   handle normal case of starting up the serial interface */
 
-#ifdef CONFIG_SERIAL
+extern int zs_init(void);
+extern int dz_init(void);
 
+/*
+ * rs_init - starts up the serial interface -
+ * handle normal case of starting up the serial interface
+ */
 int __init rs_init(void)
 {
-
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	return zs_init();
-    else
-	return dz_init();
-#else
-
 #ifdef CONFIG_ZS
-    return zs_init();
+	if (IOASIC)
+		return zs_init();
 #endif
-
 #ifdef CONFIG_DZ
-    return dz_init();
-#endif
-
+	if (!IOASIC)
+		return dz_init();
 #endif
+	return -ENXIO;
 }
 
 __initcall(rs_init);
 
-#endif
 
-#ifdef CONFIG_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
+
+extern void zs_serial_console_init(void);
+extern void dz_serial_console_init(void);
 
-/* serial_console_init handles the special case of starting
- *   up the console on the serial port
+/*
+ * dec_serial_console_init handles the special case of starting
+ * up the console on the serial port
  */
-static int __init decserial_console_init(void)
+static int __init dec_serial_console_init(void)
 {
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	zs_serial_console_init();
-    else
-	dz_serial_console_init();
-#else
-
 #ifdef CONFIG_ZS
-    zs_serial_console_init();
+	if (IOASIC)
+		zs_serial_console_init();
 #endif
-
 #ifdef CONFIG_DZ
-    dz_serial_console_init();
-#endif
-
+	if (!IOASIC)
+		dz_serial_console_init();
 #endif
     return 0;
 }
-console_initcall(decserial_console_init);
+console_initcall(dec_serial_console_init);
 
 #endif
diff -Naur linux-2.6.14/drivers/char/generic_serial.c linux-mips-2.6.14.orig/drivers/char/generic_serial.c
--- linux-2.6.14/drivers/char/generic_serial.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/generic_serial.c	2005-11-17 11:42:46.000000000 -0800
@@ -21,6 +21,7 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/interrupt.h>
 #include <linux/tty.h>
 #include <linux/serial.h>
 #include <linux/mm.h>
diff -Naur linux-2.6.14/drivers/char/ibm_workpad_keymap.map linux-mips-2.6.14.orig/drivers/char/ibm_workpad_keymap.map
--- linux-2.6.14/drivers/char/ibm_workpad_keymap.map	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/char/ibm_workpad_keymap.map	2005-11-17 11:42:46.000000000 -0800
@@ -0,0 +1,343 @@
+# Keymap for IBM Workpad z50
+# US Mapping
+#
+# by Michael Klar <wyldfier@iname.com>
+#
+# This is a great big mess on account of how the Caps Lock key is handled as
+# LeftShift-RightShift.  Right shift key had to be broken out, so don't use
+# use this map file as a basis for other keyboards that don't do the same
+# thing with Caps Lock.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+
+keymaps 0-2,4-5,8,12,32-33,36-37
+strings as usual
+
+keycode 0 = F1 F11 Console_13
+	shiftr keycode 0 = F11
+	shift shiftr keycode 0 = F11
+	control keycode 0 = F1
+	alt keycode 0 = Console_1
+	control alt keycode 0 = Console_1
+keycode 1 = F3 F13 Console_15
+	shiftr keycode 1 = F13
+	shift shiftr keycode 1 = F13
+	control keycode 1 = F3
+	alt keycode 1 = Console_3
+	control alt keycode 1 = Console_3
+keycode 2 = F5 F15 Console_17
+	shiftr keycode 2 = F15
+	shift shiftr keycode 2 = F15
+	control keycode 2 = F5
+	alt keycode 2 = Console_5
+	control alt keycode 2 = Console_5
+keycode 3 = F7 F17 Console_19
+	shiftr keycode 3 = F17
+	shift shiftr keycode 3 = F17
+	control keycode 3 = F7
+	alt keycode 3 = Console_7
+	control alt keycode 3 = Console_7
+keycode 4 = F9 F19 Console_21
+	shiftr keycode 4 = F19
+	shift shiftr keycode 4 = F19
+	control keycode 4 = F9
+	alt keycode 4 = Console_9
+	control alt keycode 4 = Console_9
+#keycode 5 is contrast down
+#keycode 6 is contrast up
+keycode 7 = F11 F11 Console_23
+	shiftr keycode 7 = F11
+	shift shiftr keycode 7 = F11
+	control keycode 7 = F11
+	alt keycode 7 = Console_11
+	control alt keycode 7 = Console_11
+keycode 8 = F2 F12 Console_14
+	shiftr keycode 8 = F12
+	shift shiftr keycode 8 = F12
+	control keycode 8 = F2
+	alt keycode 8 = Console_2
+	control alt keycode 8 = Console_2
+keycode 9 = F4 F14 Console_16
+	shiftr keycode 9 = F14
+	shift shiftr keycode 9 = F14
+	control keycode 9 = F4
+	alt keycode 9 = Console_4
+	control alt keycode 9 = Console_4
+keycode 10 = F6 F16 Console_18
+	shiftr keycode 10 = F16
+	shift shiftr keycode 10 = F16
+	control keycode 10 = F6
+	alt keycode 10 = Console_6
+	control alt keycode 10 = Console_6
+keycode 11 = F8 F18 Console_20
+	shiftr keycode 11 = F18
+	shift shiftr keycode 11 = F18
+	control keycode 11 = F8
+	alt keycode 11 = Console_8
+	control alt keycode 11 = Console_8
+keycode 12 = F10 F20 Console_22
+	shiftr keycode 12 = F20
+	shift shiftr keycode 12 = F20
+	control keycode 12 = F10
+	alt keycode 12 = Console_10
+	control alt keycode 12 = Console_10
+#keycode 13 is brightness down
+#keycode 14 is brightness up
+keycode 15 = F12 F12 Console_24
+	shiftr keycode 15 = F12
+	shift shiftr keycode 15 = F12
+	control keycode 15 = F12
+	alt keycode 15 = Console_12
+	control alt keycode 15 = Console_12
+keycode 16 = apostrophe quotedbl
+	shiftr keycode 16 = quotedbl
+	shift shiftr keycode 16 = quotedbl
+	control keycode 16 = Control_g
+	alt keycode 16 = Meta_apostrophe
+keycode 17 = bracketleft braceleft
+	shiftr keycode 17 = braceleft
+	shift shiftr keycode 17 = braceleft
+	control keycode 17 = Escape
+	alt keycode 17 = Meta_bracketleft
+keycode 18 = minus underscore backslash       
+	shiftr keycode 18 = underscore
+	shift shiftr keycode 18 = underscore
+	control keycode 18 = Control_underscore
+	shift control keycode 18 = Control_underscore
+	shiftr control keycode 18 = Control_underscore
+	shift shiftr control keycode 18 = Control_underscore
+	alt keycode 18 = Meta_minus
+keycode 19 = zero parenright braceright
+	shiftr keycode 19 = parenright
+	shift shiftr keycode 19 = parenright
+	alt keycode 19 = Meta_zero
+keycode 20 = p
+	shiftr keycode 20 = +P
+	shift shiftr keycode 20 = +p
+keycode 21 = semicolon colon
+	shiftr keycode 21 = colon
+	shift shiftr keycode 21 = colon
+	alt keycode 21 = Meta_semicolon
+keycode 22 = Up Scroll_Backward
+	shiftr keycode 22 = Scroll_Backward
+	shift shiftr keycode 22 = Scroll_Backward
+	alt keycode 22 = Prior
+keycode 23 = slash question
+	shiftr keycode 23 = question
+	shift shiftr keycode 23 = question
+	control keycode 23 = Delete
+	alt keycode 23 = Meta_slash
+
+keycode 27 = nine parenleft bracketright
+	shiftr keycode 27 = parenleft
+	shift shiftr keycode 27 = parenleft
+	alt keycode 27 = Meta_nine
+keycode 28 = o
+	shiftr keycode 28 = +O
+	shift shiftr keycode 28 = +o
+keycode 29 = l
+	shiftr keycode 29 = +L
+	shift shiftr keycode 29 = +l
+keycode 30 = period greater
+	shiftr keycode 30 = greater
+	shift shiftr keycode 30 = greater
+	control keycode 30 = Compose
+	alt keycode 30 = Meta_period
+
+keycode 32 = Left Decr_Console
+	shiftr keycode 32 = Decr_Console
+	shift shiftr keycode 32 = Decr_Console
+	alt keycode 32 = Home
+keycode 33 = bracketright braceright asciitilde      
+	shiftr keycode 33 = braceright
+	shift shiftr keycode 33 = braceright
+	control keycode 33 = Control_bracketright
+	alt keycode 33 = Meta_bracketright
+keycode 34 = equal plus
+	shiftr keycode 34 = plus
+	shift shiftr keycode 34 = plus
+	alt keycode 34 = Meta_equal
+keycode 35 = eight asterisk bracketleft
+	shiftr keycode 35 = asterisk
+	shift shiftr keycode 35 = asterisk
+	control keycode 35 = Delete
+	alt keycode 35 = Meta_eight
+keycode 36 = i
+	shiftr keycode 36 = +I
+	shift shiftr keycode 36 = +i
+keycode 37 = k
+	shiftr keycode 37 = +K
+	shift shiftr keycode 37 = +k
+keycode 38 = comma less
+	shiftr keycode 38 = less
+	shift shiftr keycode 38 = less
+	alt keycode 38 = Meta_comma
+
+keycode 40 = h
+	shiftr keycode 40 = +H
+	shift shiftr keycode 40 = +h
+keycode 41 = y
+	shiftr keycode 41 = +Y
+	shift shiftr keycode 41 = +y
+keycode 42 = six asciicircum
+	shiftr keycode 42 = asciicircum
+	shift shiftr keycode 42 = asciicircum
+	control keycode 42 = Control_asciicircum
+	alt keycode 42 = Meta_six
+keycode 43 = seven ampersand braceleft
+	shiftr keycode 43 = ampersand
+	shift shiftr keycode 43 = ampersand
+	control keycode 43 = Control_underscore
+	alt keycode 43 = Meta_seven
+keycode 44 = u
+	shiftr keycode 44 = +U
+	shift shiftr keycode 44 = +u
+keycode 45 = j
+	shiftr keycode 45 = +J
+	shift shiftr keycode 45 = +j
+keycode 46 = m
+	shiftr keycode 46 = +M
+	shift shiftr keycode 46 = +m
+keycode 47 = n
+	shiftr keycode 47 = +N
+	shift shiftr keycode 47 = +n
+
+# This is the "Backspace" key:
+keycode 49 = Delete Delete
+	shiftr keycode 49 = Delete
+	shift shiftr keycode 49 = Delete
+	control keycode 49 = BackSpace
+	alt keycode 49 = Meta_Delete
+keycode 50 = Num_Lock
+	shift keycode 50 = Bare_Num_Lock
+	shiftr keycode 50 = Bare_Num_Lock
+	shift shiftr keycode 50 = Bare_Num_Lock
+# This is the "Delete" key:
+keycode 51 = Remove
+	control alt keycode 51 = Boot
+
+keycode 53 = backslash bar
+	shiftr keycode 53 = bar
+	shift shiftr keycode 53 = bar
+	control keycode 53 = Control_backslash
+	alt keycode 53 = Meta_backslash
+keycode 54 = Return
+	alt keycode 54 = Meta_Control_m
+keycode 55 = space space           
+	shiftr keycode 55 = space
+	shift shiftr keycode 55 = space
+	control keycode 55 = nul
+	alt keycode 55 = Meta_space
+keycode 56 = g
+	shiftr keycode 56 = +G
+	shift shiftr keycode 56 = +g
+keycode 57 = t
+	shiftr keycode 57 = +T
+	shift shiftr keycode 57 = +t
+keycode 58 = five percent
+	shiftr keycode 58 = percent
+	shift shiftr keycode 58 = percent
+	control keycode 58 = Control_bracketright
+	alt keycode 58 = Meta_five
+keycode 59 = four dollar dollar
+	shiftr keycode 59 = dollar
+	shift shiftr keycode 59 = dollar
+	control keycode 59 = Control_backslash
+	alt keycode 59 = Meta_four
+keycode 60 = r
+	shiftr keycode 60 = +R
+	shift shiftr keycode 60 = +r
+keycode 61 = f
+	shiftr keycode 61 = +F
+	shift shiftr keycode 61 = +f
+	altgr keycode 61 = Hex_F
+keycode 62 = v
+	shiftr keycode 62 = +V
+	shift shiftr keycode 62 = +v
+keycode 63 = b
+	shiftr keycode 63 = +B
+	shift shiftr keycode 63 = +b
+	altgr keycode 63 = Hex_B
+
+keycode 67 = three numbersign
+	shiftr keycode 67 = numbersign
+	shift shiftr keycode 67 = numbersign
+	control keycode 67 = Escape
+	alt keycode 67 = Meta_three
+keycode 68 = e
+	shiftr keycode 68 = +E
+	shift shiftr keycode 68 = +e
+	altgr keycode 68 = Hex_E
+keycode 69 = d
+	shiftr keycode 69 = +D
+	shift shiftr keycode 69 = +d
+	altgr keycode 69 = Hex_D
+keycode 70 = c
+	shiftr keycode 70 = +C
+	shift shiftr keycode 70 = +c
+	altgr keycode 70 = Hex_C
+keycode 71 = Right Incr_Console
+	shiftr keycode 71 = Incr_Console
+	shift shiftr keycode 71 = Incr_Console
+	alt keycode 71 = End
+
+keycode 75 = two at at
+	shiftr keycode 75 = at
+	shift shiftr keycode 75 = at
+	control keycode 75 = nul
+	shift control keycode 75 = nul
+	shiftr control keycode 75 = nul
+	shift shiftr control keycode 75 = nul
+	alt keycode 75 = Meta_two
+keycode 76 = w
+	shiftr keycode 76 = +W
+	shift shiftr keycode 76 = +w
+keycode 77 = s
+	shiftr keycode 77 = +S
+	shift shiftr keycode 77 = +s
+keycode 78 = x
+	shiftr keycode 78 = +X
+	shift shiftr keycode 78 = +x
+keycode 79 = Down Scroll_Forward
+	shiftr keycode 79 = Scroll_Forward
+	shift shiftr keycode 79 = Scroll_Forward
+	alt keycode 79 = Next
+keycode 80 = Escape Escape
+	shiftr keycode 80 = Escape
+	shift shiftr keycode 80 = Escape
+	alt keycode 80 = Meta_Escape
+keycode 81 = Tab Tab             
+	shiftr keycode 81 = Tab
+	shift shiftr keycode 81 = Tab
+	alt keycode 81 = Meta_Tab
+keycode 82 = grave asciitilde
+	shiftr keycode 82 = asciitilde
+	shift shiftr keycode 82 = asciitilde
+	control keycode 82 = nul
+	alt keycode 82 = Meta_grave
+keycode 83 = one exclam
+	shiftr keycode 83 = exclam
+	shift shiftr keycode 83 = exclam
+	alt keycode 83 = Meta_one
+keycode 84 = q
+	shiftr keycode 84 = +Q
+	shift shiftr keycode 84 = +q
+keycode 85 = a
+	shiftr keycode 85 = +A
+	shift shiftr keycode 85 = +a
+	altgr keycode 85 = Hex_A
+keycode 86 = z
+	shiftr keycode 86 = +Z
+	shift shiftr keycode 86 = +z
+
+# This is the windows key:
+keycode 88 = Decr_Console
+keycode 89 = Shift
+keycode 90 = Control
+keycode 91 = Control
+keycode 92 = Alt
+keycode 93 = AltGr
+keycode 94 = ShiftR
+	shift keycode 94 = Caps_Lock
diff -Naur linux-2.6.14/drivers/char/Kconfig linux-mips-2.6.14.orig/drivers/char/Kconfig
--- linux-2.6.14/drivers/char/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/Kconfig	2005-11-17 11:42:45.000000000 -0800
@@ -97,7 +97,7 @@
 	tristate "Comtrol RocketPort support"
 	depends on SERIAL_NONSTANDARD
 	help
-	  This driver supports Comtrol RocketPort and RocketModem PCI boards.   
+	  This driver supports Comtrol RocketPort and RocketModem PCI boards.
           These boards provide 2, 4, 8, 16, or 32 high-speed serial ports or
           modems.  For information about the RocketPort/RocketModem  boards
           and this driver read <file:Documentation/rocket.txt>.
@@ -331,23 +331,68 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called istallion.
 
-config AU1000_UART
-	bool "Enable Au1000 UART Support"
-	depends on SERIAL_NONSTANDARD && MIPS
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use serial ports, say Y.  Otherwise, say N.
-
-config AU1000_SERIAL_CONSOLE
-	bool "Enable Au1000 serial console"
-	depends on AU1000_UART
+config AU1X00_GPIO
+	tristate "Alchemy Au1000 GPIO device support"
+	depends on MIPS && SOC_AU1X00
+
+config TS_AU1X00_ADS7846
+	tristate "Au1000/ADS7846 touchscreen support"
+	depends on MIPS && SOC_AU1X00
+
+config AU1X00_USB_TTY
+	tristate "Au1000 USB TTY Device support"
+	depends on MIPS && MIPS_AU1000 && AU1000_USB_DEVICE=y && AU1000_USB_DEVICE
+
+config AU1X00_USB_RAW
+	tristate "Au1000 USB Raw Device support"
+	depends on MIPS && MIPS_AU1000 && AU1000_USB_DEVICE=y && AU1000_USB_TTY!=y && AU1X00_USB_DEVICE
+
+config SIBYTE_SB1250_DUART
+	bool "Support for BCM1xxx onchip DUART"
+	depends on MIPS && SIBYTE_SB1xxx_SOC=y
+
+config SIBYTE_SB1250_DUART_CONSOLE
+	bool "Console on BCM1xxx DUART"
+	depends on SIBYTE_SB1250_DUART
+
+config SERIAL_DEC
+	bool "DECstation serial support"
+	depends on MACH_DECSTATION
+	default y
+	help
+	  This selects whether you want to be asked about drivers for
+	  DECstation serial ports.
+
+	  Note that the answer to this question won't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about DECstation serial ports.
+
+	  If unsure, say Y.
+
+config SERIAL_DEC_CONSOLE
+	bool "Support for console on a DECstation serial port"
+	depends on SERIAL_DEC
+	default y
+	help
+	  If you say Y here, it will be possible to use a serial port as the
+	  system console (the system console is the device which receives all
+	  kernel messages and warnings and which allows logins in single user
+	  mode).  Note that the firmware uses ttyS0 as the serial console on
+	  the Maxine and ttyS2 on the others.
+
+	  If unsure, say Y.
+
+config ZS
+	bool "Z85C30 Serial Support"
+	depends on SERIAL_DEC
+	default y
 	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use a console on a serial port, say Y.  Otherwise, say N.
+	  Documentation on the Zilog 85C350 serial communications controller
+	  is downloadable at <http://www.zilog.com/pdfs/serial/z85c30.pdf>.
 
 config QTRONIX_KEYBOARD
 	bool "Enable Qtronix 990P Keyboard Support"
-	depends on IT8712
+	depends on MIPS && (MIPS_ITE8172 || MIPS_IVR)
 	help
 	  Images of Qtronix keyboards are at
 	  <http://www.qtronix.com/keyboard.html>.
@@ -359,7 +404,7 @@
 
 config IT8172_SCR0
 	bool "Enable Smart Card Reader 0 Support "
-	depends on IT8712
+	depends on MIPS && (MIPS_ITE8172 || MIPS_IVR)
 	help
 	  Say Y here to support smart-card reader 0 (SCR0) on the Integrated
 	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
@@ -368,13 +413,17 @@
 
 config IT8172_SCR1
 	bool "Enable Smart Card Reader 1 Support "
-	depends on IT8712
+	depends on MIPS && (MIPS_ITE8172 || MIPS_IVR) && MIPS_ITE8172
 	help
 	  Say Y here to support smart-card reader 1 (SCR1) on the Integrated
 	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
 	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
 	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
 
+config ITE_GPIO
+	tristate "ITE GPIO"
+	depends on MIPS && MIPS_ITE8172
+
 config A2232
 	tristate "Commodore A2232 serial support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && ZORRO && BROKEN_ON_SMP
@@ -779,10 +828,6 @@
 	  Samsung S3C2410. This can provide periodic interrupt rates
 	  from 1Hz to 64Hz for user programs, and wakeup from Alarm.
 
-config RTC_VR41XX
-	tristate "NEC VR4100 series Real Time Clock Support"
-	depends on CPU_VR41XX
-
 config COBALT_LCD
 	bool "Support for Cobalt LCD"
 	depends on MIPS_COBALT
@@ -841,8 +886,15 @@
 	  module will be called sonypi.
 
 config TANBAC_TB0219
-	tristate "TANBAC TB0219 base board support"
+	tristate "TANBAC TB0219 (VR4131DIMM-EK) Evaluation board support"
 	depends TANBAC_TB022X
+	select PCI
+	select PCI_VR41XX
+	help
+	  The TANBAC TB0219 (VR4131DIMM-EK) is a Evaluation board for VR4131DIMM
+	  manufactured by TANBAC.
+	  Please refer to <http://www.tanbac.co.jp/> about VR4131DIMM-EK.
+
 
 menu "Ftape, the floppy tape device driver"
 
@@ -935,8 +987,8 @@
 config RAW_DRIVER
 	tristate "RAW driver (/dev/raw/rawN) (OBSOLETE)"
 	help
-	  The raw driver permits block devices to be bound to /dev/raw/rawN. 
-	  Once bound, I/O against /dev/raw/rawN uses efficient zero-copy I/O. 
+	  The raw driver permits block devices to be bound to /dev/raw/rawN.
+	  Once bound, I/O against /dev/raw/rawN uses efficient zero-copy I/O.
 	  See the raw(8) manpage for more details.
 
           The raw driver is deprecated and will be removed soon.
diff -Naur linux-2.6.14/drivers/char/lcd.c linux-mips-2.6.14.orig/drivers/char/lcd.c
--- linux-2.6.14/drivers/char/lcd.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/lcd.c	2005-11-17 11:42:46.000000000 -0800
@@ -575,8 +575,8 @@
 
 static int lcd_waiters = 0;
 
-static long lcd_read(struct inode *inode, struct file *file, char *buf,
-		     unsigned long count)
+static ssize_t lcd_read(struct file *file, char *buf,
+		     size_t count, loff_t *ofs)
 {
 	long buttons_now;
 
diff -Naur linux-2.6.14/drivers/char/lcd.h linux-mips-2.6.14.orig/drivers/char/lcd.h
--- linux-2.6.14/drivers/char/lcd.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/lcd.h	2005-11-17 11:42:46.000000000 -0800
@@ -22,7 +22,7 @@
 #define MAX_IDLE_TIME 120
 
 struct lcd_display {
-        unsigned long buttons;
+        unsigned buttons;
         int size1;
         int size2;
         unsigned char line1[LCD_CHARS_PER_LINE];
diff -Naur linux-2.6.14/drivers/char/Makefile linux-mips-2.6.14.orig/drivers/char/Makefile
--- linux-2.6.14/drivers/char/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/Makefile	2005-11-17 11:42:45.000000000 -0800
@@ -31,6 +31,7 @@
 obj-$(CONFIG_A2232)		+= ser_a2232.o generic_serial.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_MOXA_SMARTIO)	+= mxser.o
+obj-$(CONFIG_SIBYTE_SB1250_DUART) += sb1250_duart.o
 obj-$(CONFIG_COMPUTONE)		+= ip2.o ip2main.o
 obj-$(CONFIG_RISCOM8)		+= riscom8.o
 obj-$(CONFIG_ISI)		+= isicom.o
@@ -48,6 +49,7 @@
 obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_HVCS)		+= hvcs.o
 obj-$(CONFIG_SGI_MBCS)		+= mbcs.o
+obj-$(CONFIG_SERIAL_DEC)	+= decserial.o
 
 obj-$(CONFIG_PRINTER) += lp.o
 obj-$(CONFIG_TIPAR) += tipar.o
@@ -64,7 +66,6 @@
 obj-$(CONFIG_SGI_IP27_RTC) += ip27-rtc.o
 obj-$(CONFIG_DS1302) += ds1302.o
 obj-$(CONFIG_S3C2410_RTC) += s3c2410-rtc.o
-obj-$(CONFIG_RTC_VR41XX) += vr41xx_rtc.o
 ifeq ($(CONFIG_GENERIC_NVRAM),y)
   obj-$(CONFIG_NVRAM) += generic_nvram.o
 else
@@ -76,12 +77,15 @@
 obj-$(CONFIG_HW_RANDOM) += hw_random.o
 obj-$(CONFIG_FTAPE) += ftape/
 obj-$(CONFIG_COBALT_LCD) += lcd.o
+obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
+obj-$(CONFIG_AU1000_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1000_USB_TTY) += au1000_usbtty.o
+obj-$(CONFIG_AU1000_USB_RAW) += au1000_usbraw.o
 obj-$(CONFIG_PPDEV) += ppdev.o
 obj-$(CONFIG_NWBUTTON) += nwbutton.o
 obj-$(CONFIG_NWFLASH) += nwflash.o
 obj-$(CONFIG_SCx200_GPIO) += scx200_gpio.o
 obj-$(CONFIG_GPIO_VR41XX) += vr41xx_giu.o
-obj-$(CONFIG_TANBAC_TB0219) += tb0219.o
 
 obj-$(CONFIG_WATCHDOG)	+= watchdog/
 obj-$(CONFIG_MWAVE) += mwave/
@@ -93,7 +97,7 @@
 obj-$(CONFIG_HANGCHECK_TIMER) += hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM) += tpm/
 # Files generated that shall be removed upon make clean
-clean-files := consolemap_deftbl.c defkeymap.c qtronixmap.c
+clean-files := consolemap_deftbl.c defkeymap.c qtronixmap.c ibm_workpad_keymap.c
 
 quiet_cmd_conmk = CONMK   $@
       cmd_conmk = scripts/conmakehash $< > $@
@@ -105,6 +109,8 @@
 
 $(obj)/qtronixmap.o: $(obj)/qtronixmap.c
 
+$(obj)/ibm_workpad_keymap.o: $(obj)/ibm_workpad_keymap.c
+
 # Uncomment if you're changing the keymap and have an appropriate
 # loadkeys version for the map. By default, we'll use the shipped
 # versions.
@@ -112,7 +118,8 @@
 
 ifdef GENERATE_KEYMAP
 
-$(obj)/defkeymap.c $(obj)/qtronixmap.c: $(obj)/%.c: $(src)/%.map
+$(obj)/defkeymap.c $(obj)/qtronixmap.c $(obj)/ibm_workpad_keymap.c: \
+		$(obj)/%.c: $(src)/%.map
 	loadkeys --mktable $< > $@.tmp
 	sed -e 's/^static *//' $@.tmp > $@
 	rm $@.tmp
diff -Naur linux-2.6.14/drivers/char/qtronix.c linux-mips-2.6.14.orig/drivers/char/qtronix.c
--- linux-2.6.14/drivers/char/qtronix.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/qtronix.c	2005-11-17 11:42:46.000000000 -0800
@@ -535,8 +535,7 @@
 		i--;
 	}
 	if (count-i) {
-		struct inode *inode = file->f_dentry->d_inode;
-		inode->i_atime = current_fs_time(inode->i_sb);
+		file->f_dentry->d_inode->i_atime = get_seconds();
 		return count-i;
 	}
 	if (signal_pending(current))
@@ -591,6 +590,11 @@
 		return retval;
 
 	queue = (struct aux_queue *) kmalloc(sizeof(*queue), GFP_KERNEL);
+	if (!queue) {
+		misc_deregister(&psaux_mouse);
+		return -ENOMEM;
+	}
+		
 	memset(queue, 0, sizeof(*queue));
 	queue->head = queue->tail = 0;
 	init_waitqueue_head(&queue->proc_list);
diff -Naur linux-2.6.14/drivers/char/rtc.c linux-mips-2.6.14.orig/drivers/char/rtc.c
--- linux-2.6.14/drivers/char/rtc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/rtc.c	2005-11-17 11:42:46.000000000 -0800
@@ -35,23 +35,21 @@
  *	1.09a	Pete Zaitcev: Sun SPARC
  *	1.09b	Jeff Garzik: Modularize, init cleanup
  *	1.09c	Jeff Garzik: SMP cleanup
- *	1.10    Paul Barton-Davis: add support for async I/O
+ *	1.10	Paul Barton-Davis: add support for async I/O
  *	1.10a	Andrea Arcangeli: Alpha updates
  *	1.10b	Andrew Morton: SMP lock fix
  *	1.10c	Cesar Barros: SMP locking fixes and cleanup
  *	1.10d	Paul Gortmaker: delete paranoia check in rtc_exit
  *	1.10e	Maciej W. Rozycki: Handle DECstation's year weirdness.
- *      1.11    Takashi Iwai: Kernel access functions
+ *	1.11	Takashi Iwai: Kernel access functions
  *			      rtc_register/rtc_unregister/rtc_control
  *      1.11a   Daniele Bellucci: Audit create_proc_read_entry in rtc_init
- *	1.12	Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer
+ *	1.12    Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer
  *		CONFIG_HPET_EMULATE_RTC
- *
+ *	1.12a	Maciej W. Rozycki: Handle memory-mapped chips properly.
  */
 
-#define RTC_VERSION		"1.12"
-
-#define RTC_IO_EXTENT	0x8
+#define RTC_VERSION		"1.12a"
 
 /*
  *	Note that *all* calls to CMOS_READ and CMOS_WRITE are done with
@@ -324,7 +322,15 @@
 	if (rtc_has_irq == 0)
 		return -EIO;
 
-	if (count < sizeof(unsigned))
+	/*
+	 * Historically this function used to assume that sizeof(unsigned long)
+	 * is the same in userspace and kernelspace.  This lead to problems
+	 * for configurations with multiple ABIs such a the MIPS o32 and 64
+	 * ABIs supported on the same kernel.  So now we support read of both
+	 * 4 and 8 bytes and assume that's the sizeof(unsigned long) in the
+	 * userspace ABI.
+	 */
+	if (count != sizeof(unsigned int) && count !=  sizeof(unsigned long))
 		return -EINVAL;
 
 	add_wait_queue(&rtc_wait, &wait);
@@ -355,10 +361,12 @@
 		schedule();
 	} while (1);
 
-	if (count < sizeof(unsigned long))
-		retval = put_user(data, (unsigned int __user *)buf) ?: sizeof(int); 
+	if (count == sizeof(unsigned int))
+		retval = put_user(data, (unsigned int __user *)buf) ?: sizeof(int);
 	else
 		retval = put_user(data, (unsigned long __user *)buf) ?: sizeof(long);
+	if (!retval)
+		retval = count;
  out:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&rtc_wait, &wait);
@@ -905,6 +913,9 @@
 	struct sparc_isa_device *isa_dev;
 #endif
 #endif
+#ifndef __sparc__
+	void *r;
+#endif
 
 #ifdef __sparc__
 	for_each_ebus(ebus) {
@@ -950,8 +961,13 @@
 	}
 no_irq:
 #else
-	if (!request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc")) {
-		printk(KERN_ERR "rtc: I/O port %d is not free.\n", RTC_PORT (0));
+	if (RTC_IOMAPPED)
+		r = request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc");
+	else
+		r = request_mem_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc");
+	if (!r) {
+		printk(KERN_ERR "rtc: I/O resource %lx is not free.\n",
+		       (long)(RTC_PORT(0)));
 		return -EIO;
 	}
 
@@ -965,7 +981,10 @@
 	if(request_irq(RTC_IRQ, rtc_int_handler_ptr, SA_INTERRUPT, "rtc", NULL)) {
 		/* Yeah right, seeing as irq 8 doesn't even hit the bus. */
 		printk(KERN_ERR "rtc: IRQ %d is not free.\n", RTC_IRQ);
-		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		if (RTC_IOMAPPED)
+			release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		else
+			release_mem_region(RTC_PORT(0), RTC_IO_EXTENT);
 		return -EIO;
 	}
 	hpet_rtc_timer_init();
@@ -1065,7 +1084,10 @@
 	if (rtc_has_irq)
 		free_irq (rtc_irq, &rtc_port);
 #else
-	release_region (RTC_PORT (0), RTC_IO_EXTENT);
+	if (RTC_IOMAPPED)
+		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+	else
+		release_mem_region(RTC_PORT(0), RTC_IO_EXTENT);
 #ifdef RTC_IRQ
 	if (rtc_has_irq)
 		free_irq (RTC_IRQ, NULL);
diff -Naur linux-2.6.14/drivers/char/sb1250_duart.c linux-mips-2.6.14.orig/drivers/char/sb1250_duart.c
--- linux-2.6.14/drivers/char/sb1250_duart.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/char/sb1250_duart.c	2005-11-17 11:42:47.000000000 -0800
@@ -0,0 +1,915 @@
+/*
+ * Copyright (C) 2000,2001,2002,2003,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/* 
+ * Driver support for the on-chip sb1250 dual-channel serial port,
+ * running in asynchronous mode.  Also, support for doing a serial console
+ * on one of those ports 
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/termios.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+#include <linux/tty.h>
+#include <linux/sched.h>
+#include <linux/tty_flip.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/sibyte/swarm.h>
+#include <asm/sibyte/sb1250.h>
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_int.h>
+#else
+#error invalid SiByte UART configuation
+#endif
+#include <asm/sibyte/sb1250_uart.h>
+#include <asm/war.h>
+
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+#define UNIT_CHANREG(n,reg)	A_BCM1480_DUART_CHANREG((n),(reg))
+#define UNIT_IMRREG(n)		A_BCM1480_DUART_IMRREG(n)
+#define UNIT_INT(n)		(K_BCM1480_INT_UART_0 + (n))
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
+#define UNIT_CHANREG(n,reg)	A_DUART_CHANREG((n),(reg))
+#define UNIT_IMRREG(n)		A_DUART_IMRREG(n)
+#define UNIT_INT(n)		(K_INT_UART_0 + (n))
+#else
+#error invalid SiByte UART configuation
+#endif
+
+/* Toggle spewing of debugging output */
+#undef DEBUG
+
+#define DEFAULT_CFLAGS          (CS8 | B115200)
+
+#define TX_INTEN          1
+#define DUART_INITIALIZED 2
+
+#define DUART_MAX_LINE 4
+char sb1250_duart_present[DUART_MAX_LINE];
+EXPORT_SYMBOL(sb1250_duart_present);
+
+/*
+ * Still not sure what the termios structures set up here are for, 
+ *  but we have to supply pointers to them to register the tty driver
+ */
+static struct tty_driver *sb1250_duart_driver; //, sb1250_duart_callout_driver;
+
+/*
+ * This lock protects both the open flags for all the uart states as 
+ * well as the reference count for the module
+ */
+static DEFINE_SPINLOCK(open_lock);
+
+typedef struct { 
+	unsigned char       outp_buf[SERIAL_XMIT_SIZE];
+	unsigned int        outp_head;
+	unsigned int        outp_tail;
+	unsigned int        outp_count;
+	spinlock_t          outp_lock;
+	unsigned int        open;
+	unsigned int        line;
+	unsigned int        last_cflags;
+	unsigned long       flags;
+	struct tty_struct   *tty;
+	/* CSR addresses */
+	u32		    *status;
+	u32		    *imr;
+	u32		    *tx_hold;
+	u32		    *rx_hold;
+	u32		    *mode_1;
+	u32		    *mode_2;
+	u32		    *clk_sel;
+	u32		    *cmd;
+} uart_state_t;
+
+static uart_state_t uart_states[DUART_MAX_LINE];
+
+/*
+ * Inline functions local to this module 
+ */
+
+/*
+ * In bug 1956, we get glitches that can mess up uart registers.  This
+ * "write-mode-1 after any register access" is the accepted
+ * workaround.
+ */
+#if SIBYTE_1956_WAR
+static unsigned int last_mode1[DUART_MAX_LINE];
+#endif
+
+static inline u32 READ_SERCSR(u32 *addr, int line)
+{
+	u32 val = csr_in32(addr);
+#if SIBYTE_1956_WAR
+	csr_out32(last_mode1[line], uart_states[line].mode_1);
+#endif
+	return val;
+}
+
+static inline void WRITE_SERCSR(u32 val, u32 *addr, int line)
+{
+	csr_out32(val, addr);
+#if SIBYTE_1956_WAR
+	csr_out32(last_mode1[line], uart_states[line].mode_1);
+#endif
+}
+
+static void init_duart_port(uart_state_t *port, int line)
+{
+	if (!(port->flags & DUART_INITIALIZED)) {
+		port->line = line;
+		port->status = IOADDR(UNIT_CHANREG(line, R_DUART_STATUS));
+		port->imr = IOADDR(UNIT_IMRREG(line));
+		port->tx_hold = IOADDR(UNIT_CHANREG(line, R_DUART_TX_HOLD));
+		port->rx_hold = IOADDR(UNIT_CHANREG(line, R_DUART_RX_HOLD));
+		port->mode_1 = IOADDR(UNIT_CHANREG(line, R_DUART_MODE_REG_1));
+		port->mode_2 = IOADDR(UNIT_CHANREG(line, R_DUART_MODE_REG_2));
+		port->clk_sel = IOADDR(UNIT_CHANREG(line, R_DUART_CLK_SEL));
+		port->cmd = IOADDR(UNIT_CHANREG(line, R_DUART_CMD));
+		port->flags |= DUART_INITIALIZED;
+	}
+}
+
+/*
+ * Mask out the passed interrupt lines at the duart level.  This should be
+ * called while holding the associated outp_lock.
+ */
+static inline void duart_mask_ints(unsigned int line, unsigned int mask)
+{
+	uart_state_t *port = uart_states + line;
+	u64 tmp = READ_SERCSR(port->imr, line);
+	WRITE_SERCSR(tmp & ~mask, port->imr, line);
+}
+
+	
+/* Unmask the passed interrupt lines at the duart level */
+static inline void duart_unmask_ints(unsigned int line, unsigned int mask)
+{
+	uart_state_t *port = uart_states + line;
+	u64 tmp = READ_SERCSR(port->imr, line);
+	WRITE_SERCSR(tmp | mask, port->imr, line);
+}
+
+static inline void transmit_char_pio(uart_state_t *us)
+{
+	struct tty_struct *tty = us->tty;
+	int blocked = 0;
+
+	if (spin_trylock(&us->outp_lock)) {
+		for (;;) {
+			if (!(READ_SERCSR(us->status, us->line) & M_DUART_TX_RDY))
+				break;
+			if (us->outp_count <= 0 || tty->stopped || tty->hw_stopped) {
+				break;
+			} else {
+				WRITE_SERCSR(us->outp_buf[us->outp_head],
+					     us->tx_hold, us->line);
+				us->outp_head = (us->outp_head + 1) & (SERIAL_XMIT_SIZE-1);
+				if (--us->outp_count <= 0)
+					break;
+			}
+			udelay(10);
+		}
+		spin_unlock(&us->outp_lock);
+	} else {
+		blocked = 1;
+	}
+
+	if (!us->outp_count || tty->stopped ||
+	    tty->hw_stopped || blocked) {
+		us->flags &= ~TX_INTEN;
+		duart_mask_ints(us->line, M_DUART_IMR_TX);
+	}
+
+      	if (us->open &&
+	    (us->outp_count < (SERIAL_XMIT_SIZE/2))) {
+		/*
+		 * We told the discipline at one point that we had no
+		 * space, so it went to sleep.  Wake it up when we hit
+		 * half empty
+		 */
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		    tty->ldisc.write_wakeup)
+			tty->ldisc.write_wakeup(tty);
+		wake_up_interruptible(&tty->write_wait);
+	}
+}
+
+/* 
+ * Generic interrupt handler for both channels.  dev_id is a pointer
+ * to the proper uart_states structure, so from that we can derive 
+ * which port interrupted 
+ */
+
+static irqreturn_t duart_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	uart_state_t *us = (uart_state_t *)dev_id;
+	struct tty_struct *tty = us->tty;
+	unsigned int status = READ_SERCSR(us->status, us->line);
+
+	pr_debug("DUART INT\n");
+
+	if (status & M_DUART_RX_RDY) {
+		int counter = 2048;
+		unsigned int ch;
+
+		if (status & M_DUART_OVRUN_ERR)
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		if (status & M_DUART_PARITY_ERR) {
+			printk("Parity error!\n");
+		} else if (status & M_DUART_FRM_ERR) {
+			printk("Frame error!\n");
+		}
+
+		while (counter > 0) {
+			if (!(READ_SERCSR(us->status, us->line) & M_DUART_RX_RDY))
+				break;
+			ch = READ_SERCSR(us->rx_hold, us->line);
+			if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+				*tty->flip.char_buf_ptr++ = ch;
+				*tty->flip.flag_buf_ptr++ = 0;
+				tty->flip.count++;
+			}
+			udelay(1);
+			counter--;
+		}
+		tty_flip_buffer_push(tty);
+	}
+
+	if (status & M_DUART_TX_RDY) {
+		transmit_char_pio(us);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *  Actual driver functions
+ */
+
+/* Return the number of characters we can accomodate in a write at this instant */
+static int duart_write_room(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	int retval;
+
+	retval = SERIAL_XMIT_SIZE - us->outp_count;
+
+	pr_debug("duart_write_room called, returning %i\n", retval);
+
+	return retval;
+}
+
+/* memcpy the data from src to destination, but take extra care if the
+   data is coming from user space */
+static inline int copy_buf(char *dest, const char *src, int size, int from_user) 
+{
+	if (from_user) {
+		(void) copy_from_user(dest, src, size); 
+	} else {
+		memcpy(dest, src, size);
+	}
+	return size;
+}
+
+/*
+ * Buffer up to count characters from buf to be written.  If we don't have
+ * other characters buffered, enable the tx interrupt to start sending
+ */
+static int duart_write(struct tty_struct *tty, const unsigned char *buf,
+		       int count)
+{
+	uart_state_t *us;
+	int c, t, total = 0;
+	unsigned long flags;
+
+	if (!tty) return 0;
+
+	us = tty->driver_data;
+	if (!us) return 0;
+
+	pr_debug("duart_write called for %i chars by %i (%s)\n", count, current->pid, current->comm);
+
+	spin_lock_irqsave(&us->outp_lock, flags);
+
+	for (;;) {
+		c = count;
+
+		t = SERIAL_XMIT_SIZE - us->outp_tail;
+		if (t < c) c = t;
+
+		t = SERIAL_XMIT_SIZE - 1 - us->outp_count;
+		if (t < c) c = t;
+
+		if (c <= 0) break;
+
+		memcpy(us->outp_buf + us->outp_tail, buf, c);
+
+		us->outp_count += c;
+		us->outp_tail = (us->outp_tail + c) & (SERIAL_XMIT_SIZE - 1);
+		buf += c;
+		count -= c;
+		total += c;
+	}
+
+	spin_unlock_irqrestore(&us->outp_lock, flags);
+
+	if (us->outp_count && !tty->stopped && 
+	    !tty->hw_stopped && !(us->flags & TX_INTEN)) {
+		us->flags |= TX_INTEN;
+		duart_unmask_ints(us->line, M_DUART_IMR_TX);
+	}
+
+	return total;
+}
+
+
+/* Buffer one character to be written.  If there's not room for it, just drop
+   it on the floor.  This is used for echo, among other things */
+static void duart_put_char(struct tty_struct *tty, u_char ch)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long flags;
+
+	pr_debug("duart_put_char called.  Char is %x (%c)\n", (int)ch, ch);
+
+	spin_lock_irqsave(&us->outp_lock, flags);
+
+	if (us->outp_count == SERIAL_XMIT_SIZE) {
+		spin_unlock_irqrestore(&us->outp_lock, flags);
+		return;
+	}
+
+	us->outp_buf[us->outp_tail] = ch;
+	us->outp_tail = (us->outp_tail + 1) &(SERIAL_XMIT_SIZE-1);
+	us->outp_count++;
+
+	spin_unlock_irqrestore(&us->outp_lock, flags);
+}
+
+static void duart_flush_chars(struct tty_struct * tty)
+{
+	uart_state_t *port;
+
+	if (!tty) return;
+
+	port = tty->driver_data;
+
+	if (!port) return;
+
+	if (port->outp_count <= 0 || tty->stopped || tty->hw_stopped) {
+		return;
+	}
+
+	port->flags |= TX_INTEN;
+	duart_unmask_ints(port->line, M_DUART_IMR_TX);
+}
+
+/* Return the number of characters in the output buffer that have yet to be 
+   written */
+static int duart_chars_in_buffer(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	int retval;
+
+	retval = us->outp_count;
+
+	pr_debug("duart_chars_in_buffer returning %i\n", retval);
+
+	return retval;
+}
+
+/* Kill everything we haven't yet shoved into the FIFO.  Turn off the
+   transmit interrupt since we've nothing more to transmit */
+static void duart_flush_buffer(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long flags;
+
+	pr_debug("duart_flush_buffer called\n");
+	spin_lock_irqsave(&us->outp_lock, flags);
+	us->outp_head = us->outp_tail = us->outp_count = 0;
+	spin_unlock_irqrestore(&us->outp_lock, flags);
+
+	wake_up_interruptible(&us->tty->write_wait);
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		tty->ldisc.write_wakeup(tty);
+}
+
+
+/* See sb1250 user manual for details on these registers */
+static inline void duart_set_cflag(unsigned int line, unsigned int cflag)
+{
+	unsigned int mode_reg1 = 0, mode_reg2 = 0;
+	unsigned int clk_divisor;
+	uart_state_t *port = uart_states + line;
+
+	switch (cflag & CSIZE) {
+	case CS7:
+		mode_reg1 |= V_DUART_BITS_PER_CHAR_7;
+		
+	default:
+		/* We don't handle CS5 or CS6...is there a way we're supposed to flag this? 
+		   right now we just force them to CS8 */
+		mode_reg1 |= 0x0;
+		break;
+	}
+	if (cflag & CSTOPB) {
+	        mode_reg2 |= M_DUART_STOP_BIT_LEN_2;
+	}
+	if (!(cflag & PARENB)) {
+	        mode_reg1 |= V_DUART_PARITY_MODE_NONE;
+	}
+	if (cflag & PARODD) {
+		mode_reg1 |= M_DUART_PARITY_TYPE_ODD;
+	}
+	
+	/* Formula for this is (5000000/baud)-1, but we saturate
+	   at 12 bits, which means we can't actually do anything less
+	   that 1200 baud */
+	switch (cflag & CBAUD) {
+	case B200:	
+	case B300:	
+	case B1200:	clk_divisor = 4095;		break;
+	case B1800:	clk_divisor = 2776;		break;
+	case B2400:	clk_divisor = 2082;		break;
+	case B4800:	clk_divisor = 1040;		break;
+	default:
+	case B9600:	clk_divisor = 519;		break;
+	case B19200:	clk_divisor = 259;		break;
+	case B38400:	clk_divisor = 129;		break;
+	case B57600:	clk_divisor = 85;		break;
+	case B115200:	clk_divisor = 42;		break;
+	}
+	WRITE_SERCSR(mode_reg1, port->mode_1, port->line);
+	WRITE_SERCSR(mode_reg2, port->mode_2, port->line);
+	WRITE_SERCSR(clk_divisor, port->clk_sel, port->line);
+	port->last_cflags = cflag;
+}
+
+
+/* Handle notification of a termios change.  */
+static void duart_set_termios(struct tty_struct *tty, struct termios *old)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+	pr_debug("duart_set_termios called by %i (%s)\n", current->pid, current->comm);
+	if (old && tty->termios->c_cflag == old->c_cflag)
+		return;
+	duart_set_cflag(us->line, tty->termios->c_cflag);
+}
+
+static int get_serial_info(uart_state_t *us, struct serial_struct * retinfo) {
+
+	struct serial_struct tmp;
+
+	memset(&tmp, 0, sizeof(tmp));
+
+	tmp.type=PORT_SB1250;
+	tmp.line=us->line;
+	tmp.port=UNIT_CHANREG(tmp.line,0);
+	tmp.irq=UNIT_INT(tmp.line);
+	tmp.xmit_fifo_size=16; /* fixed by hw */
+	tmp.baud_base=5000000;
+	tmp.io_type=SERIAL_IO_MEM;
+
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int duart_ioctl(struct tty_struct *tty, struct file * file,
+		       unsigned int cmd, unsigned long arg)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+/*	if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
+	return -ENODEV;*/
+	switch (cmd) {
+	case TIOCMGET:
+		printk("Ignoring TIOCMGET\n");
+		break;
+	case TIOCMBIS:
+		printk("Ignoring TIOCMBIS\n");
+		break;
+	case TIOCMBIC:
+		printk("Ignoring TIOCMBIC\n");
+		break;
+	case TIOCMSET:
+		printk("Ignoring TIOCMSET\n");
+		break;
+	case TIOCGSERIAL:
+		return get_serial_info(us,(struct serial_struct *) arg);
+	case TIOCSSERIAL:
+		printk("Ignoring TIOCSSERIAL\n");
+		break;
+	case TIOCSERCONFIG:
+		printk("Ignoring TIOCSERCONFIG\n");
+		break;
+	case TIOCSERGETLSR: /* Get line status register */
+		printk("Ignoring TIOCSERGETLSR\n");
+		break;
+	case TIOCSERGSTRUCT:
+		printk("Ignoring TIOCSERGSTRUCT\n");
+		break;
+	case TIOCMIWAIT:
+		printk("Ignoring TIOCMIWAIT\n");
+		break;
+	case TIOCGICOUNT:
+		printk("Ignoring TIOCGICOUNT\n");
+		break;
+	case TIOCSERGWILD:
+		printk("Ignoring TIOCSERGWILD\n");
+		break;
+	case TIOCSERSWILD:
+		printk("Ignoring TIOCSERSWILD\n");
+		break;
+	default:
+		break;
+	}
+//	printk("Ignoring IOCTL %x from pid %i (%s)\n", cmd, current->pid, current->comm);
+	return -ENOIOCTLCMD;
+}
+
+/* XXXKW locking? */
+static void duart_start(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+	pr_debug("duart_start called\n");
+
+	if (us->outp_count && !(us->flags & TX_INTEN)) {
+		us->flags |= TX_INTEN;
+		duart_unmask_ints(us->line, M_DUART_IMR_TX);
+	}
+}
+
+/* XXXKW locking? */
+static void duart_stop(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+	pr_debug("duart_stop called\n");
+
+	if (us->outp_count && (us->flags & TX_INTEN)) {
+		us->flags &= ~TX_INTEN;
+		duart_mask_ints(us->line, M_DUART_IMR_TX);
+	}
+}
+
+/* Not sure on the semantics of this; are we supposed to wait until the stuff
+   already in the hardware FIFO drains, or are we supposed to wait until 
+   we've drained the output buffer, too?  I'm assuming the former, 'cause thats
+   what the other drivers seem to assume 
+*/
+
+static void duart_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long orig_jiffies;
+
+	orig_jiffies = jiffies;
+	pr_debug("duart_wait_until_sent(%d)+\n", timeout);
+	while (!(READ_SERCSR(us->status, us->line) & M_DUART_TX_EMT)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+	 	schedule_timeout(1);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+	pr_debug("duart_wait_until_sent()-\n");
+}
+
+/*
+ * duart_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void duart_hangup(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+	duart_flush_buffer(tty);
+	us->open = 0;
+	us->tty = 0;
+}
+
+/*
+ * Open a tty line.  Note that this can be called multiple times, so ->open can
+ * be >1.  Only set up the tty struct if this is a "new" open, e.g. ->open was
+ * zero
+ */
+static int duart_open(struct tty_struct *tty, struct file *filp)
+{
+	uart_state_t *us;
+	unsigned int line = tty->index;
+	unsigned long flags;
+
+	if ((line >= tty->driver->num) || !sb1250_duart_present[line])
+		return -ENODEV;
+
+	pr_debug("duart_open called by %i (%s), tty is %p, rw is %p, ww is %p\n",
+	       current->pid, current->comm, tty, tty->read_wait,
+	       tty->write_wait);
+
+	us = uart_states + line;
+	tty->driver_data = us;
+
+	spin_lock_irqsave(&open_lock, flags);
+	if (!us->open) {
+		us->tty = tty;
+		us->tty->termios->c_cflag = us->last_cflags;
+	}
+	us->open++;
+	us->flags &= ~TX_INTEN;
+	duart_unmask_ints(line, M_DUART_IMR_RX);
+	spin_unlock_irqrestore(&open_lock, flags);
+
+	return 0;
+}
+
+
+/*
+ * Close a reference count out.  If reference count hits zero, null the
+ * tty, kill the interrupts.  The tty_io driver is responsible for making
+ * sure we've cleared out our internal buffers before calling close()
+ */
+static void duart_close(struct tty_struct *tty, struct file *filp)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long flags;
+
+	pr_debug("duart_close called by %i (%s)\n", current->pid, current->comm);
+
+	if (!us || !us->open)
+		return;
+
+	spin_lock_irqsave(&open_lock, flags);
+	if (tty_hung_up_p(filp)) {
+		spin_unlock_irqrestore(&open_lock, flags);
+		return;
+	}
+
+	if (--us->open < 0) {
+		us->open = 0;
+		printk(KERN_ERR "duart: bad open count: %d\n", us->open);
+	}
+	if (us->open) {
+		spin_unlock_irqrestore(&open_lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&open_lock, flags);
+
+	tty->closing = 1;
+
+	/* Stop accepting input */
+	duart_mask_ints(us->line, M_DUART_IMR_RX);
+	/* Wait for FIFO to drain */
+	while (!(READ_SERCSR(us->status, us->line) & M_DUART_TX_EMT))
+		;
+
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+}
+
+
+static struct tty_operations duart_ops = {
+        .open   = duart_open,
+        .close = duart_close,
+        .write = duart_write,
+        .put_char = duart_put_char,
+        .flush_chars = duart_flush_chars,
+        .write_room = duart_write_room,
+        .chars_in_buffer = duart_chars_in_buffer,
+        .flush_buffer = duart_flush_buffer,
+        .ioctl = duart_ioctl,
+//        .throttle = duart_throttle,
+//        .unthrottle = duart_unthrottle,
+        .set_termios = duart_set_termios,
+        .stop = duart_stop,
+        .start = duart_start,
+        .hangup = duart_hangup,
+	.wait_until_sent = duart_wait_until_sent,
+};
+
+/* Initialize the sb1250_duart_present array based on SOC type.  */
+static void __init sb1250_duart_init_present_lines(void)
+{
+	int i, max_lines;
+
+	/* Set the number of available units based on the SOC type.  */
+	switch (soc_type) {
+	case K_SYS_SOC_TYPE_BCM1x55:
+	case K_SYS_SOC_TYPE_BCM1x80:
+		max_lines = 4;
+		break;
+	default:
+		/* Assume at least two serial ports at the normal address.  */
+		max_lines = 2;
+		break;
+	}
+	if (max_lines > DUART_MAX_LINE)
+		max_lines = DUART_MAX_LINE;
+
+	for (i = 0; i < max_lines; i++)
+		sb1250_duart_present[i] = 1;
+}
+
+/* Set up the driver and register it, register the UART interrupts.  This
+   is called from tty_init, or as a part of the module init */
+static int __init sb1250_duart_init(void) 
+{
+	int i;
+
+	sb1250_duart_init_present_lines();
+
+	sb1250_duart_driver = alloc_tty_driver(DUART_MAX_LINE);
+	if (!sb1250_duart_driver)
+		return -ENOMEM;
+
+	sb1250_duart_driver->owner = THIS_MODULE;
+	sb1250_duart_driver->name = "duart";
+	sb1250_duart_driver->devfs_name = "duart/";
+	sb1250_duart_driver->major = TTY_MAJOR;
+	sb1250_duart_driver->minor_start = SB1250_DUART_MINOR_BASE;
+	sb1250_duart_driver->type            = TTY_DRIVER_TYPE_SERIAL;
+	sb1250_duart_driver->subtype         = SERIAL_TYPE_NORMAL;
+	sb1250_duart_driver->init_termios    = tty_std_termios;
+	sb1250_duart_driver->flags           = TTY_DRIVER_REAL_RAW;
+	tty_set_operations(sb1250_duart_driver, &duart_ops);
+
+	for (i=0; i<DUART_MAX_LINE; i++) {
+		uart_state_t *port = uart_states + i;
+
+		if (!sb1250_duart_present[i])
+			continue;
+
+		init_duart_port(port, i);
+		spin_lock_init(&port->outp_lock);
+		duart_mask_ints(i, M_DUART_IMR_ALL);
+		if (request_irq(UNIT_INT(i), duart_int, 0, "uart", port)) {
+			panic("Couldn't get uart0 interrupt line");
+		}
+		__raw_writeq(M_DUART_RX_EN|M_DUART_TX_EN,
+			     IOADDR(UNIT_CHANREG(i, R_DUART_CMD)));
+		duart_set_cflag(i, DEFAULT_CFLAGS);
+	}
+
+	/* Interrupts are now active, our ISR can be called. */
+
+	if (tty_register_driver(sb1250_duart_driver)) {
+		printk(KERN_ERR "Couldn't register sb1250 duart serial driver\n");
+		put_tty_driver(sb1250_duart_driver);
+		return 1;
+	}
+	return 0;
+}
+
+/* Unload the driver.  Unregister stuff, get ready to go away */
+static void __exit sb1250_duart_fini(void)
+{
+	unsigned long flags;
+	int i;
+
+	local_irq_save(flags);
+	tty_unregister_driver(sb1250_duart_driver);
+	put_tty_driver(sb1250_duart_driver);
+
+	for (i=0; i<DUART_MAX_LINE; i++) {
+		if (!sb1250_duart_present[i])
+			continue;
+		free_irq(UNIT_INT(i), &uart_states[i]);
+		disable_irq(UNIT_INT(i));
+	}
+	local_irq_restore(flags);
+}
+
+module_init(sb1250_duart_init);
+module_exit(sb1250_duart_fini);
+MODULE_DESCRIPTION("SB1250 Duart serial driver");
+MODULE_AUTHOR("Broadcom Corp.");
+
+#ifdef CONFIG_SIBYTE_SB1250_DUART_CONSOLE
+
+/*
+ * Serial console stuff.  Very basic, polling driver for doing serial
+ * console output.  The console_sem is held by the caller, so we
+ * shouldn't be interrupted for more console activity.
+ * XXXKW What about getting interrupted by uart driver activity?
+ */
+
+void serial_outc(unsigned char c, int line)
+{
+	uart_state_t *port = uart_states + line;
+	while (!(READ_SERCSR(port->status, line) & M_DUART_TX_RDY)) ;
+	WRITE_SERCSR(c, port->tx_hold, line);
+	while (!(READ_SERCSR(port->status, port->line) & M_DUART_TX_EMT)) ;
+}
+
+static void ser_console_write(struct console *cons, const char *s,
+	unsigned int count)
+{
+	int line = cons->index;
+	uart_state_t *port = uart_states + line;
+	u32 imr;
+
+	imr = READ_SERCSR(port->imr, line);
+	WRITE_SERCSR(0, port->imr, line);
+	while (count--) {
+		if (*s == '\n')
+			serial_outc('\r', line);
+		serial_outc(*s++, line);
+    	}
+	WRITE_SERCSR(imr, port->imr, line);
+}
+
+static struct tty_driver *ser_console_device(struct console *c, int *index)
+{
+	*index = c->index;
+	return sb1250_duart_driver;
+}
+
+static int ser_console_setup(struct console *cons, char *str)
+{
+	int i;
+
+	sb1250_duart_init_present_lines();
+
+	for (i=0; i<DUART_MAX_LINE; i++) {
+		uart_state_t *port = uart_states + i;
+
+		if (!sb1250_duart_present[i])
+			continue;
+
+		init_duart_port(port, i);
+#if SIBYTE_1956_WAR
+		last_mode1[i] = V_DUART_PARITY_MODE_NONE|V_DUART_BITS_PER_CHAR_8;
+#endif
+		WRITE_SERCSR(V_DUART_PARITY_MODE_NONE|V_DUART_BITS_PER_CHAR_8,
+			     port->mode_1, i);
+		WRITE_SERCSR(M_DUART_STOP_BIT_LEN_1,
+			     port->mode_2, i);
+		WRITE_SERCSR(V_DUART_BAUD_RATE(115200),
+			     port->clk_sel, i);
+		WRITE_SERCSR(M_DUART_RX_EN|M_DUART_TX_EN,
+			     port->cmd, i);
+	}
+	return 0;
+}
+
+static struct console sb1250_ser_cons = {
+	.name		= "duart",
+	.write		= ser_console_write,
+	.device		= ser_console_device,
+	.setup		= ser_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+};
+
+static int __init sb1250_serial_console_init(void)
+{
+	register_console(&sb1250_ser_cons);
+	return 0;
+}
+
+console_initcall(sb1250_serial_console_init);
+
+#endif /* CONFIG_SIBYTE_SB1250_DUART_CONSOLE */
diff -Naur linux-2.6.14/drivers/char/tb0219.c linux-mips-2.6.14.orig/drivers/char/tb0219.c
--- linux-2.6.14/drivers/char/tb0219.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/tb0219.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,366 +0,0 @@
-/*
- *  Driver for TANBAC TB0219 base board.
- *
- *  Copyright (C) 2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/module.h>
-
-#include <asm/io.h>
-#include <asm/reboot.h>
-#include <asm/vr41xx/giu.h>
-#include <asm/vr41xx/tb0219.h>
-
-MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
-MODULE_DESCRIPTION("TANBAC TB0219 base board driver");
-MODULE_LICENSE("GPL");
-
-static int major;	/* default is dynamic major device number */
-module_param(major, int, 0);
-MODULE_PARM_DESC(major, "Major device number");
-
-static void (*old_machine_restart)(char *command);
-static void __iomem *tb0219_base;
-static spinlock_t tb0219_lock;
-
-#define tb0219_read(offset)		readw(tb0219_base + (offset))
-#define tb0219_write(offset, value)	writew((value), tb0219_base + (offset))
-
-#define TB0219_START	0x0a000000UL
-#define TB0219_SIZE	0x20UL
-
-#define TB0219_LED			0x00
-#define TB0219_GPIO_INPUT		0x02
-#define TB0219_GPIO_OUTPUT		0x04
-#define TB0219_DIP_SWITCH		0x06
-#define TB0219_MISC			0x08
-#define TB0219_RESET			0x0e
-#define TB0219_PCI_SLOT1_IRQ_STATUS	0x10
-#define TB0219_PCI_SLOT2_IRQ_STATUS	0x12
-#define TB0219_PCI_SLOT3_IRQ_STATUS	0x14
-
-typedef enum {
-	TYPE_LED,
-	TYPE_GPIO_OUTPUT,
-} tb0219_type_t;
-
-/*
- * Minor device number
- *	 0 = 7 segment LED
- *
- *	16 = GPIO IN 0
- *	17 = GPIO IN 1
- *	18 = GPIO IN 2
- *	19 = GPIO IN 3
- *	20 = GPIO IN 4
- *	21 = GPIO IN 5
- *	22 = GPIO IN 6
- *	23 = GPIO IN 7
- *
- *	32 = GPIO OUT 0
- *	33 = GPIO OUT 1
- *	34 = GPIO OUT 2
- *	35 = GPIO OUT 3
- *	36 = GPIO OUT 4
- *	37 = GPIO OUT 5
- *	38 = GPIO OUT 6
- *	39 = GPIO OUT 7
- *
- *	48 = DIP switch 1
- *	49 = DIP switch 2
- *	50 = DIP switch 3
- *	51 = DIP switch 4
- *	52 = DIP switch 5
- *	53 = DIP switch 6
- *	54 = DIP switch 7
- *	55 = DIP switch 8
- */
-
-static inline char get_led(void)
-{
-	return (char)tb0219_read(TB0219_LED);
-}
-
-static inline char get_gpio_input_pin(unsigned int pin)
-{
-	uint16_t values;
-
-	values = tb0219_read(TB0219_GPIO_INPUT);
-	if (values & (1 << pin))
-		return '1';
-
-	return '0';
-}
-
-static inline char get_gpio_output_pin(unsigned int pin)
-{
-	uint16_t values;
-
-	values = tb0219_read(TB0219_GPIO_OUTPUT);
-	if (values & (1 << pin))
-		return '1';
-
-	return '0';
-}
-
-static inline char get_dip_switch(unsigned int pin)
-{
-	uint16_t values;
-
-	values = tb0219_read(TB0219_DIP_SWITCH);
-	if (values & (1 << pin))
-		return '1';
-
-	return '0';
-}
-
-static inline int set_led(char command)
-{
-	tb0219_write(TB0219_LED, command);
-
-	return 0;
-}
-
-static inline int set_gpio_output_pin(unsigned int pin, char command)
-{
-	unsigned long flags;
-	uint16_t value;
-
-	if (command != '0' && command != '1')
-		return -EINVAL;
-
-	spin_lock_irqsave(&tb0219_lock, flags);
-	value = tb0219_read(TB0219_GPIO_OUTPUT);
-	if (command == '0')
-		value &= ~(1 << pin);
-	else
-		value |= 1 << pin;
-	tb0219_write(TB0219_GPIO_OUTPUT, value);
-	spin_unlock_irqrestore(&tb0219_lock, flags);
-
-	return 0;
-
-}
-
-static ssize_t tanbac_tb0219_read(struct file *file, char __user *buf, size_t len,
-                                  loff_t *ppos)
-{
-	unsigned int minor;
-	char value;
-
-	minor = iminor(file->f_dentry->d_inode);
-	switch (minor) {
-	case 0:
-		value = get_led();
-		break;
-	case 16 ... 23:
-		value = get_gpio_input_pin(minor - 16);
-		break;
-	case 32 ... 39:
-		value = get_gpio_output_pin(minor - 32);
-		break;
-	case 48 ... 55:
-		value = get_dip_switch(minor - 48);
-		break;
-	default:
-		return -EBADF;
-	}
-
-	if (len <= 0)
-		return -EFAULT;
-
-	if (put_user(value, buf))
-		return -EFAULT;
-
-	return 1;
-}
-
-static ssize_t tanbac_tb0219_write(struct file *file, const char __user *data,
-                                   size_t len, loff_t *ppos)
-{
-	unsigned int minor;
-	tb0219_type_t type;
-	size_t i;
-	int retval = 0;
-	char c;
-
-	minor = iminor(file->f_dentry->d_inode);
-	switch (minor) {
-	case 0:
-		type = TYPE_LED;
-		break;
-	case 32 ... 39:
-		type = TYPE_GPIO_OUTPUT;
-		break;
-	default:
-		return -EBADF;
-	}
-
-	for (i = 0; i < len; i++) {
-		if (get_user(c, data + i))
-			return -EFAULT;
-
-		switch (type) {
-		case TYPE_LED:
-			retval = set_led(c);
-			break;
-		case TYPE_GPIO_OUTPUT:
-			retval = set_gpio_output_pin(minor - 32, c);
-			break;
-		}
-
-		if (retval < 0)
-			break;
-	}
-
-	return i;
-}
-
-static int tanbac_tb0219_open(struct inode *inode, struct file *file)
-{
-	unsigned int minor;
-
-	minor = iminor(inode);
-	switch (minor) {
-	case 0:
-	case 16 ... 23:
-	case 32 ... 39:
-	case 48 ... 55:
-		return nonseekable_open(inode, file);
-	default:
-		break;
-	}
-
-	return -EBADF;
-}
-
-static int tanbac_tb0219_release(struct inode *inode, struct file *file)
-{
-	return 0;
-}
-
-static struct file_operations tb0219_fops = {
-	.owner		= THIS_MODULE,
-	.read		= tanbac_tb0219_read,
-	.write		= tanbac_tb0219_write,
-	.open		= tanbac_tb0219_open,
-	.release	= tanbac_tb0219_release,
-};
-
-static void tb0219_restart(char *command)
-{
-	tb0219_write(TB0219_RESET, 0);
-}
-
-static void tb0219_pci_irq_init(void)
-{
-	/* PCI Slot 1 */
-	vr41xx_set_irq_trigger(TB0219_PCI_SLOT1_PIN, IRQ_TRIGGER_LEVEL, IRQ_SIGNAL_THROUGH);
-	vr41xx_set_irq_level(TB0219_PCI_SLOT1_PIN, IRQ_LEVEL_LOW);
-
-	/* PCI Slot 2 */
-	vr41xx_set_irq_trigger(TB0219_PCI_SLOT2_PIN, IRQ_TRIGGER_LEVEL, IRQ_SIGNAL_THROUGH);
-	vr41xx_set_irq_level(TB0219_PCI_SLOT2_PIN, IRQ_LEVEL_LOW);
-
-	/* PCI Slot 3 */
-	vr41xx_set_irq_trigger(TB0219_PCI_SLOT3_PIN, IRQ_TRIGGER_LEVEL, IRQ_SIGNAL_THROUGH);
-	vr41xx_set_irq_level(TB0219_PCI_SLOT3_PIN, IRQ_LEVEL_LOW);
-}
-
-static int tb0219_probe(struct device *dev)
-{
-	int retval;
-
-	if (request_mem_region(TB0219_START, TB0219_SIZE, "TB0219") == NULL)
-		return -EBUSY;
-
-	tb0219_base = ioremap(TB0219_START, TB0219_SIZE);
-	if (tb0219_base == NULL) {
-		release_mem_region(TB0219_START, TB0219_SIZE);
-		return -ENOMEM;
-	}
-
-	retval = register_chrdev(major, "TB0219", &tb0219_fops);
-	if (retval < 0) {
-		iounmap(tb0219_base);
-		tb0219_base = NULL;
-		release_mem_region(TB0219_START, TB0219_SIZE);
-		return retval;
-	}
-
-	spin_lock_init(&tb0219_lock);
-
-	old_machine_restart = _machine_restart;
-	_machine_restart = tb0219_restart;
-
-	tb0219_pci_irq_init();
-
-	if (major == 0) {
-		major = retval;
-		printk(KERN_INFO "TB0219: major number %d\n", major);
-	}
-
-	return 0;
-}
-
-static int tb0219_remove(struct device *dev)
-{
-	_machine_restart = old_machine_restart;
-
-	iounmap(tb0219_base);
-	tb0219_base = NULL;
-
-	release_mem_region(TB0219_START, TB0219_SIZE);
-
-	return 0;
-}
-
-static struct platform_device *tb0219_platform_device;
-
-static struct device_driver tb0219_device_driver = {
-	.name		= "TB0219",
-	.bus		= &platform_bus_type,
-	.probe		= tb0219_probe,
-	.remove		= tb0219_remove,
-};
-
-static int __devinit tanbac_tb0219_init(void)
-{
-	int retval;
-
-	tb0219_platform_device = platform_device_register_simple("TB0219", -1, NULL, 0);
-	if (IS_ERR(tb0219_platform_device))
-		return PTR_ERR(tb0219_platform_device);
-
-	retval = driver_register(&tb0219_device_driver);
-	if (retval < 0)
-		platform_device_unregister(tb0219_platform_device);
-
-	return retval;
-}
-
-static void __devexit tanbac_tb0219_exit(void)
-{
-	driver_unregister(&tb0219_device_driver);
-
-	platform_device_unregister(tb0219_platform_device);
-}
-
-module_init(tanbac_tb0219_init);
-module_exit(tanbac_tb0219_exit);
diff -Naur linux-2.6.14/drivers/char/vr41xx_rtc.c linux-mips-2.6.14.orig/drivers/char/vr41xx_rtc.c
--- linux-2.6.14/drivers/char/vr41xx_rtc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/char/vr41xx_rtc.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,709 +0,0 @@
-/*
- *  Driver for NEC VR4100 series  Real Time Clock unit.
- *
- *  Copyright (C) 2003-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/irq.h>
-#include <linux/mc146818rtc.h>
-#include <linux/miscdevice.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-#include <linux/rtc.h>
-#include <linux/spinlock.h>
-#include <linux/types.h>
-#include <linux/wait.h>
-
-#include <asm/div64.h>
-#include <asm/io.h>
-#include <asm/time.h>
-#include <asm/uaccess.h>
-#include <asm/vr41xx/vr41xx.h>
-
-MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
-MODULE_DESCRIPTION("NEC VR4100 series RTC driver");
-MODULE_LICENSE("GPL");
-
-#define RTC1_TYPE1_START	0x0b0000c0UL
-#define RTC1_TYPE1_END		0x0b0000dfUL
-#define RTC2_TYPE1_START	0x0b0001c0UL
-#define RTC2_TYPE1_END		0x0b0001dfUL
-
-#define RTC1_TYPE2_START	0x0f000100UL
-#define RTC1_TYPE2_END		0x0f00011fUL
-#define RTC2_TYPE2_START	0x0f000120UL
-#define RTC2_TYPE2_END		0x0f00013fUL
-
-#define RTC1_SIZE		0x20
-#define RTC2_SIZE		0x20
-
-/* RTC 1 registers */
-#define ETIMELREG		0x00
-#define ETIMEMREG		0x02
-#define ETIMEHREG		0x04
-/* RFU */
-#define ECMPLREG		0x08
-#define ECMPMREG		0x0a
-#define ECMPHREG		0x0c
-/* RFU */
-#define RTCL1LREG		0x10
-#define RTCL1HREG		0x12
-#define RTCL1CNTLREG		0x14
-#define RTCL1CNTHREG		0x16
-#define RTCL2LREG		0x18
-#define RTCL2HREG		0x1a
-#define RTCL2CNTLREG		0x1c
-#define RTCL2CNTHREG		0x1e
-
-/* RTC 2 registers */
-#define TCLKLREG		0x00
-#define TCLKHREG		0x02
-#define TCLKCNTLREG		0x04
-#define TCLKCNTHREG		0x06
-/* RFU */
-#define RTCINTREG		0x1e
- #define TCLOCK_INT		0x08
- #define RTCLONG2_INT		0x04
- #define RTCLONG1_INT		0x02
- #define ELAPSEDTIME_INT	0x01
-
-#define RTC_FREQUENCY		32768
-#define MAX_PERIODIC_RATE	6553
-#define MAX_USER_PERIODIC_RATE	64
-
-static void __iomem *rtc1_base;
-static void __iomem *rtc2_base;
-
-#define rtc1_read(offset)		readw(rtc1_base + (offset))
-#define rtc1_write(offset, value)	writew((value), rtc1_base + (offset))
-
-#define rtc2_read(offset)		readw(rtc2_base + (offset))
-#define rtc2_write(offset, value)	writew((value), rtc2_base + (offset))
-
-static unsigned long epoch = 1970;	/* Jan 1 1970 00:00:00 */
-
-static spinlock_t rtc_task_lock;
-static wait_queue_head_t rtc_wait;
-static unsigned long rtc_irq_data;
-static struct fasync_struct *rtc_async_queue;
-static rtc_task_t *rtc_callback;
-static char rtc_name[] = "RTC";
-static unsigned long periodic_frequency;
-static unsigned long periodic_count;
-
-typedef enum {
-	RTC_RELEASE,
-	RTC_OPEN,
-} rtc_status_t;
-
-static rtc_status_t rtc_status;
-
-typedef enum {
-	FUNCTION_RTC_IOCTL,
-	FUNCTION_RTC_CONTROL,
-} rtc_callfrom_t;
-
-struct resource rtc_resource[2] = {
-	{	.name	= rtc_name,
-		.flags	= IORESOURCE_MEM,	},
-	{	.name	= rtc_name,
-		.flags	= IORESOURCE_MEM,	},
-};
-
-#define RTC_NUM_RESOURCES	sizeof(rtc_resource) / sizeof(struct resource)
-
-static inline unsigned long read_elapsed_second(void)
-{
-	unsigned long first_low, first_mid, first_high;
-	unsigned long second_low, second_mid, second_high;
-
-	do {
-		first_low = rtc1_read(ETIMELREG);
-		first_mid = rtc1_read(ETIMEMREG);
-		first_high = rtc1_read(ETIMEHREG);
-		second_low = rtc1_read(ETIMELREG);
-		second_mid = rtc1_read(ETIMEMREG);
-		second_high = rtc1_read(ETIMEHREG);
-	} while (first_low != second_low || first_mid != second_mid ||
-	         first_high != second_high);
-
-	return (first_high << 17) | (first_mid << 1) | (first_low >> 15);
-}
-
-static inline void write_elapsed_second(unsigned long sec)
-{
-	spin_lock_irq(&rtc_lock);
-
-	rtc1_write(ETIMELREG, (uint16_t)(sec << 15));
-	rtc1_write(ETIMEMREG, (uint16_t)(sec >> 1));
-	rtc1_write(ETIMEHREG, (uint16_t)(sec >> 17));
-
-	spin_unlock_irq(&rtc_lock);
-}
-
-static void set_alarm(struct rtc_time *time)
-{
-	unsigned long alarm_sec;
-
-	alarm_sec = mktime(time->tm_year + 1900, time->tm_mon + 1, time->tm_mday,
-	                   time->tm_hour, time->tm_min, time->tm_sec);
-
-	spin_lock_irq(&rtc_lock);
-
-	rtc1_write(ECMPLREG, (uint16_t)(alarm_sec << 15));
-	rtc1_write(ECMPMREG, (uint16_t)(alarm_sec >> 1));
-	rtc1_write(ECMPHREG, (uint16_t)(alarm_sec >> 17));
-
-	spin_unlock_irq(&rtc_lock);
-}
-
-static void read_alarm(struct rtc_time *time)
-{
-	unsigned long low, mid, high;
-
-	spin_lock_irq(&rtc_lock);
-
-	low = rtc1_read(ECMPLREG);
-	mid = rtc1_read(ECMPMREG);
-	high = rtc1_read(ECMPHREG);
-
-	spin_unlock_irq(&rtc_lock);
-
-	to_tm((high << 17) | (mid << 1) | (low >> 15), time);
-	time->tm_year -= 1900;
-}
-
-static void read_time(struct rtc_time *time)
-{
-	unsigned long epoch_sec, elapsed_sec;
-
-	epoch_sec = mktime(epoch, 1, 1, 0, 0, 0);
-	elapsed_sec = read_elapsed_second();
-
-	to_tm(epoch_sec + elapsed_sec, time);
-	time->tm_year -= 1900;
-}
-
-static void set_time(struct rtc_time *time)
-{
-	unsigned long epoch_sec, current_sec;
-
-	epoch_sec = mktime(epoch, 1, 1, 0, 0, 0);
-	current_sec = mktime(time->tm_year + 1900, time->tm_mon + 1, time->tm_mday,
-	                     time->tm_hour, time->tm_min, time->tm_sec);
-
-	write_elapsed_second(current_sec - epoch_sec);
-}
-
-static ssize_t rtc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	unsigned long irq_data;
-	int retval = 0;
-
-	if (count != sizeof(unsigned int) && count != sizeof(unsigned long))
-		return -EINVAL;
-
-	add_wait_queue(&rtc_wait, &wait);
-
-	do {
-		__set_current_state(TASK_INTERRUPTIBLE);
-
-		spin_lock_irq(&rtc_lock);
-		irq_data = rtc_irq_data;
-		rtc_irq_data = 0;
-		spin_unlock_irq(&rtc_lock);
-
-		if (irq_data != 0)
-			break;
-
-		if (file->f_flags & O_NONBLOCK) {
-			retval = -EAGAIN;
-			break;
-		}
-
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-	} while (1);
-
-	if (retval == 0) {
-		if (count == sizeof(unsigned int)) {
-			retval = put_user(irq_data, (unsigned int __user *)buf);
-			if (retval == 0)
-				retval = sizeof(unsigned int);
-		} else {
-			retval = put_user(irq_data, (unsigned long __user *)buf);
-			if (retval == 0)
-				retval = sizeof(unsigned long);
-		}
-
-	}
-
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&rtc_wait, &wait);
-
-	return retval;
-}
-
-static unsigned int rtc_poll(struct file *file, struct poll_table_struct *table)
-{
-	poll_wait(file, &rtc_wait, table);
-
-	if (rtc_irq_data != 0)
-		return POLLIN | POLLRDNORM;
-
-	return 0;
-}
-
-static int rtc_do_ioctl(unsigned int cmd, unsigned long arg, rtc_callfrom_t from)
-{
-	struct rtc_time time;
-	unsigned long count;
-
-	switch (cmd) {
-	case RTC_AIE_ON:
-		enable_irq(ELAPSEDTIME_IRQ);
-		break;
-	case RTC_AIE_OFF:
-		disable_irq(ELAPSEDTIME_IRQ);
-		break;
-	case RTC_PIE_ON:
-		enable_irq(RTCLONG1_IRQ);
-		break;
-	case RTC_PIE_OFF:
-		disable_irq(RTCLONG1_IRQ);
-		break;
-	case RTC_ALM_SET:
-		if (copy_from_user(&time, (struct rtc_time __user *)arg,
-		                   sizeof(struct rtc_time)))
-			return -EFAULT;
-
-		set_alarm(&time);
-		break;
-	case RTC_ALM_READ:
-		memset(&time, 0, sizeof(struct rtc_time));
-		read_alarm(&time);
-		break;
-	case RTC_RD_TIME:
-		memset(&time, 0, sizeof(struct rtc_time));
-		read_time(&time);
-		if (copy_to_user((void __user *)arg, &time, sizeof(struct rtc_time)))
-			return -EFAULT;
-		break;
-	case RTC_SET_TIME:
-		if (capable(CAP_SYS_TIME) == 0)
-			return -EACCES;
-
-		if (copy_from_user(&time, (struct rtc_time __user *)arg,
-		                   sizeof(struct rtc_time)))
-			return -EFAULT;
-
-		set_time(&time);
-		break;
-	case RTC_IRQP_READ:
-		return put_user(periodic_frequency, (unsigned long __user *)arg);
-		break;
-	case RTC_IRQP_SET:
-		if (arg > MAX_PERIODIC_RATE)
-			return -EINVAL;
-
-		if (from == FUNCTION_RTC_IOCTL && arg > MAX_USER_PERIODIC_RATE &&
-		    capable(CAP_SYS_RESOURCE) == 0)
-			return -EACCES;
-
-		periodic_frequency = arg;
-
-		count = RTC_FREQUENCY;
-		do_div(count, arg);
-
-		periodic_count = count;
-
-		spin_lock_irq(&rtc_lock);
-
-		rtc1_write(RTCL1LREG, count);
-		rtc1_write(RTCL1HREG, count >> 16);
-
-		spin_unlock_irq(&rtc_lock);
-		break;
-	case RTC_EPOCH_READ:
-		return put_user(epoch, (unsigned long __user *)arg);
-	case RTC_EPOCH_SET:
-		/* Doesn't support before 1900 */
-		if (arg < 1900)
-			return -EINVAL;
-
-		if (capable(CAP_SYS_TIME) == 0)
-			return -EACCES;
-
-		epoch = arg;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
-                     unsigned long arg)
-{
-	return rtc_do_ioctl(cmd, arg, FUNCTION_RTC_IOCTL);
-}
-
-static int rtc_open(struct inode *inode, struct file *file)
-{
-	spin_lock_irq(&rtc_lock);
-
-	if (rtc_status == RTC_OPEN) {
-		spin_unlock_irq(&rtc_lock);
-		return -EBUSY;
-	}
-
-	rtc_status = RTC_OPEN;
-	rtc_irq_data = 0;
-
-	spin_unlock_irq(&rtc_lock);
-
-	return 0;
-}
-
-static int rtc_release(struct inode *inode, struct file *file)
-{
-	if (file->f_flags & FASYNC)
-		(void)fasync_helper(-1, file, 0, &rtc_async_queue);
-
-	spin_lock_irq(&rtc_lock);
-
-	rtc1_write(ECMPLREG, 0);
-	rtc1_write(ECMPMREG, 0);
-	rtc1_write(ECMPHREG, 0);
-	rtc1_write(RTCL1LREG, 0);
-	rtc1_write(RTCL1HREG, 0);
-
-	rtc_status = RTC_RELEASE;
-
-	spin_unlock_irq(&rtc_lock);
-
-	disable_irq(ELAPSEDTIME_IRQ);
-	disable_irq(RTCLONG1_IRQ);
-
-	return 0;
-}
-
-static int rtc_fasync(int fd, struct file *file, int on)
-{
-	return fasync_helper(fd, file, on, &rtc_async_queue);
-}
-
-static struct file_operations rtc_fops = {
-	.owner		= THIS_MODULE,
-	.llseek		= no_llseek,
-	.read		= rtc_read,
-	.poll		= rtc_poll,
-	.ioctl		= rtc_ioctl,
-	.open		= rtc_open,
-	.release	= rtc_release,
-	.fasync		= rtc_fasync,
-};
-
-static irqreturn_t elapsedtime_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	spin_lock(&rtc_lock);
-	rtc2_write(RTCINTREG, ELAPSEDTIME_INT);
-
-	rtc_irq_data += 0x100;
-	rtc_irq_data &= ~0xff;
-	rtc_irq_data |= RTC_AF;
-	spin_unlock(&rtc_lock);
-
-	spin_lock(&rtc_lock);
-	if (rtc_callback)
-		rtc_callback->func(rtc_callback->private_data);
-	spin_unlock(&rtc_lock);
-
-	wake_up_interruptible(&rtc_wait);
-
-	kill_fasync(&rtc_async_queue, SIGIO, POLL_IN);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t rtclong1_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	unsigned long count = periodic_count;
-
-	spin_lock(&rtc_lock);
-	rtc2_write(RTCINTREG, RTCLONG1_INT);
-
-	rtc1_write(RTCL1LREG, count);
-	rtc1_write(RTCL1HREG, count >> 16);
-
-	rtc_irq_data += 0x100;
-	rtc_irq_data &= ~0xff;
-	rtc_irq_data |= RTC_PF;
-	spin_unlock(&rtc_lock);
-
-	spin_lock(&rtc_task_lock);
-	if (rtc_callback)
-		rtc_callback->func(rtc_callback->private_data);
-	spin_unlock(&rtc_task_lock);
-
-	wake_up_interruptible(&rtc_wait);
-
-	kill_fasync(&rtc_async_queue, SIGIO, POLL_IN);
-
-	return IRQ_HANDLED;
-}
-
-int rtc_register(rtc_task_t *task)
-{
-	if (task == NULL || task->func == NULL)
-		return -EINVAL;
-
-	spin_lock_irq(&rtc_lock);
-	if (rtc_status == RTC_OPEN) {
-		spin_unlock_irq(&rtc_lock);
-		return -EBUSY;
-	}
-
-	spin_lock(&rtc_task_lock);
-	if (rtc_callback != NULL) {
-		spin_unlock(&rtc_task_lock);
-		spin_unlock_irq(&rtc_task_lock);
-		return -EBUSY;
-	}
-
-	rtc_callback = task;
-	spin_unlock(&rtc_task_lock);
-
-	rtc_status = RTC_OPEN;
-
-	spin_unlock_irq(&rtc_lock);
-
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(rtc_register);
-
-int rtc_unregister(rtc_task_t *task)
-{
-	spin_lock_irq(&rtc_task_lock);
-	if (task == NULL || rtc_callback != task) {
-		spin_unlock_irq(&rtc_task_lock);
-		return -ENXIO;
-	}
-
-	spin_lock(&rtc_lock);
-
-	rtc1_write(ECMPLREG, 0);
-	rtc1_write(ECMPMREG, 0);
-	rtc1_write(ECMPHREG, 0);
-	rtc1_write(RTCL1LREG, 0);
-	rtc1_write(RTCL1HREG, 0);
-
-	rtc_status = RTC_RELEASE;
-
-	spin_unlock(&rtc_lock);
-
-	rtc_callback = NULL;
-
-	spin_unlock_irq(&rtc_task_lock);
-
-	disable_irq(ELAPSEDTIME_IRQ);
-	disable_irq(RTCLONG1_IRQ);
-
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(rtc_unregister);
-
-int rtc_control(rtc_task_t *task, unsigned int cmd, unsigned long arg)
-{
-	int retval = 0;
-
-	spin_lock_irq(&rtc_task_lock);
-
-	if (rtc_callback != task)
-		retval = -ENXIO;
-	else
-		rtc_do_ioctl(cmd, arg, FUNCTION_RTC_CONTROL);
-
-	spin_unlock_irq(&rtc_task_lock);
-
-	return retval;
-}
-
-EXPORT_SYMBOL_GPL(rtc_control);
-
-static struct miscdevice rtc_miscdevice = {
-	.minor	= RTC_MINOR,
-	.name	= rtc_name,
-	.fops	= &rtc_fops,
-};
-
-static int rtc_probe(struct device *dev)
-{
-	struct platform_device *pdev;
-	unsigned int irq;
-	int retval;
-
-	pdev = to_platform_device(dev);
-	if (pdev->num_resources != 2)
-		return -EBUSY;
-
-	rtc1_base = ioremap(pdev->resource[0].start, RTC1_SIZE);
-	if (rtc1_base == NULL)
-		return -EBUSY;
-
-	rtc2_base = ioremap(pdev->resource[1].start, RTC2_SIZE);
-	if (rtc2_base == NULL) {
-		iounmap(rtc1_base);
-		rtc1_base = NULL;
-		return -EBUSY;
-	}
-
-	retval = misc_register(&rtc_miscdevice);
-	if (retval < 0) {
-		iounmap(rtc1_base);
-		iounmap(rtc2_base);
-		rtc1_base = NULL;
-		rtc2_base = NULL;
-		return retval;
-	}
-
-	spin_lock_irq(&rtc_lock);
-
-	rtc1_write(ECMPLREG, 0);
-	rtc1_write(ECMPMREG, 0);
-	rtc1_write(ECMPHREG, 0);
-	rtc1_write(RTCL1LREG, 0);
-	rtc1_write(RTCL1HREG, 0);
-
-	rtc_status = RTC_RELEASE;
-	rtc_irq_data = 0;
-
-	spin_unlock_irq(&rtc_lock);
-
-	init_waitqueue_head(&rtc_wait);
-
-	irq = ELAPSEDTIME_IRQ;
-	retval = request_irq(irq, elapsedtime_interrupt, SA_INTERRUPT,
-	                     "elapsed_time", NULL);
-	if (retval == 0) {
-		irq = RTCLONG1_IRQ;
-		retval = request_irq(irq, rtclong1_interrupt, SA_INTERRUPT,
-		                     "rtclong1", NULL);
-	}
-
-	if (retval < 0) {
-		printk(KERN_ERR "rtc: IRQ%d is busy\n", irq);
-		if (irq == RTCLONG1_IRQ)
-			free_irq(ELAPSEDTIME_IRQ, NULL);
-		iounmap(rtc1_base);
-		iounmap(rtc2_base);
-		rtc1_base = NULL;
-		rtc2_base = NULL;
-		return retval;
-	}
-
-	disable_irq(ELAPSEDTIME_IRQ);
-	disable_irq(RTCLONG1_IRQ);
-
-	spin_lock_init(&rtc_task_lock);
-
-	printk(KERN_INFO "rtc: Real Time Clock of NEC VR4100 series\n");
-
-	return 0;
-}
-
-static int rtc_remove(struct device *dev)
-{
-	int retval;
-
-	retval = misc_deregister(&rtc_miscdevice);
-	if (retval < 0)
-		return retval;
-
-	free_irq(ELAPSEDTIME_IRQ, NULL);
-	free_irq(RTCLONG1_IRQ, NULL);
-	if (rtc1_base != NULL)
-		iounmap(rtc1_base);
-	if (rtc2_base != NULL)
-		iounmap(rtc2_base);
-
-	return 0;
-}
-
-static struct platform_device *rtc_platform_device;
-
-static struct device_driver rtc_device_driver = {
-	.name		= rtc_name,
-	.bus		= &platform_bus_type,
-	.probe		= rtc_probe,
-	.remove		= rtc_remove,
-};
-
-static int __devinit vr41xx_rtc_init(void)
-{
-	int retval;
-
-	switch (current_cpu_data.cputype) {
-	case CPU_VR4111:
-	case CPU_VR4121:
-		rtc_resource[0].start = RTC1_TYPE1_START;
-		rtc_resource[0].end = RTC1_TYPE1_END;
-		rtc_resource[1].start = RTC2_TYPE1_START;
-		rtc_resource[1].end = RTC2_TYPE1_END;
-		break;
-	case CPU_VR4122:
-	case CPU_VR4131:
-	case CPU_VR4133:
-		rtc_resource[0].start = RTC1_TYPE2_START;
-		rtc_resource[0].end = RTC1_TYPE2_END;
-		rtc_resource[1].start = RTC2_TYPE2_START;
-		rtc_resource[1].end = RTC2_TYPE2_END;
-		break;
-	default:
-		return -ENODEV;
-		break;
-	}
-
-	rtc_platform_device = platform_device_register_simple("RTC", -1, rtc_resource, RTC_NUM_RESOURCES);
-	if (IS_ERR(rtc_platform_device))
-		return PTR_ERR(rtc_platform_device);
-
-	retval = driver_register(&rtc_device_driver);
-	if (retval < 0)
-		platform_device_unregister(rtc_platform_device);
-
-	return retval;
-}
-
-static void __devexit vr41xx_rtc_exit(void)
-{
-	driver_unregister(&rtc_device_driver);
-
-	platform_device_unregister(rtc_platform_device);
-}
-
-module_init(vr41xx_rtc_init);
-module_exit(vr41xx_rtc_exit);
diff -Naur linux-2.6.14/drivers/ide/ide.c linux-mips-2.6.14.orig/drivers/ide/ide.c
--- linux-2.6.14/drivers/ide/ide.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/ide/ide.c	2005-11-17 11:42:56.000000000 -0800
@@ -1843,6 +1843,12 @@
 		q40ide_init();
 	}
 #endif /* CONFIG_BLK_DEV_Q40IDE */
+#ifdef CONFIG_BLK_DEV_IDE_SWARM
+	{
+		extern void swarm_ide_probe(void);
+		swarm_ide_probe();
+	}
+#endif /* CONFIG_BLK_DEV_IDE_SWARM */
 #ifdef CONFIG_BLK_DEV_BUDDHA
 	{
 		extern void buddha_init(void);
diff -Naur linux-2.6.14/drivers/ide/ide-proc.c linux-mips-2.6.14.orig/drivers/ide/ide-proc.c
--- linux-2.6.14/drivers/ide/ide-proc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/ide/ide-proc.c	2005-11-17 11:42:55.000000000 -0800
@@ -64,6 +64,7 @@
 		case ide_cy82c693:	name = "cy82c693";	break;
 		case ide_4drives:	name = "4drives";	break;
 		case ide_pmac:		name = "mac-io";	break;
+		case ide_au1xxx:	name = "au1xxx";	break;
 		default:		name = "(unknown)";	break;
 	}
 	len = sprintf(page, "%s\n", name);
diff -Naur linux-2.6.14/drivers/ide/Kconfig linux-mips-2.6.14.orig/drivers/ide/Kconfig
--- linux-2.6.14/drivers/ide/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/ide/Kconfig	2005-11-17 11:42:55.000000000 -0800
@@ -778,6 +778,39 @@
 	  This option enables the use of the sleep LED as a hard drive
 	  activity LED.
 
+config BLK_DEV_IDE_SWARM
+	bool "IDE for Sibyte evaluation boards"
+	depends on SIBYTE_SB1xxx_SOC
+
+config BLK_DEV_IDE_AU1XXX
+       bool "IDE for AMD Alchemy Au1200"
+       depends on SOC_AU1200
+choice
+       prompt "IDE Mode for AMD Alchemy Au1200"
+       default CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA
+       depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
+
+config BLK_DEV_IDE_AU1XXX_PIO_DBDMA
+       bool "PIO+DbDMA IDE for AMD Alchemy Au1200"
+
+config BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+       bool "MDMA2+DbDMA IDE for AMD Alchemy Au1200"
+       depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX     
+endchoice
+
+config BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
+        bool "Enable burstable Mode on DbDMA"
+        default false
+        depends BLK_DEV_IDE_AU1XXX
+        help
+          This option enable the burstable Flag on DbDMA controller
+          (cf. "AMD Alchemy 'Au1200' Processor Data Book - PRELIMINARY").
+
+config BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
+       int "Maximum transfer size (KB) per request (up to 128)"
+       default "128"
+       depends BLK_DEV_IDE_AU1XXX
+
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
@@ -1013,7 +1046,7 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
diff -Naur linux-2.6.14/drivers/ide/Makefile linux-mips-2.6.14.orig/drivers/ide/Makefile
--- linux-2.6.14/drivers/ide/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/ide/Makefile	2005-11-17 11:42:55.000000000 -0800
@@ -48,6 +48,6 @@
 obj-$(CONFIG_BLK_DEV_IDETAPE)		+= ide-tape.o
 obj-$(CONFIG_BLK_DEV_IDEFLOPPY)		+= ide-floppy.o
 
-obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/
+obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/ mips/
 obj-$(CONFIG_BLK_DEV_HD)		+= legacy/
 obj-$(CONFIG_ETRAX_IDE)		+= cris/
diff -Naur linux-2.6.14/drivers/ide/mips/au1xxx-ide.c linux-mips-2.6.14.orig/drivers/ide/mips/au1xxx-ide.c
--- linux-2.6.14/drivers/ide/mips/au1xxx-ide.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/ide/mips/au1xxx-ide.c	2005-11-17 11:42:56.000000000 -0800
@@ -0,0 +1,1250 @@
+/*
+ * linux/drivers/ide/mips/au1xxx-ide.c  version 01.30.00        Aug. 02 2005
+ *
+ * BRIEF MODULE DESCRIPTION
+ * AMD Alchemy Au1xxx IDE interface routines over the Static Bus
+ *
+ * Copyright (c) 2003-2005 AMD, Personal Connectivity Solutions
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Note: for more information, please refer "AMD Alchemy Au1200/Au1550 IDE
+ *       Interface and Linux Device Driver" Application Note.
+ */
+#undef REALLY_SLOW_IO           /* most systems can safely undef this */
+
+#include <linux/config.h>       /* for CONFIG_BLK_DEV_IDEPCI */
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/hdreg.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+#include <linux/sysdev.h>
+
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/mach-au1x00/au1xxx.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+
+#if CONFIG_PM
+#include <asm/mach-au1x00/au1xxx_pm.h>
+#endif
+
+#include <asm/mach-au1x00/au1xxx_ide.h>
+
+#define DRV_NAME	"au1200-ide"
+#define DRV_VERSION	"1.0"
+#define DRV_AUTHOR	"AMD PCS / Pete Popov <ppopov@embeddedalley.com>"
+#define DRV_DESC	"Au1200 IDE"
+
+static _auide_hwif auide_hwif;
+static DEFINE_SPINLOCK(ide_tune_drive_spin_lock);
+static DEFINE_SPINLOCK(ide_tune_chipset_spin_lock);
+static int dbdma_init_done = 0;
+
+/*
+ * local I/O functions
+ */
+u8 auide_inb(unsigned long port)
+{
+        return (au_readb(port));
+}
+
+u16 auide_inw(unsigned long port)
+{
+        return (au_readw(port));
+}
+
+u32 auide_inl(unsigned long port)
+{
+        return (au_readl(port));
+}
+
+void auide_insw(unsigned long port, void *addr, u32 count)
+{
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
+
+        _auide_hwif *ahwif = &auide_hwif;
+        chan_tab_t *ctp;
+        au1x_ddma_desc_t *dp;
+
+        if(!put_dest_flags(ahwif->rx_chan, (void*)addr, count << 1, 
+				DDMA_FLAGS_NOIE)) {
+                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+                return;
+        }
+        ctp = *((chan_tab_t **)ahwif->rx_chan);
+        dp = ctp->cur_ptr;
+        while (dp->dscr_cmd0 & DSCR_CMD0_V)
+                ;
+        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
+#else
+        while (count--)
+        {
+                *(u16 *)addr = au_readw(port);
+                addr +=2 ;
+        }
+#endif
+}
+
+void auide_insl(unsigned long port, void *addr, u32 count)
+{
+        while (count--)
+        {
+                *(u32 *)addr = au_readl(port);
+                /* NOTE: For IDE interfaces over PCMCIA,
+                 * 32-bit access does not work
+                 */
+                addr += 4;
+        }
+}
+
+void auide_outb(u8 addr, unsigned long port)
+{
+        return (au_writeb(addr, port));
+}
+
+void auide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port)
+{
+        return (au_writeb(addr, port));
+}
+
+void auide_outw(u16 addr, unsigned long port)
+{
+        return (au_writew(addr, port));
+}
+
+void auide_outl(u32 addr, unsigned long port)
+{
+        return (au_writel(addr, port));
+}
+
+void auide_outsw(unsigned long port, void *addr, u32 count)
+{
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
+        _auide_hwif *ahwif = &auide_hwif;
+        chan_tab_t *ctp;
+        au1x_ddma_desc_t *dp;
+
+        if(!put_source_flags(ahwif->tx_chan, (void*)addr,
+                                          count << 1, DDMA_FLAGS_NOIE)) {
+                printk(KERN_ERR "%s failed %d\n", __FUNCTION__, __LINE__);
+                return;
+        }
+        ctp = *((chan_tab_t **)ahwif->tx_chan);
+        dp = ctp->cur_ptr;
+        while (dp->dscr_cmd0 & DSCR_CMD0_V)
+                ;
+        ctp->cur_ptr = au1xxx_ddma_get_nextptr_virt(dp);
+#else
+        while (count--)
+        {
+                au_writew(*(u16 *)addr, port);
+                addr += 2;
+        }
+#endif
+}
+
+void auide_outsl(unsigned long port, void *addr, u32 count)
+{
+        while (count--)
+        {
+                au_writel(*(u32 *)addr, port);
+                /* NOTE: For IDE interfaces over PCMCIA, 
+                 * 32-bit access does not work
+                 */
+                addr += 4;
+        }
+}
+
+static void auide_tune_drive(ide_drive_t *drive, byte pio)
+{
+        int mem_sttime;
+        int mem_stcfg;
+        unsigned long flags;
+        u8 speed;
+
+        /* get the best pio mode for the drive */
+        pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+
+        printk("%s: setting Au1XXX IDE to PIO mode%d\n",
+                drive->name, pio);
+
+        spin_lock_irqsave(&ide_tune_drive_spin_lock, flags);
+
+        mem_sttime = 0;
+        mem_stcfg  = au_readl(MEM_STCFG2);
+
+        /* set pio mode! */
+        switch(pio) {
+                case 0:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO0_TWCS
+                                     | SBC_IDE_PIO0_TCSH
+                                     | SBC_IDE_PIO0_TCSOFF
+                                     | SBC_IDE_PIO0_TWP
+                                     | SBC_IDE_PIO0_TCSW
+                                     | SBC_IDE_PIO0_TPM
+                                     | SBC_IDE_PIO0_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO0_TCSOE | SBC_IDE_PIO0_TOECS;
+
+                        au_writel(mem_sttime,MEM_STTIME2);
+                        au_writel(mem_stcfg,MEM_STCFG2);
+                        break;
+
+                case 1:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO1_TWCS
+                                     | SBC_IDE_PIO1_TCSH
+                                     | SBC_IDE_PIO1_TCSOFF
+                                     | SBC_IDE_PIO1_TWP
+                                     | SBC_IDE_PIO1_TCSW
+                                     | SBC_IDE_PIO1_TPM
+                                     | SBC_IDE_PIO1_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO1_TCSOE | SBC_IDE_PIO1_TOECS;
+                        break;
+
+                case 2:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO2_TWCS
+                                     | SBC_IDE_PIO2_TCSH
+                                     | SBC_IDE_PIO2_TCSOFF
+                                     | SBC_IDE_PIO2_TWP
+                                     | SBC_IDE_PIO2_TCSW
+                                     | SBC_IDE_PIO2_TPM
+                                     | SBC_IDE_PIO2_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO2_TCSOE | SBC_IDE_PIO2_TOECS;
+                        break;
+
+                case 3:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO3_TWCS
+                                     | SBC_IDE_PIO3_TCSH
+                                     | SBC_IDE_PIO3_TCSOFF
+                                     | SBC_IDE_PIO3_TWP
+                                     | SBC_IDE_PIO3_TCSW
+                                     | SBC_IDE_PIO3_TPM
+                                     | SBC_IDE_PIO3_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO3_TCSOE | SBC_IDE_PIO3_TOECS;
+
+                        break;
+
+                case 4:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_PIO4_TWCS
+                                     | SBC_IDE_PIO4_TCSH
+                                     | SBC_IDE_PIO4_TCSOFF
+                                     | SBC_IDE_PIO4_TWP
+                                     | SBC_IDE_PIO4_TCSW
+                                     | SBC_IDE_PIO4_TPM
+                                     | SBC_IDE_PIO4_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_PIO4_TCSOE | SBC_IDE_PIO4_TOECS;
+                        break;
+        }
+
+        au_writel(mem_sttime,MEM_STTIME2);
+        au_writel(mem_stcfg,MEM_STCFG2);
+
+        spin_unlock_irqrestore(&ide_tune_drive_spin_lock, flags);
+
+        speed = pio + XFER_PIO_0;
+        ide_config_drive_speed(drive, speed);
+}
+
+static int auide_tune_chipset (ide_drive_t *drive, u8 speed)
+{
+        u8 mode = 0;
+        int mem_sttime;
+        int mem_stcfg;
+        unsigned long flags;
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        struct hd_driveid *id = drive->id;
+
+        /*
+         * Now see what the current drive is capable of,
+         * selecting UDMA only if the mate said it was ok.
+         */
+        if (id && (id->capability & 1) && drive->autodma &&
+            !__ide_dma_bad_drive(drive)) {
+                if (!mode && (id->field_valid & 2) && (id->dma_mword & 7)) {
+                        if      (id->dma_mword & 4)
+                                mode = XFER_MW_DMA_2;
+                        else if (id->dma_mword & 2)
+                                mode = XFER_MW_DMA_1;
+                        else if (id->dma_mword & 1)
+                                mode = XFER_MW_DMA_0;
+                }
+        }
+#endif
+
+        spin_lock_irqsave(&ide_tune_chipset_spin_lock, flags);
+
+        mem_sttime = 0;
+        mem_stcfg  = au_readl(MEM_STCFG2);
+
+        switch(speed) {
+                case XFER_PIO_4:
+                case XFER_PIO_3:
+                case XFER_PIO_2:
+                case XFER_PIO_1:
+                case XFER_PIO_0:
+                        auide_tune_drive(drive, (speed - XFER_PIO_0));
+                        break;
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+                case XFER_MW_DMA_2:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_MDMA2_TWCS
+                                     | SBC_IDE_MDMA2_TCSH
+                                     | SBC_IDE_MDMA2_TCSOFF
+                                     | SBC_IDE_MDMA2_TWP
+                                     | SBC_IDE_MDMA2_TCSW
+                                     | SBC_IDE_MDMA2_TPM
+                                     | SBC_IDE_MDMA2_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_MDMA2_TCSOE | SBC_IDE_MDMA2_TOECS;
+
+                        mode = XFER_MW_DMA_2;
+                        break;
+                case XFER_MW_DMA_1:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_MDMA1_TWCS
+                                     | SBC_IDE_MDMA1_TCSH
+                                     | SBC_IDE_MDMA1_TCSOFF
+                                     | SBC_IDE_MDMA1_TWP
+                                     | SBC_IDE_MDMA1_TCSW
+                                     | SBC_IDE_MDMA1_TPM
+                                     | SBC_IDE_MDMA1_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg &= ~TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_MDMA1_TCSOE | SBC_IDE_MDMA1_TOECS;
+
+                        mode = XFER_MW_DMA_1;
+                        break;
+                case XFER_MW_DMA_0:
+                        /* set timing parameters for RCS2# */
+                        mem_sttime =   SBC_IDE_MDMA0_TWCS
+                                     | SBC_IDE_MDMA0_TCSH
+                                     | SBC_IDE_MDMA0_TCSOFF
+                                     | SBC_IDE_MDMA0_TWP
+                                     | SBC_IDE_MDMA0_TCSW
+                                     | SBC_IDE_MDMA0_TPM
+                                     | SBC_IDE_MDMA0_TA;
+                        /* set configuration for RCS2# */
+                        mem_stcfg |= TS_MASK;
+                        mem_stcfg &= ~TCSOE_MASK;
+                        mem_stcfg &= ~TOECS_MASK;
+                        mem_stcfg |= SBC_IDE_MDMA0_TCSOE | SBC_IDE_MDMA0_TOECS;
+
+                        mode = XFER_MW_DMA_0;
+                        break;
+#endif
+                default:
+                        return 1;
+        }
+
+        /*
+         * Tell the drive to switch to the new mode; abort on failure.
+         */
+        if (!mode || ide_config_drive_speed(drive, mode))
+        {
+                return 1;       /* failure */
+        }
+
+
+        au_writel(mem_sttime,MEM_STTIME2);
+        au_writel(mem_stcfg,MEM_STCFG2);
+
+        spin_unlock_irqrestore(&ide_tune_chipset_spin_lock, flags);
+
+        return 0;
+}
+
+/*
+ * Multi-Word DMA + DbDMA functions
+ */
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+
+static int in_drive_list(struct hd_driveid *id, 
+                         const struct drive_list_entry *drive_table)
+{
+        for ( ; drive_table->id_model ; drive_table++){
+                if ((!strcmp(drive_table->id_model, id->model)) &&
+                        ((strstr(drive_table->id_firmware, id->fw_rev)) ||
+                        (!strcmp(drive_table->id_firmware, "ALL")))
+                )
+                        return 1;
+        }
+        return 0;
+}
+
+static int auide_build_sglist(ide_drive_t *drive,  struct request *rq)
+{
+        ide_hwif_t *hwif = drive->hwif;
+        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+        struct scatterlist *sg = hwif->sg_table;
+
+        ide_map_sg(drive, rq);
+
+        if (rq_data_dir(rq) == READ)
+                hwif->sg_dma_direction = DMA_FROM_DEVICE;
+        else
+                hwif->sg_dma_direction = DMA_TO_DEVICE;
+
+        return dma_map_sg(ahwif->dev, sg, hwif->sg_nents,
+                          hwif->sg_dma_direction);
+}
+
+static int auide_build_dmatable(ide_drive_t *drive)
+{
+        int i, iswrite, count = 0;
+        ide_hwif_t *hwif = HWIF(drive);
+
+        struct request *rq = HWGROUP(drive)->rq;
+
+        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+        struct scatterlist *sg;
+
+        iswrite = (rq_data_dir(rq) == WRITE);
+        /* Save for interrupt context */
+        ahwif->drive = drive;
+
+        /* Build sglist */
+        hwif->sg_nents = i = auide_build_sglist(drive, rq);
+
+        if (!i)
+                return 0;
+
+        /* fill the descriptors */
+        sg = hwif->sg_table;
+        while (i && sg_dma_len(sg)) {
+                u32 cur_addr;
+                u32 cur_len;
+
+                cur_addr = sg_dma_address(sg);
+                cur_len = sg_dma_len(sg);
+
+                while (cur_len) {
+                        u32 flags = DDMA_FLAGS_NOIE;
+                        unsigned int tc = (cur_len < 0xfe00)? cur_len: 0xfe00;
+
+                        if (++count >= PRD_ENTRIES) {
+                                printk(KERN_WARNING "%s: DMA table too small\n",
+                                drive->name);
+                                goto use_pio_instead;
+                        }
+
+                        /* Lets enable intr for the last descriptor only */
+                        if (1==i)
+                                flags = DDMA_FLAGS_IE;
+                        else
+                                flags = DDMA_FLAGS_NOIE;
+
+                        if (iswrite) {
+				if(!put_source_flags(ahwif->tx_chan, 
+						(void*)(page_address(sg->page) 
+							+ sg->offset), 
+						tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+							__FUNCTION__, __LINE__);
+				}
+                        } else 
+			{
+				if(!put_dest_flags(ahwif->rx_chan, 
+						(void*)(page_address(sg->page) 
+							+ sg->offset), 
+						tc, flags)) { 
+					printk(KERN_ERR "%s failed %d\n", 
+							__FUNCTION__, __LINE__);
+				}
+                        }
+
+                        cur_addr += tc;
+                        cur_len -= tc;
+                }
+                sg++;
+                i--;
+        }
+
+        if (count)
+                return 1;
+
+use_pio_instead:
+        dma_unmap_sg(ahwif->dev,
+                     hwif->sg_table,
+                     hwif->sg_nents,
+                     hwif->sg_dma_direction);
+
+        return 0; /* revert to PIO for this request */
+}
+
+static int auide_dma_end(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        _auide_hwif *ahwif = (_auide_hwif*)hwif->hwif_data;
+
+        if (hwif->sg_nents) {
+                dma_unmap_sg(ahwif->dev, hwif->sg_table, hwif->sg_nents,
+                             hwif->sg_dma_direction);
+                hwif->sg_nents = 0;
+        }
+
+        return 0;
+}
+
+static void auide_dma_start(ide_drive_t *drive )
+{
+//      printk("%s\n", __FUNCTION__);
+}
+
+ide_startstop_t auide_dma_intr(ide_drive_t *drive)
+{
+        //printk("%s\n", __FUNCTION__);
+
+        u8 stat = 0, dma_stat = 0;
+
+        dma_stat = HWIF(drive)->ide_dma_end(drive);
+        stat = HWIF(drive)->INB(IDE_STATUS_REG);        /* get drive status */
+        if (OK_STAT(stat,DRIVE_READY,drive->bad_wstat|DRQ_STAT)) {
+                if (!dma_stat) {
+                        struct request *rq = HWGROUP(drive)->rq;
+
+                        ide_end_request(drive, 1, rq->nr_sectors);
+                        return ide_stopped;
+                }
+                printk(KERN_ERR "%s: dma_intr: bad DMA status (dma_stat=%x)\n",
+                                 drive->name, dma_stat);
+        }
+        return ide_error(drive, "dma_intr", stat);
+}
+
+static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+        //printk("%s\n", __FUNCTION__);
+
+        /* issue cmd to drive */
+        ide_execute_command(drive, command, &auide_dma_intr,
+                            (2*WAIT_CMD), NULL);
+}
+
+static int auide_dma_setup(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        if (drive->media != ide_disk)
+                return 1;
+
+        if (!auide_build_dmatable(drive))
+                        /* try PIO instead of DMA */
+                        return 1;
+
+        drive->waiting_for_dma = 1;
+
+        return 0;
+}
+
+static int auide_dma_check(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        if( !dbdma_init_done ){
+                auide_hwif.white_list = in_drive_list(drive->id,
+                                                      dma_white_list);
+                auide_hwif.black_list = in_drive_list(drive->id,
+                                                      dma_black_list);
+                auide_hwif.drive = drive;
+                auide_ddma_init(&auide_hwif);
+                dbdma_init_done = 1;
+        }
+#endif
+
+        /* Is the drive in our DMA black list? */
+        if ( auide_hwif.black_list ) {
+                drive->using_dma = 0;
+                printk("%s found in dma_blacklist[]! Disabling DMA.\n",
+                drive->id->model);
+        }
+        else
+                drive->using_dma = 1;
+
+        return HWIF(drive)->ide_dma_host_on(drive);
+}
+
+static int auide_dma_test_irq(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        if (!drive->waiting_for_dma)
+                printk(KERN_WARNING "%s: ide_dma_test_irq \
+                                     called while not waiting\n", drive->name);
+
+        /* If dbdma didn't execute the STOP command yet, the
+         * active bit is still set
+	 */
+        drive->waiting_for_dma++;
+        if (drive->waiting_for_dma >= DMA_WAIT_TIMEOUT) {
+                printk(KERN_WARNING "%s: timeout waiting for ddma to \
+                                     complete\n", drive->name);
+                return 1;
+        }
+        udelay(10);
+        return 0;
+}
+
+static int auide_dma_host_on(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        return 0;
+}
+
+static int auide_dma_on(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        drive->using_dma = 1;
+        return auide_dma_host_on(drive);
+}
+
+
+static int auide_dma_host_off(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        return 0;
+}
+
+static int auide_dma_off_quietly(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+        drive->using_dma = 0;
+        return auide_dma_host_off(drive);
+}
+
+static int auide_dma_lostirq(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        printk(KERN_ERR "%s: IRQ lost\n", drive->name);
+        return 0;
+}
+
+static void auide_ddma_tx_callback(int irq, void *param, struct pt_regs *regs)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        _auide_hwif *ahwif = (_auide_hwif*)param;
+        ahwif->drive->waiting_for_dma = 0;
+        return;
+}
+
+static void auide_ddma_rx_callback(int irq, void *param, struct pt_regs *regs)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        _auide_hwif *ahwif = (_auide_hwif*)param;
+        ahwif->drive->waiting_for_dma = 0;
+        return;
+}
+
+static int auide_dma_timeout(ide_drive_t *drive)
+{
+//      printk("%s\n", __FUNCTION__);
+
+        printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
+
+        if (HWIF(drive)->ide_dma_test_irq(drive))
+                return 0;
+
+        return HWIF(drive)->ide_dma_end(drive);
+}
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+
+
+static int auide_ddma_init( _auide_hwif *auide )
+{
+//      printk("%s\n", __FUNCTION__);
+
+        dbdev_tab_t source_dev_tab;
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        dbdev_tab_t target_dev_tab;
+        ide_hwif_t *hwif = auide->hwif;
+        char warning_output [2][80];
+        int i;
+#endif
+
+        /* Add our custom device to DDMA device table */
+        /* Create our new device entries in the table */
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        source_dev_tab.dev_id = AU1XXX_ATA_DDMA_REQ;
+
+        if( auide->white_list || auide->black_list ){
+                source_dev_tab.dev_tsize       = 8;
+                source_dev_tab.dev_devwidth    = 32;
+                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                source_dev_tab.dev_intlevel    = 0;
+                source_dev_tab.dev_intpolarity = 0;
+
+                /* init device table for target - static bus controller - */
+                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
+                target_dev_tab.dev_tsize       = 8;
+                target_dev_tab.dev_devwidth    = 32;
+                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                target_dev_tab.dev_intlevel    = 0;
+                target_dev_tab.dev_intpolarity = 0;
+                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
+        }
+        else{
+                source_dev_tab.dev_tsize       = 1;
+                source_dev_tab.dev_devwidth    = 16;
+                source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                source_dev_tab.dev_intlevel    = 0;
+                source_dev_tab.dev_intpolarity = 0;
+
+                /* init device table for target - static bus controller - */
+                target_dev_tab.dev_id          = DSCR_CMD0_ALWAYS;
+                target_dev_tab.dev_tsize       = 1;
+                target_dev_tab.dev_devwidth    = 16;
+                target_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+                target_dev_tab.dev_intlevel    = 0;
+                target_dev_tab.dev_intpolarity = 0;
+                target_dev_tab.dev_flags       = DEV_FLAGS_ANYUSE;
+
+                sprintf(&warning_output[0][0],
+                        "%s is not on ide driver white list.",
+                        auide_hwif.drive->id->model);
+                for ( i=strlen(&warning_output[0][0]) ; i<76; i++ ){
+                        sprintf(&warning_output[0][i]," ");
+                }
+
+                sprintf(&warning_output[1][0],
+                "To add %s please read 'Documentation/mips/AU1xxx_IDE.README'.",
+                        auide_hwif.drive->id->model);
+                for ( i=strlen(&warning_output[1][0]) ; i<76; i++ ){
+                        sprintf(&warning_output[1][i]," ");
+                }
+
+                printk("\n****************************************");
+                printk("****************************************\n");
+                printk("* %s *\n",&warning_output[0][0]);
+                printk("* Switch to safe MWDMA Mode!            ");
+                printk("                                       *\n");
+                printk("* %s *\n",&warning_output[1][0]);
+                printk("****************************************");
+                printk("****************************************\n\n");        
+        }
+#else
+        source_dev_tab.dev_id = DSCR_CMD0_ALWAYS;
+        source_dev_tab.dev_tsize       = 8;
+        source_dev_tab.dev_devwidth    = 32;
+        source_dev_tab.dev_physaddr    = (u32)AU1XXX_ATA_PHYS_ADDR;
+        source_dev_tab.dev_intlevel    = 0;
+        source_dev_tab.dev_intpolarity = 0;
+#endif
+
+#if CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
+        /* set flags for tx channel */
+        source_dev_tab.dev_flags =  DEV_FLAGS_OUT
+                                  | DEV_FLAGS_SYNC
+                                  | DEV_FLAGS_BURSTABLE;
+        auide->tx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+        /* set flags for rx channel */
+        source_dev_tab.dev_flags =  DEV_FLAGS_IN
+                                  | DEV_FLAGS_SYNC
+                                  | DEV_FLAGS_BURSTABLE;
+        auide->rx_dev_id = au1xxx_ddma_add_device( &source_dev_tab );
+#else
+        /* set flags for tx channel */
+        source_dev_tab.dev_flags = DEV_FLAGS_OUT | DEV_FLAGS_SYNC;
+        auide->tx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
+        /* set flags for rx channel */
+        source_dev_tab.dev_flags = DEV_FLAGS_IN | DEV_FLAGS_SYNC;
+        auide->rx_dev_id         = au1xxx_ddma_add_device( &source_dev_tab );
+#endif
+
+#if  defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+
+        auide->target_dev_id           = au1xxx_ddma_add_device(&target_dev_tab);
+
+        /* Get a channel for TX */
+        auide->tx_chan = au1xxx_dbdma_chan_alloc(auide->target_dev_id,
+                                                 auide->tx_dev_id,
+                                                 auide_ddma_tx_callback,
+                                                 (void*)auide);
+        /* Get a channel for RX */
+        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+                                                 auide->target_dev_id, 
+                                                 auide_ddma_rx_callback, 
+                                                 (void*)auide);
+#else   /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
+        /*
+         * Note: if call back is not enabled, update ctp->cur_ptr manually 
+         */
+        auide->tx_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,
+                                                 auide->tx_dev_id,
+                                                 NULL, 
+                                                 (void*)auide);
+        auide->rx_chan = au1xxx_dbdma_chan_alloc(auide->rx_dev_id,
+                                                 DSCR_CMD0_ALWAYS,
+                                                 NULL,
+                                                 (void*)auide);
+#endif
+        auide->tx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->tx_chan, 
+                                                             NUM_DESCRIPTORS);
+        auide->rx_desc_head = (void*)au1xxx_dbdma_ring_alloc(auide->rx_chan, 
+                                                             NUM_DESCRIPTORS);
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        hwif->dmatable_cpu = dma_alloc_coherent(auide->dev,
+                                                PRD_ENTRIES * PRD_BYTES,        /* 1 Page */
+                                                &hwif->dmatable_dma, GFP_KERNEL);
+
+        auide->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES,
+                                GFP_KERNEL|GFP_DMA);
+        if (auide->sg_table == NULL) {
+                return -ENOMEM;
+        }
+#endif
+        au1xxx_dbdma_start( auide->tx_chan );
+        au1xxx_dbdma_start( auide->rx_chan );
+        return 0;
+}
+
+static void auide_setup_ports(hw_regs_t *hw, _auide_hwif *ahwif)
+{
+        int i;
+#define ide_ioreg_t unsigned long
+        ide_ioreg_t *ata_regs = hw->io_ports;
+
+	/* fixme */
+        for (i = 0; i < IDE_CONTROL_OFFSET; i++) {
+                *ata_regs++ = (ide_ioreg_t) ahwif->regbase 
+                            + (ide_ioreg_t)(i << AU1XXX_ATA_REG_OFFSET);
+        }
+
+        /* set the Alternative Status register */
+        *ata_regs = (ide_ioreg_t) ahwif->regbase
+                  + (ide_ioreg_t)(14 << AU1XXX_ATA_REG_OFFSET);
+}
+
+static int au_ide_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+        _auide_hwif *ahwif = &auide_hwif;
+        ide_hwif_t *hwif;
+	struct resource *res;
+	int ret = 0;
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA)
+        char *mode = "MWDMA2";
+#elif defined(CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA)
+        char *mode = "PIO+DDMA(offload)";
+#endif
+
+        memset(&auide_hwif, 0, sizeof(_auide_hwif));
+        auide_hwif.dev                  = 0;
+
+	ahwif->dev = dev;
+	ahwif->irq = platform_get_irq(pdev, 0);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL) {
+		pr_debug("%s %d: no base address\n", DRV_NAME, pdev->id);
+		ret = -ENODEV;
+		goto out;
+	}
+
+        if (!request_mem_region (res->start, res->end-res->start, pdev->name)) {
+		pr_debug("%s: request_mem_region failed\n", DRV_NAME);
+                ret =  -EBUSY;
+		goto out;
+        }
+
+	ahwif->regbase = (u32)ioremap(res->start, res->end-res->start);
+	if (ahwif->regbase == 0) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+        hwif                            = &ide_hwifs[pdev->id];
+	hw_regs_t *hw 			= &hwif->hw;
+        hwif->irq = hw->irq             = ahwif->irq;
+        hwif->chipset                   = ide_au1xxx;
+
+        auide_setup_ports(hw, ahwif);
+	memcpy(hwif->io_ports, hw->io_ports, sizeof(hwif->io_ports));
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ
+        hwif->rqsize = CONFIG_BLK_DEV_IDE_AU1XXX_SEQTS_PER_RQ;
+        hwif->rqsize                    = ((hwif->rqsize > AU1XXX_ATA_RQSIZE) 
+                                        || (hwif->rqsize < 32)) ? AU1XXX_ATA_RQSIZE : hwif->rqsize;
+#else /* if kernel config is not set */
+        hwif->rqsize                    = AU1XXX_ATA_RQSIZE;
+#endif
+
+        hwif->ultra_mask                = 0x0;  /* Disable Ultra DMA */
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        hwif->mwdma_mask                = 0x07; /* Multimode-2 DMA  */
+        hwif->swdma_mask                = 0x07;
+#else
+        hwif->mwdma_mask                = 0x0;
+        hwif->swdma_mask                = 0x0;
+#endif
+        //hwif->noprobe = !hwif->io_ports[IDE_DATA_OFFSET];
+        hwif->noprobe = 0;
+        hwif->drives[0].unmask          = 1;
+        hwif->drives[1].unmask          = 1;
+
+        /* hold should be on in all cases */
+        hwif->hold                      = 1;
+        hwif->mmio                      = 2;
+
+        /* set up local I/O function entry points */
+        hwif->INB                       = auide_inb;
+        hwif->INW                       = auide_inw;
+        hwif->INL                       = auide_inl;
+        hwif->INSW                      = auide_insw;
+        hwif->INSL                      = auide_insl;
+        hwif->OUTB                      = auide_outb;
+        hwif->OUTBSYNC                  = auide_outbsync;
+        hwif->OUTW                      = auide_outw;
+        hwif->OUTL                      = auide_outl;
+        hwif->OUTSW                     = auide_outsw;
+        hwif->OUTSL                     = auide_outsl;
+
+        hwif->tuneproc                  = &auide_tune_drive;
+        hwif->speedproc                 = &auide_tune_chipset;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        hwif->ide_dma_off_quietly       = &auide_dma_off_quietly;
+        hwif->ide_dma_timeout           = &auide_dma_timeout;
+
+        hwif->ide_dma_check             = &auide_dma_check;
+        hwif->dma_exec_cmd              = &auide_dma_exec_cmd;
+        hwif->dma_start                 = &auide_dma_start;
+        hwif->ide_dma_end               = &auide_dma_end;
+        hwif->dma_setup                 = &auide_dma_setup;
+        hwif->ide_dma_test_irq          = &auide_dma_test_irq;
+        hwif->ide_dma_host_off          = &auide_dma_host_off;
+        hwif->ide_dma_host_on           = &auide_dma_host_on;
+        hwif->ide_dma_lostirq           = &auide_dma_lostirq;
+        hwif->ide_dma_on                = &auide_dma_on;
+
+        hwif->autodma                   = 1;
+        hwif->drives[0].autodma         = hwif->autodma;
+        hwif->drives[1].autodma         = hwif->autodma;
+        hwif->atapi_dma                 = 1;
+        hwif->drives[0].using_dma       = 1;
+        hwif->drives[1].using_dma       = 1;
+#else /* !CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+        hwif->autodma                   = 0;
+        hwif->channel                   = 0;
+        hwif->hold                      = 1;
+        hwif->select_data               = 0;    /* no chipset-specific code */
+        hwif->config_data               = 0;    /* no chipset-specific code */
+
+        hwif->drives[0].autodma         = 0;
+        hwif->drives[0].drive_data      = 0;    /* no drive data */
+        hwif->drives[0].using_dma       = 0;
+        hwif->drives[0].waiting_for_dma = 0;
+        hwif->drives[0].autotune        = 1;    /* 1=autotune, 2=noautotune, 0=default */
+        /* secondary hdd not supported */
+        hwif->drives[1].autodma         = 0;
+
+        hwif->drives[1].drive_data      = 0;
+        hwif->drives[1].using_dma       = 0;
+        hwif->drives[1].waiting_for_dma = 0;
+        hwif->drives[1].autotune        = 2;   /* 1=autotune, 2=noautotune, 0=default */
+#endif
+        hwif->drives[0].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
+        hwif->drives[1].io_32bit        = 0;   /* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
+
+        /*Register Driver with PM Framework*/
+#ifdef CONFIG_PM
+        auide_hwif.pm.lock    = SPIN_LOCK_UNLOCKED;
+        auide_hwif.pm.stopped = 0;
+
+        auide_hwif.pm.dev = new_au1xxx_power_device( "ide",
+                                                &au1200ide_pm_callback,
+                                                NULL);
+        if ( auide_hwif.pm.dev == NULL )
+                printk(KERN_INFO "Unable to create a power management \
+                                device entry for the au1200-IDE.\n");
+        else
+                printk(KERN_INFO "Power management device entry for the \
+                                au1200-IDE loaded.\n");
+#endif
+
+        auide_hwif.hwif                 = hwif;
+        hwif->hwif_data                 = &auide_hwif;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA           
+        auide_ddma_init(&auide_hwif);
+        dbdma_init_done = 1;
+#endif
+
+	probe_hwif_init(hwif);
+	dev_set_drvdata(dev, hwif);
+
+        printk(KERN_INFO "Au1xxx IDE(builtin) configured for %s\n", mode );
+
+out:
+        return ret;
+}
+
+static int au_ide_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct resource *res;
+	ide_hwif_t *hwif = dev_get_drvdata(dev);
+        _auide_hwif *ahwif = &auide_hwif;
+
+	ide_unregister(hwif - ide_hwifs);
+
+	iounmap((void *)ahwif->regbase);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start);
+
+	return 0;
+}
+
+static struct device_driver au1200_ide_driver = {
+	.name		= "au1200-ide",
+	.bus		= &platform_bus_type,
+	.probe 		= au_ide_probe,
+	.remove		= au_ide_remove,
+};
+
+static int __init au_ide_init(void)
+{
+	return driver_register(&au1200_ide_driver);
+}
+
+static void __init au_ide_exit(void)
+{
+	driver_unregister(&au1200_ide_driver);
+}
+
+#ifdef CONFIG_PM
+int au1200ide_pm_callback( au1xxx_power_dev_t *dev,\
+                        au1xxx_request_t request, void *data) {
+
+        unsigned int d, err = 0;
+        unsigned long flags;
+
+        spin_lock_irqsave(auide_hwif.pm.lock, flags);
+
+        switch (request){
+                case AU1XXX_PM_SLEEP:
+                        err = au1xxxide_pm_sleep(dev);
+                        break;
+                case AU1XXX_PM_WAKEUP:
+                        d = *((unsigned int*)data);
+                        if ( d > 0 && d <= 99) {
+                                err = au1xxxide_pm_standby(dev);
+                        }
+                        else {
+                                err = au1xxxide_pm_resume(dev);
+                        }
+                        break;
+                case AU1XXX_PM_GETSTATUS:
+                        err = au1xxxide_pm_getstatus(dev);
+                        break;
+                case AU1XXX_PM_ACCESS:
+                        err = au1xxxide_pm_access(dev);
+                        break;
+                case AU1XXX_PM_IDLE:
+                        err = au1xxxide_pm_idle(dev);
+                        break;
+                case AU1XXX_PM_CLEANUP:
+                        err = au1xxxide_pm_cleanup(dev);
+                        break;
+                default:
+                        err = -1;
+                        break;
+        }
+
+        spin_unlock_irqrestore(auide_hwif.pm.lock, flags);
+
+        return err;	
+}
+
+static int au1xxxide_pm_standby( au1xxx_power_dev_t *dev ) {
+        return 0; 
+}
+
+static int au1xxxide_pm_sleep( au1xxx_power_dev_t *dev ) {
+
+        int retval;
+        ide_hwif_t *hwif = auide_hwif.hwif;
+        struct request rq;
+        struct request_pm_state rqpm;
+        ide_task_t args;
+
+        if(auide_hwif.pm.stopped)
+                return -1;
+
+        /* 
+         * wait until hard disc is ready
+         */
+        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
+                printk("Wait for drive sleep timeout!\n");
+                retval = -1;
+        }
+
+        /*
+         * sequenz to tell the high level ide driver that pm is resuming
+         */
+        memset(&rq, 0, sizeof(rq));
+        memset(&rqpm, 0, sizeof(rqpm));
+        memset(&args, 0, sizeof(args));
+        rq.flags = REQ_PM_SUSPEND;
+        rq.special = &args;
+        rq.pm = &rqpm;
+        rqpm.pm_step = ide_pm_state_start_suspend;
+        rqpm.pm_state = PMSG_SUSPEND;
+
+        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_wait);
+
+        if (wait_for_ready (&hwif->drives[0], 35000)) {
+                printk("Wait for drive sleep timeout!\n");
+                retval = -1;
+        }
+
+        /*
+         * stop dbdma channels
+         */
+        au1xxx_dbdma_reset(auide_hwif.tx_chan);
+        au1xxx_dbdma_reset(auide_hwif.rx_chan);
+
+        auide_hwif.pm.stopped = 1;
+
+        return retval;
+}
+
+static int au1xxxide_pm_resume( au1xxx_power_dev_t *dev ) {
+
+        int retval;
+        ide_hwif_t *hwif = auide_hwif.hwif;
+        struct request rq;
+        struct request_pm_state rqpm;
+        ide_task_t args;
+
+        if(!auide_hwif.pm.stopped)
+                return -1;
+
+        /*
+         * start dbdma channels
+         */	
+        au1xxx_dbdma_start(auide_hwif.tx_chan);
+        au1xxx_dbdma_start(auide_hwif.rx_chan);
+
+        /*
+         * wait until hard disc is ready
+         */
+        if (wait_for_ready ( &hwif->drives[0], 35000)) {
+                printk("Wait for drive wake up timeout!\n");
+                retval = -1;
+        }
+
+        /*
+         * sequenz to tell the high level ide driver that pm is resuming
+         */
+        memset(&rq, 0, sizeof(rq));
+        memset(&rqpm, 0, sizeof(rqpm));
+        memset(&args, 0, sizeof(args));
+        rq.flags = REQ_PM_RESUME;
+        rq.special = &args;
+        rq.pm = &rqpm;
+        rqpm.pm_step = ide_pm_state_start_resume;
+        rqpm.pm_state = PMSG_ON;
+
+        retval = ide_do_drive_cmd(&hwif->drives[0], &rq, ide_head_wait);
+
+        /*
+        * wait for hard disc
+        */
+        if ( wait_for_ready(&hwif->drives[0], 35000) ) {
+                printk("Wait for drive wake up timeout!\n");
+                retval = -1;
+        }
+
+        auide_hwif.pm.stopped = 0;
+
+        return retval;
+}
+
+static int au1xxxide_pm_getstatus( au1xxx_power_dev_t *dev ) {
+        return dev->cur_state;
+}
+
+static int au1xxxide_pm_access( au1xxx_power_dev_t *dev ) {
+        if (dev->cur_state != AWAKE_STATE)
+                return 0;
+        else
+                return -1;
+}
+
+static int au1xxxide_pm_idle( au1xxx_power_dev_t *dev ) {
+        return 0;
+}
+
+static int au1xxxide_pm_cleanup( au1xxx_power_dev_t *dev ) {
+        return 0;
+}
+#endif /* CONFIG_PM */
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("AU1200 IDE driver");
+
+module_init(au_ide_init);
+module_exit(au_ide_exit);
diff -Naur linux-2.6.14/drivers/ide/mips/Makefile linux-mips-2.6.14.orig/drivers/ide/mips/Makefile
--- linux-2.6.14/drivers/ide/mips/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/ide/mips/Makefile	2005-11-17 11:42:56.000000000 -0800
@@ -0,0 +1,4 @@
+obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
+obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
+
+EXTRA_CFLAGS	:= -I../
diff -Naur linux-2.6.14/drivers/ide/mips/swarm.c linux-mips-2.6.14.orig/drivers/ide/mips/swarm.c
--- linux-2.6.14/drivers/ide/mips/swarm.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/ide/mips/swarm.c	2005-11-17 11:42:56.000000000 -0800
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2001, 2002, 2003 Broadcom Corporation
+ * Copyright (C) 2004 MontaVista Software Inc.
+ *	Author:	Manish Lachwani, mlachwani@mvista.com
+ * Copyright (C) 2004  MIPS Technologies, Inc.  All rights reserved.
+ *	Author: Maciej W. Rozycki <macro@mips.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ *  Derived loosely from ide-pmac.c, so:  
+ *  Copyright (C) 1998 Paul Mackerras.
+ *  Copyright (C) 1995-1998 Mark Lord
+ */
+
+/*
+ * Boards with SiByte processors so far have supported IDE devices via
+ * the Generic Bus, PCI bus, and built-in PCMCIA interface.  In all
+ * cases, byte-swapping must be avoided for these devices (whereas
+ * other PCI devices, for example, will require swapping).  Any
+ * SiByte-targetted kernel including IDE support will include this
+ * file.  Probing of a Generic Bus for an IDE device is controlled by
+ * the definition of "SIBYTE_HAVE_IDE", which is provided by
+ * <asm/sibyte/board.h> for Broadcom boards.
+ */
+
+#include <linux/ide.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+
+#include <asm/sibyte/board.h>
+#include <asm/sibyte/sb1250_genbus.h>
+#include <asm/sibyte/sb1250_regs.h>
+
+#define DRV_NAME "ide-swarm"
+
+static struct resource swarm_ide_resource = {
+	.name	= "SWARM GenBus IDE",
+	.flags	= IORESOURCE_MEM,
+};
+
+/*
+ * swarm_ide_probe - if the board header indicates the existence of
+ * Generic Bus IDE, allocate a HWIF for it.
+ */
+void __init swarm_ide_probe(void)
+{
+	ide_hwif_t *hwif;
+	u8 __iomem *base;
+	phys_t offset, size;
+	int i;
+
+	if (!SIBYTE_HAVE_IDE)
+		return;
+
+	/* Find an empty slot.  */
+	for (i = 0; i < MAX_HWIFS; i++) 
+		if (!ide_hwifs[i].io_ports[IDE_DATA_OFFSET])
+			break;
+	if (i >= MAX_HWIFS) {
+		printk(KERN_ERR DRV_NAME ": no free slot for interface\n");
+		return;
+	}
+	hwif = ide_hwifs + i;
+
+	base = ioremap(A_IO_EXT_BASE, 0x800);
+	offset = __raw_readq(base + R_IO_EXT_REG(R_IO_EXT_START_ADDR, IDE_CS));
+	size = __raw_readq(base + R_IO_EXT_REG(R_IO_EXT_MULT_SIZE, IDE_CS));
+	iounmap(base);
+	
+	offset = G_IO_START_ADDR(offset) << S_IO_ADDRBASE;
+	size = (G_IO_MULT_SIZE(size) + 1) << S_IO_REGSIZE;
+	if (offset < A_PHYS_GENBUS || offset >= A_PHYS_GENBUS_END) {
+		printk(KERN_INFO DRV_NAME
+		       ": IDE interface at GenBus disabled\n");
+		return;
+	}
+
+	printk(KERN_INFO DRV_NAME ": IDE interface at GenBus slot %i\n",
+	       IDE_CS);
+
+	swarm_ide_resource.start = offset;
+	swarm_ide_resource.end = offset + size - 1;
+	if (request_resource(&iomem_resource, &swarm_ide_resource)) {
+		printk(KERN_ERR DRV_NAME
+		       ": can't request I/O memory resource\n");
+		return;
+	}
+
+	base = ioremap(offset, size);
+
+	/* Setup MMIO ops.  */
+	default_hwif_mmiops(hwif);
+	/* Prevent resource map manipulation.  */
+	hwif->mmio = 2;
+	hwif->noprobe = 0;
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+		hwif->hw.io_ports[i] =
+				(unsigned long)(base + ((0x1f0 + i) << 5));
+	hwif->hw.io_ports[IDE_CONTROL_OFFSET] =
+				(unsigned long)(base + (0x3f6 << 5));
+	hwif->hw.irq = K_INT_GB_IDE;
+
+	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+	hwif->irq = hwif->hw.irq;
+}
diff -Naur linux-2.6.14/drivers/media/video/indycam.c linux-mips-2.6.14.orig/drivers/media/video/indycam.c
--- linux-2.6.14/drivers/media/video/indycam.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/indycam.c	2005-11-17 11:42:59.000000000 -0800
@@ -9,16 +9,16 @@
  *  published by the Free Software Foundation.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
+#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/major.h>
-#include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/sched.h>
+#include <linux/slab.h>
 
 #include <linux/videodev.h>
 /* IndyCam decodes stream of photons into digital image representation ;-) */
@@ -27,15 +27,15 @@
 
 #include "indycam.h"
 
-//#define INDYCAM_DEBUG
-
-#define INDYCAM_MODULE_VERSION "0.0.3"
+#define INDYCAM_MODULE_VERSION "0.0.5"
 
 MODULE_DESCRIPTION("SGI IndyCam driver");
 MODULE_VERSION(INDYCAM_MODULE_VERSION);
 MODULE_AUTHOR("Mikael Nousiainen <tmnousia@cc.hut.fi>");
 MODULE_LICENSE("GPL");
 
+// #define INDYCAM_DEBUG
+
 #ifdef INDYCAM_DEBUG
 #define dprintk(x...) printk("IndyCam: " x);
 #define indycam_regdump(client) indycam_regdump_debug(client)
@@ -44,18 +44,16 @@
 #define indycam_regdump(client)
 #endif
 
-#define VINO_ADAPTER	(I2C_ALGO_SGI | I2C_HW_SGI_VINO)
-
 struct indycam {
 	struct i2c_client *client;
-	int version;
+	u8 version;
 };
 
 static struct i2c_driver i2c_driver_indycam;
 
-static const unsigned char initseq[] = {
+static const u8 initseq[] = {
 	INDYCAM_CONTROL_AGCENA,		/* INDYCAM_CONTROL */
-	INDYCAM_SHUTTER_DEFAULT,	/* INDYCAM_SHUTTER */
+	INDYCAM_SHUTTER_60,		/* INDYCAM_SHUTTER */
 	INDYCAM_GAIN_DEFAULT,		/* INDYCAM_GAIN */
 	0x00,				/* INDYCAM_BRIGHTNESS (read-only) */
 	INDYCAM_RED_BALANCE_DEFAULT,	/* INDYCAM_RED_BALANCE */
@@ -66,12 +64,11 @@
 
 /* IndyCam register handling */
 
-static int indycam_read_reg(struct i2c_client *client, unsigned char reg,
-			     unsigned char *value)
+static int indycam_read_reg(struct i2c_client *client, u8 reg, u8 *value)
 {
 	int ret;
 
-	if (reg == INDYCAM_RESET) {
+	if (reg == INDYCAM_REG_RESET) {
 		dprintk("indycam_read_reg(): "
 			"skipping write-only register %d\n", reg);
 		*value = 0;
@@ -79,24 +76,24 @@
 	}
 
 	ret = i2c_smbus_read_byte_data(client, reg);
+
 	if (ret < 0) {
 		printk(KERN_ERR "IndyCam: indycam_read_reg(): read failed, "
 		       "register = 0x%02x\n", reg);
 		return ret;
 	}
 
-	*value = (unsigned char)ret;
+	*value = (u8)ret;
 
 	return 0;
 }
 
-static int indycam_write_reg(struct i2c_client *client, unsigned char reg,
-			     unsigned char value)
+static int indycam_write_reg(struct i2c_client *client, u8 reg, u8 value)
 {
 	int err;
 
-	if ((reg == INDYCAM_BRIGHTNESS)
-	    || (reg == INDYCAM_VERSION)) {
+	if ((reg == INDYCAM_REG_BRIGHTNESS)
+	    || (reg == INDYCAM_REG_VERSION)) {
 		dprintk("indycam_write_reg(): "
 			"skipping read-only register %d\n", reg);
 		return 0;
@@ -104,6 +101,7 @@
 
 	dprintk("Writing Reg %d = 0x%02x\n", reg, value);
 	err = i2c_smbus_write_byte_data(client, reg, value);
+
 	if (err) {
 		printk(KERN_ERR "IndyCam: indycam_write_reg(): write failed, "
 		       "register = 0x%02x, value = 0x%02x\n", reg, value);
@@ -111,13 +109,12 @@
 	return err;
 }
 
-static int indycam_write_block(struct i2c_client *client, unsigned char reg,
-				unsigned char length, unsigned char *data)
+static int indycam_write_block(struct i2c_client *client, u8 reg,
+			       u8 length, u8 *data)
 {
-	unsigned char i;
-	int err;
+	int i, err;
 
-	for (i = reg; i < length; i++) {
+	for (i = 0; i < length; i++) {
 		err = indycam_write_reg(client, reg + i, data[i]);
 		if (err)
 			return err;
@@ -132,7 +129,7 @@
 static void indycam_regdump_debug(struct i2c_client *client)
 {
 	int i;
-	unsigned char val;
+	u8 val;
 
 	for (i = 0; i < 9; i++) {
 		indycam_read_reg(client, i, &val);
@@ -141,76 +138,144 @@
 }
 #endif
 
-static int indycam_get_controls(struct i2c_client *client,
-				struct indycam_control *ctrl)
+static int indycam_get_control(struct i2c_client *client,
+			       struct indycam_control *ctrl)
 {
-	unsigned char ctrl_reg;
+	struct indycam *camera = i2c_get_clientdata(client);
+	u8 reg;
+	int ret = 0;
 
-	indycam_read_reg(client, INDYCAM_CONTROL, &ctrl_reg);
-	ctrl->agc = (ctrl_reg & INDYCAM_CONTROL_AGCENA)
-		? INDYCAM_VALUE_ENABLED
-		: INDYCAM_VALUE_DISABLED;
-	ctrl->awb = (ctrl_reg & INDYCAM_CONTROL_AWBCTL)
-		? INDYCAM_VALUE_ENABLED
-		: INDYCAM_VALUE_DISABLED;
-	indycam_read_reg(client, INDYCAM_SHUTTER,
-			 (unsigned char *)&ctrl->shutter);
-	indycam_read_reg(client, INDYCAM_GAIN,
-			 (unsigned char *)&ctrl->gain);
-	indycam_read_reg(client, INDYCAM_RED_BALANCE,
-			 (unsigned char *)&ctrl->red_balance);
-	indycam_read_reg(client, INDYCAM_BLUE_BALANCE,
-			 (unsigned char *)&ctrl->blue_balance);
-	indycam_read_reg(client, INDYCAM_RED_SATURATION,
-			 (unsigned char *)&ctrl->red_saturation);
-	indycam_read_reg(client, INDYCAM_BLUE_SATURATION,
-			 (unsigned char *)&ctrl->blue_saturation);
-	indycam_read_reg(client, INDYCAM_GAMMA,
-			 (unsigned char *)&ctrl->gamma);
+	switch (ctrl->type) {
+	case INDYCAM_CONTROL_AGC:
+	case INDYCAM_CONTROL_AWB:
+		ret = indycam_read_reg(client, INDYCAM_REG_CONTROL, &reg);
+		if (ret)
+			return -EIO;
+		if (ctrl->type == INDYCAM_CONTROL_AGC)
+			ctrl->value = (reg & INDYCAM_CONTROL_AGCENA)
+				? 1 : 0;
+		else
+			ctrl->value = (reg & INDYCAM_CONTROL_AWBCTL)
+				? 1 : 0;
+		break;
+	case INDYCAM_CONTROL_SHUTTER:
+		ret = indycam_read_reg(client, INDYCAM_REG_SHUTTER, &reg);
+		if (ret)
+			return -EIO;
+		ctrl->value = ((s32)reg == 0x00) ? 0xff : ((s32)reg - 1);
+		break;
+	case INDYCAM_CONTROL_GAIN:
+		ret = indycam_read_reg(client, INDYCAM_REG_GAIN, &reg);
+		if (ret)
+			return -EIO;
+		ctrl->value = (s32)reg;
+		break;
+	case INDYCAM_CONTROL_RED_BALANCE:
+		ret = indycam_read_reg(client, INDYCAM_REG_RED_BALANCE, &reg);
+		if (ret)
+			return -EIO;
+		ctrl->value = (s32)reg;
+		break;
+	case INDYCAM_CONTROL_BLUE_BALANCE:
+		ret = indycam_read_reg(client, INDYCAM_REG_BLUE_BALANCE, &reg);
+		if (ret)
+			return -EIO;
+		ctrl->value = (s32)reg;
+		break;
+	case INDYCAM_CONTROL_RED_SATURATION:
+		ret = indycam_read_reg(client,
+				       INDYCAM_REG_RED_SATURATION, &reg);
+		if (ret)
+			return -EIO;
+		ctrl->value = (s32)reg;
+		break;
+	case INDYCAM_CONTROL_BLUE_SATURATION:
+		ret = indycam_read_reg(client,
+				       INDYCAM_REG_BLUE_SATURATION, &reg);
+		if (ret)
+			return -EIO;
+		ctrl->value = (s32)reg;
+		break;
+	case INDYCAM_CONTROL_GAMMA:
+		if (camera->version == CAMERA_VERSION_MOOSE) {
+			ret = indycam_read_reg(client,
+					       INDYCAM_REG_GAMMA, &reg);
+			if (ret)
+				return -EIO;
+			ctrl->value = (s32)reg;
+		} else {
+			ctrl->value = INDYCAM_GAMMA_DEFAULT;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+	}
 
-	return 0;
+	return ret;
 }
 
-static int indycam_set_controls(struct i2c_client *client,
-				struct indycam_control *ctrl)
+static int indycam_set_control(struct i2c_client *client,
+			       struct indycam_control *ctrl)
 {
-	unsigned char ctrl_reg;
+	struct indycam *camera = i2c_get_clientdata(client);
+	u8 reg;
+	int ret = 0;
 
-	indycam_read_reg(client, INDYCAM_CONTROL, &ctrl_reg);
-	if (ctrl->agc != INDYCAM_VALUE_UNCHANGED) {
-		if (ctrl->agc)
-			ctrl_reg |= INDYCAM_CONTROL_AGCENA;
-		else
-			ctrl_reg &= ~INDYCAM_CONTROL_AGCENA;
-	}
-	if (ctrl->awb != INDYCAM_VALUE_UNCHANGED) {
-		if (ctrl->awb)
-			ctrl_reg |= INDYCAM_CONTROL_AWBCTL;
-		else
-			ctrl_reg &= ~INDYCAM_CONTROL_AWBCTL;
-	}
-	indycam_write_reg(client, INDYCAM_CONTROL, ctrl_reg);
+	switch (ctrl->type) {
+	case INDYCAM_CONTROL_AGC:
+	case INDYCAM_CONTROL_AWB:
+		ret = indycam_read_reg(client, INDYCAM_REG_CONTROL, &reg);
+		if (ret)
+			break;
 
-	if (ctrl->shutter >= 0)
-		indycam_write_reg(client, INDYCAM_SHUTTER, ctrl->shutter);
-	if (ctrl->gain >= 0)
-		indycam_write_reg(client, INDYCAM_GAIN, ctrl->gain);
-	if (ctrl->red_balance >= 0)
-		indycam_write_reg(client, INDYCAM_RED_BALANCE,
-				  ctrl->red_balance);
-	if (ctrl->blue_balance >= 0)
-		indycam_write_reg(client, INDYCAM_BLUE_BALANCE,
-				  ctrl->blue_balance);
-	if (ctrl->red_saturation >= 0)
-		indycam_write_reg(client, INDYCAM_RED_SATURATION,
-				  ctrl->red_saturation);
-	if (ctrl->blue_saturation >= 0)
-		indycam_write_reg(client, INDYCAM_BLUE_SATURATION,
-				  ctrl->blue_saturation);
-	if (ctrl->gamma >= 0)
-		indycam_write_reg(client, INDYCAM_GAMMA, ctrl->gamma);
+		if (ctrl->type == INDYCAM_CONTROL_AGC) {
+			if (ctrl->value)
+				reg |= INDYCAM_CONTROL_AGCENA;
+			else
+				reg &= ~INDYCAM_CONTROL_AGCENA;
+		} else {
+			if (ctrl->value)
+				reg |= INDYCAM_CONTROL_AWBCTL;
+			else
+				reg &= ~INDYCAM_CONTROL_AWBCTL;
+		}
 
-	return 0;
+		ret = indycam_write_reg(client, INDYCAM_REG_CONTROL, reg);
+		break;
+	case INDYCAM_CONTROL_SHUTTER:
+		reg = (ctrl->value == 0xff) ? 0x00 : (ctrl->value + 1);
+		ret = indycam_write_reg(client, INDYCAM_REG_SHUTTER, reg);
+		break;
+	case INDYCAM_CONTROL_GAIN:
+		ret = indycam_write_reg(client, INDYCAM_REG_GAIN, ctrl->value);
+		break;
+	case INDYCAM_CONTROL_RED_BALANCE:
+		ret = indycam_write_reg(client, INDYCAM_REG_RED_BALANCE,
+					ctrl->value);
+		break;
+	case INDYCAM_CONTROL_BLUE_BALANCE:
+		ret = indycam_write_reg(client, INDYCAM_REG_BLUE_BALANCE,
+					ctrl->value);
+		break;
+	case INDYCAM_CONTROL_RED_SATURATION:
+		ret = indycam_write_reg(client, INDYCAM_REG_RED_SATURATION,
+					ctrl->value);
+		break;
+	case INDYCAM_CONTROL_BLUE_SATURATION:
+		ret = indycam_write_reg(client, INDYCAM_REG_BLUE_SATURATION,
+					ctrl->value);
+		break;
+	case INDYCAM_CONTROL_GAMMA:
+		if (camera->version == CAMERA_VERSION_MOOSE) {
+			ret = indycam_write_reg(client, INDYCAM_REG_GAMMA,
+						ctrl->value);
+		}
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
 }
 
 /* I2C-interface */
@@ -249,7 +314,8 @@
 	if (err)
 		goto out_free_camera;
 
-	camera->version = i2c_smbus_read_byte_data(client, INDYCAM_VERSION);
+	camera->version = i2c_smbus_read_byte_data(client,
+						   INDYCAM_REG_VERSION);
 	if (camera->version != CAMERA_VERSION_INDY &&
 	    camera->version != CAMERA_VERSION_MOOSE) {
 		err = -ENODEV;
@@ -262,8 +328,7 @@
 	indycam_regdump(client);
 
 	// initialize
-	err = indycam_write_block(client, 0, sizeof(initseq),
-				  (unsigned char *)&initseq);
+	err = indycam_write_block(client, 0, sizeof(initseq), (u8 *)&initseq);
 	if (err) {
 		printk(KERN_ERR "IndyCam initalization failed\n");
 		err = -EIO;
@@ -273,11 +338,10 @@
 	indycam_regdump(client);
 
 	// white balance
-	err = indycam_write_reg(client, INDYCAM_CONTROL,
+	err = indycam_write_reg(client, INDYCAM_REG_CONTROL,
 			  INDYCAM_CONTROL_AGCENA | INDYCAM_CONTROL_AWBCTL);
 	if (err) {
-		printk(KERN_ERR "IndyCam white balance "
-		       "initialization failed\n");
+		printk(KERN_ERR "IndyCam: White balancing camera failed\n");
 		err = -EIO;
 		goto out_detach_client;
 	}
@@ -300,7 +364,7 @@
 static int indycam_probe(struct i2c_adapter *adap)
 {
 	/* Indy specific crap */
-	if (adap->id == VINO_ADAPTER)
+	if (adap->id == I2C_HW_SGI_VINO)
 		return indycam_attach(adap, INDYCAM_ADDR, 0);
 	/* Feel free to add probe here :-) */
 	return -ENODEV;
@@ -373,13 +437,11 @@
 		/* TODO: convert values for indycam_set_controls() */
 		break;
 	}
-	case DECODER_INDYCAM_GET_CONTROLS: {
-		struct indycam_control *ctrl = arg;
-		indycam_get_controls(client, ctrl);
-	}
-	case DECODER_INDYCAM_SET_CONTROLS: {
-		struct indycam_control *ctrl = arg;
-		indycam_set_controls(client, ctrl);
+	case DECODER_INDYCAM_GET_CONTROL: {
+		return indycam_get_control(client, arg);
+	}
+	case DECODER_INDYCAM_SET_CONTROL: {
+		return indycam_set_control(client, arg);
 	}
 	default:
 		return -EINVAL;
@@ -390,12 +452,12 @@
 
 static struct i2c_driver i2c_driver_indycam = {
 	.owner		= THIS_MODULE,
-	.name 		= "indycam",
-	.id 		= I2C_DRIVERID_INDYCAM,
-	.flags 		= I2C_DF_NOTIFY,
+	.name		= "indycam",
+	.id		= I2C_DRIVERID_INDYCAM,
+	.flags		= I2C_DF_NOTIFY,
 	.attach_adapter = indycam_probe,
-	.detach_client 	= indycam_detach,
-	.command 	= indycam_command,
+	.detach_client	= indycam_detach,
+	.command	= indycam_command,
 };
 
 static int __init indycam_init(void)
diff -Naur linux-2.6.14/drivers/media/video/indycam.h linux-mips-2.6.14.orig/drivers/media/video/indycam.h
--- linux-2.6.14/drivers/media/video/indycam.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/indycam.h	2005-11-17 11:42:59.000000000 -0800
@@ -22,21 +22,21 @@
 #define INDYCAM_VERSION_MINOR(x)	((x) & 0x0f)
 
 /* Register bus addresses */
-#define INDYCAM_CONTROL			0x00
-#define INDYCAM_SHUTTER			0x01
-#define INDYCAM_GAIN			0x02
-#define INDYCAM_BRIGHTNESS		0x03 /* read-only */
-#define INDYCAM_RED_BALANCE		0x04
-#define INDYCAM_BLUE_BALANCE		0x05
-#define INDYCAM_RED_SATURATION		0x06
-#define INDYCAM_BLUE_SATURATION		0x07
-#define INDYCAM_GAMMA			0x08
-#define INDYCAM_VERSION			0x0e /* read-only */
-#define INDYCAM_RESET			0x0f /* write-only */
-
-#define INDYCAM_LED			0x46
-#define INDYCAM_ORIENTATION		0x47
-#define INDYCAM_BUTTON			0x48
+#define INDYCAM_REG_CONTROL		0x00
+#define INDYCAM_REG_SHUTTER		0x01
+#define INDYCAM_REG_GAIN		0x02
+#define INDYCAM_REG_BRIGHTNESS		0x03 /* read-only */
+#define INDYCAM_REG_RED_BALANCE		0x04
+#define INDYCAM_REG_BLUE_BALANCE	0x05
+#define INDYCAM_REG_RED_SATURATION	0x06
+#define INDYCAM_REG_BLUE_SATURATION	0x07
+#define INDYCAM_REG_GAMMA		0x08
+#define INDYCAM_REG_VERSION		0x0e /* read-only */
+#define INDYCAM_REG_RESET		0x0f /* write-only */
+
+#define INDYCAM_REG_LED			0x46
+#define INDYCAM_REG_ORIENTATION		0x47
+#define INDYCAM_REG_BUTTON		0x48
 
 /* Field definitions of registers */
 #define INDYCAM_CONTROL_AGCENA		(1<<0) /* automatic gain control */
@@ -59,13 +59,14 @@
 #define INDYCAM_ORIENTATION_BOTTOM_TO_TOP	0x40
 #define INDYCAM_BUTTON_RELEASED			0x10
 
+/* Values for controls */
 #define INDYCAM_SHUTTER_MIN		0x00
 #define INDYCAM_SHUTTER_MAX		0xff
 #define INDYCAM_GAIN_MIN                0x00
 #define INDYCAM_GAIN_MAX                0xff
-#define INDYCAM_RED_BALANCE_MIN 	0x00 /* the effect is the opposite? */
-#define INDYCAM_RED_BALANCE_MAX 	0xff
-#define INDYCAM_BLUE_BALANCE_MIN        0x00 /* the effect is the opposite? */
+#define INDYCAM_RED_BALANCE_MIN		0x00
+#define INDYCAM_RED_BALANCE_MAX		0xff
+#define INDYCAM_BLUE_BALANCE_MIN        0x00
 #define INDYCAM_BLUE_BALANCE_MAX        0xff
 #define INDYCAM_RED_SATURATION_MIN      0x00
 #define INDYCAM_RED_SATURATION_MAX      0xff
@@ -74,34 +75,9 @@
 #define INDYCAM_GAMMA_MIN		0x00
 #define INDYCAM_GAMMA_MAX		0xff
 
-/* Driver interface definitions */
-
-#define INDYCAM_VALUE_ENABLED		1
-#define INDYCAM_VALUE_DISABLED		0
-#define INDYCAM_VALUE_UNCHANGED		-1
-
-/* When setting controls, a value of -1 leaves the control unchanged. */
-struct indycam_control {
-	int agc;	/* boolean */
-	int awb;	/* boolean */
-	int shutter;
-	int gain;
-	int red_balance;
-	int blue_balance;
-	int red_saturation;
-	int blue_saturation;
-	int gamma;
-};
-
-#define	DECODER_INDYCAM_GET_CONTROLS	_IOR('d', 193, struct indycam_control)
-#define	DECODER_INDYCAM_SET_CONTROLS	_IOW('d', 194, struct indycam_control)
-
-/* Default values for controls */
-
-#define INDYCAM_AGC_DEFAULT		INDYCAM_VALUE_ENABLED
-#define INDYCAM_AWB_DEFAULT		INDYCAM_VALUE_ENABLED
-
-#define INDYCAM_SHUTTER_DEFAULT		INDYCAM_SHUTTER_60
+#define INDYCAM_AGC_DEFAULT		1
+#define INDYCAM_AWB_DEFAULT		0
+#define INDYCAM_SHUTTER_DEFAULT		0xff
 #define INDYCAM_GAIN_DEFAULT		0x80
 #define INDYCAM_RED_BALANCE_DEFAULT	0x18
 #define INDYCAM_BLUE_BALANCE_DEFAULT	0xa4
@@ -109,4 +85,24 @@
 #define INDYCAM_BLUE_SATURATION_DEFAULT	0xc0
 #define INDYCAM_GAMMA_DEFAULT		0x80
 
+/* Driver interface definitions */
+
+#define INDYCAM_CONTROL_AGC			0	/* boolean */
+#define INDYCAM_CONTROL_AWB			1	/* boolean */
+#define INDYCAM_CONTROL_SHUTTER			2
+#define INDYCAM_CONTROL_GAIN			3
+#define INDYCAM_CONTROL_RED_BALANCE		4
+#define INDYCAM_CONTROL_BLUE_BALANCE		5
+#define INDYCAM_CONTROL_RED_SATURATION		6
+#define INDYCAM_CONTROL_BLUE_SATURATION		7
+#define INDYCAM_CONTROL_GAMMA			8
+
+struct indycam_control {
+	u8 type;
+	s32 value;
+};
+
+#define	DECODER_INDYCAM_GET_CONTROL	_IOR('d', 193, struct indycam_control)
+#define	DECODER_INDYCAM_SET_CONTROL	_IOW('d', 194, struct indycam_control)
+
 #endif
diff -Naur linux-2.6.14/drivers/media/video/Kconfig linux-mips-2.6.14.orig/drivers/media/video/Kconfig
--- linux-2.6.14/drivers/media/video/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/Kconfig	2005-11-17 11:42:58.000000000 -0800
@@ -91,6 +91,14 @@
 	  Check out <file:Documentation/video4linux/w9966.txt> for more
 	  information.
 
+config VIDEO_SWARM_7114H
+	tristate "Philips SAA7114H for SiByte BCM91250A"
+	depends on SIBYTE_SWARM && VIDEO_DEV && I2C_ALGO_SIBYTE
+	help
+	  Say Y or M to build the video4linux driver for the Philips
+	  SAA7114H video decoder on Broadcom SWARM board (BCM91250A).
+	  The decoder chip is on the BCM1250's "E2" 8-bit FIFO port.
+
 config VIDEO_CPIA
 	tristate "CPiA Video For Linux"
 	depends on VIDEO_DEV
diff -Naur linux-2.6.14/drivers/media/video/Makefile linux-mips-2.6.14.orig/drivers/media/video/Makefile
--- linux-2.6.14/drivers/media/video/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/Makefile	2005-11-17 11:42:58.000000000 -0800
@@ -52,6 +52,9 @@
 obj-$(CONFIG_VIDEO_BTCX)  += btcx-risc.o
 obj-$(CONFIG_VIDEO_TVEEPROM) += tveeprom.o
 
+obj-$(CONFIG_VIDEO_SWARM_7114H) += swarm_saa7114h.o
+obj-$(CONFIG_TUNER_3036) += tuner-3036.o
+
 obj-$(CONFIG_VIDEO_M32R_AR_M64278) += arv.o
 
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
diff -Naur linux-2.6.14/drivers/media/video/saa7191.c linux-mips-2.6.14.orig/drivers/media/video/saa7191.c
--- linux-2.6.14/drivers/media/video/saa7191.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/saa7191.c	2005-11-17 11:42:59.000000000 -0800
@@ -9,16 +9,16 @@
  *  published by the Free Software Foundation.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
+#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/major.h>
-#include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/sched.h>
+#include <linux/slab.h>
 
 #include <linux/videodev.h>
 #include <linux/video_decoder.h>
@@ -26,73 +26,95 @@
 
 #include "saa7191.h"
 
-#define SAA7191_MODULE_VERSION "0.0.3"
+#define SAA7191_MODULE_VERSION	"0.0.5"
 
 MODULE_DESCRIPTION("Philips SAA7191 video decoder driver");
 MODULE_VERSION(SAA7191_MODULE_VERSION);
 MODULE_AUTHOR("Mikael Nousiainen <tmnousia@cc.hut.fi>");
 MODULE_LICENSE("GPL");
 
-#define VINO_ADAPTER	(I2C_ALGO_SGI | I2C_HW_SGI_VINO)
+// #define SAA7191_DEBUG
+
+#ifdef SAA7191_DEBUG
+#define dprintk(x...) printk("SAA7191: " x);
+#else
+#define dprintk(x...)
+#endif
+
+#define SAA7191_SYNC_COUNT	30
+#define SAA7191_SYNC_DELAY	100	/* milliseconds */
 
 struct saa7191 {
 	struct i2c_client *client;
 
 	/* the register values are stored here as the actual
 	 * I2C-registers are write-only */
-	unsigned char reg[25];
+	u8 reg[25];
 
-	unsigned char norm;
-	unsigned char input;
+	int input;
+	int norm;
 };
 
 static struct i2c_driver i2c_driver_saa7191;
 
-static const unsigned char initseq[] = {
+static const u8 initseq[] = {
 	0,	/* Subaddress */
-	0x50,	/* SAA7191_REG_IDEL */
-	0x30,	/* SAA7191_REG_HSYB */
-	0x00,	/* SAA7191_REG_HSYS */
-	0xe8,	/* SAA7191_REG_HCLB */
-	0xb6,	/* SAA7191_REG_HCLS */
-	0xf4,	/* SAA7191_REG_HPHI */
-	0x01,	/* SAA7191_REG_LUMA - chrominance trap active (CVBS) */
-	0x00,	/* SAA7191_REG_HUEC */
-	0xf8,	/* SAA7191_REG_CKTQ */
-	0xf8,	/* SAA7191_REG_CKTS */
-	0x90,	/* SAA7191_REG_PLSE */
-	0x90,	/* SAA7191_REG_SESE */
-	0x00,	/* SAA7191_REG_GAIN */
-	0x0c,	/* SAA7191_REG_STDC - not SECAM, slow time constant */
-	0x78,	/* SAA7191_REG_IOCK - chrominance from CVBS, GPSW1 & 2 off */
-	0x99,	/* SAA7191_REG_CTL3 - automatic field detection */
-	0x00,	/* SAA7191_REG_CTL4 */
-	0x2c,	/* SAA7191_REG_CHCV */
+
+	0x50,	/* (0x50) SAA7191_REG_IDEL */
+
+	/* 50 Hz signal timing */
+	0x30,	/* (0x30) SAA7191_REG_HSYB */
+	0x00,	/* (0x00) SAA7191_REG_HSYS */
+	0xe8,	/* (0xe8) SAA7191_REG_HCLB */
+	0xb6,	/* (0xb6) SAA7191_REG_HCLS */
+	0xf4,	/* (0xf4) SAA7191_REG_HPHI */
+
+	/* control */
+	SAA7191_LUMA_APER_1,	/* (0x01) SAA7191_REG_LUMA - CVBS mode */
+	0x00,	/* (0x00) SAA7191_REG_HUEC */
+	0xf8,	/* (0xf8) SAA7191_REG_CKTQ */
+	0xf8,	/* (0xf8) SAA7191_REG_CKTS */
+	0x90,	/* (0x90) SAA7191_REG_PLSE */
+	0x90,	/* (0x90) SAA7191_REG_SESE */
+	0x00,	/* (0x00) SAA7191_REG_GAIN */
+	SAA7191_STDC_NFEN | SAA7191_STDC_HRMV,	/* (0x0c) SAA7191_REG_STDC
+						 * - not SECAM,
+						 * slow time constant */
+	SAA7191_IOCK_OEDC | SAA7191_IOCK_OEHS | SAA7191_IOCK_OEVS
+	| SAA7191_IOCK_OEDY,	/* (0x78) SAA7191_REG_IOCK
+				 * - chroma from CVBS, GPSW1 & 2 off */
+	SAA7191_CTL3_AUFD | SAA7191_CTL3_SCEN | SAA7191_CTL3_OFTS
+	| SAA7191_CTL3_YDEL0,	/* (0x99) SAA7191_REG_CTL3
+				 * - automatic field detection */
+	0x00,	/* (0x00) SAA7191_REG_CTL4 */
+	0x2c,	/* (0x2c) SAA7191_REG_CHCV - PAL nominal value */
 	0x00,	/* unused */
 	0x00,	/* unused */
-	0x34,	/* SAA7191_REG_HS6B */
-	0x0a,	/* SAA7191_REG_HS6S */
-	0xf4,	/* SAA7191_REG_HC6B */
-	0xce,	/* SAA7191_REG_HC6S */
-	0xf4,	/* SAA7191_REG_HP6I */
+
+	/* 60 Hz signal timing */
+	0x34,	/* (0x34) SAA7191_REG_HS6B */
+	0x0a,	/* (0x0a) SAA7191_REG_HS6S */
+	0xf4,	/* (0xf4) SAA7191_REG_HC6B */
+	0xce,	/* (0xce) SAA7191_REG_HC6S */
+	0xf4,	/* (0xf4) SAA7191_REG_HP6I */
 };
 
 /* SAA7191 register handling */
 
-static unsigned char saa7191_read_reg(struct i2c_client *client,
-				      unsigned char reg)
+static u8 saa7191_read_reg(struct i2c_client *client,
+			   u8 reg)
 {
 	return ((struct saa7191 *)i2c_get_clientdata(client))->reg[reg];
 }
 
 static int saa7191_read_status(struct i2c_client *client,
-			       unsigned char *value)
+			       u8 *value)
 {
 	int ret;
 
 	ret = i2c_master_recv(client, value, 1);
 	if (ret < 0) {
-		printk(KERN_ERR "SAA7191: saa7191_read_status(): read failed");
+		printk(KERN_ERR "SAA7191: saa7191_read_status(): read failed\n");
 		return ret;
 	}
 
@@ -100,17 +122,16 @@
 }
 
 
-static int saa7191_write_reg(struct i2c_client *client, unsigned char reg,
-			     unsigned char value)
+static int saa7191_write_reg(struct i2c_client *client, u8 reg,
+			     u8 value)
 {
-
 	((struct saa7191 *)i2c_get_clientdata(client))->reg[reg] = value;
 	return i2c_smbus_write_byte_data(client, reg, value);
 }
 
 /* the first byte of data must be the first subaddress number (register) */
 static int saa7191_write_block(struct i2c_client *client,
-			       unsigned char length, unsigned char *data)
+			       u8 length, u8 *data)
 {
 	int i;
 	int ret;
@@ -123,7 +144,7 @@
 	ret = i2c_master_send(client, data, length);
 	if (ret < 0) {
 		printk(KERN_ERR "SAA7191: saa7191_write_block(): "
-		       "write failed");
+		       "write failed\n");
 		return ret;
 	}
 
@@ -134,8 +155,9 @@
 
 static int saa7191_set_input(struct i2c_client *client, int input)
 {
-	unsigned char luma = saa7191_read_reg(client, SAA7191_REG_LUMA);
-	unsigned char iock = saa7191_read_reg(client, SAA7191_REG_IOCK);
+	struct saa7191 *decoder = i2c_get_clientdata(client);
+	u8 luma = saa7191_read_reg(client, SAA7191_REG_LUMA);
+	u8 iock = saa7191_read_reg(client, SAA7191_REG_IOCK);
 	int err;
 
 	switch (input) {
@@ -161,32 +183,20 @@
 	if (err)
 		return -EIO;
 
+	decoder->input = input;
+
 	return 0;
 }
 
 static int saa7191_set_norm(struct i2c_client *client, int norm)
 {
 	struct saa7191 *decoder = i2c_get_clientdata(client);
-	unsigned char stdc = saa7191_read_reg(client, SAA7191_REG_STDC);
-	unsigned char ctl3 = saa7191_read_reg(client, SAA7191_REG_CTL3);
-	unsigned char chcv = saa7191_read_reg(client, SAA7191_REG_CHCV);
+	u8 stdc = saa7191_read_reg(client, SAA7191_REG_STDC);
+	u8 ctl3 = saa7191_read_reg(client, SAA7191_REG_CTL3);
+	u8 chcv = saa7191_read_reg(client, SAA7191_REG_CHCV);
 	int err;
 
 	switch(norm) {
-	case SAA7191_NORM_AUTO: {
-		unsigned char status;
-
-		// does status depend on current norm ?
-		if (saa7191_read_status(client, &status))
-			return -EIO;
-
-		stdc &= ~SAA7191_STDC_SECS;
-		ctl3 &= ~SAA7191_CTL3_FSEL;
-		ctl3 |= SAA7191_CTL3_AUFD;
-		chcv = (status & SAA7191_STATUS_FIDT)
-			       ? SAA7191_CHCV_NTSC : SAA7191_CHCV_PAL;
-		break;
-	}
 	case SAA7191_NORM_PAL:
 		stdc &= ~SAA7191_STDC_SECS;
 		ctl3 &= ~(SAA7191_CTL3_AUFD | SAA7191_CTL3_FSEL);
@@ -219,60 +229,335 @@
 
 	decoder->norm = norm;
 
+	dprintk("ctl3: %02x stdc: %02x chcv: %02x\n", ctl3,
+		stdc, chcv);
+	dprintk("norm: %d\n", norm);
+
 	return 0;
 }
 
-static int saa7191_get_controls(struct i2c_client *client,
-				struct saa7191_control *ctrl)
+static int saa7191_wait_for_signal(struct i2c_client *client, u8 *status)
 {
-	unsigned char hue = saa7191_read_reg(client, SAA7191_REG_HUEC);
-	unsigned char stdc = saa7191_read_reg(client, SAA7191_REG_STDC);
+	int i = 0;
 
-	if (hue < 0x80) {
-		hue += 0x80;
-	} else {
-		hue -= 0x80;
+	dprintk("Checking for signal...\n");
+
+	for (i = 0; i < SAA7191_SYNC_COUNT; i++) {
+		if (saa7191_read_status(client, status))
+			return -EIO;
+
+		if (((*status) & SAA7191_STATUS_HLCK) == 0) {
+			dprintk("Signal found\n");
+			return 0;
+		}
+
+		msleep(SAA7191_SYNC_DELAY);
 	}
-	ctrl->hue = hue;
 
-	ctrl->vtrc = (stdc & SAA7191_STDC_VTRC)
-		? SAA7191_VALUE_ENABLED : SAA7191_VALUE_DISABLED;
+	dprintk("No signal\n");
 
-	return 0;
+	return -EBUSY;
 }
 
-static int saa7191_set_controls(struct i2c_client *client,
-				struct saa7191_control *ctrl)
+static int saa7191_autodetect_norm_extended(struct i2c_client *client)
 {
-	int err;
+	u8 stdc = saa7191_read_reg(client, SAA7191_REG_STDC);
+	u8 ctl3 = saa7191_read_reg(client, SAA7191_REG_CTL3);
+	u8 status;
+	int err = 0;
 
-	if (ctrl->hue >= 0) {
-		unsigned char hue = ctrl->hue & 0xff;
-		if (hue < 0x80) {
-			hue += 0x80;
-		} else {
-			hue -= 0x80;
+	dprintk("SAA7191 extended signal auto-detection...\n");
+
+	stdc &= ~SAA7191_STDC_SECS;
+	ctl3 &= ~(SAA7191_CTL3_FSEL);
+
+	err = saa7191_write_reg(client, SAA7191_REG_STDC, stdc);
+	if (err) {
+		err = -EIO;
+		goto out;
+	}
+	err = saa7191_write_reg(client, SAA7191_REG_CTL3, ctl3);
+	if (err) {
+		err = -EIO;
+		goto out;
+	}
+
+	ctl3 |= SAA7191_CTL3_AUFD;
+	err = saa7191_write_reg(client, SAA7191_REG_CTL3, ctl3);
+	if (err) {
+		err = -EIO;
+		goto out;
+	}
+
+	msleep(SAA7191_SYNC_DELAY);
+
+	err = saa7191_wait_for_signal(client, &status);
+	if (err)
+		goto out;
+
+	if (status & SAA7191_STATUS_FIDT) {
+		/* 60Hz signal -> NTSC */
+		dprintk("60Hz signal: NTSC\n");
+		return saa7191_set_norm(client, SAA7191_NORM_NTSC);
+	}
+
+	/* 50Hz signal */
+	dprintk("50Hz signal: Trying PAL...\n");
+
+	/* try PAL first */
+	err = saa7191_set_norm(client, SAA7191_NORM_PAL);
+	if (err)
+		goto out;
+
+	msleep(SAA7191_SYNC_DELAY);
+
+	err = saa7191_wait_for_signal(client, &status);
+	if (err)
+		goto out;
+
+	/* not 50Hz ? */
+	if (status & SAA7191_STATUS_FIDT) {
+		dprintk("No 50Hz signal\n");
+		err = -EAGAIN;
+		goto out;
+	}
+
+	if (status & SAA7191_STATUS_CODE) {
+		dprintk("PAL\n");
+		return 0;
+	}
+
+	dprintk("No color detected with PAL - Trying SECAM...\n");
+
+	/* no color detected ? -> try SECAM */
+	err = saa7191_set_norm(client,
+			       SAA7191_NORM_SECAM);
+	if (err)
+		goto out;
+
+	msleep(SAA7191_SYNC_DELAY);
+
+	err = saa7191_wait_for_signal(client, &status);
+	if (err)
+		goto out;
+
+	/* not 50Hz ? */
+	if (status & SAA7191_STATUS_FIDT) {
+		dprintk("No 50Hz signal\n");
+		err = -EAGAIN;
+		goto out;
+	}
+
+	if (status & SAA7191_STATUS_CODE) {
+		/* Color detected -> SECAM */
+		dprintk("SECAM\n");
+		return 0;
+	}
+
+	dprintk("No color detected with SECAM - Going back to PAL.\n");
+
+	/* still no color detected ?
+	 * -> set norm back to PAL */
+	err = saa7191_set_norm(client,
+			       SAA7191_NORM_PAL);
+	if (err)
+		goto out;
+
+out:
+	ctl3 = saa7191_read_reg(client, SAA7191_REG_CTL3);
+	if (ctl3 & SAA7191_CTL3_AUFD) {
+		ctl3 &= ~(SAA7191_CTL3_AUFD);
+		err = saa7191_write_reg(client, SAA7191_REG_CTL3, ctl3);
+		if (err) {
+			err = -EIO;
 		}
-		err = saa7191_write_reg(client, SAA7191_REG_HUEC, hue);
-		if (err)
-			return -EIO;
 	}
-	if (ctrl->vtrc >= 0) {
-		unsigned char stdc =
-			saa7191_read_reg(client, SAA7191_REG_STDC);
 
-		if (ctrl->vtrc) {
-			stdc |= SAA7191_STDC_VTRC;
-		} else {
-			stdc &= ~SAA7191_STDC_VTRC;
+	return err;
+}
+
+static int saa7191_autodetect_norm(struct i2c_client *client)
+{
+	u8 status;
+
+	dprintk("SAA7191 signal auto-detection...\n");
+
+	dprintk("Reading status...\n");
+
+	if (saa7191_read_status(client, &status))
+		return -EIO;
+
+	dprintk("Checking for signal...\n");
+
+	/* no signal ? */
+	if (status & SAA7191_STATUS_HLCK) {
+		dprintk("No signal\n");
+		return -EBUSY;
+	}
+
+	dprintk("Signal found\n");
+
+	if (status & SAA7191_STATUS_FIDT) {
+		/* 60hz signal -> NTSC */
+		dprintk("NTSC\n");
+		return saa7191_set_norm(client, SAA7191_NORM_NTSC);
+	} else {
+		/* 50hz signal -> PAL */
+		dprintk("PAL\n");
+		return saa7191_set_norm(client, SAA7191_NORM_PAL);
+	}
+}
+
+static int saa7191_get_control(struct i2c_client *client,
+			       struct saa7191_control *ctrl)
+{
+	u8 reg;
+	int ret = 0;
+
+	switch (ctrl->type) {
+	case SAA7191_CONTROL_BANDPASS:
+	case SAA7191_CONTROL_BANDPASS_WEIGHT:
+	case SAA7191_CONTROL_CORING:
+		reg = saa7191_read_reg(client, SAA7191_REG_LUMA);
+		switch (ctrl->type) {
+		case SAA7191_CONTROL_BANDPASS:
+			ctrl->value = ((s32)reg & SAA7191_LUMA_BPSS_MASK)
+				>> SAA7191_LUMA_BPSS_SHIFT;
+			break;
+		case SAA7191_CONTROL_BANDPASS_WEIGHT:
+			ctrl->value = ((s32)reg & SAA7191_LUMA_APER_MASK)
+				>> SAA7191_LUMA_APER_SHIFT;
+			break;
+		case SAA7191_CONTROL_CORING:
+			ctrl->value = ((s32)reg & SAA7191_LUMA_CORI_MASK)
+				>> SAA7191_LUMA_CORI_SHIFT;
+			break;
 		}
+		break;
+	case SAA7191_CONTROL_FORCE_COLOUR:
+	case SAA7191_CONTROL_CHROMA_GAIN:
+		reg = saa7191_read_reg(client, SAA7191_REG_GAIN);
+		if (ctrl->type == SAA7191_CONTROL_FORCE_COLOUR)
+			ctrl->value = ((s32)reg & SAA7191_GAIN_COLO) ? 1 : 0;
+		else
+			ctrl->value = ((s32)reg & SAA7191_GAIN_LFIS_MASK)
+				>> SAA7191_GAIN_LFIS_SHIFT;
+		break;
+	case SAA7191_CONTROL_HUE:
+		reg = saa7191_read_reg(client, SAA7191_REG_HUEC);
+		if (reg < 0x80)
+			reg += 0x80;
+		else
+			reg -= 0x80;
+		ctrl->value = (s32)reg;
+		break;
+	case SAA7191_CONTROL_VTRC:
+		reg = saa7191_read_reg(client, SAA7191_REG_STDC);
+		ctrl->value = ((s32)reg & SAA7191_STDC_VTRC) ? 1 : 0;
+		break;
+	case SAA7191_CONTROL_LUMA_DELAY:
+		reg = saa7191_read_reg(client, SAA7191_REG_CTL3);
+		ctrl->value = ((s32)reg & SAA7191_CTL3_YDEL_MASK)
+			>> SAA7191_CTL3_YDEL_SHIFT;
+		if (ctrl->value >= 4)
+			ctrl->value -= 8;
+		break;
+	case SAA7191_CONTROL_VNR:
+		reg = saa7191_read_reg(client, SAA7191_REG_CTL4);
+		ctrl->value = ((s32)reg & SAA7191_CTL4_VNOI_MASK)
+			>> SAA7191_CTL4_VNOI_SHIFT;
+		break;
+	default:
+		ret = -EINVAL;
+	}
 
-		err = saa7191_write_reg(client, SAA7191_REG_STDC, stdc);
-		if (err)
-			return -EIO;
+	return ret;
+}
+
+static int saa7191_set_control(struct i2c_client *client,
+			       struct saa7191_control *ctrl)
+{
+	u8 reg;
+	int ret = 0;
+
+	switch (ctrl->type) {
+	case SAA7191_CONTROL_BANDPASS:
+	case SAA7191_CONTROL_BANDPASS_WEIGHT:
+	case SAA7191_CONTROL_CORING:
+		reg = saa7191_read_reg(client, SAA7191_REG_LUMA);
+		switch (ctrl->type) {
+		case SAA7191_CONTROL_BANDPASS:
+			reg &= ~SAA7191_LUMA_BPSS_MASK;
+			reg |= (ctrl->value << SAA7191_LUMA_BPSS_SHIFT)
+				& SAA7191_LUMA_BPSS_MASK;
+			break;
+		case SAA7191_CONTROL_BANDPASS_WEIGHT:
+			reg &= ~SAA7191_LUMA_APER_MASK;
+			reg |= (ctrl->value << SAA7191_LUMA_APER_SHIFT)
+				& SAA7191_LUMA_APER_MASK;
+			break;
+		case SAA7191_CONTROL_CORING:
+			reg &= ~SAA7191_LUMA_CORI_MASK;
+			reg |= (ctrl->value << SAA7191_LUMA_CORI_SHIFT)
+				& SAA7191_LUMA_CORI_MASK;
+			break;
+		}
+		ret = saa7191_write_reg(client, SAA7191_REG_LUMA, reg);
+		break;
+	case SAA7191_CONTROL_FORCE_COLOUR:
+	case SAA7191_CONTROL_CHROMA_GAIN:
+		reg = saa7191_read_reg(client, SAA7191_REG_GAIN);
+		if (ctrl->type == SAA7191_CONTROL_FORCE_COLOUR) {
+			if (ctrl->value)
+				reg |= SAA7191_GAIN_COLO;
+			else
+				reg &= ~SAA7191_GAIN_COLO;
+		} else {
+			reg &= ~SAA7191_GAIN_LFIS_MASK;
+			reg |= (ctrl->value << SAA7191_GAIN_LFIS_SHIFT)
+				& SAA7191_GAIN_LFIS_MASK;
+		}
+		ret = saa7191_write_reg(client, SAA7191_REG_GAIN, reg);
+		break;
+	case SAA7191_CONTROL_HUE:
+		reg = ctrl->value & 0xff;
+		if (reg < 0x80)
+			reg += 0x80;
+		else
+			reg -= 0x80;
+		ret = saa7191_write_reg(client, SAA7191_REG_HUEC, reg);
+		break;
+	case SAA7191_CONTROL_VTRC:
+		reg = saa7191_read_reg(client, SAA7191_REG_STDC);
+		if (ctrl->value)
+			reg |= SAA7191_STDC_VTRC;
+		else
+			reg &= ~SAA7191_STDC_VTRC;
+		ret = saa7191_write_reg(client, SAA7191_REG_STDC, reg);
+		break;
+	case SAA7191_CONTROL_LUMA_DELAY: {
+		s32 value = ctrl->value;
+		if (value < 0)
+			value += 8;
+		reg = saa7191_read_reg(client, SAA7191_REG_CTL3);
+		reg &= ~SAA7191_CTL3_YDEL_MASK;
+		reg |= (value << SAA7191_CTL3_YDEL_SHIFT)
+			& SAA7191_CTL3_YDEL_MASK;
+		ret = saa7191_write_reg(client, SAA7191_REG_CTL3, reg);
+		break;
+	}
+	case SAA7191_CONTROL_VNR:
+		reg = saa7191_read_reg(client, SAA7191_REG_CTL4);
+		reg &= ~SAA7191_CTL4_VNOI_MASK;
+		reg |= (ctrl->value << SAA7191_CTL4_VNOI_SHIFT)
+			& SAA7191_CTL4_VNOI_MASK;
+		ret = saa7191_write_reg(client, SAA7191_REG_CTL4, reg);
+		break;
+	default:
+		ret = -EINVAL;
 	}
 
-	return 0;
+	return ret;
 }
 
 /* I2C-interface */
@@ -311,11 +596,7 @@
 	if (err)
 		goto out_free_decoder;
 
-	decoder->input = SAA7191_INPUT_COMPOSITE;
-	decoder->norm = SAA7191_NORM_AUTO;
-
-	err = saa7191_write_block(client, sizeof(initseq),
-				  (unsigned char *)initseq);
+	err = saa7191_write_block(client, sizeof(initseq), (u8 *)initseq);
 	if (err) {
 		printk(KERN_ERR "SAA7191 initialization failed\n");
 		goto out_detach_client;
@@ -323,6 +604,14 @@
 
 	printk(KERN_INFO "SAA7191 initialized\n");
 
+	decoder->input = SAA7191_INPUT_COMPOSITE;
+	decoder->norm = SAA7191_NORM_PAL;
+
+	err = saa7191_autodetect_norm(client);
+	if (err && (err != -EBUSY)) {
+		printk(KERN_ERR "SAA7191: Signal auto-detection failed\n");
+	}
+
 	return 0;
 
 out_detach_client:
@@ -337,7 +626,7 @@
 static int saa7191_probe(struct i2c_adapter *adap)
 {
 	/* Always connected to VINO */
-	if (adap->id == VINO_ADAPTER)
+	if (adap->id == I2C_HW_SGI_VINO)
 		return saa7191_attach(adap, SAA7191_ADDR, 0);
 	/* Feel free to add probe here :-) */
 	return -ENODEV;
@@ -364,13 +653,13 @@
 
 		cap->flags  = VIDEO_DECODER_PAL | VIDEO_DECODER_NTSC |
 			      VIDEO_DECODER_SECAM | VIDEO_DECODER_AUTO;
-		cap->inputs = (client->adapter->id == VINO_ADAPTER) ? 2 : 1;
+		cap->inputs = (client->adapter->id == I2C_HW_SGI_VINO) ? 2 : 1;
 		cap->outputs = 1;
 		break;
 	}
 	case DECODER_GET_STATUS: {
 		int *iarg = arg;
-		unsigned char status;
+		u8 status;
 		int res = 0;
 
 		if (saa7191_read_status(client, &status)) {
@@ -406,7 +695,7 @@
 
 		switch (*iarg) {
 		case VIDEO_MODE_AUTO:
-			return saa7191_set_norm(client, SAA7191_NORM_AUTO);
+			return saa7191_autodetect_norm(client);
 		case VIDEO_MODE_PAL:
 			return saa7191_set_norm(client, SAA7191_NORM_PAL);
 		case VIDEO_MODE_NTSC:
@@ -422,7 +711,7 @@
 		int *iarg = arg;
 
 		switch (client->adapter->id) {
-		case VINO_ADAPTER:
+		case I2C_HW_SGI_VINO:
 			return saa7191_set_input(client, *iarg);
 		default:
 			if (*iarg != 0)
@@ -448,38 +737,48 @@
 		int err;
 
 		val = (pic->hue >> 8) - 0x80;
+
 		err = saa7191_write_reg(client, SAA7191_REG_HUEC, val);
 		if (err)
 			return -EIO;
+
 		break;
 	}
 	case DECODER_SAA7191_GET_STATUS: {
 		struct saa7191_status *status = arg;
-		unsigned char status_reg;
+		u8 status_reg;
 
 		if (saa7191_read_status(client, &status_reg))
 			return -EIO;
+
 		status->signal = ((status_reg & SAA7191_STATUS_HLCK) == 0)
-			? SAA7191_VALUE_ENABLED : SAA7191_VALUE_DISABLED;
-		status->ntsc = (status_reg & SAA7191_STATUS_FIDT)
-			? SAA7191_VALUE_ENABLED : SAA7191_VALUE_DISABLED;
-		status->color = (status_reg & SAA7191_STATUS_CODE)
-			? SAA7191_VALUE_ENABLED : SAA7191_VALUE_DISABLED;
+			? 1 : 0;
+		status->signal_60hz = (status_reg & SAA7191_STATUS_FIDT)
+			? 1 : 0;
+		status->color = (status_reg & SAA7191_STATUS_CODE) ? 1 : 0;
 
 		status->input = decoder->input;
 		status->norm = decoder->norm;
+
+		break;
 	}
 	case DECODER_SAA7191_SET_NORM: {
 		int *norm = arg;
-		return saa7191_set_norm(client, *norm);
+
+		switch (*norm) {
+		case SAA7191_NORM_AUTO:
+			return saa7191_autodetect_norm(client);
+		case SAA7191_NORM_AUTO_EXT:
+			return saa7191_autodetect_norm_extended(client);
+		default:
+			return saa7191_set_norm(client, *norm);
+		}
+	}
+	case DECODER_SAA7191_GET_CONTROL: {
+		return saa7191_get_control(client, arg);
 	}
-	case DECODER_SAA7191_GET_CONTROLS: {
-		struct saa7191_control *ctrl = arg;
-		return saa7191_get_controls(client, ctrl);
-	}
-	case DECODER_SAA7191_SET_CONTROLS: {
-		struct saa7191_control *ctrl = arg;
-		return saa7191_set_controls(client, ctrl);
+	case DECODER_SAA7191_SET_CONTROL: {
+		return saa7191_set_control(client, arg);
 	}
 	default:
 		return -EINVAL;
@@ -490,12 +789,12 @@
 
 static struct i2c_driver i2c_driver_saa7191 = {
 	.owner		= THIS_MODULE,
-	.name 		= "saa7191",
-	.id 		= I2C_DRIVERID_SAA7191,
-	.flags 		= I2C_DF_NOTIFY,
+	.name		= "saa7191",
+	.id		= I2C_DRIVERID_SAA7191,
+	.flags		= I2C_DF_NOTIFY,
 	.attach_adapter = saa7191_probe,
-	.detach_client 	= saa7191_detach,
-	.command 	= saa7191_command
+	.detach_client	= saa7191_detach,
+	.command	= saa7191_command
 };
 
 static int saa7191_init(void)
diff -Naur linux-2.6.14/drivers/media/video/saa7191.h linux-mips-2.6.14.orig/drivers/media/video/saa7191.h
--- linux-2.6.14/drivers/media/video/saa7191.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/saa7191.h	2005-11-17 11:42:59.000000000 -0800
@@ -24,8 +24,8 @@
 #define SAA7191_REG_HPHI	0x05
 #define SAA7191_REG_LUMA	0x06
 #define SAA7191_REG_HUEC	0x07
-#define SAA7191_REG_CKTQ	0x08
-#define SAA7191_REG_CKTS	0x09
+#define SAA7191_REG_CKTQ	0x08 /* bits 3-7 */
+#define SAA7191_REG_CKTS	0x09 /* bits 3-7 */
 #define SAA7191_REG_PLSE	0x0a
 #define SAA7191_REG_SESE	0x0b
 #define SAA7191_REG_GAIN	0x0c
@@ -43,30 +43,82 @@
 
 /* Status Register definitions */
 #define SAA7191_STATUS_CODE	0x01	/* color detected flag */
-#define SAA7191_STATUS_FIDT	0x20	/* format type NTSC/PAL */
-#define SAA7191_STATUS_HLCK	0x40	/* PLL unlocked/locked */
+#define SAA7191_STATUS_FIDT	0x20	/* signal type 50/60 Hz */
+#define SAA7191_STATUS_HLCK	0x40	/* PLL unlocked(1)/locked(0) */
 #define SAA7191_STATUS_STTC	0x80	/* tv/vtr time constant */
 
 /* Luminance Control Register definitions */
+/* input mode select bit:
+ * 0=CVBS (chrominance trap active), 1=S-Video (trap bypassed) */
 #define SAA7191_LUMA_BYPS	0x80
+/* pre-filter (only when chrominance trap is active) */
+#define SAA7191_LUMA_PREF	0x40
+/* aperture bandpass to select different characteristics with maximums
+ * (bits 4-5) */
+#define SAA7191_LUMA_BPSS_MASK	0x30
+#define SAA7191_LUMA_BPSS_SHIFT	4
+#define SAA7191_LUMA_BPSS_3	0x30
+#define SAA7191_LUMA_BPSS_2	0x20
+#define SAA7191_LUMA_BPSS_1	0x10
+#define SAA7191_LUMA_BPSS_0	0x00
+/* coring range for high frequency components according to 8-bit luminance
+ * (bits 2-3)
+ * 0=coring off, n= (+-)n LSB */
+#define SAA7191_LUMA_CORI_MASK	0x0c
+#define SAA7191_LUMA_CORI_SHIFT	2
+#define SAA7191_LUMA_CORI_3	0x0c
+#define SAA7191_LUMA_CORI_2	0x08
+#define SAA7191_LUMA_CORI_1	0x04
+#define SAA7191_LUMA_CORI_0	0x00
+/* aperture bandpass filter weights high frequency components of luminance
+ * signal (bits 0-1)
+ * 0=factor 0, 1=0.25, 2=0.5, 3=1 */
+#define SAA7191_LUMA_APER_MASK	0x03
+#define SAA7191_LUMA_APER_SHIFT	0
+#define SAA7191_LUMA_APER_3	0x03
+#define SAA7191_LUMA_APER_2	0x02
+#define SAA7191_LUMA_APER_1	0x01
+#define SAA7191_LUMA_APER_0	0x00
 
-/* Chroma Gain Control Settings Register definitions */
-/* 0=automatic colour-killer enabled, 1=forced colour on */
+/* Chrominance Gain Control Settings Register definitions */
+/* colour on: 0=automatic colour-killer enabled, 1=forced colour on */
 #define SAA7191_GAIN_COLO	0x80
+/* chrominance gain control (AGC filter)
+ * 0=loop filter time constant slow, 1=medium, 2=fast, 3=actual gain */
+#define SAA7191_GAIN_LFIS_MASK	0x60
+#define SAA7191_GAIN_LFIS_SHIFT	5
+#define SAA7191_GAIN_LFIS_3	0x60
+#define SAA7191_GAIN_LFIS_2	0x40
+#define SAA7191_GAIN_LFIS_1	0x20
+#define SAA7191_GAIN_LFIS_0	0x00
 
 /* Standard/Mode Control Register definitions */
 /* tv/vtr mode bit: 0=TV mode (slow time constant),
  * 1=VTR mode (fast time constant) */
 #define SAA7191_STDC_VTRC	0x80
+/* SAA7191B-specific functions enable (RTCO, ODD and GPSW0 outputs)
+ * 0=outputs set to high-impedance (circuit equals SAA7191), 1=enabled */
+#define SAA7191_STDC_NFEN	0x08
+/* HREF generation: 0=like SAA7191, 1=HREF is 8xLLC2 clocks earlier */
+#define SAA7191_STDC_HRMV	0x04
+/* general purpose switch 0
+ * (not used with VINO afaik) */
+#define SAA7191_STDC_GPSW0	0x02
 /* SECAM mode bit: 0=other standards, 1=SECAM */
 #define SAA7191_STDC_SECS	0x01
-/* the bit fields above must be or'd with this value */
-#define SAA7191_STDC_VALUE	0x0c
 
 /* I/O and Clock Control Register definitions */
 /* horizontal clock PLL: 0=PLL closed,
  * 1=PLL circuit open and horizontal freq fixed */
 #define SAA7191_IOCK_HPLL	0x80
+/* colour-difference output enable (outputs UV0-UV7) */
+#define SAA7191_IOCK_OEDC	0x40
+/* H-sync output enable */
+#define SAA7191_IOCK_OEHS	0x20
+/* V-sync output enable */
+#define SAA7191_IOCK_OEVS	0x10
+/* luminance output enable (outputs Y0-Y7) */
+#define SAA7191_IOCK_OEDY	0x08
 /* S-VHS bit (chrominance from CVBS or from chrominance input):
  * 0=controlled by BYPS-bit, 1=from chrominance input */
 #define SAA7191_IOCK_CHRS	0x04
@@ -83,11 +135,40 @@
 /* field select: (if AUFD=0)
  * 0=50Hz (625 lines), 1=60Hz (525 lines) */
 #define SAA7191_CTL3_FSEL	0x40
-/* the bit fields above must be or'd with this value */
-#define SAA7191_CTL3_VALUE	0x19
+/* SECAM cross-colour reduction enable */
+#define SAA7191_CTL3_SXCR	0x20
+/* sync and clamping pulse enable (HCL and HSY outputs) */
+#define SAA7191_CTL3_SCEN	0x10
+/* output format: 0=4:1:1, 1=4:2:2 (4:2:2 for VINO) */
+#define SAA7191_CTL3_OFTS	0x08
+/* luminance delay compensation
+ * 0=0*2/LLC,  1=+1*2/LLC, 2=+2*2/LLC, 3=+3*2/LLC,
+ * 4=-4*2/LLC, 5=-3*2/LLC, 6=-2*2/LLC, 7=-1*2/LLC
+ * step size = 2/LLC = 67.8ns for 50Hz, 81.5ns for 60Hz */
+#define SAA7191_CTL3_YDEL_MASK	0x07
+#define SAA7191_CTL3_YDEL_SHIFT	0
+#define SAA7191_CTL3_YDEL2	0x04
+#define SAA7191_CTL3_YDEL1	0x02
+#define SAA7191_CTL3_YDEL0	0x01
+
+/* Miscellaneous Control #2 Register definitions */
+/* select HREF position
+ * 0=normal, HREF is matched to YUV output port,
+ * 1=HREF is matched to CVBS input port */
+#define SAA7191_CTL4_HRFS	0x04
+/* vertical noise reduction
+ * 0=normal, 1=searching window, 2=auto-deflection, 3=reduction bypassed */
+#define SAA7191_CTL4_VNOI_MASK	0x03
+#define SAA7191_CTL4_VNOI_SHIFT	0
+#define SAA7191_CTL4_VNOI_3	0x03
+#define SAA7191_CTL4_VNOI_2	0x02
+#define SAA7191_CTL4_VNOI_1	0x01
+#define SAA7191_CTL4_VNOI_0	0x00
 
 /* Chrominance Gain Control Register definitions
- * (nominal value for UV CCIR level) */
+ * - for QAM-modulated input signals, effects output amplitude
+ * (SECAM gain fixed)
+ * (nominal values for UV CCIR level) */
 #define SAA7191_CHCV_NTSC	0x2c
 #define SAA7191_CHCV_PAL	0x59
 
@@ -99,16 +180,13 @@
 #define SAA7191_NORM_PAL	1
 #define SAA7191_NORM_NTSC	2
 #define SAA7191_NORM_SECAM	3
-
-#define SAA7191_VALUE_ENABLED		1
-#define SAA7191_VALUE_DISABLED		0
-#define SAA7191_VALUE_UNCHANGED		-1
+#define SAA7191_NORM_AUTO_EXT	4	/* extended auto-detection */
 
 struct saa7191_status {
-	/* 0=no signal, 1=signal active*/
+	/* 0=no signal, 1=signal detected */
 	int signal;
 	/* 0=50hz (pal) signal, 1=60hz (ntsc) signal */
-	int ntsc;
+	int signal_60hz;
 	/* 0=no color detected, 1=color detected */
 	int color;
 
@@ -118,22 +196,60 @@
 	int norm;
 };
 
-#define SAA7191_HUE_MIN		0x00
-#define SAA7191_HUE_MAX		0xff
-#define SAA7191_HUE_DEFAULT	0x80
-
-#define SAA7191_VTRC_MIN	0x00
-#define SAA7191_VTRC_MAX	0x01
-#define SAA7191_VTRC_DEFAULT	0x00
+#define SAA7191_BANDPASS_MIN		0x00
+#define SAA7191_BANDPASS_MAX		0x03
+#define SAA7191_BANDPASS_DEFAULT	0x00
+
+#define SAA7191_BANDPASS_WEIGHT_MIN	0x00
+#define SAA7191_BANDPASS_WEIGHT_MAX	0x03
+#define SAA7191_BANDPASS_WEIGHT_DEFAULT	0x01
+
+#define SAA7191_CORING_MIN		0x00
+#define SAA7191_CORING_MAX		0x03
+#define SAA7191_CORING_DEFAULT		0x00
+
+#define SAA7191_HUE_MIN			0x00
+#define SAA7191_HUE_MAX			0xff
+#define SAA7191_HUE_DEFAULT		0x80
+
+#define SAA7191_VTRC_MIN		0x00
+#define SAA7191_VTRC_MAX		0x01
+#define SAA7191_VTRC_DEFAULT		0x00
+
+#define SAA7191_FORCE_COLOUR_MIN	0x00
+#define SAA7191_FORCE_COLOUR_MAX	0x01
+#define SAA7191_FORCE_COLOUR_DEFAULT	0x00
+
+#define SAA7191_CHROMA_GAIN_MIN		0x00
+#define SAA7191_CHROMA_GAIN_MAX		0x03
+#define SAA7191_CHROMA_GAIN_DEFAULT	0x00
+
+#define SAA7191_LUMA_DELAY_MIN		-0x04
+#define SAA7191_LUMA_DELAY_MAX		0x03
+#define SAA7191_LUMA_DELAY_DEFAULT	0x01
+
+#define SAA7191_VNR_MIN			0x00
+#define SAA7191_VNR_MAX			0x03
+#define SAA7191_VNR_DEFAULT		0x00
+
+#define SAA7191_CONTROL_BANDPASS	0
+#define SAA7191_CONTROL_BANDPASS_WEIGHT	1
+#define SAA7191_CONTROL_CORING		2
+#define SAA7191_CONTROL_FORCE_COLOUR	3	/* boolean */
+#define SAA7191_CONTROL_CHROMA_GAIN	4
+#define SAA7191_CONTROL_HUE		5
+#define SAA7191_CONTROL_VTRC		6	/* boolean */
+#define SAA7191_CONTROL_LUMA_DELAY	7
+#define SAA7191_CONTROL_VNR		8
 
 struct saa7191_control {
-	int hue;
-	int vtrc;
+	u8 type;
+	s32 value;
 };
 
 #define	DECODER_SAA7191_GET_STATUS	_IOR('d', 195, struct saa7191_status)
 #define	DECODER_SAA7191_SET_NORM	_IOW('d', 196, int)
-#define	DECODER_SAA7191_GET_CONTROLS	_IOR('d', 197, struct saa7191_control)
-#define	DECODER_SAA7191_SET_CONTROLS	_IOW('d', 198, struct saa7191_control)
+#define	DECODER_SAA7191_GET_CONTROL	_IOR('d', 197, struct saa7191_control)
+#define	DECODER_SAA7191_SET_CONTROL	_IOW('d', 198, struct saa7191_control)
 
 #endif
diff -Naur linux-2.6.14/drivers/media/video/swarm_saa7114h.c linux-mips-2.6.14.orig/drivers/media/video/swarm_saa7114h.c
--- linux-2.6.14/drivers/media/video/swarm_saa7114h.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/media/video/swarm_saa7114h.c	2005-11-17 11:42:59.000000000 -0800
@@ -0,0 +1,1690 @@
+/* 
+   saa7114h - Philips SAA7114H video decoder driver
+
+   Copyright (C) 2001,2002,2003 Broadcom Corporation
+
+   From saa7111.c:
+     Copyright (C) 1998 Dave Perks <dperks@ibm.net>
+   From cpia.c:
+     (C) Copyright 1999-2000 Peter Pregler
+     (C) Copyright 1999-2000 Scott J. Bertin
+     (C) Copyright 1999-2000 Johannes Erdfelt <johannes@erdfelt.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Important note: this driver is reasonably functional, and has been
+ * tested with the "camserv" v4l application.  But it primarily a
+ * proof-of-concept, and example for setting up FIFO-mode.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#include <linux/types.h>
+#include <linux/wrapper.h>
+#include <linux/smp_lock.h>
+#include <asm/hardirq.h>
+
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c-algo-sibyte.h>
+
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_int.h>
+#include <asm/sibyte/sb1250_mac.h>
+#include <asm/sibyte/sb1250_dma.h>
+
+#define SAA_BRIGHTNESS	 0x0a
+#define SAA_CONTRAST	 0x0b
+#define SAA_SATURATION	 0x0c
+#define SAA_HUE		 0x0d
+
+#define DECODER_STATUS	 0x1f
+#define SLICER_STATUS_0	 0x60
+#define SLICER_STATUS_1	 0x61
+#define SLICER_STATUS_2	 0x62
+#define SCALER_STATUS	 0x8f
+
+#define NUM_FRAME	 2
+#define MAX_HORIZ	 720
+#define MAX_VERT	 480
+#define MIN_HORIZ	 180
+#define MIN_VERT	 120
+#define MAX_PER_PIXEL	 3
+#define MAX_FRAME_SIZE	 (MAX_HORIZ*MAX_VERT*MAX_PER_PIXEL)
+#define MAX_MMAP_SIZE	 (PAGE_ALIGN(MAX_FRAME_SIZE*NUM_FRAME))
+#define RAW_PER_PIXEL	 2
+#define RAW_LINE_PAD	 8
+#define RAW_LINE_SIZE	 (((MAX_HORIZ*RAW_PER_PIXEL)+RAW_LINE_PAD+0x1f) & ~0x1f)
+#define RAW_FRAME_SIZE	 (RAW_LINE_SIZE*MAX_VERT)
+
+#define NUM_DESCR	 64
+#define INTR_PKT_CNT	 8
+
+/* Extensions to videodev.h IOCTL definitions */
+#define VIDIOREADREG	_IOR('v', 50, int)
+#define VIDIOWRITEREG	_IOW('v', 50, int)
+#define VIDIOGRABFRAME	_IOR('v', 51, int)
+#define VIDIOSHOWEAV	_IOR('v', 52, int)
+
+#define IF_NAME "saa7114h"
+
+#define MAC2_CSR(r)	   (KSEG1 + A_MAC_REGISTER(2, r))
+#define MAC2_DMARX0_CSR(r) (KSEG1 + A_MAC_DMA_REGISTER(2, DMA_RX, 0, r))
+
+/* Options */
+#define DMA_DEINTERLACE	 1
+#define LAZY_READ	 1
+#define NULL_DMA	 0
+
+/* Debug filters */
+#define DBG_NULL	 0x0000
+#define DBG_IO		 0x0001
+#define DBG_DESCR	 0x0002
+#define DBG_INTR	 0x0004
+#define DBG_CONVERT	 0x0008
+#define DBG_FRAMING	 0x0010
+#define DBG_REGISTER	 0x0020
+#define DBG_CALL	 0x0040
+#define DBG_FRAMING_LOUD 0x0080
+
+/* XXXKW make this settable through /proc... */
+#define DEBUG_LVL	 (DBG_NULL)
+
+#if DEBUG_LVL
+#define DBG(l, p) do { if (DEBUG_LVL & l) p; } while (0)
+#else
+#define DBG(l, p)
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+enum {
+	FRAME_READY,		/* Ready to grab into */
+	FRAME_GRABBING,		/* In the process of being grabbed into */
+	FRAME_DONE,		/* Finished grabbing, but not been synced yet */
+	FRAME_UNUSED,		/* Unused (belongs to driver, but can't be used) */
+};
+
+struct saa_frame {
+	uint8_t		 *data;
+	uint8_t		 *pos;
+	int		  width;
+	int		  height;
+	uint32_t	  size;
+	volatile int	  state;
+	wait_queue_head_t read_wait;
+};
+
+typedef struct fifo_descr_s {
+	uint64_t descr_a;
+	uint64_t descr_b;
+} fifo_descr_t;
+
+typedef unsigned long paddr_t;
+
+typedef struct fifo_s {
+	unsigned	 ringsz;
+	fifo_descr_t	*descrtab;
+	fifo_descr_t	*descrtab_end;
+	fifo_descr_t	*next_descr;
+	paddr_t		 descrtab_phys;
+	void		*dma_buf;	    /* DMA buffer */
+} fifo_t;
+
+struct saa7114h {
+	struct i2c_client    *client;
+	struct video_device  *vd;
+	struct video_window   vw;
+	struct video_picture  vp;
+	uint8_t		      reg[256];
+
+	fifo_t		 ff;
+	void		*frame_buf; /* hold frames for the client */
+	struct saa_frame frame[NUM_FRAME]; /* point into frame_buf */
+	int		 hwframe;
+	int		 swframe;
+
+	uint16_t depth;
+	uint16_t palette;
+	uint8_t	 bright;
+	uint8_t	 contrast;
+	uint8_t	 hue;
+	uint8_t	 sat;
+
+	struct proc_dir_entry *proc_entry;
+	struct semaphore       param_lock;
+	struct semaphore       busy_lock;
+
+	int	dma_enable;
+	int	opened;
+	int	irq;
+	int	interlaced;
+};
+
+static int saa7114h_probe(struct i2c_adapter *adap);
+static int saa7114h_detach(struct i2c_client *device);
+
+struct i2c_driver i2c_driver_saa7114h =
+{
+	name:		"saa7114h",		/* name */
+	id:		I2C_DRIVERID_SAA7114H,	/* ID */
+	flags:		I2C_DF_NOTIFY,		/* XXXKW do I care? */
+	attach_adapter: saa7114h_probe,
+	detach_client:	saa7114h_detach
+};
+
+/* -----------------------------------------------------------------------
+ * VM assist for MMAPed space
+ * ----------------------------------------------------------------------- */
+
+/* Given PGD from the address space's page table, return the kernel
+ * virtual mapping of the physical memory mapped at ADR.
+ */
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+{
+	unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, adr);
+		if (!pmd_none(*pmd)) {
+			ptep = pte_offset(pmd, adr);
+			pte = *ptep;
+			if (pte_present(pte)) {
+				ret = (unsigned long) page_address(pte_page(pte));
+				ret |= (adr & (PAGE_SIZE-1));
+			}
+		}
+	}
+	return ret;
+}
+
+/* Here we want the physical address of the memory.
+ * This is used when initializing the contents of the
+ * area and marking the pages as reserved.
+ */
+static inline unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long va, kva, ret;
+
+	va = VMALLOC_VMADDR(adr);
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	ret = __pa(kva);
+	return ret;
+}
+
+static void *rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr, page;
+
+	/* Round it off to PAGE_SIZE */
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_reserve(virt_to_page(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return mem;
+}
+
+static void rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr, page;
+
+	if (!mem)
+		return;
+
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_unreserve(virt_to_page(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	vfree(mem);
+}
+
+/* -----------------------------------------------------------------------
+ * Control interface (i2c)
+ * ----------------------------------------------------------------------- */
+
+static int saa7114h_reg_read(struct saa7114h *dev, unsigned char subaddr)
+{
+	return i2c_smbus_read_byte_data(dev->client, subaddr);
+}
+
+static int saa7114h_reg_write(struct saa7114h *dev, unsigned char subaddr, int data)
+{
+	return i2c_smbus_write_byte_data(dev->client, subaddr, data & 0xff);
+}
+
+static int saa7114h_reg_init(struct saa7114h *dev, unsigned const char *data, unsigned int len)
+{
+	int rc = 0;
+	int val;
+
+	while (len && !rc) {
+		dev->reg[data[0]] = data[1];
+		rc = saa7114h_reg_write(dev, data[0], data[1]);
+		if (!rc && (data[0] != 0)) {
+			val = saa7114h_reg_read(dev, data[0]);
+			if ((val < 0) || (val != data[1])) {
+				printk(KERN_ERR
+				       IF_NAME ": init readback mismatch reg %02x = %02x (should be %02x)\n",
+				       data[0], val, data[1]);
+			}
+		}
+		len -= 2;
+		data += 2;
+	}
+	return rc;
+}
+
+/* -----------------------------------------------------------------------
+ * /proc interface
+ * ----------------------------------------------------------------------- */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *saa7114h_proc_root=NULL;
+
+static int decoder_read_proc(char *page, char **start, off_t off,
+			     int count, int *eof, void *data)
+{
+	char *out = page;
+	int len, status;
+	struct saa7114h *decoder = data;
+
+	out += sprintf(out, "  SWARM saa7114h\n------------------\n");
+	status = saa7114h_reg_read(decoder, DECODER_STATUS);
+	out += sprintf(out, "  Decoder status = %02x\n", status);
+	if (status & 0x80)
+		out += sprintf(out, "	 interlaced\n");
+	if (status & 0x40)
+		out += sprintf(out, "	 not locked\n");
+	if (status & 0x02)
+		out += sprintf(out, "	 Macrovision detected\n");
+	if (status & 0x01)
+		out += sprintf(out, "	 color\n");
+	out += sprintf(out, "  Brightness = %02x\n", decoder->bright);
+	out += sprintf(out, "  Contrast	  = %02x\n", decoder->contrast);
+	out += sprintf(out, "  Saturation = %02x\n", decoder->sat);
+	out += sprintf(out, "  Hue	  = %02x\n\n", decoder->hue);
+
+	out += sprintf(out, "  Scaler status  = %02x\n", 
+		       (int)saa7114h_reg_read(decoder, SCALER_STATUS));
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0) return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+	return len;
+}
+
+static int decoder_write_proc(struct file *file, const char *buffer,
+			       unsigned long count, void *data)
+{
+	struct saa7114h *d = data;
+	int retval;
+	unsigned int cmd, reg, reg_val;
+	
+	if (down_interruptible(&d->param_lock))
+		return -ERESTARTSYS;
+
+#define VALUE \
+	({ \
+		char *_p; \
+		unsigned long int _ret; \
+		while (count && isspace(*buffer)) { \
+			buffer++; \
+			count--; \
+		} \
+		_ret = simple_strtoul(buffer, &_p, 16); \
+		if (_p == buffer) \
+			retval = -EINVAL; \
+		else { \
+			count -= _p - buffer; \
+			buffer = _p; \
+		} \
+		_ret; \
+	})
+	
+	retval = 0;
+	while (count && !retval) {
+		cmd = VALUE;
+		if (retval)
+			break;
+		switch (cmd) {
+		case 1:
+			reg = VALUE;
+			if (retval)
+				break;
+			reg_val = VALUE;
+			if (retval)
+				break;
+			printk(IF_NAME ": write reg %x <- %x\n", reg, reg_val);
+			if (saa7114h_reg_write(d, reg, reg_val) == -1)
+				retval = -EINVAL;
+			break;
+		case 2:
+			reg = VALUE;
+			if (retval)
+				break;
+			reg_val = saa7114h_reg_read(d, reg);
+			if (reg_val == -1)
+				retval = -EINVAL;
+			else
+				printk(IF_NAME ": read reg %x -> %x\n", reg, reg_val);
+			break;
+		default:
+			break;
+		}
+	}
+	up(&d->param_lock);
+	
+	return retval;
+}
+
+static void create_proc_decoder(struct saa7114h *decoder)
+{
+	char name[8];
+	struct proc_dir_entry *ent;
+	
+	if (!saa7114h_proc_root || !decoder)
+		return;
+
+	sprintf(name, "video%d", decoder->vd->minor);
+	
+	ent = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUSR, saa7114h_proc_root);
+	if (!ent) {
+		printk(KERN_INFO IF_NAME ": Unable to initialize /proc/saa7114h/%s\n", name);
+		return;
+	}
+
+	ent->data = decoder;
+	ent->read_proc = decoder_read_proc;
+	ent->write_proc = decoder_write_proc;
+	ent->size = 3626;	/* XXXKW ??? */
+	decoder->proc_entry = ent;
+}
+
+static void destroy_proc_decoder(struct saa7114h *decoder)
+{
+	char name[7];
+	
+	if (!decoder || !decoder->proc_entry)
+		return;
+	
+	sprintf(name, "video%d", decoder->vd->minor);
+	remove_proc_entry(name, saa7114h_proc_root);
+	decoder->proc_entry = NULL;
+}
+
+static void proc_saa7114h_create(void)
+{
+	saa7114h_proc_root = create_proc_entry("saa7114h", S_IFDIR, 0);
+
+	if (saa7114h_proc_root)
+		saa7114h_proc_root->owner = THIS_MODULE;
+	else
+		printk(KERN_INFO IF_NAME ": Unable to initialize /proc/saa7114h\n");
+}
+
+static void proc_saa7114h_destroy(void)
+{
+	remove_proc_entry("saa7114h", 0);
+}
+#endif /* CONFIG_PROC_FS */
+
+
+/* -----------------------------------------------------------------------
+ * Initialization
+ * ----------------------------------------------------------------------- */
+
+static int dma_setup(struct saa7114h *d)
+{
+	int i;
+	void *curbuf;
+
+	/* Reset the port */
+	__raw_writeq(M_MAC_PORT_RESET, MAC2_CSR(R_MAC_ENABLE));
+	__raw_readq(MAC2_CSR(R_MAC_ENABLE));
+
+	/* Zero everything out, disable filters */
+	__raw_writeq(0, MAC2_CSR(R_MAC_TXD_CTL));
+	__raw_writeq(M_MAC_ALLPKT_EN, MAC2_CSR(R_MAC_ADFILTER_CFG));
+	__raw_writeq(V_MAC_RX_RD_THRSH(4) | V_MAC_RX_RL_THRSH(4),
+	      MAC2_CSR(R_MAC_THRSH_CFG));
+	for (i=0; i<MAC_CHMAP_COUNT; i++) {
+		__raw_writeq(0, MAC2_CSR(R_MAC_CHLO0_BASE+(i*8)));
+		__raw_writeq(0, MAC2_CSR(R_MAC_CHUP0_BASE+(i*8)));
+	}
+	for (i=0; i<MAC_HASH_COUNT; i++) {
+		__raw_writeq(0, MAC2_CSR(R_MAC_HASH_BASE+(i*8)));
+	}
+	for (i=0; i<MAC_ADDR_COUNT; i++) {
+		__raw_writeq(0, MAC2_CSR(R_MAC_ADDR_BASE+(i*8)));
+	}	 
+	
+	__raw_writeq(V_MAC_MAX_FRAMESZ(16*1024) | V_MAC_MIN_FRAMESZ(0),
+	      MAC2_CSR(R_MAC_FRAMECFG));
+
+	/* Select bypass mode */
+	__raw_writeq((M_MAC_BYPASS_SEL | V_MAC_BYPASS_CFG(K_MAC_BYPASS_EOP) | 
+	       M_MAC_FC_SEL | M_MAC_SS_EN | V_MAC_SPEED_SEL_1000MBPS),
+	      MAC2_CSR(R_MAC_CFG));
+
+	/* Set up the descriptor table */
+	d->ff.descrtab = kmalloc(NUM_DESCR * sizeof(fifo_descr_t), GFP_KERNEL);
+	d->ff.descrtab_phys = __pa(d->ff.descrtab);
+	d->ff.descrtab_end = d->ff.descrtab + NUM_DESCR;
+	d->ff.next_descr = d->ff.descrtab;
+	d->ff.ringsz = NUM_DESCR;
+#if 0
+	/* XXXKW this won't work because the physical may not be
+	   contiguous; how do I handle a bigger alloc then? */
+	d->ff.dma_buf = rvmalloc(RAW_LINE_SIZE*NUM_DESCR);
+	printk(KERN_DEBUG IF_NAME ": DMA buffer allocated (%p)\n",
+	       d->ff.dma_buf);
+#else
+	d->ff.dma_buf = kmalloc(RAW_LINE_SIZE*NUM_DESCR, GFP_KERNEL);
+#endif
+	if (!d->ff.dma_buf) {
+		printk(KERN_ERR IF_NAME ": couldn't allocate DMA buffer\n");
+		return -ENOMEM;
+	}
+	memset(d->ff.dma_buf, 0, RAW_LINE_SIZE*NUM_DESCR);
+
+	for (i=0, curbuf=d->ff.dma_buf; i<d->ff.ringsz; i++, curbuf+=RAW_LINE_SIZE) {
+		d->ff.descrtab[i].descr_a = (__pa(curbuf) |
+					     V_DMA_DSCRA_A_SIZE(RAW_LINE_SIZE >> 5));
+		d->ff.descrtab[i].descr_b = 0;
+	}
+
+	__raw_writeq(V_DMA_INT_PKTCNT(INTR_PKT_CNT) | M_DMA_EOP_INT_EN |
+	      V_DMA_RINGSZ(d->ff.ringsz) | M_DMA_TDX_EN,
+	      MAC2_DMARX0_CSR(R_MAC_DMA_CONFIG0));
+	__raw_writeq(M_DMA_L2CA, MAC2_DMARX0_CSR(R_MAC_DMA_CONFIG1));
+	__raw_writeq(d->ff.descrtab_phys, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_BASE));
+
+	/* Enable interrupts and DMA */
+	__raw_writeq(M_MAC_INT_EOP_COUNT<<S_MAC_RX_CH0, MAC2_CSR(R_MAC_INT_MASK));
+	__raw_writeq(M_MAC_RXDMA_EN0 | M_MAC_BYP_RX_ENABLE, MAC2_CSR(R_MAC_ENABLE));
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------
+ * v4linux helpers - color conversion, etc  (taken from cpia.c)
+ * ----------------------------------------------------------------------- */
+
+#define LIMIT(x) ((((x)>0xffffff)?0xff0000:(((x)<=0xffff)?0:(x)&0xff0000))>>16)
+
+static void yuvconvert_inplace(uint8_t *data, uint32_t in_uyvy, int out_fmt, int mmap)
+{
+	int y, u, v, r, g, b, y1;
+	uint8_t *src, *dst;
+
+	if (out_fmt == VIDEO_PALETTE_RGB24) {
+		src = (uint8_t *)((int)data + in_uyvy);
+		dst = (uint8_t *)((int)data + in_uyvy + (in_uyvy >> 1));
+		DBG(DBG_CONVERT, printk(KERN_DEBUG "inplace: %p %p %p\n", data, src, dst));
+		while (src > data) {
+			if ((int)(src-data) < 4)
+				break;
+				//printk("freaky %p %p\n", src, data);
+			y1 = (*(--src) - 16) * 76310;
+			v = *(--src) - 128;
+			y = (*(--src) - 16) * 76310;
+			u = *(--src) - 128;
+			r = 104635 * v;
+			g = -25690 * u + -53294 * v;
+			b = 132278 * u;
+			/* XXXKW what on earth is up with mmap? */
+			if (mmap) {
+				*(--dst) = LIMIT(r+y1);
+				*(--dst) = LIMIT(g+y1);
+				*(--dst) = LIMIT(b+y1);
+				*(--dst) = LIMIT(r+y);
+				*(--dst) = LIMIT(g+y);
+				*(--dst) = LIMIT(b+y);
+			} else {
+				*(--dst) = LIMIT(b+y1);
+				*(--dst) = LIMIT(g+y1);
+				*(--dst) = LIMIT(r+y1);
+				*(--dst) = LIMIT(b+y);
+				*(--dst) = LIMIT(g+y);
+				*(--dst) = LIMIT(r+y);
+			}
+		}
+	}
+}
+
+static int saa7114h_get_cparams(struct saa7114h *decoder)
+{
+	/* XXX check for error code */
+	decoder->bright	    = saa7114h_reg_read(decoder, SAA_BRIGHTNESS);
+	decoder->contrast   = saa7114h_reg_read(decoder, SAA_CONTRAST);
+	decoder->sat	    = saa7114h_reg_read(decoder, SAA_SATURATION);
+	decoder->hue	    = saa7114h_reg_read(decoder, SAA_HUE);
+
+	decoder->vp.brightness = (uint16_t)decoder->bright << 8;
+	decoder->vp.contrast   = (uint16_t)decoder->contrast << 9;
+	decoder->vp.colour     = decoder->sat << 9;
+	decoder->vp.hue	       = ((int16_t)decoder->hue + 128) << 8;
+	return 0;
+}
+
+static int saa7114h_set_cparams(struct saa7114h *decoder)
+{
+	decoder->bright	  = decoder->vp.brightness >> 8;
+	decoder->contrast = decoder->vp.contrast >> 9;
+	decoder->sat	  = decoder->vp.colour >> 9;
+	decoder->hue	  = (uint8_t)((int8_t)(decoder->vp.hue >> 8) - 128);
+
+	return (saa7114h_reg_write(decoder, SAA_BRIGHTNESS, decoder->bright) ||
+		saa7114h_reg_write(decoder, SAA_CONTRAST, decoder->contrast) ||
+		saa7114h_reg_write(decoder, SAA_SATURATION, decoder->sat) ||
+		saa7114h_reg_write(decoder, SAA_HUE, decoder->hue));
+}
+
+/* -----------------------------------------------------------------------
+ * Custom IOCTL support
+ * ----------------------------------------------------------------------- */
+
+unsigned char eav[625][2];
+static int grab_frame(struct saa7114h *d, void *user_buf, int print_eav)
+{
+	int cur_idx = 0;
+	int to_go = 625;
+	int delta;
+	int i, len, eav_val, sav_val;
+	int started = 0;
+	uint8_t *buf;
+	fifo_descr_t *cur_d;
+	int swptr = d->ff.next_descr - d->ff.descrtab;
+	int hwptr;
+
+	DBG(DBG_CALL, printk(IF_NAME ": grabbing frame\n"));
+
+	/* Check for Macrovision -- if it's on, DMA won't happen */
+	if (saa7114h_reg_read(d, DECODER_STATUS) & 0x2)
+		return -EACCES;
+
+	__raw_writeq(d->ff.ringsz, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	do {
+		hwptr = (unsigned) (((__raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_CUR_DSCRADDR)) &
+				      M_DMA_CURDSCR_ADDR) -
+				     d->ff.descrtab_phys) /
+				    sizeof(fifo_descr_t));
+		delta = (hwptr + d->ff.ringsz - swptr) % d->ff.ringsz;
+		
+		if (delta == 0) {
+#if 0
+			uint64_t val = __raw_readq(MAC2_DMARX0_CSR(R_MAC_STATUS));
+			printk("mac status: %08x%08x\n",
+			       (u32)(val >> 32), (u32)(val&0xffffffff));
+#endif
+		}
+
+		for (i=0; i<delta; i++) {
+			cur_d = d->ff.next_descr;
+			if (++d->ff.next_descr == d->ff.descrtab_end)
+				d->ff.next_descr = d->ff.descrtab;
+			
+			if (!(cur_d->descr_a & M_DMA_ETHRX_SOP)) {
+				printk("bogus RX\n");
+				continue;
+			}
+			cur_d->descr_a &= ~M_DMA_ETHRX_SOP;
+			len = G_DMA_DSCRB_PKT_SIZE(cur_d->descr_b);
+			buf = (uint8_t *)__va(cur_d->descr_a & M_DMA_DSCRA_A_ADDR);
+			if (len != (d->vw.width*RAW_PER_PIXEL)+RAW_LINE_PAD) {
+				printk("funny size %d\n", len);
+				continue;
+			}
+			eav_val = buf[1];
+			sav_val = buf[5];
+			if (eav_val == 0xf1) { /* end of field 2, V-blank */
+				if (started) {
+					started = 0;
+					delta = to_go = 0;
+					/* just let DMA finish in background */
+				} else {
+					started = 1;
+				}
+			}
+			if (started) {
+				eav[cur_idx][0] = eav_val;
+				eav[cur_idx++][1] = sav_val;
+				if (copy_to_user(user_buf, &buf[6], 1440))
+					return -EFAULT;
+				user_buf += 1440;
+			}
+		}
+		swptr = hwptr;
+		if (delta) {
+			if (started)
+				to_go -= delta;
+			if (delta > to_go)
+				delta = to_go;
+			__raw_writeq(delta, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		}
+	} while (to_go);
+
+	if (print_eav) {
+		for (i=0; i<cur_idx; i++) {
+			printk("%3d: %02x | %02x\n", i, eav[i][0], eav[i][1]);
+		}
+	}
+
+	return cur_idx;
+}
+
+/* -----------------------------------------------------------------------
+ * Interrupt handler
+ * ----------------------------------------------------------------------- */
+
+unsigned long int_count = 0;
+
+static void saa7114h_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct saa7114h *d = dev_id;
+	uint64_t status_val;
+	fifo_descr_t *cur_d;
+	int i, delta, len;
+	uint8_t *buf, eav_val;
+	int swptr = d->ff.next_descr - d->ff.descrtab;
+	int hwptr;
+
+	status_val = __raw_readq(MAC2_CSR(R_MAC_STATUS));
+
+	/* Process finished decsriptors */
+	hwptr = (unsigned) (((__raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_CUR_DSCRADDR)) &
+			      M_DMA_CURDSCR_ADDR) - d->ff.descrtab_phys) /
+			    sizeof(fifo_descr_t));
+	delta = (hwptr + d->ff.ringsz - swptr) % d->ff.ringsz;
+	if (!delta) {
+		if (status_val & M_MAC_INT_EOP_SEEN<<S_MAC_RX_CH0) {
+			/* Must have wrapped since the last interrupt */
+			delta = d->ff.ringsz;
+		} else {
+			/* XXXKW why would this happen? */
+			return;
+		}
+	}
+
+	for (i=0; i<delta; i++) {
+		cur_d = d->ff.next_descr;
+		if (++d->ff.next_descr == d->ff.descrtab_end)
+			d->ff.next_descr = d->ff.descrtab;
+		
+		if (!(cur_d->descr_a & M_DMA_ETHRX_SOP)) {
+			printk(KERN_DEBUG "bogus RX\n");
+			continue;
+		}
+		cur_d->descr_a &= ~M_DMA_ETHRX_SOP;
+		if (!d->dma_enable)
+			continue;
+		
+		len = G_DMA_DSCRB_PKT_SIZE(cur_d->descr_b);
+		buf = (uint8_t *)__va(cur_d->descr_a & M_DMA_DSCRA_A_ADDR);
+		if (len != (d->vw.width*RAW_PER_PIXEL)+RAW_LINE_PAD) {
+			printk(KERN_DEBUG "funny size %d\n", len);
+//				  continue;
+		}
+		len -= RAW_LINE_PAD;
+		eav_val = buf[1];
+		DBG(DBG_FRAMING_LOUD,
+		    printk(KERN_DEBUG "eav: %02x len: %d\n", eav_val, len));
+		if (eav_val == 0xf1) { /* end of field 2, V-blank: start-of-frame */
+			switch (d->frame[d->hwframe].state) {
+			case FRAME_UNUSED:
+				DBG(DBG_FRAMING,
+				    printk(KERN_ERR "capture to unused frame %d\n", 
+					   d->hwframe));
+				break;
+			case FRAME_READY:
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame started %d\n",
+					   d->hwframe));
+				/* start this frame (skip eav/sav) */
+				memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+#if DMA_DEINTERLACE
+				if (!d->interlaced)
+					memcpy(d->frame[d->hwframe].pos-len, &buf[6], len);
+				d->frame[d->hwframe].pos += len*2;
+#else
+				d->frame[d->hwframe].pos += len;
+#endif
+				d->frame[d->hwframe].state = FRAME_GRABBING;
+				/* XXXKW check pos overflow */
+				break;
+			case FRAME_GRABBING:
+				/* kick over to new frame */
+				d->frame[d->hwframe].size = d->frame[d->hwframe].pos -
+					d->frame[d->hwframe].data;
+				d->frame[d->hwframe].state = FRAME_DONE;
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame finished %d\n",
+					   d->frame[d->hwframe].size));
+				/* wake up a waiting reader */
+				DBG(DBG_IO, printk(KERN_DEBUG "wakeup\n"));
+				wake_up(&d->frame[d->hwframe].read_wait);
+				d->hwframe = (d->hwframe + 1) % NUM_FRAME;
+				if (d->frame[d->hwframe].state == FRAME_READY) {
+					/* start this frame */
+					DBG(DBG_FRAMING,
+					    printk(KERN_DEBUG "frame bumped %d\n",
+						   d->hwframe));
+					memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+#if DMA_DEINTERLACE
+					if (!d->interlaced)
+						memcpy(d->frame[d->hwframe].pos-len, &buf[6], len);
+					d->frame[d->hwframe].pos += len*2;
+#else
+					d->frame[d->hwframe].pos += len;
+#endif
+					d->frame[d->hwframe].state = FRAME_GRABBING;
+				} else {
+					/* drop on the floor,
+					   note that we've stopped DMA'ing */
+					DBG(DBG_FRAMING,
+					    printk(KERN_DEBUG "frame capture halted\n"));
+					d->dma_enable = 0;
+				}
+				break;
+			case FRAME_DONE:
+				/* drop on the floor (must be waiting for sw) */
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame capture halted\n"));
+				d->dma_enable = 0;
+				break;
+			}
+		} else {
+			switch (d->frame[d->hwframe].state) {
+			case FRAME_UNUSED:
+				DBG(DBG_FRAMING,
+				    printk(KERN_ERR "capture to unused frame %d\n",
+					   d->hwframe));
+				break;
+			case FRAME_READY:
+				/* drop on the floor (must have dropped something) */
+				DBG(DBG_FRAMING_LOUD,
+				    printk(KERN_DEBUG "missed SOF\n"));
+				break;
+			case FRAME_DONE:
+				/* drop on the floor (must be waiting for sw) */
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame overflow\n"));
+				d->dma_enable = 0;
+				break;
+			case FRAME_GRABBING:
+#if DMA_DEINTERLACE
+				if (eav_val == 0xb6) {
+					d->frame[d->hwframe].pos = d->frame[d->hwframe].data;
+				}
+				memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+				if (!d->interlaced)
+					memcpy(d->frame[d->hwframe].pos-len, &buf[6], len);
+				d->frame[d->hwframe].pos += len*2;
+#else
+				memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+				d->frame[d->hwframe].pos += len;
+#endif
+				/* XXXKW check pos overflow */
+				break;
+			}
+		}
+	}
+	
+	if (d->dma_enable) {
+		__raw_writeq(delta, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		DBG(DBG_DESCR,
+		    printk(KERN_DEBUG IF_NAME ": interrupt adds %d -> %d descrs\n",
+			   delta, (int)__raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT))));
+	}
+}
+
+/* -----------------------------------------------------------------------
+ * /dev/video interface
+ * ----------------------------------------------------------------------- */
+
+static int saa7114h_open(struct video_device *vd, int nb)
+{
+	struct saa7114h *d = vd->priv;
+	uint32_t status;
+
+	if (!d || d->opened)
+		return -EBUSY;
+
+	d->opened = 1;
+	DBG(DBG_CALL, printk(KERN_DEBUG IF_NAME ": open\n"));
+
+	/* XXKW Should check this periodically!? */
+	status = saa7114h_reg_read(d, DECODER_STATUS);
+	d->interlaced = ((status & 0x80) != 0);
+
+#if !NULL_DMA
+	if (d->dma_enable) {
+		printk(IF_NAME ": open found DMA on?!\n");
+#if LAZY_READ
+	}
+#else
+	} else {
+		int descr;
+		d->dma_enable = 1;
+		DBG(DBG_DESCR, printk(IF_NAME ": open enabling DMA\n"));
+		/* Force capture to start into frame buffer 0 */
+		descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		DBG(DBG_DESCR,
+		    printk(IF_NAME ": open adds %d -> %d descrs\n",
+			   d->ff.ringsz-desc, descr));
+		__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	}
+#endif
+#endif
+
+	return 0;
+}
+
+static void saa7114h_release(struct video_device *vd)
+{
+	struct saa7114h *d = vd->priv;
+
+	DBG(DBG_CALL, printk(KERN_DEBUG IF_NAME ": release\n"));
+	d->opened = 0;
+	d->dma_enable = 0;
+
+	/* XXXKW do a clean drain of outstanding DMAs? toss leftover
+	   buffer contents to avoid stale pictures? */
+
+	return;
+}
+
+static long saa7114h_read(struct video_device *vd, char *buf,
+			  unsigned long count, int noblock)
+{
+	struct saa7114h *d = vd->priv;
+	int descr, status;
+
+	if (!d)
+		return -ENODEV;
+
+	/* XXKW Should check this periodically!? */
+	status = saa7114h_reg_read(d, DECODER_STATUS);
+//	  d->interlaced = ((status & 0x80) != 0);
+	
+#if !NULL_DMA
+#if LAZY_READ
+	if (!d->dma_enable) {
+		DBG(DBG_DESCR, printk(KERN_DEBUG IF_NAME ": enabling DMA\n"));
+		/* Give the buffer to the DMA engine (force ptr reset) */
+		d->swframe = d->hwframe;
+		d->frame[d->swframe].state = FRAME_READY;
+#if DMA_DEINTERLACE
+		d->frame[d->swframe].pos = d->frame[d->swframe].data+d->vw.width*RAW_PER_PIXEL;
+#else
+		d->frame[d->swframe].pos = d->frame[d->swframe].data;
+#endif
+		/* Fire up the DMA engine again if it stopped */
+		d->dma_enable = 1;
+		descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	}
+#endif
+#endif
+
+	/* XXXKW mmap/read mixture could break the swframe sequence */
+
+	if (d->frame[d->swframe].state != FRAME_DONE) {
+		if (noblock)
+			return -EAGAIN;
+		else {
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": sleeping for frame\n"));
+			interruptible_sleep_on(&d->frame[d->swframe].read_wait);
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": awakened\n"));
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		}
+	}
+
+	if (count < d->frame[d->swframe].size)
+		return -EFAULT;
+
+	count = d->frame[d->swframe].size;
+	yuvconvert_inplace(d->frame[d->swframe].data, d->frame[d->swframe].size, d->vp.palette, 0);
+	copy_to_user(buf, d->frame[d->swframe].data, d->frame[d->swframe].size);
+	d->swframe = (d->swframe + 1) % NUM_FRAME;
+	/* XXXKW doesn't do format conversion!!! */
+#if !NULL_DMA
+#if !LAZY_READ
+	/* XXXKW Fire up the DMA engine again if it stopped ??? */
+	if (!d->dma_enable) {
+		DBG(DBG_DESCR, printk(KERN_DEBUG IF_NAME ": enabling DMA\n"));
+		/* Fire up the DMA engine again if it stopped */
+		d->dma_enable = 1;
+		descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	}
+#endif
+#endif
+
+	return count;
+}
+
+static int saa7114h_ioctl(struct video_device *vd, unsigned int cmd, void *arg)
+{
+	struct saa7114h *d = vd->priv;
+	int val, reg, retval = 0;
+
+	if (!d)
+		return -ENODEV;
+
+	switch (cmd) {
+	case VIDIOCGCHAN:
+	{
+		struct video_channel v;
+
+		if (copy_from_user(&v, arg, sizeof(v))) {
+			retval = -EFAULT;
+			break;
+		}
+		if (v.channel != 0) {
+			retval = -EINVAL;
+			break;
+		}
+
+		v.channel = 0;
+		strcpy(v.name, "Camera");
+		v.tuners = 0;
+		v.flags = 0;
+		v.type = VIDEO_TYPE_CAMERA;
+		v.norm = 0;
+
+		if (copy_to_user(arg, &v, sizeof(v)))
+			retval = -EFAULT;
+		break;
+	}
+	
+	case VIDIOCSCHAN:
+	{
+		int v;
+
+		if (copy_from_user(&v, arg, sizeof(v)))
+			retval = -EFAULT;
+
+		if (retval == 0 && v != 0)
+			retval = -EINVAL;
+
+		break;
+	}
+
+	case VIDIOCGCAP:
+	{
+		struct video_capability b;
+
+		strcpy(b.name, "Philips SAA7114H Decoder");
+		b.type = VID_TYPE_CAPTURE /* | VID_TYPE_TELETEXT */ | VID_TYPE_SCALES;
+		b.channels = 1;
+		b.audios = 0;
+		b.maxwidth = MAX_HORIZ;
+		b.maxheight = MAX_VERT;
+		/* XXXKW find real values */
+		b.minwidth = 48;
+		b.minheight = 48;
+
+		if (copy_to_user(arg, &b, sizeof(b)))
+			retval = -EFAULT;
+
+		break;
+	}
+
+	/* image properties */
+	case VIDIOCGPICT:
+		if (copy_to_user(arg, &d->vp, sizeof(struct video_picture)))
+			retval = -EFAULT;
+		break;
+		
+	case VIDIOCSPICT:
+	{
+		struct video_picture vp;
+
+		/* copy_from_user */
+		if (copy_from_user(&vp, arg, sizeof(vp))) {
+			retval = -EFAULT;
+			break;
+		}
+
+		down(&d->param_lock);
+		/* brightness, colour, contrast need not check 0-65535 */
+		memcpy( &d->vp, &vp, sizeof(vp) );
+		/* update cam->params.colourParams */
+		saa7114h_set_cparams(d);
+		up(&d->param_lock);
+		break;
+	}
+
+	/* get/set capture window */
+	case VIDIOCGWIN:
+		if (copy_to_user(arg, &d->vw, sizeof(struct video_window)))
+			retval = -EFAULT;
+		break;
+	
+	case VIDIOCSWIN:
+	{
+		/* copy_from_user, check validity, copy to internal structure */
+		struct video_window vw;
+		if (copy_from_user(&vw, arg, sizeof(vw))) {
+			retval = -EFAULT;
+			break;
+		}
+
+		if (vw.clipcount != 0) {    /* clipping not supported */
+			retval = -EINVAL;
+			break;
+		}
+		if (vw.clips != NULL) {	    /* clipping not supported */
+			retval = -EINVAL;
+			break;
+		}
+		if ((vw.width > MAX_HORIZ || vw.width < MIN_HORIZ) ||
+		    (vw.height > MAX_VERT || vw.height < MIN_VERT)) {
+			retval = -EINVAL;
+			break;
+		}
+
+		/* we set the video window to something smaller or equal to what
+		 * is requested by the user???
+		 */
+		down(&d->param_lock);
+		if (vw.width != d->vw.width || vw.height != d->vw.height) {
+			uint32_t scale_factor;
+			/* XXXKW base percentage on input stream, not MAX? */
+
+			/* Assert scaler reset */
+			saa7114h_reg_write(d, 0x88, 0x98);
+
+			/* Vertical scaling */
+			scale_factor = (MAX_VERT*1024) / vw.height;
+			saa7114h_reg_write(d, 0x9e, vw.height & 0xff);
+			saa7114h_reg_write(d, 0x9f, (vw.height >> 8) & 0xf);
+			saa7114h_reg_write(d, 0xb0, scale_factor & 0xff);
+			saa7114h_reg_write(d, 0xb1, (scale_factor >> 8) & 0xff);
+			saa7114h_reg_write(d, 0xb2, scale_factor & 0xff);
+			saa7114h_reg_write(d, 0xb3, (scale_factor >> 8) & 0xff);
+			/* Horizontal scaling */
+			scale_factor = (MAX_HORIZ*1024) / vw.width;
+			saa7114h_reg_write(d, 0x9c, vw.width & 0xff);
+			saa7114h_reg_write(d, 0x9d, (vw.width >> 8) & 0xf);
+			saa7114h_reg_write(d, 0xa8, scale_factor & 0xff);
+			saa7114h_reg_write(d, 0xa9, (scale_factor >> 8) & 0xff);
+			saa7114h_reg_write(d, 0xac, (scale_factor >> 1) & 0xff);
+			saa7114h_reg_write(d, 0xad, (scale_factor >> 9) & 0xff);
+#if 0
+			/* prescaler
+			saa7114h_reg_write(d, 0xa0, 2);
+			saa7114h_reg_write(d, 0xa1, 1);
+			saa7114h_reg_write(d, 0xa2, 1);
+			*/
+#endif
+
+			/* Release scaler reset */
+			saa7114h_reg_write(d, 0x88, 0xb8);
+			d->vw.width = vw.width;
+			d->vw.height = vw.height;
+		}
+		up(&d->param_lock);
+		break;
+	}
+
+	/* mmap interface */
+	case VIDIOCGMBUF:
+	{
+		struct video_mbuf vm;
+		int i;
+
+		memset(&vm, 0, sizeof(vm));
+		vm.size = MAX_FRAME_SIZE*NUM_FRAME;
+		vm.frames = NUM_FRAME;
+		for (i = 0; i < NUM_FRAME; i++)
+			vm.offsets[i] = MAX_FRAME_SIZE * i;
+
+		if (copy_to_user((void *)arg, (void *)&vm, sizeof(vm)))
+			retval = -EFAULT;
+
+		break;
+	}
+
+	case VIDIOCMCAPTURE:
+	{
+		struct video_mmap vm;
+		int descr, status;
+
+		if (copy_from_user((void *)&vm, (void *)arg, sizeof(vm))) {
+			retval = -EFAULT;
+			break;
+		}
+		if (vm.frame<0||vm.frame>NUM_FRAME) {
+			retval = -EINVAL;
+			break;
+		}
+
+		DBG(DBG_CALL,
+		    printk(KERN_DEBUG IF_NAME ":ioctl MCAPTURE %d\n", vm.frame));
+
+		d->vp.palette = vm.format;
+		/* XXXKW set depth? */
+		/* XXXKW match/update for vm.width, vm.height */
+
+		/* XXKW Should check this periodically!? */
+		status = saa7114h_reg_read(d, DECODER_STATUS);
+//		  d->interlaced = ((status & 0x80) != 0);
+
+		/* Give the buffer to the DMA engine */
+		/* XXXKW vm.frame vs d->swframe!!  mmap/read mismatch */
+#if DMA_DEINTERLACE
+		d->frame[vm.frame].pos = d->frame[vm.frame].data + d->vw.width*RAW_PER_PIXEL;
+#else
+		d->frame[vm.frame].pos = d->frame[vm.frame].data;
+#endif
+#if !NULL_DMA
+		d->frame[vm.frame].state = FRAME_READY;
+		/* Fire up the DMA engine again if it stopped */
+		if (!d->dma_enable) {
+			d->dma_enable = 1;
+			d->hwframe = d->swframe = vm.frame;
+			descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+			DBG(DBG_DESCR,
+			    printk(KERN_DEBUG IF_NAME ": capture adds %d -> %d descrs\n",
+				   d->ff.ringsz-descr, descr));
+			__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		}
+#endif
+		break;
+	}
+
+	case VIDIOCSYNC:
+	{
+		int frame;
+
+		if (copy_from_user((void *)&frame, arg, sizeof(int))) {
+			retval = -EFAULT;
+			break;
+		}
+
+		if (frame<0 || frame >= NUM_FRAME) {
+			retval = -EINVAL;
+			break;
+		}
+
+		DBG(DBG_CALL, printk(KERN_DEBUG IF_NAME ":ioctl CSYNC %d\n", frame));
+
+		switch (d->frame[frame].state) {
+		case FRAME_UNUSED:
+			DBG(DBG_IO,
+			    printk(KERN_ERR IF_NAME ":sync to unused frame %d\n", frame));
+			retval = -EINVAL;
+			break;
+
+		case FRAME_READY:
+		case FRAME_GRABBING:
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": sleeping for frame %d\n", frame));
+			interruptible_sleep_on(&d->frame[frame].read_wait);
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": awakened\n"));
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		case FRAME_DONE:
+#if !NULL_DMA
+			yuvconvert_inplace(d->frame[frame].data,
+					   d->frame[frame].size,
+					   d->vp.palette, 1);
+			d->frame[frame].state = FRAME_UNUSED;
+#endif
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": sync finished %d\n",
+				   frame));
+			break;
+		}
+		break;
+	}
+
+	case VIDIOREADREG:
+		reg = *(int *)arg;
+		DBG(DBG_REGISTER, printk(KERN_DEBUG IF_NAME ": read of %02x\n", reg));
+		if ((reg > 0xEF) || (reg < 0))
+			return -EINVAL;
+		val = saa7114h_reg_read((struct saa7114h *)vd->priv, reg);
+		if (val == -1)
+			return -EIO;
+		*(int *)arg = val;
+		break;
+	case VIDIOWRITEREG:
+		if (copy_from_user(&reg, arg, sizeof(int)) ||
+		    copy_from_user(&val, arg+sizeof(int), sizeof(int)))
+			return -EFAULT;
+		DBG(DBG_REGISTER, printk(KERN_DEBUG IF_NAME ": write of %02x <- %02x\n", reg, val));
+		if ((reg > 0xEF) || (reg < 0))
+			return -EINVAL;
+		val = saa7114h_reg_write((struct saa7114h *)vd->priv, reg, val);
+		if (val == -1)
+			return -EIO;
+		break;
+	case VIDIOGRABFRAME:
+		return grab_frame((struct saa7114h *)vd->priv, arg, 0);
+	case VIDIOSHOWEAV:
+		return grab_frame((struct saa7114h *)vd->priv, arg, 1);
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+	return retval;
+}
+
+static int saa7114h_mmap(struct video_device *vd, const char *adr,
+			 unsigned long size)
+{
+	struct saa7114h *d = vd->priv;
+	unsigned long start = (unsigned long)adr;
+	unsigned long page, pos;
+
+	if (!d)
+		return -ENODEV;
+
+	if (size > MAX_MMAP_SIZE) {
+		printk("mmap: bad size %lu > %lu\n", size, MAX_MMAP_SIZE);
+		return -EINVAL;
+	}
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&d->busy_lock))
+		return -EINTR;
+
+	pos = (unsigned long)(d->frame_buf);
+	while (size > 0) {
+		page = kvirt_to_pa(pos);
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+			up(&d->busy_lock);
+			return -EAGAIN;
+		}
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	up(&d->busy_lock);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------
+ * Device probing and initialization
+ * ----------------------------------------------------------------------- */
+
+/* Default values to program into SAA7114H */
+static const unsigned char reg_init[] =	{
+	0x00, 0x00,	/* 00 - ID byte */
+
+	/*front end */
+	0x01, 0x08,	/* 01 - Horizontal increment -> recommended delay */
+	0x02, 0xC4,	/* 02 - AI Control 1 (CVBS AI23) */
+	0x03, 0x10,	/* 03 - AI Control 2 */
+	0x04, 0x90,	/* 04 - AI Control 3 (Gain ch 1) */
+	0x05, 0x90,	/* 05 - AI Control 4 (Gain ch 2) */
+	
+	/* decoder */
+	0x06, 0xEB,	/* 06 - Horiz sync start */
+	0x07, 0xE0,	/* 07 - Horiz sync stop */
+	0x08, 0x98,	/* 08 - Sync control */
+	0x09, 0x40,	/* 09 - L Control */
+	0x0a, 0x80,	/* 0a - L Brightness */
+	0x0b, 0x44,	/* 0b - L Contrast */
+	0x0c, 0x40,	/* 0c - C Saturation */
+	0x0d, 0x00,	/* 0d - C Hue */
+	0x0e, 0x89,	/* 0e - C Control 1 */
+	0x0f, 0x0f,	/* 0f - C Gain (??? 0x2A recommended) */
+	0x10, 0x0E,	/* 10 - C Control 2 */
+	0x11, 0x00,	/* 11 - Mode/Delay */
+	0x12, 0x00,	/* 12 - RT signal control */
+	0x13, 0x00,	/* 13 - RT/X output */
+	0x14, 0x00,	/* 14 - Analog, Compat */
+	0x15, 0x11,	/* 15 - VGATE start */
+	0x16, 0xFE,	/* 16 - VGATE stop */
+	0x17, 0x40,	/* 17 - Misc VGATE (disable LLC2) */
+	0x18, 0x40,	/* 18 - Raw data gain - 128 */
+	0x19, 0x80,	/* 19 - Raw data offset - 0 */
+
+	/* Global settings */
+	0x88, 0x98,	/* 88 - AI1x on, AI2x off; decoder/slicer off; ACLK gen off */
+	0x83, 0x00,	/* 83 - X-port output disabled */
+	0x84, 0xF0,	/* 84 - I-port V/G output framing, IGP1=0=IGP0=0 */
+	0x85, 0x00,	/* 85 - I-port default polarities, X-port signals */
+	0x86, 0x40,	/* 86 - more IGP1/0, FIFO level, only video transmitted */
+	0x87, 0x01,	/* 87 - ICK default, IDQ default, I-port output enabled */
+
+	/* Task A: scaler input config and output format */
+	0x90, 0x00,	/* 90 - Task handling */
+	0x91, 0x08,	/* 91 - Scalar input and format */
+	0x92, 0x10,	/* 92 - Reference signal def */
+	0x93, 0x80,	/* 93 - I-port output */
+
+	/* Task B */
+	0xc0, 0x42,	/* 90 - Task handling */
+	0xc1, 0x08,	/* 91 - Scalar input and format */
+	0xc2, 0x10,	/* 92 - Reference signal def */
+	0xc3, 0x80,	/* 93 - I-port output */
+
+	/* Input and Output windows */
+	0x94, 0x10,	/*  - */
+	0x95, 0x00,	/*  - */
+	0x96, 0xD0,	/*  - */
+	0x97, 0x02,	/*  - */
+	0x98, 0x0A,	/*  - */
+	0x99, 0x00,	/*  - */
+	0x9a, 0xF2,	/*  - */
+	0x9b, 0x00,	/*  - */
+	0x9c, 0xD0,	/*  - */
+	0x9d, 0x02,	/*  - */
+	0xc4, 0x10,	/*  - */
+	0xc5, 0x00,	/*  - */
+	0xc6, 0xD0,	/*  - */
+	0xc7, 0x02,	/*  - */
+	0xc8, 0x0A,	/*  - */
+	0xc9, 0x00,	/*  - */
+	0xca, 0xF2,	/*  - */
+	0xcb, 0x00,	/*  - */
+	0xcc, 0xD0,	/*  - */
+	0xcd, 0x02,	/*  - */
+
+	0x9e, 0xf0,	/*  - */
+	0x9f, 0x00,	/*  - */
+	0xce, 0xf0,	/*  - */
+	0xcf, 0x00,	/*  - */
+
+	/* Prefiltering and prescaling */
+	0xa0, 0x01,	/*  - */
+	0xa1, 0x00,	/*  - */
+	0xa2, 0x00,	/*  - */
+	0xa4, 0x80,	/*  - */
+	0xa5, 0x40,	/*  - */
+	0xa6, 0x40,	/*  - */
+	0xd4, 0x80,	/*  - */
+	0xd5, 0x40,	/*  - */
+	0xd6, 0x40,	/*  - */
+
+	/* Horizontal phase scaling */
+	0xa8, 0x00,	/*  - */
+	0xa9, 0x04,	/*  - */
+	0xaa, 0x00,	/*  - */
+	0xd8, 0x00,	/*  - */
+	0xd9, 0x04,	/*  - */
+	0xda, 0x00,	/*  - */
+
+	0xac, 0x00,	/*  - */
+	0xad, 0x02,	/*  - */
+	0xae, 0x00,	/*  - */
+	0xdc, 0x00,	/*  - */
+	0xdd, 0x02,	/*  - */
+	0xde, 0x00,	/*  - */
+
+	/* Vertical phase scaling */
+	0xb0, 0x00,	/*  - */
+	0xb1, 0x04,	/*  - */
+	0xb2, 0x00,	/*  - */
+	0xb3, 0x04,	/*  - */
+	0xe0, 0x00,	/*  - */
+	0xe1, 0x04,	/*  - */
+	0xe2, 0x00,	/*  - */
+	0xe3, 0x04,	/*  - */
+	0xb4, 0x00,	/* b4 - vscale mode control */
+	0xe4, 0x00,	/* b4 - vscale mode control */
+
+	/* Task enables */
+	0x80, 0x10,	/* 80 - LLC->ICLK, dq->IDQ, scaler->F/V timing, task enables */
+
+	/* Reset the slicer */
+	0x88, 0xb8,	/* 88 - AI1x on, AI2x off; decoder/slicer on; ACLK gen off */
+};
+
+static int saa7114h_attach(struct i2c_adapter *adap, int addr, unsigned short flags, int kind)
+{
+	struct i2c_client *client;
+	struct video_device *vd;
+	struct saa7114h *decoder;
+	int err;
+	int val, i;
+
+	client = kmalloc(sizeof(*client), GFP_KERNEL);
+	if (client == NULL)
+		return -ENOMEM;
+	client->adapter = adap;
+	client->addr = addr;
+	client->driver = &i2c_driver_saa7114h;
+	strcpy(client->name, IF_NAME);
+
+	decoder = kmalloc(sizeof(*decoder), GFP_KERNEL);
+	if (decoder == NULL) {
+		kfree(client);
+		return -ENOMEM;
+	}
+	memset(decoder, 0, sizeof(struct saa7114h));
+	decoder->client = client;
+	decoder->dma_enable = 0;
+	decoder->palette = VIDEO_PALETTE_UYVY;
+	decoder->depth = 16;
+	decoder->vw.width = MAX_HORIZ;
+	decoder->vw.height = MAX_VERT;
+	decoder->frame_buf = rvmalloc(MAX_FRAME_SIZE*NUM_FRAME);
+	if (!decoder->frame_buf) {
+		kfree(decoder);
+		kfree(client);
+		return -ENOMEM;
+	}
+	/* XXXKW use clear_page? */
+	memset(decoder->frame_buf, 0, MAX_FRAME_SIZE*NUM_FRAME);
+	printk("saa7114h_attach: frame_buf = (fb=%8p / %08lx)\n",
+	       decoder->frame_buf, kvirt_to_pa((int)decoder->frame_buf));
+	for (i=0; i<NUM_FRAME; i++) {
+		decoder->frame[i].data = decoder->frame_buf+i*MAX_FRAME_SIZE;
+#if NULL_DMA
+		decoder->frame[i].state = FRAME_DONE;
+#else
+		decoder->frame[i].state = FRAME_UNUSED;
+#endif
+		init_waitqueue_head(&decoder->frame[i].read_wait);
+	}
+	decoder->irq = K_INT_MAC_2;
+	if (request_irq
+	    (decoder->irq, saa7114h_interrupt, 0, "Philips SAA7114h", decoder)) {
+		rvfree(decoder->frame_buf, MAX_FRAME_SIZE*NUM_FRAME);
+		kfree(decoder);
+		kfree(client);
+		return -ENOMEM;
+	}
+	init_MUTEX(&decoder->param_lock);
+	init_MUTEX(&decoder->busy_lock);
+
+	if ((err = i2c_attach_client(client)) < 0) {
+		kfree(client);
+		kfree(decoder);
+		return err;
+	}
+
+	if (saa7114h_reg_init(decoder, reg_init, sizeof(reg_init)) ||
+	    saa7114h_get_cparams(decoder)) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		return -ENODEV;
+	}
+
+	vd = kmalloc(sizeof(*vd), GFP_KERNEL);
+	memset(vd, 0, sizeof(*vd));
+	if (vd == NULL) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		return -ENOMEM;
+	}
+	vd->priv = decoder;
+	strcpy(vd->name, IF_NAME);
+	vd->type = VID_TYPE_CAPTURE;
+	vd->hardware = VID_HARDWARE_SAA7114H;
+	vd->open =  saa7114h_open;
+	vd->close = saa7114h_release;
+	vd->read =  saa7114h_read;
+	vd->ioctl = saa7114h_ioctl;
+	vd->mmap =  saa7114h_mmap;
+
+	if ((err = video_register_device(vd, VFL_TYPE_GRABBER, -1)) < 0) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		kfree(vd);
+		return err;
+	}
+
+	client->data = vd;
+	decoder->vd = vd;
+
+	/* Turn on the ITRDY - preserve the GENO pin for syncser */
+	val = __raw_readq(KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO));
+	__raw_writeq(M_MAC_MDIO_OUT | (val & M_MAC_GENC),
+	      KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO));
+
+	if ((err = dma_setup(decoder))) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		kfree(vd);
+		return err;
+	}
+
+	printk("saa7114h_attach successful\n");
+
+#ifdef CONFIG_PROC_FS
+	proc_saa7114h_create();
+	create_proc_decoder(vd->priv);
+#endif
+
+	return 0;
+}
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = {I2C_CLIENT_END};
+static unsigned short normal_i2c_range[] = {0x20, 0x21, I2C_CLIENT_END};
+static unsigned short probe[2]	      = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2]  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2]	      = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2]	      = { I2C_CLIENT_END, I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data = {
+	normal_i2c, normal_i2c_range,
+	probe, probe_range,
+	ignore, ignore_range,
+	force
+};
+
+static int saa7114h_probe(struct i2c_adapter *adap)
+{
+	/* Look for this device on the given adapter (bus) */
+	if (adap->id == (I2C_ALGO_SIBYTE | I2C_HW_SIBYTE))
+		return i2c_probe(adap, &addr_data, &saa7114h_attach);
+	else
+		return 0;
+}
+
+static int saa7114h_detach(struct i2c_client *device)
+{
+#if 0
+	kfree(device->data);
+#endif
+#ifdef CONFIG_PROC_FS
+	destroy_proc_decoder(((struct video_device *)device->data)->priv);
+	proc_saa7114h_destroy();
+#endif
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static int __init swarm_7114h_init(void)
+{
+	return i2c_add_driver(&i2c_driver_saa7114h);
+}
+
+static void __exit swarm_7114h_cleanup(void)
+{
+}
+
+MODULE_AUTHOR("Kip Walker, Broadcom Corp.");
+MODULE_DESCRIPTION("Philips SAA7114H Driver for Broadcom SWARM board");
+
+module_init(swarm_7114h_init);
+module_exit(swarm_7114h_cleanup);
diff -Naur linux-2.6.14/drivers/media/video/vino.c linux-mips-2.6.14.orig/drivers/media/video/vino.c
--- linux-2.6.14/drivers/media/video/vino.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/media/video/vino.c	2005-11-17 11:42:59.000000000 -0800
@@ -12,28 +12,25 @@
 
 /*
  * TODO:
- * - remove "hacks" from memory allocation code and implement nopage()
+ * - remove "mark pages reserved-hacks" from memory allocation code
+ *   and implement nopage()
  * - check decimation, calculating and reporting image size when
  *   using decimation
- * - check vino_acquire_input(), vino_set_input() and channel
- *   ownership handling
- * - report VINO error-interrupts via ioctls ?
- * - implement picture controls (all implemented?)
- * - use macros for boolean values (?)
- * - implement user mode buffers and overlay (?)
+ * - implement read(), user mode buffers and overlay (?)
  */
 
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/dma-mapping.h>
 #include <linux/errno.h>
 #include <linux/fs.h>
+#include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/dma-mapping.h>
-#include <linux/time.h>
 #include <linux/moduleparam.h>
+#include <linux/time.h>
+#include <linux/version.h>
 
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
@@ -59,18 +56,16 @@
  * debug info.
  * Note that the debug output also slows down the driver significantly */
 // #define VINO_DEBUG
+// #define VINO_DEBUG_INT
 
-#define VINO_MODULE_VERSION "0.0.3"
-#define VINO_VERSION_CODE KERNEL_VERSION(0, 0, 3)
+#define VINO_MODULE_VERSION "0.0.5"
+#define VINO_VERSION_CODE KERNEL_VERSION(0, 0, 5)
 
 MODULE_DESCRIPTION("SGI VINO Video4Linux2 driver");
 MODULE_VERSION(VINO_MODULE_VERSION);
 MODULE_AUTHOR("Mikael Nousiainen <tmnousia@cc.hut.fi>");
 MODULE_LICENSE("GPL");
 
-#define mem_map_reserve(p) set_bit(PG_reserved, &((p)->flags))
-#define mem_map_unreserve(p) clear_bit(PG_reserved, &((p)->flags))
-
 #ifdef VINO_DEBUG
 #define dprintk(x...) printk("VINO: " x);
 #else
@@ -90,15 +85,16 @@
 #define VINO_MIN_HEIGHT			32
 
 #define VINO_CLIPPING_START_ODD_D1	1
-#define VINO_CLIPPING_START_ODD_PAL	1
-#define VINO_CLIPPING_START_ODD_NTSC	1
+#define VINO_CLIPPING_START_ODD_PAL	15
+#define VINO_CLIPPING_START_ODD_NTSC	12
 
 #define VINO_CLIPPING_START_EVEN_D1	2
-#define VINO_CLIPPING_START_EVEN_PAL	2
-#define VINO_CLIPPING_START_EVEN_NTSC	2
+#define VINO_CLIPPING_START_EVEN_PAL	15
+#define VINO_CLIPPING_START_EVEN_NTSC	12
 
 #define VINO_INPUT_CHANNEL_COUNT	3
 
+/* the number is the index for vino_inputs */
 #define VINO_INPUT_NONE			-1
 #define VINO_INPUT_COMPOSITE		0
 #define VINO_INPUT_SVIDEO		1
@@ -106,15 +102,13 @@
 
 #define VINO_PAGE_RATIO			(PAGE_SIZE / VINO_PAGE_SIZE)
 
-#define VINO_FIFO_THRESHOLD_DEFAULT	512
+#define VINO_FIFO_THRESHOLD_DEFAULT	16
 
-/*#define VINO_FRAMEBUFFER_SIZE		(VINO_PAL_WIDTH * VINO_PAL_HEIGHT * 4 \
-  + 2 * PAGE_SIZE)*/
 #define VINO_FRAMEBUFFER_SIZE		((VINO_PAL_WIDTH \
 					  * VINO_PAL_HEIGHT * 4 \
 					  + 3 * PAGE_SIZE) & ~(PAGE_SIZE - 1))
 
-#define VINO_FRAMEBUFFER_MAX_COUNT	8
+#define VINO_FRAMEBUFFER_COUNT_MAX	8
 
 #define VINO_FRAMEBUFFER_UNUSED		0
 #define VINO_FRAMEBUFFER_IN_USE		1
@@ -130,24 +124,27 @@
 #define VINO_DUMMY_DESC_COUNT		4
 #define VINO_DESC_FETCH_DELAY		5	/* microseconds */
 
+#define VINO_MAX_FRAME_SKIP_COUNT	128
+
 /* the number is the index for vino_data_formats */
 #define VINO_DATA_FMT_NONE		-1
 #define VINO_DATA_FMT_GREY		0
 #define VINO_DATA_FMT_RGB332		1
 #define VINO_DATA_FMT_RGB32		2
 #define VINO_DATA_FMT_YUV		3
-//#define VINO_DATA_FMT_RGB24		4
 
 #define VINO_DATA_FMT_COUNT		4
 
+/* the number is the index for vino_data_norms */
 #define VINO_DATA_NORM_NONE		-1
 #define VINO_DATA_NORM_NTSC		0
 #define VINO_DATA_NORM_PAL		1
 #define VINO_DATA_NORM_SECAM		2
 #define VINO_DATA_NORM_D1		3
-/* The following is a special entry that can be used to
+/* The following are special entries that can be used to
  * autodetect the norm. */
-#define VINO_DATA_NORM_AUTO		0xff
+#define VINO_DATA_NORM_AUTO		0xfe
+#define VINO_DATA_NORM_AUTO_EXT		0xff
 
 #define VINO_DATA_NORM_COUNT		4
 
@@ -231,7 +228,7 @@
 	unsigned int head;
 	unsigned int tail;
 
-	unsigned int data[VINO_FRAMEBUFFER_MAX_COUNT];
+	unsigned int data[VINO_FRAMEBUFFER_COUNT_MAX];
 };
 
 struct vino_framebuffer_queue {
@@ -245,13 +242,20 @@
 	struct vino_framebuffer_fifo in;
 	struct vino_framebuffer_fifo out;
 
-	struct vino_framebuffer *buffer[VINO_FRAMEBUFFER_MAX_COUNT];
+	struct vino_framebuffer *buffer[VINO_FRAMEBUFFER_COUNT_MAX];
 
 	spinlock_t queue_lock;
 	struct semaphore queue_sem;
 	wait_queue_head_t frame_wait_queue;
 };
 
+struct vino_interrupt_data {
+	struct timeval timestamp;
+	unsigned int frame_counter;
+	unsigned int skip_count;
+	unsigned int skip;
+};
+
 struct vino_channel_settings {
 	unsigned int channel;
 
@@ -284,6 +288,8 @@
 
 	unsigned int users;
 
+	struct vino_interrupt_data int_data;
+
 	/* V4L support */
 	struct video_device *v4l_device;
 };
@@ -314,7 +320,7 @@
 /* Module parameters */
 
 /*
- * Using vino_pixel_conversion the ARGB32-format pixels supplied
+ * Using vino_pixel_conversion the ABGR32-format pixels supplied
  * by the VINO chip can be converted to more common formats
  * like RGBA32 (or probably RGB24 in the future). This way we
  * can give out data that can be specified correctly with
@@ -328,7 +334,9 @@
  * Use non-zero value to enable conversion.
  */
 static int vino_pixel_conversion = 0;
+
 module_param_named(pixelconv, vino_pixel_conversion, int, 0);
+
 MODULE_PARM_DESC(pixelconv,
 		 "enable pixel conversion (non-zero value enables)");
 
@@ -344,15 +352,22 @@
 static const char *vino_v4l_device_name_a = "SGI VINO Channel A";
 static const char *vino_v4l_device_name_b = "SGI VINO Channel B";
 
+static void vino_capture_tasklet(unsigned long channel);
+
+DECLARE_TASKLET(vino_tasklet_a, vino_capture_tasklet, VINO_CHANNEL_A);
+DECLARE_TASKLET(vino_tasklet_b, vino_capture_tasklet, VINO_CHANNEL_B);
+
 static const struct vino_input vino_inputs[] = {
 	{
 		.name		= "Composite",
-		.std		= V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,
+		.std		= V4L2_STD_NTSC | V4L2_STD_PAL
+		| V4L2_STD_SECAM,
 	},{
 		.name		= "S-Video",
-		.std		= V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM,
+		.std		= V4L2_STD_NTSC | V4L2_STD_PAL
+		| V4L2_STD_SECAM,
 	},{
-		.name		= "D1 (IndyCam)",
+		.name		= "D1/IndyCam",
 		.std		= V4L2_STD_NTSC,
 	}
 };
@@ -375,15 +390,10 @@
 		.colorspace	= V4L2_COLORSPACE_SRGB,
 	},{
 		.description	= "YUV 4:2:2",
-		.bpp		= 4,
+		.bpp		= 2,
 		.pixelformat	= V4L2_PIX_FMT_YUYV, // XXX: swapped?
 		.colorspace	= V4L2_COLORSPACE_SMPTE170M,
-	}/*,{
-		.description	= "24-bit RGB",
-		.bpp		= 3,
-		.pixelformat	= V4L2_PIX_FMT_RGB24,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		}*/
+	}
 };
 
 static const struct vino_data_norm vino_data_norms[] = {
@@ -396,18 +406,18 @@
 		.width		= VINO_NTSC_WIDTH,
 		.height		= VINO_NTSC_HEIGHT,
 		.odd		= {
-			.top 	= VINO_CLIPPING_START_ODD_NTSC,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_ODD_NTSC,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_ODD_NTSC
 			+ VINO_NTSC_HEIGHT / 2 - 1,
-			.right 	= VINO_NTSC_WIDTH,
+			.right	= VINO_NTSC_WIDTH,
 		},
 		.even		= {
-			.top 	= VINO_CLIPPING_START_EVEN_NTSC,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_EVEN_NTSC,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_EVEN_NTSC
 			+ VINO_NTSC_HEIGHT / 2 - 1,
-			.right 	= VINO_NTSC_WIDTH,
+			.right	= VINO_NTSC_WIDTH,
 		},
 	},{
 		.description	= "PAL",
@@ -418,18 +428,18 @@
 		.width		= VINO_PAL_WIDTH,
 		.height		= VINO_PAL_HEIGHT,
 		.odd		= {
-			.top 	= VINO_CLIPPING_START_ODD_PAL,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_ODD_PAL,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_ODD_PAL
 			+ VINO_PAL_HEIGHT / 2 - 1,
-			.right 	= VINO_PAL_WIDTH,
+			.right	= VINO_PAL_WIDTH,
 		},
 		.even		= {
-			.top 	= VINO_CLIPPING_START_EVEN_PAL,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_EVEN_PAL,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_EVEN_PAL
 			+ VINO_PAL_HEIGHT / 2 - 1,
-			.right 	= VINO_PAL_WIDTH,
+			.right	= VINO_PAL_WIDTH,
 		},
 	},{
 		.description	= "SECAM",
@@ -440,21 +450,21 @@
 		.width		= VINO_PAL_WIDTH,
 		.height		= VINO_PAL_HEIGHT,
 		.odd		= {
-			.top 	= VINO_CLIPPING_START_ODD_PAL,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_ODD_PAL,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_ODD_PAL
 			+ VINO_PAL_HEIGHT / 2 - 1,
-			.right 	= VINO_PAL_WIDTH,
+			.right	= VINO_PAL_WIDTH,
 		},
 		.even		= {
-			.top 	= VINO_CLIPPING_START_EVEN_PAL,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_EVEN_PAL,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_EVEN_PAL
 			+ VINO_PAL_HEIGHT / 2 - 1,
-			.right 	= VINO_PAL_WIDTH,
+			.right	= VINO_PAL_WIDTH,
 		},
 	},{
-		.description	= "NTSC (D1 input)",
+		.description	= "NTSC/D1",
 		.std		= V4L2_STD_NTSC,
 		.fps_min	= 6,
 		.fps_max	= 30,
@@ -462,18 +472,18 @@
 		.width		= VINO_NTSC_WIDTH,
 		.height		= VINO_NTSC_HEIGHT,
 		.odd		= {
-			.top 	= VINO_CLIPPING_START_ODD_D1,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_ODD_D1,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_ODD_D1
 			+ VINO_NTSC_HEIGHT / 2 - 1,
-			.right 	= VINO_NTSC_WIDTH,
+			.right	= VINO_NTSC_WIDTH,
 		},
 		.even		= {
-			.top 	= VINO_CLIPPING_START_EVEN_D1,
-			.left 	= 0,
+			.top	= VINO_CLIPPING_START_EVEN_D1,
+			.left	= 0,
 			.bottom	= VINO_CLIPPING_START_EVEN_D1
 			+ VINO_NTSC_HEIGHT / 2 - 1,
-			.right 	= VINO_NTSC_WIDTH,
+			.right	= VINO_NTSC_WIDTH,
 		},
 	}
 };
@@ -490,7 +500,7 @@
 		.step = 1,
 		.default_value = INDYCAM_AGC_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_AGC, 0 },
 	},{
 		.id = V4L2_CID_AUTO_WHITE_BALANCE,
 		.type = V4L2_CTRL_TYPE_BOOLEAN,
@@ -500,7 +510,7 @@
 		.step = 1,
 		.default_value = INDYCAM_AWB_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_AWB, 0 },
 	},{
 		.id = V4L2_CID_GAIN,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -510,7 +520,7 @@
 		.step = 1,
 		.default_value = INDYCAM_GAIN_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_GAIN, 0 },
 	},{
 		.id = V4L2_CID_PRIVATE_BASE,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -520,7 +530,7 @@
 		.step = 1,
 		.default_value = INDYCAM_RED_SATURATION_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_RED_SATURATION, 0 },
 	},{
 		.id = V4L2_CID_PRIVATE_BASE + 1,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -530,7 +540,7 @@
 		.step = 1,
 		.default_value = INDYCAM_BLUE_SATURATION_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_BLUE_SATURATION, 0 },
 	},{
 		.id = V4L2_CID_RED_BALANCE,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -540,7 +550,7 @@
 		.step = 1,
 		.default_value = INDYCAM_RED_BALANCE_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_RED_BALANCE, 0 },
 	},{
 		.id = V4L2_CID_BLUE_BALANCE,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -550,7 +560,7 @@
 		.step = 1,
 		.default_value = INDYCAM_BLUE_BALANCE_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_BLUE_BALANCE, 0 },
 	},{
 		.id = V4L2_CID_EXPOSURE,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -560,7 +570,7 @@
 		.step = 1,
 		.default_value = INDYCAM_SHUTTER_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_SHUTTER, 0 },
 	},{
 		.id = V4L2_CID_GAMMA,
 		.type = V4L2_CTRL_TYPE_INTEGER,
@@ -570,11 +580,11 @@
 		.step = 1,
 		.default_value = INDYCAM_GAMMA_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { INDYCAM_CONTROL_GAMMA, 0 },
 	}
 };
 
-#define VINO_SAA7191_V4L2_CONTROL_COUNT		2
+#define VINO_SAA7191_V4L2_CONTROL_COUNT		9
 
 struct v4l2_queryctrl vino_saa7191_v4l2_controls[] = {
 	{
@@ -586,9 +596,59 @@
 		.step = 1,
 		.default_value = SAA7191_HUE_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { SAA7191_CONTROL_HUE, 0 },
 	},{
 		.id = V4L2_CID_PRIVATE_BASE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Luminance Bandpass",
+		.minimum = SAA7191_BANDPASS_MIN,
+		.maximum = SAA7191_BANDPASS_MAX,
+		.step = 1,
+		.default_value = SAA7191_BANDPASS_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_BANDPASS, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 1,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Luminance Bandpass Weight",
+		.minimum = SAA7191_BANDPASS_WEIGHT_MIN,
+		.maximum = SAA7191_BANDPASS_WEIGHT_MAX,
+		.step = 1,
+		.default_value = SAA7191_BANDPASS_WEIGHT_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_BANDPASS_WEIGHT, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 2,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "HF Luminance Coring",
+		.minimum = SAA7191_CORING_MIN,
+		.maximum = SAA7191_CORING_MAX,
+		.step = 1,
+		.default_value = SAA7191_CORING_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_CORING, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 3,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Force Colour",
+		.minimum = SAA7191_FORCE_COLOUR_MIN,
+		.maximum = SAA7191_FORCE_COLOUR_MAX,
+		.step = 1,
+		.default_value = SAA7191_FORCE_COLOUR_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_FORCE_COLOUR, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 4,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Chrominance Gain Control",
+		.minimum = SAA7191_CHROMA_GAIN_MIN,
+		.maximum = SAA7191_CHROMA_GAIN_MAX,
+		.step = 1,
+		.default_value = SAA7191_CHROMA_GAIN_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_CHROMA_GAIN, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 5,
 		.type = V4L2_CTRL_TYPE_BOOLEAN,
 		.name = "VTR Time Constant",
 		.minimum = SAA7191_VTRC_MIN,
@@ -596,7 +656,27 @@
 		.step = 1,
 		.default_value = SAA7191_VTRC_DEFAULT,
 		.flags = 0,
-		.reserved = { 0, 0 },
+		.reserved = { SAA7191_CONTROL_VTRC, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 6,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Luminance Delay Compensation",
+		.minimum = SAA7191_LUMA_DELAY_MIN,
+		.maximum = SAA7191_LUMA_DELAY_MAX,
+		.step = 1,
+		.default_value = SAA7191_LUMA_DELAY_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_LUMA_DELAY, 0 },
+	},{
+		.id = V4L2_CID_PRIVATE_BASE + 7,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Vertical Noise Reduction",
+		.minimum = SAA7191_VNR_MIN,
+		.maximum = SAA7191_VNR_MAX,
+		.step = 1,
+		.default_value = SAA7191_VNR_DEFAULT,
+		.flags = 0,
+		.reserved = { SAA7191_CONTROL_VNR, 0 },
 	}
 };
 
@@ -638,9 +718,10 @@
  */
 static int i2c_vino_client_reg(struct i2c_client *client)
 {
+	unsigned long flags;
 	int ret = 0;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 	switch (client->driver->id) {
 	case I2C_DRIVERID_SAA7191:
 		if (vino_drvdata->decoder.driver)
@@ -657,16 +738,17 @@
 	default:
 		ret = -ENODEV;
 	}
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return ret;
 }
 
 static int i2c_vino_client_unreg(struct i2c_client *client)
 {
+	unsigned long flags;
 	int ret = 0;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 	if (client == vino_drvdata->decoder.driver) {
 		if (vino_drvdata->decoder.owner != VINO_NO_CHANNEL)
 			ret = -EBUSY;
@@ -678,7 +760,7 @@
 		else
 			vino_drvdata->camera.driver = NULL;
 	}
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return ret;
 }
@@ -726,7 +808,7 @@
 	dprintk("vino_free_buffer_with_count(): count = %d\n", count);
 
 	for (i = 0; i < count; i++) {
-		mem_map_unreserve(virt_to_page(fb->desc_table.virtual[i]));
+		ClearPageReserved(virt_to_page(fb->desc_table.virtual[i]));
 		dma_unmap_single(NULL,
 				 fb->desc_table.dma_cpu[VINO_PAGE_RATIO * i],
 				 PAGE_SIZE, DMA_FROM_DEVICE);
@@ -804,7 +886,7 @@
 				dma_data_addr + VINO_PAGE_SIZE * j;
 		}
 
-		mem_map_reserve(virt_to_page(fb->desc_table.virtual[i]));
+		SetPageReserved(virt_to_page(fb->desc_table.virtual[i]));
 	}
 
 	/* page_count needs to be set anyway, because the descriptor table has
@@ -891,7 +973,7 @@
 				dma_data_addr + VINO_PAGE_SIZE * j;
 		}
 
-		mem_map_reserve(virt_to_page(fb->desc_table.virtual[i]));
+		SetPageReserved(virt_to_page(fb->desc_table.virtual[i]));
 	}
 
 	/* page_count needs to be set anyway, because the descriptor table has
@@ -932,7 +1014,7 @@
 
 /* Framebuffer fifo functions (need to be locked externally) */
 
-static void vino_fifo_init(struct vino_framebuffer_fifo *f,
+static inline void vino_fifo_init(struct vino_framebuffer_fifo *f,
 			   unsigned int length)
 {
 	f->length = 0;
@@ -940,16 +1022,18 @@
 	f->head = 0;
 	f->tail = 0;
 
-	if (length > VINO_FRAMEBUFFER_MAX_COUNT)
-		length = VINO_FRAMEBUFFER_MAX_COUNT;
+	if (length > VINO_FRAMEBUFFER_COUNT_MAX)
+		length = VINO_FRAMEBUFFER_COUNT_MAX;
 
 	f->length = length;
 }
 
 /* returns true/false */
-static int vino_fifo_has_id(struct vino_framebuffer_fifo *f, unsigned int id)
+static inline int vino_fifo_has_id(struct vino_framebuffer_fifo *f,
+				   unsigned int id)
 {
 	unsigned int i;
+
 	for (i = f->head; i == (f->tail - 1); i = (i + 1) % f->length) {
 		if (f->data[i] == id)
 			return 1;
@@ -958,13 +1042,15 @@
 	return 0;
 }
 
+#if 0
 /* returns true/false */
-static int vino_fifo_full(struct vino_framebuffer_fifo *f)
+static inline int vino_fifo_full(struct vino_framebuffer_fifo *f)
 {
 	return (f->used == f->length);
 }
+#endif
 
-static unsigned int vino_fifo_get_used(struct vino_framebuffer_fifo *f)
+static inline unsigned int vino_fifo_get_used(struct vino_framebuffer_fifo *f)
 {
 	return f->used;
 }
@@ -1075,8 +1161,8 @@
 
 	down(&q->queue_sem);
 
-	if (*length > VINO_FRAMEBUFFER_MAX_COUNT)
-		*length = VINO_FRAMEBUFFER_MAX_COUNT;
+	if (*length > VINO_FRAMEBUFFER_COUNT_MAX)
+		*length = VINO_FRAMEBUFFER_COUNT_MAX;
 
 	q->length = 0;
 
@@ -1312,6 +1398,7 @@
 	return ret;
 }
 
+#if 0
 static int vino_queue_get_total(struct vino_framebuffer_queue *q,
 				unsigned int *total)
 {
@@ -1337,6 +1424,7 @@
 
 	return ret;
 }
+#endif
 
 static struct vino_framebuffer *vino_queue_peek(struct
 						vino_framebuffer_queue *q,
@@ -1470,12 +1558,14 @@
 
 	dprintk("update_line_size(): before: w = %d, d = %d, "
 		"line_size = %d\n", w, d, vcs->line_size);
+
         /* line size must be multiple of 8 bytes */
 	lsize = (bpp * (w / d)) & ~7;
 	w = (lsize / bpp) * d;
 
 	vcs->clipping.right = vcs->clipping.left + w;
 	vcs->line_size = lsize;
+
 	dprintk("update_line_size(): after: w = %d, d = %d, "
 		"line_size = %d\n", w, d, vcs->line_size);
 }
@@ -1531,7 +1621,7 @@
 }
 
 /* execute with input_lock locked */
-static void vino_set_default_clipping(struct vino_channel_settings *vcs)
+static inline void vino_set_default_clipping(struct vino_channel_settings *vcs)
 {
 	vino_set_clipping(vcs, 0, 0, vino_data_norms[vcs->data_norm].width,
 			  vino_data_norms[vcs->data_norm].height);
@@ -1555,8 +1645,7 @@
 
 	if (d < 1) {
 		d = 1;
-	}
-	if (d > 8) {
+	} else if (d > 8) {
 		d = 8;
 	}
 
@@ -1569,7 +1658,7 @@
 }
 
 /* execute with input_lock locked */
-static void vino_reset_scaling(struct vino_channel_settings *vcs)
+static inline void vino_set_default_scaling(struct vino_channel_settings *vcs)
 {
 	vino_set_scaling(vcs, vcs->clipping.right - vcs->clipping.left,
 			 vcs->clipping.bottom - vcs->clipping.top);
@@ -1648,7 +1737,8 @@
 }
 
 /* execute with input_lock locked */
-static void vino_set_default_framerate(struct vino_channel_settings *vcs)
+static inline void vino_set_default_framerate(struct
+					      vino_channel_settings *vcs)
 {
 	vino_set_framerate(vcs, vino_data_norms[vcs->data_norm].fps_max);
 }
@@ -1686,6 +1776,9 @@
 	 * should be more than enough time */
 	udelay(VINO_DESC_FETCH_DELAY);
 
+	dprintk("vino_dma_setup(): start desc = %08x, next 4 desc = %08x\n",
+		ch->start_desc_tbl, ch->next_4_desc);
+
 	/* set the alpha register */
 	ch->alpha = vcs->alpha;
 
@@ -1699,9 +1792,6 @@
 		VINO_CLIP_EVEN(norm->even.top +
 			       vcs->clipping.bottom / 2 - 1) |
 		VINO_CLIP_X(vcs->clipping.right);
-	/* FIXME: end-of-field bug workaround
-		       VINO_CLIP_X(VINO_PAL_WIDTH);
-	 */
 
 	/* set the size of actual content in the buffer (DECIMATION !) */
 	fb->data_size = ((vcs->clipping.right - vcs->clipping.left) /
@@ -1801,7 +1891,7 @@
 }
 
 /* (execute only with vino_lock locked) */
-static void vino_dma_start(struct vino_channel_settings *vcs)
+static inline void vino_dma_start(struct vino_channel_settings *vcs)
 {
 	u32 ctrl = vino->control;
 
@@ -1812,12 +1902,14 @@
 }
 
 /* (execute only with vino_lock locked) */
-static void vino_dma_stop(struct vino_channel_settings *vcs)
+static inline void vino_dma_stop(struct vino_channel_settings *vcs)
 {
 	u32 ctrl = vino->control;
 
 	ctrl &= (vcs->channel == VINO_CHANNEL_A) ?
 		~VINO_CTRL_A_DMA_ENBL : ~VINO_CTRL_B_DMA_ENBL;
+	ctrl &= (vcs->channel == VINO_CHANNEL_A) ?
+		~VINO_CTRL_A_INT : ~VINO_CTRL_B_INT;
 	vino->control = ctrl;
 	dprintk("vino_dma_stop():\n");
 }
@@ -1901,7 +1993,7 @@
 	struct vino_framebuffer *fb;
 	unsigned int incoming, id;
 	int err = 0;
-	unsigned long flags, flags2;
+	unsigned long flags;
 
 	dprintk("vino_capture_next():\n");
 
@@ -1942,10 +2034,6 @@
 		goto out;
 	}
 
-	spin_lock_irqsave(&fb->state_lock, flags2);
-	fb->state = VINO_FRAMEBUFFER_UNUSED;
-	spin_unlock_irqrestore(&fb->state_lock, flags2);
-
 	if (start) {
 		vcs->capturing = 1;
 	}
@@ -1963,7 +2051,7 @@
 	return err;
 }
 
-static int vino_is_capturing(struct vino_channel_settings *vcs)
+static inline int vino_is_capturing(struct vino_channel_settings *vcs)
 {
 	int ret;
 	unsigned long flags;
@@ -2075,6 +2163,7 @@
 	dprintk("vino_capture_stop():\n");
 
 	spin_lock_irqsave(&vcs->capture_lock, flags);
+
 	/* unset capturing to stop queue processing */
 	vcs->capturing = 0;
 
@@ -2120,6 +2209,7 @@
 	spin_unlock_irqrestore(&vcs->capture_lock, flags);
 }
 
+#if 0
 static int vino_capture_failed(struct vino_channel_settings *vcs)
 {
 	struct vino_framebuffer *fb;
@@ -2164,9 +2254,31 @@
 
 	return 0;
 }
+#endif
+
+static void vino_skip_frame(struct vino_channel_settings *vcs)
+{
+	struct vino_framebuffer *fb;
+	unsigned long flags;
+	unsigned int id;
+
+	spin_lock_irqsave(&vcs->capture_lock, flags);
+	fb = vino_queue_peek(&vcs->fb_queue, &id);
+	if (!fb) {
+		spin_unlock_irqrestore(&vcs->capture_lock, flags);
+		dprintk("vino_skip_frame(): vino_queue_peek() failed!\n");
+		return;
+	}
+	spin_unlock_irqrestore(&vcs->capture_lock, flags);
+
+	spin_lock_irqsave(&fb->state_lock, flags);
+	fb->state = VINO_FRAMEBUFFER_UNUSED;
+	spin_unlock_irqrestore(&fb->state_lock, flags);
+
+	vino_capture_next(vcs, 0);
+}
 
-static void vino_frame_done(struct vino_channel_settings *vcs,
-			    unsigned int fc)
+static void vino_frame_done(struct vino_channel_settings *vcs)
 {
 	struct vino_framebuffer *fb;
 	unsigned long flags;
@@ -2180,8 +2292,9 @@
 	}
 	spin_unlock_irqrestore(&vcs->capture_lock, flags);
 
-	fb->frame_counter = fc;
-	do_gettimeofday(&fb->timestamp);
+	fb->frame_counter = vcs->int_data.frame_counter;
+	memcpy(&fb->timestamp, &vcs->int_data.timestamp,
+	       sizeof(struct timeval));
 
 	spin_lock_irqsave(&fb->state_lock, flags);
 	if (fb->state == VINO_FRAMEBUFFER_IN_USE)
@@ -2193,72 +2306,175 @@
 	vino_capture_next(vcs, 0);
 }
 
+static void vino_capture_tasklet(unsigned long channel) {
+	struct vino_channel_settings *vcs;
+
+	vcs = (channel == VINO_CHANNEL_A)
+		? &vino_drvdata->a : &vino_drvdata->b;
+
+	if (vcs->int_data.skip)
+		vcs->int_data.skip_count++;
+
+	if (vcs->int_data.skip && (vcs->int_data.skip_count
+				   <= VINO_MAX_FRAME_SKIP_COUNT)) {
+		vino_skip_frame(vcs);
+	} else {
+		vcs->int_data.skip_count = 0;
+		vino_frame_done(vcs);
+	}
+}
+
 static irqreturn_t vino_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	u32 intr;
+	u32 ctrl, intr;
 	unsigned int fc_a, fc_b;
-	int done_a = 0;
-	int done_b = 0;
+	int handled_a = 0, skip_a = 0, done_a = 0;
+	int handled_b = 0, skip_b = 0, done_b = 0;
 
-	spin_lock(&vino_drvdata->vino_lock);
-
-	intr = vino->intr_status;
-	fc_a = vino->a.field_counter / 2;
-	fc_b = vino->b.field_counter / 2;
+#ifdef VINO_DEBUG_INT
+	int loop = 0;
+	unsigned int line_count = vino->a.line_count,
+		page_index = vino->a.page_index,
+		field_counter = vino->a.field_counter,
+		start_desc_tbl = vino->a.start_desc_tbl,
+		next_4_desc = vino->a.next_4_desc;
+	unsigned int line_count_2,
+		page_index_2,
+		field_counter_2,
+		start_desc_tbl_2,
+		next_4_desc_2;
+#endif
 
-	// TODO: handle error-interrupts in some special way ?
+	spin_lock(&vino_drvdata->vino_lock);
 
- 	if (intr & VINO_INTSTAT_A) {
-		if (intr & VINO_INTSTAT_A_EOF) {
-			vino_drvdata->a.field++;
-			if (vino_drvdata->a.field > 1) {
+	while ((intr = vino->intr_status)) {
+		fc_a = vino->a.field_counter >> 1;
+		fc_b = vino->b.field_counter >> 1;
+
+		/* handle error-interrupts in some special way ?
+		 * --> skips frames */
+		if (intr & VINO_INTSTAT_A) {
+			if (intr & VINO_INTSTAT_A_EOF) {
+				vino_drvdata->a.field++;
+				if (vino_drvdata->a.field > 1) {
+					vino_dma_stop(&vino_drvdata->a);
+					vino_clear_interrupt(&vino_drvdata->a);
+					vino_drvdata->a.field = 0;
+					done_a = 1;
+				} else {
+					if (vino->a.page_index
+					    != vino_drvdata->a.line_size) {
+						vino->a.line_count = 0;
+						vino->a.page_index =
+							vino_drvdata->
+							a.line_size;
+						vino->a.next_4_desc =
+							vino->a.start_desc_tbl;
+					}
+				}
+				dprintk("channel A end-of-field "
+					"interrupt: %04x\n", intr);
+			} else {
 				vino_dma_stop(&vino_drvdata->a);
 				vino_clear_interrupt(&vino_drvdata->a);
 				vino_drvdata->a.field = 0;
-				done_a = 1;
+				skip_a = 1;
+				dprintk("channel A error interrupt: %04x\n",
+					intr);
 			}
-			dprintk("intr: channel A end-of-field interrupt: "
-				"%04x\n", intr);
-		} else {
-			vino_dma_stop(&vino_drvdata->a);
-			vino_clear_interrupt(&vino_drvdata->a);
-			done_a = 1;
-			dprintk("channel A error interrupt: %04x\n", intr);
+
+#ifdef VINO_DEBUG_INT
+			line_count_2 = vino->a.line_count;
+			page_index_2 = vino->a.page_index;
+			field_counter_2 = vino->a.field_counter;
+			start_desc_tbl_2 = vino->a.start_desc_tbl;
+			next_4_desc_2 = vino->a.next_4_desc;
+
+			printk("intr = %04x, loop = %d, field = %d\n",
+			       intr, loop, vino_drvdata->a.field);
+			printk("1- line count = %04d, page index = %04d, "
+			       "start = %08x, next = %08x\n"
+			       "   fieldc = %d, framec = %d\n",
+			       line_count, page_index, start_desc_tbl,
+			       next_4_desc, field_counter, fc_a);
+			printk("12-line count = %04d, page index = %04d, "
+			       "   start = %08x, next = %08x\n",
+			       line_count_2, page_index_2, start_desc_tbl_2,
+			       next_4_desc_2);
+
+			if (done_a)
+				printk("\n");
+#endif
 		}
-	}
-	if (intr & VINO_INTSTAT_B) {
-		if (intr & VINO_INTSTAT_B_EOF) {
-			vino_drvdata->b.field++;
-			if (vino_drvdata->b.field > 1) {
+
+		if (intr & VINO_INTSTAT_B) {
+			if (intr & VINO_INTSTAT_B_EOF) {
+				vino_drvdata->b.field++;
+				if (vino_drvdata->b.field > 1) {
+					vino_dma_stop(&vino_drvdata->b);
+					vino_clear_interrupt(&vino_drvdata->b);
+					vino_drvdata->b.field = 0;
+					done_b = 1;
+				}
+				dprintk("channel B end-of-field "
+					"interrupt: %04x\n", intr);
+			} else {
 				vino_dma_stop(&vino_drvdata->b);
 				vino_clear_interrupt(&vino_drvdata->b);
 				vino_drvdata->b.field = 0;
-				done_b = 1;
+				skip_b = 1;
+				dprintk("channel B error interrupt: %04x\n",
+					intr);
 			}
-			dprintk("intr: channel B end-of-field interrupt: "
-				"%04x\n", intr);
-		} else {
-			vino_dma_stop(&vino_drvdata->b);
-			vino_clear_interrupt(&vino_drvdata->b);
-			done_b = 1;
-			dprintk("channel B error interrupt: %04x\n", intr);
 		}
-	}
 
-	/* always remember to clear interrupt status */
-	vino->intr_status = ~intr;
+		/* Always remember to clear interrupt status.
+		 * Disable VINO interrupts while we do this. */
+		ctrl = vino->control;
+		vino->control = ctrl & ~(VINO_CTRL_A_INT | VINO_CTRL_B_INT);
+		vino->intr_status = ~intr;
+		vino->control = ctrl;
+
+		spin_unlock(&vino_drvdata->vino_lock);
+
+		if ((!handled_a) && (done_a || skip_a)) {
+			if (!skip_a) {
+				do_gettimeofday(&vino_drvdata->
+						a.int_data.timestamp);
+				vino_drvdata->a.int_data.frame_counter = fc_a;
+			}
+			vino_drvdata->a.int_data.skip = skip_a;
+
+			dprintk("channel A %s, interrupt: %d\n",
+				skip_a ? "skipping frame" : "frame done",
+				intr);
+			tasklet_hi_schedule(&vino_tasklet_a);
+			handled_a = 1;
+		}
 
-	spin_unlock(&vino_drvdata->vino_lock);
+		if ((!handled_b) && (done_b || skip_b)) {
+			if (!skip_b) {
+				do_gettimeofday(&vino_drvdata->
+						b.int_data.timestamp);
+				vino_drvdata->b.int_data.frame_counter = fc_b;
+			}
+			vino_drvdata->b.int_data.skip = skip_b;
+
+			dprintk("channel B %s, interrupt: %d\n",
+				skip_b ? "skipping frame" : "frame done",
+				intr);
+			tasklet_hi_schedule(&vino_tasklet_b);
+			handled_b = 1;
+		}
 
-	if (done_a) {
-		vino_frame_done(&vino_drvdata->a, fc_a);
-		dprintk("channel A frame done, interrupt: %d\n", intr);
-	}
-	if (done_b) {
-		vino_frame_done(&vino_drvdata->b, fc_b);
-		dprintk("channel B frame done, interrupt: %d\n", intr);
+#ifdef VINO_DEBUG_INT
+		loop++;
+#endif
+		spin_lock(&vino_drvdata->vino_lock);
 	}
 
+	spin_unlock(&vino_drvdata->vino_lock);
+
 	return IRQ_HANDLED;
 }
 
@@ -2278,11 +2494,13 @@
 	}
 }
 
-static int vino_get_saa7191_norm(int norm)
+static int vino_get_saa7191_norm(unsigned int data_norm)
 {
-	switch (norm) {
+	switch (data_norm) {
 	case VINO_DATA_NORM_AUTO:
 		return SAA7191_NORM_AUTO;
+	case VINO_DATA_NORM_AUTO_EXT:
+		return SAA7191_NORM_AUTO_EXT;
 	case VINO_DATA_NORM_PAL:
 		return SAA7191_NORM_PAL;
 	case VINO_DATA_NORM_NTSC:
@@ -2296,6 +2514,57 @@
 	}
 }
 
+static int vino_get_from_saa7191_norm(int saa7191_norm)
+{
+	switch (saa7191_norm) {
+	case SAA7191_NORM_PAL:
+		return VINO_DATA_NORM_PAL;
+	case SAA7191_NORM_NTSC:
+		return VINO_DATA_NORM_NTSC;
+	case SAA7191_NORM_SECAM:
+		return VINO_DATA_NORM_SECAM;
+	default:
+		printk(KERN_ERR "VINO: vino_get_from_saa7191_norm(): "
+		       "invalid norm!\n");
+		return VINO_DATA_NORM_NONE;
+	}
+}
+
+static int vino_saa7191_set_norm(unsigned int *data_norm)
+{
+	int saa7191_norm, new_data_norm;
+	int err = 0;
+
+	saa7191_norm = vino_get_saa7191_norm(*data_norm);
+
+	err = i2c_decoder_command(DECODER_SAA7191_SET_NORM,
+				  &saa7191_norm);
+	if (err)
+		goto out;
+
+	if ((*data_norm == VINO_DATA_NORM_AUTO)
+	    || (*data_norm == VINO_DATA_NORM_AUTO_EXT)) {
+		struct saa7191_status status;
+
+		err = i2c_decoder_command(DECODER_SAA7191_GET_STATUS,
+					  &status);
+		if (err)
+			goto out;
+
+		new_data_norm =
+			vino_get_from_saa7191_norm(status.norm);
+		if (new_data_norm == VINO_DATA_NORM_NONE) {
+			err = -EINVAL;
+			goto out;
+		}
+
+		*data_norm = (unsigned int)new_data_norm;
+	}
+
+out:
+	return err;
+}
+
 /* execute with input_lock locked */
 static int vino_is_input_owner(struct vino_channel_settings *vcs)
 {
@@ -2312,11 +2581,12 @@
 
 static int vino_acquire_input(struct vino_channel_settings *vcs)
 {
+	unsigned long flags;
 	int ret = 0;
 
 	dprintk("vino_acquire_input():\n");
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 	/* First try D1 and then SAA7191 */
 	if (vino_drvdata->camera.driver
@@ -2331,23 +2601,48 @@
 		vcs->data_norm = VINO_DATA_NORM_D1;
 	} else if (vino_drvdata->decoder.driver
 		   && (vino_drvdata->decoder.owner == VINO_NO_CHANNEL)) {
+		int input, data_norm;
 		int saa7191_input;
-		int saa7191_norm;
 
 		if (i2c_use_client(vino_drvdata->decoder.driver)) {
 			ret = -ENODEV;
 			goto out;
 		}
 
-		vino_drvdata->decoder.owner = vcs->channel;
-		vcs->input = VINO_INPUT_COMPOSITE;
-		vcs->data_norm = VINO_DATA_NORM_PAL;
+		input = VINO_INPUT_COMPOSITE;
 
-		saa7191_input = vino_get_saa7191_input(vcs->input);
-		i2c_decoder_command(DECODER_SET_INPUT, &saa7191_input);
+		saa7191_input = vino_get_saa7191_input(input);
+		ret = i2c_decoder_command(DECODER_SET_INPUT,
+					  &saa7191_input);
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
-		saa7191_norm = vino_get_saa7191_norm(vcs->data_norm);
-		i2c_decoder_command(DECODER_SAA7191_SET_NORM, &saa7191_norm);
+		/* Don't hold spinlocks while auto-detecting norm
+		 * as it may take a while... */
+
+		data_norm = VINO_DATA_NORM_AUTO_EXT;
+
+		ret = vino_saa7191_set_norm(&data_norm);
+		if ((ret == -EBUSY) || (ret == -EAGAIN)) {
+			data_norm = VINO_DATA_NORM_PAL;
+			ret = vino_saa7191_set_norm(&data_norm);
+		}
+
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		vino_drvdata->decoder.owner = vcs->channel;
+
+		vcs->input = input;
+		vcs->data_norm = data_norm;
 	} else {
 		vcs->input = (vcs->channel == VINO_CHANNEL_A) ?
 			vino_drvdata->b.input : vino_drvdata->a.input;
@@ -2360,15 +2655,14 @@
 		goto out;
 	}
 
-	if (vino_is_input_owner(vcs)) {
-		vino_set_default_clipping(vcs);
-		vino_set_default_framerate(vcs);
-	}
+	vino_set_default_clipping(vcs);
+	vino_set_default_scaling(vcs);
+	vino_set_default_framerate(vcs);
 
 	dprintk("vino_acquire_input(): %s\n", vino_inputs[vcs->input].name);
 
 out:
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return ret;
 }
@@ -2377,16 +2671,17 @@
 {
 	struct vino_channel_settings *vcs2 = (vcs->channel == VINO_CHANNEL_A) ?
 		&vino_drvdata->b : &vino_drvdata->a;
+	unsigned long flags;
 	int ret = 0;
 
 	dprintk("vino_set_input():\n");
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 	if (vcs->input == input)
 		goto out;
 
-	switch(input) {
+	switch (input) {
 	case VINO_INPUT_COMPOSITE:
 	case VINO_INPUT_SVIDEO:
 		if (!vino_drvdata->decoder.driver) {
@@ -2403,19 +2698,43 @@
 		}
 
 		if (vino_drvdata->decoder.owner == vcs->channel) {
+			int data_norm;
 			int saa7191_input;
-			int saa7191_norm;
 
-			vcs->input = input;
-			vcs->data_norm = VINO_DATA_NORM_PAL;
+			saa7191_input = vino_get_saa7191_input(input);
+			ret = i2c_decoder_command(DECODER_SET_INPUT,
+						  &saa7191_input);
+			if (ret) {
+				vino_drvdata->decoder.owner = VINO_NO_CHANNEL;
+				ret = -EINVAL;
+				goto out;
+			}
+
+			spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
+
+			/* Don't hold spinlocks while auto-detecting norm
+			 * as it may take a while... */
 
-			saa7191_input = vino_get_saa7191_input(vcs->input);
-			i2c_decoder_command(DECODER_SET_INPUT, &saa7191_input);
-			saa7191_norm = vino_get_saa7191_norm(vcs->data_norm);
-			i2c_decoder_command(DECODER_SAA7191_SET_NORM,
-					    &saa7191_norm);
+			data_norm = VINO_DATA_NORM_AUTO_EXT;
+
+			ret = vino_saa7191_set_norm(&data_norm);
+			if ((ret  == -EBUSY) || (ret == -EAGAIN)) {
+				data_norm = VINO_DATA_NORM_PAL;
+				ret = vino_saa7191_set_norm(&data_norm);
+			}
+
+			spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
+			if (ret) {
+				vino_drvdata->decoder.owner = VINO_NO_CHANNEL;
+				ret = -EINVAL;
+				goto out;
+			}
+
+			vcs->input = input;
+			vcs->data_norm = data_norm;
 		} else {
-			if (vcs2->input != input) {
+			if (input != vcs2->input) {
 				ret = -EBUSY;
 				goto out;
 			}
@@ -2470,12 +2789,13 @@
 	}
 
 	vino_set_default_clipping(vcs);
+	vino_set_default_scaling(vcs);
 	vino_set_default_framerate(vcs);
 
 	dprintk("vino_set_input(): %s\n", vino_inputs[vcs->input].name);
 
 out:
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return ret;
 }
@@ -2484,10 +2804,11 @@
 {
 	struct vino_channel_settings *vcs2 = (vcs->channel == VINO_CHANNEL_A) ?
 		&vino_drvdata->b : &vino_drvdata->a;
+	unsigned long flags;
 
 	dprintk("vino_release_input():\n");
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 	/* Release ownership of the channel
 	 * and if the other channel takes input from
@@ -2510,34 +2831,61 @@
 	}
 	vcs->input = VINO_INPUT_NONE;
 
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 }
 
 /* execute with input_lock locked */
 static int vino_set_data_norm(struct vino_channel_settings *vcs,
-			      unsigned int data_norm)
+			      unsigned int data_norm,
+			      unsigned long *flags)
 {
-	int saa7191_norm;
+	int err = 0;
+
+	if (data_norm == vcs->data_norm)
+		return 0;
 
 	switch (vcs->input) {
 	case VINO_INPUT_D1:
 		/* only one "norm" supported */
-		if (data_norm != VINO_DATA_NORM_D1)
+		if ((data_norm != VINO_DATA_NORM_D1)
+		    && (data_norm != VINO_DATA_NORM_AUTO)
+		    && (data_norm != VINO_DATA_NORM_AUTO_EXT))
 			return -EINVAL;
 		break;
 	case VINO_INPUT_COMPOSITE:
-	case VINO_INPUT_SVIDEO:
+	case VINO_INPUT_SVIDEO: {
+		if ((data_norm != VINO_DATA_NORM_PAL)
+		    && (data_norm != VINO_DATA_NORM_NTSC)
+		    && (data_norm != VINO_DATA_NORM_SECAM)
+		    && (data_norm != VINO_DATA_NORM_AUTO)
+		    && (data_norm != VINO_DATA_NORM_AUTO_EXT))
+			return -EINVAL;
+
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, *flags);
 
-		saa7191_norm = vino_get_saa7191_norm(data_norm);
+		/* Don't hold spinlocks while setting norm
+		 * as it may take a while... */
+
+		err = vino_saa7191_set_norm(&data_norm);
+
+		spin_lock_irqsave(&vino_drvdata->input_lock, *flags);
+
+		if (err)
+			goto out;
 
-		i2c_decoder_command(DECODER_SAA7191_SET_NORM, &saa7191_norm);
 		vcs->data_norm = data_norm;
+
+		vino_set_default_clipping(vcs);
+		vino_set_default_scaling(vcs);
+		vino_set_default_framerate(vcs);
 		break;
+	}
 	default:
 		return -EINVAL;
 	}
 
-	return 0;
+out:
+	return err;
 }
 
 /* V4L2 helper functions */
@@ -2557,8 +2905,9 @@
 static int vino_enum_data_norm(struct vino_channel_settings *vcs, __u32 index)
 {
 	int data_norm = VINO_DATA_NORM_NONE;
+	unsigned long flags;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 	switch(vcs->input) {
 	case VINO_INPUT_COMPOSITE:
 	case VINO_INPUT_SVIDEO:
@@ -2576,7 +2925,7 @@
 		}
 		break;
 	}
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return data_norm;
 }
@@ -2584,8 +2933,9 @@
 static int vino_enum_input(struct vino_channel_settings *vcs, __u32 index)
 {
 	int input = VINO_INPUT_NONE;
+	unsigned long flags;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 	if (vino_drvdata->decoder.driver && vino_drvdata->camera.driver) {
 		switch (index) {
 		case 0:
@@ -2614,7 +2964,7 @@
 			break;
 		}
 	}
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return input;
 }
@@ -2703,15 +3053,16 @@
 }
 
 static int vino_v4l2_g_input(struct vino_channel_settings *vcs,
-			     struct v4l2_input *i)
+			     unsigned int *i)
 {
 	__u32 index;
 	int input;
+	unsigned long flags;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 	input = vcs->input;
 	index = vino_find_input_index(vcs);
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	dprintk("input = %d\n", input);
 
@@ -2719,23 +3070,18 @@
 		return -EINVAL;
 	}
 
-	memset(i, 0, sizeof(struct v4l2_input));
-
-	i->index = index;
-	i->type = V4L2_INPUT_TYPE_CAMERA;
-	i->std = vino_inputs[input].std;
-	strcpy(i->name, vino_inputs[input].name);
+	*i = index;
 
 	return 0;
 }
 
 static int vino_v4l2_s_input(struct vino_channel_settings *vcs,
-			     struct v4l2_input *i)
+			     unsigned int *i)
 {
 	int input;
-	dprintk("requested input = %d\n", i->index);
+	dprintk("requested input = %d\n", *i);
 
-	input = vino_enum_input(vcs, i->index);
+	input = vino_enum_input(vcs, *i);
 	if (input == VINO_INPUT_NONE)
 		return -EINVAL;
 
@@ -2746,7 +3092,9 @@
 			     struct v4l2_standard *s)
 {
 	int index = s->index;
-	int data_norm = vino_enum_data_norm(vcs, index);
+	int data_norm;
+
+	data_norm = vino_enum_data_norm(vcs, index);
 	dprintk("standard index = %d\n", index);
 
 	if (data_norm == VINO_DATA_NORM_NONE)
@@ -2770,13 +3118,55 @@
 	return 0;
 }
 
+static int vino_v4l2_querystd(struct vino_channel_settings *vcs,
+			      v4l2_std_id *std)
+{
+	unsigned long flags;
+	int err = 0;
+
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
+	switch (vcs->input) {
+	case VINO_INPUT_D1:
+		*std = vino_inputs[vcs->input].std;
+		break;
+	case VINO_INPUT_COMPOSITE:
+	case VINO_INPUT_SVIDEO: {
+		struct saa7191_status status;
+
+		i2c_decoder_command(DECODER_SAA7191_GET_STATUS, &status);
+
+		if (status.signal) {
+			if (status.signal_60hz) {
+				*std = V4L2_STD_NTSC;
+			} else {
+				*std = V4L2_STD_PAL | V4L2_STD_SECAM;
+			}
+		} else {
+			*std = vino_inputs[vcs->input].std;
+		}
+		break;
+	}
+	default:
+		err = -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
+
+	return err;
+}
+
 static int vino_v4l2_g_std(struct vino_channel_settings *vcs,
 			   v4l2_std_id *std)
 {
-	spin_lock(&vino_drvdata->input_lock);
-	dprintk("current standard = %d\n", vcs->data_norm);
+	unsigned long flags;
+
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
 	*std = vino_data_norms[vcs->data_norm].std;
-	spin_unlock(&vino_drvdata->input_lock);
+	dprintk("current standard = %d\n", vcs->data_norm);
+
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return 0;
 }
@@ -2784,13 +3174,18 @@
 static int vino_v4l2_s_std(struct vino_channel_settings *vcs,
 			   v4l2_std_id *std)
 {
+	unsigned long flags;
 	int ret = 0;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
+	if (!vino_is_input_owner(vcs)) {
+		ret = -EBUSY;
+		goto out;
+	}
 
 	/* check if the standard is valid for the current input */
-	if (vino_is_input_owner(vcs)
-	    && (vino_inputs[vcs->input].std & (*std))) {
+	if ((*std) & vino_inputs[vcs->input].std) {
 		dprintk("standard accepted\n");
 
 		/* change the video norm for SAA7191
@@ -2799,24 +3194,33 @@
 		if (vcs->input == VINO_INPUT_D1)
 			goto out;
 
-		if ((*std) & V4L2_STD_PAL) {
-			vino_set_data_norm(vcs, VINO_DATA_NORM_PAL);
-			vcs->data_norm = VINO_DATA_NORM_PAL;
+		if (((*std) & V4L2_STD_PAL)
+		    && ((*std) & V4L2_STD_NTSC)
+		    && ((*std) & V4L2_STD_SECAM)) {
+			ret = vino_set_data_norm(vcs, VINO_DATA_NORM_AUTO_EXT,
+						 &flags);
+		} else if ((*std) & V4L2_STD_PAL) {
+			ret = vino_set_data_norm(vcs, VINO_DATA_NORM_PAL,
+						 &flags);
 		} else if ((*std) & V4L2_STD_NTSC) {
-			vino_set_data_norm(vcs, VINO_DATA_NORM_NTSC);
-			vcs->data_norm = VINO_DATA_NORM_NTSC;
+			ret = vino_set_data_norm(vcs, VINO_DATA_NORM_NTSC,
+						 &flags);
 		} else if ((*std) & V4L2_STD_SECAM) {
-			vino_set_data_norm(vcs, VINO_DATA_NORM_SECAM);
-			vcs->data_norm = VINO_DATA_NORM_SECAM;
+			ret = vino_set_data_norm(vcs, VINO_DATA_NORM_SECAM,
+						 &flags);
 		} else {
 			ret = -EINVAL;
 		}
+
+		if (ret) {
+			ret = -EINVAL;
+		}
 	} else {
 		ret = -EINVAL;
 	}
 
 out:
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return ret;
 }
@@ -2854,6 +3258,7 @@
 			     struct v4l2_format *f)
 {
 	struct vino_channel_settings tempvcs;
+	unsigned long flags;
 
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE: {
@@ -2862,13 +3267,13 @@
 		dprintk("requested: w = %d, h = %d\n",
 		       pf->width, pf->height);
 
-		spin_lock(&vino_drvdata->input_lock);
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 		memcpy(&tempvcs, vcs, sizeof(struct vino_channel_settings));
-		spin_unlock(&vino_drvdata->input_lock);
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 		tempvcs.data_format = vino_find_data_format(pf->pixelformat);
 		if (tempvcs.data_format == VINO_DATA_FMT_NONE) {
-			tempvcs.data_format = VINO_DATA_FMT_RGB32;
+			tempvcs.data_format = VINO_DATA_FMT_GREY;
 			pf->pixelformat =
 				vino_data_formats[tempvcs.data_format].
 				pixelformat;
@@ -2907,10 +3312,13 @@
 static int vino_v4l2_g_fmt(struct vino_channel_settings *vcs,
 			   struct v4l2_format *f)
 {
+	unsigned long flags;
+
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE: {
 		struct v4l2_pix_format *pf = &f->fmt.pix;
-		spin_lock(&vino_drvdata->input_lock);
+
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 		pf->width = (vcs->clipping.right - vcs->clipping.left) /
 			vcs->decimation;
@@ -2929,7 +3337,7 @@
 
 		pf->priv = 0;
 
-		spin_unlock(&vino_drvdata->input_lock);
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 		break;
 	}
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
@@ -2944,20 +3352,18 @@
 			   struct v4l2_format *f)
 {
 	int data_format;
+	unsigned long flags;
 
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE: {
 		struct v4l2_pix_format *pf = &f->fmt.pix;
-		spin_lock(&vino_drvdata->input_lock);
 
-		if (!vino_is_input_owner(vcs)) {
-			spin_unlock(&vino_drvdata->input_lock);
-			return -EINVAL;
-		}
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 		data_format = vino_find_data_format(pf->pixelformat);
+
 		if (data_format == VINO_DATA_FMT_NONE) {
-			vcs->data_format = VINO_DATA_FMT_RGB32;
+			vcs->data_format = VINO_DATA_FMT_GREY;
 			pf->pixelformat =
 				vino_data_formats[vcs->data_format].
 				pixelformat;
@@ -2984,7 +3390,7 @@
 
 		pf->priv = 0;
 
-		spin_unlock(&vino_drvdata->input_lock);
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 		break;
 	}
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
@@ -2999,12 +3405,15 @@
 			     struct v4l2_cropcap *ccap)
 {
 	const struct vino_data_norm *norm;
+	unsigned long flags;
 
 	switch (ccap->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		spin_lock(&vino_drvdata->input_lock);
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
 		norm = &vino_data_norms[vcs->data_norm];
-		spin_unlock(&vino_drvdata->input_lock);
+
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 		ccap->bounds.left = 0;
 		ccap->bounds.top = 0;
@@ -3027,16 +3436,18 @@
 static int vino_v4l2_g_crop(struct vino_channel_settings *vcs,
 			    struct v4l2_crop *c)
 {
+	unsigned long flags;
+
 	switch (c->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		spin_lock(&vino_drvdata->input_lock);
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 		c->c.left = vcs->clipping.left;
 		c->c.top = vcs->clipping.top;
 		c->c.width = vcs->clipping.right - vcs->clipping.left;
 		c->c.height = vcs->clipping.bottom - vcs->clipping.top;
 
-		spin_unlock(&vino_drvdata->input_lock);
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 	default:
@@ -3049,18 +3460,16 @@
 static int vino_v4l2_s_crop(struct vino_channel_settings *vcs,
 			    struct v4l2_crop *c)
 {
+	unsigned long flags;
+
 	switch (c->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		spin_lock(&vino_drvdata->input_lock);
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
-		if (!vino_is_input_owner(vcs)) {
-			spin_unlock(&vino_drvdata->input_lock);
-			return -EINVAL;
-		}
 		vino_set_clipping(vcs, c->c.left, c->c.top,
 				  c->c.width, c->c.height);
 
-		spin_unlock(&vino_drvdata->input_lock);
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 	default:
@@ -3073,6 +3482,8 @@
 static int vino_v4l2_g_parm(struct vino_channel_settings *vcs,
 			    struct v4l2_streamparm *sp)
 {
+	unsigned long flags;
+
 	switch (sp->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE: {
 		struct v4l2_captureparm *cp = &sp->parm.capture;
@@ -3081,9 +3492,11 @@
 		cp->capability = V4L2_CAP_TIMEPERFRAME;
 		cp->timeperframe.numerator = 1;
 
-		spin_lock(&vino_drvdata->input_lock);
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
 		cp->timeperframe.denominator = vcs->fps;
-		spin_unlock(&vino_drvdata->input_lock);
+
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 		// TODO: cp->readbuffers = xxx;
 		break;
@@ -3099,15 +3512,13 @@
 static int vino_v4l2_s_parm(struct vino_channel_settings *vcs,
 			    struct v4l2_streamparm *sp)
 {
+	unsigned long flags;
+
 	switch (sp->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE: {
 		struct v4l2_captureparm *cp = &sp->parm.capture;
 
-		spin_lock(&vino_drvdata->input_lock);
-		if (!vino_is_input_owner(vcs)) {
-			spin_unlock(&vino_drvdata->input_lock);
-			return -EINVAL;
-		}
+		spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 		if ((cp->timeperframe.numerator == 0) ||
 		    (cp->timeperframe.denominator == 0)) {
@@ -3117,7 +3528,8 @@
 			vino_set_framerate(vcs, cp->timeperframe.denominator /
 					   cp->timeperframe.numerator);
 		}
-		spin_unlock(&vino_drvdata->input_lock);
+
+		spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 		// TODO: set buffers according to cp->readbuffers
 		break;
@@ -3144,21 +3556,23 @@
 			return -EINVAL;
 		}
 
-		if (vino_is_capturing(vcs)) {
-			dprintk("busy, capturing\n");
-			return -EBUSY;
-		}
-
 		dprintk("count = %d\n", rb->count);
 		if (rb->count > 0) {
+			if (vino_is_capturing(vcs)) {
+				dprintk("busy, capturing\n");
+				return -EBUSY;
+			}
+
 			if (vino_queue_has_mapped_buffers(&vcs->fb_queue)) {
 				dprintk("busy, buffers still mapped\n");
 				return -EBUSY;
 			} else {
+				vcs->streaming = 0;
 				vino_queue_free(&vcs->fb_queue);
 				vino_queue_init(&vcs->fb_queue, &rb->count);
 			}
 		} else {
+			vcs->streaming = 0;
 			vino_capture_stop(vcs);
 			vino_queue_free(&vcs->fb_queue);
 		}
@@ -3301,12 +3715,12 @@
 		err = vino_queue_get_incoming(&vcs->fb_queue, &incoming);
 		if (err) {
 			dprintk("vino_queue_get_incoming() failed\n");
-			return -EIO;
+			return -EINVAL;
 		}
 		err = vino_queue_get_outgoing(&vcs->fb_queue, &outgoing);
 		if (err) {
 			dprintk("vino_queue_get_outgoing() failed\n");
-			return -EIO;
+			return -EINVAL;
 		}
 
 		dprintk("incoming = %d, outgoing = %d\n", incoming, outgoing);
@@ -3326,8 +3740,10 @@
 			if (err) {
 				err = vino_wait_for_frame(vcs);
 				if (err) {
-					/* interrupted */
-					vino_capture_failed(vcs);
+					/* interrupted or
+					 * no frames captured because
+					 * of frame skipping */
+					// vino_capture_failed(vcs);
 					return -EIO;
 				}
 			}
@@ -3340,10 +3756,12 @@
 		}
 
 		err = vino_check_buffer(vcs, fb);
+
+		vino_v4l2_get_buffer_status(vcs, fb, b);
+
 		if (err)
 			return -EIO;
 
-		vino_v4l2_get_buffer_status(vcs, fb, b);
 		break;
 	}
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
@@ -3400,8 +3818,8 @@
 	if (!vcs->streaming)
 		return 0;
 
-	vino_capture_stop(vcs);
 	vcs->streaming = 0;
+	vino_capture_stop(vcs);
 
 	return 0;
 }
@@ -3409,10 +3827,11 @@
 static int vino_v4l2_queryctrl(struct vino_channel_settings *vcs,
 			       struct v4l2_queryctrl *queryctrl)
 {
+	unsigned long flags;
 	int i;
 	int err = 0;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 	switch (vcs->input) {
 	case VINO_INPUT_D1:
@@ -3422,6 +3841,7 @@
 				memcpy(queryctrl,
 				       &vino_indycam_v4l2_controls[i],
 				       sizeof(struct v4l2_queryctrl));
+				queryctrl->reserved[0] = 0;
 				goto found;
 			}
 		}
@@ -3436,6 +3856,7 @@
 				memcpy(queryctrl,
 				       &vino_saa7191_v4l2_controls[i],
 				       sizeof(struct v4l2_queryctrl));
+				queryctrl->reserved[0] = 0;
 				goto found;
 			}
 		}
@@ -3447,7 +3868,7 @@
 	}
 
  found:
-	spin_unlock(&vino_drvdata->input_lock);
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return err;
 }
@@ -3455,70 +3876,72 @@
 static int vino_v4l2_g_ctrl(struct vino_channel_settings *vcs,
 			    struct v4l2_control *control)
 {
-	struct indycam_control indycam_ctrl;
-	struct saa7191_control saa7191_ctrl;
+	unsigned long flags;
+	int i;
 	int err = 0;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
 
 	switch (vcs->input) {
-	case VINO_INPUT_D1:
-		i2c_camera_command(DECODER_INDYCAM_GET_CONTROLS,
-				   &indycam_ctrl);
+	case VINO_INPUT_D1: {
+		struct indycam_control indycam_ctrl;
 
-		switch(control->id) {
-		case V4L2_CID_AUTOGAIN:
-			control->value = indycam_ctrl.agc;
-			break;
-		case V4L2_CID_AUTO_WHITE_BALANCE:
-			control->value = indycam_ctrl.awb;
-			break;
-		case V4L2_CID_GAIN:
-			control->value = indycam_ctrl.gain;
-			break;
-		case V4L2_CID_PRIVATE_BASE:
-			control->value = indycam_ctrl.red_saturation;
-			break;
-		case V4L2_CID_PRIVATE_BASE + 1:
-			control->value = indycam_ctrl.blue_saturation;
-			break;
-		case V4L2_CID_RED_BALANCE:
-			control->value = indycam_ctrl.red_balance;
-			break;
-		case V4L2_CID_BLUE_BALANCE:
-			control->value = indycam_ctrl.blue_balance;
-			break;
-		case V4L2_CID_EXPOSURE:
-			control->value = indycam_ctrl.shutter;
-			break;
-		case V4L2_CID_GAMMA:
-			control->value = indycam_ctrl.gamma;
-			break;
-		default:
+		for (i = 0; i < VINO_INDYCAM_V4L2_CONTROL_COUNT; i++) {
+			if (vino_indycam_v4l2_controls[i].id ==
+			    control->id) {
+				goto found1;
+			}
+		}
+
+		err = -EINVAL;
+		goto out;
+
+found1:
+		indycam_ctrl.type = vino_indycam_v4l2_controls[i].reserved[0];
+
+		err = i2c_camera_command(DECODER_INDYCAM_GET_CONTROL,
+					 &indycam_ctrl);
+		if (err) {
 			err = -EINVAL;
+			goto out;
 		}
+
+		control->value = indycam_ctrl.value;
 		break;
+	}
 	case VINO_INPUT_COMPOSITE:
-	case VINO_INPUT_SVIDEO:
-		i2c_decoder_command(DECODER_SAA7191_GET_CONTROLS,
-				   &saa7191_ctrl);
+	case VINO_INPUT_SVIDEO: {
+		struct saa7191_control saa7191_ctrl;
 
-		switch(control->id) {
-		case V4L2_CID_HUE:
-			control->value = saa7191_ctrl.hue;
-			break;
-		case V4L2_CID_PRIVATE_BASE:
-			control->value = saa7191_ctrl.vtrc;
-			break;
-		default:
+		for (i = 0; i < VINO_SAA7191_V4L2_CONTROL_COUNT; i++) {
+			if (vino_saa7191_v4l2_controls[i].id ==
+			    control->id) {
+				goto found2;
+			}
+		}
+
+		err = -EINVAL;
+		goto out;
+
+found2:
+		saa7191_ctrl.type = vino_saa7191_v4l2_controls[i].reserved[0];
+
+		err = i2c_decoder_command(DECODER_SAA7191_GET_CONTROL,
+					  &saa7191_ctrl);
+		if (err) {
 			err = -EINVAL;
+			goto out;
 		}
+
+		control->value = saa7191_ctrl.value;
 		break;
+	}
 	default:
 		err =  -EINVAL;
 	}
 
-	spin_unlock(&vino_drvdata->input_lock);
+out:
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return err;
 }
@@ -3526,15 +3949,21 @@
 static int vino_v4l2_s_ctrl(struct vino_channel_settings *vcs,
 			    struct v4l2_control *control)
 {
-	struct indycam_control indycam_ctrl;
-	struct saa7191_control saa7191_ctrl;
+	unsigned long flags;
 	int i;
 	int err = 0;
 
-	spin_lock(&vino_drvdata->input_lock);
+	spin_lock_irqsave(&vino_drvdata->input_lock, flags);
+
+	if (!vino_is_input_owner(vcs)) {
+		err = -EBUSY;
+		goto out;
+	}
 
 	switch (vcs->input) {
-	case VINO_INPUT_D1:
+	case VINO_INPUT_D1: {
+		struct indycam_control indycam_ctrl;
+
 		for (i = 0; i < VINO_INDYCAM_V4L2_CONTROL_COUNT; i++) {
 			if (vino_indycam_v4l2_controls[i].id ==
 			    control->id) {
@@ -3543,65 +3972,31 @@
 				    && (control->value <=
 					vino_indycam_v4l2_controls[i].
 					maximum)) {
-					goto ok1;
+					goto found1;
 				} else {
 					err = -ERANGE;
-					goto error;
+					goto out;
 				}
 			}
 		}
+
 		err = -EINVAL;
-		goto error;
+		goto out;
 
-ok1:
-		indycam_ctrl.agc = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.awb = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.shutter = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.gain = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.red_balance = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.blue_balance = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.red_saturation = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.blue_saturation = INDYCAM_VALUE_UNCHANGED;
-		indycam_ctrl.gamma = INDYCAM_VALUE_UNCHANGED;
-
-		switch(control->id) {
-		case V4L2_CID_AUTOGAIN:
-			indycam_ctrl.agc = control->value;
-			break;
-		case V4L2_CID_AUTO_WHITE_BALANCE:
-			indycam_ctrl.awb = control->value;
-			break;
-		case V4L2_CID_GAIN:
-			indycam_ctrl.gain = control->value;
-			break;
-		case V4L2_CID_PRIVATE_BASE:
-			indycam_ctrl.red_saturation = control->value;
-			break;
-		case V4L2_CID_PRIVATE_BASE + 1:
-			indycam_ctrl.blue_saturation = control->value;
-			break;
-		case V4L2_CID_RED_BALANCE:
-			indycam_ctrl.red_balance = control->value;
-			break;
-		case V4L2_CID_BLUE_BALANCE:
-			indycam_ctrl.blue_balance = control->value;
-			break;
-		case V4L2_CID_EXPOSURE:
-			indycam_ctrl.shutter = control->value;
-			break;
-		case V4L2_CID_GAMMA:
-			indycam_ctrl.gamma = control->value;
-			break;
-		default:
-			err =  -EINVAL;
-		}
+found1:
+		indycam_ctrl.type = vino_indycam_v4l2_controls[i].reserved[0];
+		indycam_ctrl.value = control->value;
 
-		if (!err)
-			i2c_camera_command(DECODER_INDYCAM_SET_CONTROLS,
-					   &indycam_ctrl);
+		err = i2c_camera_command(DECODER_INDYCAM_SET_CONTROL,
+					 &indycam_ctrl);
+		if (err)
+			err = -EINVAL;
 		break;
+	}
 	case VINO_INPUT_COMPOSITE:
-	case VINO_INPUT_SVIDEO:
+	case VINO_INPUT_SVIDEO: {
+		struct saa7191_control saa7191_ctrl;
+
 		for (i = 0; i < VINO_SAA7191_V4L2_CONTROL_COUNT; i++) {
 			if (vino_saa7191_v4l2_controls[i].id ==
 			    control->id) {
@@ -3610,41 +4005,32 @@
 				    && (control->value <=
 					vino_saa7191_v4l2_controls[i].
 					maximum)) {
-					goto ok2;
+					goto found2;
 				} else {
 					err = -ERANGE;
-					goto error;
+					goto out;
 				}
 			}
 		}
 		err = -EINVAL;
-		goto error;
+		goto out;
 
-ok2:
-		saa7191_ctrl.hue = SAA7191_VALUE_UNCHANGED;
-		saa7191_ctrl.vtrc = SAA7191_VALUE_UNCHANGED;
-
-		switch(control->id) {
-		case V4L2_CID_HUE:
-			saa7191_ctrl.hue = control->value;
-			break;
-		case V4L2_CID_PRIVATE_BASE:
-			saa7191_ctrl.vtrc = control->value;
-			break;
-		default:
-			err =  -EINVAL;
-		}
+found2:
+		saa7191_ctrl.type = vino_saa7191_v4l2_controls[i].reserved[0];
+		saa7191_ctrl.value = control->value;
 
-		if (!err)
-			i2c_decoder_command(DECODER_SAA7191_SET_CONTROLS,
-					    &saa7191_ctrl);
+		err = i2c_decoder_command(DECODER_SAA7191_SET_CONTROL,
+					  &saa7191_ctrl);
+		if (err)
+			err = -EINVAL;
 		break;
+	}
 	default:
 		err =  -EINVAL;
 	}
 
-error:
-	spin_unlock(&vino_drvdata->input_lock);
+out:
+	spin_unlock_irqrestore(&vino_drvdata->input_lock, flags);
 
 	return err;
 }
@@ -3864,9 +4250,9 @@
 over:
 	dprintk("poll(): data %savailable\n",
 		(outgoing > 0) ? "" : "not ");
-	if (outgoing > 0) {
+
+	if (outgoing > 0)
 		ret = POLLIN | POLLRDNORM;
-	}
 
 error:
 
@@ -3879,6 +4265,7 @@
 	struct video_device *dev = video_devdata(file);
 	struct vino_channel_settings *vcs = video_get_drvdata(dev);
 
+#ifdef VINO_DEBUG
 	switch (_IOC_TYPE(cmd)) {
 	case 'v':
 		dprintk("ioctl(): V4L1 unsupported (0x%08x)\n", cmd);
@@ -3890,9 +4277,9 @@
 	default:
 		dprintk("ioctl(): unsupported command 0x%08x\n", cmd);
 	}
+#endif
 
 	switch (cmd) {
-	/* TODO: V4L1 interface (use compatibility layer?) */
 	/* V4L2 interface */
 	case VIDIOC_QUERYCAP: {
 		vino_v4l2_querycap(arg);
@@ -3910,6 +4297,9 @@
 	case VIDIOC_ENUMSTD: {
 		return vino_v4l2_enumstd(vcs, arg);
 	}
+	case VIDIOC_QUERYSTD: {
+		return vino_v4l2_querystd(vcs, arg);
+	}
 	case VIDIOC_G_STD: {
 		return vino_v4l2_g_std(vcs, arg);
 	}
@@ -4099,8 +4489,7 @@
 		return -ENODEV;
 	}
 
-	printk(KERN_INFO "VINO with chip ID %ld, revision %ld found\n",
-	       VINO_ID_VALUE(rev_id), VINO_REV_NUM(rev_id));
+	printk(KERN_INFO "VINO revision %ld found\n", VINO_REV_NUM(rev_id));
 
 	return 0;
 }
diff -Naur linux-2.6.14/drivers/mmc/au1xmmc.c linux-mips-2.6.14.orig/drivers/mmc/au1xmmc.c
--- linux-2.6.14/drivers/mmc/au1xmmc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/mmc/au1xmmc.c	2005-11-17 11:43:08.000000000 -0800
@@ -0,0 +1,1026 @@
+/* 
+ * linux/drivers/mmc/au1xmmc.c - AU1XX0 MMC driver 
+ *  
+ *  Copyright (c) 2005, Advanced Micro Devices, Inc.
+ *
+ *  Developed with help from the 2.4.30 MMC AU1XXX controller including
+ *  the following copyright notices:
+ *     Copyright (c) 2003-2004 Embedded Edge, LLC.
+ *     Portions Copyright (C) 2002 Embedix, Inc
+ *     Copyright 2002 Hewlett-Packard Company
+
+ *  2.6 version of this driver inspired by:
+ *     (drivers/mmc/wbsd.c) Copyright (C) 2004-2005 Pierre Ossman, 
+ *     All Rights Reserved.
+ *     (drivers/mmc/pxa.c) Copyright (C) 2003 Russell King, 
+ *     All Rights Reserved.
+ *
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Why is a timer used to detect insert events?
+ *
+ * From the AU1100 MMC application guide:
+ * If the Au1100-based design is intended to support both MultiMediaCards 
+ * and 1- or 4-data bit SecureDigital cards, then the solution is to 
+ * connect a weak (560KOhm) pull-up resistor to connector pin 1. 
+ * In doing so, a MMC card never enters SPI-mode communications, 
+ * but now the SecureDigital card-detect feature of CD/DAT3 is ineffective
+ * (the low to high transition will not occur).
+ *
+ * So we use the timer to check the status manually. 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/protocol.h>
+#include <asm/io.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h> 
+#include <asm/mach-au1x00/au1100_mmc.h>
+#include <asm/scatterlist.h>
+
+#include <au1xxx.h>
+#include "au1xmmc.h"
+
+#define DRIVER_NAME "au1xxx-mmc"
+
+/* Set this to enable special debugging macros */
+/* #define MMC_DEBUG */
+
+#ifdef MMC_DEBUG
+#define DEBUG(fmt, idx, args...) printk("au1xx(%d): DEBUG: " fmt, idx, ##args)
+#else
+#define DEBUG(fmt, idx, args...)
+#endif
+
+const struct {
+	u32 iobase;
+	u32 tx_devid, rx_devid;
+	u16 bcsrpwr;
+	u16 bcsrstatus;
+	u16 wpstatus;
+} au1xmmc_card_table[] = {
+	{ SD0_BASE, DSCR_CMD0_SDMS_TX0, DSCR_CMD0_SDMS_RX0, 
+	  BCSR_BOARD_SD0PWR, BCSR_INT_SD0INSERT, BCSR_STATUS_SD0WP },
+#ifndef CONFIG_MIPS_DB1200
+	{ SD1_BASE, DSCR_CMD0_SDMS_TX1, DSCR_CMD0_SDMS_RX1, 
+	  BCSR_BOARD_DS1PWR, BCSR_INT_SD1INSERT, BCSR_STATUS_SD1WP }
+#endif
+};
+
+#define AU1XMMC_CONTROLLER_COUNT \
+	(sizeof(au1xmmc_card_table) / sizeof(au1xmmc_card_table[0]))
+
+/* This array stores pointers for the hosts (used by the IRQ handler) */
+struct au1xmmc_host *au1xmmc_hosts[AU1XMMC_CONTROLLER_COUNT];
+static int dma = 1;
+
+#ifdef MODULE
+MODULE_PARM(dma, "i");
+MODULE_PARM_DESC(dma, "Use DMA engine for data transfers (0 = disabled)");
+#endif
+
+static inline void IRQ_ON(struct au1xmmc_host *host, u32 mask) 
+{
+	u32 val = au_readl(HOST_CONFIG(host));
+	val |= mask;
+	au_writel(val, HOST_CONFIG(host));
+	au_sync();
+}
+
+static inline void FLUSH_FIFO(struct au1xmmc_host *host) 
+{
+	u32 val = au_readl(HOST_CONFIG2(host));
+
+	au_writel(val | SD_CONFIG2_FF, HOST_CONFIG2(host));
+	au_sync_delay(1);
+	
+	/* SEND_STOP will turn off clock control - this re-enables it */
+	val &= ~SD_CONFIG2_DF;
+
+	au_writel(val, HOST_CONFIG2(host));
+	au_sync();
+}
+
+static inline void IRQ_OFF(struct au1xmmc_host *host, u32 mask) 
+{
+	u32 val = au_readl(HOST_CONFIG(host));
+	val &= ~mask;
+	au_writel(val, HOST_CONFIG(host));
+	au_sync();
+}
+
+static inline void SEND_STOP(struct au1xmmc_host *host) 
+{
+
+	/* We know the value of CONFIG2, so avoid a read we don't need */
+	u32 mask = SD_CONFIG2_EN;
+
+	WARN_ON(host->status != HOST_S_DATA);
+	host->status = HOST_S_STOP;
+
+	au_writel(mask | SD_CONFIG2_DF, HOST_CONFIG2(host));
+	au_sync();
+
+	/* Send the stop commmand */
+	au_writel(STOP_CMD, HOST_CMD(host));
+}
+
+static void au1xmmc_set_power(struct au1xmmc_host *host, int state) 
+{
+
+	u32 val = au1xmmc_card_table[host->id].bcsrpwr;
+
+	bcsr->board &= ~val;
+	if (state) bcsr->board |= val;
+	
+	au_sync_delay(1);
+}
+
+static inline int au1xmmc_card_inserted(struct au1xmmc_host *host) 
+{
+	return (bcsr->sig_status & au1xmmc_card_table[host->id].bcsrstatus) 
+		? 1 : 0;
+}	
+
+static inline int au1xmmc_card_readonly(struct au1xmmc_host *host) 
+{
+	return (bcsr->status & au1xmmc_card_table[host->id].wpstatus) 
+		? 1 : 0;
+}
+
+static void au1xmmc_finish_request(struct au1xmmc_host *host) 
+{
+  
+	struct mmc_request *mrq = host->mrq;
+
+	host->mrq = NULL;
+	host->flags &= HOST_F_ACTIVE; 
+
+	host->dma.len = 0;
+	host->dma.dir = 0;
+
+	host->pio.index  = 0;
+	host->pio.offset = 0;
+	host->pio.len = 0;
+
+	host->status = HOST_S_IDLE;
+
+	bcsr->disk_leds |= (1 << 8);
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void au1xmmc_tasklet_finish(unsigned long param) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) param;
+	au1xmmc_finish_request(host);
+}
+
+static int au1xmmc_send_command(struct au1xmmc_host *host, int wait,  
+				struct mmc_command *cmd) 
+{
+
+	u32 mmccmd = (cmd->opcode << SD_CMD_CI_SHIFT);
+
+	switch(cmd->flags) {
+	case MMC_RSP_R1:
+		mmccmd |= SD_CMD_RT_1;
+		break;
+	case MMC_RSP_R1B:
+		mmccmd |= SD_CMD_RT_1B;
+		break;
+	case MMC_RSP_R2:
+		mmccmd |= SD_CMD_RT_2;
+		break;
+	case MMC_RSP_R3:
+		mmccmd |= SD_CMD_RT_3;
+		break;
+	}
+
+	switch(cmd->opcode) {
+	case MMC_READ_SINGLE_BLOCK:
+	case SD_APP_SEND_SCR:
+		mmccmd |= SD_CMD_CT_2;
+		break;
+	case MMC_READ_MULTIPLE_BLOCK:
+		mmccmd |= SD_CMD_CT_4;
+		break;
+	case MMC_WRITE_BLOCK:
+		mmccmd |= SD_CMD_CT_1;
+		break;
+	
+	case MMC_WRITE_MULTIPLE_BLOCK:
+		mmccmd |= SD_CMD_CT_3;
+		break;
+	case MMC_STOP_TRANSMISSION:
+		mmccmd |= SD_CMD_CT_7;
+		break;
+	}
+	
+	au_writel(cmd->arg, HOST_CMDARG(host));
+	au_sync();
+
+	if (wait) 
+		IRQ_OFF(host, SD_CONFIG_CR);
+	
+	au_writel((mmccmd | SD_CMD_GO), HOST_CMD(host));
+	au_sync();
+
+	/* Wait for the command to go on the line */
+
+	while(1) {
+		if (!(au_readl(HOST_CMD(host)) & SD_CMD_GO))
+			break;
+	}
+
+	/* Wait for the command to come back */
+
+	if (wait) {
+		u32 status = au_readl(HOST_STATUS(host));
+
+		while(!(status & SD_STATUS_CR)) 
+			status = au_readl(HOST_STATUS(host));
+		
+		/* Clear the CR status */
+		au_writel(SD_STATUS_CR, HOST_STATUS(host));
+
+		IRQ_ON(host, SD_CONFIG_CR);
+	}
+
+	return MMC_ERR_NONE;
+}
+
+static void au1xmmc_data_complete(struct au1xmmc_host *host, u32 status) 
+{
+
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *data;
+	u32 crc;
+
+	WARN_ON(host->status != HOST_S_DATA && host->status != HOST_S_STOP);
+
+	if (host->mrq == NULL)
+		return;
+
+	data = mrq->cmd->data;
+
+	if (status == 0)
+		status = au_readl(HOST_STATUS(host));
+
+	/* The transaction is really over when the SD_STATUS_DB bit is clear */
+
+	while((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB)) 
+		status = au_readl(HOST_STATUS(host));
+
+	data->error = MMC_ERR_NONE;
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);
+
+        /* Process any errors */
+
+	crc = (status & (SD_STATUS_WC | SD_STATUS_RC));
+	if (host->flags & HOST_F_XMIT) 
+		crc |= ((status & 0x07) == 0x02) ? 0 : 1;
+	
+	if (crc) 
+		data->error = MMC_ERR_BADCRC;
+
+	/* Clear the CRC bits */
+	au_writel(SD_STATUS_WC | SD_STATUS_RC, HOST_STATUS(host));
+
+	data->bytes_xfered = 0;
+
+	if (data->error == MMC_ERR_NONE) {
+		if (host->flags & HOST_F_DMA) {
+			u32 chan = DMA_CHANNEL(host);
+
+			chan_tab_t *c = *((chan_tab_t **) chan);
+			au1x_dma_chan_t *cp = c->chan_ptr;
+			data->bytes_xfered = cp->ddma_bytecnt;
+		}
+		else 
+			data->bytes_xfered = 
+				(data->blocks * (1 << data->blksz_bits)) - 
+				host->pio.len;
+	}
+
+	au1xmmc_finish_request(host);
+}
+
+static void au1xmmc_tasklet_data(unsigned long param) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) param;
+
+	u32 status = au_readl(HOST_STATUS(host));
+	au1xmmc_data_complete(host, status);
+}
+
+#define AU1XMMC_MAX_TRANSFER 8
+
+static void au1xmmc_send_pio(struct au1xmmc_host *host) 
+{
+
+	struct mmc_data *data = 0;
+	int sg_len, max, count = 0;
+	unsigned char *sg_ptr;
+	u32 status = 0;
+	struct scatterlist *sg;
+
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_XMIT)) 
+		return;
+	
+	/* This is the pointer to the data buffer */
+	sg = &data->sg[host->pio.index];
+	sg_ptr = page_address(sg->page) + sg->offset + host->pio.offset;
+
+	/* This is the space left inside the buffer */
+	sg_len = data->sg[host->pio.index].length - host->pio.offset;
+
+	/* Check to if we need less then the size of the sg_buffer */
+
+	max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
+	if (max > AU1XMMC_MAX_TRANSFER) max = AU1XMMC_MAX_TRANSFER;
+
+	for(count = 0; count < max; count++ ) {
+		unsigned char val;
+
+		status = au_readl(HOST_STATUS(host));		
+
+		if (!(status & SD_STATUS_TH))
+			break;
+
+		val = *sg_ptr++;
+
+		au_writel((unsigned long) val, HOST_TXPORT(host));
+		au_sync();
+	}
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+	if (host->pio.len == 0) {
+		IRQ_OFF(host, SD_CONFIG_TH);
+
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host);
+		 
+		tasklet_schedule(&host->data_task);
+	}
+}
+
+static void au1xmmc_receive_pio(struct au1xmmc_host *host) 
+{
+
+	struct mmc_data *data = 0;
+	int sg_len = 0, max = 0, count = 0;
+	unsigned char *sg_ptr = 0;
+	u32 status = 0;
+	struct scatterlist *sg;
+
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_RECV)) 
+		return;
+
+	max = host->pio.len;
+
+	if (host->pio.index < host->dma.len) {
+		sg = &data->sg[host->pio.index];
+		sg_ptr = page_address(sg->page) + sg->offset + host->pio.offset;
+			
+		/* This is the space left inside the buffer */
+		sg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;
+
+		/* Check to if we need less then the size of the sg_buffer */
+		if (sg_len < max) max = sg_len;
+	}
+
+	if (max > AU1XMMC_MAX_TRANSFER) 
+		max = AU1XMMC_MAX_TRANSFER;
+
+	for(count = 0; count < max; count++ ) { 
+		u32 val;
+		status = au_readl(HOST_STATUS(host));
+
+		if (!(status & SD_STATUS_NE))
+			break;
+
+		if (status & SD_STATUS_RC) {
+			DEBUG("RX CRC Error [%d + %d].\n", host->id, 
+					host->pio.len, count);
+			break;
+		}
+
+		if (status & SD_STATUS_RO) {
+			DEBUG("RX Overrun [%d + %d]\n", host->id, 
+					host->pio.len, count);
+			break;
+		}
+		else if (status & SD_STATUS_RU) {
+			DEBUG("RX Underrun [%d + %d]\n", host->id, 
+					host->pio.len,	count);
+			break;
+		}
+
+		val = au_readl(HOST_RXPORT(host)); 
+
+		if (sg_ptr) 
+			*sg_ptr++ = (unsigned char) (val & 0xFF);
+	}
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (sg_len && count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+	if (host->pio.len == 0) {
+		//IRQ_OFF(host, SD_CONFIG_RA | SD_CONFIG_RF);
+		IRQ_OFF(host, SD_CONFIG_NE);
+
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host);
+
+		tasklet_schedule(&host->data_task);
+	}
+}
+
+/* static void au1xmmc_cmd_complete
+   This is called when a command has been completed - grab the response
+   and check for errors.  Then start the data transfer if it is indicated.
+*/
+
+static void au1xmmc_cmd_complete(struct au1xmmc_host *host, u32 status) 
+{
+
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd;
+	int trans;
+
+	if (!host->mrq) 
+		return;
+
+	cmd = mrq->cmd;
+	cmd->error = MMC_ERR_NONE;
+
+	if ((cmd->flags & MMC_RSP_MASK) == MMC_RSP_SHORT) {
+
+		/* Techincally, we should be getting all 48 bits of the response
+		 * (SD_RESP1 + SD_RESP2), but because our response omits the CRC,
+		 * our data ends up being shifted 8 bits to the right.  In this case,
+		 * that means that the OSR data starts at bit 31, so we can just
+		 * read RESP0 and return that 
+		 */
+
+		cmd->resp[0] = au_readl(host->iobase + SD_RESP0);
+	}
+	else if ((cmd->flags & MMC_RSP_MASK) == MMC_RSP_LONG) {
+		u32 r[4];
+		int i;
+
+		r[0] = au_readl(host->iobase + SD_RESP3);
+		r[1] = au_readl(host->iobase + SD_RESP2);
+		r[2] = au_readl(host->iobase + SD_RESP1);
+		r[3] = au_readl(host->iobase + SD_RESP0);
+		
+		/* The CRC is omitted from the response, so really we only got
+		 * 120 bytes, but the engine expects 128 bits, so we have to shift
+		 * things up 
+		 */
+		
+		for(i = 0; i < 4; i++) {
+			cmd->resp[i] = (r[i] & 0x00FFFFFF) << 8;
+			if (i != 3) cmd->resp[i] |= (r[i + 1] & 0xFF000000) >> 24;
+		}
+	}
+
+        /* Figure out errors */
+
+	if (status & (SD_STATUS_SC | SD_STATUS_WC | SD_STATUS_RC))
+		cmd->error = MMC_ERR_BADCRC;
+
+	trans = host->flags & (HOST_F_XMIT | HOST_F_RECV);
+
+	if (!trans || cmd->error != MMC_ERR_NONE) {
+
+		IRQ_OFF(host, SD_CONFIG_TH | SD_CONFIG_RA|SD_CONFIG_RF);
+		tasklet_schedule(&host->finish_task);
+		return;
+	}
+
+	host->status = HOST_S_DATA;
+
+	if (host->flags & HOST_F_DMA) {
+		u32 channel = DMA_CHANNEL(host);
+
+		/* Start the DMA as soon as the buffer gets something in it */
+
+		if (host->flags & HOST_F_RECV) {
+			u32 mask = SD_STATUS_DB | SD_STATUS_NE;
+
+			while((status & mask) != mask) 
+				status = au_readl(HOST_STATUS(host));
+		}
+
+		au1xxx_dbdma_start(channel);
+	}
+}
+
+static void au1xmmc_set_clock(struct au1xmmc_host *host, int rate) 
+{
+
+	unsigned int pbus = get_au1x00_speed();
+	unsigned int divisor;
+	u32 config;
+
+	/* From databook:
+	   divisor = ((((cpuclock / sbus_divisor) / 2) / mmcclock) / 2) - 1
+	*/
+
+	pbus /= ((au_readl(SYS_POWERCTRL) & 0x3) + 2);
+	pbus /= 2;
+
+	divisor = ((pbus / rate) / 2) - 1;
+
+	config = au_readl(HOST_CONFIG(host));
+
+	config &= ~(SD_CONFIG_DIV);
+	config |= (divisor & SD_CONFIG_DIV) | SD_CONFIG_DE;
+
+	au_writel(config, HOST_CONFIG(host));
+	au_sync();
+}
+
+static int 
+au1xmmc_prepare_data(struct au1xmmc_host *host, struct mmc_data *data) 
+{
+
+	int datalen = data->blocks * (1 << data->blksz_bits);
+
+	if (dma != 0) 
+		host->flags |= HOST_F_DMA;
+
+	if (data->flags & MMC_DATA_READ)
+		host->flags |= HOST_F_RECV;
+	else
+		host->flags |= HOST_F_XMIT;
+
+	if (host->mrq->stop) 
+		host->flags |= HOST_F_STOP;
+		
+	host->dma.dir = DMA_BIDIRECTIONAL;
+
+	host->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,
+				   data->sg_len, host->dma.dir);
+
+	if (host->dma.len == 0)
+		return MMC_ERR_TIMEOUT;
+
+	au_writel((1 << data->blksz_bits) - 1, HOST_BLKSIZE(host));	
+
+	if (host->flags & HOST_F_DMA) {
+		int i;
+		u32 channel = DMA_CHANNEL(host);
+
+		au1xxx_dbdma_stop(channel);
+
+		for(i = 0; i < host->dma.len; i++) {
+			u32 ret = 0, flags = DDMA_FLAGS_NOIE;
+			struct scatterlist *sg = &data->sg[i];
+			int sg_len = sg->length;
+			
+			int len = (datalen > sg_len) ? sg_len : datalen;
+
+			if (i == host->dma.len - 1)
+				flags = DDMA_FLAGS_IE;
+
+    			if (host->flags & HOST_F_XMIT){
+      				ret = au1xxx_dbdma_put_source_flags(channel, 
+					(void *) (page_address(sg->page) + 
+						  sg->offset), 
+					len, flags);
+			}
+    			else {
+      				ret = au1xxx_dbdma_put_dest_flags(channel, 
+					(void *) (page_address(sg->page) + 
+						  sg->offset), 
+					len, flags);
+			}
+
+    			if (!ret) 
+				goto dataerr;
+
+			datalen -= len;
+		}
+	}
+	else {
+		host->pio.index = 0;
+		host->pio.offset = 0;
+		host->pio.len = datalen;
+		
+		if (host->flags & HOST_F_XMIT)
+			IRQ_ON(host, SD_CONFIG_TH);
+		else 
+			IRQ_ON(host, SD_CONFIG_NE);
+			//IRQ_ON(host, SD_CONFIG_RA|SD_CONFIG_RF);
+	}
+
+	return MMC_ERR_NONE;
+
+ dataerr:
+	dma_unmap_sg(mmc_dev(host->mmc),data->sg,data->sg_len,host->dma.dir); 
+	return MMC_ERR_TIMEOUT;
+} 
+
+/* static void au1xmmc_request
+   This actually starts a command or data transaction
+*/
+
+static void au1xmmc_request(struct mmc_host* mmc, struct mmc_request* mrq) 
+{
+
+	struct au1xmmc_host *host = mmc_priv(mmc);
+	int ret = MMC_ERR_NONE;
+
+	WARN_ON(irqs_disabled());
+	WARN_ON(host->status != HOST_S_IDLE);
+
+	host->mrq = mrq;
+	host->status = HOST_S_CMD;
+
+	bcsr->disk_leds &= ~(1 << 8);
+
+	if (mrq->data) {
+		FLUSH_FIFO(host);
+		ret = au1xmmc_prepare_data(host, mrq->data);
+	}
+
+	if (ret == MMC_ERR_NONE)
+		ret = au1xmmc_send_command(host, 0, mrq->cmd);
+
+	if (ret != MMC_ERR_NONE) {
+		mrq->cmd->error = ret;
+		au1xmmc_finish_request(host);
+	}
+}
+
+static void au1xmmc_reset_controller(struct au1xmmc_host *host) 
+{
+
+	/* Apply the clock */
+	au_writel(SD_ENABLE_CE, HOST_ENABLE(host));
+        au_sync_delay(1);
+
+	au_writel(SD_ENABLE_R | SD_ENABLE_CE, HOST_ENABLE(host));
+	au_sync_delay(5);
+
+	au_writel(~0, HOST_STATUS(host));
+	au_sync();
+
+	au_writel(0, HOST_BLKSIZE(host));
+	au_writel(0x001fffff, HOST_TIMEOUT(host));
+	au_sync();
+
+	au_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));
+        au_sync();
+
+	au_writel(SD_CONFIG2_EN | SD_CONFIG2_FF, HOST_CONFIG2(host));
+	au_sync_delay(1);
+
+	au_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));
+	au_sync();
+
+	/* Configure interrupts */
+	au_writel(AU1XMMC_INTERRUPTS, HOST_CONFIG(host));
+	au_sync();
+}
+	
+
+static void au1xmmc_set_ios(struct mmc_host* mmc, struct mmc_ios* ios) 
+{
+	struct au1xmmc_host *host = mmc_priv(mmc);
+
+	DEBUG("set_ios (power=%u, clock=%uHz, vdd=%u, mode=%u)\n",
+	      host->id, ios->power_mode, ios->clock, ios->vdd, 
+	      ios->bus_mode);
+
+	if (ios->power_mode == MMC_POWER_OFF) 
+		au1xmmc_set_power(host, 0);
+	else if (ios->power_mode == MMC_POWER_ON) {
+		au1xmmc_set_power(host, 1);
+	}
+
+	if (ios->clock && ios->clock != host->clock) {
+		au1xmmc_set_clock(host, ios->clock);
+		host->clock = ios->clock;
+	}
+}
+
+static void au1xmmc_dma_callback(int irq, void *dev_id, struct pt_regs *regs) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) dev_id;
+	u32 status;
+
+	/* Avoid spurious interrupts */
+
+	if (!host->mrq) 
+		return;
+
+	if (host->flags & HOST_F_STOP) 
+		SEND_STOP(host);
+
+	tasklet_schedule(&host->data_task);
+}
+
+#define STATUS_TIMEOUT (SD_STATUS_RAT | SD_STATUS_DT)
+#define STATUS_DATA_IN  (SD_STATUS_NE)
+#define STATUS_DATA_OUT (SD_STATUS_TH)
+
+static irqreturn_t au1xmmc_irq(int irq, void *dev_id, struct pt_regs *regs) 
+{
+  
+	u32 status;
+	int i, ret = 0;
+
+	disable_irq(AU1100_SD_IRQ);
+
+	for(i = 0; i < AU1XMMC_CONTROLLER_COUNT; i++) {    
+		struct au1xmmc_host * host = au1xmmc_hosts[i];
+		u32 handled = 1;
+
+		status = au_readl(HOST_STATUS(host));
+
+		if (host->mrq && (status & STATUS_TIMEOUT)) {
+			if (status & SD_STATUS_RAT)  
+				host->mrq->cmd->error = MMC_ERR_TIMEOUT;
+			
+			else if (status & SD_STATUS_DT) 
+				host->mrq->data->error = MMC_ERR_TIMEOUT;
+		
+			/* In PIO mode, interrupts might still be enabled */
+			IRQ_OFF(host, SD_CONFIG_NE | SD_CONFIG_TH);
+
+			//IRQ_OFF(host, SD_CONFIG_TH|SD_CONFIG_RA|SD_CONFIG_RF);
+			tasklet_schedule(&host->finish_task);
+		}
+#if 0
+		else if (status & SD_STATUS_DD) {
+
+			/* Sometimes we get a DD before a NE in PIO mode */
+
+			if (!(host->flags & HOST_F_DMA) && 
+					(status & SD_STATUS_NE))
+				au1xmmc_receive_pio(host);
+			else {
+				au1xmmc_data_complete(host, status);
+				//tasklet_schedule(&host->data_task);
+			}
+		}
+#endif
+		else if (status & (SD_STATUS_CR)) {
+			if (host->status == HOST_S_CMD)
+				au1xmmc_cmd_complete(host,status);
+		}
+		else if (!(host->flags & HOST_F_DMA)) { 
+			if ((host->flags & HOST_F_XMIT) && 
+			    (status & STATUS_DATA_OUT))
+				au1xmmc_send_pio(host);
+			else if ((host->flags & HOST_F_RECV) && 
+			    (status & STATUS_DATA_IN))
+				au1xmmc_receive_pio(host);
+		}
+		else if (status & 0x203FBC70) {
+			DEBUG("Unhandled status %8.8x\n", host->id, status);
+			handled = 0;
+		}
+		
+		au_writel(status, HOST_STATUS(host));
+		au_sync();
+
+		ret |= handled;
+	}
+
+	enable_irq(AU1100_SD_IRQ);
+	return ret;
+}
+
+static void au1xmmc_poll_event(unsigned long arg) 
+{
+	struct au1xmmc_host *host = (struct au1xmmc_host *) arg;
+
+	int card = au1xmmc_card_inserted(host);
+        int controller = (host->flags & HOST_F_ACTIVE) ? 1 : 0;
+
+	if (card != controller) {
+		host->flags &= ~HOST_F_ACTIVE;
+		if (card) host->flags |= HOST_F_ACTIVE;
+		mmc_detect_change(host->mmc, 0);
+	}
+
+	if (host->mrq != NULL) {
+		u32 status = au_readl(HOST_STATUS(host));
+		DEBUG("PENDING - %8.8x\n", host->id, status);
+	}
+
+	mod_timer(&host->timer, jiffies + AU1XMMC_DETECT_TIMEOUT);
+}
+
+static dbdev_tab_t au1xmmc_mem_dbdev = 
+{
+	DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 8, 0x00000000, 0, 0
+};
+
+static void au1xmmc_init_dma(struct au1xmmc_host *host) 
+{
+	
+	u32 rxchan, txchan;
+	
+	int txid = au1xmmc_card_table[host->id].tx_devid;
+	int rxid = au1xmmc_card_table[host->id].rx_devid;
+	
+	/* DSCR_CMD0_ALWAYS has a stride of 32 bits, we need a stride
+	   of 8 bits.  And since devices are shared, we need to create
+	   our own to avoid freaking out other devices
+	*/
+	
+	int memid = au1xxx_ddma_add_device(&au1xmmc_mem_dbdev);
+		
+	txchan = au1xxx_dbdma_chan_alloc(memid, txid, 
+					 au1xmmc_dma_callback, (void *) host);
+
+	rxchan = au1xxx_dbdma_chan_alloc(rxid, memid, 
+					 au1xmmc_dma_callback, (void *) host);
+
+	au1xxx_dbdma_set_devwidth(txchan, 8);
+	au1xxx_dbdma_set_devwidth(rxchan, 8);
+
+	au1xxx_dbdma_ring_alloc(txchan, AU1XMMC_DESCRIPTOR_COUNT);
+	au1xxx_dbdma_ring_alloc(rxchan, AU1XMMC_DESCRIPTOR_COUNT);
+
+	host->tx_chan = txchan;
+	host->rx_chan = rxchan;
+}
+
+struct mmc_host_ops au1xmmc_ops = {
+	.request	= au1xmmc_request,
+	.set_ios	= au1xmmc_set_ios,
+};
+
+static int au1xmmc_probe(struct device *dev) 
+{
+
+	int i, ret = 0;
+
+	/* THe interrupt is shared among all controllers */
+	ret = request_irq(AU1100_SD_IRQ, au1xmmc_irq, SA_INTERRUPT, "MMC", 0);
+  
+	if (ret) {
+		printk(DRIVER_NAME "ERROR: Couldn't get int %d: %d\n", 
+				AU1100_SD_IRQ, ret);
+		return -ENXIO;
+	}
+
+	disable_irq(AU1100_SD_IRQ);
+
+	for(i = 0; i < AU1XMMC_CONTROLLER_COUNT; i++) {
+		struct mmc_host *mmc = mmc_alloc_host(sizeof(struct au1xmmc_host), dev);
+		struct au1xmmc_host *host = 0;
+
+		if (!mmc) {
+			printk(DRIVER_NAME "ERROR: no mem for host %d\n", i);
+			au1xmmc_hosts[i] = 0;
+			continue;
+		}
+
+		mmc->ops = &au1xmmc_ops;
+   
+		mmc->f_min =   450000;
+		mmc->f_max = 24000000;
+
+		mmc->max_seg_size = AU1XMMC_DESCRIPTOR_SIZE;
+		mmc->max_phys_segs = AU1XMMC_DESCRIPTOR_COUNT; 
+
+		mmc->ocr_avail = AU1XMMC_OCR;
+
+		host = mmc_priv(mmc);
+		host->mmc = mmc;
+
+		host->id = i;
+		host->iobase = au1xmmc_card_table[host->id].iobase;
+		host->clock = 0;
+		host->power_mode = MMC_POWER_OFF;
+		
+		host->flags = au1xmmc_card_inserted(host) ? HOST_F_ACTIVE : 0;
+		host->status = HOST_S_IDLE;
+
+		init_timer(&host->timer);
+
+		host->timer.function = au1xmmc_poll_event;
+		host->timer.data = (unsigned long) host;
+		host->timer.expires = jiffies + AU1XMMC_DETECT_TIMEOUT;
+
+		tasklet_init(&host->data_task, au1xmmc_tasklet_data, 
+				(unsigned long) host);
+
+		tasklet_init(&host->finish_task, au1xmmc_tasklet_finish, 
+				(unsigned long) host);
+
+		spin_lock_init(&host->lock);
+
+		if (dma != 0)
+			au1xmmc_init_dma(host);
+
+		au1xmmc_reset_controller(host);
+
+		mmc_add_host(mmc);
+		au1xmmc_hosts[i] = host;
+
+		add_timer(&host->timer);
+
+		printk(KERN_INFO DRIVER_NAME ": MMC Controller %d set up at %8.8X (mode=%s)\n",
+		       host->id, host->iobase, dma ? "dma" : "pio");
+	}
+  
+	enable_irq(AU1100_SD_IRQ);
+
+	return 0;
+}
+    
+static int au1xmmc_remove(struct device *dev) 
+{
+ 
+	int i;
+
+	disable_irq(AU1100_SD_IRQ);
+  
+	for(i = 0; i < AU1XMMC_CONTROLLER_COUNT; i++) {
+		struct au1xmmc_host *host = au1xmmc_hosts[i];
+		if (!host) continue;
+
+		tasklet_kill(&host->data_task);
+		tasklet_kill(&host->finish_task);
+
+		del_timer_sync(&host->timer);
+		au1xmmc_set_power(host, 0);
+		
+		mmc_remove_host(host->mmc);
+    
+		au1xxx_dbdma_chan_free(host->tx_chan);
+		au1xxx_dbdma_chan_free(host->rx_chan);
+   
+		au_writel(0x0, HOST_ENABLE(host));
+		au_sync();	
+	} 
+
+	free_irq(AU1100_SD_IRQ, 0);
+	return 0;
+}
+
+static struct device_driver au1xmmc_driver = {
+	.name          = DRIVER_NAME,
+	.bus           = &platform_bus_type,
+	.probe         = au1xmmc_probe,
+	.remove        = au1xmmc_remove,
+	.suspend       = NULL,
+	.resume        = NULL
+};
+
+static int __init au1xmmc_init(void) 
+{
+	return driver_register(&au1xmmc_driver);
+}
+
+static void __exit au1xmmc_exit(void) 
+{
+	driver_unregister(&au1xmmc_driver);
+}
+
+module_init(au1xmmc_init);
+module_exit(au1xmmc_exit);
+
+#ifdef MODULE
+MODULE_AUTHOR("Advanced Micro Devices, Inc");
+MODULE_DESCRIPTION("MMC/SD driver for the Alchemy Au1XXX");
+MODULE_LICENSE("GPL");
+#endif
+
diff -Naur linux-2.6.14/drivers/mmc/au1xmmc.h linux-mips-2.6.14.orig/drivers/mmc/au1xmmc.h
--- linux-2.6.14/drivers/mmc/au1xmmc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/mmc/au1xmmc.h	2005-11-17 11:43:08.000000000 -0800
@@ -0,0 +1,96 @@
+#ifndef _AU1XMMC_H_
+#define _AU1XMMC_H_
+
+/* Hardware definitions */
+
+#define AU1XMMC_DESCRIPTOR_COUNT 1
+#define AU1XMMC_DESCRIPTOR_SIZE  2048
+
+#define AU1XMMC_OCR ( MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30  | \
+		      MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33  | \
+		      MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36)
+
+/* Easy access macros */
+
+#define HOST_STATUS(h)	((h)->iobase + SD_STATUS)
+#define HOST_CONFIG(h)	((h)->iobase + SD_CONFIG)
+#define HOST_ENABLE(h)	((h)->iobase + SD_ENABLE)
+#define HOST_TXPORT(h)	((h)->iobase + SD_TXPORT)
+#define HOST_RXPORT(h)	((h)->iobase + SD_RXPORT)
+#define HOST_CMDARG(h)	((h)->iobase + SD_CMDARG)
+#define HOST_BLKSIZE(h)	((h)->iobase + SD_BLKSIZE)
+#define HOST_CMD(h)	((h)->iobase + SD_CMD)
+#define HOST_CONFIG2(h)	((h)->iobase + SD_CONFIG2)
+#define HOST_TIMEOUT(h)	((h)->iobase + SD_TIMEOUT)
+#define HOST_DEBUG(h)	((h)->iobase + SD_DEBUG)
+
+#define DMA_CHANNEL(h) \
+	( ((h)->flags & HOST_F_XMIT) ? (h)->tx_chan : (h)->rx_chan)
+
+/* This gives us a hard value for the stop command that we can write directly
+ * to the command register
+ */
+
+#define STOP_CMD (SD_CMD_RT_1B|SD_CMD_CT_7|(0xC << SD_CMD_CI_SHIFT)|SD_CMD_GO)
+
+/* This is the set of interrupts that we configure by default */
+
+#if 0
+#define AU1XMMC_INTERRUPTS (SD_CONFIG_SC | SD_CONFIG_DT | SD_CONFIG_DD | \
+		SD_CONFIG_RAT | SD_CONFIG_CR | SD_CONFIG_I)
+#endif
+
+#define AU1XMMC_INTERRUPTS (SD_CONFIG_SC | SD_CONFIG_DT | \
+		SD_CONFIG_RAT | SD_CONFIG_CR | SD_CONFIG_I)
+/* The poll event (looking for insert/remove events runs twice a second */
+#define AU1XMMC_DETECT_TIMEOUT (HZ/2)
+
+struct au1xmmc_host {
+  struct mmc_host *mmc;
+  struct mmc_request *mrq;
+
+  u32 id;
+
+  u32 flags;
+  u32 iobase;
+  u32 clock;
+  u32 bus_width;
+  u32 power_mode;
+
+  int status;
+
+   struct {
+	   int len;
+	   int dir;
+  } dma;
+
+   struct {
+	   int index;
+	   int offset;
+	   int len;
+  } pio;
+
+  u32 tx_chan;
+  u32 rx_chan;
+
+  struct timer_list timer;
+  struct tasklet_struct finish_task;
+  struct tasklet_struct data_task;
+
+  spinlock_t lock;
+};
+
+/* Status flags used by the host structure */
+
+#define HOST_F_XMIT   0x0001
+#define HOST_F_RECV   0x0002
+#define HOST_F_DMA    0x0010
+#define HOST_F_ACTIVE 0x0100
+#define HOST_F_STOP   0x1000
+
+#define HOST_S_IDLE   0x0001
+#define HOST_S_CMD    0x0002
+#define HOST_S_DATA   0x0003
+#define HOST_S_STOP   0x0004
+
+#endif
diff -Naur linux-2.6.14/drivers/mmc/Kconfig linux-mips-2.6.14.orig/drivers/mmc/Kconfig
--- linux-2.6.14/drivers/mmc/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mmc/Kconfig	2005-11-17 11:43:08.000000000 -0800
@@ -60,4 +60,13 @@
 
 	  If unsure, say N.
 
+config MMC_AU1X
+	tristate "Alchemy AU1XX0 MMC Card Interface support"
+	depends on SOC_AU1X00 && MMC
+	help
+	  This selects the AMD Alchemy(R) Multimedia card interface.
+	  iIf you have a Alchemy platform with a MMC slot, say Y or M here.
+
+	  If unsure, say N.
+
 endmenu
diff -Naur linux-2.6.14/drivers/mmc/Makefile linux-mips-2.6.14.orig/drivers/mmc/Makefile
--- linux-2.6.14/drivers/mmc/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mmc/Makefile	2005-11-17 11:43:08.000000000 -0800
@@ -18,5 +18,6 @@
 obj-$(CONFIG_MMC_ARMMMCI)	+= mmci.o
 obj-$(CONFIG_MMC_PXA)		+= pxamci.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
+obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
 
 mmc_core-y := mmc.o mmc_queue.o mmc_sysfs.o
diff -Naur linux-2.6.14/drivers/mtd/devices/docprobe.c linux-mips-2.6.14.orig/drivers/mtd/devices/docprobe.c
--- linux-2.6.14/drivers/mtd/devices/docprobe.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/devices/docprobe.c	2005-11-17 11:43:09.000000000 -0800
@@ -84,10 +84,10 @@
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-        0xff000000,
+	0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-        0xff000000,
-##else
+	0xff000000,
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0xffffffff };
diff -Naur linux-2.6.14/drivers/mtd/devices/Kconfig linux-mips-2.6.14.orig/drivers/mtd/devices/Kconfig
--- linux-2.6.14/drivers/mtd/devices/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/devices/Kconfig	2005-11-17 11:43:08.000000000 -0800
@@ -47,6 +47,11 @@
 	  accelerator.  Say Y here if you have a DECstation 5000/2x0 or a
 	  DECsystem 5900 equipped with such a module.
 
+	  If you want to compile this driver as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module will
+	  be called ms02-nv.o.
+
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	depends on MTD
diff -Naur linux-2.6.14/drivers/mtd/devices/ms02-nv.c linux-mips-2.6.14.orig/drivers/mtd/devices/ms02-nv.c
--- linux-2.6.14/drivers/mtd/devices/ms02-nv.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/devices/ms02-nv.c	2005-11-17 11:43:09.000000000 -0800
@@ -293,13 +293,13 @@
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
-		csr = (volatile u32 *)KN02_CSR_BASE;
+		csr = (volatile u32 *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);
 		if (*csr & KN02_CSR_BNK32M)
 			stride = 2;
 		break;
 	case MACH_DS5000_2X0:
 	case MACH_DS5900:
-		csr = (volatile u32 *)KN03_MCR_BASE;
+		csr = (volatile u32 *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_MCR);
 		if (*csr & KN03_MCR_BNK32M)
 			stride = 2;
 		break;
diff -Naur linux-2.6.14/drivers/mtd/maps/alchemy-flash.c linux-mips-2.6.14.orig/drivers/mtd/maps/alchemy-flash.c
--- linux-2.6.14/drivers/mtd/maps/alchemy-flash.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/maps/alchemy-flash.c	2005-11-17 11:43:09.000000000 -0800
@@ -1,7 +1,7 @@
 /*
  * Flash memory access on AMD Alchemy evaluation boards
  * 
- * $Id: alchemy-flash.c,v 1.1 2005/02/27 21:50:21 ppopov Exp $
+ * $Id: alchemy-flash.c,v 1.0 2004/11/04 13:24:14 ppopov Exp $
  *
  * (C) 2003, 2004 Pete Popov <ppopov@embeddedalley.com>
  * 
diff -Naur linux-2.6.14/drivers/mtd/maps/Kconfig linux-mips-2.6.14.orig/drivers/mtd/maps/Kconfig
--- linux-2.6.14/drivers/mtd/maps/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/maps/Kconfig	2005-11-17 11:43:09.000000000 -0800
@@ -199,24 +199,12 @@
 	help
 	  Support for the flash chip on Tsunami TIG bus.
 
-config MTD_LASAT
-	tristate "Flash chips on LASAT board"
-	depends on LASAT
-	help
-	  Support for the flash chips on the Lasat 100 and 200 boards.
-
 config MTD_NETtel
 	tristate "CFI flash device on SnapGear/SecureEdge"
 	depends on X86 && MTD_PARTITIONS && MTD_JEDECPROBE
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
-config MTD_ALCHEMY
-	tristate '  AMD Alchemy Pb1xxx/Db1xxx/RDK MTD support' 
-	depends on MIPS && SOC_AU1X00
-	help
-	  Flash memory access on AMD Alchemy Pb/Db/RDK Reference Boards
-
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CONCAT && MTD_PARTITIONS && MTD_CFI_INTELEXT
@@ -292,6 +280,24 @@
 	  Mapping for the Flaga digital module. If you don't have one, ignore
 	  this setting.
 
+config MTD_ALCHEMY
+	tristate '  AMD Alchemy Pb1xxx/Db1xxx/RDK MTD support' 
+	depends on MIPS && SOC_AU1X00
+	help
+	  Flash memory access on AMD Alchemy Pb/Db/RDK Reference Boards
+
+config MTD_XXS1500
+	tristate "MyCable XXS1500 Flash device"
+	depends on MIPS && MIPS_XXS1500
+	help
+	  Flash memory access on MyCable XXS1500 Board
+
+config MTD_MTX1
+	tristate "4-G Systems MTX-1 Flash device"
+	depends on MIPS && MIPS_MTX1
+	help
+	  Flash memory access on 4-G Systems MTX-1 Board
+
 config MTD_BEECH
 	tristate "CFI Flash device mapped on IBM 405LP Beech"
 	depends on MTD_CFI && PPC32 && 40x && BEECH
@@ -392,6 +398,12 @@
 	  NVRAM on the Momenco Ocelot board. If you have one of these boards
 	  and would like access to either of these, say 'Y'.
 
+config MTD_LASAT
+	tristate "LASAT flash device"
+	depends on LASAT && MTD_CFI
+	help
+	  Support for the flash chips on the Lasat 100 and 200 boards.
+
 config MTD_SOLUTIONENGINE
 	tristate "CFI Flash device mapped on Hitachi SolutionEngine"
 	depends on SUPERH && MTD_CFI && MTD_REDBOOT_PARTS
diff -Naur linux-2.6.14/drivers/mtd/maps/lasat.c linux-mips-2.6.14.orig/drivers/mtd/maps/lasat.c
--- linux-2.6.14/drivers/mtd/maps/lasat.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/maps/lasat.c	2005-11-17 11:43:09.000000000 -0800
@@ -7,7 +7,7 @@
  * modify it under the terms of the GNU General Public License version
  * 2 as published by the Free Software Foundation.
  *
- * $Id: lasat.c,v 1.9 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: lasat.c,v 1.7 2004/07/12 21:59:44 dwmw2 Exp $
  *
  */
 
@@ -50,7 +50,7 @@
 	ENABLE_VPP((&lasat_map));
 
 	lasat_map.phys = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
-	lasat_map.virt = ioremap_nocache(
+	lasat_map.virt = (unsigned long)ioremap_nocache(
 		        lasat_map.phys, lasat_board_info.li_flash_size);
 	lasat_map.size = lasat_board_info.li_flash_size;
 
diff -Naur linux-2.6.14/drivers/mtd/maps/Makefile linux-mips-2.6.14.orig/drivers/mtd/maps/Makefile
--- linux-2.6.14/drivers/mtd/maps/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/maps/Makefile	2005-11-17 11:43:09.000000000 -0800
@@ -44,8 +44,9 @@
 obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
-obj-$(CONFIG_MTD_ALCHEMY)       += alchemy-flash.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
+obj-$(CONFIG_MTD_PB1550)	+= pb1550-flash.o
+obj-$(CONFIG_MTD_DB1550)	+= db1550-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
@@ -67,6 +68,4 @@
 obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
-obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
-obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
-obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
+obj-$(CONFIG_MTD_ALCHEMY)       += alchemy-flash.o
diff -Naur linux-2.6.14/drivers/mtd/nand/au1550nd.c linux-mips-2.6.14.orig/drivers/mtd/nand/au1550nd.c
--- linux-2.6.14/drivers/mtd/nand/au1550nd.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/nand/au1550nd.c	2005-11-17 11:43:09.000000000 -0800
@@ -11,6 +11,7 @@
  *
  */
 
+#include <linux/config.h>
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -21,13 +22,7 @@
 
 /* fixme: this is ugly */
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 0)
-#include <asm/mach-au1x00/au1000.h>
-#ifdef CONFIG_MIPS_PB1550
-#include <asm/mach-pb1x00/pb1550.h> 
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#include <asm/mach-db1x00/db1x00.h> 
-#endif
+#include <asm/mach-au1x00/au1xxx.h>
 #else
 #include <asm/au1000.h>
 #ifdef CONFIG_MIPS_PB1550
@@ -45,39 +40,22 @@
 static void __iomem *p_nand;
 static int nand_width = 1; /* default x8*/
 
-#define NAND_CS 1
-
 /*
  * Define partitions for flash device
  */
 const static struct mtd_partition partition_info[] = {
-#ifdef CONFIG_MIPS_PB1550
-#define NUM_PARTITIONS            2
-	{ 
-		.name = "Pb1550 NAND FS 0",
-	  	.offset = 0,
-	  	.size = 8*1024*1024 
-	},
-	{ 
-		.name = "Pb1550 NAND FS 1",
-		.offset =  MTDPART_OFS_APPEND,
- 		.size =    MTDPART_SIZ_FULL
-	}
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#define NUM_PARTITIONS            2
 	{ 
-		.name = "Db1550 NAND FS 0",
+		.name 	= "NAND FS 0",
 	  	.offset = 0,
-	  	.size = 8*1024*1024 
+	  	.size 	= 8*1024*1024 
 	},
 	{ 
-		.name = "Db1550 NAND FS 1",
+		.name 	= "NAND FS 1",
 		.offset =  MTDPART_OFS_APPEND,
- 		.size =    MTDPART_SIZ_FULL
+ 		.size 	=    MTDPART_SIZ_FULL
 	}
-#endif
 };
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
 
 
 /**
@@ -339,11 +317,13 @@
 /*
  * Main initialization routine
  */
-int __init au1550_init (void)
+int __init au1xxx_nand_init (void)
 {
 	struct nand_chip *this;
 	u16 boot_swapboot = 0; /* default value */
 	int retval;
+	u32 mem_staddr;
+	u32 nand_phys;
 
 	/* Allocate memory for MTD device structure and private data */
 	au1550_mtd = kmalloc (sizeof(struct mtd_info) + 
@@ -364,8 +344,11 @@
 	au1550_mtd->priv = this;
 
 
-	/* MEM_STNDCTL: disable ints, disable nand boot */
-	au_writel(0, MEM_STNDCTL);
+	/* disable interrupts */
+	au_writel(au_readl(MEM_STNDCTL) & ~(1<<8), MEM_STNDCTL);
+ 
+	/* disable NAND boot */
+	au_writel(au_readl(MEM_STNDCTL) & ~(1<<0), MEM_STNDCTL);
 
 #ifdef CONFIG_MIPS_PB1550
 	/* set gpio206 high */
@@ -397,19 +380,60 @@
 	}
 #endif
 
-	/* Configure RCE1 - should be done by YAMON */
-	au_writel(0x5 | (nand_width << 22), 0xB4001010); /* MEM_STCFG1 */
-	au_writel(NAND_TIMING, 0xB4001014); /* MEM_STTIME1 */
-	au_sync();
-
-	/* setup and enable chip select, MEM_STADDR1 */
-	/* we really need to decode offsets only up till 0x20 */
-	au_writel((1<<28) | (NAND_PHYS_ADDR>>4) | 
-			(((NAND_PHYS_ADDR + 0x1000)-1) & (0x3fff<<18)>>18), 
-			MEM_STADDR1);
-	au_sync();
+	/* Configure chip-select; normally done by boot code, e.g. YAMON */
+#ifdef NAND_STCFG
+	if (NAND_CS == 0) {
+		au_writel(NAND_STCFG,  MEM_STCFG0);
+		au_writel(NAND_STTIME, MEM_STTIME0);
+		au_writel(NAND_STADDR, MEM_STADDR0);
+	}
+	if (NAND_CS == 1) {
+		au_writel(NAND_STCFG,  MEM_STCFG1);
+		au_writel(NAND_STTIME, MEM_STTIME1);
+		au_writel(NAND_STADDR, MEM_STADDR1);
+	}
+	if (NAND_CS == 2) {
+		au_writel(NAND_STCFG,  MEM_STCFG2);
+		au_writel(NAND_STTIME, MEM_STTIME2);
+		au_writel(NAND_STADDR, MEM_STADDR2);
+	}
+	if (NAND_CS == 3) {
+		au_writel(NAND_STCFG,  MEM_STCFG3);
+		au_writel(NAND_STTIME, MEM_STTIME3);
+		au_writel(NAND_STADDR, MEM_STADDR3);
+	}
+#endif
+ 
+	/* Locate NAND chip-select in order to determine NAND phys address */
+	mem_staddr = 0x00000000;
+	if (((au_readl(MEM_STCFG0) & 0x7) == 0x5) && (NAND_CS == 0))
+		mem_staddr = au_readl(MEM_STADDR0);
+	else if (((au_readl(MEM_STCFG1) & 0x7) == 0x5) && (NAND_CS == 1))
+		mem_staddr = au_readl(MEM_STADDR1);
+	else if (((au_readl(MEM_STCFG2) & 0x7) == 0x5) && (NAND_CS == 2))
+		mem_staddr = au_readl(MEM_STADDR2);
+	else if (((au_readl(MEM_STCFG3) & 0x7) == 0x5) && (NAND_CS == 3))
+		mem_staddr = au_readl(MEM_STADDR3);
+
+	if (mem_staddr == 0x00000000) {
+		printk("Au1xxx NAND: ERROR WITH NAND CHIP-SELECT\n");
+		kfree(au1550_mtd);
+		return 1;
+	}
+	nand_phys = (mem_staddr << 4) & 0xFFFC0000;
+
+	p_nand = (void __iomem *)ioremap(nand_phys, 0x1000);
+
+	/* make controller and MTD agree */
+	if (NAND_CS == 0)
+		nand_width = au_readl(MEM_STCFG0) & (1<<22);
+	if (NAND_CS == 1)
+		nand_width = au_readl(MEM_STCFG1) & (1<<22);
+	if (NAND_CS == 2)
+		nand_width = au_readl(MEM_STCFG2) & (1<<22);
+	if (NAND_CS == 3)
+		nand_width = au_readl(MEM_STCFG3) & (1<<22);
 
-	p_nand = ioremap(NAND_PHYS_ADDR, 0x1000);
 
 	/* Set address of hardware control function */
 	this->hwcontrol = au1550_hwcontrol;
@@ -438,7 +462,7 @@
 	}
 
 	/* Register the partitions */
-	add_mtd_partitions(au1550_mtd, partition_info, NUM_PARTITIONS);
+	add_mtd_partitions(au1550_mtd, partition_info, NB_OF(partition_info));
 
 	return 0;
 
@@ -450,7 +474,7 @@
 	return retval;
 }
 
-module_init(au1550_init);
+module_init(au1xxx_nand_init);
 
 /*
  * Clean up routine
diff -Naur linux-2.6.14/drivers/mtd/nand/Kconfig linux-mips-2.6.14.orig/drivers/mtd/nand/Kconfig
--- linux-2.6.14/drivers/mtd/nand/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/mtd/nand/Kconfig	2005-11-17 11:43:09.000000000 -0800
@@ -59,8 +59,8 @@
 	tristate
 
 config MTD_NAND_AU1550
-	tristate "Au1550 NAND support"
-	depends on SOC_AU1550 && MTD_NAND
+	tristate "Au1550/1200 NAND support"
+	depends on (SOC_AU1200 || SOC_AU1550) && MTD_NAND
 	help
 	  This enables the driver for the NAND flash controller on the
 	  AMD/Alchemy 1550 SOC.
diff -Naur linux-2.6.14/drivers/net/au1000_eth.c linux-mips-2.6.14.orig/drivers/net/au1000_eth.c
--- linux-2.6.14/drivers/net/au1000_eth.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/au1000_eth.c	2005-11-17 11:43:09.000000000 -0800
@@ -32,6 +32,7 @@
  * 
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -151,13 +152,6 @@
 	SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | \
 	SUPPORTED_Autoneg
 
-static char *phy_link[] = 
-{	"unknown", 
-	"10Base2", "10BaseT", 
-	"AUI",
-	"100BaseT", "100BaseTX", "100BaseFX"
-};
-
 int bcm_5201_init(struct net_device *dev, int phy_addr)
 {
 	s16 data;
@@ -785,6 +779,7 @@
 	{"Broadcom BCM5201 10/100 BaseT PHY",0x0040,0x6212, &bcm_5201_ops,0},
 	{"Broadcom BCM5221 10/100 BaseT PHY",0x0040,0x61e4, &bcm_5201_ops,0},
 	{"Broadcom BCM5222 10/100 BaseT PHY",0x0040,0x6322, &bcm_5201_ops,1},
+	{"NS DP83847 PHY", 0x2000, 0x5c30, &bcm_5201_ops ,0},
 	{"AMD 79C901 HomePNA PHY",0x0000,0x35c8, &am79c901_ops,0},
 	{"AMD 79C874 10/100 BaseT PHY",0x0022,0x561b, &am79c874_ops,0},
 	{"LSI 80227 10/100 BaseT PHY",0x0016,0xf840, &lsi_80227_ops,0},
@@ -1045,7 +1040,7 @@
 #endif
 
 	if (aup->mii->chip_info == NULL) {
-		printk(KERN_ERR "%s: Au1x No MII transceivers found!\n",
+		printk(KERN_ERR "%s: Au1x No known MII transceivers found!\n",
 				dev->name);
 		return -1;
 	}
@@ -1546,6 +1541,9 @@
 		printk(KERN_ERR "%s: out of memory\n", dev->name);
 		goto err_out;
 	}
+	aup->mii->next = NULL;
+	aup->mii->chip_info = NULL;
+	aup->mii->status = 0;
 	aup->mii->mii_control_reg = 0;
 	aup->mii->mii_data_reg = 0;
 
diff -Naur linux-2.6.14/drivers/net/big_sur_ge.c linux-mips-2.6.14.orig/drivers/net/big_sur_ge.c
--- linux-2.6.14/drivers/net/big_sur_ge.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/big_sur_ge.c	2005-11-17 11:43:09.000000000 -0800
@@ -0,0 +1,2005 @@
+/*
+ * drivers/net/big_sur_ge.c - Driver for PMC-Sierra Big Sur ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+/*************************************************************************
+ * Description :
+ *
+ * The driver has three modes of operation: FIFO non-DMA, Simple DMA
+ * and SG DMA. There is also a Polled mode and an Interrupt mode of
+ * operation. SG DMA should do zerocopy and check offload. Probably,
+ * zerocopy on the Rx might also work. Simple DMA is the non-zerocpy
+ * case on the Tx and the Rx.
+ *
+ * We turn on Simple DMA and interrupt mode. Although, support has been
+ * added for the SG mode also but not for the polled mode. This is a
+ * Fast Ethernet driver although there will be support for Gigabit soon.
+ *
+ * The driver is divided into two parts: Hardware dependent and a
+ * Hardware independent. There is currently no support for checksum offload
+ * zerocopy and Rx NAPI. There is support for Interrupt Mitigation.
+ ****************************************************************************/
+
+/*************************************************************
+ * Hardware Indepenent Part of the driver
+ *************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "big_sur_ge.h"
+
+#define TX_TIMEOUT (60*HZ)	/* Transmission timeout is 60 seconds. */
+
+static struct net_device *dev_list = NULL;
+static DEFINE_SPINLOCK(dev_lock);
+
+typedef enum DUPLEX { UNKNOWN, HALF_DUPLEX, FULL_DUPLEX } DUPLEX;
+
+/* Big Sur Ethernet MAC structure */
+struct big_sur_ge_enet {
+	struct net_device_stats stats;	/* Statistics for this device */
+	struct net_device *next_dev;	/* The next device in dev_list */
+	struct timer_list phy_timer;	/* PHY monitoring timer */
+	u32 index;		/* Which interface is this */
+	u32 save_base_address;	/* Saved physical base address */
+	struct sk_buff *saved_skb;	/* skb being transmitted */
+	spinlock_t lock;	/* For atomic access to saved_skb */
+	u8 mii_addr;		/* The MII address of the PHY */
+	big_sur_ge emac;	/* GE driver structure */
+};
+
+/* Manish : For testing purposes only */
+static unsigned char big_sur_mac_addr_base[6] = "00:11:22:33:44:55";
+
+/*********************************************************************
+ * Function Prototypes (whole bunch of them)
+ *********************************************************************/
+unsigned long big_sur_ge_dma_control(xdma_channel *);
+void big_sur_ge_dma_reset(xdma_channel *);
+static void handle_fifo_intr(big_sur_ge *);
+void big_sur_ge_check_fifo_recv_error(big_sur_ge *);
+void big_sur_ge_check_fifo_send_error(big_sur_ge *);
+static int big_sur_ge_config_fifo(big_sur_ge *);
+big_sur_ge_config *big_sur_ge_lookup_config(unsigned int);
+static int big_sur_ge_config_dma(big_sur_ge *);
+void big_sur_ge_enet_reset(big_sur_ge *);
+void big_sur_ge_check_mac_error(big_sur_ge *, unsigned long);
+
+/*********************************************************************
+ * DMA Channel Initialization
+ **********************************************************************/
+static int big_sur_ge_dma_init(xdma_channel * dma, unsigned long base_address)
+{
+	dma->reg_base_address = base_address;
+	dma->get_ptr = NULL;
+	dma->put_ptr = NULL;
+	dma->commit_ptr = NULL;
+	dma->last_ptr = NULL;
+	dma->total_desc_count = (unsigned long) NULL;
+	dma->active_desc_count = (unsigned long) NULL;
+	dma->ready = 1;		/* DMA channel is ready */
+
+	big_sur_ge_dma_reset(dma);
+
+	return 0;
+}
+
+/*********************************************************************
+ * Is the DMA channel ready yet ?
+ **********************************************************************/
+static int big_sur_ge_dma_ready(xdma_channel * dma)
+{
+	return dma->ready == 1;
+}
+
+/*********************************************************************
+ * Perform the self test on the DMA channel
+ **********************************************************************/
+#define BIG_SUR_GE_CONTROL_REG_RESET_MASK	0x98000000
+
+static int big_sur_ge_dma_self_test(xdma_channel * dma)
+{
+	unsigned long reg_data;
+
+	big_sur_ge_dma_reset(dma);
+
+	reg_data = big_sur_ge_dma_control(dma);
+	if (reg_data != BIG_SUR_GE_CONTROL_REG_RESET_MASK) {
+		printk(KERN_ERR "DMA Channel Self Test Failed \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*********************************************************************
+ * Reset the DMA channel
+ **********************************************************************/
+static void big_sur_ge_dma_reset(xdma_channel * dma)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_RST_REG_OFFSET,
+			 BIG_SUR_GE_RESET_MASK);
+}
+
+/*********************************************************************
+ * Get control of the DMA channel
+ **********************************************************************/
+static unsigned long big_sur_ge_dma_control(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_DMAC_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Set control of the DMA channel
+ **********************************************************************/
+static void big_sur_ge_set_dma_control(xdma_channel * dma, unsigned long control)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address +
+			 BIG_SUR_GE_DMAC_REG_OFFSET, control);
+}
+
+/*********************************************************************
+ * Get the status of the DMA channel
+ *********************************************************************/
+static unsigned long big_sur_ge_dma_status(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_DMAS_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Set the interrupt status of the DMA channel
+ *********************************************************************/
+static void big_sur_ge_set_intr_status(xdma_channel * dma, unsigned long status)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_IS_REG_OFFSET,
+			 status);
+}
+
+/*********************************************************************
+ * Get the interrupt status of the DMA channel
+ *********************************************************************/
+static unsigned long big_sur_ge_get_intr_status(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_IS_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Set the Interrupt Enable
+ *********************************************************************/
+static void big_sur_ge_set_intr_enable(xdma_channel * dma, unsigned long enable)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_IE_REG_OFFSET,
+			 enable);
+}
+
+/*********************************************************************
+ * Get the Interrupt Enable field to make a check
+ *********************************************************************/
+static unsigned long big_sur_ge_get_intr_enable(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_IE_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Transfer the data over the DMA channel
+ *********************************************************************/
+static void big_sur_ge_dma_transfer(xdma_channel * dma, unsigned long *source,
+			     unsigned long *dest, unsigned long length)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_SA_REG_OFFSET,
+			 (unsigned long) source);
+
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_DA_REG_OFFSET,
+			 (unsigned long) dest);
+
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_LEN_REG_OFFSET,
+			 length);
+}
+
+/*********************************************************************
+ * Get the DMA descriptor
+ *********************************************************************/
+static int big_sur_ge_get_descriptor(xdma_channel * dma,
+			      xbuf_descriptor ** buffer_desc)
+{
+	unsigned long reg_data;
+
+	reg_data = xbuf_descriptor_GetControl(dma->get_ptr);
+	xbuf_descriptor_SetControl(dma->get_ptr, reg_data |
+				   BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+	*buffer_desc = dma->get_ptr;
+
+	dma->get_ptr = xbuf_descriptor_GetNextPtr(dma->get_ptr);
+	dma->active_desc_count--;
+
+	return 0;
+}
+
+/*********************************************************************
+ * Get the packet count
+ *********************************************************************/
+static int big_sur_ge_get_packet_count(xdma_channel * dma)
+{
+	return (BIG_SUR_GE_READ
+		(dma->reg_base_address + BIG_SUR_GE_UPC_REG_OFFSET));
+}
+
+/*********************************************************************
+ * Descrement the packet count
+ *********************************************************************/
+static void big_sur_ge_decr_packet_count(xdma_channel * dma)
+{
+	unsigned long reg_data;
+
+	reg_data =
+	    BIG_SUR_GE_READ(dma->base_address + BIG_SUR_GE_UPC_REG_OFFSET);
+	if (reg_data > 0)
+		BIG_SUR_GE_WRITE(dma->base_address +
+				 BIG_SUR_GE_UPC_REG_OFFSET, 1);
+}
+
+/****************************************************************************
+ * Start of the code that deals with the Packet Fifo
+ *****************************************************************************/
+
+/****************************************************************************
+ * Init the packet fifo
+ ****************************************************************************/
+static int packet_fifo_init(packet_fifo * fifo, u32 reg, u32 data)
+{
+	fifo->reg_base_addr = reg;
+	fifo->data_base_address = data;
+	fifo->ready_status = 1;
+
+	BIG_SUR_GE_FIFO_RESET(fifo);
+
+	return 0;
+}
+
+/****************************************************************************
+ * Packet fifo self test
+ ****************************************************************************/
+static int packet_fifo_self_test(packet_fifo * fifo, unsigned long type)
+{
+	unsigned long reg_data;
+
+	BIG_SUR_GE_FIFO_RESET(fifo);
+	reg_data =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_COUNT_STATUS_REG_OFFSET);
+
+	if (type == BIG_SUR_GE_READ_FIFO_TYPE) {
+		if (reg_data != BIG_SUR_GE_EMPTY_FULL_MASK) {
+			printk(KERN_ERR "Read FIFO not empty \n");
+			return -1;
+		}
+	} else if (!(reg_data & BIG_SUR_GE_EMPTY_FULL_MASK)) {
+		printk(KERN_ERR "Write FIFO is full \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/****************************************************************************
+ * Packet FIFO read
+ ****************************************************************************/
+static int packet_fifo_read(packet_fifo * fifo, u8 * buffer, unsigned int len)
+{
+	unsigned long fifo_count, word_count, extra_byte;
+	unsigned long *buffer_data = (unsigned long *) buffer;
+
+	fifo_count =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT);
+	fifo_count &= BIG_SUR_GE_COUNT_MASK;
+
+	if ((fifo_count * BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT) < len)
+		return -1;
+
+	word_count = len / BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+	extra_byte = len % BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+
+	for (fifo_count = 0; fifo_count < word_count; fifo_count++)
+		buffer_data[fifo_count] =
+		    BIG_SUR_GE_READ(fifo->reg_base_addr);
+
+	if (extra_byte > 0) {
+		unsigned long last_word;
+		int *extra_buffer_data =
+		    (int *) (buffer_data + word_count);
+
+		last_word = BIG_SUR_GE_READ(fifo->data_base_address);
+		if (extra_byte == 1)
+			extra_buffer_data[0] = (int) (last_word << 24);
+		else if (extra_byte == 2) {
+			extra_buffer_data[0] = (int) (last_word << 24);
+			extra_buffer_data[1] = (int) (last_word << 16);
+		} else if (extra_byte == 3) {
+			extra_buffer_data[0] = (int) (last_word << 24);
+			extra_buffer_data[1] = (int) (last_word << 16);
+			extra_buffer_data[2] = (int) (last_word << 8);
+		}
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Write the data into the packet fifo
+ *****************************************************************************/
+static int packet_fifo_write(packet_fifo * fifo, int *buffer, int len)
+{
+	unsigned long fifo_count, word_count, extra_byte;
+	unsigned long *buffer_data = (unsigned long *) buffer;
+
+	fifo_count =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT);
+	fifo_count &= BIG_SUR_GE_COUNT_MASK;
+
+	word_count = len / BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+	extra_byte = len % BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+
+	/* You should see what the ppc driver does here. It just slobbers */
+	if (extra_byte > 0)
+		if (fifo_count > (word_count + 1)) {
+			printk(KERN_ERR
+			       "No room in the packet send fifo \n");
+			return -1;
+		}
+
+	for (fifo_count = 0; fifo_count < word_count; fifo_count++)
+		BIG_SUR_GE_WRITE(fifo->data_base_address,
+				 buffer_data[fifo_count]);
+
+
+	if (extra_byte > 0) {
+		unsigned long last_word = 0;
+		int *extra_buffer_data =
+		    (int *) (buffer_data + word_count);
+
+		if (extra_byte == 1)
+			last_word = extra_buffer_data[0] << 24;
+		else if (extra_byte == 2)
+			last_word = (extra_buffer_data[0] << 24 |
+				     extra_buffer_data[1] << 16);
+
+		else if (extra_byte == 3)
+			last_word = (extra_buffer_data[0] << 24 |
+				     extra_buffer_data[1] << 16 |
+				     extra_buffer_data[2] << 8);
+
+
+		BIG_SUR_GE_WRITE(fifo->data_base_address, last_word);
+	}
+
+	return 0;
+}
+
+
+/*****************************************************************************
+ * Interrupt handlers: We handle any errors associated with the FIFO.
+ * FIFO is for simple dma case and we do want to handle the simple DMA
+ * case. We dont handle the Scatter Gather DMA for now since it is not working.
+ ******************************************************************************/
+
+/*********************************************************************************
+ * FIFO send for Simple DMA with Interrupts
+ **********************************************************************************/
+static int big_sur_ge_enet_fifo_send(big_sur_ge * emac, u8 * buffer,
+			      unsigned long byte_cnt)
+{
+	unsigned long int_status, reg_data;
+
+	/* Silly checks here that we really dont need */
+	if (!emac->started)
+		return -1;
+
+	if (emac->polled)
+		return -1;
+
+	if (emac->dma_sg)
+		return -1;
+
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	if (int_status & BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK) {
+		printk(KERN_ERR "Tx FIFO error: Queue is Full \n");
+		return -1;
+	}
+
+	/*
+	 * Write the data to the FIFO in the hardware
+	 */
+	if ((BIG_SUR_GE_GET_COUNT(&emac->send_fifo) *
+	     sizeof(unsigned long)) < byte_cnt) {
+		printk(KERN_ERR "Send FIFO on chip is full \n");
+		return -1;
+	}
+
+	if (big_sur_ge_dma_status(&emac->send_channel) &
+	    BIG_SUR_GE_DMASR_BUSY_MASK) {
+		printk(KERN_ERR "Send channel FIFO engine busy \n");
+		return -1;
+	}
+
+	big_sur_ge_set_dma_control(&emac->send_channel,
+				   BIG_SUR_GE_DMACR_SOURCE_INCR_MASK |
+				   BIG_SUR_GE_DMACR_DEST_LOCAL_MASK |
+				   BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+	big_sur_ge_dma_transfer(&emac->send_channel,
+				(unsigned long *) buffer,
+				(unsigned long *) (emac->base_address +
+						   BIG_SUR_GE_PFIFO_TXDATA_OFFSET),
+				byte_cnt);
+
+	reg_data = big_sur_ge_dma_status(&emac->send_channel);
+	while (reg_data & BIG_SUR_GE_DMASR_BUSY_MASK) {
+		reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+		if (!(reg_data & BIG_SUR_GE_DMASR_BUSY_MASK))
+			break;
+	}
+
+	if ((reg_data & BIG_SUR_GE_DMASR_BUS_ERROR_MASK) ||
+	    (reg_data & BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK)) {
+		printk(KERN_ERR "Send side DMA error \n");
+		return -1;
+	}
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_TPLR_OFFSET,
+			 byte_cnt);
+
+	return 0;
+}
+
+/*************************************************************************
+ * FIFO receive for Simple DMA case
+ *************************************************************************/
+static int big_sur_ge_enet_fifo_recv(big_sur_ge * emac, u8 * buffer,
+			      unsigned long *byte_cnt)
+{
+	unsigned long int_status, reg_data;
+
+	/* Silly checks here that we really dont need */
+	if (!emac->started)
+		return -1;
+
+	if (emac->polled)
+		return -1;
+
+	if (emac->dma_sg)
+		return -1;
+
+	if (*byte_cnt < BIG_SUR_GE_MAX_FRAME_SIZE)
+		return -1;
+
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	if (int_status & BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK) {
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IISR_OFFSET,
+				 BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK);
+		return -1;
+	}
+
+	if (big_sur_ge_dma_status(&emac->recv_channel) &
+	    BIG_SUR_GE_DMASR_BUSY_MASK) {
+		printk(KERN_ERR "Rx side DMA Engine busy \n");
+		return -1;
+	}
+
+	if (BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_RPLR_OFFSET) ==
+	    0) {
+		printk(KERN_ERR "MAC has the FIFO packet length 0 \n");
+		return -1;
+	}
+
+	/* For the simple DMA case only */
+	big_sur_ge_set_dma_control(&emac->recv_channel,
+				   BIG_SUR_GE_DMACR_DEST_INCR_MASK |
+				   BIG_SUR_GE_DMACR_SOURCE_LOCAL_MASK |
+				   BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+	if (packet_fifo_read(&emac->recv_fifo, buffer,
+			     BIG_SUR_GE_READ(emac->base_address +
+					     BIG_SUR_GE_RPLR_OFFSET)) ==
+	    -1) {
+		printk(KERN_ERR "Not enough space in the FIFO \n");
+		return -1;
+	}
+
+	big_sur_ge_dma_transfer(&emac->recv_channel,
+				(unsigned long *) (emac->base_address +
+						   BIG_SUR_GE_PFIFO_RXDATA_OFFSET),
+				(unsigned long *)
+				buffer,
+				BIG_SUR_GE_READ(emac->base_address +
+						BIG_SUR_GE_RPLR_OFFSET));
+
+	reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+	while (reg_data & BIG_SUR_GE_DMASR_BUSY_MASK) {
+		reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+		if (!(reg_data & BIG_SUR_GE_DMASR_BUSY_MASK))
+			break;
+	}
+
+	if ((reg_data & BIG_SUR_GE_DMASR_BUS_ERROR_MASK) ||
+	    (reg_data & BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK)) {
+		printk(KERN_ERR "DMA Bus Error \n");
+		return -1;
+	}
+
+	*byte_cnt =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_RPLR_OFFSET);
+
+	return 0;
+}
+
+static irqreturn_t big_sur_ge_int_handler(int irq, void *dev_id,
+				   struct pt_regs *regs)
+{
+	struct net_device *netdev = dev_id;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	big_sur_ge *emac = (big_sur_ge *)emac_ptr;
+	void *emac_ptr = &lp->emac;
+	unsigned long int_status;
+
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_DIPR_OFFSET);
+	if (int_status & BIG_SUR_GE_IPIF_EMAC_MASK)
+		handle_fifo_intr(emac);
+
+	if (int_status & BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+		big_sur_ge_check_fifo_recv_error(emac);
+
+	if (int_status & BIG_SUR_GE_IPIF_SEND_FIFO_MASK)
+		big_sur_ge_check_fifo_send_error(emac);
+
+	if (int_status & XIIF_V123B_ERROR_MASK)
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_DISR_OFFSET,
+				 XIIF_V123B_ERROR_MASK);
+
+	return IRQ_HANDLED;
+}
+
+/****************************************************************************
+ * Set the FIFO send handler
+ ***************************************************************************/
+static void big_sur_ge_set_fifo_send_handler(big_sur_ge * emac, void *call_back,
+				      big_sur_fifo_handler function)
+{
+	emac->big_sur_ge_fifo_send_handler = function;
+	emac->fifo_send_ref = call_back;
+}
+
+/****************************************************************************
+ * Set the FIFO recv handler
+ ***************************************************************************/
+static void big_sur_ge_set_fifo_recv_handler(big_sur_ge * emac, void *call_back,
+				      big_sur_fifo_handler function)
+{
+	emac->big_sur_ge_fifo_recv_handler = function;
+	emac->fifo_recv_ref = call_back;
+}
+
+/****************************************************************************
+ * Main Fifo intr handler
+ ***************************************************************************/
+static void handle_fifo_intr(big_sur_ge * emac)
+{
+	unsigned long int_status;
+
+	/* Ack the interrupts asap */
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IISR_OFFSET,
+			 int_status);
+
+	/* Process the Rx side */
+	if (int_status & BIG_SUR_GE_EIR_RECV_DONE_MASK) {
+		emac->big_sur_ge_fifo_recv_handler(&emac->fifo_recv_ref);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IISR_OFFSET,
+				 BIG_SUR_GE_EIR_RECV_DONE_MASK);
+	}
+
+	if (int_status & BIG_SUR_GE_EIR_XMIT_DONE_MASK) {
+		/* We dont collect stats and hence we dont need to get status */
+
+		emac->big_sur_ge_fifo_send_handler(emac->fifo_recv_ref);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IISR_OFFSET,
+				 BIG_SUR_GE_EIR_XMIT_DONE_MASK);
+	}
+
+	big_sur_ge_check_mac_error(emac, int_status);
+}
+
+/******************************************************************
+ * Handle the Receive side DMA interrupts. The PPC driver has
+ * callbacks all over the place. This has been eliminated here by
+ * using the following approach:
+ *
+ * The ISR is set to the main interrrupt handler. This will handle
+ * all the interrupts including the ones for DMA. In this main isr,
+ * we determine if we need to call recv or send side intr functions.
+ * Pretty complex but thats the way it is now.
+ *******************************************************************/
+static void big_sur_ge_handle_recv_intr(big_sur_ge * emac)
+{
+	unsigned long int_status;
+
+	int_status = big_sur_ge_get_intr_status(&emac->recv_channel);
+	if (int_status & (BIG_SUR_GE_IXR_PKT_THRESHOLD_MASK |
+			  BIG_SUR_GE_IXR_PKT_WAIT_BOUND_MASK)) {
+		u32 num_packets;
+		u32 num_processed;
+		u32 num_buffers;
+		u32 num_bytes;
+		xbuf_descriptor *first_desc_ptr = NULL;
+		xbuf_descriptor *buffer_desc;
+		int is_last = 0;
+
+		/* The number of packets we need to process on the Rx */
+		num_packets =
+		    big_sur_ge_get_packet_count(&emac->recv_channel);
+
+		for (num_processed = 0; num_processed < num_packets;
+		     num_processed++) {
+			while (!is_last) {
+				if (big_sur_ge_get_descriptor
+				    (&emac->recv_channel,
+				     &buffer_desc) == -1)
+					break;
+
+				if (first_desc_ptr == NULL)
+					first_desc_ptr = buffer_desc;
+
+				num_bytes +=
+				    xbuf_descriptor_GetLength(buffer_desc);
+
+				if (xbuf_descriptor_IsLastStatus
+				    (buffer_desc)) {
+					is_last = 1;
+				}
+
+				num_buffers++;
+			}
+
+			/* Number of buffers is always 1 since we dont do SG */
+
+			/*
+			 * Only for SG DMA which is currently not supported. In the
+			 * future, as we have SG channel working, we will code this
+			 * receive side routine. For now, do nothing. This is never
+			 * called from FIFO mode - Manish
+			 */
+			big_sur_ge_decr_packet_count(&emac->recv_channel);
+		}
+	}
+
+	/* Ack the interrupts */
+	big_sur_ge_set_intr_status(&emac->recv_channel, int_status);
+
+	if (int_status & BIG_SUR_GE_IXR_DMA_ERROR_MASK) {
+		/* We need a reset here */
+	}
+
+	big_sur_ge_set_intr_status(&emac->recv_channel, int_status);
+}
+
+/****************************************************************
+ * Handle the send side DMA interrupt
+ ****************************************************************/
+static void big_sur_ge_handle_send_intr(big_sur_ge * emac)
+{
+	unsigned long int_status;
+
+	int_status = big_sur_ge_get_intr_status(&emac->send_channel);
+
+	if (int_status & (BIG_SUR_GE_IXR_PKT_THRESHOLD_MASK |
+			  BIG_SUR_GE_IXR_PKT_WAIT_BOUND_MASK)) {
+		unsigned long num_frames = 0;
+		unsigned long num_processed = 0;
+		unsigned long num_buffers = 0;
+		unsigned long num_bytes = 0;
+		unsigned long is_last = 0;
+		xbuf_descriptor *first_desc_ptr = NULL;
+		xbuf_descriptor *buffer_desc;
+
+		num_frames =
+		    big_sur_ge_get_packet_count(&emac->send_channel);
+
+		for (num_processed = 0; num_processed < num_frames;
+		     num_processed++) {
+			while (!is_last) {
+				if (big_sur_ge_get_descriptor
+				    (&emac->send_channel, &buffer_desc)
+				    == -1) {
+					break;
+				}
+
+				if (first_desc_ptr == NULL)
+					first_desc_ptr = buffer_desc;
+
+				num_bytes +=
+				    xbuf_descriptor_GetLength(buffer_desc);
+				if (xbuf_descriptor_IsLastControl
+				    (buffer_desc))
+					is_last = 1;
+
+				num_buffers++;
+			}
+
+			/*
+			 * Only for SG DMA which is currently not supported. In the
+			 * future, as we have SG channel working, we will code this
+			 * receive side routine. For now, do nothing. This is never
+			 * called from FIFO mode - Manish
+			 */
+			big_sur_ge_decr_packet_count(&emac->send_channel);
+		}
+	}
+
+	/* Ack the interrupts and reset DMA channel if necessary */
+	big_sur_ge_set_intr_status(&emac->send_channel, int_status);
+	if (int_status & BIG_SUR_GE_IXR_DMA_ERROR_MASK) {
+		/* Manish : need reset */
+	}
+
+	big_sur_ge_set_intr_status(&emac->send_channel, int_status);
+}
+
+/*****************************************************************
+ * For now, the MAC address errors dont trigger a update of the
+ * stats. There is no stats framework in place. Hence, we just
+ * check for the errors below and do a reset if needed.
+ *****************************************************************/
+static void big_sur_ge_check_mac_error(big_sur_ge * emac,
+				unsigned long int_status)
+{
+	if (int_status & (BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |
+			  BIG_SUR_GE_EIR_RECV_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |
+			  BIG_SUR_GE_EIR_RECV_COLLISION_MASK |
+			  BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK |
+			  BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK |
+			  BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK)) {
+
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IIER_OFFSET, 0);
+		/*
+		 * Manish Reset the MAC here
+		 */
+	}
+}
+
+/*****************************************************************
+ * Check for FIFO Recv errors
+ *****************************************************************/
+static void big_sur_ge_check_fifo_recv_error(big_sur_ge * emac)
+{
+	if (BIG_SUR_GE_IS_DEADLOCKED(&emac->recv_fifo)) {
+		unsigned long intr_enable;
+
+		intr_enable =
+		    BIG_SUR_GE_READ(emac->base_address +
+				    XIIF_V123B_DIER_OFFSET);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_DIER_OFFSET,
+				 intr_enable &
+				 ~(BIG_SUR_GE_IPIF_RECV_FIFO_MASK));
+
+	}
+}
+
+/*****************************************************************
+ * Check for FIFO Send errors
+ *****************************************************************/
+static void big_sur_ge_check_fifo_send_error(big_sur_ge * emac)
+{
+	if (BIG_SUR_GE_IS_DEADLOCKED(&emac->send_fifo)) {
+		unsigned long intr_enable;
+
+		intr_enable =
+		    BIG_SUR_GE_READ(emac->base_address +
+				    XIIF_V123B_DIER_OFFSET);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_DIER_OFFSET,
+				 intr_enable &
+				 ~(BIG_SUR_GE_IPIF_SEND_FIFO_MASK));
+	}
+}
+
+/*****************************************************************
+ * GE unit init
+ ****************************************************************/
+static int big_sur_ge_enet_init(big_sur_ge * emac, unsigned int device_id)
+{
+	unsigned long reg_data;
+	big_sur_ge_config *config;
+	int err;
+
+	/* Assume that the device has been stopped */
+
+	config = big_sur_ge_lookup_config(device_id);
+	if (config == NULL)
+		return -1;
+
+	emac->ready = 0;
+	emac->started = 0;
+	emac->dma_sg = 0;	/* This MAC has no support for Scatter Gather DMA */
+	emac->has_mii = config->has_mii;
+	emac->has_mcast_hash_table = 0;
+	emac->dma_config = config->dma_config;
+
+	/*
+	 * Initialize the FIFO send and recv handlers to the stub handlers.
+	 * We only deal with the FIFO mode of operation since SG is not supported.
+	 * Also, there is no error handler. We try to handle as much of error as
+	 * possible and then return. No error codes also.
+	 */
+
+	emac->base_address = config->base_address;
+
+	if (big_sur_ge_config_dma(emac) == -1)
+		return -1;
+
+	err = big_sur_ge_config_fifo(emac);
+	if (err == -1)
+		return err;
+
+	/* Now, we know that the FIFO initialized successfully. So, set the ready flag */
+	emac->ready = 1;
+
+	/* Do we need a PHY reset here also. It did cause problems on some boards */
+	big_sur_ge_enet_reset(emac);
+
+	/* PHY reset code. Remove if causes a problem on the board */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &= ~(BIG_SUR_GE_ECR_PHY_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+	reg_data |= BIG_SUR_GE_ECR_PHY_ENABLE_MASK;
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	return 0;
+}
+
+/*******************************************************************
+ * Start the GE unit for Tx, Rx and Interrupts
+ *******************************************************************/
+static int big_sur_ge_start(big_sur_ge * emac)
+{
+	unsigned long reg_data;
+
+	/*
+	 * Basic mode of operation is polled and interrupt mode. We disable the polled
+	 * mode for good. We may use the polled mode for Rx NAPI but that does not
+	 * require all the interrupts to be disabled
+	 */
+
+	emac->polled = 0;
+
+	/*
+	 * DMA: Three modes of operation - simple, FIFO, SG. SG is surely not working
+	 * and so is kept off using the dma_sg flag. Simple and FIFO work. But, we may
+	 * not use FIFO at all. So, we enable the interrupts below
+	 */
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET,
+			 BIG_SUR_GE_IPIF_FIFO_DFT_MASK |
+			 XIIF_V123B_ERROR_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IIER_OFFSET,
+			 BIG_SUR_GE_EIR_DFT_FIFO_MASK);
+
+	/* Toggle the started flag */
+	emac->started = 1;
+
+	/* Start the Tx and Rx units respectively */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &=
+	    ~(BIG_SUR_GE_ECR_XMIT_RESET_MASK |
+	      BIG_SUR_GE_ECR_RECV_RESET_MASK);
+	reg_data |=
+	    (BIG_SUR_GE_ECR_XMIT_ENABLE_MASK |
+	     BIG_SUR_GE_ECR_RECV_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	return 0;
+}
+
+/**************************************************************************
+ * Stop the GE unit
+ **************************************************************************/
+static int big_sur_ge_stop(big_sur_ge * emac)
+{
+	unsigned long reg_data;
+
+	/* We assume that the device is not already stopped */
+	if (!emac->started)
+		return 0;
+
+	/* Disable the Tx and Rx unit respectively */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &=
+	    ~(BIG_SUR_GE_ECR_XMIT_ENABLE_MASK |
+	      BIG_SUR_GE_ECR_RECV_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	/* Disable the interrupts */
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DGIER_OFFSET, 0);
+
+	/* Toggle the started flag */
+	emac->started = 0;
+
+	return 0;
+}
+
+/************************************************************************
+ * Reset the GE MAC unit
+ *************************************************************************/
+static void big_sur_ge_enet_reset(big_sur_ge * emac)
+{
+	unsigned long reg_data;
+
+	(void) big_sur_ge_stop(emac);
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_RESETR_OFFSET,
+			 XIIF_V123B_RESET_MASK);
+
+	/*
+	 * For now, configure the receiver to not strip off FCS and padding since
+	 * this is not currently supported. In the future, just take the default
+	 * and provide the option for the user to change this behavior.
+	 */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &=
+	    ~(BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK |
+	      BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK);
+	reg_data &= ~(BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+}
+
+/*************************************************************************
+ * Set the MAC address of the GE mac unit
+ *************************************************************************/
+static int big_sur_ge_set_mac_address(big_sur_ge * emac, unsigned char *addr)
+{
+	unsigned long mac_addr = 0;
+
+	/* Device is started and so mac address must be set */
+	if (emac->started == 1)
+		return 0;
+
+	mac_addr = ((addr[0] << 8) | addr[1]);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_SAH_OFFSET,
+			 mac_addr);
+
+	mac_addr |= ((addr[2] << 24) | (addr[3] << 16) |
+		     (addr[4] << 8) | addr[5]);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_SAL_OFFSET,
+			 mac_addr);
+
+	return 0;
+}
+
+/****************************************************************************
+ * Get the MAC address of the GE MAC unit
+ ***************************************************************************/
+static void big_sur_ge_get_mac_unit(big_sur_ge * emac, unsigned int *addr)
+{
+	unsigned long mac_addr_hi, mac_addr_lo;
+
+	mac_addr_hi =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_SAH_OFFSET);
+	mac_addr_lo =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_SAL_OFFSET);
+
+	addr[0] = (mac_addr_hi >> 8);
+	addr[1] = mac_addr_hi;
+
+	addr[2] = (mac_addr_lo >> 24);
+	addr[3] = (mac_addr_lo >> 16);
+	addr[4] = (mac_addr_lo >> 8);
+	addr[5] = mac_addr_lo;
+}
+
+/*********************************************************************************
+ * Configure the GE MAC for DMA capabilities. Not for Scatter Gather, only Simple
+ *********************************************************************************/
+static int big_sur_ge_config_dma(big_sur_ge * emac)
+{
+	if (big_sur_ge_dma_init(&emac->recv_channel, emac->base_address +
+				BIG_SUR_GE_DMA_RECV_OFFSET) == -1) {
+		printk(KERN_ERR "Could not initialize the DMA unit  \n");
+		return -1;
+	}
+
+	if (big_sur_ge_dma_init(&emac->send_channel, emac->base_address +
+				BIG_SUR_GE_DMA_SEND_OFFSET) == -1) {
+		printk(KERN_ERR "Could not initialize the DMA unit  \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ * Configure the FIFO for simple DMA
+ ******************************************************************************/
+static int big_sur_ge_config_fifo(big_sur_ge * emac)
+{
+	int err = 0;
+
+	err = packet_fifo_init(&emac->recv_fifo, emac->base_address +
+			       BIG_SUR_GE_PFIFO_RXREG_OFFSET,
+			       emac->base_address +
+			       BIG_SUR_GE_PFIFO_RXDATA_OFFSET);
+
+	if (err == -1) {
+		printk(KERN_ERR
+		       "Could not initialize Rx packet FIFO for Simple DMA \n");
+		return err;
+	}
+
+	err = packet_fifo_init(&emac->send_fifo, emac->base_address +
+			       BIG_SUR_GE_PFIFO_TXREG_OFFSET,
+			       emac->base_address +
+			       BIG_SUR_GE_PFIFO_TXDATA_OFFSET);
+
+	if (err == -1) {
+		printk(KERN_ERR
+		       "Could not initialize Tx packet FIFO for Simple DMA \n");
+	}
+
+	return err;
+}
+
+#define BIG_SUR_GE_NUM_INSTANCES	2
+
+
+/**********************************************************************************
+ * Look up the config of the MAC
+ **********************************************************************************/
+static big_sur_ge_config *big_sur_ge_lookup_config(unsigned int device_id)
+{
+	big_sur_ge_config *config = NULL;
+	int i = 0;
+
+	for (i = 0; i < BIG_SUR_GE_NUM_INSTANCES; i++) {
+		/* Manish : Init the config here */
+		break;
+	}
+
+	return config;
+}
+
+typedef struct {
+	unsigned long option;
+	unsigned long mask;
+} option_map;
+
+static option_map option_table[] = {
+	{BIG_SUR_GE_UNICAST_OPTION, BIG_SUR_GE_ECR_UNICAST_ENABLE_MASK},
+	{BIG_SUR_GE_BROADCAST_OPTION, BIG_SUR_GE_ECR_BROAD_ENABLE_MASK},
+	{BIG_SUR_GE_PROMISC_OPTION, BIG_SUR_GE_ECR_PROMISC_ENABLE_MASK},
+	{BIG_SUR_GE_FDUPLEX_OPTION, BIG_SUR_GE_ECR_FULL_DUPLEX_MASK},
+	{BIG_SUR_GE_LOOPBACK_OPTION, BIG_SUR_GE_ECR_LOOPBACK_MASK},
+	{BIG_SUR_GE_MULTICAST_OPTION, BIG_SUR_GE_ECR_MULTI_ENABLE_MASK},
+	{BIG_SUR_GE_FLOW_CONTROL_OPTION, BIG_SUR_GE_ECR_PAUSE_FRAME_MASK},
+	{BIG_SUR_GE_INSERT_PAD_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_PAD_ENABLE_MASK},
+	{BIG_SUR_GE_INSERT_FCS_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_FCS_ENABLE_MASK},
+	{BIG_SUR_GE_INSERT_ADDR_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_ADDR_INSERT_MASK},
+	{BIG_SUR_GE_OVWRT_ADDR_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_ADDR_OVWRT_MASK},
+	{BIG_SUR_GE_STRIP_PAD_OPTION, BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK},
+	{BIG_SUR_GE_STRIP_FCS_OPTION, BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK},
+	{BIG_SUR_GE_STRIP_PAD_FCS_OPTION,
+	 BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK}
+};
+
+#define BIG_SUR_GE_NUM_OPTIONS		(sizeof(option_table) / sizeof(option_map))
+
+/**********************************************************************
+ * Set the options for the GE
+ **********************************************************************/
+static int big_sur_ge_set_options(big_sur_ge * emac, unsigned long option_flag)
+{
+	unsigned long reg_data;
+	unsigned int index;
+
+	/* Assume that the device is stopped before calling this function */
+
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	for (index = 0; index < BIG_SUR_GE_NUM_OPTIONS; index++) {
+		if (option_flag & option_table[index].option)
+			reg_data |= option_table[index].mask;
+		else
+			reg_data &= ~(option_table[index].mask);
+
+	}
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	/* No polled option */
+	emac->polled = 0;
+
+	return 0;
+}
+
+/*******************************************************
+ * Get the options from the GE
+ *******************************************************/
+static unsigned long big_sur_ge_get_options(big_sur_ge * emac)
+{
+	unsigned long option_flag = 0, reg_data;
+	unsigned int index;
+
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+
+	for (index = 0; index < BIG_SUR_GE_NUM_OPTIONS; index++) {
+		if (option_flag & option_table[index].option)
+			reg_data |= option_table[index].mask;
+	}
+
+	/* No polled mode */
+
+	return option_flag;
+}
+
+/********************************************************
+ * Set the Inter frame gap
+ ********************************************************/
+static int big_sur_ge_set_frame_gap(big_sur_ge * emac, int part1, int part2)
+{
+	unsigned long config;
+
+	/* Assume that the device is stopped before calling this */
+
+	config = ((part1 << BIG_SUR_GE_IFGP_PART1_SHIFT) |
+		  (part2 << BIG_SUR_GE_IFGP_PART2_SHIFT));
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_IFGP_OFFSET,
+			 config);
+
+	return 0;
+}
+
+/********************************************************
+ * Get the Inter frame gap
+ ********************************************************/
+static void big_sur_ge_get_frame_gap(big_sur_ge * emac, int *part1, int *part2)
+{
+	unsigned long config;
+
+	config =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_IFGP_OFFSET);
+	*part1 =
+	    ((config & BIG_SUR_GE_IFGP_PART1_SHIFT) >>
+	     BIG_SUR_GE_IFGP_PART1_SHIFT);
+	*part2 =
+	    ((config & BIG_SUR_GE_IFGP_PART2_SHIFT) >>
+	     BIG_SUR_GE_IFGP_PART2_SHIFT);
+}
+
+/*******************************************************************
+ * PHY specific functions for the MAC
+ *******************************************************************/
+#define BIG_SUR_GE_MAX_PHY_ADDR		32
+#define BIG_SUR_GE_MAX_PHY_REG		32
+
+/*******************************************************************
+ * Read the PHY reg
+ *******************************************************************/
+static int big_sur_ge_phy_read(big_sur_ge * emac, unsigned long addr,
+			unsigned long reg_num, unsigned int *data)
+{
+	unsigned long mii_control, mii_data;
+
+	if (!emac->has_mii)
+		return -1;
+
+	mii_control =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET);
+	if (mii_control & BIG_SUR_GE_MGTCR_START_MASK) {
+		printk(KERN_ERR "PHY busy \n");
+		return -1;
+	}
+
+	mii_control = (addr << BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT);
+	mii_control |= (reg_num << BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT);
+	mii_control |=
+	    (BIG_SUR_GE_MGTCR_RW_NOT_MASK | BIG_SUR_GE_MGTCR_START_MASK |
+	     BIG_SUR_GE_MGTCR_MII_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET,
+			 mii_control);
+
+	while (mii_control & BIG_SUR_GE_MGTCR_START_MASK)
+		if (!(mii_control & BIG_SUR_GE_MGTCR_START_MASK))
+			break;
+
+	mii_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTDR_OFFSET);
+	*data = (unsigned int) mii_data;
+
+	return 0;
+}
+
+/**********************************************************************
+ * Write to the PHY register
+ **********************************************************************/
+static int big_sur_ge_phy_write(big_sur_ge * emac, unsigned long addr,
+			 unsigned long reg_num, unsigned int data)
+{
+	unsigned long mii_control;
+
+	if (!emac->has_mii)
+		return -1;
+
+	mii_control =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET);
+	if (mii_control & BIG_SUR_GE_MGTCR_START_MASK) {
+		printk(KERN_ERR "PHY busy \n");
+		return -1;
+	}
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTDR_OFFSET,
+			 (unsigned long) data);
+
+	mii_control = (addr << BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT);
+	mii_control |= (reg_num << BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT);
+	mii_control |=
+	    (BIG_SUR_GE_MGTCR_START_MASK |
+	     BIG_SUR_GE_MGTCR_MII_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET,
+			 mii_control);
+
+	while (mii_control & BIG_SUR_GE_MGTCR_START_MASK)
+		if (!(mii_control & BIG_SUR_GE_MGTCR_START_MASK))
+			break;
+
+	return 0;
+}
+
+
+
+
+
+
+/********************************************************************
+ * The hardware dependent part of the driver begins here
+ ********************************************************************/
+
+
+/*******************************************************************
+ * Reset the GE system
+ *******************************************************************/
+static void big_sur_ge_reset(struct net_device *netdev, DUPLEX duplex)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+	unsigned long options;
+	int ifcfg1, ifcfg2;
+
+	/* Stop the queue */
+	netif_stop_queue(netdev);
+
+	big_sur_ge_get_frame_gap(&lp->emac, &ifcfg1, &ifcfg2);
+	options = big_sur_ge_get_options(&lp->emac);
+	switch (duplex) {
+	case HALF_DUPLEX:
+		options &= ~(BIG_SUR_GE_FDUPLEX_OPTION);
+		break;
+
+	case FULL_DUPLEX:
+		options |= BIG_SUR_GE_FDUPLEX_OPTION;
+		break;
+
+	case UNKNOWN:
+		break;
+	}
+
+	/* There is no support for SG DMA in a 100 Mpbs NIC */
+
+	big_sur_ge_enet_reset(&lp->emac);
+
+	/* Set the necessary options for the MAC unit */
+	big_sur_ge_set_mac_address(&lp->emac, netdev->dev_addr);
+	big_sur_ge_set_frame_gap(&lp->emac, ifcfg1, ifcfg2);
+	big_sur_ge_set_options(&lp->emac, options);
+
+	(void) big_sur_ge_start(&lp->emac);
+
+	spin_lock_irq(&lp->lock);
+	skb = lp->saved_skb;
+	lp->saved_skb = NULL;
+	spin_unlock_irq(&lp->lock);
+
+	if (skb)
+		dev_kfree_skb(skb);
+
+	/* Wake the queue */
+	netif_wake_queue(netdev);
+}
+
+/********************************************************************
+ * Get the PHY status
+ *******************************************************************/
+static int big_sur_ge_get_phy_status(struct net_device *netdev,
+				     DUPLEX * duplex, int *linkup)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned int reg_data;
+	int err = 0;
+
+	err =
+	    big_sur_ge_phy_read(&lp->emac, lp->mii_addr, MII_BMCR,
+				&reg_data);
+	if (err == -1) {
+		printk(KERN_ERR "%s: Could not read PHY control register",
+		       netdev->name);
+		return err;
+	}
+
+	if (!(reg_data & BMCR_ANENABLE)) {
+		if (reg_data & BMCR_FULLDPLX)
+			*duplex = FULL_DUPLEX;
+		else
+			*duplex = HALF_DUPLEX;
+	} else {
+		unsigned int advertise, partner, neg;
+
+		err =
+		    big_sur_ge_phy_read(&lp->emac, lp->mii_addr,
+					MII_ADVERTISE, &advertise);
+		if (err == -1) {
+			printk(KERN_ERR
+			       "%s: Could not read PHY control register",
+			       netdev->name);
+			return err;
+		}
+
+		err =
+		    big_sur_ge_phy_read(&lp->emac, lp->mii_addr, MII_LPA,
+					&partner);
+		if (err == -1) {
+			printk(KERN_ERR
+			       "%s: Could not read PHY control register",
+			       netdev->name);
+			return err;
+		}
+
+		neg = advertise & partner & ADVERTISE_ALL;
+		if (neg & ADVERTISE_100FULL)
+			*duplex = FULL_DUPLEX;
+		else if (neg & ADVERTISE_100HALF)
+			*duplex = HALF_DUPLEX;
+		else if (neg & ADVERTISE_10FULL)
+			*duplex = FULL_DUPLEX;
+		else
+			*duplex = HALF_DUPLEX;
+
+		err =
+		    big_sur_ge_phy_read(&lp->emac, lp->mii_addr, MII_BMSR,
+					&reg_data);
+		if (err == -1) {
+			printk(KERN_ERR
+			       "%s: Could not read PHY control register",
+			       netdev->name);
+			return err;
+		}
+
+		*linkup = (reg_data & BMSR_LSTATUS) != 0;
+
+	}
+	return 0;
+}
+
+/************************************************************
+ * Poll the MII for duplex and link status
+ ***********************************************************/
+static void big_sur_ge_poll_mii(unsigned long data)
+{
+	struct net_device *netdev = (struct net_device *) data;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+	DUPLEX mac_duplex, phy_duplex;
+	int phy_carrier, netif_carrier;
+
+	if (big_sur_ge_get_phy_status(netdev, &phy_duplex, &phy_carrier) ==
+	    -1) {
+		printk(KERN_ERR "%s: Terminating link monitoring.\n",
+		       netdev->name);
+		return;
+	}
+
+	options = big_sur_ge_get_options(&lp->emac);
+	if (options & BIG_SUR_GE_FDUPLEX_OPTION)
+		mac_duplex = FULL_DUPLEX;
+	else
+		mac_duplex = HALF_DUPLEX;
+
+	if (mac_duplex != phy_duplex) {
+		disable_irq(netdev->irq);
+		big_sur_ge_reset(netdev, phy_duplex);
+		enable_irq(netdev->irq);
+	}
+
+	netif_carrier = netif_carrier_ok(netdev) != 0;
+
+	if (phy_carrier != netif_carrier) {
+		if (phy_carrier) {
+			printk(KERN_INFO "%s: Link carrier restored.\n",
+			       netdev->name);
+			netif_carrier_on(netdev);
+		} else {
+			printk(KERN_INFO "%s: Link carrier lost.\n",
+			       netdev->name);
+			netif_carrier_off(netdev);
+		}
+	}
+
+	/* Set up the timer so we'll get called again in 2 seconds. */
+	lp->phy_timer.expires = jiffies + 2 * HZ;
+	add_timer(&lp->phy_timer);
+}
+
+/**************************************************************
+ * Open the network interface
+ *************************************************************/
+static int big_sur_ge_open(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+	DUPLEX phy_duplex, mac_duplex;
+	int phy_carrier, retval;
+
+	(void) big_sur_ge_stop(&lp->emac);
+
+	if (big_sur_ge_set_mac_address(&lp->emac, netdev->dev_addr) == -1) {
+		printk(KERN_ERR "%s: Could not set MAC address.\n",
+		       netdev->name);
+		return -EIO;
+	}
+
+	options = big_sur_ge_get_options(&lp->emac);
+
+	retval =
+	    request_irq(netdev->irq, &big_sur_ge_int_handler, 0,
+			netdev->name, netdev);
+	if (retval) {
+		printk(KERN_ERR
+		       "%s: Could not allocate interrupt %d.\n",
+		       netdev->name, netdev->irq);
+
+		return retval;
+	}
+
+	if (!
+	    (big_sur_ge_get_phy_status(netdev, &phy_duplex, &phy_carrier)))
+	{
+		if (options & BIG_SUR_GE_FDUPLEX_OPTION)
+			mac_duplex = FULL_DUPLEX;
+		else
+			mac_duplex = HALF_DUPLEX;
+
+		if (mac_duplex != phy_duplex) {
+			switch (phy_duplex) {
+			case HALF_DUPLEX:
+				options &= ~(BIG_SUR_GE_FDUPLEX_OPTION);
+				break;
+			case FULL_DUPLEX:
+				options |= BIG_SUR_GE_FDUPLEX_OPTION;
+				break;
+			case UNKNOWN:
+				break;
+			}
+
+			big_sur_ge_set_options(&lp->emac, options);
+		}
+	}
+
+	if (big_sur_ge_start(&lp->emac) == -1) {
+		printk(KERN_ERR "%s: Could not start device.\n",
+		       netdev->name);
+		free_irq(netdev->irq, netdev);
+		return -EBUSY;
+	}
+
+	netif_start_queue(netdev);
+
+	lp->phy_timer.expires = jiffies + 2 * HZ;
+	lp->phy_timer.data = (unsigned long) netdev;
+	lp->phy_timer.function = &big_sur_ge_poll_mii;
+	add_timer(&lp->phy_timer);
+
+	return 0;
+}
+
+/*********************************************************************
+ * Close the network device interface
+ *********************************************************************/
+static int big_sur_ge_close(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+
+	del_timer_sync(&lp->phy_timer);
+	netif_stop_queue(netdev);
+
+	free_irq(netdev->irq, netdev);
+
+	if (big_sur_ge_stop(&lp->emac) == -1) {
+		printk(KERN_ERR "%s: Could not stop device.\n",
+		       netdev->name);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*********************************************************************
+ * Get the network device stats. For now, do nothing
+ *********************************************************************/
+static struct net_device_stats *big_sur_ge_get_stats(struct net_device
+						     *netdev)
+{
+	/* Do nothing */
+	return (struct net_device_stats *) 0;
+}
+
+/********************************************************************
+ * FIFO send for a packet that needs to be transmitted
+ ********************************************************************/
+static int big_sur_ge_fifo_send(struct sk_buff *orig_skb,
+				struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *new_skb;
+	unsigned int len, align;
+
+	netif_stop_queue(netdev);
+	len = orig_skb->len;
+
+	if (!(new_skb = dev_alloc_skb(len + 4))) {
+		dev_kfree_skb(orig_skb);
+		printk(KERN_ERR
+		       "%s: Could not allocate transmit buffer.\n",
+		       netdev->name);
+		netif_wake_queue(netdev);
+		return -EBUSY;
+	}
+
+	align = 4 - ((unsigned long) new_skb->data & 3);
+	if (align != 4)
+		skb_reserve(new_skb, align);
+
+	skb_put(new_skb, len);
+	memcpy(new_skb->data, orig_skb->data, len);
+
+	dev_kfree_skb(orig_skb);
+
+	lp->saved_skb = new_skb;
+	if (big_sur_ge_enet_fifo_send(&lp->emac, (u8 *) new_skb->data, len)
+	    == -1) {
+		spin_lock_irq(&lp->lock);
+		new_skb = lp->saved_skb;
+		lp->saved_skb = NULL;
+		spin_unlock_irq(&lp->lock);
+
+		dev_kfree_skb(new_skb);
+		printk(KERN_ERR "%s: Could not transmit buffer.\n",
+		       netdev->name);
+		netif_wake_queue(netdev);
+		return -EIO;
+	}
+	return 0;
+}
+
+/**********************************************************************
+ * Call the fifo send handler
+ **********************************************************************/
+static void big_sur_ge_fifo_send_handler(void *callback)
+{
+	struct net_device *netdev = (struct net_device *) callback;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+
+	spin_lock_irq(&lp->lock);
+	skb = lp->saved_skb;
+	lp->saved_skb = NULL;
+	spin_unlock_irq(&lp->lock);
+
+	if (skb)
+		dev_kfree_skb(skb);
+
+	netif_wake_queue(netdev);
+}
+
+/**********************************************************************
+ * Handle the timeout of the ethernet device
+ **********************************************************************/
+static void big_sur_ge_tx_timeout(struct net_device *netdev)
+{
+	printk
+	    ("%s: Exceeded transmit timeout of %lu ms.	Resetting mac.\n",
+	     netdev->name, TX_TIMEOUT * 1000UL / HZ);
+
+	disable_irq(netdev->irq);
+	big_sur_ge_reset(netdev, UNKNOWN);
+	enable_irq(netdev->irq);
+}
+
+/*********************************************************************
+ * When in FIFO mode, the callback function for packets received
+ *********************************************************************/
+static void big_sur_ge_fifo_recv_handler(void *callback)
+{
+	struct net_device *netdev = (struct net_device *) callback;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+	unsigned long len = BIG_SUR_GE_MAX_FRAME_SIZE;
+	unsigned int align;
+
+	if (!(skb = dev_alloc_skb(len + 4))) {
+		printk(KERN_ERR "%s: Could not allocate receive buffer.\n",
+		       netdev->name);
+		return;
+	}
+
+	align = 4 - ((unsigned long) skb->data & 3);
+	if (align != 4)
+		skb_reserve(skb, align);
+
+	if (big_sur_ge_enet_fifo_recv(&lp->emac, (u8 *) skb->data, &len) ==
+	    -1) {
+		dev_kfree_skb(skb);
+
+		printk(KERN_ERR "%s: Could not receive buffer \n",
+		       netdev->name);
+		netdev->tx_timeout = NULL;
+		big_sur_ge_reset(netdev, UNKNOWN);
+		netdev->tx_timeout = big_sur_ge_tx_timeout;
+	}
+
+	skb_put(skb, len);	/* Tell the skb how much data we got. */
+	skb->dev = netdev;	/* Fill out required meta-data. */
+	skb->protocol = eth_type_trans(skb, netdev);
+
+	netif_rx(skb);		/* Send the packet upstream. */
+}
+
+/*********************************************************************
+ * Set the Multicast Hash list
+ *********************************************************************/
+static void big_sur_ge_set_multicast_hash_list(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+
+	disable_irq(netdev->irq);
+	local_bh_disable();
+
+	(void) big_sur_ge_stop(&lp->emac);
+	options = big_sur_ge_get_options(&lp->emac);
+	options &=
+	    ~(BIG_SUR_GE_PROMISC_OPTION | BIG_SUR_GE_MULTICAST_OPTION);
+
+	/* Do nothing for now */
+
+	(void) big_sur_ge_start(&lp->emac);
+	local_bh_enable();
+	enable_irq(netdev->irq);
+}
+
+/***********************************************************************
+ * IOCTL support
+ ***********************************************************************/
+static int big_sur_ge_ioctl(struct net_device *netdev, struct ifreq *rq,
+			    int cmd)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct mii_ioctl_data *data =
+	    (struct mii_ioctl_data *) &rq->ifr_data;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCDEVPRIVATE:	/* for binary compat, remove in 2.5 */
+		data->phy_id = lp->mii_addr;
+
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+	case SIOCDEVPRIVATE + 1:	/* for binary compat, remove in 2.5 */
+		if (data->phy_id > 31 || data->reg_num > 31)
+			return -ENXIO;
+
+		del_timer_sync(&lp->phy_timer);
+
+		if (big_sur_ge_phy_read(&lp->emac, data->phy_id,
+					data->reg_num,
+					&data->val_out) == -1) {
+			printk(KERN_ERR "%s: Could not read from PHY",
+			       netdev->name);
+			return -EBUSY;
+		}
+
+		lp->phy_timer.expires = jiffies + 2 * HZ;
+		add_timer(&lp->phy_timer);
+
+		return 0;
+
+	case SIOCSMIIREG:	/* Write MII PHY register. */
+	case SIOCDEVPRIVATE + 2:	/* for binary compat, remove in 2.5 */
+		if (data->phy_id > 31 || data->reg_num > 31)
+			return -ENXIO;
+
+		del_timer_sync(&lp->phy_timer);
+
+		if (big_sur_ge_phy_write
+		    (&lp->emac, data->phy_id, data->reg_num,
+		     data->val_in) == -1) {
+			printk(KERN_ERR "%s: Could not write to PHY",
+			       netdev->name);
+			return -EBUSY;
+		}
+
+		lp->phy_timer.expires = jiffies + 2 * HZ;
+		add_timer(&lp->phy_timer);
+
+		return 0;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/*****************************************************************
+ * Get the config from the config table
+ *****************************************************************/
+static big_sur_ge_config *big_sur_ge_get_config(int index)
+{
+	/* Manish */
+	return (big_sur_ge_config *) 0;
+}
+
+/*****************************************************************
+ * Release the network device structure
+ *****************************************************************/
+static void big_sur_ge_remove_head(void)
+{
+	struct net_device *netdev;
+	struct big_sur_ge_enet *lp;
+	big_sur_ge_config *config;
+
+	spin_lock(&dev_lock);
+	netdev = dev_list;
+	lp = netdev->priv;
+
+	spin_unlock(&dev_lock);
+
+	config = big_sur_ge_get_config(lp->index);
+	iounmap((void *) config->base_address);
+	config->base_address = lp->save_base_address;
+
+	if (lp->saved_skb)
+		dev_kfree_skb(lp->saved_skb);
+	kfree(lp);
+
+	unregister_netdev(netdev);
+	kfree(netdev);
+}
+
+/*****************************************************************
+ * Initial Function to probe the network interface
+ *****************************************************************/
+static int __init big_sur_ge_probe(int index)
+{
+	static const unsigned long remap_size =
+	    BIG_SUR_GE_EMAC_0_HIGHADDR - BIG_SUR_GE_EMAC_0_BASEADDR + 1;
+	struct net_device *netdev;
+	struct big_sur_ge_enet *lp;
+	big_sur_ge_config *config;
+	unsigned int irq;
+	unsigned long maddr;
+	goto err;
+
+	switch (index) {
+	case 0:
+		irq = (31 - BIG_SUR_GE_INTC_0_EMAC_0_VEC_ID);
+		break;
+	case 1:
+		irq = (31 - BIG_SUR_GE_INTC_1_EMAC_1_VEC_ID);
+		break;
+	case 2:
+		irq = (31 - BIG_SUR_GE_INTC_2_EMAC_2_VEC_ID);
+		break;
+	default:
+		err = -ENODEV;
+		goto out;
+	}
+
+	config = big_sur_ge_get_config(index);
+	if (!config) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	netdev = alloc_etherdev(sizeof(big_sur_ge_config));
+
+	if (!netdev) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	SET_MODULE_OWNER(netdev);
+
+	netdev->irq = irq;
+
+	lp = (struct big_sur_ge_enet *) netdev->priv;
+	memset(lp, 0, sizeof(struct big_sur_ge_enet));
+	spin_lock_init(&lp->lock);
+	spin_lock(&dev_lock);
+	lp->next_dev = dev_list;
+	dev_list = netdev;
+	spin_unlock(&dev_lock);
+
+	lp->save_base_address = config->base_address;
+	config->base_address =
+	    (unsigned long) ioremap(lp->save_base_address, remap_size);
+	if (!config->base_address) {
+		err = -ENOMEM;
+		goto out_unlock;
+	}
+
+	if (big_sur_ge_enet_init(&lp->emac, config->device_id) == -1) {
+		printk(KERN_ERR "%s: Could not initialize device.\n",
+		       netdev->name);
+		err = -ENODEV;
+		goto out_unmap;
+	}
+
+	/* Manish: dev_addr value */
+	memcpy(netdev->dev_addr, big_sur_mac_addr_base, 6);
+	if (big_sur_ge_set_mac_address(&lp->emac, netdev->dev_addr) == -1) {
+		printk(KERN_ERR "%s: Could not set MAC address.\n",
+		       netdev->name);
+		err = -EIO;
+		goto out_unmap;
+	}
+
+	/*
+	 * There is no Scatter Gather support but there is a Simple DMA support
+	 */
+	big_sur_ge_set_fifo_recv_handler(&lp->emac, netdev,
+					 big_sur_ge_fifo_recv_handler);
+	big_sur_ge_set_fifo_send_handler(&lp->emac, netdev,
+					 big_sur_ge_fifo_send_handler);
+	netdev->hard_start_xmit = big_sur_ge_fifo_send;
+
+	lp->mii_addr = 0xFF;
+
+	for (maddr = 0; maddr < 31; maddr++) {
+		unsigned int reg_data;
+
+		if (big_sur_ge_phy_read
+		    (&lp->emac, maddr, MII_BMCR, &reg_data) == 0) {
+			lp->mii_addr = maddr;
+			break;
+		}
+	}
+
+	if (lp->mii_addr == 0xFF) {
+		lp->mii_addr = 0;
+		printk(KERN_WARNING
+		       "%s: No PHY detected.  Assuming a PHY at address %d.\n",
+		       netdev->name, lp->mii_addr);
+	}
+
+	netdev->open = big_sur_ge_open;
+	netdev->stop = big_sur_ge_close;
+	netdev->get_stats = big_sur_ge_get_stats;	/* Does nothing */
+	netdev->do_ioctl = big_sur_ge_ioctl;
+	netdev->tx_timeout = big_sur_ge_tx_timeout;
+	netdev->watchdog_timeo = TX_TIMEOUT;
+
+	err = register_netdev(netdev))
+	if (!err)
+		goto out_unmap;
+
+	printk(KERN_INFO "%s: PMC-Sierra Big Sur Ethernet Device %d  at 0x%08X "
+	       "mapped to 0x%08X, irq=%d\n", netdev->name, index,
+	       lp->save_base_address, config->base_address, netdev->irq);
+
+	return ret;
+
+out_unmap:
+	iounmap(config->base_address);
+
+out_unlock:
+	big_sur_ge_remove_head();
+
+out:
+	return ret;
+}
+
+static int __init big_sur_ge_init(void)
+{
+	int index = 0;
+
+	while (big_sur_ge_probe(index++) == 0);
+
+	return (index > 1) ? 0 : -ENODEV;
+}
+
+static void __exit big_sur_ge_cleanup(void)
+{
+	while (dev_list)
+		big_sur_ge_remove_head();
+}
+
+module_init(big_sur_ge_init);
+module_exit(big_sur_ge_cleanup);
+
+MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
+MODULE_DESCRIPTION("PMC-Sierra Big Sur Ethernet MAC Driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/drivers/net/big_sur_ge.h linux-mips-2.6.14.orig/drivers/net/big_sur_ge.h
--- linux-2.6.14/drivers/net/big_sur_ge.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/big_sur_ge.h	2005-11-17 11:43:09.000000000 -0800
@@ -0,0 +1,713 @@
+/*
+ * drivers/net/big_sur_ge.h - Driver for PMC-Sierra Big Sur
+ * ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef	__BIG_SUR_GE_H__
+#define	__BIG_SUR_GE_H__
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#define	BIG_SUR_DEVICE_NAME	"big sur"
+#define	BIG_SUR_DEVICE_DESC	"Big Sur Ethernet 10/100 MAC"
+
+#define BIG_SUR_GE_BASE			0xbb000000
+
+#define	BIG_SUR_GE_WRITE(ofs,data)	*(volatile u32 *)(BIG_SUR_GE_BASE+(ofs)) = data
+
+#define	BIG_SUR_GE_READ(ofs)		*(volatile u32 *)(BIG_SUR_GE_BASE+(ofs))
+
+/* Manish : Need to fix these defines later */
+#define	BIG_SUR_GE_EMAC_0_HIGHADDR
+#define	BIG_SUR_GE_EMAC_0_BASEADDR
+#define	BIG_SUR_GE_INTC_0_EMAC_0_VEC_ID		1
+#define	BIG_SUR_GE_INTC_1_EMAC_1_VEC_ID		2
+#define	BIG_SUR_GE_INTC_2_EMAC_2_VEC_ID		3
+#define	BIG_SUR_GE_EMAC_0_ERR_COUNT_EXIST
+#define	BIG_SUR_GE_EMAC_0_DMA_PRESENT
+#define	BIG_SUR_GE_EMAC_0_MII_EXIST
+#define	BIG_SUR_GE_OPB_ETHERNET_0_BASEADDR
+#define	BIG_SUR_GE_EMAC_0_DEVICE_ID
+#define	BIG_SUR_GE_OPB_ETHERNET_0_ERR_COUNT_EXIST
+#define	BIG_SUR_GE_OPB_ETHERNET_0_DMA_PRESENT
+#define	BIG_SUR_GE_OPB_ETHERNET_0_MII_EXIST
+#define	BIG_SUR_GE_OPB_ETHERNET_0_DEVICE_ID
+
+#define	BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT	4UL
+/* IPIF specific defines */
+#define XIIF_V123B_DISR_OFFSET     0UL  /* device interrupt status register */
+#define XIIF_V123B_DIPR_OFFSET     4UL  /* device interrupt pending register */
+#define XIIF_V123B_DIER_OFFSET     8UL  /* device interrupt enable register */
+#define XIIF_V123B_DIIR_OFFSET     24UL /* device interrupt ID register */
+#define XIIF_V123B_DGIER_OFFSET    28UL /* device global interrupt enable reg */
+#define XIIF_V123B_IISR_OFFSET     32UL /* IP interrupt status register */
+#define XIIF_V123B_IIER_OFFSET     40UL /* IP interrupt enable register */
+#define XIIF_V123B_RESETR_OFFSET   64UL /* reset register */
+#define XIIF_V123B_RESET_MASK             0xAUL
+#define	XIIF_V123B_ERROR_MASK		0x1UL
+
+/* defines */
+#define BIG_SUR_GE_UNICAST_OPTION        	0x00000001
+#define BIG_SUR_GE_BROADCAST_OPTION      	0x00000002
+#define BIG_SUR_GE_PROMISC_OPTION        	0x00000004
+#define BIG_SUR_GE_FDUPLEX_OPTION        	0x00000008
+#define BIG_SUR_GE_POLLED_OPTION         	0x00000010
+#define BIG_SUR_GE_LOOPBACK_OPTION       	0x00000020
+#define BIG_SUR_GE_FLOW_CONTROL_OPTION   	0x00000080
+#define BIG_SUR_GE_INSERT_PAD_OPTION     	0x00000100
+#define BIG_SUR_GE_INSERT_FCS_OPTION     	0x00000200
+#define BIG_SUR_GE_INSERT_ADDR_OPTION    	0x00000400
+#define BIG_SUR_GE_OVWRT_ADDR_OPTION     	0x00000800
+#define BIG_SUR_GE_STRIP_PAD_FCS_OPTION  	0x00002000
+
+/* Not Supported */
+#define BIG_SUR_GE_MULTICAST_OPTION      	0x00000040
+#define BIG_SUR_GE_FLOW_CONTROL_OPTION   	0x00000080
+#define BIG_SUR_GE_INSERT_PAD_OPTION     	0x00000100
+#define BIG_SUR_GE_INSERT_FCS_OPTION     	0x00000200
+#define BIG_SUR_GE_INSERT_ADDR_OPTION    	0x00000400
+#define BIG_SUR_GE_OVWRT_ADDR_OPTION     	0x00000800
+#define BIG_SUR_GE_STRIP_PAD_OPTION      	0x00001000
+#define BIG_SUR_GE_STRIP_FCS_OPTION     	0x00002000
+
+
+/* Defaults for Interrupt Coalescing in the SG DMA Engine */
+#define BIG_SUR_GE_SGDMA_DFT_THRESHOLD     1   /* Default pkt threshold */
+#define BIG_SUR_GE_SGDMA_MAX_THRESHOLD     255 /* Maximum pkt theshold */
+#define BIG_SUR_GE_SGDMA_DFT_WAITBOUND     5   /* Default pkt wait bound (msec) */
+#define BIG_SUR_GE_SGDMA_MAX_WAITBOUND     1023        /* Maximum pkt wait bound (msec) */
+
+/* Direction */
+#define BIG_SUR_GE_SEND    1
+#define BIG_SUR_GE_RECV    2
+
+/* SG DMA */
+#define BIG_SUR_GE_SGDMA_NODELAY     0 /* start SG DMA immediately */
+#define BIG_SUR_GE_SGDMA_DELAY       1 /* do not start SG DMA */
+
+#define BIG_SUR_GE_CFG_NO_IPIF             0   /* Not supported by the driver */
+#define BIG_SUR_GE_CFG_NO_DMA              1   /* No DMA */
+#define BIG_SUR_GE_CFG_SIMPLE_DMA          2   /* Simple DMA */
+#define BIG_SUR_GE_CFG_DMA_SG              3   /* DMA scatter gather */
+
+#define BIG_SUR_GE_MAC_ADDR_SIZE   6   /* six-byte MAC address */
+#define BIG_SUR_GE_MTU             1500        /* max size of Ethernet frame */
+#define BIG_SUR_GE_HDR_SIZE        14  /* size of Ethernet header */
+#define BIG_SUR_GE_HDR_VLAN_SIZE   18  /* size of Ethernet header with VLAN */
+#define BIG_SUR_GE_TRL_SIZE        4   /* size of Ethernet trailer (FCS) */
+#define BIG_SUR_GE_MAX_FRAME_SIZE  \
+		(BIG_SUR_GE_MTU + BIG_SUR_GE_HDR_SIZE + BIG_SUR_GE_TRL_SIZE)
+
+#define BIG_SUR_GE_MAX_VLAN_FRAME_SIZE  \
+		(BIG_SUR_GE_MTU + BIG_SUR_GE_HDR_VLAN_SIZE + BIG_SUR_GE_TRL_SIZE)
+
+/* Send and Receive buffers */
+#define BIG_SUR_GE_MIN_RECV_BUFS   32  /* minimum # of recv buffers */
+#define BIG_SUR_GE_DFT_RECV_BUFS   64  /* default # of recv buffers */
+
+#define BIG_SUR_GE_MIN_SEND_BUFS   16  /* minimum # of send buffers */
+#define BIG_SUR_GE_DFT_SEND_BUFS   32  /* default # of send buffers */
+
+#define BIG_SUR_GE_MIN_BUFFERS     (BIG_SUR_GE_MIN_RECV_BUFS + BIG_SUR_GE_MIN_SEND_BUFS)
+#define BIG_SUR_GE_DFT_BUFFERS     (BIG_SUR_GE_DFT_RECV_BUFS + BIG_SUR_GE_DFT_SEND_BUFS)
+
+/* Send and Receive Descriptors */
+#define BIG_SUR_GE_MIN_RECV_DESC   16  /* minimum # of recv descriptors */
+#define BIG_SUR_GE_DFT_RECV_DESC   32  /* default # of recv descriptors */
+
+#define BIG_SUR_GE_MIN_SEND_DESC   8   /* minimum # of send descriptors */
+#define BIG_SUR_GE_DFT_SEND_DESC   16  /* default # of send descriptors */
+
+/* FIFO Specific Defines */
+#define BIG_SUR_GE_READ_FIFO_TYPE      0       /* a read FIFO */
+#define BIG_SUR_GE_WRITE_FIFO_TYPE     1       /* a write FIFO */
+#define BIG_SUR_GE_RESET_REG_OFFSET            0UL
+#define BIG_SUR_GE_MODULE_INFO_REG_OFFSET      0UL
+#define BIG_SUR_GE_COUNT_STATUS_REG_OFFSET     4UL
+#define BIG_SUR_GE_RESET_FIFO_MASK             0x0000000A
+#define BIG_SUR_GE_COUNT_MASK                  0x0000FFFF
+#define BIG_SUR_GE_DEADLOCK_MASK               0x20000000
+#define BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK      0x40000000
+#define BIG_SUR_GE_EMPTY_FULL_MASK             0x80000000
+
+#define BIG_SUR_GE_FIFO_RESET(fifo)	\
+	BIG_SUR_GE_WRITE((fifo)->reg_base_addr + BIG_SUR_GE_RESET_REG_OFFSET, BIG_SUR_GE_RESET_FIFO_MASK)
+
+#define	BIG_SUR_GE_GET_COUNT(fifo)	\
+	(BIG_SUR_GE_READ((fifo)->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) & 	\
+							BIG_SUR_GE_COUNT_MASK)
+
+#define	BIG_SUR_GE_IS_ALMOST_EMPTY(fifo)	\
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &	\
+							BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK)
+
+#define	BIG_SUR_GE_IS_ALMOST_FULL(fifo)  \
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK)
+
+#define BIG_SUR_GE_IS_EMPTY(fifo)  \
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_EMPTY_FULL_MASK)
+
+#define BIG_SUR_GE_IS_FULL(fifo)  \
+	(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_EMPTY_FULL_MASK)
+
+#define	BIG_SUR_GE_IS_DEADLOCKED(fifo)	\
+	(BIG_SUR_GE_READ((fifo)->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_DEADLOCK_MASK)
+
+/* Device Config */
+typedef struct _big_sur_ge_config {
+	u16		device_id;
+	u32		base_address;
+	u32		has_counters;
+	u32		has_sg_dma;
+	u8		dma_config;
+	u32		has_mii;
+} big_sur_ge_config;
+
+#define BIG_SUR_GE_SIZE_IN_WORDS           10
+typedef unsigned long xbuf_descriptor[BIG_SUR_GE_SIZE_IN_WORDS];
+
+/* Callback Functions */
+typedef void (*big_sur_sg_handler) (void *callback, xbuf_descriptor *desc, u32 num_desc);
+typedef	void (*big_sur_fifo_handler) (void *callback);
+typedef void (*big_sur_irq_handler) (void *instance);
+
+typedef struct _xdma_channel_tag {
+	u32			reg_base_address;
+        u32                     base_address;
+        u32                     ready;
+        xbuf_descriptor         *put_ptr;
+        xbuf_descriptor         *get_ptr;
+        xbuf_descriptor         *commit_ptr;
+        xbuf_descriptor         *last_ptr;
+
+        u32                     total_desc_count;
+        u32                     active_desc_count;
+} xdma_channel;
+
+typedef struct _packet_fifo {
+        u32             reg_base_addr;
+        u32             ready_status;
+        u32             data_base_address;
+} packet_fifo;
+
+
+/* Big Sur GE driver structure */
+typedef struct _big_sur_ge {
+	u32		base_address;
+	u32		started;
+	u32		ready;
+	u32		polled;
+	u32		dma_sg;
+
+	u8		dma_config;
+	u32		has_mii;
+	u32		has_mcast_hash_table;
+
+	/* For the FIFO and simple DMA case only */
+	packet_fifo	recv_fifo;
+	packet_fifo	send_fifo;
+
+	big_sur_fifo_handler	big_sur_ge_fifo_recv_handler;
+	big_sur_fifo_handler	big_sur_ge_fifo_send_handler;
+
+	void	*fifo_send_ref;
+	void	*fifo_recv_ref;	
+
+	/* For SG DMA only */
+	xdma_channel	recv_channel;
+	xdma_channel	send_channel;
+} big_sur_ge;
+
+/* Offset of the MAC registers from the IPIF base address */
+#define BIG_SUR_GE_REG_OFFSET     0x1100UL
+
+/*
+ * Register offsets for the Ethernet MAC. Each register is 32 bits.
+ */
+#define BIG_SUR_GE_EMIR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x0)        /* EMAC Module ID */
+#define BIG_SUR_GE_ECR_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x4)        /* MAC Control */
+#define BIG_SUR_GE_IFGP_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x8)        /* Interframe Gap */
+#define BIG_SUR_GE_SAH_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0xC)        /* Station addr, high */
+#define BIG_SUR_GE_SAL_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x10)       /* Station addr, low */
+#define BIG_SUR_GE_MGTCR_OFFSET  (BIG_SUR_GE_REG_OFFSET + 0x14)       /* MII mgmt control */
+#define BIG_SUR_GE_MGTDR_OFFSET  (BIG_SUR_GE_REG_OFFSET + 0x18)       /* MII mgmt data */
+#define BIG_SUR_GE_RPLR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x1C)       /* Rx packet length */
+#define BIG_SUR_GE_TPLR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x20)       /* Tx packet length */
+#define BIG_SUR_GE_TSR_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x24)       /* Tx status */
+#define BIG_SUR_GE_RMFC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x28)       /* Rx missed frames */
+#define BIG_SUR_GE_RCC_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x2C)       /* Rx collisions */
+#define BIG_SUR_GE_RFCSEC_OFFSET (BIG_SUR_GE_REG_OFFSET + 0x30)       /* Rx FCS errors */
+#define BIG_SUR_GE_RAEC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x34)       /* Rx alignment errors */
+#define BIG_SUR_GE_TEDC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x38)       /* Transmit excess
+                                                         * deferral cnt */
+/*
+ * Register offsets for the IPIF components
+ */
+#define BIG_SUR_GE_ISR_OFFSET           0x20UL /* Interrupt status */
+
+#define BIG_SUR_GE_DMA_OFFSET           0x2300UL
+#define BIG_SUR_GE_DMA_SEND_OFFSET      (BIG_SUR_GE_DMA_OFFSET + 0x0) /* DMA send channel */
+#define BIG_SUR_GE_DMA_RECV_OFFSET      (BIG_SUR_GE_DMA_OFFSET + 0x40)        /* DMA recv channel */
+
+#define BIG_SUR_GE_PFIFO_OFFSET         0x2000UL
+#define BIG_SUR_GE_PFIFO_TXREG_OFFSET   (BIG_SUR_GE_PFIFO_OFFSET + 0x0)       /* Tx registers */
+#define BIG_SUR_GE_PFIFO_RXREG_OFFSET   (BIG_SUR_GE_PFIFO_OFFSET + 0x10)      /* Rx registers */
+#define BIG_SUR_GE_PFIFO_TXDATA_OFFSET  (BIG_SUR_GE_PFIFO_OFFSET + 0x100)     /* Tx keyhole */
+#define BIG_SUR_GE_PFIFO_RXDATA_OFFSET  (BIG_SUR_GE_PFIFO_OFFSET + 0x200)     /* Rx keyhole */
+
+/*
+ * EMAC Module Identification Register (EMIR)
+ */
+#define BIG_SUR_GE_EMIR_VERSION_MASK    0xFFFF0000UL   /* Device version */
+#define BIG_SUR_GE_EMIR_TYPE_MASK       0x0000FF00UL   /* Device type */
+
+/*
+ * EMAC Control Register (ECR)
+ */
+#define BIG_SUR_GE_ECR_FULL_DUPLEX_MASK         0x80000000   /* Full duplex mode */
+#define BIG_SUR_GE_ECR_XMIT_RESET_MASK          0x40000000   /* Reset transmitter */
+#define BIG_SUR_GE_ECR_XMIT_ENABLE_MASK         0x20000000   /* Enable transmitter */
+#define BIG_SUR_GE_ECR_RECV_RESET_MASK          0x10000000   /* Reset receiver */
+#define BIG_SUR_GE_ECR_RECV_ENABLE_MASK         0x08000000   /* Enable receiver */
+#define BIG_SUR_GE_ECR_PHY_ENABLE_MASK          0x04000000   /* Enable PHY */
+#define BIG_SUR_GE_ECR_XMIT_PAD_ENABLE_MASK     0x02000000   /* Enable xmit pad insert */
+#define BIG_SUR_GE_ECR_XMIT_FCS_ENABLE_MASK     0x01000000   /* Enable xmit FCS insert */
+#define BIG_SUR_GE_ECR_XMIT_ADDR_INSERT_MASK    0x00800000   /* Enable xmit source addr insertion */
+#define BIG_SUR_GE_ECR_XMIT_ERROR_INSERT_MASK   0x00400000   /* Insert xmit error */
+#define BIG_SUR_GE_ECR_XMIT_ADDR_OVWRT_MASK     0x00200000   /* Enable xmit source addr overwrite */
+#define BIG_SUR_GE_ECR_LOOPBACK_MASK            0x00100000   /* Enable internal loopback */
+#define BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK     0x00080000   /* Enable recv pad strip */
+#define BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK     0x00040000   /* Enable recv FCS strip */
+#define BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK   0x00080000   /* Enable recv pad/fcs strip */
+#define BIG_SUR_GE_ECR_UNICAST_ENABLE_MASK      0x00020000   /* Enable unicast addr */
+#define BIG_SUR_GE_ECR_MULTI_ENABLE_MASK        0x00010000   /* Enable multicast addr */
+#define BIG_SUR_GE_ECR_BROAD_ENABLE_MASK        0x00008000   /* Enable broadcast addr */
+#define BIG_SUR_GE_ECR_PROMISC_ENABLE_MASK      0x00004000   /* Enable promiscuous mode */
+#define BIG_SUR_GE_ECR_RECV_ALL_MASK            0x00002000   /* Receive all frames */
+#define BIG_SUR_GE_ECR_RESERVED2_MASK           0x00001000   /* Reserved */
+#define BIG_SUR_GE_ECR_MULTI_HASH_ENABLE_MASK   0x00000800   /* Enable multicast hash */
+#define BIG_SUR_GE_ECR_PAUSE_FRAME_MASK         0x00000400   /* Interpret pause frames */
+#define BIG_SUR_GE_ECR_CLEAR_HASH_MASK          0x00000200   /* Clear hash table */
+#define BIG_SUR_GE_ECR_ADD_HASH_ADDR_MASK       0x00000100  /* Add hash table address */
+
+/*
+ * Interframe Gap Register (IFGR)
+ */
+#define BIG_SUR_GE_IFGP_PART1_MASK         0xF8000000        /* Interframe Gap Part1 */
+#define BIG_SUR_GE_IFGP_PART1_SHIFT        27
+#define BIG_SUR_GE_IFGP_PART2_MASK         0x07C00000        /* Interframe Gap Part2 */
+#define BIG_SUR_GE_IFGP_PART2_SHIFT        22
+
+/*
+ * Station Address High Register (SAH)
+ */
+#define BIG_SUR_GE_SAH_ADDR_MASK           0x0000FFFF        /* Station address high bytes */
+
+/*
+ * Station Address Low Register (SAL)
+ */
+#define BIG_SUR_GE_SAL_ADDR_MASK           0xFFFFFFFF        /* Station address low bytes */
+
+/*
+ * MII Management Control Register (MGTCR)
+ */
+#define BIG_SUR_GE_MGTCR_START_MASK        0x80000000        /* Start/Busy */
+#define BIG_SUR_GE_MGTCR_RW_NOT_MASK       0x40000000        /* Read/Write Not (direction) */
+#define BIG_SUR_GE_MGTCR_PHY_ADDR_MASK     0x3E000000        /* PHY address */
+#define BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT    25  /* PHY address shift */
+#define BIG_SUR_GE_MGTCR_REG_ADDR_MASK     0x01F00000        /* Register address */
+#define BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT    20  /* Register addr shift */
+#define BIG_SUR_GE_MGTCR_MII_ENABLE_MASK   0x00080000        /* Enable MII from EMAC */
+#define BIG_SUR_GE_MGTCR_RD_ERROR_MASK     0x00040000        /* MII mgmt read error */
+
+/*
+ * MII Management Data Register (MGTDR)
+ */
+#define BIG_SUR_GE_MGTDR_DATA_MASK         0x0000FFFF        /* MII data */
+
+/*
+ * Receive Packet Length Register (RPLR)
+ */
+#define BIG_SUR_GE_RPLR_LENGTH_MASK        0x0000FFFF        /* Receive packet length */
+
+/*
+ * Transmit Packet Length Register (TPLR)
+ */
+#define BIG_SUR_GE_TPLR_LENGTH_MASK        0x0000FFFF       /* Transmit packet length */
+
+/*
+ * Transmit Status Register (TSR)
+ */
+#define BIG_SUR_GE_TSR_EXCESS_DEFERRAL_MASK 0x80000000       /* Transmit excess deferral */
+#define BIG_SUR_GE_TSR_FIFO_UNDERRUN_MASK   0x40000000       /* Packet FIFO underrun */
+#define BIG_SUR_GE_TSR_ATTEMPTS_MASK        0x3E000000      /* Transmission attempts */
+#define BIG_SUR_GE_TSR_LATE_COLLISION_MASK  0x01000000      /* Transmit late collision */
+
+/*
+ * Receive Missed Frame Count (RMFC)
+ */
+#define BIG_SUR_GE_RMFC_DATA_MASK          0x0000FFFF
+
+/*
+ * Receive Collision Count (RCC)
+ */
+#define BIG_SUR_GE_RCC_DATA_MASK           0x0000FFFF
+/*
+ * Receive FCS Error Count (RFCSEC)
+ */
+#define BIG_SUR_GE_RFCSEC_DATA_MASK        0x0000FFFF
+
+/*
+ * Receive Alignment Error Count (RALN)
+ */
+#define BIG_SUR_GE_RAEC_DATA_MASK          0x0000FFFF
+
+/*
+ * Transmit Excess Deferral Count (TEDC)
+ */
+#define BIG_SUR_GE_TEDC_DATA_MASK          0x0000FFFF
+
+/*
+ * EMAC Interrupt Registers (Status and Enable) masks. These registers are
+ * part of the IPIF IP Interrupt registers
+ */
+#define BIG_SUR_GE_EIR_XMIT_DONE_MASK         0x00000001     /* Xmit complete */
+#define BIG_SUR_GE_EIR_RECV_DONE_MASK         0x00000002     /* Recv complete */
+#define BIG_SUR_GE_EIR_XMIT_ERROR_MASK        0x00000004     /* Xmit error */
+#define BIG_SUR_GE_EIR_RECV_ERROR_MASK        0x00000008     /* Recv error */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_EMPTY_MASK  0x00000010     /* Xmit status fifo empty */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK  0x00000020     /* Recv length fifo empty */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK   0x00000040     /* Xmit length fifo full */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK   0x00000080     /* Recv length fifo overrun */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK  0x00000100     /* Recv length fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK   0x00000200     /* Xmit status fifo overrun */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK  0x00000400     /* Transmit status fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK   0x00000800     /* Transmit length fifo overrun */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK  0x00001000     /* Transmit length fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_PAUSE_MASK        0x00002000     /* Transmit pause pkt received */
+#define BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK   0x00004000     /* Receive data fifo overrun */
+#define BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK 0x00008000     /* Receive missed frame error */
+#define BIG_SUR_GE_EIR_RECV_COLLISION_MASK    0x00010000     /* Receive collision error */
+#define BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK    0x00020000     /* Receive FCS error */
+#define BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK    0x00040000     /* Receive length field error */
+#define BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK  0x00080000     /* Receive short frame error */
+#define BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK   0x00100000     /* Receive long frame error */
+#define BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK  0x00200000     /* Receive alignment error */
+
+#define	BIG_SUR_GE_READ_REG(base_addr, reg_offset)	\
+		BIG_SUR_GE_READ(base_addr + reg_offset)
+
+#define	BIG_SUR_GE_WRITE_REG(base_addr, reg_offset, data)	\
+		 BIG_SUR_GE_WRITE(base_addr + reg_offset, data)
+
+#define BIG_SUR_GE_CONTROL_REG(base_addr, mask)		\
+		BIG_SUR_GE_WRITE(base_addr + BIG_SUR_GE_ECR_OFFSET, mask)
+
+/* Set the MAC Address */
+#define	big_sur_ge_set_mac(base_addr, address)					\
+{										\
+	u32	mac_addr;							\
+										\
+	mac_addr = ((address[0] << 8) | (address[1]);				\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_SAH_OFFSET, mac_address);		\
+										\
+	mac_addr = ((address[2] << 24) | (address[3] << 16) |			\
+			(address[4] << 8) | address[5]);			\
+										\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_SAL_OFFSET, mac_address);		\
+										\
+}										
+
+/* Enable the MAC unit */
+#define	big_sur_ge_mac_enable(base_address)					\
+{										\
+	u32	control;							\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);		\
+	control &= ~(BIG_SUR_GE_ECR_XMIT_RESET_MASK | BIG_SUR_GE_ECR_RECV_RESET_MASK);	\
+	control |= (BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_ENABLE_MASK);	\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);		\
+}
+
+/* Disable the MAC unit */
+#define	big_sur_ge_mac_disable(base_address)					\
+{										\
+	u32	control;							\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);		\
+	control &= ~(BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_ENABLE_MASK);	\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);		\
+}
+
+/* Check if the Tx is done */
+#define	big_sur_ge_tx_done(base_address)						\
+	(BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ISR_OFFSET) & BIG_SUR_GE_EIR_XMIT_DONE_MASK)
+
+
+/* Check if Rx FIFO is empty */
+#define	big_sur_ge_rx_empty(base_address)						\
+	(!(BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ISR_OFFSET) & BIG_SUR_GE_EIR_RECV_DONE_MASK))
+
+/* Reset the MAC PHY */
+#define	big_sur_ge_reset_phy(base_address)						\
+{											\
+	u32	control;								\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);			\
+	control &= ~(BIG_SUR_GE_ECR_PHY_ENABLE_MASK);						\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);			\
+	control |= BIG_SUR_GE_ECR_PHY_ENABLE_MASK;						\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);			\
+}
+
+/* DMA SG defines */
+#define BIG_SUR_GE_CONTROL_LAST_BD_MASK        0x02000000
+#define BIG_SUR_GE_STATUS_LAST_BD_MASK         0x10000000
+#define BIG_SUR_GE_RST_REG_OFFSET      0       /* reset register */
+#define BIG_SUR_GE_MI_REG_OFFSET       0       /* module information register */
+#define BIG_SUR_GE_DMAC_REG_OFFSET     4       /* DMA control register */
+#define BIG_SUR_GE_SA_REG_OFFSET       8       /* source address register */
+#define BIG_SUR_GE_DA_REG_OFFSET       12      /* destination address register */
+#define BIG_SUR_GE_LEN_REG_OFFSET      16      /* length register */
+#define BIG_SUR_GE_DMAS_REG_OFFSET     20      /* DMA status register */
+#define BIG_SUR_GE_BDA_REG_OFFSET      24      /* buffer descriptor address register */
+#define BIG_SUR_GE_SWCR_REG_OFFSET 28  /* software control register */
+#define BIG_SUR_GE_UPC_REG_OFFSET      32      /* unserviced packet count register */
+#define BIG_SUR_GE_PCT_REG_OFFSET      36      /* packet count threshold register */
+#define BIG_SUR_GE_PWB_REG_OFFSET      40      /* packet wait bound register */
+#define BIG_SUR_GE_IS_REG_OFFSET       44      /* interrupt status register */
+#define BIG_SUR_GE_IE_REG_OFFSET       48      /* interrupt enable register */
+
+#define BIG_SUR_GE_RESET_MASK                          0x0000000A
+
+/* Buffer Descriptor Control */
+
+#define BIG_SUR_GE_DEVICE_STATUS_OFFSET    0
+#define BIG_SUR_GE_CONTROL_OFFSET          1
+#define BIG_SUR_GE_SOURCE_OFFSET           2
+#define BIG_SUR_GE_DESTINATION_OFFSET      3
+#define BIG_SUR_GE_LENGTH_OFFSET           4
+#define BIG_SUR_GE_STATUS_OFFSET           5
+#define BIG_SUR_GE_NEXT_PTR_OFFSET         6
+#define BIG_SUR_GE_ID_OFFSET               7
+#define BIG_SUR_GE_FLAGS_OFFSET            8
+#define BIG_SUR_GE_RQSTED_LENGTH_OFFSET    9
+
+#define BIG_SUR_GE_FLAGS_LOCKED_MASK       1
+
+#define	xbuf_descriptor_init(base)				\
+{								\
+	(*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) = 0);		\
+	(*((u32 *)base + BIG_SUR_GE_SOURCE_OFFSET) = 0);        \
+    	(*((u32 *)base + BIG_SUR_GE_DESTINATION_OFFSET) = 0);   \
+    	(*((u32 *)base + BIG_SUR_GE_LENGTH_OFFSET) = 0);        \
+    	(*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET) = 0);        \
+    	(*((u32 *)base + BIG_SUR_GE_DEVICE_STATUS_OFFSET) = 0); \
+    	(*((u32 *)base + BIG_SUR_GE_NEXT_PTR_OFFSET) = 0);      \
+    	(*((u32 *)base + BIG_SUR_GE_ID_OFFSET) = 0);            \
+    	(*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) = 0);         \
+    	(*((u32 *)base + BIG_SUR_GE_RQSTED_LENGTH_OFFSET) = 0); \
+}
+
+#define xbuf_descriptor_GetControl(base)   \
+    (u32)(*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET))
+
+#define xbuf_descriptor_SetControl(base, Control)  \
+    (*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) = (u32)Control)
+
+#define xbuf_descriptor_IsLastControl(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) & \
+               BIG_SUR_GE_CONTROL_LAST_BD_MASK)
+
+#define xbuf_descriptor_SetLast(base) \
+    (*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) |= BIG_SUR_GECONTROL_LAST_BD_MASK)
+
+#define xbuf_descriptor_GetSrcAddress(base) \
+    ((u32 *)(*((u32 *)base + BIG_SUR_GE_SOURCE_OFFSET)))
+
+#define xbuf_descriptor_SetSrcAddress(base, Source) \
+    (*((u32 *)base + BIG_SUR_GE_SOURCE_OFFSET) = (u32)Source)
+
+#define xbuf_descriptor_GetDestAddress(base) \
+    ((u32 *)(*((u32 *)base + BIG_SUR_GE_DESTINATION_OFFSET)))
+
+#define xbuf_descriptor_SetDestAddress(base, Destination) \
+    (*((u32 *)base + BIG_SUR_GE_DESTINATION_OFFSET) = (u32)Destination)
+
+#define xbuf_descriptor_GetLength(base)                           \
+    (u32)(*((u32 *)base + BIG_SUR_GE_RQSTED_LENGTH_OFFSET) -    \
+              *((u32 *)base + BIG_SUR_GE_LENGTH_OFFSET))
+
+#define xbuf_descriptor_SetLength(base, Length)                       \
+{                                                                           \
+    (*((u32 *)base + BIG_SUR_GE_LENGTH_OFFSET) = (u32)(Length));    \
+    (*((u32 *)base + BIG_SUR_GE_RQSTED_LENGTH_OFFSET) = (u32)(Length));\
+}
+
+#define xbuf_descriptor_GetStatus(base)    \
+    (u32)(*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET))
+
+#define xbuf_descriptor_SetStatus(base, Status)    \
+    (*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET) = (u32)Status)
+
+#define xbuf_descriptor_IsLastStatus(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET) & \
+               BIG_SUR_GE_STATUS_LAST_BD_MASK)
+
+#define xbuf_descriptor_GetDeviceStatus(base) \
+    ((u32)(*((u32 *)base + BIG_SUR_GE_DEVICE_STATUS_OFFSET)))
+
+#define xbuf_descriptor_SetDeviceStatus(base, Status) \
+    (*((u32 *)base + BIG_SUR_GE_DEVICE_STATUS_OFFSET) = (u32)Status)
+
+#define xbuf_descriptor_GetNextPtr(base) \
+    (xbuf_descriptor *)(*((u32 *)base + BIG_SUR_GE_NEXT_PTR_OFFSET))
+
+#define xbuf_descriptor_SetNextPtr(base, NextPtr) \
+    (*((u32 *)base + BIG_SUR_GE_NEXT_PTR_OFFSET) = (u32)NextPtr)
+
+#define xbuf_descriptor_GetId(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_ID_OFFSET))
+
+#define xbuf_descriptor_SetId(base, Id) \
+    (*((u32 *)base + BIG_SUR_GE_ID_OFFSET) = (u32)Id)
+
+#define xbuf_descriptor_GetFlags(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET))
+
+#define xbuf_descriptor_SetFlags(base, Flags) \
+    (*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) = (u32)Flags)
+
+#define xbuf_descriptor_Lock(base) \
+    (*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) |= BIG_SUR_GE_FLAGS_LOCKED_MASK)
+
+#define xbuf_descriptor_Unlock(base) \
+    (*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) &= ~BIG_SUR_GE_FLAGS_LOCKED_MASK)
+
+#define xbuf_descriptor_IsLocked(base) \
+	(*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) & BIG_SUR_GE_FLAGS_LOCKED_MASK)
+
+#define BIG_SUR_GE_DMACR_SOURCE_INCR_MASK      0x80000000UL    /* increment source address */
+#define BIG_SUR_GE_DMACR_DEST_INCR_MASK        0x40000000UL    /* increment dest address */
+#define BIG_SUR_GE_DMACR_SOURCE_LOCAL_MASK 0x20000000UL        /* local source address */
+#define BIG_SUR_GE_DMACR_DEST_LOCAL_MASK       0x10000000UL    /* local dest address */
+#define BIG_SUR_GE_DMACR_SG_DISABLE_MASK       0x08000000UL    /* scatter gather disable */
+#define BIG_SUR_GE_DMACR_GEN_BD_INTR_MASK      0x04000000UL    /* descriptor interrupt */
+#define BIG_SUR_GE_DMACR_LAST_BD_MASK          BIG_SUR_GE_CONTROL_LAST_BD_MASK        /* last buffer */
+#define BIG_SUR_GE_DMASR_BUSY_MASK                     0x80000000UL    /* channel is busy */
+#define BIG_SUR_GE_DMASR_BUS_ERROR_MASK        0x40000000UL    /* bus error occurred */
+#define BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK      0x20000000UL    /* bus timeout occurred */
+#define BIG_SUR_GE_DMASR_LAST_BD_MASK          BIG_SUR_GE_STATUS_LAST_BD_MASK /* last buffer */
+#define BIG_SUR_GE_DMASR_SG_BUSY_MASK          0x08000000UL    /* scatter gather is busy */
+#define BIG_SUR_GE_IXR_DMA_DONE_MASK           0x1UL   /* dma operation done */
+#define BIG_SUR_GE_IXR_DMA_ERROR_MASK      0x2UL       /* dma operation error */
+#define BIG_SUR_GE_IXR_PKT_DONE_MASK       0x4UL       /* packet done */
+#define BIG_SUR_GE_IXR_PKT_THRESHOLD_MASK      0x8UL   /* packet count threshold */
+#define BIG_SUR_GE_IXR_PKT_WAIT_BOUND_MASK 0x10UL      /* packet wait bound reached */
+#define BIG_SUR_GE_IXR_SG_DISABLE_ACK_MASK 0x20UL      /* scatter gather disable
+                                                   acknowledge occurred */
+#define BIG_SUR_GEIXR_SG_END_MASK                     0x40UL  /* last buffer descriptor
+                                                           disabled scatter gather */
+#define BIG_SUR_GEIXR_BD_MASK                         0x80UL  /* buffer descriptor done */
+
+/* BD control */
+#define BIG_SUR_GE_DFT_SEND_BD_MASK    (BIG_SUR_GEDMACR_SOURCE_INCR_MASK | \
+                                 BIG_SUR_GEDMACR_DEST_LOCAL_MASK)
+#define BIG_SUR_GE_DFT_RECV_BD_MASK    (BIG_SUR_GEDMACR_DEST_INCR_MASK |  \
+                                 BIG_SUR_GEDMACR_SOURCE_LOCAL_MASK)
+
+/* Interrupts */
+#define BIG_SUR_GE_IPIF_EMAC_MASK      0x00000004UL    /* MAC interrupt */
+#define BIG_SUR_GE_IPIF_SEND_DMA_MASK  0x00000008UL    /* Send DMA interrupt */
+#define BIG_SUR_GE_IPIF_RECV_DMA_MASK  0x00000010UL    /* Receive DMA interrupt */
+#define BIG_SUR_GE_IPIF_RECV_FIFO_MASK 0x00000020UL    /* Receive FIFO interrupt */
+#define BIG_SUR_GE_IPIF_SEND_FIFO_MASK 0x00000040UL    /* Send FIFO interrupt */
+
+#define BIG_SUR_GE_IPIF_DMA_DFT_MASK   (BIG_SUR_GE_IPIF_SEND_DMA_MASK |   \
+                                 BIG_SUR_GE_IPIF_RECV_DMA_MASK |   \
+                                 BIG_SUR_GE_IPIF_EMAC_MASK |       \
+                                 BIG_SUR_GE_IPIF_SEND_FIFO_MASK |  \
+                                 BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+
+#define BIG_SUR_GE_IPIF_FIFO_DFT_MASK  (BIG_SUR_GE_IPIF_EMAC_MASK |       \
+                                 BIG_SUR_GE_IPIF_SEND_FIFO_MASK |  \
+                                 BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+
+#define BIG_SUR_GE_IPIF_DMA_DEV_INTR_COUNT   7 /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_FIFO_DEV_INTR_COUNT  5 /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_DEVICE_INTR_COUNT  7   /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_IP_INTR_COUNT      22  /* Number of MAC interrupts */
+
+/* a mask for all transmit interrupts, used in polled mode */
+#define BIG_SUR_GE_EIR_XMIT_ALL_MASK   (BIG_SUR_GE_EIR_XMIT_DONE_MASK |           \
+                                 BIG_SUR_GE_EIR_XMIT_ERROR_MASK |          \
+                                 BIG_SUR_GE_EIR_XMIT_SFIFO_EMPTY_MASK |    \
+                                 BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK)
+
+/* a mask for all receive interrupts, used in polled mode */
+#define BIG_SUR_GE_EIR_RECV_ALL_MASK   (BIG_SUR_GE_EIR_RECV_DONE_MASK |           \
+                                 BIG_SUR_GE_EIR_RECV_ERROR_MASK |          \
+                                 BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK |    \
+                                 BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |     \
+                                 BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |    \
+                                 BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK |     \
+                                 BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |   \
+                                 BIG_SUR_GE_EIR_RECV_COLLISION_MASK |      \
+                                 BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |      \
+                                 BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |      \
+                                 BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |    \
+                                 BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |     \
+                                 BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK)
+
+/* a default interrupt mask for scatter-gather DMA operation */
+#define BIG_SUR_GE_EIR_DFT_SG_MASK    (BIG_SUR_GE_EIR_RECV_ERROR_MASK |           \
+                                BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |     \
+                                BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK |     \
+                                BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK |     \
+                                BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |    \
+                                BIG_SUR_GE_EIR_RECV_COLLISION_MASK |       \
+                                BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |       \
+                                BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |       \
+                                BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |     \
+                                BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |      \
+                                BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK)
+
+/* a default interrupt mask for non-DMA operation (direct FIFOs) */
+#define BIG_SUR_GE_EIR_DFT_FIFO_MASK  (BIG_SUR_GE_EIR_XMIT_DONE_MASK |            \
+                                BIG_SUR_GE_EIR_RECV_DONE_MASK |            \
+                                BIG_SUR_GE_EIR_DFT_SG_MASK)
+
+#define BIG_SUR_GE_DMA_SG_INTR_MASK    (BIG_SUR_GEIXR_DMA_ERROR_MASK  |      \
+                                 BIG_SUR_GEIXR_PKT_THRESHOLD_MASK |   \
+                                 BIG_SUR_GEIXR_PKT_WAIT_BOUND_MASK |  \
+                                 BIG_SUR_GEIXR_SG_END_MASK)
+
+#endif
diff -Naur linux-2.6.14/drivers/net/declance.c linux-mips-2.6.14.orig/drivers/net/declance.c
--- linux-2.6.14/drivers/net/declance.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/declance.c	2005-11-17 11:43:10.000000000 -0800
@@ -5,7 +5,7 @@
  *
  *      adopted from sunlance.c by Richard van den Berg
  *
- *      Copyright (C) 2002, 2003  Maciej W. Rozycki
+ *      Copyright (C) 2002, 2003, 2005  Maciej W. Rozycki
  *
  *      additional sources:
  *      - PMAD-AA TURBOchannel Ethernet Module Functional Specification,
@@ -57,13 +57,15 @@
 #include <linux/string.h>
 
 #include <asm/addrspace.h>
+#include <asm/system.h>
+
 #include <asm/dec/interrupts.h>
 #include <asm/dec/ioasic.h>
 #include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/kn01.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/system.h>
 #include <asm/dec/tc.h>
-#include <asm/system.h>
 
 static char version[] __devinitdata =
 "declance.c: v0.009 by Linux MIPS DECstation task force\n";
@@ -79,10 +81,6 @@
 #define PMAD_LANCE 2
 #define PMAX_LANCE 3
 
-#ifndef CONFIG_TC
-unsigned long system_base;
-unsigned long dmaptr;
-#endif
 
 #define LE_CSR0 0
 #define LE_CSR1 1
@@ -237,7 +235,7 @@
 /*
  * This works *only* for the ring descriptors
  */
-#define LANCE_ADDR(x) (PHYSADDR(x) >> 1)
+#define LANCE_ADDR(x) (CPHYSADDR(x) >> 1)
 
 struct lance_private {
 	struct net_device *next;
@@ -697,16 +695,17 @@
 	spin_unlock(&lp->lock);
 }
 
-static void lance_dma_merr_int(const int irq, void *dev_id,
-				struct pt_regs *regs)
+static irqreturn_t lance_dma_merr_int(const int irq, void *dev_id,
+				      struct pt_regs *regs)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
 
 	printk("%s: DMA error\n", dev->name);
+	return IRQ_HANDLED;
 }
 
-static irqreturn_t
-lance_interrupt(const int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t lance_interrupt(const int irq, void *dev_id,
+				   struct pt_regs *regs)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
 	struct lance_private *lp = netdev_priv(dev);
@@ -1026,10 +1025,6 @@
 	unsigned long esar_base;
 	unsigned char *esar;
 
-#ifndef CONFIG_TC
-	system_base = KN01_LANCE_BASE;
-#endif
-
 	if (dec_lance_debug && version_printed++ == 0)
 		printk(version);
 
@@ -1062,16 +1057,16 @@
 	switch (type) {
 #ifdef CONFIG_TC
 	case ASIC_LANCE:
-		dev->base_addr = system_base + IOASIC_LANCE;
+		dev->base_addr = CKSEG1ADDR(dec_kn_slot_base + IOASIC_LANCE);
 
 		/* buffer space for the on-board LANCE shared memory */
 		/*
 		 * FIXME: ugly hack!
 		 */
-		dev->mem_start = KSEG1ADDR(0x00020000);
+		dev->mem_start = CKSEG1ADDR(0x00020000);
 		dev->mem_end = dev->mem_start + 0x00020000;
 		dev->irq = dec_interrupt[DEC_IRQ_LANCE];
-		esar_base = system_base + IOASIC_ESAR;
+		esar_base = CKSEG1ADDR(dec_kn_slot_base + IOASIC_ESAR);
 
 		/* Workaround crash with booting KN04 2.1k from Disk */
 		memset((void *)dev->mem_start, 0,
@@ -1101,14 +1096,14 @@
 		/* Setup I/O ASIC LANCE DMA.  */
 		lp->dma_irq = dec_interrupt[DEC_IRQ_LANCE_MERR];
 		ioasic_write(IO_REG_LANCE_DMA_P,
-			     PHYSADDR(dev->mem_start) << 3);
+			     CPHYSADDR(dev->mem_start) << 3);
 
 		break;
 
 	case PMAD_LANCE:
 		claim_tc_card(slot);
 
-		dev->mem_start = get_tc_base_addr(slot);
+		dev->mem_start = CKSEG1ADDR(get_tc_base_addr(slot));
 		dev->base_addr = dev->mem_start + 0x100000;
 		dev->irq = get_tc_irq_nr(slot);
 		esar_base = dev->mem_start + 0x1c0002;
@@ -1137,9 +1132,9 @@
 
 	case PMAX_LANCE:
 		dev->irq = dec_interrupt[DEC_IRQ_LANCE];
-		dev->base_addr = KN01_LANCE_BASE;
-		dev->mem_start = KN01_LANCE_BASE + 0x01000000;
-		esar_base = KN01_RTC_BASE + 1;
+		dev->base_addr = CKSEG1ADDR(KN01_SLOT_BASE + KN01_LANCE);
+		dev->mem_start = CKSEG1ADDR(KN01_SLOT_BASE + KN01_LANCE_MEM);
+		esar_base = CKSEG1ADDR(KN01_SLOT_BASE + KN01_ESAR + 1);
 		lp->dma_irq = -1;
 
 		/*
@@ -1260,7 +1255,7 @@
 	return 0;
 
 err_out_free_dev:
-	kfree(dev);
+	free_netdev(dev);
 
 err_out:
 	return ret;
@@ -1306,6 +1301,7 @@
 	while (root_lance_dev) {
 		struct net_device *dev = root_lance_dev;
 		struct lance_private *lp = netdev_priv(dev);
+
 		unregister_netdev(dev);
 #ifdef CONFIG_TC
 		if (lp->slot >= 0)
diff -Naur linux-2.6.14/drivers/net/gt64240eth.c linux-mips-2.6.14.orig/drivers/net/gt64240eth.c
--- linux-2.6.14/drivers/net/gt64240eth.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/gt64240eth.c	2005-11-17 11:43:10.000000000 -0800
@@ -0,0 +1,1672 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Patton Electronics Company
+ * Copyright (C) 2002 Momentum Computer
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or support@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Ethernet driver for the MIPS GT96100 Advanced Communication Controller.
+ * 
+ * Modified for the Gallileo/Marvell GT-64240 Communication Controller.
+ *
+ * Support for Rx NAPI, Rx checksum offload, IOCTL and ETHTOOL added
+ * Manish Lachwani (lachwani@pmc-sierra.com) - 09/16/2003
+ *
+ * Modified for later version of Linux 2.4 kernel
+ * Manish Lachwani (lachwani@pmc-sierra.com) - 04/29/2004
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/mii.h>
+
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#define DESC_DATA_BE 1
+
+#include "gt64240eth.h"
+
+// enable this port (set hash size to 1/2K)
+//- #define PORT_CONFIG pcrHS
+#define PORT_CONFIG (pcrHS | pcrHD)
+//- #define PORT_CONFIG pcrHS |pcrPM |pcrPBF|pcrHDM
+//- GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, pcrEN | pcrHS);
+//- GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, pcrEN | pcrHS | pcrPM);
+//- GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, pcrEN | pcrHS | pcrPM | 1<<pcrLPBKBit);
+
+// clear all the MIB ctr regs
+#define EXT_CONFIG_CLEAR (pcxrFCTL | pcxrFCTLen | pcxrFLP | pcxrDPLXen | pcxrPRIOrxOverride | pcxrRMIIen)
+
+/*
+ * _debug level:
+ * <= 2	none.
+ *  > 2	some warnings such as queue full, .....
+ *  > 3	lots of change-of-state messages.
+ *  > 4	EXTENSIVE data/descriptor dumps.
+ */
+
+#ifdef GT64240_DEBUG
+static int gt64240_debug = GT64240_DEBUG;
+#else
+static int gt64240_debug = 0;
+#endif
+
+static int debug = -1;
+
+#define GT64240_MSG_ENABLE	(NETIF_MSG_DRV          | \
+				NETIF_MSG_PROBE        | \
+				NETIF_MSG_LINK)
+
+
+/********************************************************/
+
+// prototypes
+static void gt64240_delay(int msec);
+static int gt64240_add_hash_entry(struct net_device *dev,
+				  unsigned char *addr);
+static void read_mib_counters(struct gt64240_private *gp);
+static void dump_MII(struct net_device *dev);
+static void dump_tx_desc(struct net_device *dev, int i);
+static void dump_rx_desc(struct net_device *dev, int i);
+static void dump_hw_addr(unsigned char *addr_str);
+static void update_stats(struct gt64240_private *gp);
+static void abort(struct net_device *dev, u32 abort_bits);
+static void hard_stop(struct net_device *dev);
+static void enable_ether_irq(struct net_device *dev);
+static void disable_ether_irq(struct net_device *dev);
+static int __init gt64240_probe1(unsigned long ioaddr, int irq, int port_num);
+static void reset_tx(struct net_device *dev);
+static void reset_rx(struct net_device *dev);
+static int gt64240_init(struct net_device *dev);
+static int gt64240_open(struct net_device *dev);
+static int gt64240_close(struct net_device *dev);
+static int gt64240_tx(struct sk_buff *skb, struct net_device *dev);
+#ifdef GT64240_NAPI
+static int gt64240_poll(struct net_device *dev, int *budget);
+static int gt64240_rx(struct net_device *dev, u32 status, int budget);
+#else
+static int gt64240_rx(struct net_device *dev, u32 status);
+#endif
+static void gt64240_tx_timeout(struct net_device *dev);
+static void gt64240_set_rx_mode(struct net_device *dev);
+static struct net_device_stats *gt64240_get_stats(struct net_device *dev);
+
+extern char *__init prom_getcmdline(void);
+extern int prom_get_mac_addrs(unsigned char
+			      station_addr[NUM_INTERFACES][6]);
+
+static char version[] __devinitdata =
+	"gt64240eth.o: version 0.1, <www.patton.com>\n";
+
+// PHY device addresses
+static u32 gt64240_phy_addr[NUM_INTERFACES] __devinitdata = { 0x8, 0x1, 0xa };
+
+// Need real Ethernet addresses -- in parse_mac_addr_options(),
+// these will be replaced by prom_get_mac_addrs() and/or prom_getcmdline().
+static unsigned char gt64240_station_addr[NUM_INTERFACES][6] = {
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05},
+	{0x01, 0x02, 0x03, 0x04, 0x05, 0x06},
+	{0x02, 0x03, 0x04, 0x05, 0x06, 0x07}
+};
+
+static int max_interrupt_work = 32;
+
+/*
+ * Base address and interupt of the GT64240 ethernet controllers
+ */
+static struct {
+	unsigned int port;
+	int irq;
+} gt64240_iflist[NUM_INTERFACES] = {
+	{
+	GT64240_ETH0_BASE, 8}, {
+	GT64240_ETH1_BASE, 8}, {
+	GT64240_ETH2_BASE, 8}
+};
+
+static void gt64240_delay(int ms)
+{
+	if (in_interrupt())
+		return;
+	else {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(ms * HZ / 1000);
+	}
+}
+
+unsigned char prom_mac_addr_base[6];
+
+int prom_get_mac_addrs(unsigned char station_addr[NUM_INTERFACES][6])
+{
+	memcpy(station_addr[0], prom_mac_addr_base, 6);
+	memcpy(station_addr[1], prom_mac_addr_base, 6);
+	memcpy(station_addr[2], prom_mac_addr_base, 6);
+
+	station_addr[1][5] += 1;
+	station_addr[2][5] += 2;
+
+	return 0;
+}
+
+void parse_mac_addr_options(void)
+{
+	prom_get_mac_addrs(gt64240_station_addr);
+}
+
+static int read_MII(struct net_device *dev, int phy, int reg)
+{
+	int timedout = 20;
+	u32 smir = smirOpCode | (phy << smirPhyAdBit) |
+	    (reg << smirRegAdBit);
+
+	// wait for last operation to complete
+	while ((GT64240_READ(GT64240_ETH_SMI_REG)) & smirBusy) {
+		// snooze for 1 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: read_MII busy timeout!!\n", dev->name);
+			return -1;
+		}
+	}
+
+	GT64240_WRITE(GT64240_ETH_SMI_REG, smir);
+
+	timedout = 20;
+	// wait for read to complete
+	while (!
+	       ((smir =
+		 GT64240_READ(GT64240_ETH_SMI_REG)) & smirReadValid)) {
+		// snooze for 1 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: read_MII timeout!!\n", dev->name);
+			return -1;
+		}
+	}
+
+	return (int) (smir & smirDataMask);
+}
+
+static void gp_get_drvinfo (struct net_device *dev, 
+				struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "gt64260");
+	strcpy(info->version, version);
+}
+
+static int gp_get_settings(struct net_device *dev, 
+				struct ethtool_cmd *cmd)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int rc;
+
+	spin_lock_irq(&gp->lock);
+	rc = mii_ethtool_gset(&gp->mii_if, cmd);
+	spin_unlock_irq(&gp->lock);
+	return rc;
+}
+
+static int gp_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int rc;
+
+	spin_lock_irq(&gp->lock);
+	rc = mii_ethtool_sset(&gp->mii_if, cmd);
+	spin_unlock_irq(&gp->lock);
+	return rc;
+}
+
+static int gp_nway_reset(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	return mii_nway_restart(&gp->mii_if);
+}
+
+static u32 gp_get_link(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	return mii_link_ok(&gp->mii_if);
+}
+
+static u32 gp_get_msglevel(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	return gp->msg_enable;
+}
+
+static void gp_set_msglevel(struct net_device *dev, u32 value)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	gp->msg_enable = value;
+}
+
+static struct ethtool_ops gp_ethtool_ops = {
+	.get_drvinfo		= gp_get_drvinfo,
+	.get_settings		= gp_get_settings,
+	.set_settings		= gp_set_settings,
+	.nway_reset		= gp_nway_reset,
+	.get_link		= gp_get_link,
+	.get_msglevel		= gp_get_msglevel,
+	.set_msglevel		= gp_set_msglevel,
+};
+
+static int gt64240_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	struct mii_ioctl_data *data =
+	    (struct mii_ioctl_data *) &rq->ifr_data;
+	int retval;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	spin_lock_irq(&gp->lock);
+	retval = generic_mii_ioctl(&gp->mii_if, data, cmd, NULL);
+	spin_unlock_irq(&gp->lock);
+
+	return retval;
+}
+
+static void dump_tx_desc(struct net_device *dev, int i)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	gt64240_td_t *td = &gp->tx_ring[i];
+
+	printk("%s:tx[%d]: self=%p cmd=%08x, cnt=%4d. bufp=%08x, next=%08x\n",
+	       dev->name, i, td, td->cmdstat, td->byte_cnt, td->buff_ptr,
+	       td->next);
+}
+
+static void dump_rx_desc(struct net_device *dev, int i)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	gt64240_rd_t *rd = &gp->rx_ring[i];
+
+	printk("%s:rx_dsc[%d]: self=%p cst=%08x,size=%4d. cnt=%4d. "
+	       "bufp=%08x, next=%08x\n",
+	       dev->name, i, rd, rd->cmdstat, rd->buff_sz, rd->byte_cnt,
+	       rd->buff_ptr, rd->next);
+}
+
+// These routines work, just disabled to avoid compile warnings
+static void write_MII(struct net_device *dev, int phy, int reg, int data)
+{
+	u32 smir = (phy << smirPhyAdBit) | (reg << smirRegAdBit) | data;
+	int timedout = 20;
+
+	// wait for last operation to complete
+	while (GT64240_READ(GT64240_ETH_SMI_REG) & smirBusy) {
+		// snooze for 1 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: write_MII busy timeout!!\n",
+			       dev->name);
+			return;
+		}
+	}
+
+	GT64240_WRITE(GT64240_ETH_SMI_REG, smir);
+}
+
+static void dump_MII(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int i, val;
+
+	for (i = 0; i < 7; i++) {
+		if ((val = read_MII(dev, gp->phy_addr, i)) >= 0)
+			printk("%s: MII Reg %d=%x\n", dev->name, i, val);
+	}
+	for (i = 16; i < 21; i++) {
+		if ((val = read_MII(dev, gp->phy_addr, i)) >= 0)
+			printk("%s: MII Reg %d=%x\n", dev->name, i, val);
+	}
+}
+
+
+static void dump_hw_addr(unsigned char *addr_str)
+{
+	int i;
+	for (i = 0; i < 6; i++) {
+		printk("%2.2x", addr_str[i]);
+		printk(i < 5 ? ":" : "\n");
+	}
+}
+
+static int gt64240_add_hash_entry(struct net_device *dev,
+				  unsigned char *addr)
+{
+	static unsigned char swapped[256];
+	struct gt64240_private *gp;
+	u32 value1, value0, *entry;
+	unsigned char hash_ea[6];
+	static int flag = 0;
+	u16 hashResult;
+	int i;
+
+	if (flag == 0) {	/* Create table to swap bits in a byte  */
+		flag = 1;
+		for (i = 0; i < 256; i++) {
+			swapped[i] = (i & 0x01) << 7;
+			swapped[i] |= (i & 0x02) << 5;
+			swapped[i] |= (i & 0x04) << 3;
+			swapped[i] |= (i & 0x08) << 1;
+			swapped[i] |= (i & 0x10) >> 1;
+			swapped[i] |= (i & 0x20) >> 3;
+			swapped[i] |= (i & 0x40) >> 5;
+			swapped[i] |= (i & 0x80) >> 7;
+		}
+	}
+
+	for (i = 0; i < 6; i++) {	/* swap bits from mac to create hash mac */
+		hash_ea[i] = swapped[addr[i]];
+	}
+
+	gp = netdev_priv(dev);
+
+	/* create hash entry address    */
+	hashResult = (((hash_ea[5] >> 2) & 0x3F) << 9) & 0x7E00;
+	hashResult |= ((hash_ea[4] & 0x7F) << 2) | (hash_ea[5] & 0x03);
+	hashResult ^=
+	    ((hash_ea[3] & 0xFF) << 1) | ((hash_ea[4] >> 7) & 0x01);
+	hashResult ^= ((hash_ea[1] & 0x01) << 8) | (hash_ea[2] & 0xFF);
+
+	value0 = hteValid | hteRD;	/* Create hash table entry value */
+	value0 |= (u32) addr[0] << 3;
+	value0 |= (u32) addr[1] << 11;
+	value0 |= (u32) addr[2] << 19;
+	value0 |= ((u32) addr[3] & 0x1f) << 27;
+
+	value1 = ((u32) addr[3] >> 5) & 0x07;
+	value1 |= (u32) addr[4] << 3;
+	value1 |= (u32) addr[5] << 11;
+
+	/* Inset entry value into hash table */
+	for (i = 0; i < HASH_HOP_NUMBER; i++) {
+		entry = (u32 *) ((u32) gp->hash_table +
+				 (((u32) hashResult & 0x07ff) << 3));
+		if ((*entry & hteValid) && !(*entry & hteSkip)) {
+			hashResult += 2;	/* oops, occupied, go to next entry */
+		} else {
+#ifdef __LITTLE_ENDIAN
+			entry[1] = value1;
+			entry[0] = value0;
+#else
+			entry[0] = value1;
+			entry[1] = value0;
+#endif
+			break;
+		}
+	}
+	if (i >= HASH_HOP_NUMBER) {
+		printk("%s: gt64240_add_hash_entry expired!\n", dev->name);
+		return (-1);
+	}
+	return (0);
+}
+
+
+static void read_mib_counters(struct gt64240_private *gp)
+{
+	u32 *mib_regs = (u32 *) & gp->mib;
+	int i;
+
+	for (i = 0; i < sizeof(mib_counters_t) / sizeof(u32); i++)
+		mib_regs[i] =
+		    GT64240ETH_READ(gp,
+				    GT64240_ETH_MIB_COUNT_BASE +
+				    i * sizeof(u32));
+}
+
+
+static void update_stats(struct gt64240_private *gp)
+{
+	mib_counters_t *mib = &gp->mib;
+	struct net_device_stats *stats = &gp->stats;
+
+	read_mib_counters(gp);
+
+	stats->rx_packets = mib->totalFramesReceived;
+	stats->tx_packets = mib->framesSent;
+	stats->rx_bytes = mib->totalByteReceived;
+	stats->tx_bytes = mib->byteSent;
+	stats->rx_errors = mib->totalFramesReceived - mib->framesReceived;
+	//the tx error counters are incremented by the ISR
+	//rx_dropped incremented by gt64240_rx
+	//tx_dropped incremented by gt64240_tx
+	stats->multicast = mib->multicastFramesReceived;
+	// collisions incremented by gt64240_tx_complete
+	stats->rx_length_errors = mib->oversizeFrames + mib->fragments;
+	// The RxError condition means the Rx DMA encountered a
+	// CPU owned descriptor, which, if things are working as
+	// they should, means the Rx ring has overflowed.
+	stats->rx_over_errors = mib->macRxError;
+	stats->rx_crc_errors = mib->cRCError;
+}
+
+static void abort(struct net_device *dev, u32 abort_bits)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int timedout = 100;	// wait up to 100 msec for hard stop to complete
+
+	if (gt64240_debug > 3)
+		printk("%s: abort\n", dev->name);
+
+	// Return if neither Rx or Tx abort bits are set
+	if (!(abort_bits & (sdcmrAR | sdcmrAT)))
+		return;
+
+	// make sure only the Rx/Tx abort bits are set
+	abort_bits &= (sdcmrAR | sdcmrAT);
+
+	spin_lock(&gp->lock);
+
+	// abort any Rx/Tx DMA immediately
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, abort_bits);
+
+	if (gt64240_debug > 3)
+		printk("%s: abort: SDMA cmd  = %x/%x\n",
+		       dev->name, abort_bits, GT64240ETH_READ(gp,
+							      GT64240_ETH_SDMA_COMM));
+
+	// wait for abort to complete
+	while ((GT64240ETH_READ(gp, GT64240_ETH_SDMA_COMM)) & abort_bits) {
+		// snooze for 20 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: abort timeout!!\n", dev->name);
+			break;
+		}
+	}
+
+	spin_unlock(&gp->lock);
+}
+
+
+static void hard_stop(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+
+	if (gt64240_debug > 3)
+		printk("%s: hard stop\n", dev->name);
+
+	disable_ether_irq(dev);
+
+	abort(dev, sdcmrAR | sdcmrAT);
+
+	// disable port
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, 0);
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_hard_stop: Port Config=%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_PORT_CONFIG));
+
+}
+
+static void gt64240_tx_complete(struct net_device *dev, u32 status)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int nextOut, cdp;
+	gt64240_td_t *td;
+	u32 cmdstat;
+
+	cdp = (GT64240ETH_READ(gp, GT64240_ETH_CURR_TX_DESC_PTR0)
+	       - gp->tx_ring_dma) / sizeof(gt64240_td_t);
+
+	if (gt64240_debug > 3) {	/*+prk17aug01 */
+		nextOut = gp->tx_next_out;
+		printk
+		    ("%s: tx_complete: TX_PTR0=0x%08x, cdp=%d. nextOut=%d.\n",
+		     dev->name, GT64240ETH_READ(gp,
+						GT64240_ETH_CURR_TX_DESC_PTR0),
+		     cdp, nextOut);
+		td = &gp->tx_ring[nextOut];
+	}
+
+/*** NEED to check and CLEAR these errors every time thru here: ***/
+	if (gt64240_debug > 2) {
+		if (GT64240_READ(COMM_UNIT_INTERRUPT_CAUSE))
+			printk
+			    ("%s: gt64240_tx_complete: CIU Cause=%08x, Mask=%08x, EAddr=%08x\n",
+			     dev->name,
+			     GT64240_READ(COMM_UNIT_INTERRUPT_CAUSE),
+			     GT64240_READ(COMM_UNIT_INTERRUPT_MASK),
+			     GT64240_READ(COMM_UNIT_ERROR_ADDRESS));
+		GT64240_WRITE(COMM_UNIT_INTERRUPT_CAUSE, 0);
+	}
+	// Continue until we reach the current descriptor pointer
+	for (nextOut = gp->tx_next_out; nextOut != cdp;
+	     nextOut = (nextOut + 1) % TX_RING_SIZE) {
+
+		if (--gp->intr_work_done == 0)
+			break;
+
+		td = &gp->tx_ring[nextOut];
+		cmdstat = td->cmdstat;
+
+		if (cmdstat & (u32) txOwn) {
+			// DMA is not finished writing descriptor???
+			// Leave and come back later to pick-up where we left off.
+			break;
+		}
+		// increment Tx error stats
+		if (cmdstat & (u32) txErrorSummary) {
+			if (gt64240_debug > 2)
+				printk
+				    ("%s: tx_complete: Tx error, cmdstat = %x\n",
+				     dev->name, cmdstat);
+			gp->stats.tx_errors++;
+			if (cmdstat & (u32) txReTxLimit)
+				gp->stats.tx_aborted_errors++;
+			if (cmdstat & (u32) txUnderrun)
+				gp->stats.tx_fifo_errors++;
+			if (cmdstat & (u32) txLateCollision)
+				gp->stats.tx_window_errors++;
+		}
+
+		if (cmdstat & (u32) txCollision)
+			gp->stats.collisions +=
+			    (unsigned long) ((cmdstat & txReTxCntMask) >>
+					     txReTxCntBit);
+
+		// Wake the queue if the ring was full
+		if (gp->tx_full) {
+			gp->tx_full = 0;
+			if (gp->last_psr & psrLink) {
+				netif_wake_queue(dev);
+			}
+		}
+		// decrement tx ring buffer count
+		if (gp->tx_count)
+			gp->tx_count--;
+
+		// free the skb
+		if (gp->tx_skbuff[nextOut]) {
+			if (gt64240_debug > 3)
+				printk
+				    ("%s: tx_complete: good Tx, skb=%p\n",
+				     dev->name, gp->tx_skbuff[nextOut]);
+			dev_kfree_skb_irq(gp->tx_skbuff[nextOut]);
+			gp->tx_skbuff[nextOut] = NULL;
+		} else {
+			printk("%s: tx_complete: no skb!\n", dev->name);
+		}
+	}
+
+	gp->tx_next_out = nextOut;
+
+	if ((status & icrTxEndLow) && gp->tx_count != 0) {
+		// we must restart the DMA
+		GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM,
+				 sdcmrERD | sdcmrTXDL);
+	}
+}
+
+static irqreturn_t gt64240_interrupt(int irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct gt64240_private *gp = netdev_priv(dev);
+	u32 status;
+
+	if (dev == NULL) {
+		printk("%s: isr: null dev ptr\n", dev->name);
+		return IRQ_NONE;
+	}
+
+	spin_lock(&gp->lock);
+
+	if (gt64240_debug > 3)
+		printk("%s: isr: entry\n", dev->name);
+
+	gp->intr_work_done = max_interrupt_work;
+
+	while (gp->intr_work_done > 0) {
+
+		status = GT64240ETH_READ(gp, GT64240_ETH_INT_CAUSE);
+#ifdef GT64240_NAPI
+		/* dont ack Rx interrupts */
+		if (!(status & icrRxBuffer))
+			GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0);
+#else
+		// ACK interrupts
+		GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0);
+#endif
+
+		if (gt64240_debug > 3)
+			printk("%s: isr: work=%d., icr=%x\n", dev->name,
+			       gp->intr_work_done, status);
+
+		if ((status & icrEtherIntSum) == 0) {
+			if (!(status &
+			      (icrTxBufferLow | icrTxBufferHigh |
+			       icrRxBuffer))) {
+				/* exit from the while() loop */
+				break;
+			}
+		}
+
+		if (status & icrMIIPhySTC) {
+			u32 psr =
+			    GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS);
+			if (gp->last_psr != psr) {
+				printk("%s: port status: 0x%08x\n",
+				       dev->name, psr);
+				printk
+				    ("%s:    %s MBit/s, %s-duplex, flow-control %s, link is %s,\n",
+				     dev->name,
+				     psr & psrSpeed ? "100" : "10",
+				     psr & psrDuplex ? "full" : "half",
+				     psr & psrFctl ? "disabled" :
+				     "enabled",
+				     psr & psrLink ? "up" : "down");
+				printk
+				    ("%s:    TxLowQ is %s, TxHighQ is %s, Transmitter is %s\n",
+				     dev->name,
+				     psr & psrTxLow ? "running" :
+				     "stopped",
+				     psr & psrTxHigh ? "running" :
+				     "stopped",
+				     psr & psrTxInProg ? "on" : "off");
+
+				if ((psr & psrLink) && !gp->tx_full &&
+				    netif_queue_stopped(dev)) {
+					printk
+					    ("%s: isr: Link up, waking queue.\n",
+					     dev->name);
+					netif_wake_queue(dev);
+				} else if (!(psr & psrLink)
+					   && !netif_queue_stopped(dev)) {
+					printk
+					    ("%s: isr: Link down, stopping queue.\n",
+					     dev->name);
+					netif_stop_queue(dev);
+				}
+
+				gp->last_psr = psr;
+			}
+		}
+
+		if (status & (icrTxBufferLow | icrTxEndLow))
+			gt64240_tx_complete(dev, status);
+
+		if (status & icrRxBuffer) {
+#ifdef GT64240_NAPI
+			if (netif_rx_schedule_prep(dev)) {
+				disable_ether_irq(dev);
+				__netif_rx_schedule(dev);
+			}
+#else
+			gt64240_rx(dev, status);
+#endif
+		}
+		// Now check TX errors (RX errors were handled in gt64240_rx)
+		if (status & icrTxErrorLow) {
+			printk("%s: isr: Tx resource error\n", dev->name);
+		}
+
+		if (status & icrTxUdr) {
+			printk("%s: isr: Tx underrun error\n", dev->name);
+		}
+	}
+
+	if (gp->intr_work_done == 0) {
+		// ACK any remaining pending interrupts
+		GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0);
+		if (gt64240_debug > 3)
+			printk("%s: isr: hit max work\n", dev->name);
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: isr: exit, icr=%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_INT_CAUSE));
+
+	spin_unlock(&gp->lock);
+
+	return IRQ_HANDLED;
+}
+
+static void enable_ether_irq(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	u32 intMask;
+
+	intMask =
+	    icrTxBufferLow | icrTxEndLow | icrTxErrorLow |
+	    icrTxBufferHigh | icrTxEndHigh | icrTxErrorHigh | icrTxUdr |
+	    icrRxBuffer | icrRxOVR | icrRxError | icrMIIPhySTC |
+	    icrEtherIntSum;
+
+
+//- GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0); /* CLEAR existing ints */
+	// unmask device interrupts:
+	GT64240ETH_WRITE(gp, GT64240_ETH_INT_MASK, intMask);
+
+	// now route ethernet interrupts to GT PCI1 (eth0 and eth1 will be
+	// sharing it).
+	intMask = MV_READ(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH);
+	intMask |= 1 << gp->port_num;
+	MV_WRITE(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH, intMask);
+}
+
+static void disable_ether_irq(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	u32 intMask;
+
+	intMask = MV_READ(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH);
+	intMask &= ~(1 << gp->port_num);
+	MV_WRITE(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH, intMask);
+
+	// mask all device interrupts: 
+	GT64240ETH_WRITE(gp, GT64240_ETH_INT_MASK, 0);
+}
+
+/*
+ * Probe for a GT64240 ethernet controller.
+ */
+static int __init gt64240_probe(void)
+{
+	int found = 0;
+	int i;
+
+	parse_mac_addr_options();
+
+	for (i = 0; i < NUM_INTERFACES; i++) {
+		unsigned long base_addr = gt64240_iflist[i].port;
+
+		if (check_region(base_addr, GT64240_ETH_IO_SIZE)) {
+			printk("gt64240_probe: ioaddr 0x%lx taken?\n",
+			       base_addr);
+			continue;
+		}
+
+		if (gt64240_probe1(base_addr, gt64240_iflist[i].irq, i) == 0) {
+			/*
+			 * Does not seem to be the "traditional" way folks do
+			 * this, but I want to init both eth ports if at all
+			 * possible!
+			 *
+			 * So, until I find out the "correct" way to do this:
+			 */
+			if (++found == NUM_INTERFACES)	/* That's all of them */
+				return 0;
+		}
+	}
+
+	if (found)
+		return 0;	/* as long as we found at least one! */
+
+	return -ENODEV;
+}
+
+module_init(gt64240_probe);
+
+static int __init gt64240_probe1(unsigned long ioaddr, int irq, int port_num)
+{
+	struct net_device *dev = NULL;
+	static unsigned version_printed = 0;
+	struct gt64240_private *gp = NULL;
+	int retval;
+	u32 cpuConfig;
+
+	dev = alloc_etherdev(sizeof(struct gt64240_private));
+	if (!dev)
+		return -ENOMEM;
+
+	if (irq < 0) {
+		printk
+		    ("gt64240_probe1: irq unknown - probing not supported\n");
+		return -ENODEV;
+	}
+#if 1				/* KLUDGE Alert: no check on return value: */
+	if (!request_region(ioaddr, GT64240_ETH_IO_SIZE, "gt64240eth"))
+		printk("*** request_region() failed!\n");
+#endif
+
+	cpuConfig = GT64240_READ(CPU_CONFIGURATION);
+	printk("gt64240_probe1: cpu in %s-endian mode\n",
+	       (cpuConfig & (1 << 12)) ? "little" : "big");
+
+	printk("%s: GT64240 found at ioaddr 0x%lx, irq %d.\n",
+	       dev->name, ioaddr, irq);
+
+	if (gt64240_debug && version_printed++ == 0)
+		printk("%s: %s", dev->name, version);
+
+	/* private struct aligned and zeroed by init_etherdev */
+	/* Fill in the 'dev' fields. */
+	dev->base_addr = ioaddr;
+	dev->irq = irq;
+	memcpy(dev->dev_addr, gt64240_station_addr[port_num],
+	       sizeof(dev->dev_addr));
+
+	printk("%s: HW Address ", dev->name);
+	dump_hw_addr(dev->dev_addr);
+
+	gp = dev->priv;
+
+	gp->msg_enable = (debug < 0 ? GT64240_MSG_ENABLE : debug);
+	gp->port_num = port_num;
+	gp->io_size = GT64240_ETH_IO_SIZE;
+	gp->port_offset = port_num * GT64240_ETH_IO_SIZE;
+	gp->phy_addr = gt64240_phy_addr[port_num];
+
+	printk("%s: GT64240 ethernet port %d\n", dev->name, gp->port_num);
+
+#ifdef GT64240_NAPI
+	printk("Rx NAPI supported \n");
+#endif
+
+/* MII Initialization */
+	gp->mii_if.dev = dev;
+	gp->mii_if.phy_id = dev->base_addr;
+	gp->mii_if.mdio_read = read_MII;
+	gp->mii_if.mdio_write = write_MII;
+	gp->mii_if.advertising = read_MII(dev, gp->phy_addr, MII_ADVERTISE);
+
+	// Allocate Rx and Tx descriptor rings
+	if (gp->rx_ring == NULL) {
+		// All descriptors in ring must be 16-byte aligned
+		gp->rx_ring = dma_alloc_noncoherent(NULL,
+					sizeof(gt64240_rd_t) * RX_RING_SIZE +
+					sizeof(gt64240_td_t) * TX_RING_SIZE,
+					&gp->rx_ring_dma, GFP_KERNEL);
+		if (gp->rx_ring == NULL) {
+			retval = -ENOMEM;
+			goto free_region;
+		}
+
+		gp->tx_ring = (gt64240_td_t *) (gp->rx_ring + RX_RING_SIZE);
+		gp->tx_ring_dma =
+			gp->rx_ring_dma + sizeof(gt64240_rd_t) * RX_RING_SIZE;
+	}
+	// Allocate the Rx Data Buffers
+	if (gp->rx_buff == NULL) {
+		gp->rx_buff = dma_alloc_coherent(NULL,
+				PKT_BUF_SZ * RX_RING_SIZE, &gp->rx_buff_dma,
+				GFP_KERNEL);
+		if (gp->rx_buff == NULL) {
+			dma_free_noncoherent(NULL,
+				sizeof(gt64240_rd_t) * RX_RING_SIZE +
+				sizeof(gt64240_td_t) * TX_RING_SIZE,
+				gp->rx_ring, gp->rx_ring_dma);
+			retval = -ENOMEM;
+			goto free_region;
+		}
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_probe1, rx_ring=%p, tx_ring=%p\n",
+		       dev->name, gp->rx_ring, gp->tx_ring);
+
+	// Allocate Rx Hash Table
+	if (gp->hash_table == NULL) {
+		gp->hash_table = dma_alloc_coherent(NULL,
+				RX_HASH_TABLE_SIZE, &gp->hash_table_dma,
+				GFP_KERNEL);
+		if (gp->hash_table == NULL) {
+			dma_free_noncoherent(NULL,
+				sizeof(gt64240_rd_t) * RX_RING_SIZE +
+				sizeof(gt64240_td_t) * TX_RING_SIZE,
+				gp->rx_ring, gp->rx_ring_dma);
+			dma_free_noncoherent(NULL, PKT_BUF_SZ * RX_RING_SIZE,
+				gp->rx_buff, gp->rx_buff_dma);
+			retval = -ENOMEM;
+			goto free_region;
+		}
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_probe1, hash=%p\n",
+		       dev->name, gp->hash_table);
+
+	spin_lock_init(&gp->lock);
+
+	dev->open = gt64240_open;
+	dev->hard_start_xmit = gt64240_tx;
+	dev->stop = gt64240_close;
+	dev->get_stats = gt64240_get_stats;
+	dev->do_ioctl = gt64240_ioctl;
+	dev->set_multicast_list = gt64240_set_rx_mode;
+	dev->tx_timeout = gt64240_tx_timeout;
+	dev->watchdog_timeo = GT64240ETH_TX_TIMEOUT;
+
+#ifdef GT64240_NAPI
+	dev->poll = gt64240_poll;
+	dev->weight = 64;
+#endif
+	dev->ethtool_ops = &gp_ethtool_ops;
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	return 0;
+
+free_region:
+	release_region(ioaddr, gp->io_size);
+	unregister_netdev(dev);
+	free_netdev(dev);
+	printk("%s: gt64240_probe1 failed.  Returns %d\n",
+	       dev->name, retval);
+	return retval;
+}
+
+
+static void reset_tx(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int i;
+
+	abort(dev, sdcmrAT);
+
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		if (gp->tx_skbuff[i]) {
+			if (in_interrupt())
+				dev_kfree_skb_irq(gp->tx_skbuff[i]);
+			else
+				dev_kfree_skb(gp->tx_skbuff[i]);
+			gp->tx_skbuff[i] = NULL;
+		}
+//-     gp->tx_ring[i].cmdstat = 0; // CPU owns
+		gp->tx_ring[i].cmdstat =
+		    (u32) (txGenCRC | txEI | txPad | txFirst | txLast);
+		gp->tx_ring[i].byte_cnt = 0;
+		gp->tx_ring[i].buff_ptr = 0;
+		gp->tx_ring[i].next =
+		    gp->tx_ring_dma + sizeof(gt64240_td_t) * (i + 1);
+		if (gt64240_debug > 4)
+			dump_tx_desc(dev, i);
+	}
+	/* Wrap the ring. */
+	gp->tx_ring[i - 1].next = gp->tx_ring_dma;
+	if (gt64240_debug > 4)
+		dump_tx_desc(dev, i - 1);
+
+	// setup only the lowest priority TxCDP reg
+	GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0,
+			 gp->tx_ring_dma);
+//- GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0, 0);     /* ROLLINS */
+//- GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0,virt_to_phys(&gp->tx_ring[0]));  /* ROLLINS */
+
+	GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR1, 0);
+
+	// init Tx indeces and pkt counter
+	gp->tx_next_in = gp->tx_next_out = 0;
+	gp->tx_count = 0;
+}
+
+static void reset_rx(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int i;
+
+	abort(dev, sdcmrAR);
+
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		gp->rx_ring[i].next =
+		    gp->rx_ring_dma + sizeof(gt64240_rd_t) * (i + 1);
+		gp->rx_ring[i].buff_ptr = gp->rx_buff_dma + i * PKT_BUF_SZ;
+		gp->rx_ring[i].buff_sz = PKT_BUF_SZ;
+		gp->rx_ring[i].byte_cnt = 0;	/* just for debug printk's */
+		// Give ownership to device, set first and last, enable interrupt
+		gp->rx_ring[i].cmdstat =
+		    (uint32_t) (rxFirst | rxLast | rxOwn | rxEI);
+		if (gt64240_debug > 4)
+			dump_rx_desc(dev, i);
+	}
+	/* Wrap the ring. */
+	gp->rx_ring[i - 1].next = gp->rx_ring_dma;
+	if (gt64240_debug > 4)
+		dump_rx_desc(dev, i - 1);
+
+	// Setup only the lowest priority RxFDP and RxCDP regs
+	for (i = 0; i < 4; i++) {
+		if (i == 0) {
+			GT64240ETH_WRITE(gp, GT64240_ETH_1ST_RX_DESC_PTR0,
+					 gp->rx_ring_dma);
+			GT64240ETH_WRITE(gp, GT64240_ETH_CURR_RX_DESC_PTR0,
+					 gp->rx_ring_dma);
+		} else {
+			GT64240ETH_WRITE(gp,
+					 GT64240_ETH_1ST_RX_DESC_PTR0 +
+					 i * 4, 0);
+			GT64240ETH_WRITE(gp,
+					 GT64240_ETH_CURR_RX_DESC_PTR0 +
+					 i * 4, 0);
+		}
+	}
+
+	// init Rx NextOut index
+	gp->rx_next_out = 0;
+}
+
+
+static int gt64240_init(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+
+	if (gt64240_debug > 3) {
+		printk("%s: gt64240_init: dev=%p\n", dev->name, dev);
+		printk("%s: gt64240_init: scs0_lo=%04x, scs0_hi=%04x\n",
+		       dev->name, GT64240_READ(0x008),
+		       GT64240_READ(0x010));
+		printk("%s: gt64240_init: scs1_lo=%04x, scs1_hi=%04x\n",
+		       dev->name, GT64240_READ(0x208),
+		       GT64240_READ(0x210));
+		printk("%s: gt64240_init: scs2_lo=%04x, scs2_hi=%04x\n",
+		       dev->name, GT64240_READ(0x018),
+		       GT64240_READ(0x020));
+		printk("%s: gt64240_init: scs3_lo=%04x, scs3_hi=%04x\n",
+		       dev->name, GT64240_READ(0x218),
+		       GT64240_READ(0x220));
+	}
+	// Stop and disable Port
+	hard_stop(dev);
+
+	GT64240_WRITE(COMM_UNIT_INTERRUPT_MASK, 0x07070777);	/*+prk21aug01 */
+	if (gt64240_debug > 2)
+		printk
+		    ("%s: gt64240_init: CIU Cause=%08x, Mask=%08x, EAddr=%08x\n",
+		     dev->name, GT64240_READ(COMM_UNIT_INTERRUPT_CAUSE),
+		     GT64240_READ(COMM_UNIT_INTERRUPT_MASK),
+		     GT64240_READ(COMM_UNIT_ERROR_ADDRESS));
+
+	// Set-up hash table
+	memset(gp->hash_table, 0, RX_HASH_TABLE_SIZE);	// clear it
+	gp->hash_mode = 0;
+	// Add a single entry to hash table - our ethernet address
+	gt64240_add_hash_entry(dev, dev->dev_addr);
+	// Set-up DMA ptr to hash table
+	GT64240ETH_WRITE(gp, GT64240_ETH_HASH_TBL_PTR, gp->hash_table_dma);
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Hash Tbl Ptr=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_HASH_TBL_PTR));
+
+	// Setup Tx
+	reset_tx(dev);
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Curr Tx Desc Ptr0=%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_CURR_TX_DESC_PTR0));
+
+	// Setup Rx
+	reset_rx(dev);
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: 1st/Curr Rx Desc Ptr0=%x/%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_1ST_RX_DESC_PTR0),
+		       GT64240ETH_READ(gp, GT64240_ETH_CURR_RX_DESC_PTR0));
+
+	if (gt64240_debug > 3)
+		dump_MII(dev);
+
+	/* force a PHY reset -- self-clearing! */
+	write_MII(dev, gp->phy_addr, 0, 0x8000);
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: PhyAD=%x\n", dev->name,
+		       GT64240_READ(GT64240_ETH_PHY_ADDR_REG));
+
+	// setup DMA
+	// We want the Rx/Tx DMA to write/read data to/from memory in
+	// Big Endian mode. Also set DMA Burst Size to 8 64Bit words.
+#ifdef DESC_DATA_BE
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_CONFIG,
+			 (0xf << sdcrRCBit) | sdcrRIFB | (3 <<
+							  sdcrBSZBit));
+#else
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_CONFIG, sdcrBLMR | sdcrBLMT |
+//-                  (0xf<<sdcrRCBit) | sdcrRIFB | (3<<sdcrBSZBit));
+			 (0xf << sdcrRCBit) | sdcrRIFB | (2 <<
+							  sdcrBSZBit));
+#endif
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: SDMA Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_SDMA_CONFIG));
+
+#if 0
+	// start Rx DMA
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, sdcmrERD);
+#endif
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: SDMA Cmd =%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_SDMA_COMM));
+
+#if 1
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, PORT_CONFIG);
+#endif
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG));
+
+	/*
+	 * Disable all Type-of-Service queueing. All Rx packets will be
+	 * treated normally and will be sent to the lowest priority
+	 * queue.
+	 *
+	 * Disable flow-control for now. FIX! support flow control?
+	 */
+
+#if 1
+	// clear all the MIB ctr regs
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG_EXT,
+			 EXT_CONFIG_CLEAR);
+	read_mib_counters(gp);
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG_EXT,
+			 EXT_CONFIG_CLEAR | pcxrMIBclrMode);
+
+#endif
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Config Ext=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG_EXT));
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Command=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_COMMAND));
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_COMMAND, 0x0);
+
+	netif_start_queue(dev);
+
+	/* enable the port */
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG,
+			 (PORT_CONFIG | pcrEN));
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG));
+#if 1
+	// start Rx DMA
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, sdcmrERD);
+#endif
+
+
+	// enable interrupts
+	enable_ether_irq(dev);
+
+//---    gp->last_psr |= psrLink;   /* KLUDGE ALERT */
+
+	// we should now be receiving frames
+	return 0;
+}
+
+
+static int gt64240_open(struct net_device *dev)
+{
+	int retval;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_open: dev=%p\n", dev->name, dev);
+
+	if ((retval = request_irq(dev->irq, &gt64240_interrupt,
+				  SA_SHIRQ, dev->name, dev))) {
+		printk("%s: unable to get IRQ %d\n", dev->name, dev->irq);
+
+		return retval;
+	}
+	// Initialize and startup the GT-64240 ethernet port
+	if ((retval = gt64240_init(dev))) {
+		printk("%s: error in gt64240_open\n", dev->name);
+		free_irq(dev->irq, dev);
+
+		return retval;
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_open: Initialization done.\n",
+		       dev->name);
+
+	return 0;
+}
+
+static int gt64240_close(struct net_device *dev)
+{
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_close: dev=%p\n", dev->name, dev);
+
+	// stop the device
+	if (netif_device_present(dev)) {
+		netif_stop_queue(dev);
+		hard_stop(dev);
+	}
+
+	free_irq(dev->irq, dev);
+
+	return 0;
+}
+
+#ifdef GT64240_NAPI
+/*
+ * Function will release Tx skbs which are now complete
+ */
+static void gt64240_tx_fill(struct net_device *dev, u32 status)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int nextOut, cdp;
+	gt64240_td_t *td;
+	u32 cmdstat;
+
+	cdp = (GT64240ETH_READ(gp, GT64240_ETH_CURR_TX_DESC_PTR0)
+	       - gp->tx_ring_dma) / sizeof(gt64240_td_t);
+
+	for (nextOut = gp->tx_next_out; nextOut != cdp;
+	     nextOut = (nextOut + 1) % TX_RING_SIZE) {
+		if (--gp->intr_work_done == 0)
+			break;
+
+		td = &gp->tx_ring[nextOut];
+		cmdstat = td->cmdstat;
+
+		if (cmdstat & (u32) txOwn)
+			break;
+
+		if (gp->tx_full) {
+			gp->tx_full = 0;
+			if (gp->last_psr & psrLink) {
+				netif_wake_queue(dev);
+			}
+		}
+		// decrement tx ring buffer count
+		if (gp->tx_count)
+			gp->tx_count--;
+
+		// free the skb
+		if (gp->tx_skbuff[nextOut]) {
+			dev_kfree_skb_irq(gp->tx_skbuff[nextOut]);
+			gp->tx_skbuff[nextOut] = NULL;
+		}
+	}
+
+	gp->tx_next_out = nextOut;
+
+	if ((status & icrTxEndLow) && gp->tx_count != 0)
+		// we must restart the DMA
+		GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM,
+				 sdcmrERD | sdcmrTXDL);
+}
+
+/*
+ * Main function for NAPI
+ */
+static int gt64240_poll(struct net_device *dev, int *budget)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+	int done = 1, orig_budget, work_done;
+	u32 status = GT64240ETH_READ(gp, GT64240_ETH_INT_CAUSE);
+
+	spin_lock_irqsave(&gp->lock, flags);
+	gt64240_tx_fill(dev, status);
+
+	if (GT64240ETH_READ(gp, GT64240_ETH_CURR_RX_DESC_PTR0) !=
+	    gp->rx_next_out) {
+		orig_budget = *budget;
+		if (orig_budget > dev->quota)
+			orig_budget = dev->quota;
+
+		work_done = gt64240_rx(dev, status, orig_budget);
+		*budget -= work_done;
+		dev->quota -= work_done;
+		if (work_done >= orig_budget)
+			done = 0;
+		if (done) {
+			__netif_rx_complete(dev);
+			enable_ether_irq(dev);
+		}
+	}
+
+	spin_unlock_irqrestore(&gp->lock, flags);
+
+	return (done ? 0 : 1);
+}
+#endif
+
+static int gt64240_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+	int nextIn;
+
+	spin_lock_irqsave(&gp->lock, flags);
+
+	nextIn = gp->tx_next_in;
+
+	if (gt64240_debug > 3) {
+		printk("%s: gt64240_tx: nextIn=%d.\n", dev->name, nextIn);
+	}
+
+	if (gp->tx_count >= TX_RING_SIZE) {
+		printk("%s: Tx Ring full, pkt dropped.\n", dev->name);
+		gp->stats.tx_dropped++;
+		spin_unlock_irqrestore(&gp->lock, flags);
+		return 1;
+	}
+
+	if (!(gp->last_psr & psrLink)) {
+		printk("%s: gt64240_tx: Link down, pkt dropped.\n",
+		       dev->name);
+		gp->stats.tx_dropped++;
+		spin_unlock_irqrestore(&gp->lock, flags);
+//---   dump_MII(dev);          /* KLUDGE ALERT !!! */
+		return 1;
+	}
+
+	if (gp->tx_ring[nextIn].cmdstat & txOwn) {
+		printk
+		    ("%s: gt64240_tx: device owns descriptor, pkt dropped.\n",
+		     dev->name);
+		gp->stats.tx_dropped++;
+		// stop the queue, so Tx timeout can fix it
+		netif_stop_queue(dev);
+		spin_unlock_irqrestore(&gp->lock, flags);
+		return 1;
+	}
+	// Prepare the Descriptor at tx_next_in
+	gp->tx_skbuff[nextIn] = skb;
+	gp->tx_ring[nextIn].byte_cnt = skb->len;
+	gp->tx_ring[nextIn].buff_ptr = virt_to_phys(skb->data);
+
+	// make sure packet gets written back to memory
+	dma_cache_wback_inv((unsigned long) (skb->data), skb->len);
+	mb();
+
+	// Give ownership to device, set first and last desc, enable interrupt
+	// Setting of ownership bit must be *last*!
+	gp->tx_ring[nextIn].cmdstat =
+	    txOwn | txGenCRC | txEI | txPad | txFirst | txLast;
+
+	if (gt64240_debug > 5) {
+		dump_tx_desc(dev, nextIn);
+	}
+	// increment tx_next_in with wrap
+	gp->tx_next_in = (nextIn + 1) % TX_RING_SIZE;
+
+//+prk20aug01:
+	if (0) {		/* ROLLINS */
+		GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0,
+				 virt_to_phys(&gp->tx_ring[nextIn]));
+	}
+
+	if (gt64240_debug > 3) {	/*+prk17aug01 */
+		printk
+		    ("%s: gt64240_tx: TX_PTR0=0x%08x, EthPortStatus=0x%08x\n",
+		     dev->name, GT64240ETH_READ(gp,
+						GT64240_ETH_CURR_TX_DESC_PTR0),
+		     GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS));
+	}
+	// If DMA is stopped, restart
+	if (!((GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS)) & psrTxLow)) {
+		GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM,
+				 sdcmrERD | sdcmrTXDL);
+	}
+
+	if (gt64240_debug > 3) {	/*+prk17aug01 */
+		printk
+		    ("%s: gt64240_tx: TX_PTR0=0x%08x, EthPortStatus=0x%08x\n",
+		     dev->name, GT64240ETH_READ(gp,
+						GT64240_ETH_CURR_TX_DESC_PTR0),
+		     GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS));
+	}
+	// increment count and stop queue if full
+	if (++gp->tx_count >= TX_RING_SIZE) {
+		gp->tx_full = 1;
+		netif_stop_queue(dev);
+	}
+
+	dev->trans_start = jiffies;
+	spin_unlock_irqrestore(&gp->lock, flags);
+
+	return 0;
+}
+
+
+static int
+#ifdef GT64240_NAPI
+gt64240_rx(struct net_device *dev, u32 status, int budget)
+#else
+gt64240_rx(struct net_device *dev, u32 status)
+#endif
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	struct sk_buff *skb;
+	int pkt_len, nextOut, cdp;
+	gt64240_rd_t *rd;
+	u32 cmdstat;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_rx: dev=%p, status=%x\n",
+		       dev->name, dev, status);
+
+	cdp = (GT64240ETH_READ(gp, GT64240_ETH_CURR_RX_DESC_PTR0)
+	       - gp->rx_ring_dma) / sizeof(gt64240_rd_t);
+
+	// Continue until we reach the current descriptor pointer
+	for (nextOut = gp->rx_next_out; nextOut != cdp;
+	     nextOut = (nextOut + 1) % RX_RING_SIZE) {
+
+#ifdef GT64240_NAPI
+		if (budget <= 0)
+			break;
+
+		budget--;
+#endif
+
+		if (--gp->intr_work_done == 0)
+			break;
+
+		if (gt64240_debug > 4)
+			dump_rx_desc(dev, nextOut);
+
+		rd = &gp->rx_ring[nextOut];
+		cmdstat = rd->cmdstat;
+
+		if (gt64240_debug > 3)
+			printk("%s: isr: Rx desc cmdstat=%x, nextOut=%d\n",
+			       dev->name, cmdstat, nextOut);
+
+		if (cmdstat & (u32) rxOwn) {
+			if (gt64240_debug > 2)
+				printk
+				    ("%s: gt64240_rx: device owns descriptor!\n",
+				     dev->name);
+			// DMA is not finished updating descriptor???
+			// Leave and come back later to pick-up where we left off.
+			break;
+		}
+		// must be first and last (ie only) buffer of packet
+		if (!(cmdstat & (u32) rxFirst)
+		    || !(cmdstat & (u32) rxLast)) {
+			printk
+			    ("%s: gt64240_rx: desc not first and last!\n",
+			     dev->name);
+			cmdstat |= (u32) rxOwn;
+			rd->cmdstat = cmdstat;
+			continue;
+		}
+		// Drop this received pkt if there were any errors
+		if ((cmdstat & (u32) rxErrorSummary)
+		    || (status & icrRxError)) {
+			// update the detailed rx error counters that are not covered
+			// by the MIB counters.
+			if (cmdstat & (u32) rxOverrun)
+				gp->stats.rx_fifo_errors++;
+			cmdstat |= (u32) rxOwn;
+			rd->cmdstat = cmdstat;
+			continue;
+		}
+
+		pkt_len = rd->byte_cnt;
+
+		/* Create new skb. */
+//      skb = dev_alloc_skb(pkt_len+2);
+		skb = dev_alloc_skb(1538);
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n",
+			       dev->name);
+			gp->stats.rx_dropped++;
+			cmdstat |= (u32) rxOwn;
+			rd->cmdstat = cmdstat;
+			continue;
+		}
+		skb->dev = dev;
+		skb_reserve(skb, 2);	/* 16 byte IP header align */
+		memcpy(skb_put(skb, pkt_len),
+		       &gp->rx_buff[nextOut * PKT_BUF_SZ], pkt_len);
+		skb->protocol = eth_type_trans(skb, dev);
+
+		/* NIC performed some checksum computation */
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+#ifdef GT64240_NAPI
+		netif_receive_skb(skb);
+#else
+		netif_rx(skb);	/* pass the packet to upper layers */
+#endif
+
+		// now we can release ownership of this desc back to device
+		cmdstat |= (u32) rxOwn;
+		rd->cmdstat = cmdstat;
+
+		dev->last_rx = jiffies;
+	}
+
+	if (gt64240_debug > 3 && nextOut == gp->rx_next_out)
+		printk("%s: gt64240_rx: RxCDP did not increment?\n",
+		       dev->name);
+
+	gp->rx_next_out = nextOut;
+	return 0;
+}
+
+
+static void gt64240_tx_timeout(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&gp->lock, flags);
+
+
+	if (!(gp->last_psr & psrLink)) {
+		spin_unlock_irqrestore(&gp->lock, flags);
+	} else {
+		printk("======------> gt64240_tx_timeout: %d jiffies \n",
+		       GT64240ETH_TX_TIMEOUT);
+
+		disable_ether_irq(dev);
+		spin_unlock_irqrestore(&gp->lock, flags);
+		reset_tx(dev);
+		enable_ether_irq(dev);
+
+		netif_wake_queue(dev);
+	}
+}
+
+
+static void gt64240_set_rx_mode(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+	struct dev_mc_list *mcptr;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_set_rx_mode: dev=%p, flags=%x\n",
+		       dev->name, dev, dev->flags);
+
+	// stop the Receiver DMA
+	abort(dev, sdcmrAR);
+
+	spin_lock_irqsave(&gp->lock, flags);
+
+	if (dev->flags & IFF_PROMISC)
+		GT64240ETH_SETBIT(gp, GT64240_ETH_PORT_CONFIG, pcrPM);
+	else
+		GT64240ETH_CLRBIT(gp, GT64240_ETH_PORT_CONFIG, pcrPM);
+/*
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG,
+		(PORT_CONFIG | pcrPM | pcrEN));
+*/
+
+	memset(gp->hash_table, 0, RX_HASH_TABLE_SIZE);	// clear hash table
+	// Add our ethernet address
+	gt64240_add_hash_entry(dev, dev->dev_addr);
+	if (dev->mc_count) {
+		for (mcptr = dev->mc_list; mcptr; mcptr = mcptr->next) {
+			if (gt64240_debug > 2) {
+				printk("%s: gt64240_set_rx_mode: addr=\n",
+				       dev->name);
+				dump_hw_addr(mcptr->dmi_addr);
+			}
+			gt64240_add_hash_entry(dev, mcptr->dmi_addr);
+		}
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_set_rx: Port Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG));
+
+	// restart Rx DMA
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, sdcmrERD);
+
+	spin_unlock_irqrestore(&gp->lock, flags);
+}
+
+static struct net_device_stats *gt64240_get_stats(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_get_stats: dev=%p\n", dev->name, dev);
+
+	if (netif_device_present(dev)) {
+		spin_lock_irqsave(&gp->lock, flags);
+		update_stats(gp);
+		spin_unlock_irqrestore(&gp->lock, flags);
+	}
+
+	return &gp->stats;
+}
diff -Naur linux-2.6.14/drivers/net/gt64240eth.h linux-mips-2.6.14.orig/drivers/net/gt64240eth.h
--- linux-2.6.14/drivers/net/gt64240eth.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/gt64240eth.h	2005-11-17 11:43:10.000000000 -0800
@@ -9,6 +9,7 @@
  * Copyright 2000 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
  *         	stevel@mvista.com or support@mvista.com
+ * Copyright 2004, 05 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -31,6 +32,7 @@
 #ifndef _GT64240ETH_H
 #define _GT64240ETH_H
 
+#include <linux/config.h>
 #include <asm/gt64240.h>
 
 #define ETHERNET_PORTS_DIFFERENCE_OFFSETS	0x400
@@ -108,10 +110,10 @@
 #define REV_GT64240A 0x10
 
 #define GT64240ETH_READ(gp, offset)					\
-	GT_READ((gp)->port_offset + (offset))
+	MV_READ((gp)->port_offset + (offset))
 
 #define GT64240ETH_WRITE(gp, offset, data)				\
-	GT_WRITE((gp)->port_offset + (offset), (data))
+	MV_WRITE((gp)->port_offset + (offset), (data))
 
 #define GT64240ETH_SETBIT(gp, offset, bits)				\
 	GT64240ETH_WRITE((gp), (offset),				\
@@ -121,8 +123,8 @@
 	GT64240ETH_WRITE((gp), (offset),				\
 	                 GT64240ETH_READ((gp), (offset)) & ~(bits))
 
-#define GT64240_READ(ofs)		GT_READ(ofs)
-#define GT64240_WRITE(ofs, data)	GT_WRITE((ofs), (data))
+#define GT64240_READ(ofs)		MV_READ(ofs)
+#define GT64240_WRITE(ofs, data)	MV_WRITE((ofs), (data))
 
 /* Bit definitions of the SMI Reg */
 enum {
diff -Naur linux-2.6.14/drivers/net/ioc3-eth.c linux-mips-2.6.14.orig/drivers/net/ioc3-eth.c
--- linux-2.6.14/drivers/net/ioc3-eth.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/ioc3-eth.c	2005-11-17 11:43:10.000000000 -0800
@@ -46,10 +46,12 @@
 #include <linux/udp.h>
 
 #ifdef CONFIG_SERIAL_8250
-#include <linux/serial.h>
-#include <asm/serial.h>
-#define IOC3_BAUD (22000000 / (3*16))
-#define IOC3_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#include <linux/serial_core.h>
+
+/*
+ * Bloody function has no prototype in headers ...
+ */
+extern int serial8250_register_port(struct uart_port *port);
 #endif
 
 #include <linux/netdevice.h>
@@ -1146,12 +1148,11 @@
  * around ioc3 oddities in this respect.
  *
  * The IOC3 serials use a 22MHz clock rate with an additional divider by 3.
- * (IOC3_BAUD = (22000000 / (3*16)))
  */
 
 static void __devinit ioc3_serial_probe(struct pci_dev *pdev, struct ioc3 *ioc3)
 {
-	struct serial_struct req;
+	struct uart_port port;
 
 	/*
 	 * We need to recognice and treat the fourth MENET serial as it
@@ -1165,20 +1166,25 @@
 	if (ioc3_is_menet(pdev) && PCI_SLOT(pdev->devfn) == 3)
 		return;
 
-	/* Register to interrupt zero because we share the interrupt with
-	   the serial driver which we don't properly support yet.  */
-	memset(&req, 0, sizeof(req));
-	req.irq             = 0;
-	req.flags           = IOC3_COM_FLAGS;
-	req.io_type         = SERIAL_IO_MEM;
-	req.iomem_reg_shift = 0;
-	req.baud_base       = IOC3_BAUD;
+	/*
+	 * Register to interrupt zero because we share the interrupt with
+	 * the serial driver which we don't properly support yet.
+	 *
+	 * Can't use UPF_IOREMAP as the whole of IOC3 resources have already
+	 * been registered.
+	 */
+	memset(&port, 0, sizeof(port));
+	port.irq      = 0;
+	port.flags    = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;
+	port.iotype   = UPIO_MEM;
+	port.regshift = 0;
+	port.uartclk  = 22000000 / 3;
 
-	req.iomem_base      = (unsigned char *) &ioc3->sregs.uarta;
-	register_serial(&req);
+	port.membase  = (unsigned char *) &ioc3->sregs.uarta;
+	serial8250_register_port(&port);
 
-	req.iomem_base      = (unsigned char *) &ioc3->sregs.uartb;
-	register_serial(&req);
+	port.membase  = (unsigned char *) &ioc3->sregs.uartb;
+	serial8250_register_port(&port);
 }
 #endif
 
diff -Naur linux-2.6.14/drivers/net/Kconfig linux-mips-2.6.14.orig/drivers/net/Kconfig
--- linux-2.6.14/drivers/net/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/Kconfig	2005-11-17 11:43:09.000000000 -0800
@@ -427,6 +427,14 @@
 	  This is the driver for the onboard card of MIPS Magnum 4000,
 	  Acer PICA, Olivetti M700-10 and a few other identical OEM systems.
 
+config GALILEO_64240_ETH
+	tristate "Galileo GT64240 Ethernet support"
+	depends on NET_ETHERNET && MOMENCO_OCELOT_G
+	select MII
+	help
+	  This is the driver for the ethernet interfaces integrated into
+	  the Galileo (now Marvell) GT64240 chipset.
+
 config MIPS_GT96100ETH
 	bool "MIPS GT96100 Ethernet support"
 	depends on NET_ETHERNET && MIPS_GT96100
@@ -441,10 +449,6 @@
 	  If you have an Alchemy Semi AU1X00 based system
 	  say Y.  Otherwise, say N.
 
-config NET_SB1250_MAC
-	tristate "SB1250 Ethernet support"
-	depends on NET_ETHERNET && SIBYTE_SB1xxx_SOC
-
 config SGI_IOC3_ETH
 	bool "SGI IOC3 Ethernet"
 	depends on NET_ETHERNET && PCI && SGI_IP27 && BROKEN
@@ -475,6 +479,14 @@
 	  the moment only acceleration of IPv4 is supported.  This option
 	  enables offloading for checksums on transmit.  If unsure, say Y.
 
+config MIPS_SIM_NET
+	tristate "MIPS simulator Network device (EXPERIMENTAL)"
+	depends on NETDEVICES && MIPS_SIM && EXPERIMENTAL
+	help
+	  The MIPSNET device is a simple Ethernet network device which is
+	  emulated by the MIPS Simulator.
+	  If you are not using a MIPSsim or are unsure, say N.
+
 config SGI_O2MACE_ETH
 	tristate "SGI O2 MACE Fast Ethernet support"
 	depends on NET_ETHERNET && SGI_IP32=y
@@ -1929,6 +1941,10 @@
 
 	  If in doubt, say N.
 
+config NET_SB1250_MAC
+	tristate "SB1250 Ethernet support"
+	depends on SIBYTE_SB1xxx_SOC
+
 config R8169_VLAN
 	bool "VLAN support"
 	depends on R8169 && VLAN_8021Q
@@ -2096,8 +2112,8 @@
 	depends on MOMENCO_OCELOT_C || MOMENCO_JAGUAR_ATX || MV64360 || MOMENCO_OCELOT_3 || PPC_MULTIPLATFORM
 	help
 	  This driver supports the gigabit Ethernet on the Marvell MV643XX
-	  chipset which is used in the Momenco Ocelot C and Jaguar ATX and
-	  Pegasos II, amongst other PPC and MIPS boards.
+	  chipset which is used in the Momenco Ocelot C Ocelot, Jaguar ATX
+	  and Pegasos II, amongst other PPC and MIPS boards.
 
 config MV643XX_ETH_0
 	bool "MV-643XX Port 0"
@@ -2120,6 +2136,20 @@
 	  This enables support for Port 2 of the Marvell MV643XX Gigabit
 	  Ethernet.
 
+config BIG_SUR_FE
+	bool "PMC-Sierra TITAN Fast Ethernet Support"
+	depends on NET_ETHERNET && PMC_BIG_SUR
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Big Sur SoC.
+
+config TITAN_GE
+	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
+	depends on PMC_YOSEMITE
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Titan SoC.
+
 endmenu
 
 #
diff -Naur linux-2.6.14/drivers/net/Makefile linux-mips-2.6.14.orig/drivers/net/Makefile
--- linux-2.6.14/drivers/net/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/Makefile	2005-11-17 11:43:09.000000000 -0800
@@ -106,6 +106,11 @@
 
 obj-$(CONFIG_MV643XX_ETH) += mv643xx_eth.o
 
+obj-$(CONFIG_GALILEO_64240_ETH) += gt64240eth.o
+obj-$(CONFIG_MV64340_ETH) += mv64340_eth.o
+obj-$(CONFIG_BIG_SUR_FE) += big_sur_ge.o
+obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
+
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
@@ -166,6 +171,7 @@
 obj-$(CONFIG_MIPS_JAZZ_SONIC) += jazzsonic.o
 obj-$(CONFIG_MIPS_GT96100ETH) += gt96100eth.o
 obj-$(CONFIG_MIPS_AU1X00_ENET) += au1000_eth.o
+obj-$(CONFIG_MIPS_SIM_NET) += mipsnet.o
 obj-$(CONFIG_SGI_IOC3_ETH) += ioc3-eth.o
 obj-$(CONFIG_DECLANCE) += declance.o
 obj-$(CONFIG_ATARILANCE) += atarilance.o
diff -Naur linux-2.6.14/drivers/net/mipsnet.c linux-mips-2.6.14.orig/drivers/net/mipsnet.c
--- linux-2.6.14/drivers/net/mipsnet.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/mipsnet.c	2005-11-17 11:43:11.000000000 -0800
@@ -0,0 +1,371 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#define DEBUG
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+#include <linux/etherdevice.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+#include <asm/mips-boards/simint.h>
+
+#include "mipsnet.h"		/* actual device IO mapping */
+
+#define MIPSNET_VERSION "2005-06-20"
+
+#define mipsnet_reg_address(dev, field) (dev->base_addr + field_offset(field))
+
+struct mipsnet_priv {
+	struct net_device_stats stats;
+};
+
+static struct platform_device *mips_plat_dev;
+
+static char mipsnet_string[] = "mipsnet";
+
+/*
+ * Copy data from the MIPSNET rx data port
+ */
+static int ioiocpy_frommipsnet(struct net_device *dev, unsigned char *kdata,
+			int len)
+{
+	uint32_t available_len = inl(mipsnet_reg_address(dev, rxDataCount));
+	if (available_len < len)
+		return -EFAULT;
+
+	for (; len > 0; len--, kdata++) {
+		*kdata = inb(mipsnet_reg_address(dev, rxDataBuffer));
+	}
+
+	return inl(mipsnet_reg_address(dev, rxDataCount));
+}
+
+static inline ssize_t mipsnet_put_todevice(struct net_device *dev,
+	struct sk_buff *skb)
+{
+	int count_to_go = skb->len;
+	char *buf_ptr = skb->data;
+	struct mipsnet_priv *mp = netdev_priv(dev);
+
+	pr_debug("%s: %s(): telling MIPSNET txDataCount(%d)\n",
+	         dev->name, __FUNCTION__, skb->len);
+
+	outl(skb->len, mipsnet_reg_address(dev, txDataCount));
+
+	pr_debug("%s: %s(): sending data to MIPSNET txDataBuffer(%d)\n",
+	         dev->name, __FUNCTION__, skb->len);
+
+	for (; count_to_go; buf_ptr++, count_to_go--) {
+		outb(*buf_ptr, mipsnet_reg_address(dev, txDataBuffer));
+	}
+
+	mp->stats.tx_packets++;
+	mp->stats.tx_bytes += skb->len;
+
+	return skb->len;
+}
+
+static int mipsnet_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	pr_debug("%s:%s(): transmitting %d bytes\n",
+	         dev->name, __FUNCTION__, skb->len);
+
+	/* Only one packet at a time. Once TXDONE interrupt is serviced, the
+	 * queue will be restarted.
+	 */
+	netif_stop_queue(dev);
+	mipsnet_put_todevice(dev, skb);
+
+	return 0;
+}
+
+static inline ssize_t mipsnet_get_fromdev(struct net_device *dev, size_t count)
+{
+	struct sk_buff *skb;
+	size_t len = count;
+	struct mipsnet_priv *mp = netdev_priv(dev);
+
+	if (!(skb = alloc_skb(len + 2, GFP_KERNEL))) {
+		mp->stats.rx_dropped++;
+		return -ENOMEM;
+	}
+
+	skb_reserve(skb, 2);
+	if (ioiocpy_frommipsnet(dev, skb_put(skb, len), len))
+		return -EFAULT;
+
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	pr_debug("%s:%s(): pushing RXed data to kernel\n",
+	         dev->name, __FUNCTION__);
+	netif_rx(skb);
+
+	mp->stats.rx_packets++;
+	mp->stats.rx_bytes += len;
+
+	return count;
+}
+
+static irqreturn_t
+mipsnet_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev = dev_id;
+
+	irqreturn_t retval = IRQ_NONE;
+	uint64_t interruptFlags;
+
+	if (irq == dev->irq) {
+		pr_debug("%s:%s(): irq %d for device\n",
+		         dev->name, __FUNCTION__, irq);
+
+		retval = IRQ_HANDLED;
+
+		interruptFlags =
+		    inl(mipsnet_reg_address(dev, interruptControl));
+		pr_debug("%s:%s(): intCtl=0x%016llx\n", dev->name,
+		         __FUNCTION__, interruptFlags);
+
+		if (interruptFlags & MIPSNET_INTCTL_TXDONE) {
+			pr_debug("%s:%s(): got TXDone\n",
+			         dev->name, __FUNCTION__);
+			outl(MIPSNET_INTCTL_TXDONE,
+			     mipsnet_reg_address(dev, interruptControl));
+			// only one packet at a time, we are done.
+			netif_wake_queue(dev);
+		} else if (interruptFlags & MIPSNET_INTCTL_RXDONE) {
+			pr_debug("%s:%s(): got RX data\n",
+			         dev->name, __FUNCTION__);
+			mipsnet_get_fromdev(dev,
+			            inl(mipsnet_reg_address(dev, rxDataCount)));
+			pr_debug("%s:%s(): clearing RX int\n",
+			         dev->name, __FUNCTION__);
+			outl(MIPSNET_INTCTL_RXDONE,
+			     mipsnet_reg_address(dev, interruptControl));
+
+		} else if (interruptFlags & MIPSNET_INTCTL_TESTBIT) {
+			pr_debug("%s:%s(): got test interrupt\n",
+			         dev->name, __FUNCTION__);
+			// TESTBIT is cleared on read.
+			//    And takes effect after a write with 0
+			outl(0, mipsnet_reg_address(dev, interruptControl));
+		} else {
+			pr_debug("%s:%s(): no valid fags 0x%016llx\n",
+			         dev->name, __FUNCTION__, interruptFlags);
+			// Maybe shared IRQ, just ignore, no clearing.
+			retval = IRQ_NONE;
+		}
+
+	} else {
+		printk(KERN_INFO "%s: %s(): irq %d for unknown device\n",
+		       dev->name, __FUNCTION__, irq);
+		retval = IRQ_NONE;
+	}
+	return retval;
+}				//mipsnet_interrupt()
+
+static int mipsnet_open(struct net_device *dev)
+{
+	int err;
+	pr_debug("%s: mipsnet_open\n", dev->name);
+
+	err = request_irq(dev->irq, &mipsnet_interrupt,
+			  SA_SHIRQ, dev->name, (void *) dev);
+
+	if (err) {
+		pr_debug("%s: %s(): can't get irq %d\n",
+		         dev->name, __FUNCTION__, dev->irq);
+		release_region(dev->base_addr, MIPSNET_IO_EXTENT);
+		return err;
+	}
+
+	pr_debug("%s: %s(): got IO region at 0x%04lx and irq %d for dev.\n",
+	         dev->name, __FUNCTION__, dev->base_addr, dev->irq);
+
+
+	netif_start_queue(dev);
+
+	// test interrupt handler
+	outl(MIPSNET_INTCTL_TESTBIT,
+	     mipsnet_reg_address(dev, interruptControl));
+
+
+	return 0;
+}
+
+static int mipsnet_close(struct net_device *dev)
+{
+	pr_debug("%s: %s()\n", dev->name, __FUNCTION__);
+	netif_stop_queue(dev);
+	return 0;
+}
+
+static struct net_device_stats *mipsnet_get_stats(struct net_device *dev)
+{
+	struct mipsnet_priv *mp = netdev_priv(dev);
+
+	return &mp->stats;
+}
+
+static void mipsnet_set_mclist(struct net_device *dev)
+{
+	// we don't do anything
+	return;
+}
+
+static int __init mipsnet_probe(struct device *dev)
+{
+	struct net_device *netdev;
+	int err;
+
+	netdev = alloc_etherdev(sizeof(struct mipsnet_priv));
+	if (!netdev) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	dev_set_drvdata(dev, netdev);
+
+	netdev->open			= mipsnet_open;
+	netdev->stop			= mipsnet_close;
+	netdev->hard_start_xmit		= mipsnet_xmit;
+	netdev->get_stats		= mipsnet_get_stats;
+	netdev->set_multicast_list	= mipsnet_set_mclist;
+
+	/*
+	 * TODO: probe for these or load them from PARAM
+	 */
+	netdev->base_addr = 0x4200;
+	netdev->irq = MIPSCPU_INT_BASE + MIPSCPU_INT_MB0 +
+	              inl(mipsnet_reg_address(netdev, interruptInfo));
+
+	// Get the io region now, get irq on open()
+	if (!request_region(netdev->base_addr, MIPSNET_IO_EXTENT, "mipsnet")) {
+		pr_debug("%s: %s(): IO region {start: 0x%04lux, len: %d} "
+		         "for dev is not availble.\n", netdev->name,
+		         __FUNCTION__, netdev->base_addr, MIPSNET_IO_EXTENT);
+		err = -EBUSY;
+		goto out_free_netdev;
+	}
+
+	/*
+	 * Lacking any better mechanism to allocate a MAC address we use a
+	 * random one ...
+	 */
+	random_ether_addr(netdev->dev_addr);
+
+	err = register_netdev(netdev);
+	if (err) {
+		printk(KERN_ERR "MIPSNet: failed to register netdev.\n");
+		goto out_free_region;
+	}
+
+	return 0;
+
+out_free_region:
+	release_region(netdev->base_addr, MIPSNET_IO_EXTENT);
+
+out_free_netdev:
+	free_netdev(netdev);
+
+out:
+	return err;
+}
+
+static int __devexit mipsnet_device_remove(struct device *device)
+{
+	struct net_device *dev = dev_get_drvdata(device);
+
+	unregister_netdev(dev);
+	release_region(dev->base_addr, MIPSNET_IO_EXTENT);
+	free_netdev(dev);
+	dev_set_drvdata(device, NULL);
+
+	return 0;
+}
+
+static struct device_driver mipsnet_driver = {
+	.name	= mipsnet_string,
+	.bus	= &platform_bus_type,
+	.probe	= mipsnet_probe,
+	.remove	= __devexit_p(mipsnet_device_remove),
+};
+
+static void mipsnet_platform_release(struct device *device)
+{
+	struct platform_device *pldev;
+
+	/* free device */
+	pldev = to_platform_device(device);
+	kfree(pldev);
+}
+
+static int __init mipsnet_init_module(void)
+{
+	struct platform_device *pldev;
+	int err;
+
+	printk(KERN_INFO "MIPSNet Ethernet driver. Version: %s. "
+	       "(c)2005 MIPS Technologies, Inc.\n", MIPSNET_VERSION);
+
+	if (driver_register(&mipsnet_driver)) {
+		printk(KERN_ERR "Driver registration failed\n");
+		err = -ENODEV;
+		goto out;
+	}
+
+        if (!(pldev = kmalloc (sizeof (*pldev), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto out_unregister_driver;
+	}
+
+	memset (pldev, 0, sizeof (*pldev));
+	pldev->name		= mipsnet_string;
+	pldev->id		= 0;
+	pldev->dev.release	= mipsnet_platform_release;
+
+	if (platform_device_register(pldev)) {
+		err = -ENODEV;
+		goto out_free_pldev;
+	}
+
+        if (!pldev->dev.driver) {
+		/*
+		 * The driver was not bound to this device, there was
+                 * no hardware at this address. Unregister it, as the
+		 * release fuction will take care of freeing the
+		 * allocated structure
+		 */
+		platform_device_unregister (pldev);
+	}
+
+	mips_plat_dev		= pldev;
+
+	return 0;
+
+out_free_pldev:
+	kfree(pldev);
+
+out_unregister_driver:
+	driver_unregister(&mipsnet_driver);
+out:
+	return err;
+}
+
+static void __exit mipsnet_exit_module(void)
+{
+	pr_debug("MIPSNet Ethernet driver exiting\n");
+
+	driver_unregister(&mipsnet_driver);
+}
+
+module_init(mipsnet_init_module);
+module_exit(mipsnet_exit_module);
diff -Naur linux-2.6.14/drivers/net/mipsnet.h linux-mips-2.6.14.orig/drivers/net/mipsnet.h
--- linux-2.6.14/drivers/net/mipsnet.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/mipsnet.h	2005-11-17 11:43:11.000000000 -0800
@@ -0,0 +1,127 @@
+//
+// <COPYRIGHT CLASS="1B" YEAR="2005">
+// Unpublished work (c) MIPS Technologies, Inc.  All rights reserved.
+// Unpublished rights reserved under the copyright laws of the U.S.A. and
+//  other countries.
+//
+// PROPRIETARY / SECRET CONFIDENTIAL INFORMATION OF MIPS TECHNOLOGIES, INC.
+// FOR INTERNAL USE ONLY.
+//
+// Under no circumstances (contract or otherwise) may this information be
+// disclosed to, or copied, modified or used by anyone other than employees
+// or contractors of MIPS Technologies having a need to know.
+// </COPYRIGHT>
+//
+//++
+// File: MIPS_Net.h
+//
+// Description:
+//   The definition of the emulated MIPSNET device's interface.
+//
+// Notes: This include file needs to work from a Linux device drivers.
+//
+//--
+//
+
+#ifndef __MIPSNET_H
+#define __MIPSNET_H
+
+/*
+ *  Id of this Net device, as seen by the core.
+ */
+#define MIPS_NET_DEV_ID ((uint64_t)           \
+	                     ((uint64_t)'M'<< 0)| \
+	                     ((uint64_t)'I'<< 8)| \
+	                     ((uint64_t)'P'<<16)| \
+	                     ((uint64_t)'S'<<24)| \
+	                     ((uint64_t)'N'<<32)| \
+	                     ((uint64_t)'E'<<40)| \
+	                     ((uint64_t)'T'<<48)| \
+	                     ((uint64_t)'0'<<56))
+
+/*
+ * Net status/control block as seen by sw in the core.
+ * (Why not use bit fields? can't be bothered with cross-platform struct
+ *  packing.)
+ */
+typedef struct _net_control_block {
+	/// dev info for probing
+	///  reads as MIPSNET%d where %d is some form of version
+	uint64_t devId;		/*0x00 */
+
+	/*
+	 * read only busy flag.
+	 * Set and cleared by the Net Device to indicate that an rx or a tx
+	 * is in progress.
+	 */
+	uint32_t busy;		/*0x08 */
+
+	/*
+	 * Set by the Net Device.
+	 * The device will set it once data has been received.
+	 * The value is the number of bytes that should be read from
+	 * rxDataBuffer.  The value will decrease till 0 until all the data
+	 * from rxDataBuffer has been read.
+	 */
+	uint32_t rxDataCount;	/*0x0c */
+#define MIPSNET_MAX_RXTX_DATACOUNT (1<<16)
+
+	/*
+	 * Settable from the MIPS core, cleared by the Net Device.
+	 * The core should set the number of bytes it wants to send,
+	 *   then it should write those bytes of data to txDataBuffer.
+	 * The device will clear txDataCount has been processed (not necessarily sent).
+	 */
+	uint32_t txDataCount;	/*0x10 */
+
+	/*
+	 * Interrupt control
+	 *
+	 * Used to clear the interrupted generated by this dev.
+	 * Write a 1 to clear the interrupt. (except bit31).
+	 *
+	 * Bit0 is set if it was a tx-done interrupt.
+	 * Bit1 is set when new rx-data is available.
+	 *      Until this bit is cleared there will be no other RXs.
+	 *
+	 * Bit31 is used for testing, it clears after a read.
+	 *    Writing 1 to this bit will cause an interrupt to be generated.
+	 *    To clear the test interrupt, write 0 to this register.
+	 */
+	uint32_t interruptControl;	/*0x14 */
+#define MIPSNET_INTCTL_TXDONE     ((uint32_t)(1<< 0))
+#define MIPSNET_INTCTL_RXDONE     ((uint32_t)(1<< 1))
+#define MIPSNET_INTCTL_TESTBIT    ((uint32_t)(1<<31))
+#define MIPSNET_INTCTL_ALLSOURCES (MIPSNET_INTCTL_TXDONE|MIPSNET_INTCTL_RXDONE|MIPSNET_INTCTL_TESTBIT)
+
+	/*
+	 * Readonly core-specific interrupt info for the device to signal the core.
+	 * The meaning of the contents of this field might change.
+	 */
+	/*###\todo: the whole memIntf interrupt scheme is messy: the device should have
+	 *  no control what so ever of what VPE/register set is being used.
+	 *  The MemIntf should only expose interrupt lines, and something in the
+	 *  config should be responsible for the line<->core/vpe bindings.
+	 */
+	uint32_t interruptInfo;	/*0x18 */
+
+	/*
+	 *  This is where the received data is read out.
+	 *  There is more data to read until rxDataReady is 0.
+	 *  Only 1 byte at this regs offset is used.
+	 */
+	uint32_t rxDataBuffer;	/*0x1c */
+
+	/*
+	 * This is where the data to transmit is written.
+	 * Data should be written for the amount specified in the txDataCount register.
+	 *  Only 1 byte at this regs offset is used.
+	 */
+	uint32_t txDataBuffer;	/*0x20 */
+} MIPS_T_NetControl;
+
+#define MIPSNET_IO_EXTENT 0x40	/* being generous */
+
+#define field_offset(field) ((int)&((MIPS_T_NetControl*)(0))->field)
+
+#endif /* __MIPSNET_H */
diff -Naur linux-2.6.14/drivers/net/ne.c linux-mips-2.6.14.orig/drivers/net/ne.c
--- linux-2.6.14/drivers/net/ne.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/ne.c	2005-11-17 11:43:11.000000000 -0800
@@ -54,6 +54,10 @@
 #include <asm/system.h>
 #include <asm/io.h>
 
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+#include <asm/tx4938/rbtx4938.h>
+#endif
+
 #include "8390.h"
 
 #define DRV_NAME "ne"
@@ -111,6 +115,9 @@
     {"E-LAN100", "E-LAN200", {0x00, 0x00, 0x5d}}, /* Broken ne1000 clones */
     {"PCM-4823", "PCM-4823", {0x00, 0xc0, 0x6c}}, /* Broken Advantech MoBo */
     {"REALTEK", "RTL8019", {0x00, 0x00, 0xe8}}, /* no-name with Realtek chip */
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+    {"RBHMA4X00-RTL8019", "RBHMA4X00/RTL8019", {0x00, 0x60, 0x0a}},  /* Toshiba built-in */
+#endif
     {"LCS-8834", "LCS-8836", {0x04, 0x04, 0x37}}, /* ShinyNet (SET) */
     {NULL,}
 };
@@ -226,6 +233,10 @@
 	sprintf(dev->name, "eth%d", unit);
 	netdev_boot_setup_check(dev);
 
+#ifdef CONFIG_TOSHIBA_RBTX4938
+	dev->base_addr = 0x07f20280;
+	dev->irq = RBTX4938_RTL_8019_IRQ;
+#endif
 	err = do_ne_probe(dev);
 	if (err)
 		goto out;
@@ -506,6 +517,10 @@
 	ei_status.name = name;
 	ei_status.tx_start_page = start_page;
 	ei_status.stop_page = stop_page;
+#if defined(CONFIG_TOSHIBA_RBTX4927) || defined(CONFIG_TOSHIBA_RBTX4938)
+	wordlength = 1;
+#endif
+
 #ifdef CONFIG_PLAT_OAKS32R
 	ei_status.word16 = 0;
 #else
diff -Naur linux-2.6.14/drivers/net/saa9730.c linux-mips-2.6.14.orig/drivers/net/saa9730.c
--- linux-2.6.14/drivers/net/saa9730.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/saa9730.c	2005-11-17 11:43:11.000000000 -0800
@@ -1,8 +1,7 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- *
- * ########################################################################
+ * Copyright (C) 2000, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -17,15 +16,13 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
  *
- * ########################################################################
- *
  * SAA9730 ethernet driver.
  *
  * Changes:
- * Angelo Dell'Aera <buffer@antifork.org> : Conversion to the new PCI API (pci_driver).
- *                                          Conversion to spinlocks.
- *                                          Error handling fixes.
- *                                           
+ * Angelo Dell'Aera <buffer@antifork.org> :	Conversion to the new PCI API
+ *						(pci_driver).
+ *						Conversion to spinlocks.
+ *						Error handling fixes.
  */
 
 #include <linux/init.h>
@@ -36,8 +33,11 @@
 #include <linux/skbuff.h>
 #include <linux/pci.h>
 #include <linux/spinlock.h>
+#include <linux/types.h>
 
 #include <asm/addrspace.h>
+#include <asm/io.h>
+
 #include <asm/mips-boards/prom.h>
 
 #include "saa9730.h"
@@ -51,8 +51,8 @@
 #define DRV_MODULE_NAME "saa9730"
 
 static struct pci_device_id saa9730_pci_tbl[] = {
-	{ PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA9370,
-          PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA9730,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{ 0, }
 };
 
@@ -61,8 +61,8 @@
 /* Non-zero only if the current card is a PCI with BIOS-set IRQ. */
 static unsigned int pci_irq_line;
 
-#define INL(a)     inl((unsigned long)a)
-#define OUTL(x,a)  outl(x,(unsigned long)a)
+#define INL(a)		readl(a)
+#define OUTL(x, a)	writel(x, a)
 
 static void evm_saa9730_enable_lan_int(struct lan_saa9730_private *lp)
 {
@@ -98,13 +98,13 @@
 	     &lp->evm_saa9730_regs->InterruptBlock1);
 }
 
-static void show_saa9730_regs(struct lan_saa9730_private *lp)
+static void __attribute_used__ show_saa9730_regs(struct lan_saa9730_private *lp)
 {
 	int i, j;
-	printk("TxmBufferA = %x\n", lp->TxmBuffer[0][0]);
-	printk("TxmBufferB = %x\n", lp->TxmBuffer[1][0]);
-	printk("RcvBufferA = %x\n", lp->RcvBuffer[0][0]);
-	printk("RcvBufferB = %x\n", lp->RcvBuffer[1][0]);
+	printk("TxmBufferA = %p\n", lp->TxmBuffer[0][0]);
+	printk("TxmBufferB = %p\n", lp->TxmBuffer[1][0]);
+	printk("RcvBufferA = %p\n", lp->RcvBuffer[0][0]);
+	printk("RcvBufferB = %p\n", lp->RcvBuffer[1][0]);
 	for (i = 0; i < LAN_SAA9730_BUFFERS; i++) {
 		for (j = 0; j < LAN_SAA9730_TXM_Q_SIZE; j++) {
 			printk("TxmBuffer[%d][%d] = %x\n", i, j,
@@ -214,88 +214,95 @@
 	}
 }
 
-static int lan_saa9730_allocate_buffers(struct lan_saa9730_private *lp)
+static void lan_saa9730_free_buffers(struct pci_dev *pdev,
+				     struct lan_saa9730_private *lp)
 {
-	unsigned int mem_size;
-	void *Pa;
-	unsigned int i, j, RcvBufferSize, TxmBufferSize;
-	unsigned int buffer_start;
+	pci_free_consistent(pdev, lp->buffer_size, lp->buffer_start,
+			    lp->dma_addr);
+}
 
-	/* 
-	 * Allocate all RX and TX packets in one chunk. 
-	 * The Rx and Tx packets must be PACKET_SIZE aligned.
-	 */
-	mem_size = ((LAN_SAA9730_RCV_Q_SIZE + LAN_SAA9730_TXM_Q_SIZE) *
-		    LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_BUFFERS) +
-	    LAN_SAA9730_PACKET_SIZE;
-	buffer_start =
-	    (unsigned int) kmalloc(mem_size, GFP_DMA | GFP_KERNEL);
-
-	if (!buffer_start)
-		return -ENOMEM;
-
-	/* 
-	 * Set DMA buffer to kseg1 (uncached).
-	 * Make sure to flush before using it uncached.
-	 */
-	Pa = (void *) KSEG1ADDR((buffer_start + LAN_SAA9730_PACKET_SIZE) &
-				~(LAN_SAA9730_PACKET_SIZE - 1));
-	dma_cache_wback_inv((unsigned long) Pa, mem_size);
+static int lan_saa9730_allocate_buffers(struct pci_dev *pdev,
+					struct lan_saa9730_private *lp)
+{
+	void *Pa;
+	unsigned int i, j, rxoffset, txoffset;
+	int ret;
 
 	/* Initialize buffer space */
-	RcvBufferSize = LAN_SAA9730_PACKET_SIZE;
-	TxmBufferSize = LAN_SAA9730_PACKET_SIZE;
 	lp->DmaRcvPackets = LAN_SAA9730_RCV_Q_SIZE;
 	lp->DmaTxmPackets = LAN_SAA9730_TXM_Q_SIZE;
 
+	/* Initialize Rx Buffer Index */
+	lp->NextRcvPacketIndex = 0;
+	lp->NextRcvBufferIndex = 0;
+
+	/* Set current buffer index & next available packet index */
+	lp->NextTxmPacketIndex = 0;
+	lp->NextTxmBufferIndex = 0;
+	lp->PendingTxmPacketIndex = 0;
+	lp->PendingTxmBufferIndex = 0;
+
+	/*
+	 * Allocate all RX and TX packets in one chunk.
+	 * The Rx and Tx packets must be PACKET_SIZE aligned.
+	 */
+	lp->buffer_size = ((LAN_SAA9730_RCV_Q_SIZE + LAN_SAA9730_TXM_Q_SIZE) *
+			   LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_BUFFERS) +
+			  LAN_SAA9730_PACKET_SIZE;
+	lp->buffer_start = pci_alloc_consistent(pdev, lp->buffer_size,
+						&lp->dma_addr);
+	if (!lp->buffer_start) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	Pa = (void *)ALIGN((unsigned long)lp->buffer_start,
+			   LAN_SAA9730_PACKET_SIZE);
+
+	rxoffset = Pa - lp->buffer_start;
+
 	/* Init RX buffers */
 	for (i = 0; i < LAN_SAA9730_BUFFERS; i++) {
 		for (j = 0; j < LAN_SAA9730_RCV_Q_SIZE; j++) {
 			*(unsigned int *) Pa =
 			    cpu_to_le32(RXSF_READY <<
 					RX_STAT_CTL_OWNER_SHF);
-			lp->RcvBuffer[i][j] = (unsigned int) Pa;
-			Pa += RcvBufferSize;
+			lp->RcvBuffer[i][j] = Pa;
+			Pa += LAN_SAA9730_PACKET_SIZE;
 		}
 	}
 
+	txoffset = Pa - lp->buffer_start;
+
 	/* Init TX buffers */
 	for (i = 0; i < LAN_SAA9730_BUFFERS; i++) {
 		for (j = 0; j < LAN_SAA9730_TXM_Q_SIZE; j++) {
 			*(unsigned int *) Pa =
 			    cpu_to_le32(TXSF_EMPTY <<
 					TX_STAT_CTL_OWNER_SHF);
-			lp->TxmBuffer[i][j] = (unsigned int) Pa;
-			Pa += TxmBufferSize;
+			lp->TxmBuffer[i][j] = Pa;
+			Pa += LAN_SAA9730_PACKET_SIZE;
 		}
 	}
 
-	/* 
-	 * Set rx buffer A and rx buffer B to point to the first two buffer 
+	/*
+	 * Set rx buffer A and rx buffer B to point to the first two buffer
 	 * spaces.
 	 */
-	OUTL(PHYSADDR(lp->RcvBuffer[0][0]),
+	OUTL(lp->dma_addr + rxoffset,
 	     &lp->lan_saa9730_regs->RxBuffA);
-	OUTL(PHYSADDR(lp->RcvBuffer[1][0]),
+	OUTL(lp->dma_addr + rxoffset +
+	     LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_RCV_Q_SIZE,
 	     &lp->lan_saa9730_regs->RxBuffB);
 
-	/* Initialize Buffer Index */
-	lp->NextRcvPacketIndex = 0;
-	lp->NextRcvToUseIsA = 1;
-
-	/* Set current buffer index & next availble packet index */
-	lp->NextTxmPacketIndex = 0;
-	lp->NextTxmBufferIndex = 0;
-	lp->PendingTxmPacketIndex = 0;
-	lp->PendingTxmBufferIndex = 0;
-
-	/* 
+	/*
 	 * Set txm_buf_a and txm_buf_b to point to the first two buffer
-	 * space 
+	 * space
 	 */
-	OUTL(PHYSADDR(lp->TxmBuffer[0][0]),
+	OUTL(lp->dma_addr + txoffset,
 	     &lp->lan_saa9730_regs->TxBuffA);
-	OUTL(PHYSADDR(lp->TxmBuffer[1][0]),
+	OUTL(lp->dma_addr + txoffset +
+	     LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_TXM_Q_SIZE,
 	     &lp->lan_saa9730_regs->TxBuffB);
 
 	/* Set packet number */
@@ -306,6 +313,9 @@
 	     &lp->lan_saa9730_regs->PacketCount);
 
 	return 0;
+
+out:
+	return ret;
 }
 
 static int lan_saa9730_cam_load(struct lan_saa9730_private *lp)
@@ -328,8 +338,7 @@
 
 static int lan_saa9730_cam_init(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned int i;
 
 	/* Copy MAC-address into all entries. */
@@ -469,9 +478,9 @@
 	OUTL(CAM_CONTROL_COMP_EN | CAM_CONTROL_BROAD_ACC,
 	     &lp->lan_saa9730_regs->CamCtl);
 
-	/* 
+	/*
 	 * Initialize CAM enable register, only turn on first entry, should
-	 * contain own addr. 
+	 * contain own addr.
 	 */
 	OUTL(0x0001, &lp->lan_saa9730_regs->CamEnable);
 
@@ -501,7 +510,7 @@
 	OUTL(INL(&lp->lan_saa9730_regs->MacCtl) | MAC_CONTROL_RESET,
 	     &lp->lan_saa9730_regs->MacCtl);
 
-	/* 
+	/*
 	 * Wait for MAC reset to have finished. The reset bit is auto cleared
 	 * when the reset is done.
 	 */
@@ -536,9 +545,9 @@
 
 	/* Initialize Rx Buffer Index */
 	lp->NextRcvPacketIndex = 0;
-	lp->NextRcvToUseIsA = 1;
+	lp->NextRcvBufferIndex = 0;
 
-	/* Set current buffer index & next availble packet index */
+	/* Set current buffer index & next available packet index */
 	lp->NextTxmPacketIndex = 0;
 	lp->NextTxmBufferIndex = 0;
 	lp->PendingTxmPacketIndex = 0;
@@ -555,9 +564,8 @@
 	OUTL(INL(&lp->lan_saa9730_regs->RxCtl) | RX_CTL_RX_EN,
 	     &lp->lan_saa9730_regs->RxCtl);
 
-	/* Set Ok2Use to let hardware owns the buffers */
-	OUTL(OK2USE_RX_A | OK2USE_RX_B | OK2USE_TX_A | OK2USE_TX_B,
-	     &lp->lan_saa9730_regs->Ok2Use);
+	/* Set Ok2Use to let hardware own the buffers.  */
+	OUTL(OK2USE_RX_A | OK2USE_RX_B, &lp->lan_saa9730_regs->Ok2Use);
 
 	return 0;
 }
@@ -572,8 +580,7 @@
 
 static int lan_saa9730_tx(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned int *pPacket;
 	unsigned int tx_status;
 
@@ -584,10 +591,8 @@
 	OUTL(DMA_STATUS_MAC_TX_INT, &lp->lan_saa9730_regs->DmaStatus);
 
 	while (1) {
-		pPacket =
-		    (unsigned int *) lp->TxmBuffer[lp->
-						   PendingTxmBufferIndex]
-		    [lp->PendingTxmPacketIndex];
+		pPacket = lp->TxmBuffer[lp->PendingTxmBufferIndex]
+				       [lp->PendingTxmPacketIndex];
 
 		/* Get status of first packet transmitted. */
 		tx_status = le32_to_cpu(*pPacket);
@@ -605,23 +610,22 @@
 			lp->stats.tx_errors++;
 			if (tx_status &
 			    (TX_STATUS_EX_COLL << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_aborted_errors++;
+				lp->stats.tx_aborted_errors++;
 			if (tx_status &
-			    (TX_STATUS_LATE_COLL <<
-			     TX_STAT_CTL_STATUS_SHF)) lp->stats.
-	     tx_window_errors++;
+			    (TX_STATUS_LATE_COLL << TX_STAT_CTL_STATUS_SHF))
+				lp->stats.tx_window_errors++;
 			if (tx_status &
 			    (TX_STATUS_L_CARR << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_carrier_errors++;
+				lp->stats.tx_carrier_errors++;
 			if (tx_status &
 			    (TX_STATUS_UNDER << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_fifo_errors++;
+				lp->stats.tx_fifo_errors++;
 			if (tx_status &
 			    (TX_STATUS_SQ_ERR << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_heartbeat_errors++;
+				lp->stats.tx_heartbeat_errors++;
 
 			lp->stats.collisions +=
-			    tx_status & TX_STATUS_TX_COLL_MSK;
+				tx_status & TX_STATUS_TX_COLL_MSK;
 		}
 
 		/* Free buffer. */
@@ -636,21 +640,15 @@
 		}
 	}
 
-	/* Make sure A and B are available to hardware. */
-	OUTL(OK2USE_TX_A | OK2USE_TX_B, &lp->lan_saa9730_regs->Ok2Use);
-
-	if (netif_queue_stopped(dev)) {
-		/* The tx buffer is no longer full. */
-		netif_wake_queue(dev);
-	}
+	/* The tx buffer is no longer full. */
+	netif_wake_queue(dev);
 
 	return 0;
 }
 
 static int lan_saa9730_rx(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	int len = 0;
 	struct sk_buff *skb = 0;
 	unsigned int rx_status;
@@ -667,12 +665,9 @@
 	     DMA_STATUS_RX_TO_INT, &lp->lan_saa9730_regs->DmaStatus);
 
 	/* Address next packet */
-	if (lp->NextRcvToUseIsA)
-		BufferIndex = 0;
-	else
-		BufferIndex = 1;
+	BufferIndex = lp->NextRcvBufferIndex;
 	PacketIndex = lp->NextRcvPacketIndex;
-	pPacket = (unsigned int *) lp->RcvBuffer[BufferIndex][PacketIndex];
+	pPacket = lp->RcvBuffer[BufferIndex][PacketIndex];
 	rx_status = le32_to_cpu(*pPacket);
 
 	/* Process each packet. */
@@ -715,51 +710,39 @@
 			lp->stats.rx_errors++;
 			if (rx_status &
 			    (RX_STATUS_CRC_ERR << RX_STAT_CTL_STATUS_SHF))
-				    lp->stats.rx_crc_errors++;
+				lp->stats.rx_crc_errors++;
 			if (rx_status &
-			    (RX_STATUS_ALIGN_ERR <<
-			     RX_STAT_CTL_STATUS_SHF)) lp->stats.
-	     rx_frame_errors++;
+			    (RX_STATUS_ALIGN_ERR << RX_STAT_CTL_STATUS_SHF))
+				lp->stats.rx_frame_errors++;
 			if (rx_status &
 			    (RX_STATUS_OVERFLOW << RX_STAT_CTL_STATUS_SHF))
-				    lp->stats.rx_fifo_errors++;
+				lp->stats.rx_fifo_errors++;
 			if (rx_status &
 			    (RX_STATUS_LONG_ERR << RX_STAT_CTL_STATUS_SHF))
-				    lp->stats.rx_length_errors++;
+				lp->stats.rx_length_errors++;
 		}
 
 		/* Indicate we have processed the buffer. */
-		*pPacket =
-		    cpu_to_le32(RXSF_READY << RX_STAT_CTL_OWNER_SHF);
+		*pPacket = cpu_to_le32(RXSF_READY << RX_STAT_CTL_OWNER_SHF);
+
+		/* Make sure A or B is available to hardware as appropriate. */
+		OUTL(BufferIndex ? OK2USE_RX_B : OK2USE_RX_A,
+		     &lp->lan_saa9730_regs->Ok2Use);
 
 		/* Go to next packet in sequence. */
 		lp->NextRcvPacketIndex++;
 		if (lp->NextRcvPacketIndex >= LAN_SAA9730_RCV_Q_SIZE) {
 			lp->NextRcvPacketIndex = 0;
-			if (BufferIndex) {
-				lp->NextRcvToUseIsA = 1;
-			} else {
-				lp->NextRcvToUseIsA = 0;
-			}
+			lp->NextRcvBufferIndex ^= 1;
 		}
-		OUTL(OK2USE_RX_A | OK2USE_RX_B,
-		     &lp->lan_saa9730_regs->Ok2Use);
 
 		/* Address next packet */
-		if (lp->NextRcvToUseIsA)
-			BufferIndex = 0;
-		else
-			BufferIndex = 1;
+		BufferIndex = lp->NextRcvBufferIndex;
 		PacketIndex = lp->NextRcvPacketIndex;
-		pPacket =
-		    (unsigned int *) lp->
-		    RcvBuffer[BufferIndex][PacketIndex];
+		pPacket = lp->RcvBuffer[BufferIndex][PacketIndex];
 		rx_status = le32_to_cpu(*pPacket);
 	}
 
-	/* Make sure A and B are available to hardware. */
-	OUTL(OK2USE_RX_A | OK2USE_RX_B, &lp->lan_saa9730_regs->Ok2Use);
-
 	return 0;
 }
 
@@ -767,8 +750,7 @@
 				  struct pt_regs *regs)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	if (lan_saa9730_debug > 5)
 		printk("lan_saa9730_interrupt\n");
@@ -794,15 +776,9 @@
 	return IRQ_HANDLED;
 }
 
-static int lan_saa9730_open_fail(struct net_device *dev)
-{
-	return -ENODEV;
-}
-
 static int lan_saa9730_open(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	/* Associate IRQ with lan_saa9730_interrupt */
 	if (request_irq(dev->irq, &lan_saa9730_interrupt, 0, "SAA9730 Eth",
@@ -834,15 +810,13 @@
 	int PacketIndex;
 
 	if (lan_saa9730_debug > 5)
-		printk("lan_saa9730_write: skb=%08x\n",
-		       (unsigned int) skb);
+		printk("lan_saa9730_write: skb=%p\n", skb);
 
 	BufferIndex = lp->NextTxmBufferIndex;
 	PacketIndex = lp->NextTxmPacketIndex;
 
-	tx_status =
-	    le32_to_cpu(*(unsigned int *) lp->
-			TxmBuffer[BufferIndex][PacketIndex]);
+	tx_status = le32_to_cpu(*(unsigned int *)lp->TxmBuffer[BufferIndex]
+							      [PacketIndex]);
 	if ((tx_status & TX_STAT_CTL_OWNER_MSK) !=
 	    (TXSF_EMPTY << TX_STAT_CTL_OWNER_SHF)) {
 		if (lan_saa9730_debug > 4)
@@ -858,29 +832,29 @@
 		lp->NextTxmBufferIndex ^= 1;
 	}
 
-	pbPacketData =
-	    (unsigned char *) lp->TxmBuffer[BufferIndex][PacketIndex];
+	pbPacketData = lp->TxmBuffer[BufferIndex][PacketIndex];
 	pbPacketData += 4;
 
 	/* copy the bits */
 	memcpy(pbPacketData, pbData, len);
 
 	/* Set transmit status for hardware */
-	*(unsigned int *) lp->TxmBuffer[BufferIndex][PacketIndex] =
-	    cpu_to_le32((TXSF_READY << TX_STAT_CTL_OWNER_SHF) |
-			(TX_STAT_CTL_INT_AFTER_TX << TX_STAT_CTL_FRAME_SHF)
-			| (len << TX_STAT_CTL_LENGTH_SHF));
+	*(unsigned int *)lp->TxmBuffer[BufferIndex][PacketIndex] =
+		cpu_to_le32((TXSF_READY << TX_STAT_CTL_OWNER_SHF) |
+			    (TX_STAT_CTL_INT_AFTER_TX <<
+			     TX_STAT_CTL_FRAME_SHF) |
+			    (len << TX_STAT_CTL_LENGTH_SHF));
 
-	/* Set hardware tx buffer. */
-	OUTL(OK2USE_TX_A | OK2USE_TX_B, &lp->lan_saa9730_regs->Ok2Use);
+	/* Make sure A or B is available to hardware as appropriate. */
+	OUTL(BufferIndex ? OK2USE_TX_B : OK2USE_TX_A,
+	     &lp->lan_saa9730_regs->Ok2Use);
 
 	return 0;
 }
 
 static void lan_saa9730_tx_timeout(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	/* Transmitter timeout, serious problems */
 	lp->stats.tx_errors++;
@@ -889,20 +863,19 @@
 	lan_saa9730_restart(lp);
 
 	dev->trans_start = jiffies;
-	netif_start_queue(dev);
+	netif_wake_queue(dev);
 }
 
 static int lan_saa9730_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned long flags;
 	int skblen;
 	int len;
 
 	if (lan_saa9730_debug > 4)
-		printk("Send packet: skb=%08x\n", (unsigned int) skb);
+		printk("Send packet: skb=%p\n", skb);
 
 	skblen = skb->len;
 
@@ -912,8 +885,7 @@
 
 	if (lan_saa9730_write(lp, skb, skblen)) {
 		spin_unlock_irqrestore(&lp->lock, flags);
-		printk("Error when writing packet to controller: skb=%08x\n",
-		     (unsigned int) skb);
+		printk("Error when writing packet to controller: skb=%p\n", skb);
 		netif_stop_queue(dev);
 		return -1;
 	}
@@ -922,7 +894,7 @@
 	lp->stats.tx_packets++;
 
 	dev->trans_start = jiffies;
-	netif_start_queue(dev);
+	netif_wake_queue(dev);
 	dev_kfree_skb(skb);
 
 	spin_unlock_irqrestore(&lp->lock, flags);
@@ -932,8 +904,7 @@
 
 static int lan_saa9730_close(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	if (lan_saa9730_debug > 1)
 		printk("lan_saa9730_close:\n");
@@ -955,16 +926,14 @@
 static struct net_device_stats *lan_saa9730_get_stats(struct net_device
 						      *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	return &lp->stats;
 }
 
 static void lan_saa9730_set_multicast(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	/* Stop the controller */
 	lan_saa9730_stop(lp);
@@ -981,7 +950,7 @@
 			     CAM_CONTROL_BROAD_ACC,
 			     &lp->lan_saa9730_regs->CamCtl);
 		} else {
-			/* 
+			/*
 			 * Will handle the multicast stuff later. -carstenl
 			 */
 		}
@@ -993,94 +962,86 @@
 
 static void __devexit saa9730_remove_one(struct pci_dev *pdev)
 {
-        struct net_device *dev = pci_get_drvdata(pdev);
-
-        if (dev) {
-                unregister_netdev(dev);
-
-		if (dev->priv)
-			kfree(dev->priv);
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
-                free_netdev(dev);
-                pci_release_regions(pdev);
-                pci_disable_device(pdev);
-                pci_set_drvdata(pdev, NULL);
-        }
+	if (dev) {
+		unregister_netdev(dev);
+		lan_saa9730_free_buffers(pdev, lp);
+		iounmap(lp->lan_saa9730_regs);
+		iounmap(lp->evm_saa9730_regs);
+		free_netdev(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
 }
 
 
-static int lan_saa9730_init(struct net_device *dev, int ioaddr, int irq)
+static int lan_saa9730_init(struct net_device *dev, struct pci_dev *pdev,
+	unsigned long ioaddr, int irq)
 {
-	struct lan_saa9730_private *lp;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned char ethernet_addr[6];
-	int ret = 0;
+	int ret;
 
-	dev->open = lan_saa9730_open_fail;
+	if (get_ethernet_addr(ethernet_addr)) {
+		ret = -ENODEV;
+		goto out;
+	}
 
-	if (get_ethernet_addr(ethernet_addr))
-		return -ENODEV;
-	
 	memcpy(dev->dev_addr, ethernet_addr, 6);
 	dev->base_addr = ioaddr;
 	dev->irq = irq;
-	
-	/* 
-	 * Make certain the data structures used by the controller are aligned 
-	 * and DMAble. 
-	 */
-	/*
-	 *  XXX: that is obviously broken - kfree() won't be happy with us.
-	 */
-	lp = (struct lan_saa9730_private *) (((unsigned long)
-					      kmalloc(sizeof(*lp) + 7,
-						      GFP_DMA | GFP_KERNEL)
-					      + 7) & ~7);
 
-	if (!lp)
-		return -ENOMEM;
-
-	dev->priv = lp;
-	memset(lp, 0, sizeof(*lp));
+	lp->pci_dev = pdev;
 
 	/* Set SAA9730 LAN base address. */
-	lp->lan_saa9730_regs = (t_lan_saa9730_regmap *) (ioaddr +
-							 SAA9730_LAN_REGS_ADDR);
+	lp->lan_saa9730_regs = ioremap(ioaddr + SAA9730_LAN_REGS_ADDR,
+				       SAA9730_LAN_REGS_SIZE);
+	if (!lp->lan_saa9730_regs) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	/* Set SAA9730 EVM base address. */
-	lp->evm_saa9730_regs = (t_evm_saa9730_regmap *) (ioaddr +
-							 SAA9730_EVM_REGS_ADDR);
+	lp->evm_saa9730_regs = ioremap(ioaddr + SAA9730_EVM_REGS_ADDR,
+				       SAA9730_EVM_REGS_SIZE);
+	if (!lp->evm_saa9730_regs) {
+		ret = -ENOMEM;
+		goto out_iounmap_lan;
+	}
 
 	/* Allocate LAN RX/TX frame buffer space. */
-	/* FIXME: a leak */
-	if ((ret = lan_saa9730_allocate_buffers(lp)))
-		goto out;
+	if ((ret = lan_saa9730_allocate_buffers(pdev, lp)))
+		goto out_iounmap;
 
 	/* Stop LAN controller. */
-	if ((ret = lan_saa9730_stop(lp))) 
-		goto out;
-	
+	if ((ret = lan_saa9730_stop(lp)))
+		goto out_free_consistent;
+
 	/* Initialize CAM registers. */
 	if ((ret = lan_saa9730_cam_init(dev)))
-		goto out;
+		goto out_free_consistent;
 
 	/* Initialize MII registers. */
 	if ((ret = lan_saa9730_mii_init(lp)))
-		goto out;
+		goto out_free_consistent;
 
 	/* Initialize control registers. */
-	if ((ret = lan_saa9730_control_init(lp))) 
-		goto out;
-        
+	if ((ret = lan_saa9730_control_init(lp)))
+		goto out_free_consistent;
+
 	/* Load CAM registers. */
-	if ((ret = lan_saa9730_cam_load(lp))) 
-		goto out;
-	
+	if ((ret = lan_saa9730_cam_load(lp)))
+		goto out_free_consistent;
+
 	/* Initialize DMA context registers. */
 	if ((ret = lan_saa9730_dma_init(lp)))
-		goto out;
-	
+		goto out_free_consistent;
+
 	spin_lock_init(&lp->lock);
-		
+
 	dev->open = lan_saa9730_open;
 	dev->hard_start_xmit = lan_saa9730_start_xmit;
 	dev->stop = lan_saa9730_close;
@@ -1089,45 +1050,43 @@
 	dev->tx_timeout = lan_saa9730_tx_timeout;
 	dev->watchdog_timeo = (HZ >> 1);
 	dev->dma = 0;
-	
-	ret = register_netdev(dev);
+
+	ret = register_netdev (dev);
 	if (ret)
-		goto out;
+		goto out_free_consistent;
+
 	return 0;
 
- out:
-	if (dev->priv)
-		kfree(dev->priv);
+out_free_consistent:
+	lan_saa9730_free_buffers(pdev, lp);
+out_iounmap:
+	iounmap(lp->evm_saa9730_regs);
+out_iounmap_lan:
+	iounmap(lp->lan_saa9730_regs);
+out:
 	return ret;
 }
 
 
 static int __devinit saa9730_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	struct net_device *dev;
-	unsigned int pci_ioaddr;
+	struct net_device *dev = NULL;
+	unsigned long pci_ioaddr;
 	int err;
 
 	if (lan_saa9730_debug > 1)
 		printk("saa9730.c: PCI bios is present, checking for devices...\n");
 
-	err = -ENOMEM;
-	dev = alloc_etherdev(0);
-	if (!dev)
-		goto out;
-
-	SET_MODULE_OWNER(dev);
-
 	err = pci_enable_device(pdev);
-        if (err) {
-                printk(KERN_ERR "Cannot enable PCI device, aborting.\n");
-                goto out1;
-        }
+	if (err) {
+		printk(KERN_ERR "Cannot enable PCI device, aborting.\n");
+		goto out;
+	}
 
 	err = pci_request_regions(pdev, DRV_MODULE_NAME);
 	if (err) {
 		printk(KERN_ERR "Cannot obtain PCI resources, aborting.\n");
-		goto out2;
+		goto out_disable_pdev;
 	}
 
 	pci_irq_line = pdev->irq;
@@ -1136,49 +1095,52 @@
 	pci_ioaddr = pci_resource_start(pdev, 1);
 	pci_set_master(pdev);
 
-	printk("Found SAA9730 (PCI) at %#x, irq %d.\n",
+	printk("Found SAA9730 (PCI) at %lx, irq %d.\n",
 	       pci_ioaddr, pci_irq_line);
 
-	err = lan_saa9730_init(dev, pci_ioaddr, pci_irq_line);
+	dev = alloc_etherdev(sizeof(struct lan_saa9730_private));
+	if (!dev)
+		goto out_disable_pdev;
+
+	err = lan_saa9730_init(dev, pdev, pci_ioaddr, pci_irq_line);
 	if (err) {
-		printk("Lan init failed");
-		goto out2;
+		printk("LAN init failed");
+		goto out_free_netdev;
 	}
 
 	pci_set_drvdata(pdev, dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 	return 0;
-	
-out2:
-	pci_disable_device(pdev);
-out1:
+
+out_free_netdev:
 	free_netdev(dev);
+out_disable_pdev:
+	pci_disable_device(pdev);
 out:
+	pci_set_drvdata(pdev, NULL);
 	return err;
 }
 
 
 static struct pci_driver saa9730_driver = {
-	.name           = DRV_MODULE_NAME,
-	.id_table       = saa9730_pci_tbl,
-	.probe          = saa9730_init_one,
-	.remove         = __devexit_p(saa9730_remove_one),
+	.name		= DRV_MODULE_NAME,
+	.id_table	= saa9730_pci_tbl,
+	.probe		= saa9730_init_one,
+	.remove		= __devexit_p(saa9730_remove_one),
 };
 
 
 static int __init saa9730_init(void)
 {
-        return pci_module_init(&saa9730_driver);
+	return pci_module_init(&saa9730_driver);
 }
 
 static void __exit saa9730_cleanup(void)
 {
-        pci_unregister_driver(&saa9730_driver);
+	pci_unregister_driver(&saa9730_driver);
 }
 
 module_init(saa9730_init);
 module_exit(saa9730_cleanup);
 
-
-
 MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/drivers/net/saa9730.h linux-mips-2.6.14.orig/drivers/net/saa9730.h
--- linux-2.6.14/drivers/net/saa9730.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/saa9730.h	2005-11-17 11:43:11.000000000 -0800
@@ -1,6 +1,7 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2000, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  * ########################################################################
  *
@@ -265,6 +266,7 @@
 
 /* The SAA9730 (LAN) controller register map, as seen via the PCI-bus. */
 #define SAA9730_LAN_REGS_ADDR   0x20400
+#define SAA9730_LAN_REGS_SIZE   0x00400
 
 struct lan_saa9730_regmap {
 	volatile unsigned int TxBuffA;			/* 0x20400 */
@@ -309,6 +311,7 @@
 
 /* The SAA9730 (EVM) controller register map, as seen via the PCI-bus. */
 #define SAA9730_EVM_REGS_ADDR   0x02000
+#define SAA9730_EVM_REGS_SIZE   0x00400
 
 struct evm_saa9730_regmap {
 	volatile unsigned int InterruptStatus1;		/* 0x2000 */
@@ -329,16 +332,32 @@
 
 
 struct lan_saa9730_private {
+	/*
+	 * Rx/Tx packet buffers.
+	 * The Rx and Tx packets must be PACKET_SIZE aligned.
+	 */
+	void		*buffer_start;
+	unsigned int	buffer_size;
+
+	/*
+	 * DMA address of beginning of this object, returned
+	 * by pci_alloc_consistent().
+	 */
+	dma_addr_t	dma_addr;
+
+	/* Pointer to the associated pci device structure */
+	struct pci_dev	*pci_dev;
+
 	/* Pointer for the SAA9730 LAN controller register set. */
 	t_lan_saa9730_regmap *lan_saa9730_regs;
 
 	/* Pointer to the SAA9730 EVM register. */
 	t_evm_saa9730_regmap *evm_saa9730_regs;
 
-	/* TRUE if the next buffer to write is RxBuffA,  FALSE if RxBuffB. */
-	unsigned char NextRcvToUseIsA;
 	/* Rcv buffer Index. */
 	unsigned char NextRcvPacketIndex;
+	/* Next buffer index. */
+	unsigned char NextRcvBufferIndex;
 
 	/* Index of next packet to use in that buffer. */
 	unsigned char NextTxmPacketIndex;
@@ -353,13 +372,8 @@
 	unsigned char DmaRcvPackets;
 	unsigned char DmaTxmPackets;
 
-	unsigned char RcvAIndex;	/* index into RcvBufferSpace[] for Blk A */
-	unsigned char RcvBIndex;	/* index into RcvBufferSpace[] for Blk B */
-
-	unsigned int
-	    TxmBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_TXM_Q_SIZE];
-	unsigned int
-	    RcvBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_RCV_Q_SIZE];
+	void	      *TxmBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_TXM_Q_SIZE];
+	void	      *RcvBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_RCV_Q_SIZE];
 	unsigned int TxBufferFree[LAN_SAA9730_BUFFERS];
 
 	unsigned char PhysicalAddress[LAN_SAA9730_CAM_ENTRIES][6];
diff -Naur linux-2.6.14/drivers/net/sb1250-mac.c linux-mips-2.6.14.orig/drivers/net/sb1250-mac.c
--- linux-2.6.14/drivers/net/sb1250-mac.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/sb1250-mac.c	2005-11-17 11:43:11.000000000 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2001,2002,2003 Broadcom Corporation
+ * Copyright (C) 2001,2002,2003,2004 Broadcom Corporation
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -10,7 +10,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
@@ -43,6 +43,7 @@
 #define SBMAC_ETH0_HWADDR "40:00:00:00:01:00"
 #define SBMAC_ETH1_HWADDR "40:00:00:00:01:01"
 #define SBMAC_ETH2_HWADDR "40:00:00:00:01:02"
+#define SBMAC_ETH3_HWADDR "40:00:00:00:01:03"
 #endif
 
 
@@ -57,7 +58,7 @@
 
 #define CONFIG_SBMAC_COALESCE
 
-#define MAX_UNITS 3		/* More are supported, limit only on options */
+#define MAX_UNITS 4		/* More are supported, limit only on options */
 
 /* Time in jiffies before concluding the transmitter is hung. */
 #define TX_TIMEOUT  (2*HZ)
@@ -85,11 +86,11 @@
    The media type is usually passed in 'options[]'.
 */
 #ifdef MODULE
-static int options[MAX_UNITS] = {-1, -1, -1};
+static int options[MAX_UNITS] = {-1, -1, -1, -1};
 module_param_array(options, int, NULL, S_IRUGO);
 MODULE_PARM_DESC(options, "1-" __MODULE_STRING(MAX_UNITS));
 
-static int full_duplex[MAX_UNITS] = {-1, -1, -1};
+static int full_duplex[MAX_UNITS] = {-1, -1, -1, -1};
 module_param_array(full_duplex, int, NULL, S_IRUGO);
 MODULE_PARM_DESC(full_duplex, "1-" __MODULE_STRING(MAX_UNITS));
 #endif
@@ -105,21 +106,32 @@
 #endif
 
 #include <asm/sibyte/sb1250.h>
-#include <asm/sibyte/sb1250_defs.h>
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+#include <asm/sibyte/bcm1480_regs.h>
+#include <asm/sibyte/bcm1480_int.h>
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
 #include <asm/sibyte/sb1250_regs.h>
-#include <asm/sibyte/sb1250_mac.h>
-#include <asm/sibyte/sb1250_dma.h>
 #include <asm/sibyte/sb1250_int.h>
+#else
+#error invalid SiByte MAC configuation
+#endif
 #include <asm/sibyte/sb1250_scd.h>
+#include <asm/sibyte/sb1250_mac.h>
+#include <asm/sibyte/sb1250_dma.h>
 
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+#define UNIT_INT(n)		(K_BCM1480_INT_MAC_0 + ((n) * 2))
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
+#define UNIT_INT(n)		(K_INT_MAC_0 + (n))
+#else
+#error invalid SiByte MAC configuation
+#endif
 
 /**********************************************************************
  *  Simple types
  ********************************************************************* */
 
 
-typedef unsigned long sbmac_port_t;
-
 typedef enum { sbmac_speed_auto, sbmac_speed_10,
 	       sbmac_speed_100, sbmac_speed_1000 } sbmac_speed_t;
 
@@ -129,7 +141,7 @@
 typedef enum { sbmac_fc_auto, sbmac_fc_disabled, sbmac_fc_frame,
 	       sbmac_fc_collision, sbmac_fc_carrier } sbmac_fc_t;
 
-typedef enum { sbmac_state_uninit, sbmac_state_off, sbmac_state_on, 
+typedef enum { sbmac_state_uninit, sbmac_state_off, sbmac_state_on,
 	       sbmac_state_broken } sbmac_state_t;
 
 
@@ -146,15 +158,15 @@
 
 #define SBMAC_READCSR(t)	__raw_readq((unsigned long)t)
 #define SBMAC_WRITECSR(t,v)	__raw_writeq(v, (unsigned long)t)
- 
+
 
 #define SBMAC_MAX_TXDESCR	32
 #define SBMAC_MAX_RXDESCR	32
 
 #define ETHER_ALIGN	2
 #define ETHER_ADDR_LEN	6
-#define ENET_PACKET_SIZE	1518 
-/*#define ENET_PACKET_SIZE	9216 */ 
+#define ENET_PACKET_SIZE	1518
+/*#define ENET_PACKET_SIZE	9216 */
 
 /**********************************************************************
  *  DMA Descriptor structure
@@ -172,12 +184,12 @@
  ********************************************************************* */
 
 typedef struct sbmacdma_s {
-	
-	/* 
+
+	/*
 	 * This stuff is used to identify the channel and the registers
 	 * associated with it.
 	 */
-	
+
 	struct sbmac_softc *sbdma_eth;	        /* back pointer to associated MAC */
 	int              sbdma_channel;	/* channel number */
 	int		 sbdma_txdir;       /* direction (1=transmit) */
@@ -187,21 +199,21 @@
 	int		 sbdma_int_timeout; /* # usec rx/tx interrupt */
 #endif
 
-	sbmac_port_t     sbdma_config0;	/* DMA config register 0 */
-	sbmac_port_t     sbdma_config1;	/* DMA config register 1 */
-	sbmac_port_t     sbdma_dscrbase;	/* Descriptor base address */
-	sbmac_port_t     sbdma_dscrcnt;     /* Descriptor count register */
-	sbmac_port_t     sbdma_curdscr;	/* current descriptor address */
-	
+	volatile void __iomem *sbdma_config0;	/* DMA config register 0 */
+	volatile void __iomem *sbdma_config1;	/* DMA config register 1 */
+	volatile void __iomem *sbdma_dscrbase;	/* Descriptor base address */
+	volatile void __iomem *sbdma_dscrcnt;     /* Descriptor count register */
+	volatile void __iomem *sbdma_curdscr;	/* current descriptor address */
+
 	/*
 	 * This stuff is for maintenance of the ring
 	 */
-	
+
 	sbdmadscr_t     *sbdma_dscrtable;	/* base of descriptor table */
 	sbdmadscr_t     *sbdma_dscrtable_end; /* end of descriptor table */
-	
+
 	struct sk_buff **sbdma_ctxtable;    /* context table, one per descr */
-	
+
 	paddr_t          sbdma_dscrtable_phys; /* and also the phys addr */
 	sbdmadscr_t     *sbdma_addptr;	/* next dscr for sw to add */
 	sbdmadscr_t     *sbdma_remptr;	/* next dscr for sw to remove */
@@ -213,15 +225,15 @@
  ********************************************************************* */
 
 struct sbmac_softc {
-	
+
 	/*
 	 * Linux-specific things
 	 */
-	
+
 	struct net_device *sbm_dev;		/* pointer to linux device */
 	spinlock_t sbm_lock;		/* spin lock */
 	struct timer_list sbm_timer;     	/* for monitoring MII */
-	struct net_device_stats sbm_stats; 
+	struct net_device_stats sbm_stats;
 	int sbm_devflags;			/* current device flags */
 
 	int	     sbm_phy_oldbmsr;
@@ -229,31 +241,31 @@
 	int	     sbm_phy_oldk1stsr;
 	int	     sbm_phy_oldlinkstat;
 	int sbm_buffersize;
-	
+
 	unsigned char sbm_phys[2];
-	
+
 	/*
 	 * Controller-specific things
 	 */
-	
-	unsigned long	sbm_base;          /* MAC's base address */
+
+	volatile void __iomem *sbm_base;          /* MAC's base address */
 	sbmac_state_t    sbm_state;         /* current state */
-	
-	sbmac_port_t     sbm_macenable;	/* MAC Enable Register */
-	sbmac_port_t     sbm_maccfg;	/* MAC Configuration Register */
-	sbmac_port_t     sbm_fifocfg;	/* FIFO configuration register */
-	sbmac_port_t     sbm_framecfg;	/* Frame configuration register */
-	sbmac_port_t     sbm_rxfilter;	/* receive filter register */
-	sbmac_port_t     sbm_isr;		/* Interrupt status register */
-	sbmac_port_t     sbm_imr;		/* Interrupt mask register */
-	sbmac_port_t     sbm_mdio;		/* MDIO register */
-	
+
+	volatile void __iomem	*sbm_macenable;	/* MAC Enable Register */
+	volatile void __iomem	*sbm_maccfg;	/* MAC Configuration Register */
+	volatile void __iomem	*sbm_fifocfg;	/* FIFO configuration register */
+	volatile void __iomem	*sbm_framecfg;	/* Frame configuration register */
+	volatile void __iomem	*sbm_rxfilter;	/* receive filter register */
+	volatile void __iomem	*sbm_isr;	/* Interrupt status register */
+	volatile void __iomem	*sbm_imr;	/* Interrupt mask register */
+	volatile void __iomem	*sbm_mdio;	/* MDIO register */
+
 	sbmac_speed_t    sbm_speed;		/* current speed */
 	sbmac_duplex_t   sbm_duplex;	/* current duplex */
 	sbmac_fc_t       sbm_fc;		/* current flow control setting */
-	
+
 	unsigned char    sbm_hwaddr[ETHER_ADDR_LEN];
-	
+
 	sbmacdma_t       sbm_txdma;		/* for now, only use channel 0 */
 	sbmacdma_t       sbm_rxdma;
 	int              rx_hw_checksum;
@@ -302,6 +314,7 @@
 static int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static int sbmac_close(struct net_device *dev);
 static int sbmac_mii_poll(struct sbmac_softc *s,int noisy);
+static int sbmac_mii_probe(struct net_device *dev);
 
 static void sbmac_mii_sync(struct sbmac_softc *s);
 static void sbmac_mii_senddata(struct sbmac_softc *s,unsigned int data, int bitcnt);
@@ -439,6 +452,9 @@
 
 #define	MII_BMCR	0x00 	/* Basic mode control register (rw) */
 #define	MII_BMSR	0x01	/* Basic mode status register (ro) */
+#define	MII_PHYIDR1	0x02
+#define	MII_PHYIDR2	0x03
+
 #define MII_K1STSR	0x0A	/* 1K Status Register (ro) */
 #define	MII_ANLPAR	0x05	/* Autonegotiation lnk partner abilities (rw) */
 
@@ -450,13 +466,13 @@
 
 /**********************************************************************
  *  SBMAC_MII_SYNC(s)
- *  
+ *
  *  Synchronize with the MII - send a pattern of bits to the MII
  *  that will guarantee that it is ready to accept a command.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -467,25 +483,25 @@
 	uint64_t bits;
 	int mac_mdio_genc;
 
-	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
-	
+	mac_mdio_genc = __raw_readq(s->sbm_mdio) & M_MAC_GENC;
+
 	bits = M_MAC_MDIO_DIR_OUTPUT | M_MAC_MDIO_OUT;
-	
-	SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
-	
+
+	__raw_writeq(bits | mac_mdio_genc, s->sbm_mdio);
+
 	for (cnt = 0; cnt < 32; cnt++) {
-		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC | mac_mdio_genc);
-		SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
+		__raw_writeq(bits | M_MAC_MDC | mac_mdio_genc, s->sbm_mdio);
+		__raw_writeq(bits | mac_mdio_genc, s->sbm_mdio);
 	}
 }
 
 /**********************************************************************
  *  SBMAC_MII_SENDDATA(s,data,bitcnt)
- *  
+ *
  *  Send some bits to the MII.  The bits to be sent are right-
  *  justified in the 'data' parameter.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
  *  	   data - data to send
  *  	   bitcnt - number of bits to send
@@ -498,20 +514,20 @@
 	unsigned int curmask;
 	int mac_mdio_genc;
 
-	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
-	
+	mac_mdio_genc = __raw_readq(s->sbm_mdio) & M_MAC_GENC;
+
 	bits = M_MAC_MDIO_DIR_OUTPUT;
-	SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
-	
+	__raw_writeq(bits | mac_mdio_genc, s->sbm_mdio);
+
 	curmask = 1 << (bitcnt - 1);
-	
+
 	for (i = 0; i < bitcnt; i++) {
 		if (data & curmask)
 			bits |= M_MAC_MDIO_OUT;
 		else bits &= ~M_MAC_MDIO_OUT;
-		SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
-		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC | mac_mdio_genc);
-		SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
+		__raw_writeq(bits | mac_mdio_genc, s->sbm_mdio);
+		__raw_writeq(bits | M_MAC_MDC | mac_mdio_genc, s->sbm_mdio);
+		__raw_writeq(bits | mac_mdio_genc, s->sbm_mdio);
 		curmask >>= 1;
 	}
 }
@@ -520,14 +536,14 @@
 
 /**********************************************************************
  *  SBMAC_MII_READ(s,phyaddr,regidx)
- *  
+ *
  *  Read a PHY register.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
  *  	   phyaddr - PHY's address
  *  	   regidx = index of register to read
- *  	   
+ *
  *  Return value:
  *  	   value read, or 0 if an error occurred.
  ********************************************************************* */
@@ -543,9 +559,9 @@
 	 * Synchronize ourselves so that the PHY knows the next
 	 * thing coming down is a command
 	 */
-	
+
 	sbmac_mii_sync(s);
-	
+
 	/*
 	 * Send the data to the PHY.  The sequence is
 	 * a "start" command (2 bits)
@@ -553,59 +569,55 @@
 	 * the PHY addr (5 bits)
 	 * the register index (5 bits)
 	 */
-	
+
 	sbmac_mii_senddata(s,MII_COMMAND_START, 2);
 	sbmac_mii_senddata(s,MII_COMMAND_READ, 2);
 	sbmac_mii_senddata(s,phyaddr, 5);
 	sbmac_mii_senddata(s,regidx, 5);
-	
-	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
-	
-	/* 
+
+	mac_mdio_genc = __raw_readq(s->sbm_mdio) & M_MAC_GENC;
+
+	/*
 	 * Switch the port around without a clock transition.
 	 */
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
-	
+	__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, s->sbm_mdio);
+
 	/*
 	 * Send out a clock pulse to signal we want the status
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_mdio,
-		       M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc);
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
-	
-	/* 
+
+	__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc, s->sbm_mdio);
+	__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, s->sbm_mdio);
+
+	/*
 	 * If an error occurred, the PHY will signal '1' back
 	 */
-	error = SBMAC_READCSR(s->sbm_mdio) & M_MAC_MDIO_IN;
-	
-	/* 
+	error = __raw_readq(s->sbm_mdio) & M_MAC_MDIO_IN;
+
+	/*
 	 * Issue an 'idle' clock pulse, but keep the direction
 	 * the same.
 	 */
-	SBMAC_WRITECSR(s->sbm_mdio,
-		       M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc);
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
-	
+	__raw_writeq(M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc, s->sbm_mdio);
+	__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, s->sbm_mdio);
+
 	regval = 0;
-	
+
 	for (idx = 0; idx < 16; idx++) {
 		regval <<= 1;
-		
+
 		if (error == 0) {
-			if (SBMAC_READCSR(s->sbm_mdio) & M_MAC_MDIO_IN)
+			if (__raw_readq(s->sbm_mdio) & M_MAC_MDIO_IN)
 				regval |= 1;
 		}
-		
-		SBMAC_WRITECSR(s->sbm_mdio,
-			       M_MAC_MDIO_DIR_INPUT|M_MAC_MDC | mac_mdio_genc);
-		SBMAC_WRITECSR(s->sbm_mdio,
-			       M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
+
+		__raw_writeq(M_MAC_MDIO_DIR_INPUT|M_MAC_MDC | mac_mdio_genc, s->sbm_mdio);
+		__raw_writeq(M_MAC_MDIO_DIR_INPUT | mac_mdio_genc, s->sbm_mdio);
 	}
-	
+
 	/* Switch back to output */
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc);
-	
+	__raw_writeq(M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc, s->sbm_mdio);
+
 	if (error == 0)
 		return regval;
 	return 0;
@@ -614,15 +626,15 @@
 
 /**********************************************************************
  *  SBMAC_MII_WRITE(s,phyaddr,regidx,regval)
- *  
+ *
  *  Write a value to a PHY register.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
  *  	   phyaddr - PHY to use
  *  	   regidx - register within the PHY
  *  	   regval - data to write to register
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -633,7 +645,7 @@
 	int mac_mdio_genc;
 
 	sbmac_mii_sync(s);
-	
+
 	sbmac_mii_senddata(s,MII_COMMAND_START,2);
 	sbmac_mii_senddata(s,MII_COMMAND_WRITE,2);
 	sbmac_mii_senddata(s,phyaddr, 5);
@@ -641,27 +653,27 @@
 	sbmac_mii_senddata(s,MII_COMMAND_ACK,2);
 	sbmac_mii_senddata(s,regval,16);
 
-	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
+	mac_mdio_genc = __raw_readq(s->sbm_mdio) & M_MAC_GENC;
 
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc);
+	__raw_writeq(M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc, s->sbm_mdio);
 }
 
 
 
 /**********************************************************************
  *  SBDMA_INITCTX(d,s,chan,txrx,maxdescr)
- *  
+ *
  *  Initialize a DMA channel context.  Since there are potentially
  *  eight DMA channels per MAC, it's nice to do this in a standard
- *  way.  
- *  
- *  Input parameters: 
+ *  way.
+ *
+ *  Input parameters:
  *  	   d - sbmacdma_t structure (DMA channel context)
  *  	   s - sbmac_softc structure (pointer to a MAC)
  *  	   chan - channel number (0..1 right now)
  *  	   txrx - Identifies DMA_TX or DMA_RX for channel direction
  *      maxdescr - number of descriptors
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -672,101 +684,87 @@
 			  int txrx,
 			  int maxdescr)
 {
-	/* 
-	 * Save away interesting stuff in the structure 
+	/*
+	 * Save away interesting stuff in the structure
 	 */
-	
+
 	d->sbdma_eth       = s;
 	d->sbdma_channel   = chan;
 	d->sbdma_txdir     = txrx;
-	
+
 #if 0
 	/* RMON clearing */
 	s->sbe_idx =(s->sbm_base - A_MAC_BASE_0)/MAC_SPACING;
 #endif
 
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BYTES)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_COLLISIONS)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_LATE_COL)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_EX_COL)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_FCS_ERROR)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_ABORT)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BAD)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_GOOD)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_RUNT)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_OVERSIZE)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BYTES)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_MCAST)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BCAST)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BAD)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_GOOD)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_RUNT)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_OVERSIZE)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_FCS_ERROR)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_LENGTH_ERROR)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_CODE_ERROR)), 0);
-	SBMAC_WRITECSR(IOADDR(
-	A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_ALIGN_ERROR)), 0);
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BYTES)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_COLLISIONS)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_LATE_COL)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_EX_COL)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_FCS_ERROR)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_ABORT)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_BAD)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_GOOD)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_RUNT)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_TX_OVERSIZE)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BYTES)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_MCAST)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BCAST)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_BAD)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_GOOD)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_RUNT)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_OVERSIZE)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_FCS_ERROR)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_LENGTH_ERROR)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_CODE_ERROR)));
+	__raw_writeq(0, IOADDR(A_MAC_REGISTER(s->sbe_idx, R_MAC_RMON_RX_ALIGN_ERROR)));
 
-	/* 
-	 * initialize register pointers 
+	/*
+	 * initialize register pointers
 	 */
-	
-	d->sbdma_config0 = 
+
+	d->sbdma_config0 =
 		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG0);
-	d->sbdma_config1 = 
+	d->sbdma_config1 =
 		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CONFIG1);
-	d->sbdma_dscrbase = 
+	d->sbdma_dscrbase =
 		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_BASE);
-	d->sbdma_dscrcnt = 
+	d->sbdma_dscrcnt =
 		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_DSCR_CNT);
-	d->sbdma_curdscr = 	
+	d->sbdma_curdscr =
 		s->sbm_base + R_MAC_DMA_REGISTER(txrx,chan,R_MAC_DMA_CUR_DSCRADDR);
-	
+
 	/*
 	 * Allocate memory for the ring
 	 */
-	
+
 	d->sbdma_maxdescr = maxdescr;
-	
-	d->sbdma_dscrtable = (sbdmadscr_t *) 
-		kmalloc(d->sbdma_maxdescr*sizeof(sbdmadscr_t), GFP_KERNEL);
-	
+
+	d->sbdma_dscrtable = (sbdmadscr_t *)
+		kmalloc((d->sbdma_maxdescr+1)*sizeof(sbdmadscr_t), GFP_KERNEL);
+
+	/*
+	 * The descriptor table must be aligned to at least 16 bytes or the
+	 * MAC will corrupt it.
+	 */
+	d->sbdma_dscrtable = (sbdmadscr_t *)
+		ALIGN((unsigned long)d->sbdma_dscrtable, sizeof(sbdmadscr_t));
+
 	memset(d->sbdma_dscrtable,0,d->sbdma_maxdescr*sizeof(sbdmadscr_t));
-	
+
 	d->sbdma_dscrtable_end = d->sbdma_dscrtable + d->sbdma_maxdescr;
-	
+
 	d->sbdma_dscrtable_phys = virt_to_phys(d->sbdma_dscrtable);
-	
+
 	/*
 	 * And context table
 	 */
-	
-	d->sbdma_ctxtable = (struct sk_buff **) 
+
+	d->sbdma_ctxtable = (struct sk_buff **)
 		kmalloc(d->sbdma_maxdescr*sizeof(struct sk_buff *), GFP_KERNEL);
-	
+
 	memset(d->sbdma_ctxtable,0,d->sbdma_maxdescr*sizeof(struct sk_buff *));
-	
+
 #ifdef CONFIG_SBMAC_COALESCE
 	/*
 	 * Setup Rx/Tx DMA coalescing defaults
@@ -777,7 +775,7 @@
 	} else {
 		d->sbdma_int_pktcnt = 1;
 	}
-	
+
 	if ( int_timeout ) {
 		d->sbdma_int_timeout = int_timeout;
 	} else {
@@ -789,13 +787,13 @@
 
 /**********************************************************************
  *  SBDMA_CHANNEL_START(d)
- *  
+ *
  *  Initialize the hardware registers for a DMA channel.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   d - DMA channel to init (context must be previously init'd
  *         rxtx - DMA_RX or DMA_TX depending on what type of channel
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -805,24 +803,21 @@
 	/*
 	 * Turn on the DMA channel
 	 */
-	
+
 #ifdef CONFIG_SBMAC_COALESCE
-	SBMAC_WRITECSR(d->sbdma_config1,
-		       V_DMA_INT_TIMEOUT(d->sbdma_int_timeout) |
-		       0);
-	SBMAC_WRITECSR(d->sbdma_config0,
-		       M_DMA_EOP_INT_EN |
+	__raw_writeq(V_DMA_INT_TIMEOUT(d->sbdma_int_timeout) |
+		       0, d->sbdma_config1);
+	__raw_writeq(M_DMA_EOP_INT_EN |
 		       V_DMA_RINGSZ(d->sbdma_maxdescr) |
 		       V_DMA_INT_PKTCNT(d->sbdma_int_pktcnt) |
-		       0);
+		       0, d->sbdma_config0);
 #else
-	SBMAC_WRITECSR(d->sbdma_config1,0);
-	SBMAC_WRITECSR(d->sbdma_config0,
-		       V_DMA_RINGSZ(d->sbdma_maxdescr) |
-		       0);
+	__raw_writeq(0, d->sbdma_config1);
+	__raw_writeq(V_DMA_RINGSZ(d->sbdma_maxdescr) |
+		       0, d->sbdma_config0);
 #endif
 
-	SBMAC_WRITECSR(d->sbdma_dscrbase,d->sbdma_dscrtable_phys);
+	__raw_writeq(d->sbdma_dscrtable_phys, d->sbdma_dscrbase);
 
 	/*
 	 * Initialize ring pointers
@@ -834,12 +829,12 @@
 
 /**********************************************************************
  *  SBDMA_CHANNEL_STOP(d)
- *  
+ *
  *  Initialize the hardware registers for a DMA channel.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   d - DMA channel to init (context must be previously init'd
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -849,44 +844,44 @@
 	/*
 	 * Turn off the DMA channel
 	 */
-	
-	SBMAC_WRITECSR(d->sbdma_config1,0);
-	
-	SBMAC_WRITECSR(d->sbdma_dscrbase,0);
-	
-	SBMAC_WRITECSR(d->sbdma_config0,0);
-	
+
+	__raw_writeq(0, d->sbdma_config1);
+
+	__raw_writeq(0, d->sbdma_dscrbase);
+
+	__raw_writeq(0, d->sbdma_config0);
+
 	/*
 	 * Zero ring pointers
 	 */
-	
-	d->sbdma_addptr = 0;
-	d->sbdma_remptr = 0;
+
+	d->sbdma_addptr = NULL;
+	d->sbdma_remptr = NULL;
 }
 
 static void sbdma_align_skb(struct sk_buff *skb,int power2,int offset)
 {
 	unsigned long addr;
 	unsigned long newaddr;
-	
+
 	addr = (unsigned long) skb->data;
-	
+
 	newaddr = (addr + power2 - 1) & ~(power2 - 1);
-	
+
 	skb_reserve(skb,newaddr-addr+offset);
 }
 
 
 /**********************************************************************
  *  SBDMA_ADD_RCVBUFFER(d,sb)
- *  
+ *
  *  Add a buffer to the specified DMA channel.   For receive channels,
  *  this queues a buffer for inbound packets.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   d - DMA channel descriptor
  * 	   sb - sk_buff to add, or NULL if we should allocate one
- *  	   
+ *
  *  Return value:
  *  	   0 if buffer could not be added (ring is full)
  *  	   1 if buffer added successfully
@@ -899,24 +894,24 @@
 	sbdmadscr_t *nextdsc;
 	struct sk_buff *sb_new = NULL;
 	int pktsize = ENET_PACKET_SIZE;
-	
+
 	/* get pointer to our current place in the ring */
-	
+
 	dsc = d->sbdma_addptr;
 	nextdsc = SBDMA_NEXTBUF(d,sbdma_addptr);
-	
+
 	/*
 	 * figure out if the ring is full - if the next descriptor
 	 * is the same as the one that we're going to remove from
 	 * the ring, the ring is full
 	 */
-	
+
 	if (nextdsc == d->sbdma_remptr) {
 		return -ENOSPC;
 	}
 
-	/* 
-	 * Allocate a sk_buff if we don't already have one.  
+	/*
+	 * Allocate a sk_buff if we don't already have one.
 	 * If we do have an sk_buff, reset it so that it's empty.
 	 *
 	 * Note: sk_buffs don't seem to be guaranteed to have any sort
@@ -925,7 +920,7 @@
 	 *
 	 *    1. the data does not start in the middle of a cache line.
 	 *    2. The data does not end in the middle of a cache line
-	 *    3. The buffer can be aligned such that the IP addresses are 
+	 *    3. The buffer can be aligned such that the IP addresses are
 	 *       naturally aligned.
 	 *
 	 *  Remember, the SOCs MAC writes whole cache lines at a time,
@@ -933,7 +928,7 @@
 	 *  data portion starts in the middle of a cache line, the SOC
 	 *  DMA will trash the beginning (and ending) portions.
 	 */
-	
+
 	if (sb == NULL) {
 		sb_new = dev_alloc_skb(ENET_PACKET_SIZE + SMP_CACHE_BYTES * 2 + ETHER_ALIGN);
 		if (sb_new == NULL) {
@@ -949,23 +944,22 @@
 	}
 	else {
 		sb_new = sb;
-		/* 
+		/*
 		 * nothing special to reinit buffer, it's already aligned
 		 * and sb->data already points to a good place.
 		 */
 	}
-	
+
 	/*
-	 * fill in the descriptor 
+	 * fill in the descriptor
 	 */
-	
+
 #ifdef CONFIG_SBMAC_COALESCE
 	/*
 	 * Do not interrupt per DMA transfer.
 	 */
 	dsc->dscr_a = virt_to_phys(sb_new->data) |
-		V_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize+ETHER_ALIGN)) |
-		0;
+		V_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize+ETHER_ALIGN)) | 0;
 #else
 	dsc->dscr_a = virt_to_phys(sb_new->data) |
 		V_DMA_DSCRA_A_SIZE(NUMCACHEBLKS(pktsize+ETHER_ALIGN)) |
@@ -974,38 +968,38 @@
 
 	/* receiving: no options */
 	dsc->dscr_b = 0;
-	
+
 	/*
-	 * fill in the context 
+	 * fill in the context
 	 */
-	
+
 	d->sbdma_ctxtable[dsc-d->sbdma_dscrtable] = sb_new;
-	
-	/* 
-	 * point at next packet 
+
+	/*
+	 * point at next packet
 	 */
-	
+
 	d->sbdma_addptr = nextdsc;
-	
-	/* 
+
+	/*
 	 * Give the buffer to the DMA engine.
 	 */
-	
-	SBMAC_WRITECSR(d->sbdma_dscrcnt,1);
-	
+
+	__raw_writeq(1, d->sbdma_dscrcnt);
+
 	return 0;					/* we did it */
 }
 
 /**********************************************************************
  *  SBDMA_ADD_TXBUFFER(d,sb)
- *  
+ *
  *  Add a transmit buffer to the specified DMA channel, causing a
  *  transmit to start.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   d - DMA channel descriptor
  * 	   sb - sk_buff to add
- *  	   
+ *
  *  Return value:
  *  	   0 transmit queued successfully
  *  	   otherwise error code
@@ -1019,70 +1013,70 @@
 	uint64_t phys;
 	uint64_t ncb;
 	int length;
-	
+
 	/* get pointer to our current place in the ring */
-	
+
 	dsc = d->sbdma_addptr;
 	nextdsc = SBDMA_NEXTBUF(d,sbdma_addptr);
-	
+
 	/*
 	 * figure out if the ring is full - if the next descriptor
 	 * is the same as the one that we're going to remove from
 	 * the ring, the ring is full
 	 */
-	
+
 	if (nextdsc == d->sbdma_remptr) {
 		return -ENOSPC;
 	}
-	
+
 	/*
 	 * Under Linux, it's not necessary to copy/coalesce buffers
 	 * like it is on NetBSD.  We think they're all contiguous,
 	 * but that may not be true for GBE.
 	 */
-	
+
 	length = sb->len;
-	
+
 	/*
 	 * fill in the descriptor.  Note that the number of cache
 	 * blocks in the descriptor is the number of blocks
 	 * *spanned*, so we need to add in the offset (if any)
 	 * while doing the calculation.
 	 */
-	
+
 	phys = virt_to_phys(sb->data);
 	ncb = NUMCACHEBLKS(length+(phys & (SMP_CACHE_BYTES - 1)));
 
-	dsc->dscr_a = phys | 
+	dsc->dscr_a = phys |
 		V_DMA_DSCRA_A_SIZE(ncb) |
 #ifndef CONFIG_SBMAC_COALESCE
 		M_DMA_DSCRA_INTERRUPT |
 #endif
 		M_DMA_ETHTX_SOP;
-	
+
 	/* transmitting: set outbound options and length */
 
 	dsc->dscr_b = V_DMA_DSCRB_OPTIONS(K_DMA_ETHTX_APPENDCRC_APPENDPAD) |
 		V_DMA_DSCRB_PKT_SIZE(length);
-	
+
 	/*
-	 * fill in the context 
+	 * fill in the context
 	 */
-	
+
 	d->sbdma_ctxtable[dsc-d->sbdma_dscrtable] = sb;
-	
-	/* 
-	 * point at next packet 
+
+	/*
+	 * point at next packet
 	 */
-	
+
 	d->sbdma_addptr = nextdsc;
-	
-	/* 
+
+	/*
 	 * Give the buffer to the DMA engine.
 	 */
-	
-	SBMAC_WRITECSR(d->sbdma_dscrcnt,1);
-	
+
+	__raw_writeq(1, d->sbdma_dscrcnt);
+
 	return 0;					/* we did it */
 }
 
@@ -1091,12 +1085,12 @@
 
 /**********************************************************************
  *  SBDMA_EMPTYRING(d)
- *  
+ *
  *  Free all allocated sk_buffs on the specified DMA channel;
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   d  - DMA channel
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1105,7 +1099,7 @@
 {
 	int idx;
 	struct sk_buff *sb;
-	
+
 	for (idx = 0; idx < d->sbdma_maxdescr; idx++) {
 		sb = d->sbdma_ctxtable[idx];
 		if (sb) {
@@ -1118,13 +1112,13 @@
 
 /**********************************************************************
  *  SBDMA_FILLRING(d)
- *  
+ *
  *  Fill the specified DMA channel (must be receive channel)
  *  with sk_buffs
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   d - DMA channel
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1132,7 +1126,7 @@
 static void sbdma_fillring(sbmacdma_t *d)
 {
 	int idx;
-	
+
 	for (idx = 0; idx < SBMAC_MAX_RXDESCR-1; idx++) {
 		if (sbdma_add_rcvbuffer(d,NULL) != 0)
 			break;
@@ -1142,16 +1136,16 @@
 
 /**********************************************************************
  *  SBDMA_RX_PROCESS(sc,d)
- *  
- *  Process "completed" receive buffers on the specified DMA channel.  
+ *
+ *  Process "completed" receive buffers on the specified DMA channel.
  *  Note that this isn't really ideal for priority channels, since
- *  it processes all of the packets on a given channel before 
- *  returning. 
+ *  it processes all of the packets on a given channel before
+ *  returning.
  *
- *  Input parameters: 
+ *  Input parameters:
  *	   sc - softc structure
  *  	   d - DMA channel context
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1163,56 +1157,56 @@
 	sbdmadscr_t *dsc;
 	struct sk_buff *sb;
 	int len;
-	
+
 	for (;;) {
-		/* 
+		/*
 		 * figure out where we are (as an index) and where
 		 * the hardware is (also as an index)
 		 *
-		 * This could be done faster if (for example) the 
+		 * This could be done faster if (for example) the
 		 * descriptor table was page-aligned and contiguous in
 		 * both virtual and physical memory -- you could then
 		 * just compare the low-order bits of the virtual address
 		 * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)
 		 */
-		
+
 		curidx = d->sbdma_remptr - d->sbdma_dscrtable;
-		hwidx = (int) (((SBMAC_READCSR(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -
+		hwidx = (int) (((__raw_readq(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -
 				d->sbdma_dscrtable_phys) / sizeof(sbdmadscr_t));
-		
+
 		/*
 		 * If they're the same, that means we've processed all
 		 * of the descriptors up to (but not including) the one that
 		 * the hardware is working on right now.
 		 */
-		
+
 		if (curidx == hwidx)
 			break;
-		
+
 		/*
 		 * Otherwise, get the packet's sk_buff ptr back
 		 */
-		
+
 		dsc = &(d->sbdma_dscrtable[curidx]);
 		sb = d->sbdma_ctxtable[curidx];
 		d->sbdma_ctxtable[curidx] = NULL;
-		
+
 		len = (int)G_DMA_DSCRB_PKT_SIZE(dsc->dscr_b) - 4;
-		
+
 		/*
 		 * Check packet status.  If good, process it.
 		 * If not, silently drop it and put it back on the
 		 * receive ring.
 		 */
-		
+
 		if (!(dsc->dscr_a & M_DMA_ETHRX_BAD)) {
-			
+
 			/*
 			 * Add a new buffer to replace the old one.  If we fail
 			 * to allocate a buffer, we're going to drop this
 			 * packet and put it right back on the receive ring.
 			 */
-			
+
 			if (sbdma_add_rcvbuffer(d,NULL) == -ENOBUFS) {
 				sc->sbm_stats.rx_dropped++;
 				sbdma_add_rcvbuffer(d,sb); /* re-add old buffer */
@@ -1221,7 +1215,7 @@
 				 * Set length into the packet
 				 */
 				skb_put(sb,len);
-				
+
 				/*
 				 * Buffer has been replaced on the
 				 * receive ring.  Pass the buffer to
@@ -1240,7 +1234,7 @@
 						sb->ip_summed = CHECKSUM_NONE;
 					}
 				}
-				
+
 				netif_rx(sb);
 			}
 		} else {
@@ -1251,14 +1245,14 @@
 			sc->sbm_stats.rx_errors++;
 			sbdma_add_rcvbuffer(d,sb);
 		}
-		
-		
-		/* 
+
+
+		/*
 		 * .. and advance to the next buffer.
 		 */
-		
+
 		d->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);
-		
+
 	}
 }
 
@@ -1266,17 +1260,17 @@
 
 /**********************************************************************
  *  SBDMA_TX_PROCESS(sc,d)
- *  
- *  Process "completed" transmit buffers on the specified DMA channel.  
+ *
+ *  Process "completed" transmit buffers on the specified DMA channel.
  *  This is normally called within the interrupt service routine.
  *  Note that this isn't really ideal for priority channels, since
- *  it processes all of the packets on a given channel before 
- *  returning. 
+ *  it processes all of the packets on a given channel before
+ *  returning.
  *
- *  Input parameters: 
+ *  Input parameters:
  *      sc - softc structure
  *  	   d - DMA channel context
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1290,21 +1284,21 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&(sc->sbm_lock), flags);
-	
+
 	for (;;) {
-		/* 
+		/*
 		 * figure out where we are (as an index) and where
 		 * the hardware is (also as an index)
 		 *
-		 * This could be done faster if (for example) the 
+		 * This could be done faster if (for example) the
 		 * descriptor table was page-aligned and contiguous in
 		 * both virtual and physical memory -- you could then
 		 * just compare the low-order bits of the virtual address
 		 * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)
 		 */
-		
+
 		curidx = d->sbdma_remptr - d->sbdma_dscrtable;
-		hwidx = (int) (((SBMAC_READCSR(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -
+		hwidx = (int) (((__raw_readq(d->sbdma_curdscr) & M_DMA_CURDSCR_ADDR) -
 				d->sbdma_dscrtable_phys) / sizeof(sbdmadscr_t));
 
 		/*
@@ -1312,75 +1306,75 @@
 		 * of the descriptors up to (but not including) the one that
 		 * the hardware is working on right now.
 		 */
-		
+
 		if (curidx == hwidx)
 			break;
-		
+
 		/*
 		 * Otherwise, get the packet's sk_buff ptr back
 		 */
-		
+
 		dsc = &(d->sbdma_dscrtable[curidx]);
 		sb = d->sbdma_ctxtable[curidx];
 		d->sbdma_ctxtable[curidx] = NULL;
-		
+
 		/*
 		 * Stats
 		 */
-		
+
 		sc->sbm_stats.tx_bytes += sb->len;
 		sc->sbm_stats.tx_packets++;
-		
+
 		/*
 		 * for transmits, we just free buffers.
 		 */
-		
+
 		dev_kfree_skb_irq(sb);
-		
-		/* 
+
+		/*
 		 * .. and advance to the next buffer.
 		 */
 
 		d->sbdma_remptr = SBDMA_NEXTBUF(d,sbdma_remptr);
-		
+
 	}
-	
+
 	/*
 	 * Decide if we should wake up the protocol or not.
 	 * Other drivers seem to do this when we reach a low
 	 * watermark on the transmit queue.
 	 */
-	
+
 	netif_wake_queue(d->sbdma_eth->sbm_dev);
-	
+
 	spin_unlock_irqrestore(&(sc->sbm_lock), flags);
-	
+
 }
 
 
 
 /**********************************************************************
  *  SBMAC_INITCTX(s)
- *  
+ *
  *  Initialize an Ethernet context structure - this is called
  *  once per MAC on the 1250.  Memory is allocated here, so don't
  *  call it again from inside the ioctl routines that bring the
  *  interface up/down
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac context structure
- *  	   
+ *
  *  Return value:
  *  	   0
  ********************************************************************* */
 
 static int sbmac_initctx(struct sbmac_softc *s)
 {
-	
-	/* 
-	 * figure out the addresses of some ports 
+
+	/*
+	 * figure out the addresses of some ports
 	 */
-	
+
 	s->sbm_macenable = s->sbm_base + R_MAC_ENABLE;
 	s->sbm_maccfg    = s->sbm_base + R_MAC_CFG;
 	s->sbm_fifocfg   = s->sbm_base + R_MAC_THRSH_CFG;
@@ -1397,29 +1391,29 @@
 	s->sbm_phy_oldanlpar = 0;
 	s->sbm_phy_oldk1stsr = 0;
 	s->sbm_phy_oldlinkstat = 0;
-	
+
 	/*
 	 * Initialize the DMA channels.  Right now, only one per MAC is used
 	 * Note: Only do this _once_, as it allocates memory from the kernel!
 	 */
-	
+
 	sbdma_initctx(&(s->sbm_txdma),s,0,DMA_TX,SBMAC_MAX_TXDESCR);
 	sbdma_initctx(&(s->sbm_rxdma),s,0,DMA_RX,SBMAC_MAX_RXDESCR);
-	
+
 	/*
 	 * initial state is OFF
 	 */
-	
+
 	s->sbm_state = sbmac_state_off;
-	
+
 	/*
 	 * Initial speed is (XXX TEMP) 10MBit/s HDX no FC
 	 */
-	
+
 	s->sbm_speed = sbmac_speed_10;
 	s->sbm_duplex = sbmac_duplex_half;
 	s->sbm_fc = sbmac_fc_disabled;
-	
+
 	return 0;
 }
 
@@ -1430,7 +1424,7 @@
 		kfree(d->sbdma_dscrtable);
 		d->sbdma_dscrtable = NULL;
 	}
-	
+
 	if (d->sbdma_ctxtable) {
 		kfree(d->sbdma_ctxtable);
 		d->sbdma_ctxtable = NULL;
@@ -1447,12 +1441,12 @@
 
 /**********************************************************************
  *  SBMAC_CHANNEL_START(s)
- *  
+ *
  *  Start packet processing on this MAC.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1460,50 +1454,50 @@
 static void sbmac_channel_start(struct sbmac_softc *s)
 {
 	uint64_t reg;
-	sbmac_port_t port;
+	volatile void __iomem *port;
 	uint64_t cfg,fifo,framecfg;
 	int idx, th_value;
-	
+
 	/*
 	 * Don't do this if running
 	 */
 
 	if (s->sbm_state == sbmac_state_on)
 		return;
-	
+
 	/*
 	 * Bring the controller out of reset, but leave it off.
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_macenable,0);
-	
+
+	__raw_writeq(0, s->sbm_macenable);
+
 	/*
 	 * Ignore all received packets
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_rxfilter,0);
-	
-	/* 
+
+	__raw_writeq(0, s->sbm_rxfilter);
+
+	/*
 	 * Calculate values for various control registers.
 	 */
-	
+
 	cfg = M_MAC_RETRY_EN |
-		M_MAC_TX_HOLD_SOP_EN | 
+		M_MAC_TX_HOLD_SOP_EN |
 		V_MAC_TX_PAUSE_CNT_16K |
 		M_MAC_AP_STAT_EN |
 		M_MAC_FAST_SYNC |
 		M_MAC_SS_EN |
 		0;
-	
-	/* 
+
+	/*
 	 * Be sure that RD_THRSH+WR_THRSH <= 32 for pass1 pars
 	 * and make sure that RD_THRSH + WR_THRSH <=128 for pass2 and above
 	 * Use a larger RD_THRSH for gigabit
 	 */
-	if (periph_rev >= 2) 
-		th_value = 64;
-	else 
+	if (soc_type == K_SYS_SOC_TYPE_BCM1250 && periph_rev < 2)
 		th_value = 28;
+	else
+		th_value = 64;
 
 	fifo = V_MAC_TX_WR_THRSH(4) |	/* Must be '4' or '8' */
 		((s->sbm_speed == sbmac_speed_1000)
@@ -1520,51 +1514,51 @@
 		V_MAC_BACKOFF_SEL(1);
 
 	/*
-	 * Clear out the hash address map 
+	 * Clear out the hash address map
 	 */
-	
+
 	port = s->sbm_base + R_MAC_HASH_BASE;
 	for (idx = 0; idx < MAC_HASH_COUNT; idx++) {
-		SBMAC_WRITECSR(port,0);
+		__raw_writeq(0, port);
 		port += sizeof(uint64_t);
 	}
-	
+
 	/*
 	 * Clear out the exact-match table
 	 */
-	
+
 	port = s->sbm_base + R_MAC_ADDR_BASE;
 	for (idx = 0; idx < MAC_ADDR_COUNT; idx++) {
-		SBMAC_WRITECSR(port,0);
+		__raw_writeq(0, port);
 		port += sizeof(uint64_t);
 	}
-	
+
 	/*
 	 * Clear out the DMA Channel mapping table registers
 	 */
-	
+
 	port = s->sbm_base + R_MAC_CHUP0_BASE;
 	for (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {
-		SBMAC_WRITECSR(port,0);
+		__raw_writeq(0, port);
 		port += sizeof(uint64_t);
 	}
 
 
 	port = s->sbm_base + R_MAC_CHLO0_BASE;
 	for (idx = 0; idx < MAC_CHMAP_COUNT; idx++) {
-		SBMAC_WRITECSR(port,0);
+		__raw_writeq(0, port);
 		port += sizeof(uint64_t);
 	}
-	
+
 	/*
 	 * Program the hardware address.  It goes into the hardware-address
 	 * register as well as the first filter register.
 	 */
-	
+
 	reg = sbmac_addr2reg(s->sbm_hwaddr);
-	
+
 	port = s->sbm_base + R_MAC_ADDR_BASE;
-	SBMAC_WRITECSR(port,reg);
+	__raw_writeq(reg, port);
 	port = s->sbm_base + R_MAC_ETHERNET_ADDR;
 
 #ifdef CONFIG_SB1_PASS_1_WORKAROUNDS
@@ -1573,108 +1567,109 @@
 	 * destination address in the R_MAC_ETHERNET_ADDR register.
 	 * Set the value to zero.
 	 */
-	SBMAC_WRITECSR(port,0);
+	__raw_writeq(0, port);
 #else
-	SBMAC_WRITECSR(port,reg);
+	__raw_writeq(reg, port);
 #endif
-	
+
 	/*
 	 * Set the receive filter for no packets, and write values
 	 * to the various config registers
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_rxfilter,0);
-	SBMAC_WRITECSR(s->sbm_imr,0);
-	SBMAC_WRITECSR(s->sbm_framecfg,framecfg);
-	SBMAC_WRITECSR(s->sbm_fifocfg,fifo);
-	SBMAC_WRITECSR(s->sbm_maccfg,cfg);
-	
+
+	__raw_writeq(0, s->sbm_rxfilter);
+	__raw_writeq(0, s->sbm_imr);
+	__raw_writeq(framecfg, s->sbm_framecfg);
+	__raw_writeq(fifo, s->sbm_fifocfg);
+	__raw_writeq(cfg, s->sbm_maccfg);
+
 	/*
 	 * Initialize DMA channels (rings should be ok now)
 	 */
-	
+
 	sbdma_channel_start(&(s->sbm_rxdma), DMA_RX);
 	sbdma_channel_start(&(s->sbm_txdma), DMA_TX);
-	
+
 	/*
 	 * Configure the speed, duplex, and flow control
 	 */
 
 	sbmac_set_speed(s,s->sbm_speed);
 	sbmac_set_duplex(s,s->sbm_duplex,s->sbm_fc);
-	
+
 	/*
 	 * Fill the receive ring
 	 */
-	
+
 	sbdma_fillring(&(s->sbm_rxdma));
-	
-	/* 
+
+	/*
 	 * Turn on the rest of the bits in the enable register
-	 */      
-	
-	SBMAC_WRITECSR(s->sbm_macenable,
-		       M_MAC_RXDMA_EN0 |
+	 */
+
+#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)
+	__raw_writeq(M_MAC_RXDMA_EN0 |
+		       M_MAC_TXDMA_EN0, s->sbm_macenable);
+#elif defined(CONFIG_SIBYTE_SB1250) || defined(CONFIG_SIBYTE_BCM112X)
+	__raw_writeq(M_MAC_RXDMA_EN0 |
 		       M_MAC_TXDMA_EN0 |
 		       M_MAC_RX_ENABLE |
-		       M_MAC_TX_ENABLE);
-	
-	
-
+		       M_MAC_TX_ENABLE, s->sbm_macenable);
+#else
+#error invalid SiByte MAC configuation
+#endif
 
 #ifdef CONFIG_SBMAC_COALESCE
 	/*
 	 * Accept any TX interrupt and EOP count/timer RX interrupts on ch 0
 	 */
-	SBMAC_WRITECSR(s->sbm_imr,
-		       ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |
-		       ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0));
+	__raw_writeq(((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_TX_CH0) |
+		       ((M_MAC_INT_EOP_COUNT | M_MAC_INT_EOP_TIMER) << S_MAC_RX_CH0), s->sbm_imr);
 #else
 	/*
 	 * Accept any kind of interrupt on TX and RX DMA channel 0
 	 */
-	SBMAC_WRITECSR(s->sbm_imr,
-		       (M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |
-		       (M_MAC_INT_CHANNEL << S_MAC_RX_CH0));
+	__raw_writeq((M_MAC_INT_CHANNEL << S_MAC_TX_CH0) |
+		       (M_MAC_INT_CHANNEL << S_MAC_RX_CH0), s->sbm_imr);
 #endif
-	
-	/* 
-	 * Enable receiving unicasts and broadcasts 
+
+	/*
+	 * Enable receiving unicasts and broadcasts
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_rxfilter,M_MAC_UCAST_EN | M_MAC_BCAST_EN);
-	
+
+	__raw_writeq(M_MAC_UCAST_EN | M_MAC_BCAST_EN, s->sbm_rxfilter);
+
 	/*
-	 * we're running now. 
+	 * we're running now.
 	 */
-	
+
 	s->sbm_state = sbmac_state_on;
-	
-	/* 
-	 * Program multicast addresses 
+
+	/*
+	 * Program multicast addresses
 	 */
-	
+
 	sbmac_setmulti(s);
-	
-	/* 
-	 * If channel was in promiscuous mode before, turn that on 
+
+	/*
+	 * If channel was in promiscuous mode before, turn that on
 	 */
-	
+
 	if (s->sbm_devflags & IFF_PROMISC) {
 		sbmac_promiscuous_mode(s,1);
 	}
-	
+
 }
 
 
 /**********************************************************************
  *  SBMAC_CHANNEL_STOP(s)
- *  
+ *
  *  Stop packet processing on this MAC.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1682,49 +1677,49 @@
 static void sbmac_channel_stop(struct sbmac_softc *s)
 {
 	/* don't do this if already stopped */
-	
+
 	if (s->sbm_state == sbmac_state_off)
 		return;
-	
+
 	/* don't accept any packets, disable all interrupts */
-	
-	SBMAC_WRITECSR(s->sbm_rxfilter,0);
-	SBMAC_WRITECSR(s->sbm_imr,0);
-	
+
+	__raw_writeq(0, s->sbm_rxfilter);
+	__raw_writeq(0, s->sbm_imr);
+
 	/* Turn off ticker */
-	
+
 	/* XXX */
-	
+
 	/* turn off receiver and transmitter */
-	
-	SBMAC_WRITECSR(s->sbm_macenable,0);
-	
+
+	__raw_writeq(0, s->sbm_macenable);
+
 	/* We're stopped now. */
-	
+
 	s->sbm_state = sbmac_state_off;
-	
+
 	/*
 	 * Stop DMA channels (rings should be ok now)
 	 */
-	
+
 	sbdma_channel_stop(&(s->sbm_rxdma));
 	sbdma_channel_stop(&(s->sbm_txdma));
-	
+
 	/* Empty the receive and transmit rings */
-	
+
 	sbdma_emptyring(&(s->sbm_rxdma));
 	sbdma_emptyring(&(s->sbm_txdma));
-	
+
 }
 
 /**********************************************************************
  *  SBMAC_SET_CHANNEL_STATE(state)
- *  
+ *
  *  Set the channel's state ON or OFF
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   state - new state
- *  	   
+ *
  *  Return value:
  *  	   old state
  ********************************************************************* */
@@ -1732,43 +1727,43 @@
 					     sbmac_state_t state)
 {
 	sbmac_state_t oldstate = sc->sbm_state;
-	
+
 	/*
 	 * If same as previous state, return
 	 */
-	
+
 	if (state == oldstate) {
 		return oldstate;
 	}
-	
+
 	/*
-	 * If new state is ON, turn channel on 
+	 * If new state is ON, turn channel on
 	 */
-	
+
 	if (state == sbmac_state_on) {
 		sbmac_channel_start(sc);
 	}
 	else {
 		sbmac_channel_stop(sc);
 	}
-	
+
 	/*
 	 * Return previous state
 	 */
-	
+
 	return oldstate;
 }
 
 
 /**********************************************************************
  *  SBMAC_PROMISCUOUS_MODE(sc,onoff)
- *  
+ *
  *  Turn on or off promiscuous mode
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   sc - softc
  *      onoff - 1 to turn on, 0 to turn off
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1776,30 +1771,30 @@
 static void sbmac_promiscuous_mode(struct sbmac_softc *sc,int onoff)
 {
 	uint64_t reg;
-	
+
 	if (sc->sbm_state != sbmac_state_on)
 		return;
-	
+
 	if (onoff) {
-		reg = SBMAC_READCSR(sc->sbm_rxfilter);
+		reg = __raw_readq(sc->sbm_rxfilter);
 		reg |= M_MAC_ALLPKT_EN;
-		SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
-	}	
+		__raw_writeq(reg, sc->sbm_rxfilter);
+	}
 	else {
-		reg = SBMAC_READCSR(sc->sbm_rxfilter);
+		reg = __raw_readq(sc->sbm_rxfilter);
 		reg &= ~M_MAC_ALLPKT_EN;
-		SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
+		__raw_writeq(reg, sc->sbm_rxfilter);
 	}
 }
 
 /**********************************************************************
  *  SBMAC_SETIPHDR_OFFSET(sc,onoff)
- *  
+ *
  *  Set the iphdr offset as 15 assuming ethernet encapsulation
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   sc - softc
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -1807,30 +1802,31 @@
 static void sbmac_set_iphdr_offset(struct sbmac_softc *sc)
 {
 	uint64_t reg;
-	
+
 	/* Hard code the off set to 15 for now */
-	reg = SBMAC_READCSR(sc->sbm_rxfilter);
+	reg = __raw_readq(sc->sbm_rxfilter);
 	reg &= ~M_MAC_IPHDR_OFFSET | V_MAC_IPHDR_OFFSET(15);
-	SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
-	
-	/* read system identification to determine revision */
-	if (periph_rev >= 2) {
-		sc->rx_hw_checksum = ENABLE;
-	} else {
+	__raw_writeq(reg, sc->sbm_rxfilter);
+
+	/* BCM1250 pass1 didn't have hardware checksum.  Everything
+	   later does.  */
+	if (soc_type == K_SYS_SOC_TYPE_BCM1250 && periph_rev < 2) {
 		sc->rx_hw_checksum = DISABLE;
+	} else {
+		sc->rx_hw_checksum = ENABLE;
 	}
 }
 
 
 /**********************************************************************
  *  SBMAC_ADDR2REG(ptr)
- *  
+ *
  *  Convert six bytes into the 64-bit register value that
  *  we typically write into the SBMAC's address/mcast registers
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   ptr - pointer to 6 bytes
- *  	   
+ *
  *  Return value:
  *  	   register value
  ********************************************************************* */
@@ -1838,35 +1834,35 @@
 static uint64_t sbmac_addr2reg(unsigned char *ptr)
 {
 	uint64_t reg = 0;
-	
+
 	ptr += 6;
-	
-	reg |= (uint64_t) *(--ptr); 
+
+	reg |= (uint64_t) *(--ptr);
 	reg <<= 8;
-	reg |= (uint64_t) *(--ptr); 
+	reg |= (uint64_t) *(--ptr);
 	reg <<= 8;
-	reg |= (uint64_t) *(--ptr); 
+	reg |= (uint64_t) *(--ptr);
 	reg <<= 8;
-	reg |= (uint64_t) *(--ptr); 
+	reg |= (uint64_t) *(--ptr);
 	reg <<= 8;
-	reg |= (uint64_t) *(--ptr); 
+	reg |= (uint64_t) *(--ptr);
 	reg <<= 8;
-	reg |= (uint64_t) *(--ptr); 
-	
+	reg |= (uint64_t) *(--ptr);
+
 	return reg;
 }
 
 
 /**********************************************************************
  *  SBMAC_SET_SPEED(s,speed)
- *  
+ *
  *  Configure LAN speed for the specified MAC.
  *  Warning: must be called when MAC is off!
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
  *  	   speed - speed to set MAC to (see sbmac_speed_t enum)
- *  	   
+ *
  *  Return value:
  *  	   1 if successful
  *      0 indicates invalid parameters
@@ -1880,31 +1876,31 @@
 	/*
 	 * Save new current values
 	 */
-	
+
 	s->sbm_speed = speed;
-	
+
 	if (s->sbm_state == sbmac_state_on)
 		return 0;	/* save for next restart */
 
 	/*
-	 * Read current register values 
+	 * Read current register values
 	 */
-	
-	cfg = SBMAC_READCSR(s->sbm_maccfg);
-	framecfg = SBMAC_READCSR(s->sbm_framecfg);
-	
+
+	cfg = __raw_readq(s->sbm_maccfg);
+	framecfg = __raw_readq(s->sbm_framecfg);
+
 	/*
 	 * Mask out the stuff we want to change
 	 */
-	
+
 	cfg &= ~(M_MAC_BURST_EN | M_MAC_SPEED_SEL);
 	framecfg &= ~(M_MAC_IFG_RX | M_MAC_IFG_TX | M_MAC_IFG_THRSH |
 		      M_MAC_SLOT_SIZE);
-	
+
 	/*
 	 * Now add in the new bits
 	 */
-	
+
 	switch (speed) {
 	case sbmac_speed_10:
 		framecfg |= V_MAC_IFG_RX_10 |
@@ -1913,7 +1909,7 @@
 			V_MAC_SLOT_SIZE_10;
 		cfg |= V_MAC_SPEED_SEL_10MBPS;
 		break;
-		
+
 	case sbmac_speed_100:
 		framecfg |= V_MAC_IFG_RX_100 |
 			V_MAC_IFG_TX_100 |
@@ -1921,7 +1917,7 @@
 			V_MAC_SLOT_SIZE_100;
 		cfg |= V_MAC_SPEED_SEL_100MBPS ;
 		break;
-		
+
 	case sbmac_speed_1000:
 		framecfg |= V_MAC_IFG_RX_1000 |
 			V_MAC_IFG_TX_1000 |
@@ -1929,34 +1925,34 @@
 			V_MAC_SLOT_SIZE_1000;
 		cfg |= V_MAC_SPEED_SEL_1000MBPS | M_MAC_BURST_EN;
 		break;
-		
+
 	case sbmac_speed_auto:		/* XXX not implemented */
 		/* fall through */
 	default:
 		return 0;
 	}
-	
+
 	/*
-	 * Send the bits back to the hardware 
+	 * Send the bits back to the hardware
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_framecfg,framecfg);
-	SBMAC_WRITECSR(s->sbm_maccfg,cfg);
-	
+
+	__raw_writeq(framecfg, s->sbm_framecfg);
+	__raw_writeq(cfg, s->sbm_maccfg);
+
 	return 1;
 }
 
 /**********************************************************************
  *  SBMAC_SET_DUPLEX(s,duplex,fc)
- *  
+ *
  *  Set Ethernet duplex and flow control options for this MAC
  *  Warning: must be called when MAC is off!
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   s - sbmac structure
  *  	   duplex - duplex setting (see sbmac_duplex_t)
  *  	   fc - flow control setting (see sbmac_fc_t)
- *  	   
+ *
  *  Return value:
  *  	   1 if ok
  *  	   0 if an invalid parameter combination was specified
@@ -1965,67 +1961,67 @@
 static int sbmac_set_duplex(struct sbmac_softc *s,sbmac_duplex_t duplex,sbmac_fc_t fc)
 {
 	uint64_t cfg;
-	
+
 	/*
 	 * Save new current values
 	 */
-	
+
 	s->sbm_duplex = duplex;
 	s->sbm_fc = fc;
-	
+
 	if (s->sbm_state == sbmac_state_on)
 		return 0;	/* save for next restart */
-	
+
 	/*
-	 * Read current register values 
+	 * Read current register values
 	 */
-	
-	cfg = SBMAC_READCSR(s->sbm_maccfg);
-	
+
+	cfg = __raw_readq(s->sbm_maccfg);
+
 	/*
 	 * Mask off the stuff we're about to change
 	 */
-	
+
 	cfg &= ~(M_MAC_FC_SEL | M_MAC_FC_CMD | M_MAC_HDX_EN);
-	
-	
+
+
 	switch (duplex) {
 	case sbmac_duplex_half:
 		switch (fc) {
 		case sbmac_fc_disabled:
 			cfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_DISABLED;
 			break;
-			
+
 		case sbmac_fc_collision:
 			cfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_ENABLED;
 			break;
-			
+
 		case sbmac_fc_carrier:
 			cfg |= M_MAC_HDX_EN | V_MAC_FC_CMD_ENAB_FALSECARR;
 			break;
-			
+
 		case sbmac_fc_auto:		/* XXX not implemented */
-			/* fall through */					   
+			/* fall through */
 		case sbmac_fc_frame:		/* not valid in half duplex */
 		default:			/* invalid selection */
 			return 0;
 		}
 		break;
-		
+
 	case sbmac_duplex_full:
 		switch (fc) {
 		case sbmac_fc_disabled:
 			cfg |= V_MAC_FC_CMD_DISABLED;
 			break;
-			
+
 		case sbmac_fc_frame:
 			cfg |= V_MAC_FC_CMD_ENABLED;
 			break;
-			
+
 		case sbmac_fc_collision:	/* not valid in full duplex */
 		case sbmac_fc_carrier:		/* not valid in full duplex */
 		case sbmac_fc_auto:		/* XXX not implemented */
-			/* fall through */					   
+			/* fall through */
 		default:
 			return 0;
 		}
@@ -2034,13 +2030,13 @@
 		/* XXX not implemented */
 		break;
 	}
-	
+
 	/*
-	 * Send the bits back to the hardware 
+	 * Send the bits back to the hardware
 	 */
-	
-	SBMAC_WRITECSR(s->sbm_maccfg,cfg);
-	
+
+	__raw_writeq(cfg, s->sbm_maccfg);
+
 	return 1;
 }
 
@@ -2049,12 +2045,12 @@
 
 /**********************************************************************
  *  SBMAC_INTR()
- *  
+ *
  *  Interrupt handler for MAC interrupts
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   MAC structure
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -2066,27 +2062,27 @@
 	int handled = 0;
 
 	for (;;) {
-		
+
 		/*
 		 * Read the ISR (this clears the bits in the real
 		 * register, except for counter addr)
 		 */
-		
-		isr = SBMAC_READCSR(sc->sbm_isr) & ~M_MAC_COUNTER_ADDR;
-		
+
+		isr = __raw_readq(sc->sbm_isr) & ~M_MAC_COUNTER_ADDR;
+
 		if (isr == 0)
 			break;
 
 		handled = 1;
-		
+
 		/*
 		 * Transmits on channel 0
 		 */
-		
+
 		if (isr & (M_MAC_INT_CHANNEL << S_MAC_TX_CH0)) {
 			sbdma_tx_process(sc,&(sc->sbm_txdma));
 		}
-		
+
 		/*
 		 * Receives on channel 0
 		 */
@@ -2106,8 +2102,8 @@
 		 * EOP_SEEN here takes care of this case.
 		 * (EOP_SEEN is part of M_MAC_INT_CHANNEL << S_MAC_RX_CH0)
 		 */
-		 
-		
+
+
 		if (isr & (M_MAC_INT_CHANNEL << S_MAC_RX_CH0)) {
 			sbdma_rx_process(sc,&(sc->sbm_rxdma));
 		}
@@ -2118,29 +2114,29 @@
 
 /**********************************************************************
  *  SBMAC_START_TX(skb,dev)
- *  
- *  Start output on the specified interface.  Basically, we 
+ *
+ *  Start output on the specified interface.  Basically, we
  *  queue as many buffers as we can until the ring fills up, or
  *  we run off the end of the queue, whichever comes first.
- *  
- *  Input parameters: 
- *  	   
- *  	   
+ *
+ *  Input parameters:
+ *
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
 static int sbmac_start_tx(struct sk_buff *skb, struct net_device *dev)
 {
 	struct sbmac_softc *sc = netdev_priv(dev);
-	
+
 	/* lock eth irq */
 	spin_lock_irq (&sc->sbm_lock);
-	
+
 	/*
-	 * Put the buffer on the transmit ring.  If we 
+	 * Put the buffer on the transmit ring.  If we
 	 * don't have room, stop the queue.
 	 */
-	
+
 	if (sbdma_add_txbuffer(&(sc->sbm_txdma),skb)) {
 		/* XXX save skb that we could not send */
 		netif_stop_queue(dev);
@@ -2148,24 +2144,24 @@
 
 		return 1;
 	}
-	
+
 	dev->trans_start = jiffies;
-	
+
 	spin_unlock_irq (&sc->sbm_lock);
-	
+
 	return 0;
 }
 
 /**********************************************************************
  *  SBMAC_SETMULTI(sc)
- *  
+ *
  *  Reprogram the multicast table into the hardware, given
  *  the list of multicasts associated with the interface
  *  structure.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   sc - softc
- *  	   
+ *
  *  Return value:
  *  	   nothing
  ********************************************************************* */
@@ -2173,89 +2169,89 @@
 static void sbmac_setmulti(struct sbmac_softc *sc)
 {
 	uint64_t reg;
-	sbmac_port_t port;
+	volatile void __iomem *port;
 	int idx;
 	struct dev_mc_list *mclist;
 	struct net_device *dev = sc->sbm_dev;
-	
-	/* 
+
+	/*
 	 * Clear out entire multicast table.  We do this by nuking
 	 * the entire hash table and all the direct matches except
-	 * the first one, which is used for our station address 
+	 * the first one, which is used for our station address
 	 */
-	
+
 	for (idx = 1; idx < MAC_ADDR_COUNT; idx++) {
 		port = sc->sbm_base + R_MAC_ADDR_BASE+(idx*sizeof(uint64_t));
-		SBMAC_WRITECSR(port,0);	
+		__raw_writeq(0, port);
 	}
-	
+
 	for (idx = 0; idx < MAC_HASH_COUNT; idx++) {
 		port = sc->sbm_base + R_MAC_HASH_BASE+(idx*sizeof(uint64_t));
-		SBMAC_WRITECSR(port,0);	
+		__raw_writeq(0, port);
 	}
-	
+
 	/*
 	 * Clear the filter to say we don't want any multicasts.
 	 */
-	
-	reg = SBMAC_READCSR(sc->sbm_rxfilter);
+
+	reg = __raw_readq(sc->sbm_rxfilter);
 	reg &= ~(M_MAC_MCAST_INV | M_MAC_MCAST_EN);
-	SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
-	
+	__raw_writeq(reg, sc->sbm_rxfilter);
+
 	if (dev->flags & IFF_ALLMULTI) {
-		/* 
-		 * Enable ALL multicasts.  Do this by inverting the 
-		 * multicast enable bit. 
+		/*
+		 * Enable ALL multicasts.  Do this by inverting the
+		 * multicast enable bit.
 		 */
-		reg = SBMAC_READCSR(sc->sbm_rxfilter);
+		reg = __raw_readq(sc->sbm_rxfilter);
 		reg |= (M_MAC_MCAST_INV | M_MAC_MCAST_EN);
-		SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
+		__raw_writeq(reg, sc->sbm_rxfilter);
 		return;
 	}
-	
 
-	/* 
+
+	/*
 	 * Progam new multicast entries.  For now, only use the
 	 * perfect filter.  In the future we'll need to use the
 	 * hash filter if the perfect filter overflows
 	 */
-	
+
 	/* XXX only using perfect filter for now, need to use hash
 	 * XXX if the table overflows */
-	
+
 	idx = 1;		/* skip station address */
 	mclist = dev->mc_list;
 	while (mclist && (idx < MAC_ADDR_COUNT)) {
 		reg = sbmac_addr2reg(mclist->dmi_addr);
 		port = sc->sbm_base + R_MAC_ADDR_BASE+(idx * sizeof(uint64_t));
-		SBMAC_WRITECSR(port,reg);
+		__raw_writeq(reg, port);
 		idx++;
 		mclist = mclist->next;
 	}
-	
-	/*	
+
+	/*
 	 * Enable the "accept multicast bits" if we programmed at least one
-	 * multicast. 
+	 * multicast.
 	 */
-	
+
 	if (idx > 1) {
-		reg = SBMAC_READCSR(sc->sbm_rxfilter);
+		reg = __raw_readq(sc->sbm_rxfilter);
 		reg |= M_MAC_MCAST_EN;
-		SBMAC_WRITECSR(sc->sbm_rxfilter,reg);
+		__raw_writeq(reg, sc->sbm_rxfilter);
 	}
 }
 
 
 
-#if defined(SBMAC_ETH0_HWADDR) || defined(SBMAC_ETH1_HWADDR) || defined(SBMAC_ETH2_HWADDR)
+#if defined(SBMAC_ETH0_HWADDR) || defined(SBMAC_ETH1_HWADDR) || defined(SBMAC_ETH2_HWADDR) || defined(SBMAC_ETH3_HWADDR)
 /**********************************************************************
  *  SBMAC_PARSE_XDIGIT(str)
- *  
+ *
  *  Parse a hex digit, returning its value
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   str - character
- *  	   
+ *
  *  Return value:
  *  	   hex value, or -1 if invalid
  ********************************************************************* */
@@ -2263,7 +2259,7 @@
 static int sbmac_parse_xdigit(char str)
 {
 	int digit;
-	
+
 	if ((str >= '0') && (str <= '9'))
 		digit = str - '0';
 	else if ((str >= 'a') && (str <= 'f'))
@@ -2272,20 +2268,20 @@
 		digit = str - 'A' + 10;
 	else
 		return -1;
-	
+
 	return digit;
 }
 
 /**********************************************************************
  *  SBMAC_PARSE_HWADDR(str,hwaddr)
- *  
+ *
  *  Convert a string in the form xx:xx:xx:xx:xx:xx into a 6-byte
  *  Ethernet address.
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   str - string
  *  	   hwaddr - pointer to hardware address
- *  	   
+ *
  *  Return value:
  *  	   0 if ok, else -1
  ********************************************************************* */
@@ -2294,7 +2290,7 @@
 {
 	int digit1,digit2;
 	int idx = 6;
-	
+
 	while (*str && (idx > 0)) {
 		digit1 = sbmac_parse_xdigit(*str);
 		if (digit1 < 0)
@@ -2302,7 +2298,7 @@
 		str++;
 		if (!*str)
 			return -1;
-		
+
 		if ((*str == ':') || (*str == '-')) {
 			digit2 = digit1;
 			digit1 = 0;
@@ -2313,10 +2309,10 @@
 				return -1;
 			str++;
 		}
-		
+
 		*hwaddr++ = (digit1 << 4) | digit2;
 		idx--;
-		
+
 		if (*str == '-')
 			str++;
 		if (*str == ':')
@@ -2337,12 +2333,12 @@
 
 /**********************************************************************
  *  SBMAC_INIT(dev)
- *  
+ *
  *  Attach routine - init hardware and hook ourselves into linux
- *  
- *  Input parameters: 
+ *
+ *  Input parameters:
  *  	   dev - net_device structure
- *  	   
+ *
  *  Return value:
  *  	   status
  ********************************************************************* */
@@ -2354,53 +2350,53 @@
 	uint64_t ea_reg;
 	int i;
 	int err;
-	
+
 	sc = netdev_priv(dev);
-	
+
 	/* Determine controller base address */
-	
+
 	sc->sbm_base = IOADDR(dev->base_addr);
 	sc->sbm_dev = dev;
 	sc->sbe_idx = idx;
-	
+
 	eaddr = sc->sbm_hwaddr;
-	
-	/* 
+
+	/*
 	 * Read the ethernet address.  The firwmare left this programmed
 	 * for us in the ethernet address register for each mac.
 	 */
-	
-	ea_reg = SBMAC_READCSR(sc->sbm_base + R_MAC_ETHERNET_ADDR);
-	SBMAC_WRITECSR(sc->sbm_base + R_MAC_ETHERNET_ADDR, 0);
+
+	ea_reg = __raw_readq(sc->sbm_base + R_MAC_ETHERNET_ADDR);
+	__raw_writeq(0, sc->sbm_base + R_MAC_ETHERNET_ADDR);
 	for (i = 0; i < 6; i++) {
 		eaddr[i] = (uint8_t) (ea_reg & 0xFF);
 		ea_reg >>= 8;
 	}
-	
+
 	for (i = 0; i < 6; i++) {
 		dev->dev_addr[i] = eaddr[i];
 	}
-	
-	
+
+
 	/*
-	 * Init packet size 
+	 * Init packet size
 	 */
-	
+
 	sc->sbm_buffersize = ENET_PACKET_SIZE + SMP_CACHE_BYTES * 2 + ETHER_ALIGN;
 
-	/* 
+	/*
 	 * Initialize context (get pointers to registers and stuff), then
 	 * allocate the memory for the descriptor tables.
 	 */
-	
+
 	sbmac_initctx(sc);
-	
+
 	/*
 	 * Set up Linux device callins
 	 */
-	
+
 	spin_lock_init(&(sc->sbm_lock));
-	
+
 	dev->open               = sbmac_open;
 	dev->hard_start_xmit    = sbmac_start_tx;
 	dev->stop               = sbmac_close;
@@ -2419,6 +2415,11 @@
 	if (err)
 		goto out_uninit;
 
+	if (sc->rx_hw_checksum == ENABLE) {
+		printk(KERN_INFO "%s: enabling TCP rcv checksum\n",
+			sc->sbm_dev->name);
+	}
+
 	if (periph_rev >= 2) {
 		printk(KERN_INFO "%s: enabling TCP rcv checksum\n",
 			sc->sbm_dev->name);
@@ -2430,10 +2431,10 @@
 	 * was being displayed)
 	 */
 	printk(KERN_INFO
-	       "%s: SiByte Ethernet at 0x%08lX, address: %02X:%02X:%02X:%02X:%02X:%02X\n", 
+	       "%s: SiByte Ethernet at 0x%08lX, address: %02X:%02X:%02X:%02X:%02X:%02X\n",
 	       dev->name, dev->base_addr,
 	       eaddr[0],eaddr[1],eaddr[2],eaddr[3],eaddr[4],eaddr[5]);
-	
+
 
 	return 0;
 
@@ -2447,54 +2448,86 @@
 static int sbmac_open(struct net_device *dev)
 {
 	struct sbmac_softc *sc = netdev_priv(dev);
-	
+
 	if (debug > 1) {
 		printk(KERN_DEBUG "%s: sbmac_open() irq %d.\n", dev->name, dev->irq);
 	}
-	
-	/* 
+
+	/*
 	 * map/route interrupt (clear status first, in case something
 	 * weird is pending; we haven't initialized the mac registers
 	 * yet)
 	 */
 
-	SBMAC_READCSR(sc->sbm_isr);
+	__raw_readq(sc->sbm_isr);
 	if (request_irq(dev->irq, &sbmac_intr, SA_SHIRQ, dev->name, dev))
 		return -EBUSY;
 
 	/*
-	 * Configure default speed 
+	 * Probe phy address
+	 */
+
+	if(sbmac_mii_probe(dev) == -1) {
+		printk("%s: failed to probe PHY.\n", dev->name);
+		return -EINVAL;
+	}
+
+	/*
+	 * Configure default speed
 	 */
 
 	sbmac_mii_poll(sc,noisy_mii);
-	
+
 	/*
 	 * Turn on the channel
 	 */
 
 	sbmac_set_channel_state(sc,sbmac_state_on);
-	
+
 	/*
 	 * XXX Station address is in dev->dev_addr
 	 */
-	
+
 	if (dev->if_port == 0)
-		dev->if_port = 0; 
-	
+		dev->if_port = 0;
+
 	netif_start_queue(dev);
-	
+
 	sbmac_set_rx_mode(dev);
-	
+
 	/* Set the timer to check for link beat. */
 	init_timer(&sc->sbm_timer);
 	sc->sbm_timer.expires = jiffies + 2 * HZ/100;
 	sc->sbm_timer.data = (unsigned long)dev;
 	sc->sbm_timer.function = &sbmac_timer;
 	add_timer(&sc->sbm_timer);
-	
+
 	return 0;
 }
 
+static int sbmac_mii_probe(struct net_device *dev)
+{
+	int i;
+	struct sbmac_softc *s = netdev_priv(dev);
+	u16 bmsr, id1, id2;
+	u32 vendor, device;
+
+	for (i=1; i<31; i++) {
+	bmsr = sbmac_mii_read(s, i, MII_BMSR);
+		if (bmsr != 0) {
+			s->sbm_phys[0] = i;
+			id1 = sbmac_mii_read(s, i, MII_PHYIDR1);
+			id2 = sbmac_mii_read(s, i, MII_PHYIDR2);
+			vendor = ((u32)id1 << 6) | ((id2 >> 10) & 0x3f);
+			device = (id2 >> 4) & 0x3f;
+
+			printk(KERN_INFO "%s: found phy %d, vendor %06x part %02x\n",
+				dev->name, i, vendor, device);
+			return i;
+		}
+	}
+	return -1;
+}
 
 
 static int sbmac_mii_poll(struct sbmac_softc *s,int noisy)
@@ -2609,20 +2642,20 @@
 	int mii_status;
 
 	spin_lock_irq (&sc->sbm_lock);
-	
+
 	/* make IFF_RUNNING follow the MII status bit "Link established" */
 	mii_status = sbmac_mii_read(sc, sc->sbm_phys[0], MII_BMSR);
-	
+
 	if ( (mii_status & BMSR_LINKSTAT) != (sc->sbm_phy_oldlinkstat) ) {
     	        sc->sbm_phy_oldlinkstat = mii_status & BMSR_LINKSTAT;
 		if (mii_status & BMSR_LINKSTAT) {
 			netif_carrier_on(dev);
 		}
 		else {
-			netif_carrier_off(dev);	
+			netif_carrier_off(dev);
 		}
 	}
-	
+
 	/*
 	 * Poll the PHY to see what speed we should be running at
 	 */
@@ -2640,9 +2673,9 @@
 			sbmac_channel_start(sc);
 		}
 	}
-	
+
 	spin_unlock_irq (&sc->sbm_lock);
-	
+
 	sc->sbm_timer.expires = jiffies + next_tick;
 	add_timer(&sc->sbm_timer);
 }
@@ -2651,13 +2684,13 @@
 static void sbmac_tx_timeout (struct net_device *dev)
 {
 	struct sbmac_softc *sc = netdev_priv(dev);
-	
+
 	spin_lock_irq (&sc->sbm_lock);
-	
-	
+
+
 	dev->trans_start = jiffies;
 	sc->sbm_stats.tx_errors++;
-	
+
 	spin_unlock_irq (&sc->sbm_lock);
 
 	printk (KERN_WARNING "%s: Transmit timed out\n",dev->name);
@@ -2670,13 +2703,13 @@
 {
 	struct sbmac_softc *sc = netdev_priv(dev);
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&sc->sbm_lock, flags);
-	
+
 	/* XXX update other stats here */
-	
+
 	spin_unlock_irqrestore(&sc->sbm_lock, flags);
-	
+
 	return &sc->sbm_stats;
 }
 
@@ -2693,8 +2726,8 @@
 		/*
 		 * Promiscuous changed.
 		 */
-		
-		if (dev->flags & IFF_PROMISC) {	
+
+		if (dev->flags & IFF_PROMISC) {
 			/* Unconditionally log net taps. */
 			msg_flag = 1;
 			sbmac_promiscuous_mode(sc,1);
@@ -2705,18 +2738,18 @@
 		}
 	}
 	spin_unlock_irqrestore(&sc->sbm_lock, flags);
-	
+
 	if (msg_flag) {
 		printk(KERN_NOTICE "%s: Promiscuous mode %sabled.\n",
 		       dev->name,(msg_flag==1)?"en":"dis");
 	}
-	
+
 	/*
 	 * Program the multicasts.  Do this every time.
 	 */
-	
+
 	sbmac_setmulti(sc);
-	
+
 }
 
 static int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
@@ -2725,10 +2758,10 @@
 	u16 *data = (u16 *)&rq->ifr_ifru;
 	unsigned long flags;
 	int retval;
-	
+
 	spin_lock_irqsave(&sc->sbm_lock, flags);
 	retval = 0;
-	
+
 	switch(cmd) {
 	case SIOCDEVPRIVATE:		/* Get the address of the PHY in use. */
 		data[0] = sc->sbm_phys[0] & 0x1f;
@@ -2750,7 +2783,7 @@
 	default:
 		retval = -EOPNOTSUPP;
 	}
-	
+
 	spin_unlock_irqrestore(&sc->sbm_lock, flags);
 	return retval;
 }
@@ -2781,25 +2814,25 @@
 
 	sbdma_emptyring(&(sc->sbm_txdma));
 	sbdma_emptyring(&(sc->sbm_rxdma));
-	
+
 	return 0;
 }
 
 
 
-#if defined(SBMAC_ETH0_HWADDR) || defined(SBMAC_ETH1_HWADDR) || defined(SBMAC_ETH2_HWADDR)
+#if defined(SBMAC_ETH0_HWADDR) || defined(SBMAC_ETH1_HWADDR) || defined(SBMAC_ETH2_HWADDR) || defined(SBMAC_ETH3_HWADDR)
 static void
 sbmac_setup_hwaddr(int chan,char *addr)
 {
 	uint8_t eaddr[6];
 	uint64_t val;
-	sbmac_port_t port;
+	unsigned long port;
 
 	port = A_MAC_CHANNEL_BASE(chan);
 	sbmac_parse_hwaddr(addr,eaddr);
 	val = sbmac_addr2reg(eaddr);
-	SBMAC_WRITECSR(IOADDR(port+R_MAC_ETHERNET_ADDR),val);
-	val = SBMAC_READCSR(IOADDR(port+R_MAC_ETHERNET_ADDR));
+	__raw_writeq(val, IOADDR(port+R_MAC_ETHERNET_ADDR));
+	val = __raw_readq(IOADDR(port+R_MAC_ETHERNET_ADDR));
 }
 #endif
 
@@ -2810,28 +2843,10 @@
 {
 	int idx;
 	struct net_device *dev;
-	sbmac_port_t port;
+	unsigned long port;
 	int chip_max_units;
-	
-	/*
-	 * For bringup when not using the firmware, we can pre-fill
-	 * the MAC addresses using the environment variables
-	 * specified in this file (or maybe from the config file?)
-	 */
-#ifdef SBMAC_ETH0_HWADDR
-	sbmac_setup_hwaddr(0,SBMAC_ETH0_HWADDR);
-#endif
-#ifdef SBMAC_ETH1_HWADDR
-	sbmac_setup_hwaddr(1,SBMAC_ETH1_HWADDR);
-#endif
-#ifdef SBMAC_ETH2_HWADDR
-	sbmac_setup_hwaddr(2,SBMAC_ETH2_HWADDR);
-#endif
 
-	/*
-	 * Walk through the Ethernet controllers and find
-	 * those who have their MAC addresses set.
-	 */
+	/* Set the number of available units based on the SOC type.  */
 	switch (soc_type) {
 	case K_SYS_SOC_TYPE_BCM1250:
 	case K_SYS_SOC_TYPE_BCM1250_ALT:
@@ -2843,6 +2858,10 @@
 	case K_SYS_SOC_TYPE_BCM1250_ALT2: /* Hybrid */
 		chip_max_units = 2;
 		break;
+	case K_SYS_SOC_TYPE_BCM1x55:
+	case K_SYS_SOC_TYPE_BCM1x80:
+		chip_max_units = 4;
+		break;
 	default:
 		chip_max_units = 0;
 		break;
@@ -2850,6 +2869,32 @@
 	if (chip_max_units > MAX_UNITS)
 		chip_max_units = MAX_UNITS;
 
+	/*
+	 * For bringup when not using the firmware, we can pre-fill
+	 * the MAC addresses using the environment variables
+	 * specified in this file (or maybe from the config file?)
+	 */
+#ifdef SBMAC_ETH0_HWADDR
+	if (chip_max_units > 0)
+	  sbmac_setup_hwaddr(0,SBMAC_ETH0_HWADDR);
+#endif
+#ifdef SBMAC_ETH1_HWADDR
+	if (chip_max_units > 1)
+	  sbmac_setup_hwaddr(1,SBMAC_ETH1_HWADDR);
+#endif
+#ifdef SBMAC_ETH2_HWADDR
+	if (chip_max_units > 2)
+	  sbmac_setup_hwaddr(2,SBMAC_ETH2_HWADDR);
+#endif
+#ifdef SBMAC_ETH3_HWADDR
+	if (chip_max_units > 3)
+	  sbmac_setup_hwaddr(3,SBMAC_ETH3_HWADDR);
+#endif
+
+	/*
+	 * Walk through the Ethernet controllers and find
+	 * those who have their MAC addresses set.
+	 */
 	for (idx = 0; idx < chip_max_units; idx++) {
 
 	        /*
@@ -2858,13 +2903,13 @@
 
 	        port = A_MAC_CHANNEL_BASE(idx);
 
-		/*	
+		/*
 		 * The R_MAC_ETHERNET_ADDR register will be set to some nonzero
 		 * value for us by the firmware if we're going to use this MAC.
 		 * If we find a zero, skip this MAC.
 		 */
 
-		sbmac_orig_hwaddr[idx] = SBMAC_READCSR(IOADDR(port+R_MAC_ETHERNET_ADDR));
+		sbmac_orig_hwaddr[idx] = __raw_readq(IOADDR(port+R_MAC_ETHERNET_ADDR));
 		if (sbmac_orig_hwaddr[idx] == 0) {
 			printk(KERN_DEBUG "sbmac: not configuring MAC at "
 			       "%lx\n", port);
@@ -2876,18 +2921,17 @@
 		 */
 
 		dev = alloc_etherdev(sizeof(struct sbmac_softc));
-		if (!dev) 
+		if (!dev)
 			return -ENOMEM;	/* return ENOMEM */
 
 		printk(KERN_DEBUG "sbmac: configuring MAC at %lx\n", port);
 
-		dev->irq = K_INT_MAC_0 + idx;
+		dev->irq = UNIT_INT(idx);
 		dev->base_addr = port;
 		dev->mem_end = 0;
 		if (sbmac_init(dev, idx)) {
 			port = A_MAC_CHANNEL_BASE(idx);
-			SBMAC_WRITECSR(IOADDR(port+R_MAC_ETHERNET_ADDR),
-				       sbmac_orig_hwaddr[idx]);
+			__raw_writeq(sbmac_orig_hwaddr[idx], IOADDR(port+R_MAC_ETHERNET_ADDR));
 			free_netdev(dev);
 			continue;
 		}
diff -Naur linux-2.6.14/drivers/net/sgiseeq.c linux-mips-2.6.14.orig/drivers/net/sgiseeq.c
--- linux-2.6.14/drivers/net/sgiseeq.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/sgiseeq.c	2005-11-17 11:43:11.000000000 -0800
@@ -32,8 +32,6 @@
 
 #include "sgiseeq.h"
 
-static char *version = "sgiseeq.c: David S. Miller (dm@engr.sgi.com)\n";
-
 static char *sgiseeqstr = "SGI Seeq8003";
 
 /*
@@ -113,9 +111,9 @@
 
 static inline void hpc3_eth_reset(struct hpc3_ethregs *hregs)
 {
-	hregs->rx_reset = HPC3_ERXRST_CRESET | HPC3_ERXRST_CLRIRQ;
+	hregs->reset = HPC3_ERST_CRESET | HPC3_ERST_CLRIRQ;
 	udelay(20);
-	hregs->rx_reset = 0;
+	hregs->reset = 0;
 }
 
 static inline void reset_hpc3_and_seeq(struct hpc3_ethregs *hregs,
@@ -252,7 +250,6 @@
 
 #define TSTAT_INIT_SEEQ (SEEQ_TCMD_IPT|SEEQ_TCMD_I16|SEEQ_TCMD_IC|SEEQ_TCMD_IUF)
 #define TSTAT_INIT_EDLC ((TSTAT_INIT_SEEQ) | SEEQ_TCMD_RB2)
-#define RDMACFG_INIT    (HPC3_ERXDCFG_FRXDC | HPC3_ERXDCFG_FEOP | HPC3_ERXDCFG_FIRQ)
 
 static int init_seeq(struct net_device *dev, struct sgiseeq_private *sp,
 		     struct sgiseeq_regs *sregs)
@@ -274,8 +271,6 @@
 		sregs->tstat = TSTAT_INIT_SEEQ;
 	}
 
-	hregs->rx_dconfig |= RDMACFG_INIT;
-
 	hregs->rx_ndptr = CPHYSADDR(sp->rx_desc);
 	hregs->tx_ndptr = CPHYSADDR(sp->tx_desc);
 
@@ -446,7 +441,7 @@
 	spin_lock(&sp->tx_lock);
 
 	/* Ack the IRQ and set software state. */
-	hregs->rx_reset = HPC3_ERXRST_CLRIRQ;
+	hregs->reset = HPC3_ERST_CLRIRQ;
 
 	/* Always check for received packets. */
 	sgiseeq_rx(dev, sp, hregs, sregs);
@@ -493,11 +488,13 @@
 {
 	struct sgiseeq_private *sp = netdev_priv(dev);
 	struct sgiseeq_regs *sregs = sp->sregs;
+	unsigned int irq = dev->irq;
 
 	netif_stop_queue(dev);
 
 	/* Shutdown the Seeq. */
 	reset_hpc3_and_seeq(sp->hregs, sregs);
+	free_irq(irq, dev);
 
 	return 0;
 }
@@ -644,7 +641,7 @@
 
 #define ALIGNED(x)  ((((unsigned long)(x)) + 0xf) & ~(0xf))
 
-static int sgiseeq_init(struct hpc3_regs* regs, int irq)
+static int sgiseeq_init(struct hpc3_regs* hpcregs, int irq)
 {
 	struct sgiseeq_init_block *sr;
 	struct sgiseeq_private *sp;
@@ -680,8 +677,8 @@
 	gpriv = sp;
 	gdev = dev;
 #endif
-	sp->sregs = (struct sgiseeq_regs *) &hpc3c0->eth_ext[0];
-	sp->hregs = &hpc3c0->ethregs;
+	sp->sregs = (struct sgiseeq_regs *) &hpcregs->eth_ext[0];
+	sp->hregs = &hpcregs->ethregs;
 	sp->name = sgiseeqstr;
 	sp->mode = SEEQ_RCMD_RBCAST;
 
@@ -698,6 +695,11 @@
 	setup_rx_ring(sp->rx_desc, SEEQ_RX_BUFFERS);
 	setup_tx_ring(sp->tx_desc, SEEQ_TX_BUFFERS);
 
+	/* Setup PIO and DMA transfer timing */
+	sp->hregs->pconfig = 0x161;
+	sp->hregs->dconfig = HPC3_EDCFG_FIRQ | HPC3_EDCFG_FEOP |
+			     HPC3_EDCFG_FRXDC | HPC3_EDCFG_PTO | 0x026;
+
 	/* Reset the chip. */
 	hpc3_eth_reset(sp->hregs);
 
@@ -724,7 +726,7 @@
 		goto err_out_free_page;
 	}
 
-	printk(KERN_INFO "%s: SGI Seeq8003 ", dev->name);
+	printk(KERN_INFO "%s: %s ", dev->name, sgiseeqstr);
 	for (i = 0; i < 6; i++)
 		printk("%2.2x%c", dev->dev_addr[i], i == 5 ? '\n' : ':');
 
@@ -734,7 +736,7 @@
 	return 0;
 
 err_out_free_page:
-	free_page((unsigned long) sp);
+	free_page((unsigned long) sp->srings);
 err_out_free_dev:
 	kfree(dev);
 
@@ -744,8 +746,6 @@
 
 static int __init sgiseeq_probe(void)
 {
-	printk(version);
-
 	/* On board adapter on 1st HPC is always present */
 	return sgiseeq_init(hpc3c0, SGI_ENET_IRQ);
 }
@@ -754,15 +754,12 @@
 {
 	struct net_device *next, *dev;
 	struct sgiseeq_private *sp;
-	int irq;
 
 	for (dev = root_sgiseeq_dev; dev; dev = next) {
 		sp = (struct sgiseeq_private *) netdev_priv(dev);
 		next = sp->next_module;
-		irq = dev->irq;
 		unregister_netdev(dev);
-		free_irq(irq, dev);
-		free_page((unsigned long) sp);
+		free_page((unsigned long) sp->srings);
 		free_netdev(dev);
 	}
 }
@@ -770,4 +767,6 @@
 module_init(sgiseeq_probe);
 module_exit(sgiseeq_exit);
 
+MODULE_DESCRIPTION("SGI Seeq 8003 driver");
+MODULE_AUTHOR("Linux/MIPS Mailing List <linux-mips@linux-mips.org>");
 MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/drivers/net/titan_ge.c linux-mips-2.6.14.orig/drivers/net/titan_ge.c
--- linux-2.6.14/drivers/net/titan_ge.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/titan_ge.c	2005-11-17 11:43:12.000000000 -0800
@@ -0,0 +1,2071 @@
+/*
+ * drivers/net/titan_ge.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * The MAC unit of the Titan consists of the following:
+ *
+ * -> XDMA Engine to move data to from the memory to the MAC packet FIFO
+ * -> FIFO is where the incoming and outgoing data is placed
+ * -> TRTG is the unit that pulls the data from the FIFO for Tx and pushes
+ *    the data into the FIFO for Rx
+ * -> TMAC is the outgoing MAC interface and RMAC is the incoming.
+ * -> AFX is the address filtering block
+ * -> GMII block to communicate with the PHY
+ *
+ * Rx will look like the following:
+ * GMII --> RMAC --> AFX --> TRTG --> Rx FIFO --> XDMA --> CPU memory
+ *
+ * Tx will look like the following:
+ * CPU memory --> XDMA --> Tx FIFO --> TRTG --> TMAC --> GMII
+ *
+ * The Titan driver has support for the following performance features:
+ * -> Rx side checksumming
+ * -> Jumbo Frames
+ * -> Interrupt Coalscing
+ * -> Rx NAPI
+ * -> SKB Recycling
+ * -> Transmit/Receive descriptors in SRAM
+ * -> Fast routing for IP forwarding
+ */
+
+#include <linux/config.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/init.h>
+#include <linux/in.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/prefetch.h>
+
+/* For MII specifc registers, titan_mdio.h should be included */
+#include <net/ip.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/titan_dep.h>
+
+#include "titan_ge.h"
+#include "titan_mdio.h"
+
+/* Static Function Declarations	 */
+static int titan_ge_eth_open(struct net_device *);
+static void titan_ge_eth_stop(struct net_device *);
+static struct net_device_stats *titan_ge_get_stats(struct net_device *);
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info *, int, int,
+				      unsigned long, unsigned long,
+				      unsigned long);
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info *, int,
+				      unsigned long, unsigned long);
+
+static int titan_ge_open(struct net_device *);
+static int titan_ge_start_xmit(struct sk_buff *, struct net_device *);
+static int titan_ge_stop(struct net_device *);
+
+static unsigned long titan_ge_tx_coal(unsigned long, int);
+
+static void titan_ge_port_reset(unsigned int);
+static int titan_ge_free_tx_queue(titan_ge_port_info *);
+static int titan_ge_rx_task(struct net_device *, titan_ge_port_info *);
+static int titan_ge_port_start(struct net_device *, titan_ge_port_info *);
+
+static int titan_ge_return_tx_desc(titan_ge_port_info *, int);
+
+/*
+ * Some configuration for the FIFO and the XDMA channel needs
+ * to be done only once for all the ports. This flag controls
+ * that
+ */
+static unsigned long config_done;
+
+/*
+ * One time out of memory flag
+ */
+static unsigned int oom_flag;
+
+static int titan_ge_poll(struct net_device *netdev, int *budget);
+
+static int titan_ge_receive_queue(struct net_device *, unsigned int);
+
+static struct platform_device *titan_ge_device[3];
+
+/* MAC Address */
+extern unsigned char titan_ge_mac_addr_base[6];
+
+unsigned long titan_ge_base;
+static unsigned long titan_ge_sram;
+
+static char titan_string[] = "titan";
+
+/*
+ * The Titan GE has two alignment requirements:
+ * -> skb->data to be cacheline aligned (32 byte)
+ * -> IP header alignment to 16 bytes
+ *
+ * The latter is not implemented. So, that results in an extra copy on
+ * the Rx. This is a big performance hog. For the former case, the
+ * dev_alloc_skb() has been replaced with titan_ge_alloc_skb(). The size
+ * requested is calculated:
+ *
+ * Ethernet Frame Size : 1518
+ * Ethernet Header     : 14
+ * Future Titan change for IP header alignment : 2
+ *
+ * Hence, we allocate (1518 + 14 + 2+ 64) = 1580 bytes.  For IP header
+ * alignment, we use skb_reserve().
+ */
+
+#define ALIGNED_RX_SKB_ADDR(addr) \
+	((((unsigned long)(addr) + (64UL - 1UL)) \
+	& ~(64UL - 1UL)) - (unsigned long)(addr))
+
+#define titan_ge_alloc_skb(__length, __gfp_flags) \
+({      struct sk_buff *__skb; \
+	__skb = alloc_skb((__length) + 64, (__gfp_flags)); \
+	if(__skb) { \
+		int __offset = (int) ALIGNED_RX_SKB_ADDR(__skb->data); \
+		if(__offset) \
+			skb_reserve(__skb, __offset); \
+	} \
+	__skb; \
+})
+
+/*
+ * Configure the GMII block of the Titan based on what the PHY tells us
+ */
+static void titan_ge_gmii_config(int port_num)
+{
+	unsigned int reg_data = 0, phy_reg;
+	int err;
+
+	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		printk(KERN_ERR
+			"Setting speed to 1000 Mbps and Duplex to Full \n");
+
+		return;
+	}
+
+	err = titan_ge_mdio_write(port_num, TITAN_GE_MDIO_PHY_IE, 0);
+
+	if (phy_reg & 0x8000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x201);
+		}  else {
+			/* Half Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2201);
+			}
+	}
+	if (phy_reg & 0x4000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x100);
+		} else {
+			/* Half Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2100);
+		}
+	}
+	reg_data = TITAN_GE_READ(TITAN_GE_GMII_CONFIG_GENERAL +
+				(port_num << 12));
+	reg_data |= 0x3;
+	TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_GENERAL +
+			(port_num << 12)), reg_data);
+}
+
+/*
+ * Enable the TMAC if it is not
+ */
+static void titan_ge_enable_tx(unsigned int port_num)
+{
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	if (!(reg_data & 0x8000)) {
+		printk("TMAC disabled for port %d!! \n", port_num);
+
+		reg_data |= 0x0001;	/* Enable TMAC */
+		reg_data |= 0x4000;	/* CRC Check Enable */
+		reg_data |= 0x2000;	/* Padding enable */
+		reg_data |= 0x0800;	/* CRC Add enable */
+		reg_data |= 0x0080;	/* PAUSE frame */
+
+		TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12)), reg_data);
+	}
+}
+
+/*
+ * Tx Timeout function
+ */
+static void titan_ge_tx_timeout(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	printk(KERN_INFO "%s: TX timeout  ", netdev->name);
+	printk(KERN_INFO "Resetting card \n");
+
+	/* Do the reset outside of interrupt context */
+	schedule_work(&titan_ge_eth->tx_timeout_task);
+}
+
+/*
+ * Update the AFX tables for UC and MC for slice 0 only
+ */
+static void titan_ge_update_afx(titan_ge_port_info * titan_ge_eth)
+{
+	int port = titan_ge_eth->port_num;
+	unsigned int i;
+	volatile unsigned long reg_data = 0;
+	u8 p_addr[6];
+
+	memcpy(p_addr, titan_ge_eth->port_mac_addr, 6);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((0x112c | (port << 12)), 0x1);
+	/* Configure the eight address filters */
+	for (i = 0; i < 8; i++) {
+		/* Select each of the eight filters */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_2 +
+				(port << 12)), i);
+
+		/* Configure the match */
+		reg_data = 0x9;	/* Forward Enable Bit */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_0 +
+				(port << 12)), reg_data);
+
+		/* Finally, AFX Exact Match Address Registers */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_LOW + (port << 12)),
+			       ((p_addr[1] << 8) | p_addr[0]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_MID + (port << 12)),
+			       ((p_addr[3] << 8) | p_addr[2]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_HIGH + (port << 12)),
+			       ((p_addr[5] << 8) | p_addr[4]));
+
+		/* VLAN id set to 0 */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_VID +
+				(port << 12)), 0);
+	}
+}
+
+/*
+ * Actual Routine to reset the adapter when the timeout occurred
+ */
+static void titan_ge_tx_timeout_task(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	int port = titan_ge_eth->port_num;
+
+	printk("Titan GE: Transmit timed out. Resetting ... \n");
+
+	/* Dump debug info */
+	printk(KERN_ERR "TRTG cause : %x \n",
+			TITAN_GE_READ(0x100c + (port << 12)));
+
+	/* Fix this for the other ports */
+	printk(KERN_ERR "FIFO cause : %x \n", TITAN_GE_READ(0x482c));
+	printk(KERN_ERR "IE cause : %x \n", TITAN_GE_READ(0x0040));
+	printk(KERN_ERR "XDMA GDI ERROR : %x \n",
+			TITAN_GE_READ(0x5008 + (port << 8)));
+	printk(KERN_ERR "CHANNEL ERROR: %x \n",
+			TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT
+						+ (port << 8)));
+
+	netif_device_detach(netdev);
+	titan_ge_port_reset(titan_ge_eth->port_num);
+	titan_ge_port_start(netdev, titan_ge_eth);
+	netif_device_attach(netdev);
+}
+
+/*
+ * Change the MTU of the Ethernet Device
+ */
+static int titan_ge_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned long flags;
+
+	if ((new_mtu > 9500) || (new_mtu < 64))
+		return -EINVAL;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	netdev->mtu = new_mtu;
+
+	/* Now we have to reopen the interface so that SKBs with the new
+	 * size will be allocated */
+
+	if (netif_running(netdev)) {
+		titan_ge_eth_stop(netdev);
+
+		if (titan_ge_eth_open(netdev) != TITAN_OK) {
+			printk(KERN_ERR
+			       "%s: Fatal error on opening device\n",
+			       netdev->name);
+			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+			return -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+	return 0;
+}
+
+/*
+ * Titan Gbe Interrupt Handler. All the three ports send interrupt to one line
+ * only. Once an interrupt is triggered, figure out the port and then check
+ * the channel.
+ */
+static irqreturn_t titan_ge_int_handler(int irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	struct net_device *netdev = (struct net_device *) dev_id;
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int reg_data;
+	unsigned int eth_int_cause_error = 0, is;
+	unsigned long eth_int_cause1;
+	int err = 0;
+#ifdef CONFIG_SMP
+	unsigned long eth_int_cause2;
+#endif
+
+	/* Ack the CPU interrupt */
+	switch (port_num) {
+	case 0:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS1);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR1, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS1);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR1, is);
+#endif
+		break;
+
+	case 1:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS0);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR0, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS0);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR0, is);
+#endif
+		break;
+
+	case 2:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR4, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR4, is);
+#endif
+	}
+
+	eth_int_cause1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+#ifdef CONFIG_SMP
+	eth_int_cause2 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_B);
+#endif
+
+	/* Spurious interrupt */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 == 0) && (eth_int_cause2 == 0)) {
+#else
+	if (eth_int_cause1 == 0) {
+#endif
+		eth_int_cause_error = TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT +
+					(port_num << 8));
+
+		if (eth_int_cause_error == 0)
+			return IRQ_NONE;
+	}
+
+	/* Handle Tx first. No need to ack interrupts */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x20202) ||
+		(eth_int_cause2 & 0x20202) )
+#else
+	if (eth_int_cause1 & 0x20202)
+#endif
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+	/* Handle the Rx next */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x10101) ||
+		(eth_int_cause2 & 0x10101)) {
+#else
+	if (eth_int_cause1 & 0x10101) {
+#endif
+		if (netif_rx_schedule_prep(netdev)) {
+			unsigned int ack;
+
+			ack = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+			/* Disable Tx and Rx both */
+			if (port_num == 0)
+				ack &= ~(0x3);
+			if (port_num == 1)
+				ack &= ~(0x300);
+
+			if (port_num == 2)
+				ack &= ~(0x30000);
+
+			/* Interrupts have been disabled */
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, ack);
+
+			__netif_rx_schedule(netdev);
+		}
+	}
+
+	/* Handle error interrupts */
+	if (eth_int_cause_error && (eth_int_cause_error != 0x2)) {
+		printk(KERN_ERR
+			"XDMA Channel Error : %x  on port %d\n",
+			eth_int_cause_error, port_num);
+
+		printk(KERN_ERR
+			"XDMA GDI Hardware error : %x  on port %d\n",
+			TITAN_GE_READ(0x5008 + (port_num << 8)), port_num);
+
+		printk(KERN_ERR
+			"XDMA currently has %d Rx descriptors \n",
+			TITAN_GE_READ(0x5048 + (port_num << 8)));
+
+		printk(KERN_ERR
+			"XDMA currently has prefetcted %d Rx descriptors \n",
+			TITAN_GE_READ(0x505c + (port_num << 8)));
+
+		TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
+			       (port_num << 8)), eth_int_cause_error);
+	}
+
+	/*
+	 * PHY interrupt to inform abt the changes. Reading the
+	 * PHY Status register will clear the interrupt
+	 */
+	if ((!(eth_int_cause1 & 0x30303)) &&
+		(eth_int_cause_error == 0)) {
+		err =
+		    titan_ge_mdio_read(port_num,
+			       TITAN_GE_MDIO_PHY_IS, &reg_data);
+
+		if (reg_data & 0x0400) {
+			/* Link status change */
+			titan_ge_mdio_read(port_num,
+				   TITAN_GE_MDIO_PHY_STATUS, &reg_data);
+			if (!(reg_data & 0x0400)) {
+				/* Link is down */
+				netif_carrier_off(netdev);
+				netif_stop_queue(netdev);
+			} else {
+				/* Link is up */
+				netif_carrier_on(netdev);
+				netif_wake_queue(netdev);
+
+				/* Enable the queue */
+				titan_ge_enable_tx(port_num);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Multicast and Promiscuous mode set. The
+ * set_multi entry point is called whenever the
+ * multicast address list or the network interface
+ * flags are updated.
+ */
+static void titan_ge_set_multi(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
+				(port_num << 12));
+
+	if (netdev->flags & IFF_PROMISC) {
+		reg_data |= 0x2;
+	}
+	else if (netdev->flags & IFF_ALLMULTI) {
+		reg_data |= 0x01;
+		reg_data |= 0x400; /* Use the 64-bit Multicast Hash bin */
+	}
+	else {
+		reg_data = 0x2;
+	}
+
+	TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
+			(port_num << 12)), reg_data);
+	if (reg_data & 0x01) {
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_LOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDLOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDHI +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_HI +
+				(port_num << 12)), 0xffff);
+	}
+}
+
+/*
+ * Open the network device
+ */
+static int titan_ge_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int irq = TITAN_ETH_PORT_IRQ - port_num;
+	int retval;
+
+	retval = request_irq(irq, titan_ge_int_handler,
+		     SA_INTERRUPT | SA_SAMPLE_RANDOM , netdev->name, netdev);
+
+	if (retval != 0) {
+		printk(KERN_ERR "Cannot assign IRQ number to TITAN GE \n");
+		return -1;
+	}
+
+	netdev->irq = irq;
+	printk(KERN_INFO "Assigned IRQ %d to port %d\n", irq, port_num);
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+
+	if (titan_ge_eth_open(netdev) != TITAN_OK) {
+		spin_unlock_irq(&(titan_ge_eth->lock));
+		printk("%s: Error opening interface \n", netdev->name);
+		free_irq(netdev->irq, netdev);
+		return -EBUSY;
+	}
+
+	spin_unlock_irq(&(titan_ge_eth->lock));
+
+	return 0;
+}
+
+/*
+ * Allocate the SKBs for the Rx ring. Also used
+ * for refilling the queue
+ */
+static int titan_ge_rx_task(struct net_device *netdev,
+				titan_ge_port_info *titan_ge_port)
+{
+	struct device *device = &titan_ge_device[titan_ge_port->port_num]->dev;
+	volatile titan_ge_rx_desc *rx_desc;
+	struct sk_buff *skb;
+	int rx_used_desc;
+	int count = 0;
+
+	while (titan_ge_port->rx_ring_skbs < titan_ge_port->rx_ring_size) {
+
+	/* First try to get the skb from the recycler */
+#ifdef TITAN_GE_JUMBO_FRAMES
+		skb = titan_ge_alloc_skb(TITAN_GE_JUMBO_BUFSIZE, GFP_ATOMIC);
+#else
+		skb = titan_ge_alloc_skb(TITAN_GE_STD_BUFSIZE, GFP_ATOMIC);
+#endif
+		if (unlikely(!skb)) {
+			/* OOM, set the flag */
+			printk("OOM \n");
+			oom_flag = 1;
+			break;
+		}
+		count++;
+		skb->dev = netdev;
+
+		titan_ge_port->rx_ring_skbs++;
+
+		rx_used_desc = titan_ge_port->rx_used_desc_q;
+		rx_desc = &(titan_ge_port->rx_desc_area[rx_used_desc]);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+		rx_desc->buffer_addr = dma_map_single(device, skb->data,
+				TITAN_GE_JUMBO_BUFSIZE - 2, DMA_FROM_DEVICE);
+#else
+		rx_desc->buffer_addr = dma_map_single(device, skb->data,
+				TITAN_GE_STD_BUFSIZE - 2, DMA_FROM_DEVICE);
+#endif
+
+		titan_ge_port->rx_skb[rx_used_desc] = skb;
+		rx_desc->cmd_sts = TITAN_GE_RX_BUFFER_OWNED;
+
+		titan_ge_port->rx_used_desc_q =
+			(rx_used_desc + 1) % TITAN_GE_RX_QUEUE;
+	}
+
+	return count;
+}
+
+/*
+ * Actual init of the Tital GE port. There is one register for
+ * the channel configuration
+ */
+static void titan_port_init(struct net_device *netdev,
+			    titan_ge_port_info * titan_ge_eth)
+{
+	unsigned long reg_data;
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	/* First reset the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x80000000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0xc0000000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	/* Now reset the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x00080000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0x000c0000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+}
+
+/*
+ * Start the port. All the hardware specific configuration
+ * for the XDMA, Tx FIFO, Rx FIFO, TMAC, RMAC, TRTG and AFX
+ * go here
+ */
+static int titan_ge_port_start(struct net_device *netdev,
+				titan_ge_port_info * titan_port)
+{
+	volatile unsigned long reg_data, reg_data1;
+	int port_num = titan_port->port_num;
+	int count = 0;
+	unsigned long reg_data_1;
+
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(0x0004);
+		reg_data |= 0x100;
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		reg_data &= ~(0x100);
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		/* Turn on GMII/MII mode and turn off TBI mode */
+		reg_data = TITAN_GE_READ(TITAN_GE_TSB_CTRL_1);
+		reg_data |= 0x00000700;
+		reg_data &= ~(0x00800000); /* Fencing */
+
+		TITAN_GE_WRITE(0x000c, 0x00001100);
+
+		TITAN_GE_WRITE(TITAN_GE_TSB_CTRL_1, reg_data);
+
+		/* Set the CPU Resource Limit register */
+		TITAN_GE_WRITE(0x00f8, 0x8);
+
+		/* Be conservative when using the BIU buffers */
+		TITAN_GE_WRITE(0x0068, 0x4);
+	}
+
+	titan_port->tx_threshold = 0;
+	titan_port->rx_threshold = 0;
+
+	/* We need to write the descriptors for Tx and Rx */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_TX_DESC + (port_num << 8)),
+		       (unsigned long) titan_port->tx_dma);
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_RX_DESC + (port_num << 8)),
+		       (unsigned long) titan_port->rx_dma);
+
+	if (config_done == 0) {
+		/* Step 1:  XDMA config	*/
+		reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
+		reg_data &= ~(0x80000000);      /* clear reset */
+		reg_data |= 0x1 << 29;	/* sparse tx descriptor spacing */
+		reg_data |= 0x1 << 28;	/* sparse rx descriptor spacing */
+		reg_data |= (0x1 << 23) | (0x1 << 24);  /* Descriptor Coherency */
+		reg_data |= (0x1 << 21) | (0x1 << 22);  /* Data Coherency */
+		TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
+	}
+
+	/* IR register for the XDMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8));
+	reg_data |= 0x80068000; /* No Rx_OOD */
+	TITAN_GE_WRITE((TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8)), reg_data);
+
+	/* Start the Tx and Rx XDMA controller */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + (port_num << 8));
+	reg_data &= 0x4fffffff;     /* Clear tx reset */
+	reg_data &= 0xfff4ffff;     /* Clear rx reset */
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	reg_data |= 0xa0 | 0x30030000;
+#else
+	reg_data |= 0x40 | 0x20030000;
+#endif
+
+#ifndef CONFIG_SMP
+	reg_data &= ~(0x10);
+	reg_data |= 0x0f; /* All of the packet */
+#endif
+
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG + (port_num << 8)), reg_data);
+
+	/* Rx desc count */
+	count = titan_ge_rx_task(netdev, titan_port);
+	TITAN_GE_WRITE((0x5048 + (port_num << 8)), count);
+	count = TITAN_GE_READ(0x5048 + (port_num << 8));
+
+	udelay(30);
+
+	/*
+	 * Step 2:  Configure the SDQPF, i.e. FIFO
+	 */
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+	}
+	/*
+	 * Enable RX FIFO 0, 4 and 8
+	 */
+	if (port_num == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4844);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4844, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_0);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4944);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4944, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+	}
+
+	if (port_num == 1) {
+		reg_data = TITAN_GE_READ(0x4870);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (0xff + 1);
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4874);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4874, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+
+		reg_data = TITAN_GE_READ(0x494c);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+		reg_data |= (0xff << 10) | (0xff + 1);
+		TITAN_GE_WRITE(0x494c, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4950);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4950, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+	}
+
+	/*
+	 * Titan 1.2 revision does support port #2
+	 */
+	if (port_num == 2) {
+		/*
+		 * Put the descriptors in the SRAM
+		 */
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	if (port_num == 2) {
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	/*
+	 * Step 3:  TRTG block enable
+	 */
+	reg_data = TITAN_GE_READ(TITAN_GE_TRTG_CONFIG + (port_num << 12));
+
+	/*
+	 * This is the 1.2 revision of the chip. It has fix for the
+	 * IP header alignment. Now, the IP header begins at an
+	 * aligned address and this wont need an extra copy in the
+	 * driver. This performance drawback existed in the previous
+	 * versions of the silicon
+	 */
+	reg_data_1 = TITAN_GE_READ(0x103c + (port_num << 12));
+	reg_data_1 |= 0x40000000;
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	reg_data_1 |= 0x04000000;
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	mdelay(5);
+
+	reg_data_1 &= ~(0x04000000);
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	mdelay(5);
+
+	reg_data |= 0x0001;
+	TITAN_GE_WRITE((TITAN_GE_TRTG_CONFIG + (port_num << 12)), reg_data);
+
+	/*
+	 * Step 4:  Start the Tx activity
+	 */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_2 + (port_num << 12)), 0xe197);
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1258 + (port_num << 12)), 0x4000);
+#endif
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* Enable TMAC */
+	reg_data |= 0x6c70;	/* PAUSE also set */
+
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/* Destination Address drop bit */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_2 + (port_num << 12));
+	reg_data |= 0x218;        /* DA_DROP bit and pause */
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_2 + (port_num << 12)), reg_data);
+
+	TITAN_GE_WRITE((0x1218 + (port_num << 12)), 0x3);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1208 + (port_num << 12)), 0x4000);
+#endif
+	/* Start the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* RMAC Enable */
+	reg_data |= 0x0010;	/* CRC Check enable */
+	reg_data |= 0x0040;	/* Min Frame check enable */
+	reg_data |= 0x4400;	/* Max Frame check enable */
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/*
+	 * Enable the Interrupts for Tx and Rx
+	 */
+	reg_data1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0) {
+		reg_data1 |= 0x3;
+#ifdef CONFIG_SMP
+		TITAN_GE_WRITE(0x0038, 0x003);
+#else
+		TITAN_GE_WRITE(0x0038, 0x303);
+#endif
+	}
+
+	if (port_num == 1) {
+		reg_data1 |= 0x300;
+	}
+
+	if (port_num == 2)
+		reg_data1 |= 0x30000;
+
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data1);
+	TITAN_GE_WRITE(0x003c, 0x300);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x0024, 0x04000024);	/* IRQ vector */
+		TITAN_GE_WRITE(0x0020, 0x000fb000);	/* INTMSG base */
+	}
+
+	/* Priority */
+	reg_data = TITAN_GE_READ(0x1038 + (port_num << 12));
+	reg_data &= ~(0x00f00000);
+	TITAN_GE_WRITE((0x1038 + (port_num << 12)), reg_data);
+
+	/* Step 5:  GMII config */
+	titan_ge_gmii_config(port_num);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x1a80, 0);
+		config_done = 1;
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Function to queue the packet for the Ethernet device
+ */
+static void titan_ge_tx_queue(titan_ge_port_info * titan_ge_eth,
+				struct sk_buff * skb)
+{
+	struct device *device = &titan_ge_device[titan_ge_eth->port_num]->dev;
+	unsigned int curr_desc = titan_ge_eth->tx_curr_desc_q;
+	volatile titan_ge_tx_desc *tx_curr;
+	int port_num = titan_ge_eth->port_num;
+
+	tx_curr = &(titan_ge_eth->tx_desc_area[curr_desc]);
+	tx_curr->buffer_addr =
+		dma_map_single(device, skb->data, skb_headlen(skb),
+			       DMA_TO_DEVICE);
+
+	titan_ge_eth->tx_skb[curr_desc] = (struct sk_buff *) skb;
+	tx_curr->buffer_len = skb_headlen(skb);
+
+	/* Last descriptor enables interrupt and changes ownership */
+	tx_curr->cmd_sts = 0x1 | (1 << 15) | (1 << 5);
+
+	/* Kick the XDMA to start the transfer from memory to the FIFO */
+	TITAN_GE_WRITE((0x5044 + (port_num << 8)), 0x1);
+
+	/* Current descriptor updated */
+	titan_ge_eth->tx_curr_desc_q = (curr_desc + 1) % TITAN_GE_TX_QUEUE;
+
+	/* Prefetch the next descriptor */
+	prefetch((const void *)
+		 &titan_ge_eth->tx_desc_area[titan_ge_eth->tx_curr_desc_q]);
+}
+
+/*
+ * Actually does the open of the Ethernet device
+ */
+static int titan_ge_eth_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	struct device *device = &titan_ge_device[port_num]->dev;
+	unsigned long reg_data;
+	unsigned int phy_reg;
+	int err = 0;
+
+	/* Stop the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	/* Clear the port interrupts */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT + (port_num << 8)), 0x0);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0);
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_B, 0);
+	}
+
+	/* Set the MAC Address */
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+
+	if (config_done == 0)
+		titan_port_init(netdev, titan_ge_eth);
+
+	titan_ge_update_afx(titan_ge_eth);
+
+	/* Allocate the Tx ring now */
+	titan_ge_eth->tx_ring_skbs = 0;
+	titan_ge_eth->tx_ring_size = TITAN_GE_TX_QUEUE;
+
+	/* Allocate space in the SRAM for the descriptors */
+	titan_ge_eth->tx_desc_area = (titan_ge_tx_desc *)
+		(titan_ge_sram + TITAN_TX_RING_BYTES * port_num);
+	titan_ge_eth->tx_dma = TITAN_SRAM_BASE + TITAN_TX_RING_BYTES * port_num;
+
+	if (!titan_ge_eth->tx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Tx Ring (size %d bytes) for port %d\n",
+		       netdev->name, TITAN_TX_RING_BYTES, port_num);
+		return -ENOMEM;
+	}
+
+	memset(titan_ge_eth->tx_desc_area, 0, titan_ge_eth->tx_desc_area_size);
+
+	/* Now initialize the Tx descriptor ring */
+	titan_ge_init_tx_desc_ring(titan_ge_eth,
+				   titan_ge_eth->tx_ring_size,
+				   (unsigned long) titan_ge_eth->tx_desc_area,
+				   (unsigned long) titan_ge_eth->tx_dma);
+
+	/* Allocate the Rx ring now */
+	titan_ge_eth->rx_ring_size = TITAN_GE_RX_QUEUE;
+	titan_ge_eth->rx_ring_skbs = 0;
+
+	titan_ge_eth->rx_desc_area =
+		(titan_ge_rx_desc *)(titan_ge_sram + 0x1000 + TITAN_RX_RING_BYTES * port_num);
+
+	titan_ge_eth->rx_dma = TITAN_SRAM_BASE + 0x1000 + TITAN_RX_RING_BYTES * port_num;
+
+	if (!titan_ge_eth->rx_desc_area) {
+		printk(KERN_ERR "%s: Cannot allocate Rx Ring (size %d bytes)\n",
+		       netdev->name, TITAN_RX_RING_BYTES);
+
+		printk(KERN_ERR "%s: Freeing previously allocated TX queues...",
+		       netdev->name);
+
+		dma_free_coherent(device, titan_ge_eth->tx_desc_area_size,
+				    (void *) titan_ge_eth->tx_desc_area,
+				    titan_ge_eth->tx_dma);
+
+		return -ENOMEM;
+	}
+
+	memset(titan_ge_eth->rx_desc_area, 0, titan_ge_eth->rx_desc_area_size);
+
+	/* Now initialize the Rx ring */
+#ifdef TITAN_GE_JUMBO_FRAMES
+	if ((titan_ge_init_rx_desc_ring
+	    (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_JUMBO_BUFSIZE,
+	     (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#else
+	if ((titan_ge_init_rx_desc_ring
+	     (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_STD_BUFSIZE,
+	      (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#endif
+		panic("%s: Error initializing RX Ring\n", netdev->name);
+
+	/* Fill the Rx ring with the SKBs */
+	titan_ge_port_start(netdev, titan_ge_eth);
+
+	/*
+	 * Check if Interrupt Coalscing needs to be turned on. The
+	 * values specified in the register is multiplied by
+	 * (8 x 64 nanoseconds) to determine when an interrupt should
+	 * be sent to the CPU.
+	 */
+
+	if (TITAN_GE_TX_COAL) {
+		titan_ge_eth->tx_int_coal =
+		    titan_ge_tx_coal(TITAN_GE_TX_COAL, port_num);
+	}
+
+	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		return TITAN_ERROR;
+	}
+	if (!(phy_reg & 0x0400)) {
+		netif_carrier_off(netdev);
+		netif_stop_queue(netdev);
+		return TITAN_ERROR;
+	} else {
+		netif_carrier_on(netdev);
+		netif_start_queue(netdev);
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Queue the packet for Tx. Currently no support for zero copy,
+ * checksum offload and Scatter Gather. The chip does support
+ * Scatter Gather only. But, that wont help here since zero copy
+ * requires support for Tx checksumming also.
+ */
+int titan_ge_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned long flags;
+	struct net_device_stats *stats;
+//printk("titan_ge_start_xmit\n");
+
+	stats = &titan_ge_eth->stats;
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	if ((TITAN_GE_TX_QUEUE - titan_ge_eth->tx_ring_skbs) <=
+	    (skb_shinfo(skb)->nr_frags + 1)) {
+		netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		printk(KERN_ERR "Tx OOD \n");
+		return 1;
+	}
+
+	titan_ge_tx_queue(titan_ge_eth, skb);
+	titan_ge_eth->tx_ring_skbs++;
+
+	if (TITAN_GE_TX_QUEUE <= (titan_ge_eth->tx_ring_skbs + 4)) {
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		titan_ge_free_tx_queue(titan_ge_eth);
+		spin_lock_irqsave(&titan_ge_eth->lock, flags);
+	}
+
+	stats->tx_bytes += skb->len;
+	stats->tx_packets++;
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	netdev->trans_start = jiffies;
+
+	return 0;
+}
+
+/*
+ * Actually does the Rx. Rx side checksumming supported.
+ */
+static int titan_ge_rx(struct net_device *netdev, int port_num,
+			titan_ge_port_info * titan_ge_port,
+		       titan_ge_packet * packet)
+{
+	int rx_curr_desc, rx_used_desc;
+	volatile titan_ge_rx_desc *rx_desc;
+
+	rx_curr_desc = titan_ge_port->rx_curr_desc_q;
+	rx_used_desc = titan_ge_port->rx_used_desc_q;
+
+	if (((rx_curr_desc + 1) % TITAN_GE_RX_QUEUE) == rx_used_desc)
+		return TITAN_ERROR;
+
+	rx_desc = &(titan_ge_port->rx_desc_area[rx_curr_desc]);
+
+	if (rx_desc->cmd_sts & TITAN_GE_RX_BUFFER_OWNED)
+		return TITAN_ERROR;
+
+	packet->skb = titan_ge_port->rx_skb[rx_curr_desc];
+	packet->len = (rx_desc->cmd_sts & 0x7fff);
+
+	/*
+	 * At this point, we dont know if the checksumming
+	 * actually helps relieve CPU. So, keep it for
+	 * port 0 only
+	 */
+	packet->checksum = ntohs((rx_desc->buffer & 0xffff0000) >> 16);
+	packet->cmd_sts = rx_desc->cmd_sts;
+
+	titan_ge_port->rx_curr_desc_q = (rx_curr_desc + 1) % TITAN_GE_RX_QUEUE;
+
+	/* Prefetch the next descriptor */
+	prefetch((const void *)
+	       &titan_ge_port->rx_desc_area[titan_ge_port->rx_curr_desc_q + 1]);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx queue of the used SKBs
+ */
+static int titan_ge_free_tx_queue(titan_ge_port_info *titan_ge_eth)
+{
+	unsigned long flags;
+
+	/* Take the lock */
+	spin_lock_irqsave(&(titan_ge_eth->lock), flags);
+
+	while (titan_ge_return_tx_desc(titan_ge_eth, titan_ge_eth->port_num) == 0)
+		if (titan_ge_eth->tx_ring_skbs != 1)
+			titan_ge_eth->tx_ring_skbs--;
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	return TITAN_OK;
+}
+
+/*
+ * Threshold beyond which we do the cleaning of
+ * Tx queue and new allocation for the Rx
+ * queue
+ */
+#define	TX_THRESHOLD	4
+#define	RX_THRESHOLD	10
+
+/*
+ * Receive the packets and send it to the kernel.
+ */
+static int titan_ge_receive_queue(struct net_device *netdev, unsigned int max)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	titan_ge_packet packet;
+	struct net_device_stats *stats;
+	struct sk_buff *skb;
+	unsigned long received_packets = 0;
+	unsigned int ack;
+
+	stats = &titan_ge_eth->stats;
+
+	while ((--max)
+	       && (titan_ge_rx(netdev, port_num, titan_ge_eth, &packet) == TITAN_OK)) {
+		skb = (struct sk_buff *) packet.skb;
+
+		titan_ge_eth->rx_ring_skbs--;
+
+		if (--titan_ge_eth->rx_work_limit < 0)
+			break;
+		received_packets++;
+
+		stats->rx_packets++;
+		stats->rx_bytes += packet.len;
+
+		if ((packet.cmd_sts & TITAN_GE_RX_PERR) ||
+			(packet.cmd_sts & TITAN_GE_RX_OVERFLOW_ERROR) ||
+			(packet.cmd_sts & TITAN_GE_RX_TRUNC) ||
+			(packet.cmd_sts & TITAN_GE_RX_CRC_ERROR)) {
+				stats->rx_dropped++;
+				dev_kfree_skb_any(skb);
+
+				continue;
+		}
+		/*
+		 * Either support fast path or slow path. Decision
+		 * making can really slow down the performance. The
+		 * idea is to cut down the number of checks and improve
+		 * the fastpath.
+		 */
+
+		skb_put(skb, packet.len - 2);
+
+		/*
+		 * Increment data pointer by two since thats where
+		 * the MAC starts
+		 */
+		skb_reserve(skb, 2);
+		skb->protocol = eth_type_trans(skb, netdev);
+		netif_receive_skb(skb);
+
+		if (titan_ge_eth->rx_threshold > RX_THRESHOLD) {
+			ack = titan_ge_rx_task(netdev, titan_ge_eth);
+			TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
+			titan_ge_eth->rx_threshold = 0;
+		} else
+			titan_ge_eth->rx_threshold++;
+
+		if (titan_ge_eth->tx_threshold > TX_THRESHOLD) {
+			titan_ge_eth->tx_threshold = 0;
+			titan_ge_free_tx_queue(titan_ge_eth);
+		}
+		else
+			titan_ge_eth->tx_threshold++;
+
+	}
+	return received_packets;
+}
+
+
+/*
+ * Enable the Rx side interrupts
+ */
+static void titan_ge_enable_int(unsigned int port_num,
+			titan_ge_port_info *titan_ge_eth,
+			struct net_device *netdev)
+{
+	unsigned long reg_data = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0)
+		reg_data |= 0x3;
+	if (port_num == 1)
+		reg_data |= 0x300;
+	if (port_num == 2)
+		reg_data |= 0x30000;
+
+	/* Re-enable interrupts */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data);
+}
+
+/*
+ * Main function to handle the polling for Rx side NAPI.
+ * Receive interrupts have been disabled at this point.
+ * The poll schedules the transmit followed by receive.
+ */
+static int titan_ge_poll(struct net_device *netdev, int *budget)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	int port_num = titan_ge_eth->port_num;
+	int work_done = 0;
+	unsigned long flags, status;
+
+	titan_ge_eth->rx_work_limit = *budget;
+	if (titan_ge_eth->rx_work_limit > netdev->quota)
+		titan_ge_eth->rx_work_limit = netdev->quota;
+
+	do {
+		/* Do the transmit cleaning work here */
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+		/* Ack the Rx interrupts */
+		if (port_num == 0)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x3);
+		if (port_num == 1)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x300);
+		if (port_num == 2)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x30000);
+
+		work_done += titan_ge_receive_queue(netdev, 0);
+
+		/* Out of quota and there is work to be done */
+		if (titan_ge_eth->rx_work_limit < 0)
+			goto not_done;
+
+		/* Receive alloc_skb could lead to OOM */
+		if (oom_flag == 1) {
+			oom_flag = 0;
+			goto oom;
+		}
+
+		status = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+	} while (status & 0x30300);
+
+	/* If we are here, then no more interrupts to process */
+	goto done;
+
+not_done:
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	return 1;
+
+oom:
+	printk(KERN_ERR "OOM \n");
+	netif_rx_complete(netdev);
+	return 0;
+
+done:
+	/*
+	 * No more packets on the poll list. Turn the interrupts
+	 * back on and we should be able to catch the new
+	 * packets in the interrupt handler
+	 */
+	if (!work_done)
+		work_done = 1;
+
+	*budget -= work_done;
+	netdev->quota -= work_done;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	/* Remove us from the poll list */
+	netif_rx_complete(netdev);
+
+	/* Re-enable interrupts */
+	titan_ge_enable_int(port_num, titan_ge_eth, netdev);
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	return 0;
+}
+
+/*
+ * Close the network device
+ */
+int titan_ge_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+	titan_ge_eth_stop(netdev);
+	free_irq(netdev->irq, netdev);
+	spin_unlock_irq(&titan_ge_eth->lock);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx ring
+ */
+static void titan_ge_free_tx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int curr;
+	unsigned long reg_data;
+
+	/* Stop the Tx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0xc0000000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     (titan_ge_eth->tx_ring_skbs) && (curr < TITAN_GE_TX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->tx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->tx_skb[curr]);
+			titan_ge_eth->tx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->tx_ring_skbs != 0)
+		printk
+		    ("%s: Error on Tx descriptor free - could not free %d"
+		     " descriptors\n", netdev->name,
+		     titan_ge_eth->tx_ring_skbs);
+
+#ifndef TITAN_RX_RING_IN_SRAM
+	dma_free_coherent(&titan_ge_device[port_num]->dev,
+			  titan_ge_eth->tx_desc_area_size,
+			  (void *) titan_ge_eth->tx_desc_area,
+			  titan_ge_eth->tx_dma);
+#endif
+}
+
+/*
+ * Free the Rx ring
+ */
+static void titan_ge_free_rx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int curr;
+	unsigned long reg_data;
+
+	/* Stop the Rx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0x000c0000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     titan_ge_eth->rx_ring_skbs && (curr < TITAN_GE_RX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->rx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->rx_skb[curr]);
+			titan_ge_eth->rx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->rx_ring_skbs != 0)
+		printk(KERN_ERR
+		       "%s: Error in freeing Rx Ring. %d skb's still"
+		       " stuck in RX Ring - ignoring them\n", netdev->name,
+		       titan_ge_eth->rx_ring_skbs);
+
+#ifndef TITAN_RX_RING_IN_SRAM
+	dma_free_coherent(&titan_ge_device[port_num]->dev,
+			  titan_ge_eth->rx_desc_area_size,
+			  (void *) titan_ge_eth->rx_desc_area,
+			  titan_ge_eth->rx_dma);
+#endif
+}
+
+/*
+ * Actually does the stop of the Ethernet device
+ */
+static void titan_ge_eth_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	netif_stop_queue(netdev);
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	titan_ge_free_tx_rings(netdev);
+	titan_ge_free_rx_rings(netdev);
+
+	/* Disable the Tx and Rx Interrupts for all channels */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, 0x0);
+}
+
+/*
+ * Update the MAC address. Note that we have to write the
+ * address in three station registers, 16 bits each. And this
+ * has to be done for TMAC and RMAC
+ */
+static void titan_ge_update_mac_address(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	u8 p_addr[6];
+
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+	memcpy(p_addr, netdev->dev_addr, 6);
+
+	/* Update the Address Filtering Match tables */
+	titan_ge_update_afx(titan_ge_eth);
+
+	printk("Station MAC : %d %d %d %d %d %d  \n",
+		p_addr[5], p_addr[4], p_addr[3],
+		p_addr[2], p_addr[1], p_addr[0]);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+}
+
+/*
+ * Set the MAC address of the Ethernet device
+ */
+static int titan_ge_set_mac_address(struct net_device *dev, void *addr)
+{
+	titan_ge_port_info *tp = netdev_priv(dev);
+	struct sockaddr *sa = addr;
+
+	memcpy(dev->dev_addr, sa->sa_data, dev->addr_len);
+
+	spin_lock_irq(&tp->lock);
+	titan_ge_update_mac_address(dev);
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/*
+ * Get the Ethernet device stats
+ */
+static struct net_device_stats *titan_ge_get_stats(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	return &titan_ge_eth->stats;
+}
+
+/*
+ * Initialize the Rx descriptor ring for the Titan Ge
+ */
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info * titan_eth_port,
+				      int rx_desc_num,
+				      int rx_buff_size,
+				      unsigned long rx_desc_base_addr,
+				      unsigned long rx_buff_base_addr,
+				      unsigned long rx_dma)
+{
+	volatile titan_ge_rx_desc *rx_desc;
+	unsigned long buffer_addr;
+	int index;
+	unsigned long titan_ge_rx_desc_bus = rx_dma;
+
+	buffer_addr = rx_buff_base_addr;
+	rx_desc = (titan_ge_rx_desc *) rx_desc_base_addr;
+
+	/* Check alignment */
+	if (rx_buff_base_addr & 0xF)
+		return 0;
+
+	/* Check Rx buffer size */
+	if ((rx_buff_size < 8) || (rx_buff_size > TITAN_GE_MAX_RX_BUFFER))
+		return 0;
+
+	/* 64-bit alignment
+	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
+		return 0; */
+
+	/* Initialize the Rx desc ring */
+	for (index = 0; index < rx_desc_num; index++) {
+		titan_ge_rx_desc_bus += sizeof(titan_ge_rx_desc);
+		rx_desc[index].cmd_sts = 0;
+		rx_desc[index].buffer_addr = buffer_addr;
+		titan_eth_port->rx_skb[index] = NULL;
+		buffer_addr += rx_buff_size;
+	}
+
+	titan_eth_port->rx_curr_desc_q = 0;
+	titan_eth_port->rx_used_desc_q = 0;
+
+	titan_eth_port->rx_desc_area = (titan_ge_rx_desc *) rx_desc_base_addr;
+	titan_eth_port->rx_desc_area_size =
+	    rx_desc_num * sizeof(titan_ge_rx_desc);
+
+	titan_eth_port->rx_dma = rx_dma;
+
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the Tx descriptor ring. Descriptors in the SRAM
+ */
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info * titan_ge_port,
+				      int tx_desc_num,
+				      unsigned long tx_desc_base_addr,
+				      unsigned long tx_dma)
+{
+	titan_ge_tx_desc *tx_desc;
+	int index;
+	unsigned long titan_ge_tx_desc_bus = tx_dma;
+
+	if (tx_desc_base_addr & 0xF)
+		return 0;
+
+	tx_desc = (titan_ge_tx_desc *) tx_desc_base_addr;
+
+	for (index = 0; index < tx_desc_num; index++) {
+		titan_ge_port->tx_dma_array[index] =
+		    (dma_addr_t) titan_ge_tx_desc_bus;
+		titan_ge_tx_desc_bus += sizeof(titan_ge_tx_desc);
+		tx_desc[index].cmd_sts = 0x0000;
+		tx_desc[index].buffer_len = 0;
+		tx_desc[index].buffer_addr = 0x00000000;
+		titan_ge_port->tx_skb[index] = NULL;
+	}
+
+	titan_ge_port->tx_curr_desc_q = 0;
+	titan_ge_port->tx_used_desc_q = 0;
+
+	titan_ge_port->tx_desc_area = (titan_ge_tx_desc *) tx_desc_base_addr;
+	titan_ge_port->tx_desc_area_size =
+	    tx_desc_num * sizeof(titan_ge_tx_desc);
+
+	titan_ge_port->tx_dma = tx_dma;
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the device as an Ethernet device
+ */
+static int __init titan_ge_probe(struct device *device)
+{
+	titan_ge_port_info *titan_ge_eth;
+	struct net_device *netdev;
+	int port = to_platform_device(device)->id;
+	int err;
+
+	netdev = alloc_etherdev(sizeof(titan_ge_port_info));
+	if (!netdev) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	netdev->open = titan_ge_open;
+	netdev->stop = titan_ge_stop;
+	netdev->hard_start_xmit = titan_ge_start_xmit;
+	netdev->get_stats = titan_ge_get_stats;
+	netdev->set_multicast_list = titan_ge_set_multi;
+	netdev->set_mac_address = titan_ge_set_mac_address;
+
+	/* Tx timeout */
+	netdev->tx_timeout = titan_ge_tx_timeout;
+	netdev->watchdog_timeo = 2 * HZ;
+
+	/* Set these to very high values */
+	netdev->poll = titan_ge_poll;
+	netdev->weight = 64;
+
+	netdev->tx_queue_len = TITAN_GE_TX_QUEUE;
+	netif_carrier_off(netdev);
+	netdev->base_addr = 0;
+
+	netdev->change_mtu = titan_ge_change_mtu;
+
+	titan_ge_eth = netdev_priv(netdev);
+	/* Allocation of memory for the driver structures */
+
+	titan_ge_eth->port_num = port;
+
+	/* Configure the Tx timeout handler */
+	INIT_WORK(&titan_ge_eth->tx_timeout_task,
+		  (void (*)(void *)) titan_ge_tx_timeout_task, netdev);
+
+	spin_lock_init(&titan_ge_eth->lock);
+
+	/* set MAC addresses */
+	memcpy(netdev->dev_addr, titan_ge_mac_addr_base, 6);
+	netdev->dev_addr[5] += port;
+
+	err = register_netdev(netdev);
+
+	if (err)
+		goto out_free_netdev;
+
+	printk(KERN_NOTICE
+	       "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       netdev->name, port, netdev->dev_addr[0],
+	       netdev->dev_addr[1], netdev->dev_addr[2],
+	       netdev->dev_addr[3], netdev->dev_addr[4],
+	       netdev->dev_addr[5]);
+
+	printk(KERN_NOTICE "Rx NAPI supported, Tx Coalescing ON \n");
+
+	return 0;
+
+out_free_netdev:
+	kfree(netdev);
+
+out:
+	return err;
+}
+
+static void __devexit titan_device_remove(struct device *device)
+{
+}
+
+/*
+ * Reset the Ethernet port
+ */
+static void titan_ge_port_reset(unsigned int port_num)
+{
+	unsigned int reg_data;
+
+	/* Stop the Tx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	/* Stop the Rx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	return;
+}
+
+/*
+ * Return the Tx desc after use by the XDMA
+ */
+static int titan_ge_return_tx_desc(titan_ge_port_info * titan_ge_eth, int port)
+{
+	int tx_desc_used;
+	struct sk_buff *skb;
+
+	tx_desc_used = titan_ge_eth->tx_used_desc_q;
+
+	/* return right away */
+	if (tx_desc_used == titan_ge_eth->tx_curr_desc_q)
+		return TITAN_ERROR;
+
+	/* Now the critical stuff */
+	skb = titan_ge_eth->tx_skb[tx_desc_used];
+
+	dev_kfree_skb_any(skb);
+
+	titan_ge_eth->tx_skb[tx_desc_used] = NULL;
+	titan_ge_eth->tx_used_desc_q =
+	    (tx_desc_used + 1) % TITAN_GE_TX_QUEUE;
+
+	return 0;
+}
+
+/*
+ * Coalescing for the Tx path
+ */
+static unsigned long titan_ge_tx_coal(unsigned long delay, int port)
+{
+	unsigned long rx_delay;
+
+	rx_delay = TITAN_GE_READ(TITAN_GE_INT_COALESCING);
+	delay = (delay << 16) | rx_delay;
+
+	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
+	TITAN_GE_WRITE(0x5038, delay);
+
+	return delay;
+}
+
+static struct device_driver titan_soc_driver = {
+	.name   = titan_string,
+	.bus    = &platform_bus_type,
+	.probe  = titan_ge_probe,
+	.remove = __devexit_p(titan_device_remove),
+};
+
+static void titan_platform_release (struct device *device)
+{
+	struct platform_device *pldev;
+
+	/* free device */
+	pldev = to_platform_device (device);
+	kfree (pldev);
+}
+
+/*
+ * Register the Titan GE with the kernel
+ */
+static int __init titan_ge_init_module(void)
+{
+	struct platform_device *pldev;
+	unsigned int version, device;
+	int i;
+
+	printk(KERN_NOTICE
+	       "PMC-Sierra TITAN 10/100/1000 Ethernet Driver \n");
+
+	titan_ge_base = (unsigned long) ioremap(TITAN_GE_BASE, TITAN_GE_SIZE);
+	if (!titan_ge_base) {
+		printk("Mapping Titan GE failed\n");
+		goto out;
+	}
+
+	device = TITAN_GE_READ(TITAN_GE_DEVICE_ID);
+	version = (device & 0x000f0000) >> 16;
+	device &= 0x0000ffff;
+
+	printk(KERN_NOTICE "Device Id : %x,  Version : %x \n", device, version);
+
+#ifdef TITAN_RX_RING_IN_SRAM
+	titan_ge_sram = (unsigned long) ioremap(TITAN_SRAM_BASE,
+						TITAN_SRAM_SIZE);
+	if (!titan_ge_sram) {
+		printk("Mapping Titan SRAM failed\n");
+		goto out_unmap_ge;
+	}
+#endif
+
+	if (driver_register(&titan_soc_driver)) {
+		printk(KERN_ERR "Driver registration failed\n");
+		goto out_unmap_sram;
+	}
+
+	for (i = 0; i < 3; i++) {
+		titan_ge_device[i] = NULL;
+
+	        if (!(pldev = kmalloc (sizeof (*pldev), GFP_KERNEL)))
+	                continue;
+
+                memset (pldev, 0, sizeof (*pldev));
+                pldev->name		= titan_string;
+                pldev->id		= i;
+                pldev->dev.release	= titan_platform_release;
+                titan_ge_device[i]	= pldev;
+
+                if (platform_device_register (pldev)) {
+                        kfree (pldev);
+                        titan_ge_device[i] = NULL;
+                        continue;
+                }
+                                                                                
+                if (!pldev->dev.driver) {
+	                /*
+			 * The driver was not bound to this device, there was
+	                 * no hardware at this address. Unregister it, as the
+	                 * release fuction will take care of freeing the
+	                 * allocated structure
+			 */
+                        titan_ge_device[i] = NULL;
+                        platform_device_unregister (pldev);
+                }
+        }
+
+	return 0;
+
+out_unmap_sram:
+	iounmap((void *)titan_ge_sram);
+
+out_unmap_ge:
+	iounmap((void *)titan_ge_base);
+
+out:
+	return -ENOMEM;
+}
+
+/*
+ * Unregister the Titan GE from the kernel
+ */
+static void __exit titan_ge_cleanup_module(void)
+{
+	int i;
+
+	driver_unregister(&titan_soc_driver);
+
+	for (i = 0; i < 3; i++) {
+		if (titan_ge_device[i]) {
+			platform_device_unregister (titan_ge_device[i]);
+			titan_ge_device[i] = NULL;
+		}
+	}
+
+	iounmap((void *)titan_ge_sram);
+	iounmap((void *)titan_ge_base);
+}
+
+MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
+MODULE_DESCRIPTION("Titan GE Ethernet driver");
+MODULE_LICENSE("GPL");
+
+module_init(titan_ge_init_module);
+module_exit(titan_ge_cleanup_module);
diff -Naur linux-2.6.14/drivers/net/titan_ge.h linux-mips-2.6.14.orig/drivers/net/titan_ge.h
--- linux-2.6.14/drivers/net/titan_ge.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/titan_ge.h	2005-11-17 11:43:12.000000000 -0800
@@ -0,0 +1,419 @@
+#ifndef _TITAN_GE_H_
+#define _TITAN_GE_H_
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+
+/*
+ * These functions should be later moved to a more generic location since there
+ * will be others accessing it also
+ */
+
+/*
+ * This is the way it works: LKB5 Base is at 0x0128. TITAN_BASE is defined in
+ * include/asm/titan_dep.h. TITAN_GE_BASE is the value in the TITAN_GE_LKB5
+ * register.
+ */
+
+#define	TITAN_GE_BASE	0xfe000000UL
+#define	TITAN_GE_SIZE	0x10000UL
+
+extern unsigned long titan_ge_base;
+
+#define	TITAN_GE_WRITE(offset, data) \
+		*(volatile u32 *)(titan_ge_base + (offset)) = (data)
+
+#define TITAN_GE_READ(offset) *(volatile u32 *)(titan_ge_base + (offset))
+
+#ifndef msec_delay
+#define msec_delay(x)   do { if(in_interrupt()) { \
+				/* Don't mdelay in interrupt context! */ \
+				BUG(); \
+			} else { \
+				set_current_state(TASK_UNINTERRUPTIBLE); \
+				schedule_timeout((x * HZ)/1000); \
+			} } while(0)
+#endif
+
+#define TITAN_GE_PORT_0
+
+#define	TITAN_SRAM_BASE		((OCD_READ(RM9000x2_OCD_LKB13) & ~1) << 4)
+#define	TITAN_SRAM_SIZE		0x2000UL
+
+extern unsigned long titan_ge_sram;
+
+/*
+ * We may need these constants
+ */
+#define TITAN_BIT0    0x00000001
+#define TITAN_BIT1    0x00000002
+#define TITAN_BIT2    0x00000004
+#define TITAN_BIT3    0x00000008
+#define TITAN_BIT4    0x00000010
+#define TITAN_BIT5    0x00000020
+#define TITAN_BIT6    0x00000040
+#define TITAN_BIT7    0x00000080
+#define TITAN_BIT8    0x00000100
+#define TITAN_BIT9    0x00000200
+#define TITAN_BIT10   0x00000400
+#define TITAN_BIT11   0x00000800
+#define TITAN_BIT12   0x00001000
+#define TITAN_BIT13   0x00002000
+#define TITAN_BIT14   0x00004000
+#define TITAN_BIT15   0x00008000
+#define TITAN_BIT16   0x00010000
+#define TITAN_BIT17   0x00020000
+#define TITAN_BIT18   0x00040000
+#define TITAN_BIT19   0x00080000
+#define TITAN_BIT20   0x00100000
+#define TITAN_BIT21   0x00200000
+#define TITAN_BIT22   0x00400000
+#define TITAN_BIT23   0x00800000
+#define TITAN_BIT24   0x01000000
+#define TITAN_BIT25   0x02000000
+#define TITAN_BIT26   0x04000000
+#define TITAN_BIT27   0x08000000
+#define TITAN_BIT28   0x10000000
+#define TITAN_BIT29   0x20000000
+#define TITAN_BIT30   0x40000000
+#define TITAN_BIT31   0x80000000
+
+/* Flow Control */
+#define	TITAN_GE_FC_NONE	0x0
+#define	TITAN_GE_FC_FULL	0x1
+#define	TITAN_GE_FC_TX_PAUSE	0x2
+#define	TITAN_GE_FC_RX_PAUSE	0x3
+
+/* Duplex Settings */
+#define	TITAN_GE_FULL_DUPLEX	0x1
+#define	TITAN_GE_HALF_DUPLEX	0x2
+
+/* Speed settings */
+#define	TITAN_GE_SPEED_1000	0x1
+#define	TITAN_GE_SPEED_100	0x2
+#define	TITAN_GE_SPEED_10	0x3
+
+/* Debugging info only */
+#undef TITAN_DEBUG
+
+/* Keep the rings in the Titan's SSRAM */
+#define TITAN_RX_RING_IN_SRAM
+
+#ifdef CONFIG_64BIT
+#define	TITAN_GE_IE_MASK	0xfffffffffb001b64
+#define	TITAN_GE_IE_STATUS	0xfffffffffb001b60
+#else
+#define	TITAN_GE_IE_MASK	0xfb001b64
+#define	TITAN_GE_IE_STATUS	0xfb001b60
+#endif
+
+/* Support for Jumbo Frames */
+#undef TITAN_GE_JUMBO_FRAMES
+
+/* Rx buffer size */
+#ifdef TITAN_GE_JUMBO_FRAMES
+#define	TITAN_GE_JUMBO_BUFSIZE	9080
+#else
+#define	TITAN_GE_STD_BUFSIZE	1580
+#endif
+
+/*
+ * Tx and Rx Interrupt Coalescing parameter. These values are
+ * for 1 Ghz processor. Rx coalescing can be taken care of
+ * by NAPI. NAPI is adaptive and hence useful. Tx coalescing
+ * is not adaptive. Hence, these values need to be adjusted
+ * based on load, CPU speed etc.
+ */
+#define	TITAN_GE_RX_COAL	150
+#define	TITAN_GE_TX_COAL	300
+
+#if defined(__BIG_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct eth_rx_desc {
+	u32     reserved;	/* Unused 		*/
+	u32     buffer_addr;	/* CPU buffer address 	*/
+	u32	cmd_sts;	/* Command and Status	*/
+	u32	buffer;		/* XDMA buffer address	*/
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct eth_tx_desc {
+	u16     cmd_sts;	/* Command, Status and Buffer count */
+	u16	buffer_len;	/* Length of the buffer	*/
+	u32     buffer_addr;	/* Physical address of the buffer */
+} titan_ge_tx_desc;
+
+#elif defined(__LITTLE_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct eth_rx_desc {
+	u32	buffer_addr;	/* CPU buffer address   */
+	u32	reserved;	/* Unused               */
+	u32	buffer;		/* XDMA buffer address  */
+	u32	cmd_sts;	/* Command and Status   */
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct eth_tx_desc {
+	u32     buffer_addr;	/* Physical address of the buffer */
+	u16     buffer_len;     /* Length of the buffer */
+	u16     cmd_sts;        /* Command, Status and Buffer count */
+} titan_ge_tx_desc;
+#endif
+
+/* Default Tx Queue Size */
+#define	TITAN_GE_TX_QUEUE	128
+#define TITAN_TX_RING_BYTES	(TITAN_GE_TX_QUEUE * sizeof(struct eth_tx_desc))
+
+/* Default Rx Queue Size */
+#define	TITAN_GE_RX_QUEUE	64
+#define TITAN_RX_RING_BYTES	(TITAN_GE_RX_QUEUE * sizeof(struct eth_rx_desc))
+
+/* Packet Structure */
+typedef struct _pkt_info {
+	unsigned int           len;
+	unsigned int            cmd_sts;
+	unsigned int            buffer;
+	struct sk_buff          *skb;
+	unsigned int		checksum;
+} titan_ge_packet;
+
+
+#define	PHYS_CNT	3
+
+/* Titan Port specific data structure */
+typedef struct _eth_port_ctrl {
+	unsigned int		port_num;
+	u8			port_mac_addr[6];
+
+	/* Rx descriptor pointers */
+	int 			rx_curr_desc_q, rx_used_desc_q;
+
+	/* Tx descriptor pointers */
+	int 			tx_curr_desc_q, tx_used_desc_q;
+
+	/* Rx descriptor area */
+	volatile titan_ge_rx_desc	*rx_desc_area;
+	unsigned int			rx_desc_area_size;
+	struct sk_buff*			rx_skb[TITAN_GE_RX_QUEUE];
+
+	/* Tx Descriptor area */
+	volatile titan_ge_tx_desc	*tx_desc_area;
+	unsigned int                    tx_desc_area_size;
+	struct sk_buff*                 tx_skb[TITAN_GE_TX_QUEUE];
+
+	/* Timeout task */
+	struct work_struct		tx_timeout_task;
+
+	/* DMA structures and handles */
+	dma_addr_t			tx_dma;
+	dma_addr_t			rx_dma;
+	dma_addr_t			tx_dma_array[TITAN_GE_TX_QUEUE];
+
+	/* Device lock */
+	spinlock_t			lock;
+
+	unsigned int			tx_ring_skbs;
+	unsigned int			rx_ring_size;
+	unsigned int			tx_ring_size;
+	unsigned int			rx_ring_skbs;
+
+	struct net_device_stats		stats;
+
+	/* Tx and Rx coalescing */
+	unsigned long			rx_int_coal;
+	unsigned long			tx_int_coal;
+
+	/* Threshold for replenishing the Rx and Tx rings */
+	unsigned int			tx_threshold;
+	unsigned int			rx_threshold;
+
+	/* NAPI work limit */
+	unsigned int			rx_work_limit;
+} titan_ge_port_info;
+
+/* Titan specific constants */
+#define	TITAN_ETH_PORT_IRQ		3
+
+/* Max Rx buffer */
+#define	TITAN_GE_MAX_RX_BUFFER		65536
+
+/* Tx and Rx Error */
+#define	TITAN_GE_ERROR
+
+/* Rx Descriptor Command and Status */
+
+#define	TITAN_GE_RX_CRC_ERROR		TITAN_BIT27	/* crc error */
+#define	TITAN_GE_RX_OVERFLOW_ERROR	TITAN_BIT15	/* overflow */
+#define TITAN_GE_RX_BUFFER_OWNED	TITAN_BIT21	/* buffer ownership */
+#define	TITAN_GE_RX_STP			TITAN_BIT31	/* start of packet */
+#define	TITAN_GE_RX_BAM			TITAN_BIT30	/* broadcast address match */
+#define TITAN_GE_RX_PAM			TITAN_BIT28	/* physical address match */
+#define TITAN_GE_RX_LAFM		TITAN_BIT29	/* logical address filter match */
+#define TITAN_GE_RX_VLAN		TITAN_BIT26	/* virtual lans */
+#define TITAN_GE_RX_PERR		TITAN_BIT19	/* packet error */
+#define TITAN_GE_RX_TRUNC		TITAN_BIT20	/* packet size greater than 32 buffers */
+
+/* Tx Descriptor Command */
+#define	TITAN_GE_TX_BUFFER_OWNED	TITAN_BIT5	/* buffer ownership */
+#define	TITAN_GE_TX_ENABLE_INTERRUPT	TITAN_BIT15	/* Interrupt Enable */
+
+/* Return Status */
+#define	TITAN_OK	0x1	/* Good Status */
+#define	TITAN_ERROR	0x2	/* Error Status */
+
+/* MIB specific register offset */
+#define TITAN_GE_MSTATX_STATS_BASE_LOW       0x0800  /* MSTATX COUNTL[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_MID       0x0804  /* MSTATX COUNTM[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_HI        0x0808  /* MSTATX COUNTH[7:0] */
+#define TITAN_GE_MSTATX_CONTROL              0x0828  /* MSTATX Control */
+#define TITAN_GE_MSTATX_VARIABLE_SELECT      0x082C  /* MSTATX Variable Select */
+
+/* MIB counter offsets, add to the TITAN_GE_MSTATX_STATS_BASE_XXX */
+#define TITAN_GE_MSTATX_RXFRAMESOK                   0x0040
+#define TITAN_GE_MSTATX_RXOCTETSOK                   0x0050
+#define TITAN_GE_MSTATX_RXFRAMES                     0x0060
+#define TITAN_GE_MSTATX_RXOCTETS                     0x0070
+#define TITAN_GE_MSTATX_RXUNICASTFRAMESOK            0x0080
+#define TITAN_GE_MSTATX_RXBROADCASTFRAMESOK          0x0090
+#define TITAN_GE_MSTATX_RXMULTICASTFRAMESOK          0x00A0
+#define TITAN_GE_MSTATX_RXTAGGEDFRAMESOK             0x00B0
+#define TITAN_GE_MSTATX_RXMACPAUSECONTROLFRAMESOK    0x00C0
+#define TITAN_GE_MSTATX_RXMACCONTROLFRAMESOK         0x00D0
+#define TITAN_GE_MSTATX_RXFCSERROR                   0x00E0
+#define TITAN_GE_MSTATX_RXALIGNMENTERROR             0x00F0
+#define TITAN_GE_MSTATX_RXSYMBOLERROR                0x0100
+#define TITAN_GE_MSTATX_RXLAYER1ERROR                0x0110
+#define TITAN_GE_MSTATX_RXINRANGELENGTHERROR         0x0120
+#define TITAN_GE_MSTATX_RXLONGLENGTHERROR            0x0130
+#define TITAN_GE_MSTATX_RXLONGLENGTHCRCERROR         0x0140
+#define TITAN_GE_MSTATX_RXSHORTLENGTHERROR           0x0150
+#define TITAN_GE_MSTATX_RXSHORTLLENGTHCRCERROR       0x0160
+#define TITAN_GE_MSTATX_RXFRAMES64OCTETS             0x0170
+#define TITAN_GE_MSTATX_RXFRAMES65TO127OCTETS        0x0180
+#define TITAN_GE_MSTATX_RXFRAMES128TO255OCTETS       0x0190
+#define TITAN_GE_MSTATX_RXFRAMES256TO511OCTETS       0x01A0
+#define TITAN_GE_MSTATX_RXFRAMES512TO1023OCTETS      0x01B0
+#define TITAN_GE_MSTATX_RXFRAMES1024TO1518OCTETS     0x01C0
+#define TITAN_GE_MSTATX_RXFRAMES1519TOMAXSIZE        0x01D0
+#define TITAN_GE_MSTATX_RXSTATIONADDRESSFILTERED     0x01E0
+#define TITAN_GE_MSTATX_RXVARIABLE                   0x01F0
+#define TITAN_GE_MSTATX_GENERICADDRESSFILTERED       0x0200
+#define TITAN_GE_MSTATX_UNICASTFILTERED              0x0210
+#define TITAN_GE_MSTATX_MULTICASTFILTERED            0x0220
+#define TITAN_GE_MSTATX_BROADCASTFILTERED            0x0230
+#define TITAN_GE_MSTATX_HASHFILTERED                 0x0240
+#define TITAN_GE_MSTATX_TXFRAMESOK                   0x0250
+#define TITAN_GE_MSTATX_TXOCTETSOK                   0x0260
+#define TITAN_GE_MSTATX_TXOCTETS                     0x0270
+#define TITAN_GE_MSTATX_TXTAGGEDFRAMESOK             0x0280
+#define TITAN_GE_MSTATX_TXMACPAUSECONTROLFRAMESOK    0x0290
+#define TITAN_GE_MSTATX_TXFCSERROR                   0x02A0
+#define TITAN_GE_MSTATX_TXSHORTLENGTHERROR           0x02B0
+#define TITAN_GE_MSTATX_TXLONGLENGTHERROR            0x02C0
+#define TITAN_GE_MSTATX_TXSYSTEMERROR                0x02D0
+#define TITAN_GE_MSTATX_TXMACERROR                   0x02E0
+#define TITAN_GE_MSTATX_TXCARRIERSENSEERROR          0x02F0
+#define TITAN_GE_MSTATX_TXSQETESTERROR               0x0300
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESOK            0x0310
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESOK          0x0320
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESOK          0x0330
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESATTEMPTED     0x0340
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESATTEMPTED   0x0350
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESATTEMPTED   0x0360
+#define TITAN_GE_MSTATX_TXFRAMES64OCTETS             0x0370
+#define TITAN_GE_MSTATX_TXFRAMES65TO127OCTETS        0x0380
+#define TITAN_GE_MSTATX_TXFRAMES128TO255OCTETS       0x0390
+#define TITAN_GE_MSTATX_TXFRAMES256TO511OCTETS       0x03A0
+#define TITAN_GE_MSTATX_TXFRAMES512TO1023OCTETS      0x03B0
+#define TITAN_GE_MSTATX_TXFRAMES1024TO1518OCTETS     0x03C0
+#define TITAN_GE_MSTATX_TXFRAMES1519TOMAXSIZE        0x03D0
+#define TITAN_GE_MSTATX_TXVARIABLE                   0x03E0
+#define TITAN_GE_MSTATX_RXSYSTEMERROR                0x03F0
+#define TITAN_GE_MSTATX_SINGLECOLLISION              0x0400
+#define TITAN_GE_MSTATX_MULTIPLECOLLISION            0x0410
+#define TITAN_GE_MSTATX_DEFERREDXMISSIONS            0x0420
+#define TITAN_GE_MSTATX_LATECOLLISIONS               0x0430
+#define TITAN_GE_MSTATX_ABORTEDDUETOXSCOLLS          0x0440
+
+/* Interrupt specific defines */
+#define TITAN_GE_DEVICE_ID         0x0000  /* Device ID */
+#define TITAN_GE_RESET             0x0004  /* Reset reg */
+#define TITAN_GE_TSB_CTRL_0        0x000C  /* TSB Control reg 0 */
+#define TITAN_GE_TSB_CTRL_1        0x0010  /* TSB Control reg 1 */
+#define TITAN_GE_INTR_GRP0_STATUS  0x0040  /* General Interrupt Group 0 Status */
+#define TITAN_GE_INTR_XDMA_CORE_A  0x0048  /* XDMA Channel Interrupt Status, Core A*/
+#define TITAN_GE_INTR_XDMA_CORE_B  0x004C  /* XDMA Channel Interrupt Status, Core B*/
+#define	TITAN_GE_INTR_XDMA_IE	   0x0058  /* XDMA Channel Interrupt Enable */
+#define TITAN_GE_SDQPF_ECC_INTR    0x480C  /* SDQPF ECC Interrupt Status */
+#define TITAN_GE_SDQPF_RXFIFO_CTL  0x4828  /* SDQPF RxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_RXFIFO_INTR 0x482C  /* SDQPF RxFifo Interrupt Status */
+#define TITAN_GE_SDQPF_TXFIFO_CTL  0x4928  /* SDQPF TxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_TXFIFO_INTR 0x492C  /* SDQPF TxFifo Interrupt Status */
+#define	TITAN_GE_SDQPF_RXFIFO_0	   0x4840  /* SDQPF RxFIFO Enable */
+#define	TITAN_GE_SDQPF_TXFIFO_0	   0x4940  /* SDQPF TxFIFO Enable */
+#define TITAN_GE_XDMA_CONFIG       0x5000  /* XDMA Global Configuration */
+#define TITAN_GE_XDMA_INTR_SUMMARY 0x5010  /* XDMA Interrupt Summary */
+#define TITAN_GE_XDMA_BUFADDRPRE   0x5018  /* XDMA Buffer Address Prefix */
+#define TITAN_GE_XDMA_DESCADDRPRE  0x501C  /* XDMA Descriptor Address Prefix */
+#define TITAN_GE_XDMA_PORTWEIGHT   0x502C  /* XDMA Port Weight Configuration */
+
+/* Rx MAC defines */
+#define TITAN_GE_RMAC_CONFIG_1               0x1200  /* RMAC Configuration 1 */
+#define TITAN_GE_RMAC_CONFIG_2               0x1204  /* RMAC Configuration 2 */
+#define TITAN_GE_RMAC_MAX_FRAME_LEN          0x1208  /* RMAC Max Frame Length */
+#define TITAN_GE_RMAC_STATION_HI             0x120C  /* Rx Station Address High */
+#define TITAN_GE_RMAC_STATION_MID            0x1210  /* Rx Station Address Middle */
+#define TITAN_GE_RMAC_STATION_LOW            0x1214  /* Rx Station Address Low */
+#define TITAN_GE_RMAC_LINK_CONFIG            0x1218  /* RMAC Link Configuration */
+
+/* Tx MAC defines */
+#define TITAN_GE_TMAC_CONFIG_1               0x1240  /* TMAC Configuration 1 */
+#define TITAN_GE_TMAC_CONFIG_2               0x1244  /* TMAC Configuration 2 */
+#define TITAN_GE_TMAC_IPG                    0x1248  /* TMAC Inter-Packet Gap */
+#define TITAN_GE_TMAC_STATION_HI             0x124C  /* Tx Station Address High */
+#define TITAN_GE_TMAC_STATION_MID            0x1250  /* Tx Station Address Middle */
+#define TITAN_GE_TMAC_STATION_LOW            0x1254  /* Tx Station Address Low */
+#define TITAN_GE_TMAC_MAX_FRAME_LEN          0x1258  /* TMAC Max Frame Length */
+#define TITAN_GE_TMAC_MIN_FRAME_LEN          0x125C  /* TMAC Min Frame Length */
+#define TITAN_GE_TMAC_PAUSE_FRAME_TIME       0x1260  /* TMAC Pause Frame Time */
+#define TITAN_GE_TMAC_PAUSE_FRAME_INTERVAL   0x1264  /* TMAC Pause Frame Interval */
+
+/* GMII register */
+#define TITAN_GE_GMII_INTERRUPT_STATUS       0x1348  /* GMII Interrupt Status */
+#define TITAN_GE_GMII_CONFIG_GENERAL         0x134C  /* GMII Configuration General */
+#define TITAN_GE_GMII_CONFIG_MODE            0x1350  /* GMII Configuration Mode */
+
+/* Tx and Rx XDMA defines */
+#define	TITAN_GE_INT_COALESCING		     0x5030 /* Interrupt Coalescing */
+#define	TITAN_GE_CHANNEL0_CONFIG	     0x5040 /* Channel 0 XDMA config */
+#define	TITAN_GE_CHANNEL0_INTERRUPT	     0x504c /* Channel 0 Interrupt Status */
+#define	TITAN_GE_GDI_INTERRUPT_ENABLE        0x5050 /* IE for the GDI Errors */
+#define	TITAN_GE_CHANNEL0_PACKET	     0x5060 /* Channel 0 Packet count */
+#define	TITAN_GE_CHANNEL0_BYTE		     0x5064 /* Channel 0 Byte count */
+#define	TITAN_GE_CHANNEL0_TX_DESC	     0x5054 /* Channel 0 Tx first desc */
+#define	TITAN_GE_CHANNEL0_RX_DESC	     0x5058 /* Channel 0 Rx first desc */
+
+/* AFX (Address Filter Exact) register offsets for Slice 0 */
+#define TITAN_GE_AFX_EXACT_MATCH_LOW         0x1100  /* AFX Exact Match Address Low*/
+#define TITAN_GE_AFX_EXACT_MATCH_MID         0x1104  /* AFX Exact Match Address Mid*/
+#define TITAN_GE_AFX_EXACT_MATCH_HIGH        0x1108  /* AFX Exact Match Address Hi */
+#define TITAN_GE_AFX_EXACT_MATCH_VID         0x110C  /* AFX Exact Match VID */
+#define TITAN_GE_AFX_MULTICAST_HASH_LOW      0x1110  /* AFX Multicast HASH Low */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDLOW   0x1114  /* AFX Multicast HASH MidLow */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDHI    0x1118  /* AFX Multicast HASH MidHi */
+#define TITAN_GE_AFX_MULTICAST_HASH_HI       0x111C  /* AFX Multicast HASH Hi */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_0     0x1120  /* AFX Address Filter Ctrl 0 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_1     0x1124  /* AFX Address Filter Ctrl 1 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_2     0x1128  /* AFX Address Filter Ctrl 2 */
+
+/* Traffic Groomer block */
+#define        TITAN_GE_TRTG_CONFIG	     0x1000  /* TRTG Config */
+
+#endif 				/* _TITAN_GE_H_ */
+
diff -Naur linux-2.6.14/drivers/net/titan_mdio.c linux-mips-2.6.14.orig/drivers/net/titan_mdio.c
--- linux-2.6.14/drivers/net/titan_mdio.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/titan_mdio.c	2005-11-17 11:43:12.000000000 -0800
@@ -0,0 +1,217 @@
+/*
+ * drivers/net/titan_mdio.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * Management Data IO (MDIO) driver for the Titan GMII. Interacts with the Marvel PHY
+ * on the Titan. No support for the TBI as yet.
+ *
+ */
+
+#include	"titan_mdio.h"
+
+#define MDIO_DEBUG
+
+/*
+ * Local constants
+ */
+#define MAX_CLKA            1023
+#define MAX_PHY_DEV         31
+#define MAX_PHY_REG         31
+#define WRITEADDRS_OPCODE   0x0
+#define	READ_OPCODE	    0x2
+#define WRITE_OPCODE        0x1
+#define MAX_MDIO_POLL       100
+
+/*
+ * Titan MDIO and SCMB registers
+ */
+#define TITAN_GE_SCMB_CONTROL                0x01c0  /* SCMB Control */
+#define TITAN_GE_SCMB_CLKA	             0x01c4  /* SCMB Clock A */
+#define TITAN_GE_MDIO_COMMAND                0x01d0  /* MDIO Command */
+#define TITAN_GE_MDIO_DEVICE_PORT_ADDRESS    0x01d4  /* MDIO Device and Port addrs */
+#define TITAN_GE_MDIO_DATA                   0x01d8  /* MDIO Data */
+#define TITAN_GE_MDIO_INTERRUPTS             0x01dC  /* MDIO Interrupts */
+
+/*
+ * Function to poll the MDIO
+ */
+static int titan_ge_mdio_poll(void)
+{
+	int	i, val;
+
+	for (i = 0; i < MAX_MDIO_POLL; i++) {
+		val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+
+		if (!(val & 0x8000))
+			return TITAN_GE_MDIO_GOOD;
+	}
+
+	return TITAN_GE_MDIO_ERROR;
+}
+
+
+/*
+ * Initialize and configure the MDIO
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *titan_mdio)
+{
+	unsigned long	val;
+
+	/* Reset the SCMB and program into MDIO mode*/
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x9000);
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x1000);
+
+	/* CLK A */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_SCMB_CLKA);
+	val = ( (val & ~(0x03ff)) | (titan_mdio->clka & 0x03ff));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CLKA, val);
+
+	/* Preamble Suppresion */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0001)) | (titan_mdio->mdio_spre & 0x0001));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	/* MDIO mode */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x4000)) | (titan_mdio->mdio_mode & 0x4000));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Set the PHY address in indirect mode
+ */
+int titan_ge_mdio_inaddrs(int dev_addr, int reg_addr)
+{
+	volatile unsigned long	val;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	/* Write the new address */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITEADDRS_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Read the MDIO register. This is what the individual parametes mean:
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register offset
+ *
+ * See the spec for the Titan MAC. We operate in the Direct Mode.
+ */
+
+#define MAX_RETRIES	2
+
+int titan_ge_mdio_read(int dev_addr, int reg_addr, unsigned int *pdata)
+{
+	volatile unsigned long	val;
+	int retries = 0;
+
+	/* Setup the PHY device */
+
+again:
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Issue the read command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (READ_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	*pdata = (unsigned int)TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DATA);
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+
+	udelay(30);
+
+	if (val & 0x2) {
+		if (retries == MAX_RETRIES)
+			return TITAN_GE_MDIO_ERROR;
+		else {
+			retries++;
+			goto again;
+		}
+	}
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Write to the MDIO register
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register that needs to be written to
+ *
+ */
+int titan_ge_mdio_write(int dev_addr, int reg_addr, unsigned int data)
+{
+	volatile unsigned long	val;
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Setup the data to write */
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DATA, data);
+
+	udelay(30);
+
+	/* Issue the write command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITE_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+	if (val & 0x2)
+		return TITAN_GE_MDIO_ERROR;
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
diff -Naur linux-2.6.14/drivers/net/titan_mdio.h linux-mips-2.6.14.orig/drivers/net/titan_mdio.h
--- linux-2.6.14/drivers/net/titan_mdio.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/net/titan_mdio.h	2005-11-17 11:43:12.000000000 -0800
@@ -0,0 +1,56 @@
+/*
+ * MDIO used to interact with the PHY when using GMII/MII
+ */
+#ifndef _TITAN_MDIO_H
+#define _TITAN_MDIO_H
+
+#include <linux/netdevice.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include "titan_ge.h"
+
+
+#define	TITAN_GE_MDIO_ERROR	(-9000)
+#define	TITAN_GE_MDIO_GOOD	0
+
+#define	TITAN_GE_MDIO_BASE		titan_ge_base
+
+#define	TITAN_GE_MDIO_READ(offset)	\
+	*(volatile u32 *)(titan_ge_base + (offset))
+
+#define	TITAN_GE_MDIO_WRITE(offset, data)	\
+	*(volatile u32 *)(titan_ge_base + (offset)) = (data)
+
+
+/* GMII specific registers */
+#define	TITAN_GE_MARVEL_PHY_ID		0x00
+#define	TITAN_PHY_AUTONEG_ADV		0x04
+#define	TITAN_PHY_LP_ABILITY		0x05
+#define	TITAN_GE_MDIO_MII_CTRL		0x09
+#define	TITAN_GE_MDIO_MII_EXTENDED	0x0f
+#define	TITAN_GE_MDIO_PHY_CTRL		0x10
+#define	TITAN_GE_MDIO_PHY_STATUS	0x11
+#define	TITAN_GE_MDIO_PHY_IE		0x12
+#define	TITAN_GE_MDIO_PHY_IS		0x13
+#define	TITAN_GE_MDIO_PHY_LED		0x18
+#define	TITAN_GE_MDIO_PHY_LED_OVER	0x19
+#define	PHY_ANEG_TIME_WAIT		45	/* 45 seconds wait time */
+
+/*
+ * MDIO Config Structure
+ */
+typedef struct {
+	unsigned int		clka;
+	int			mdio_spre;
+	int			mdio_mode;
+} titan_ge_mdio_config;
+
+/*
+ * Function Prototypes
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *);
+int titan_ge_mdio_inaddrs(int, int);
+int titan_ge_mdio_read(int, int, unsigned int *);
+int titan_ge_mdio_write(int, int, unsigned int);
+
+#endif /* _TITAN_MDIO_H */
diff -Naur linux-2.6.14/drivers/net/tulip/de2104x.c linux-mips-2.6.14.orig/drivers/net/tulip/de2104x.c
--- linux-2.6.14/drivers/net/tulip/de2104x.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/tulip/de2104x.c	2005-11-17 11:43:12.000000000 -0800
@@ -1787,10 +1787,15 @@
 	/* DEC now has a specification but early board makers
 	   just put the address in the first EEPROM locations. */
 	/* This does  memcmp(eedata, eedata+16, 8) */
+
+#ifndef CONFIG_MIPS_COBALT
+
 	for (i = 0; i < 8; i ++)
 		if (ee_data[i] != ee_data[16+i])
 			sa_offset = 20;
 
+#endif
+
 	/* store MAC address */
 	for (i = 0; i < 6; i ++)
 		de->dev->dev_addr[i] = ee_data[i + sa_offset];
diff -Naur linux-2.6.14/drivers/net/tulip/tulip_core.c linux-mips-2.6.14.orig/drivers/net/tulip/tulip_core.c
--- linux-2.6.14/drivers/net/tulip/tulip_core.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/net/tulip/tulip_core.c	2005-11-17 11:43:13.000000000 -0800
@@ -1495,8 +1495,8 @@
                if ((pdev->bus->number == 0) && (PCI_SLOT(pdev->devfn) == 4)) {
                        /* DDB5477 MAC address in first EEPROM locations. */
                        sa_offset = 0;
-                       /* No media table either */
-                       tp->flags &= ~HAS_MEDIA_TABLE;
+		       /* Ensure our media table fixup get's applied */
+		       memcpy(ee_data + 16, ee_data, 8);
                }
 #endif
 #ifdef CONFIG_MIPS_COBALT
diff -Naur linux-2.6.14/drivers/pci/pci.ids linux-mips-2.6.14.orig/drivers/pci/pci.ids
--- linux-2.6.14/drivers/pci/pci.ids	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/pci/pci.ids	2005-11-17 11:43:24.000000000 -0800
@@ -0,0 +1,10183 @@
+#
+#	List of PCI ID's
+#
+#	Maintained by Martin Mares <mj@ucw.cz> and other volunteers from the
+#	Linux PCI ID's Project at http://pciids.sf.net/. New data are always
+#	welcome (if they are accurate), we're eagerly expecting new entries,
+#	so if you have anything to contribute, please visit the home page or
+#	send a diff -u against the most recent pci.ids to pci-ids@ucw.cz.
+#
+#	Daily snapshot on Tue 2005-03-08 10:11:48
+#
+
+# Vendors, devices and subsystems. Please keep sorted.
+
+# Syntax:
+# vendor  vendor_name
+#	device  device_name				<-- single tab
+#		subvendor subdevice  subsystem_name	<-- two tabs
+
+0000  Gammagraphx, Inc.
+001a  Ascend Communications, Inc.
+0033  Paradyne corp.
+003d  Lockheed Martin-Marietta Corp
+# Real TJN ID is e159, but they got it wrong several times --mj
+0059  Tiger Jet Network Inc. (Wrong ID)
+0070  Hauppauge computer works Inc.
+	4000  WinTV PVR-350
+	4001  WinTV PVR-250 (v1)
+	4009  WinTV PVR-250
+	4801  WinTV PVR-250 MCE
+0071  Nebula Electronics Ltd.
+0095  Silicon Image, Inc. (Wrong ID)
+	0680  Ultra ATA/133 IDE RAID CONTROLLER CARD
+0100  Ncipher Corp Ltd
+# 018a is not LevelOne but there is a board misprogrammed
+018a  LevelOne
+	0106  FPC-0106TX misprogrammed [RTL81xx]
+# 021b is not Compaq but there is a board misprogrammed
+021b  Compaq Computer Corporation
+	8139  HNE-300 (RealTek RTL8139c) [iPaq Networking]
+# http://www.davicom.com.tw/
+0291  Davicom Semiconductor, Inc.
+	8212  DM9102A(DM9102AE, SM9102AF) Ethernet 100/10 MBit(Rev 40)
+# SpeedStream is Efficient Networks, Inc, a Siemens Company
+02ac  SpeedStream
+	1012  1012 PCMCIA 10/100 Ethernet Card [RTL81xx]
+0357  TTTech AG
+	000a  TTP-Monitoring Card V2.0
+0432  SCM Microsystems, Inc.
+	0001  Pluto2 DVB-T Receiver for PCMCIA [EasyWatch MobilSet]
+05e3  CyberDoor
+	0701  CBD516
+0675  Dynalink
+	1700  IS64PH ISDN Adapter
+	1702  IS64PH ISDN Adapter
+# Wrong ID used in subsystem ID of VIA USB controllers.
+0925  VIA Technologies, Inc. (Wrong ID)
+09c1  Arris
+	0704  CM 200E Cable Modem
+0a89  BREA Technologies Inc
+0b49  ASCII Corporation
+# see http://homepage1.nifty.com/mcn/lab/machines/trance_vibrator/usbview.vib.txt
+	064f  Trance Vibrator
+0e11  Compaq Computer Corporation
+	0001  PCI to EISA Bridge
+	0002  PCI to ISA Bridge
+	0046  Smart Array 64xx
+		0e11 409a  Smart Array 641
+		0e11 409b  Smart Array 642
+		0e11 409c  Smart Array 6400
+		0e11 409d  Smart Array 6400 EM
+	0049  NC7132 Gigabit Upgrade Module
+	004a  NC6136 Gigabit Server Adapter
+	007c  NC7770 1000BaseTX
+	007d  NC6770 1000BaseTX
+	0085  NC7780 1000BaseTX
+	00bb  NC7760
+	00ca  NC7771
+	00cb  NC7781
+	00cf  NC7772
+	00d0  NC7782
+	00d1  NC7783
+	00e3  NC7761
+	0508  Netelligent 4/16 Token Ring
+	1000  Triflex/Pentium Bridge, Model 1000
+	2000  Triflex/Pentium Bridge, Model 2000
+	3032  QVision 1280/p
+	3033  QVision 1280/p
+	3034  QVision 1280/p
+	4000  4000 [Triflex]
+	4030  SMART-2/P
+	4031  SMART-2SL
+	4032  Smart Array 3200
+	4033  Smart Array 3100ES
+	4034  Smart Array 221
+	4040  Integrated Array
+	4048  Compaq Raid LC2
+	4050  Smart Array 4200
+	4051  Smart Array 4250ES
+	4058  Smart Array 431
+	4070  Smart Array 5300
+	4080  Smart Array 5i
+	4082  Smart Array 532
+	4083  Smart Array 5312
+	4091  Smart Array 6i
+	409a  Smart Array 641
+	409b  Smart Array 642
+	409c  Smart Array 6400
+	409d  Smart Array 6400 EM
+	6010  HotPlug PCI Bridge 6010
+	7020  USB Controller
+	a0ec  Fibre Channel Host Controller
+	a0f0  Advanced System Management Controller
+	a0f3  Triflex PCI to ISA Bridge
+	a0f7  PCI Hotplug Controller
+		8086 002a  PCI Hotplug Controller A
+		8086 002b  PCI Hotplug Controller B
+	a0f8  ZFMicro Chipset USB
+	a0fc  FibreChannel HBA Tachyon
+	ae10  Smart-2/P RAID Controller
+		0e11 4030  Smart-2/P Array Controller
+		0e11 4031  Smart-2SL Array Controller
+		0e11 4032  Smart Array Controller
+		0e11 4033  Smart 3100ES Array Controller
+	ae29  MIS-L
+	ae2a  MPC
+	ae2b  MIS-E
+	ae31  System Management Controller
+	ae32  Netelligent 10/100 TX PCI UTP
+	ae33  Triflex Dual EIDE Controller
+	ae34  Netelligent 10 T PCI UTP
+	ae35  Integrated NetFlex-3/P
+	ae40  Netelligent Dual 10/100 TX PCI UTP
+	ae43  Netelligent Integrated 10/100 TX UTP
+	ae69  CETUS-L
+	ae6c  Northstar
+	ae6d  NorthStar CPU to PCI Bridge
+	b011  Netelligent 10/100 TX Embedded UTP
+	b012  Netelligent 10 T/2 PCI UTP/Coax
+	b01e  NC3120 Fast Ethernet NIC
+	b01f  NC3122 Fast Ethernet NIC
+	b02f  NC1120 Ethernet NIC
+	b030  Netelligent 10/100 TX UTP
+	b04a  10/100 TX PCI Intel WOL UTP Controller
+	b060  Smart Array 5300 Controller
+	b0c6  NC3161 Fast Ethernet NIC
+	b0c7  NC3160 Fast Ethernet NIC
+	b0d7  NC3121 Fast Ethernet NIC
+	b0dd  NC3131 Fast Ethernet NIC
+	b0de  NC3132 Fast Ethernet Module
+	b0df  NC6132 Gigabit Module
+	b0e0  NC6133 Gigabit Module
+	b0e1  NC3133 Fast Ethernet Module
+	b123  NC6134 Gigabit NIC
+	b134  NC3163 Fast Ethernet NIC
+	b13c  NC3162 Fast Ethernet NIC
+	b144  NC3123 Fast Ethernet NIC
+	b163  NC3134 Fast Ethernet NIC
+	b164  NC3165 Fast Ethernet Upgrade Module
+	b178  Smart Array 5i/532
+		0e11 4080  Smart Array 5i
+		0e11 4082  Smart Array 532
+		0e11 4083  Smart Array 5312
+	b1a4  NC7131 Gigabit Server Adapter
+# HP Memory Hot-Plug Controller
+	b200  Memory Hot-Plug Controller
+	b203  Integrated Lights Out Controller
+	b204  Integrated Lights Out  Processor
+	f130  NetFlex-3/P ThunderLAN 1.0
+	f150  NetFlex-3/P ThunderLAN 2.3
+0e55  HaSoTec GmbH
+# Formerly NCR
+1000  LSI Logic / Symbios Logic
+	0001  53c810
+		1000 1000  LSI53C810AE PCI to SCSI I/O Processor
+	0002  53c820
+	0003  53c825
+		1000 1000  LSI53C825AE PCI to SCSI I/O Processor (Ultra Wide)
+	0004  53c815
+	0005  53c810AP
+	0006  53c860
+		1000 1000  LSI53C860E PCI to Ultra SCSI I/O Processor
+	000a  53c1510
+		1000 1000  LSI53C1510 PCI to Dual Channel Wide Ultra2 SCSI Controller (Nonintelligent mode)
+	000b  53C896/897
+		0e11 6004  EOB003 Series SCSI host adapter
+		1000 1000  LSI53C896/7 PCI to Dual Channel Ultra2 SCSI Multifunction Controller
+		1000 1010  LSI22910 PCI to Dual Channel Ultra2 SCSI host adapter
+		1000 1020  LSI21002 PCI to Dual Channel Ultra2 SCSI host adapter
+# multifunction PCI card: Dual U2W SCSI, dual 10/100TX, graphics
+		13e9 1000  6221L-4U
+	000c  53c895
+		1000 1010  LSI8951U PCI to Ultra2 SCSI host adapter
+		1000 1020  LSI8952U PCI to Ultra2 SCSI host adapter
+		1de1 3906  DC-390U2B SCSI adapter
+		1de1 3907  DC-390U2W
+	000d  53c885
+	000f  53c875
+		0e11 7004  Embedded Ultra Wide SCSI Controller
+		1000 1000  LSI53C876/E PCI to Dual Channel SCSI Controller
+		1000 1010  LSI22801 PCI to Dual Channel Ultra SCSI host adapter
+		1000 1020  LSI22802 PCI to Dual Channel Ultra SCSI host adapter
+		1092 8760  FirePort 40 Dual SCSI Controller
+		1de1 3904  DC390F/U Ultra Wide SCSI Adapter
+		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
+		4c53 1050  CT7 mainboard
+	0010  53C1510
+		0e11 4040  Integrated Array Controller
+		0e11 4048  RAID LC2 Controller
+		1000 1000  53C1510 PCI to Dual Channel Wide Ultra2 SCSI Controller (Intelligent mode)
+	0012  53c895a
+		1000 1000  LSI53C895A PCI to Ultra2 SCSI Controller
+	0013  53c875a
+		1000 1000  LSI53C875A PCI to Ultra SCSI Controller
+	0020  53c1010 Ultra3 SCSI Adapter
+		1000 1000  LSI53C1010-33 PCI to Dual Channel Ultra160 SCSI Controller
+		1de1 1020  DC-390U3W
+	0021  53c1010 66MHz  Ultra3 SCSI Adapter
+		1000 1000  LSI53C1000/1000R/1010R/1010-66 PCI to Ultra160 SCSI Controller
+		1000 1010  Asus TR-DLS onboard 53C1010-66
+		124b 1070  PMC-USCSI3
+		4c53 1080  CT8 mainboard
+		4c53 1300  P017 mezzanine (32-bit PMC)
+		4c53 1310  P017 mezzanine (64-bit PMC)
+	0030  53c1030 PCI-X Fusion-MPT Dual Ultra320 SCSI
+		1028 0123  PowerEdge 2600
+		1028 014a  PowerEdge 1750
+		1028 016c  PowerEdge 1850 MPT Fusion SCSI/RAID (Perc 4)
+		1028 0183  PowerEdge 1800
+		1028 1010  LSI U320 SCSI Controller
+	0031  53c1030ZC PCI-X Fusion-MPT Dual Ultra320 SCSI
+	0032  53c1035 PCI-X Fusion-MPT Dual Ultra320 SCSI
+		1000 1000  LSI53C1020/1030 PCI-X to Ultra320 SCSI Controller
+	0033  1030ZC_53c1035 PCI-X Fusion-MPT Dual Ultra320 SCSI
+	0040  53c1035 PCI-X Fusion-MPT Dual Ultra320 SCSI
+		1000 0033  MegaRAID SCSI 320-2XR
+		1000 0066  MegaRAID SCSI 320-2XRWS
+	0041  53C1035ZC PCI-X Fusion-MPT Dual Ultra320 SCSI
+	008f  53c875J
+		1092 8000  FirePort 40 SCSI Controller
+		1092 8760  FirePort 40 Dual SCSI Host Adapter
+	0407  MegaRAID
+		1000 0530  MegaRAID 530 SCSI 320-0X RAID Controller
+		1000 0531  MegaRAID 531 SCSI 320-4X RAID Controller
+		1000 0532  MegaRAID 532 SCSI 320-2X RAID Controller
+		1028 0531  PowerEdge Expandable RAID Controller 4/QC
+		1028 0533  PowerEdge Expandable RAID Controller 4/QC
+		8086 0530  MegaRAID Intel RAID Controller SRCZCRX
+		8086 0532  MegaRAID Intel RAID Controller SRCU42X
+	0408  MegaRAID
+		1000 0001  MegaRAID SCSI 320-1E RAID Controller
+		1000 0002  MegaRAID SCSI 320-2E RAID Controller
+		1025 004d  MegaRAID ACER ROMB-2E RAID Controller
+		1028 0001  PowerEdge RAID Controller PERC4e/SC
+		1028 0002  PowerEdge RAID Controller PERC4e/DC
+		1734 1065  FSC MegaRAID PCI Express ROMB
+		8086 0002  MegaRAID Intel RAID Controller SRCU42E
+	0409  MegaRAID
+		1000 3004  MegaRAID SATA 300-4X RAID Controller
+		1000 3008  MegaRAID SATA 300-8X RAID Controller
+		8086 3008  MegaRAID RAID Controller SRCS28X
+		8086 3431  MegaRAID RAID Controller Alief SROMBU42E
+		8086 3499  MegaRAID RAID Controller Harwich SROMBU42E
+	0621  FC909 Fibre Channel Adapter
+	0622  FC929 Fibre Channel Adapter
+		1000 1020  44929 O Dual Fibre Channel card
+	0623  FC929 LAN
+	0624  FC919 Fibre Channel Adapter
+	0625  FC919 LAN
+	0626  FC929X Fibre Channel Adapter
+		1000 1010  7202-XP-LC Dual Fibre Channel card
+	0627  FC929X LAN
+	0628  FC919X Fibre Channel Adapter
+	0629  FC919X LAN
+	0701  83C885 NT50 DigitalScape Fast Ethernet
+	0702  Yellowfin G-NIC gigabit ethernet
+		1318 0000  PEI100X
+	0804  SA2010
+	0805  SA2010ZC
+	0806  SA2020
+	0807  SA2020ZC
+	0901  61C102
+	1000  63C815
+	1960  MegaRAID
+		1000 0518  MegaRAID 518 SCSI 320-2 Controller
+		1000 0520  MegaRAID 520 SCSI 320-1 Controller
+		1000 0522  MegaRAID 522 i4 133 RAID Controller
+		1000 0523  MegaRAID SATA 150-6 RAID Controller
+		1000 4523  MegaRAID SATA 150-4 RAID Controller
+		1000 a520  MegaRAID ZCR SCSI 320-0 Controller
+		1028 0518  MegaRAID 518 DELL PERC 4/DC RAID Controller
+		1028 0520  MegaRAID 520 DELL PERC 4/SC RAID Controller
+		1028 0531  PowerEdge Expandable RAID Controller 4/QC
+		1028 0533  PowerEdge Expandable RAID Controller 4/QC
+		8086 0520  MegaRAIDRAID Controller SRCU41L
+		8086 0523  MegaRAID RAID Controller SRCS16
+1001  Kolter Electronic
+	0010  PCI 1616 Measurement card with 32 digital I/O lines
+	0011  OPTO-PCI Opto-Isolated digital I/O board
+	0012  PCI-AD/DA Analogue I/O board
+	0013  PCI-OPTO-RELAIS Digital I/O board with relay outputs
+	0014  PCI-Counter/Timer Counter Timer board
+	0015  PCI-DAC416 Analogue output board
+	0016  PCI-MFB Analogue I/O board
+	0017  PROTO-3 PCI Prototyping board
+	9100  INI-9100/9100W SCSI Host
+1002  ATI Technologies Inc
+	3150  M24 1P [Radeon Mobility X600]
+	3154  M24 1T [FireGL M24 GL]
+	3e50  RV380 0x3e50 [Radeon X600]
+	3e54  RV380 0x3e54 [FireGL V3200]
+	3e70  RV380 [Radeon X600] Secondary
+	4136  Radeon IGP 320 M
+	4137  Radeon IGP330/340/350
+	4144  R300 AD [Radeon 9500 Pro]
+# New PCI ID provided by ATI developer relations (correction to above)
+	4145  R300 AE [Radeon 9700 Pro]
+# New PCI ID provided by ATI developer relations (oops, correction to above)
+	4146  R300 AF [Radeon 9700 Pro]
+	4147  R300 AG [FireGL Z1/X1]
+	4148  R350 AH [Radeon 9800]
+	4149  R350 AI [Radeon 9800]
+	414a  R350 AJ [Radeon 9800]
+	414b  R350 AK [Fire GL X2]
+# New PCI ID provided by ATI developer relations
+	4150  RV350 AP [Radeon 9600]
+		1002 0002  R9600 Pro primary (Asus OEM for HP)
+		1002 0003  R9600 Pro secondary (Asus OEM for HP)
+		1458 4024  Giga-Byte GV-R96128D Primary
+		148c 2064  PowerColor R96A-C3N
+		148c 2066  PowerColor R96A-C3N
+		174b 7c19  Sapphire Atlantis Radeon 9600 Pro
+		174b 7c29  GC-R9600PRO Primary [Sapphire]
+		17ee 2002  Radeon 9600 256Mb Primary
+		18bc 0101  GC-R9600PRO Primary
+# New PCI ID provided by ATI developer relations
+	4151  RV350 AQ [Radeon 9600]
+		1043 c004  A9600SE
+# New PCI ID provided by ATI developer relations
+	4152  RV350 AR [Radeon 9600]
+		1002 0002  Radeon 9600XT
+		1043 c002  Radeon 9600 XT TVD
+		174b 7c29  Sapphire Radeon 9600XT
+		1787 4002  Radeon 9600 XT
+	4153  RV350 AS [Radeon 9600 AS]
+	4154  RV350 AT [Fire GL T2]
+	4155  RV350 AU [Fire GL T2]
+	4156  RV350 AV [Fire GL T2]
+	4157  RV350 AW [Fire GL T2]
+	4158  68800AX [Mach32]
+# The PCI ID is unrelated to any DVI output.
+	4164  R300 AD [Radeon 9500 Pro] (Secondary)
+# New PCI ID info provided by ATI developer relations
+	4165  R300 AE [Radeon 9700 Pro] (Secondary)
+# New PCI ID info provided by ATI developer relations
+	4166  R300 AF [Radeon 9700 Pro] (Secondary)
+# New PCI ID provided by ATI developer relations
+	4168  Radeon R350 [Radeon 9800] (Secondary)
+# New PCI ID provided by ATI developer relations (correction to above)
+	4170  RV350 AP [Radeon 9600] (Secondary)
+		1458 4025  Giga-Byte GV-R96128D Secondary
+		148c 2067  PowerColor R96A-C3N (Secondary)
+		174b 7c28  GC-R9600PRO Secondary [Sapphire]
+		17ee 2003  Radeon 9600 256Mb Secondary
+		18bc 0100  GC-R9600PRO Secondary
+# New PCI ID provided by ATI developer relations (correction to above)
+	4171  RV350 AQ [Radeon 9600] (Secondary)
+		1043 c005  A9600SE (Secondary)
+# New PCI ID provided by ATI developer relations (correction to above)
+	4172  RV350 AR [Radeon 9600] (Secondary)
+		1002 0003  Radeon 9600XT (Secondary)
+		1043 c003  A9600XT (Secondary)
+		174b 7c28  Sapphire Radeon 9600XT (Secondary)
+		1787 4003  Radeon 9600 XT (Secondary)
+	4173  RV350 ?? [Radeon 9550] (Secondary)
+	4237  Radeon 7000 IGP
+	4242  R200 BB [Radeon All in Wonder 8500DV]
+		1002 02aa  Radeon 8500 AIW DV Edition
+	4243  R200 BC [Radeon All in Wonder 8500]
+	4336  Radeon Mobility U1
+		103c 0024  Pavilion ze4400 builtin Video
+	4337  Radeon IGP 330M/340M/350M
+		1014 053a  ThinkPad R40e (2684-HVG) builtin VGA controller
+		103c 0850  Radeon IGP 345M
+	4341  IXP150 AC'97 Audio Controller
+	4345  EHCI USB Controller
+	4347  OHCI USB Controller #1
+	4348  OHCI USB Controller #2
+	4349  ATI Dual Channel Bus Master PCI IDE Controller
+	434d  IXP AC'97 Modem
+	4353  ATI SMBus
+	4354  215CT [Mach64 CT]
+	4358  210888CX [Mach64 CX]
+	4363  ATI SMBus
+	436e  ATI 436E Serial ATA Controller
+	4372  ATI SMBus
+	4376  Standard Dual Channel PCI IDE Controller ATI
+	4379  ATI 4379 Serial ATA Controller
+	437a  ATI 437A Serial ATA Controller
+	4437  Radeon Mobility 7000 IGP
+	4554  210888ET [Mach64 ET]
+	4654  Mach64 VT
+	4742  3D Rage Pro AGP 1X/2X
+		1002 0040  Rage Pro Turbo AGP 2X
+		1002 0044  Rage Pro Turbo AGP 2X
+		1002 0061  Rage Pro AIW AGP 2X
+		1002 0062  Rage Pro AIW AGP 2X
+		1002 0063  Rage Pro AIW AGP 2X
+		1002 0080  Rage Pro Turbo AGP 2X
+		1002 0084  Rage Pro Turbo AGP 2X
+		1002 4742  Rage Pro Turbo AGP 2X
+		1002 8001  Rage Pro Turbo AGP 2X
+		1028 0082  Rage Pro Turbo AGP 2X
+		1028 4082  Optiplex GX1 Onboard Display Adapter
+		1028 8082  Rage Pro Turbo AGP 2X
+		1028 c082  Rage Pro Turbo AGP 2X
+		8086 4152  Xpert 98D AGP 2X
+		8086 464a  Rage Pro Turbo AGP 2X
+	4744  3D Rage Pro AGP 1X
+		1002 4744  Rage Pro Turbo AGP
+	4747  3D Rage Pro
+	4749  3D Rage Pro
+		1002 0061  Rage Pro AIW
+		1002 0062  Rage Pro AIW
+	474c  Rage XC
+	474d  Rage XL AGP 2X
+		1002 0004  Xpert 98 RXL AGP 2X
+		1002 0008  Xpert 98 RXL AGP 2X
+		1002 0080  Rage XL AGP 2X
+		1002 0084  Xpert 98 AGP 2X
+		1002 474d  Rage XL AGP
+		1033 806a  Rage XL AGP
+	474e  Rage XC AGP
+		1002 474e  Rage XC AGP
+	474f  Rage XL
+		1002 0008  Rage XL
+		1002 474f  Rage XL
+	4750  3D Rage Pro 215GP
+		1002 0040  Rage Pro Turbo
+		1002 0044  Rage Pro Turbo
+		1002 0080  Rage Pro Turbo
+		1002 0084  Rage Pro Turbo
+		1002 4750  Rage Pro Turbo
+	4751  3D Rage Pro 215GQ
+	4752  Rage XL
+		1002 0008  Rage XL
+		1002 4752  Rage XL
+		1002 8008  Rage XL
+		1028 00ce  PowerEdge 1400
+		1028 00d1  PowerEdge 2550
+		1028 00d9  PowerEdge 2500
+		8086 3411  SDS2 Mainboard
+		8086 3427  S875WP1-E mainboard
+	4753  Rage XC
+		1002 4753  Rage XC
+	4754  3D Rage I/II 215GT [Mach64 GT]
+	4755  3D Rage II+ 215GTB [Mach64 GTB]
+	4756  3D Rage IIC 215IIC [Mach64 GT IIC]
+		1002 4756  Rage IIC
+	4757  3D Rage IIC AGP
+		1002 4757  Rage IIC AGP
+		1028 0089  Rage 3D IIC
+		1028 4082  Rage 3D IIC
+		1028 8082  Rage 3D IIC
+		1028 c082  Rage 3D IIC
+	4758  210888GX [Mach64 GX]
+	4759  3D Rage IIC
+	475a  3D Rage IIC AGP
+		1002 0084  Rage 3D Pro AGP 2x XPERT 98
+		1002 0087  Rage 3D IIC
+		1002 475a  Rage IIC AGP
+	4964  Radeon RV250 Id [Radeon 9000]
+	4965  Radeon RV250 Ie [Radeon 9000]
+	4966  Radeon RV250 If [Radeon 9000]
+		10f1 0002  RV250 If [Tachyon G9000 PRO]
+		148c 2039  RV250 If [Radeon 9000 Pro "Evil Commando"]
+		1509 9a00  RV250 If [Radeon 9000 "AT009"]
+# New subdevice - 3D Prophet 9000 PCI by Hercules. AGP version probably would have same ID, so not specified.
+		1681 0040  RV250 If [3D prophet 9000]
+		174b 7176  RV250 If [Sapphire Radeon 9000 Pro]
+		174b 7192  RV250 If [Radeon 9000 "Atlantis"]
+		17af 2005  RV250 If [Excalibur Radeon 9000 Pro]
+		17af 2006  RV250 If [Excalibur Radeon 9000]
+	4967  Radeon RV250 Ig [Radeon 9000]
+	496e  Radeon RV250 [Radeon 9000] (Secondary)
+	4a48  R420 JH [Radeon X800]
+	4a49  R420 JI [Radeon X800PRO]
+	4a4a  R420 JJ [Radeon X800SE]
+	4a4b  R420 JK [Radeon X800]
+	4a4c  R420 JL [Radeon X800]
+	4a4d  R420 JM [FireGL X3]
+	4a4e  M18 JN [Radeon Mobility 9800]
+	4a50  R420 JP [Radeon X800XT]
+	4a70  R420 [X800XT-PE] (Secondary)
+	4c42  3D Rage LT Pro AGP-133
+		0e11 b0e7  Rage LT Pro (Compaq Presario 5240)
+		0e11 b0e8  Rage 3D LT Pro
+		0e11 b10e  3D Rage LT Pro (Compaq Armada 1750)
+		1002 0040  Rage LT Pro AGP 2X
+		1002 0044  Rage LT Pro AGP 2X
+		1002 4c42  Rage LT Pro AGP 2X
+		1002 8001  Rage LT Pro AGP 2X
+		1028 0085  Rage 3D LT Pro
+	4c44  3D Rage LT Pro AGP-66
+	4c45  Rage Mobility M3 AGP
+	4c46  Rage Mobility M3 AGP 2x
+		1028 00b1  Latitude C600
+	4c47  3D Rage LT-G 215LG
+	4c49  3D Rage LT Pro
+		1002 0004  Rage LT Pro
+		1002 0040  Rage LT Pro
+		1002 0044  Rage LT Pro
+		1002 4c49  Rage LT Pro
+	4c4d  Rage Mobility P/M AGP 2x
+		0e11 b111  Armada M700
+		0e11 b160  Armada E500
+		1002 0084  Xpert 98 AGP 2X (Mobility)
+		1014 0154  ThinkPad A20m
+		1028 00aa  Latitude CPt
+		1028 00bb  Latitude CPx
+	4c4e  Rage Mobility L AGP 2x
+	4c50  3D Rage LT Pro
+		1002 4c50  Rage LT Pro
+	4c51  3D Rage LT Pro
+	4c52  Rage Mobility P/M
+		1033 8112  Versa Note VXi
+	4c53  Rage Mobility L
+	4c54  264LT [Mach64 LT]
+	4c57  Radeon Mobility M7 LW [Radeon Mobility 7500]
+		1014 0517  ThinkPad T30
+		1028 00e6  Radeon Mobility M7 LW (Dell Inspiron 8100)
+		1028 012a  Latitude C640
+		144d c006  Radeon Mobility M7 LW in vpr Matrix 170B4
+	4c58  Radeon RV200 LX [Mobility FireGL 7800 M7]
+	4c59  Radeon Mobility M6 LY
+		1014 0235  ThinkPad A30/A30p (2652/2653)
+		1014 0239  ThinkPad X22/X23/X24
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+	4c5a  Radeon Mobility M6 LZ
+	4c64  Radeon R250 Ld [Radeon Mobility 9000 M9]
+	4c65  Radeon R250 Le [Radeon Mobility 9000 M9]
+	4c66  Radeon R250 Lf [FireGL 9000]
+	4c67  Radeon R250 Lg [Radeon Mobility 9000 M9]
+# Secondary chip to the Lf
+	4c6e  Radeon R250 Ln [Radeon Mobility 9000 M9] [Secondary]
+	4d46  Rage Mobility M4 AGP
+	4d4c  Rage Mobility M4 AGP
+	4e44  Radeon R300 ND [Radeon 9700 Pro]
+	4e45  Radeon R300 NE [Radeon 9500 Pro]
+		1002 0002  Radeon R300 NE [Radeon 9500 Pro]
+		1681 0002  Hercules 3D Prophet 9500 PRO [Radeon 9500 Pro]
+# New PCI ID provided by ATI developer relations (correction to above)
+	4e46  RV350 NF [Radeon 9600]
+	4e47  Radeon R300 NG [FireGL X1]
+# (added pro)
+	4e48  Radeon R350 [Radeon 9800 Pro]
+# New PCI ID provided by ATI developer relations
+	4e49  Radeon R350 [Radeon 9800]
+	4e4a  RV350 NJ [Radeon 9800 XT]
+	4e4b  R350 NK [Fire GL X2]
+# New PCI ID provided by ATI developer relations
+	4e50  RV350 [Mobility Radeon 9600 M10]
+		1025 005a  TravelMate 290
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1734 1055  Amilo M1420W
+	4e51  M10 NQ [Radeon Mobility 9600]
+	4e52  RV350 [Mobility Radeon 9600 M10]
+	4e53  M10 NS [Radeon Mobility 9600]
+	4e54  M10 NT [FireGL Mobility T2]
+	4e56  M11 NV [FireGL Mobility T2e]
+	4e64  Radeon R300 [Radeon 9700 Pro] (Secondary)
+	4e65  Radeon R300 [Radeon 9500 Pro] (Secondary)
+		1002 0003  Radeon R300 NE [Radeon 9500 Pro]
+		1681 0003  Hercules 3D Prophet 9500 PRO [Radeon 9500 Pro] (Secondary)
+# New PCI ID provided by ATI developer relations (correction to above)
+	4e66  RV350 NF [Radeon 9600] (Secondary)
+	4e67  Radeon R300 [FireGL X1] (Secondary)
+# (added pro)
+	4e68  Radeon R350 [Radeon 9800 Pro] (Secondary)
+# New PCI ID provided by ATI developer relations
+	4e69  Radeon R350 [Radeon 9800] (Secondary)
+	4e6a  RV350 NJ [Radeon 9800 XT] (Secondary)
+		1002 4e71  ATI Technologies Inc M10 NQ [Radeon Mobility 9600]
+	5041  Rage 128 PA/PRO
+	5042  Rage 128 PB/PRO AGP 2x
+	5043  Rage 128 PC/PRO AGP 4x
+	5044  Rage 128 PD/PRO TMDS
+		1002 0028  Rage 128 AIW
+		1002 0029  Rage 128 AIW
+	5045  Rage 128 PE/PRO AGP 2x TMDS
+	5046  Rage 128 PF/PRO AGP 4x TMDS
+		1002 0004  Rage Fury Pro
+		1002 0008  Rage Fury Pro/Xpert 2000 Pro
+		1002 0014  Rage Fury Pro
+		1002 0018  Rage Fury Pro/Xpert 2000 Pro
+		1002 0028  Rage 128 Pro AIW AGP
+		1002 002a  Rage 128 Pro AIW AGP
+		1002 0048  Rage Fury Pro
+		1002 2000  Rage Fury MAXX AGP 4x (TMDS) (VGA device)
+		1002 2001  Rage Fury MAXX AGP 4x (TMDS) (Extra device?!)
+	5047  Rage 128 PG/PRO
+	5048  Rage 128 PH/PRO AGP 2x
+	5049  Rage 128 PI/PRO AGP 4x
+	504a  Rage 128 PJ/PRO TMDS
+	504b  Rage 128 PK/PRO AGP 2x TMDS
+	504c  Rage 128 PL/PRO AGP 4x TMDS
+	504d  Rage 128 PM/PRO
+	504e  Rage 128 PN/PRO AGP 2x
+	504f  Rage 128 PO/PRO AGP 4x
+	5050  Rage 128 PP/PRO TMDS [Xpert 128]
+		1002 0008  Xpert 128
+	5051  Rage 128 PQ/PRO AGP 2x TMDS
+	5052  Rage 128 PR/PRO AGP 4x TMDS
+	5053  Rage 128 PS/PRO
+	5054  Rage 128 PT/PRO AGP 2x
+	5055  Rage 128 PU/PRO AGP 4x
+	5056  Rage 128 PV/PRO TMDS
+	5057  Rage 128 PW/PRO AGP 2x TMDS
+	5058  Rage 128 PX/PRO AGP 4x TMDS
+	5144  Radeon R100 QD [Radeon 7200]
+		1002 0008  Radeon 7000/Radeon VE
+		1002 0009  Radeon 7000/Radeon
+		1002 000a  Radeon 7000/Radeon
+		1002 001a  Radeon 7000/Radeon
+		1002 0029  Radeon AIW
+		1002 0038  Radeon 7000/Radeon
+		1002 0039  Radeon 7000/Radeon
+		1002 008a  Radeon 7000/Radeon
+		1002 00ba  Radeon 7000/Radeon
+		1002 0139  Radeon 7000/Radeon
+		1002 028a  Radeon 7000/Radeon
+		1002 02aa  Radeon AIW
+		1002 053a  Radeon 7000/Radeon
+	5145  Radeon R100 QE
+	5146  Radeon R100 QF
+	5147  Radeon R100 QG
+	5148  Radeon R200 QH [Radeon 8500]
+		1002 010a  FireGL 8800 64Mb
+		1002 0152  FireGL 8800 128Mb
+		1002 0162  FireGL 8700 32Mb
+		1002 0172  FireGL 8700 64Mb
+	5149  Radeon R200 QI
+	514a  Radeon R200 QJ
+	514b  Radeon R200 QK
+	514c  Radeon R200 QL [Radeon 8500 LE]
+		1002 003a  Radeon R200 QL [Radeon 8500 LE]
+		1002 013a  Radeon 8500
+		148c 2026  R200 QL [Radeon 8500 Evil Master II Multi Display Edition]
+		1681 0010  Radeon 8500 [3D Prophet 8500 128Mb]
+		174b 7149  Radeon R200 QL [Sapphire Radeon 8500 LE]
+	514d  Radeon R200 QM [Radeon 9100]
+	514e  Radeon R200 QN [Radeon 8500LE]
+	514f  Radeon R200 QO [Radeon 8500LE]
+	5154  R200 QT [Radeon 8500]
+	5155  R200 QU [Radeon 9100]
+	5157  Radeon RV200 QW [Radeon 7500]
+		1002 013a  Radeon 7500
+		1002 103a  Dell Optiplex GX260
+		1458 4000  RV200 QW [RADEON 7500 PRO MAYA AR]
+		148c 2024  RV200 QW [Radeon 7500LE Dual Display]
+		148c 2025  RV200 QW [Radeon 7500 Evil Master Multi Display Edition]
+		148c 2036  RV200 QW [Radeon 7500 PCI Dual Display]
+		174b 7146  RV200 QW [Radeon 7500 LE]
+		174b 7147  RV200 QW [Sapphire Radeon 7500LE]
+		174b 7161  Radeon RV200 QW [Radeon 7500 LE]
+		17af 0202  RV200 QW [Excalibur Radeon 7500LE]
+	5158  Radeon RV200 QX [Radeon 7500]
+	5159  Radeon RV100 QY [Radeon 7000/VE]
+		1002 000a  Radeon 7000/Radeon VE
+		1002 000b  Radeon 7000
+		1002 0038  Radeon 7000/Radeon VE
+		1002 003a  Radeon 7000/Radeon VE
+		1002 00ba  Radeon 7000/Radeon VE
+		1002 013a  Radeon 7000/Radeon VE
+		1458 4002  RV100 QY [RADEON 7000 PRO MAYA AV Series]
+		148c 2003  RV100 QY [Radeon 7000 Multi-Display Edition]
+		148c 2023  RV100 QY [Radeon 7000 Evil Master Multi-Display]
+		174b 7112  RV100 QY [Sapphire Radeon VE 7000]
+		174b 7c28  Sapphire Radeon VE 7000 DDR
+		1787 0202  RV100 QY [Excalibur Radeon 7000]
+	515a  Radeon RV100 QZ [Radeon 7000/VE]
+	5168  Radeon R200 Qh
+	5169  Radeon R200 Qi
+	516a  Radeon R200 Qj
+	516b  Radeon R200 Qk
+# This one is not in ATI documentation, but is in XFree86 source code
+	516c  Radeon R200 Ql
+	5245  Rage 128 RE/SG
+		1002 0008  Xpert 128
+		1002 0028  Rage 128 AIW
+		1002 0029  Rage 128 AIW
+		1002 0068  Rage 128 AIW
+	5246  Rage 128 RF/SG AGP
+		1002 0004  Magnum/Xpert 128/Xpert 99
+		1002 0008  Magnum/Xpert128/X99/Xpert2000
+		1002 0028  Rage 128 AIW AGP
+		1002 0044  Rage Fury/Xpert 128/Xpert 2000
+		1002 0068  Rage 128 AIW AGP
+		1002 0448  Rage Fury
+	5247  Rage 128 RG
+	524b  Rage 128 RK/VR
+	524c  Rage 128 RL/VR AGP
+		1002 0008  Xpert 99/Xpert 2000
+		1002 0088  Xpert 99
+	5345  Rage 128 SE/4x
+	5346  Rage 128 SF/4x AGP 2x
+		1002 0048  RAGE 128 16MB VGA TVOUT AMC PAL
+	5347  Rage 128 SG/4x AGP 4x
+	5348  Rage 128 SH
+	534b  Rage 128 SK/4x
+	534c  Rage 128 SL/4x AGP 2x
+	534d  Rage 128 SM/4x AGP 4x
+		1002 0008  Xpert 99/Xpert 2000
+		1002 0018  Xpert 2000
+	534e  Rage 128 4x
+	5354  Mach 64 VT
+		1002 5654  Mach 64 reference
+	5446  Rage 128 Pro Ultra TF
+		1002 0004  Rage Fury Pro
+		1002 0008  Rage Fury Pro/Xpert 2000 Pro
+		1002 0018  Rage Fury Pro/Xpert 2000 Pro
+		1002 0028  Rage 128 AIW Pro AGP
+		1002 0029  Rage 128 AIW
+		1002 002a  Rage 128 AIW Pro AGP
+		1002 002b  Rage 128 AIW
+		1002 0048  Xpert 2000 Pro
+	544c  Rage 128 Pro Ultra TL
+	5452  Rage 128 Pro Ultra TR
+		1002 001c  Rage 128 Pro 4XL
+		103c 1279  Rage 128 Pro 4XL
+	5453  Rage 128 Pro Ultra TS
+	5454  Rage 128 Pro Ultra TT
+	5455  Rage 128 Pro Ultra TU
+	5460  M22 [Radeon Mobility M300]
+	5464  M22 [FireGL GL]
+	5548  R423 UH [Radeon X800 (PCIE)]
+	5549  R423 UI [Radeon X800PRO (PCIE)]
+	554a  R423 UJ [Radeon X800LE (PCIE)]
+	554b  R423 UK [Radeon X800SE (PCIE)]
+	5551  R423 UQ [FireGL V7200 (PCIE)]
+	5552  R423 UR [FireGL V5100 (PCIE)]
+	5554  R423 UT [FireGL V7100 (PCIE)]
+	556b  Radeon R423 UK (PCIE) [X800 SE] (Secondary)
+	5654  264VT [Mach64 VT]
+		1002 5654  Mach64VT Reference
+	5655  264VT3 [Mach64 VT3]
+	5656  264VT4 [Mach64 VT4]
+	5830  RS300 Host Bridge
+	5831  RS300 Host Bridge
+	5832  RS300 Host Bridge
+	5833  Radeon 9100 IGP Host Bridge
+	5834  Radeon 9100 IGP
+	5835  RS300M AGP [Radeon Mobility 9100IGP]
+	5838  Radeon 9100 IGP AGP Bridge
+	5941  RV280 [Radeon 9200] (Secondary)
+		1458 4019  Gigabyte Radeon 9200
+		174b 7c12  Sapphire Radeon 9200
+# http://www.hightech.com.hk/html/9200.htm
+		17af 200d  Excalibur Radeon 9200
+		18bc 0050  GeXcube GC-R9200-C3 (Secondary)
+	5944  RV280 [Radeon 9200 SE (PCI)]
+	5960  RV280 [Radeon 9200 PRO]
+	5961  RV280 [Radeon 9200]
+		1002 2f72  All-in-Wonder 9200 Series
+		1019 4c30  Radeon 9200 VIVO
+		12ab 5961  YUAN SMARTVGA Radeon 9200
+		1458 4018  Gigabyte Radeon 9200
+		174b 7c13  Sapphire Radeon 9200
+# http://www.hightech.com.hk/html/9200.htm
+		17af 200c  Excalibur Radeon 9200
+		18bc 0050  Radeon 9200 Game Buster
+		18bc 0051  GeXcube GC-R9200-C3
+		18bc 0053  Radeon 9200 Game Buster VIVO
+	5962  RV280 [Radeon 9200]
+	5964  RV280 [Radeon 9200 SE]
+		1043 c006  ASUS Radeon 9200 SE / TD / 128M
+		1458 4018  Radeon 9200 SE
+		148c 2073  CN-AG92E
+		174b 7c13  Sapphire Radeon 9200 SE
+		1787 5964  Excalibur 9200SE VIVO 128M
+		17af 2012  Radeon 9200 SE Excalibur
+		18bc 0170  Sapphire Radeon 9200 SE 128MB Game Buster
+# 128MB DDR, DVI/VGA/TV out
+		18bc 0173  GC-R9200L(SE)-C3H [Radeon 9200 Game Buster]
+	5b60  RV370 5B60 [Radeon X300 (PCIE)]
+		1043 002a  Extreme AX300SE-X
+		1043 032e  Extreme AX300/TD
+	5b62  RV370 5B62 [Radeon X600 (PCIE)]
+	5b64  RV370 5B64 [FireGL V3100 (PCIE)]
+	5b65  RV370 5B65 [FireGL D1100 (PCIE)]
+	5c61  M9+ 5C61 [Radeon Mobility 9200 (AGP)]
+	5c63  M9+ 5C63 [Radeon Mobility 9200 (AGP)]
+	5d44  RV280 [Radeon 9200 SE] (Secondary)
+		1458 4019  Radeon 9200 SE (Secondary)
+		174b 7c12  Sapphire Radeon 9200 SE (Secondary)
+		1787 5965  Excalibur 9200SE VIVO 128M (Secondary)
+		17af 2013  Radeon 9200 SE Excalibur (Secondary)
+		18bc 0171  Radeon 9200 SE 128MB Game Buster (Secondary)
+		18bc 0172  GC-R9200L(SE)-C3H [Radeon 9200 Game Buster]
+	5d4d  R480 [Radeon X850XT Platinum]
+	5d57  R423 5F57 [Radeon X800XT (PCIE)]
+	700f  PCI Bridge [IGP 320M]
+	7010  PCI Bridge [IGP 340M]
+	7834  Radeon 9100 PRO IGP
+	7835  Radeon Mobility 9200 IGP
+	7c37  RV350 AQ [Radeon 9600 SE]
+	cab0  AGP Bridge [IGP 320M]
+	cab2  RS200/RS200M AGP Bridge [IGP 340M]
+	cbb2  RS200/RS200M AGP Bridge [IGP 340M]
+1003  ULSI Systems
+	0201  US201
+1004  VLSI Technology Inc
+	0005  82C592-FC1
+	0006  82C593-FC1
+	0007  82C594-AFC2
+	0008  82C596/7 [Wildcat]
+	0009  82C597-AFC2
+	000c  82C541 [Lynx]
+	000d  82C543 [Lynx]
+	0101  82C532
+	0102  82C534 [Eagle]
+	0103  82C538
+	0104  82C535
+	0105  82C147
+	0200  82C975
+	0280  82C925
+	0304  QSound ThunderBird PCI Audio
+		1004 0304  QSound ThunderBird PCI Audio
+		122d 1206  DSP368 Audio
+		1483 5020  XWave Thunder 3D Audio
+	0305  QSound ThunderBird PCI Audio Gameport
+		1004 0305  QSound ThunderBird PCI Audio Gameport
+		122d 1207  DSP368 Audio Gameport
+		1483 5021  XWave Thunder 3D Audio Gameport
+	0306  QSound ThunderBird PCI Audio Support Registers
+		1004 0306  QSound ThunderBird PCI Audio Support Registers
+		122d 1208  DSP368 Audio Support Registers
+		1483 5022  XWave Thunder 3D Audio Support Registers
+	0307  Thunderbird
+	0308  Thunderbird
+	0702  VAS96011 [Golden Gate II]
+	0703  Tollgate
+1005  Avance Logic Inc. [ALI]
+	2064  ALG2032/2064
+	2128  ALG2364A
+	2301  ALG2301
+	2302  ALG2302
+	2364  ALG2364
+	2464  ALG2364A
+	2501  ALG2564A/25128A
+1006  Reply Group
+1007  NetFrame Systems Inc
+1008  Epson
+100a  Phoenix Technologies
+100b  National Semiconductor Corporation
+	0001  DP83810
+	0002  87415/87560 IDE
+	000e  87560 Legacy I/O
+	000f  FireWire Controller
+	0011  NS87560 National PCI System I/O
+	0012  USB Controller
+	0020  DP83815 (MacPhyter) Ethernet Controller
+		103c 0024  Pavilion ze4400 builtin Network
+		1385 f311  FA311 / FA312 (FA311 with WoL HW)
+	0022  DP83820 10/100/1000 Ethernet Controller
+	0028  Geode GX2 Host Bridge
+	002a  CS5535 South Bridge
+	002b  CS5535 ISA bridge
+	002d  CS5535 IDE
+	002e  CS5535 Audio
+	002f  CS5535 USB
+	0030  Geode GX2 Graphics Processor
+	0035  DP83065 [Saturn] 10/100/1000 Ethernet Controller
+	0500  SCx200 Bridge
+	0501  SCx200 SMI
+	0502  SCx200 IDE
+	0503  SCx200 Audio
+	0504  SCx200 Video
+	0505  SCx200 XBus
+	0510  SC1100 Bridge
+	0511  SC1100 SMI
+	0515  SC1100 XBus
+	d001  87410 IDE
+100c  Tseng Labs Inc
+	3202  ET4000/W32p rev A
+	3205  ET4000/W32p rev B
+	3206  ET4000/W32p rev C
+	3207  ET4000/W32p rev D
+	3208  ET6000
+	4702  ET6300
+100d  AST Research Inc
+100e  Weitek
+	9000  P9000 Viper
+	9001  P9000 Viper
+	9002  P9000 Viper
+	9100  P9100 Viper Pro/SE
+1010  Video Logic, Ltd.
+1011  Digital Equipment Corporation
+	0001  DECchip 21050
+	0002  DECchip 21040 [Tulip]
+	0004  DECchip 21030 [TGA]
+	0007  NVRAM [Zephyr NVRAM]
+	0008  KZPSA [KZPSA]
+	0009  DECchip 21140 [FasterNet]
+		1025 0310  21140 Fast Ethernet
+		10b8 2001  SMC9332BDT EtherPower 10/100
+		10b8 2002  SMC9332BVT EtherPower T4 10/100
+		10b8 2003  SMC9334BDT EtherPower 10/100 (1-port)
+		1109 2400  ANA-6944A/TX Fast Ethernet
+		1112 2300  RNS2300 Fast Ethernet
+		1112 2320  RNS2320 Fast Ethernet
+		1112 2340  RNS2340 Fast Ethernet
+		1113 1207  EN-1207-TX Fast Ethernet
+		1186 1100  DFE-500TX Fast Ethernet
+		1186 1112  DFE-570TX Fast Ethernet
+		1186 1140  DFE-660 Cardbus Ethernet 10/100
+		1186 1142  DFE-660 Cardbus Ethernet 10/100
+		11f6 0503  Freedomline Fast Ethernet
+		1282 9100  AEF-380TXD Fast Ethernet
+		1385 1100  FA310TX Fast Ethernet
+		2646 0001  KNE100TX Fast Ethernet
+	000a  21230 Video Codec
+	000d  PBXGB [TGA2]
+	000f  DEFPA
+	0014  DECchip 21041 [Tulip Pass 3]
+		1186 0100  DE-530+
+	0016  DGLPB [OPPO]
+	0017  PV-PCI Graphics Controller (ZLXp-L)
+	0019  DECchip 21142/43
+		1011 500a  DE500A Fast Ethernet
+		1011 500b  DE500B Fast Ethernet
+		1014 0001  10/100 EtherJet Cardbus
+		1025 0315  ALN315 Fast Ethernet
+		1033 800c  PC-9821-CS01 100BASE-TX Interface Card
+		1033 800d  PC-9821NR-B06 100BASE-TX Interface Card
+		108d 0016  Rapidfire 2327 10/100 Ethernet
+		108d 0017  GoCard 2250 Ethernet 10/100 Cardbus
+		10b8 2005  SMC8032DT Extreme Ethernet 10/100
+		10b8 8034  SMC8034 Extreme Ethernet 10/100
+		10ef 8169  Cardbus Fast Ethernet
+		1109 2a00  ANA-6911A/TX Fast Ethernet
+		1109 2b00  ANA-6911A/TXC Fast Ethernet
+		1109 3000  ANA-6922/TX Fast Ethernet
+		1113 1207  Cheetah Fast Ethernet
+		1113 2220  Cardbus Fast Ethernet
+		115d 0002  Cardbus Ethernet 10/100
+		1179 0203  Fast Ethernet
+		1179 0204  Cardbus Fast Ethernet
+		1186 1100  DFE-500TX Fast Ethernet
+		1186 1101  DFE-500TX Fast Ethernet
+		1186 1102  DFE-500TX Fast Ethernet
+		1186 1112  DFE-570TX Quad Fast Ethernet
+		1259 2800  AT-2800Tx Fast Ethernet
+		1266 0004  Eagle Fast EtherMAX
+		12af 0019  NetFlyer Cardbus Fast Ethernet
+		1374 0001  Cardbus Ethernet Card 10/100
+		1374 0002  Cardbus Ethernet Card 10/100
+		1374 0007  Cardbus Ethernet Card 10/100
+		1374 0008  Cardbus Ethernet Card 10/100
+		1385 2100  FA510
+		1395 0001  10/100 Ethernet CardBus PC Card
+		13d1 ab01  EtherFast 10/100 Cardbus (PCMPC200)
+		14cb 0100  LNDL-100N 100Base-TX Ethernet PC Card
+		8086 0001  EtherExpress PRO/100 Mobile CardBus 32
+	001a  Farallon PN9000SX Gigabit Ethernet
+	0021  DECchip 21052
+	0022  DECchip 21150
+	0023  DECchip 21150
+	0024  DECchip 21152
+	0025  DECchip 21153
+	0026  DECchip 21154
+	0034  56k Modem Cardbus
+		1374 0003  56k Modem Cardbus
+	0045  DECchip 21553
+	0046  DECchip 21554
+		0e11 4050  Integrated Smart Array
+		0e11 4051  Integrated Smart Array
+		0e11 4058  Integrated Smart Array
+		103c 10c2  Hewlett-Packard NetRAID-4M
+		12d9 000a  IP Telephony card
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+		9005 0364  5400S (Mustang)
+		9005 0365  5400S (Mustang)
+		9005 1364  Dell PowerEdge RAID Controller 2
+		9005 1365  Dell PowerEdge RAID Controller 2
+		e4bf 1000  CC8-1-BLUES
+	1065  StrongARM DC21285
+		1069 0020  DAC960P / DAC1164P
+1012  Micronics Computers Inc
+1013  Cirrus Logic
+	0038  GD 7548
+	0040  GD 7555 Flat Panel GUI Accelerator
+	004c  GD 7556 Video/Graphics LCD/CRT Ctrlr
+	00a0  GD 5430/40 [Alpine]
+	00a2  GD 5432 [Alpine]
+	00a4  GD 5434-4 [Alpine]
+	00a8  GD 5434-8 [Alpine]
+	00ac  GD 5436 [Alpine]
+	00b0  GD 5440
+	00b8  GD 5446
+	00bc  GD 5480
+		1013 00bc  CL-GD5480
+	00d0  GD 5462
+	00d2  GD 5462 [Laguna I]
+	00d4  GD 5464 [Laguna]
+	00d5  GD 5464 BD [Laguna]
+	00d6  GD 5465 [Laguna]
+		13ce 8031  Barco Metheus 2 Megapixel, Dual Head
+		13cf 8031  Barco Metheus 2 Megapixel, Dual Head
+	00e8  GD 5436U
+	1100  CL 6729
+	1110  PD 6832 PCMCIA/CardBus Ctrlr
+	1112  PD 6834 PCMCIA/CardBus Ctrlr
+	1113  PD 6833 PCMCIA/CardBus Ctrlr
+	1200  GD 7542 [Nordic]
+	1202  GD 7543 [Viking]
+	1204  GD 7541 [Nordic Light]
+	4000  MD 5620 [CLM Data Fax Voice]
+	4400  CD 4400
+	6001  CS 4610/11 [CrystalClear SoundFusion Audio Accelerator]
+		1014 1010  CS4610 SoundFusion Audio Accelerator
+	6003  CS 4614/22/24 [CrystalClear SoundFusion Audio Accelerator]
+		1013 4280  Crystal SoundFusion PCI Audio Accelerator
+		153b 1136  SiXPack 5.1+
+		1681 0050  Game Theater XP
+		1681 a011  Fortissimo III 7.1
+	6004  CS 4614/22/24 [CrystalClear SoundFusion Audio Accelerator]
+	6005  Crystal CS4281 PCI Audio
+		1013 4281  Crystal CS4281 PCI Audio
+		10cf 10a8  Crystal CS4281 PCI Audio
+		10cf 10a9  Crystal CS4281 PCI Audio
+		10cf 10aa  Crystal CS4281 PCI Audio
+		10cf 10ab  Crystal CS4281 PCI Audio
+		10cf 10ac  Crystal CS4281 PCI Audio
+		10cf 10ad  Crystal CS4281 PCI Audio
+		10cf 10b4  Crystal CS4281 PCI Audio
+		1179 0001  Crystal CS4281 PCI Audio
+		14c0 000c  Crystal CS4281 PCI Audio
+1014  IBM
+	0002  PCI to MCA Bridge
+	0005  Alta Lite
+	0007  Alta MP
+	000a  Fire Coral
+	0017  CPU to PCI Bridge
+	0018  TR Auto LANstreamer
+	001b  GXT-150P
+	001c  Carrera
+	001d  82G2675
+	0020  GXT1000 Graphics Adapter
+	0022  IBM27-82351
+	002d  Python
+# [official name in AIX 5]
+	002e  SCSI RAID Adapter [ServeRAID]
+		1014 002e  ServeRAID-3x
+		1014 022e  ServeRAID-4H
+	0031  2 Port Serial Adapter
+# AS400 iSeries PCI sync serial card
+		1014 0031  2721 WAN IOA - 2 Port Sync Serial Adapter
+	0036  Miami
+	0037  82660 CPU to PCI Bridge
+	003a  CPU to PCI Bridge
+	003c  GXT250P/GXT255P Graphics Adapter
+	003e  16/4 Token ring UTP/STP controller
+		1014 003e  Token-Ring Adapter
+		1014 00cd  Token-Ring Adapter + Wake-On-LAN
+		1014 00ce  16/4 Token-Ring Adapter 2
+		1014 00cf  16/4 Token-Ring Adapter Special
+		1014 00e4  High-Speed 100/16/4 Token-Ring Adapter
+		1014 00e5  16/4 Token-Ring Adapter 2 + Wake-On-LAN
+		1014 016d  iSeries 2744 Card
+	0045  SSA Adapter
+	0046  MPIC interrupt controller
+	0047  PCI to PCI Bridge
+	0048  PCI to PCI Bridge
+	0049  Warhead SCSI Controller
+	004e  ATM Controller (14104e00)
+	004f  ATM Controller (14104f00)
+	0050  ATM Controller (14105000)
+	0053  25 MBit ATM Controller
+	0054  GXT500P/GXT550P Graphics Adapter
+	0057  MPEG PCI Bridge
+	005c  i82557B 10/100
+	005e  GXT800P Graphics Adapter
+	007c  ATM Controller (14107c00)
+	007d  3780IDSP [MWave]
+	008b  EADS PCI to PCI Bridge
+	008e  GXT3000P Graphics Adapter
+	0090  GXT 3000P
+		1014 008e  GXT-3000P
+	0091  SSA Adapter
+	0095  20H2999 PCI Docking Bridge
+	0096  Chukar chipset SCSI controller
+		1014 0097  iSeries 2778 DASD IOA
+		1014 0098  iSeries 2763 DASD IOA
+		1014 0099  iSeries 2748 DASD IOA
+	009f  PCI 4758 Cryptographic Accelerator
+	00a5  ATM Controller (1410a500)
+	00a6  ATM 155MBPS MM Controller (1410a600)
+	00b7  256-bit Graphics Rasterizer [Fire GL1]
+		1092 00b8  FireGL1 AGP 32Mb
+	00b8  GXT2000P Graphics Adapter
+	00be  ATM 622MBPS Controller (1410be00)
+	00dc  Advanced Systems Management Adapter (ASMA)
+	00fc  CPC710 Dual Bridge and Memory Controller (PCI-64)
+	0104  Gigabit Ethernet-SX Adapter
+	0105  CPC710 Dual Bridge and Memory Controller (PCI-32)
+	010f  Remote Supervisor Adapter (RSA)
+	0142  Yotta Video Compositor Input
+		1014 0143  Yotta Input Controller (ytin)
+	0144  Yotta Video Compositor Output
+		1014 0145  Yotta Output Controller (ytout)
+	0156  405GP PLB to PCI Bridge
+	015e  622Mbps ATM PCI Adapter
+	0160  64bit/66MHz PCI ATM 155 MMF
+	016e  GXT4000P Graphics Adapter
+	0170  GXT6000P Graphics Adapter
+	017d  GXT300P Graphics Adapter
+	0180  Snipe chipset SCSI controller
+		1014 0241  iSeries 2757 DASD IOA
+		1014 0264  Quad Channel PCI-X U320 SCSI RAID Adapter (2780)
+	0188  EADS-X PCI-X to PCI-X Bridge
+	01a7  PCI-X to PCI-X Bridge
+	01bd  ServeRAID Controller
+		1014 01be  ServeRAID-4M
+		1014 01bf  ServeRAID-4L
+		1014 0208  ServeRAID-4Mx
+		1014 020e  ServeRAID-4Lx
+		1014 022e  ServeRAID-4H
+		1014 0258  ServeRAID-5i
+		1014 0259  ServeRAID-5i
+	01c1  64bit/66MHz PCI ATM 155 UTP
+	01e6  Cryptographic Accelerator
+	01ff  10/100 Mbps Ethernet
+	0219  Multiport Serial Adapter
+		1014 021a  Dual RVX
+		1014 0251  Internal Modem/RVX
+		1014 0252  Quad Internal Modem
+	021b  GXT6500P Graphics Adapter
+	021c  GXT4500P Graphics Adapter
+	0233  GXT135P Graphics Adapter
+	0266  PCI-X Dual Channel SCSI
+	0268  Gigabit Ethernet-SX Adapter (PCI-X)
+	0269  10/100/1000 Base-TX Ethernet Adapter (PCI-X)
+	028c  Citrine chipset SCSI controller
+		1014 028D  Dual Channel PCI-X DDR SAS RAID Adapter (572E)
+		1014 02BE  Dual Channel PCI-X DDR U320 SCSI RAID Adapter (571B)
+		1014 02C0  Dual Channel PCI-X DDR U320 SCSI Adapter (571A)
+	0302  X-Architecture Bridge [Summit]
+	0314  ZISC 036 Neural accelerator card
+	ffff  MPIC-2 interrupt controller
+1015  LSI Logic Corp of Canada
+1016  ICL Personal Systems
+1017  SPEA Software AG
+	5343  SPEA 3D Accelerator
+1018  Unisys Systems
+1019  Elitegroup Computer Systems
+101a  AT&T GIS (NCR)
+	0005  100VG ethernet
+101b  Vitesse Semiconductor
+101c  Western Digital
+	0193  33C193A
+	0196  33C196A
+	0197  33C197A
+	0296  33C296A
+	3193  7193
+	3197  7197
+	3296  33C296A
+	4296  34C296
+	9710  Pipeline 9710
+	9712  Pipeline 9712
+	c24a  90C
+101e  American Megatrends Inc.
+	1960  MegaRAID
+		101e 0471  MegaRAID 471 Enterprise 1600 RAID Controller
+		101e 0475  MegaRAID 475 Express 500/500LC RAID Controller
+		101e 0477  MegaRAID 477 Elite 3100 RAID Controller
+		101e 0493  MegaRAID 493 Elite 1600 RAID Controller
+		101e 0494  MegaRAID 494 Elite 1650 RAID Controller
+		101e 0503  MegaRAID 503 Enterprise 1650 RAID Controller
+		101e 0511  MegaRAID 511 i4 IDE RAID Controller
+		101e 0522  MegaRAID 522 i4133 RAID Controller
+		1028 0471  PowerEdge RAID Controller 3/QC
+		1028 0475  PowerEdge RAID Controller 3/SC
+		1028 0493  PowerEdge RAID Controller 3/DC
+		1028 0511  PowerEdge Cost Effective RAID Controller ATA100/4Ch
+	9010  MegaRAID 428 Ultra RAID Controller
+	9030  EIDE Controller
+	9031  EIDE Controller
+	9032  EIDE & SCSI Controller
+	9033  SCSI Controller
+	9040  Multimedia card
+	9060  MegaRAID 434 Ultra GT RAID Controller
+	9063  MegaRAC
+		101e 0767  Dell Remote Assistant Card 2
+101f  PictureTel
+1020  Hitachi Computer Products
+1021  OKI Electric Industry Co. Ltd.
+1022  Advanced Micro Devices [AMD]
+	1100  K8 [Athlon64/Opteron] HyperTransport Technology Configuration
+	1101  K8 [Athlon64/Opteron] Address Map
+	1102  K8 [Athlon64/Opteron] DRAM Controller
+	1103  K8 [Athlon64/Opteron] Miscellaneous Control
+	2000  79c970 [PCnet32 LANCE]
+		1014 2000  NetFinity 10/100 Fast Ethernet
+		1022 2000  PCnet - Fast 79C971
+		103c 104c  Ethernet with LAN remote power Adapter
+		103c 1064  Ethernet with LAN remote power Adapter
+		103c 1065  Ethernet with LAN remote power Adapter
+		103c 106c  Ethernet with LAN remote power Adapter
+		103c 106e  Ethernet with LAN remote power Adapter
+		103c 10ea  Ethernet with LAN remote power Adapter
+		1113 1220  EN1220 10/100 Fast Ethernet
+		1259 2450  AT-2450 10/100 Fast Ethernet
+		1259 2454  AT-2450v4 10Mb Ethernet Adapter
+		1259 2700  AT-2700TX 10/100 Fast Ethernet
+		1259 2701  AT-2700FX 100Mb Ethernet
+		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
+		4c53 1010  CP5/CR6 mainboard
+		4c53 1020  VR6 mainboard
+		4c53 1030  PC5 mainboard
+		4c53 1040  CL7 mainboard
+		4c53 1060  PC7 mainboard
+	2001  79c978 [HomePNA]
+		1092 0a78  Multimedia Home Network Adapter
+		1668 0299  ActionLink Home Network Adapter
+	2003  Am 1771 MBW [Alchemy]
+	2020  53c974 [PCscsi]
+	2040  79c974
+	3000  ELanSC520 Microcontroller
+	7006  AMD-751 [Irongate] System Controller
+	7007  AMD-751 [Irongate] AGP Bridge
+	700a  AMD-IGR4 AGP Host to PCI Bridge
+	700b  AMD-IGR4 PCI to PCI Bridge
+	700c  AMD-760 MP [IGD4-2P] System Controller
+	700d  AMD-760 MP [IGD4-2P] AGP Bridge
+	700e  AMD-760 [IGD4-1P] System Controller
+	700f  AMD-760 [IGD4-1P] AGP Bridge
+	7400  AMD-755 [Cobra] ISA
+	7401  AMD-755 [Cobra] IDE
+	7403  AMD-755 [Cobra] ACPI
+	7404  AMD-755 [Cobra] USB
+	7408  AMD-756 [Viper] ISA
+	7409  AMD-756 [Viper] IDE
+	740b  AMD-756 [Viper] ACPI
+	740c  AMD-756 [Viper] USB
+	7410  AMD-766 [ViperPlus] ISA
+	7411  AMD-766 [ViperPlus] IDE
+	7413  AMD-766 [ViperPlus] ACPI
+	7414  AMD-766 [ViperPlus] USB
+	7440  AMD-768 [Opus] ISA
+		1043 8044  A7M-D Mainboard
+	7441  AMD-768 [Opus] IDE
+	7443  AMD-768 [Opus] ACPI
+		1043 8044  A7M-D Mainboard
+	7445  AMD-768 [Opus] Audio
+	7446  AMD-768 [Opus] MC97 Modem (Smart Link HAMR5600 compatible)
+	7448  AMD-768 [Opus] PCI
+	7449  AMD-768 [Opus] USB
+	7450  AMD-8131 PCI-X Bridge
+	7451  AMD-8131 PCI-X APIC
+	7454  AMD-8151 System Controller
+	7455  AMD-8151 AGP Bridge
+	7460  AMD-8111 PCI
+		161f 3017  HDAMB
+	7461  AMD-8111 USB
+	7462  AMD-8111 Ethernet
+	7464  AMD-8111 USB
+		161f 3017  HDAMB
+	7468  AMD-8111 LPC
+		161f 3017  HDAMB
+	7469  AMD-8111 IDE
+		161f 3017  HDAMB
+	746a  AMD-8111 SMBus 2.0
+	746b  AMD-8111 ACPI
+		161f 3017  HDAMB
+	746d  AMD-8111 AC97 Audio
+		161f 3017  HDAMB
+	746e  AMD-8111 MC97 Modem
+	756b  AMD-8111 ACPI
+1023  Trident Microsystems
+	0194  82C194
+	2000  4DWave DX
+	2001  4DWave NX
+		122d 1400  Trident PCI288-Q3DII (NX)
+	2100  CyberBlade XP4m32
+	2200  XGI Volari XP5
+	8400  CyberBlade/i7
+		1023 8400  CyberBlade i7 AGP
+	8420  CyberBlade/i7d
+		0e11 b15a  CyberBlade i7 AGP
+	8500  CyberBlade/i1
+	8520  CyberBlade i1
+		0e11 b16e  CyberBlade i1 AGP
+		1023 8520  CyberBlade i1 AGP
+	8620  CyberBlade/i1
+		1014 0502  ThinkPad R30/T30
+	8820  CyberBlade XPAi1
+	9320  TGUI 9320
+	9350  GUI Accelerator
+	9360  Flat panel GUI Accelerator
+	9382  Cyber 9382 [Reference design]
+	9383  Cyber 9383 [Reference design]
+	9385  Cyber 9385 [Reference design]
+	9386  Cyber 9386
+	9388  Cyber 9388
+	9397  Cyber 9397
+	939a  Cyber 9397DVD
+	9420  TGUI 9420
+	9430  TGUI 9430
+	9440  TGUI 9440
+	9460  TGUI 9460
+	9470  TGUI 9470
+	9520  Cyber 9520
+	9525  Cyber 9525
+		10cf 1094  Lifebook C6155
+	9540  Cyber 9540
+	9660  TGUI 9660/938x/968x
+	9680  TGUI 9680
+	9682  TGUI 9682
+	9683  TGUI 9683
+	9685  ProVIDIA 9685
+	9750  3DImage 9750
+		1014 9750  3DImage 9750
+		1023 9750  3DImage 9750
+	9753  TGUI 9753
+	9754  TGUI 9754
+	9759  TGUI 975
+	9783  TGUI 9783
+	9785  TGUI 9785
+	9850  3DImage 9850
+	9880  Blade 3D PCI/AGP
+		1023 9880  Blade 3D
+	9910  CyberBlade/XP
+	9930  CyberBlade/XPm
+1024  Zenith Data Systems
+1025  Acer Incorporated [ALI]
+	1435  M1435
+	1445  M1445
+	1449  M1449
+	1451  M1451
+	1461  M1461
+	1489  M1489
+	1511  M1511
+	1512  ALI M1512 Aladdin
+	1513  M1513
+	1521  ALI M1521 Aladdin III CPU Bridge
+		10b9 1521  ALI M1521 Aladdin III CPU Bridge
+	1523  ALI M1523 ISA Bridge
+		10b9 1523  ALI M1523 ISA Bridge
+	1531  M1531 Northbridge [Aladdin IV/IV+]
+	1533  M1533 PCI-to-ISA Bridge
+		10b9 1533  ALI M1533 Aladdin IV/V ISA South Bridge
+	1535  M1535 PCI Bridge + Super I/O + FIR
+	1541  M1541 Northbridge [Aladdin V]
+		10b9 1541  ALI M1541 Aladdin V/V+ AGP+PCI North Bridge
+	1542  M1542 Northbridge [Aladdin V]
+	1543  M1543 PCI-to-ISA Bridge + Super I/O + FIR
+	1561  M1561 Northbridge [Aladdin 7]
+	1621  M1621 Northbridge [Aladdin-Pro II]
+	1631  M1631 Northbridge+3D Graphics [Aladdin TNT2]
+	1641  M1641 Northbridge [Aladdin-Pro IV]
+	1647  M1647 [MaGiK1] PCI North Bridge
+	1671  M1671 Northbridge [ALADDiN-P4]
+	1672  Northbridge [CyberALADDiN-P4]
+	3141  M3141
+	3143  M3143
+	3145  M3145
+	3147  M3147
+	3149  M3149
+	3151  M3151
+	3307  M3307 MPEG-I Video Controller
+	3309  M3309 MPEG-II Video w/ Software Audio Decoder
+	3321  M3321 MPEG-II Audio/Video Decoder
+	5212  M4803
+	5215  ALI PCI EIDE Controller
+	5217  M5217H
+	5219  M5219
+	5225  M5225
+	5229  M5229
+	5235  M5235
+	5237  M5237 PCI USB Host Controller
+	5240  EIDE Controller
+	5241  PCMCIA Bridge
+	5242  General Purpose Controller
+	5243  PCI to PCI Bridge Controller
+	5244  Floppy Disk Controller
+	5247  M1541 PCI to PCI Bridge
+	5251  M5251 P1394 Controller
+	5427  PCI to AGP Bridge
+	5451  M5451 PCI AC-Link Controller Audio Device
+	5453  M5453 PCI AC-Link Controller Modem Device
+	7101  M7101 PCI PMU Power Management Controller
+		10b9 7101  M7101 PCI PMU Power Management Controller
+1028  Dell
+	0001  PowerEdge Expandable RAID Controller 2/Si
+		1028 0001  PowerEdge 2400
+	0002  PowerEdge Expandable RAID Controller 3/Di
+		1028 0002  PowerEdge 4400
+	0003  PowerEdge Expandable RAID Controller 3/Si
+		1028 0003  PowerEdge 2450
+	0006  PowerEdge Expandable RAID Controller 3/Di
+	0007  Remote Access Card III
+	0008  Remote Access Card III
+	0009  Remote Access Card III: BMC/SMIC device not present
+	000a  PowerEdge Expandable RAID Controller 3/Di
+	000c  Embedded Remote Access or ERA/O
+	000d  Embedded Remote Access: BMC/SMIC device
+	000e  PowerEdge Expandable RAID controller 4/Di
+	000f  PowerEdge Expandable RAID controller 4/Di
+	0010  Remote Access Card 4
+	0011  Remote Access Card 4 Daughter Card
+	0012  Remote Access Card 4 Daughter Card Virtual UART
+	0013  PowerEdge Expandable RAID controller 4
+		1028 016c  PowerEdge Expandable RAID Controller 4e/Si
+		1028 016d  PowerEdge Expandable RAID Controller 4e/Di
+		1028 016e  PowerEdge Expandable RAID Controller 4e/Di
+		1028 016f  PowerEdge Expandable RAID Controller 4e/Di
+		1028 0170  PowerEdge Expandable RAID Controller 4e/Di
+	0014  Remote Access Card 4 Daughter Card SMIC interface
+1029  Siemens Nixdorf IS
+102a  LSI Logic
+	0000  HYDRA
+	0010  ASPEN
+	001f  AHA-2940U2/U2W /7890/7891 SCSI Controllers
+		9005 000f  2940U2W SCSI Controller
+		9005 0106  2940U2W SCSI Controller
+		9005 a180  2940U2W SCSI Controller
+	00c5  AIC-7899 U160/m SCSI Controller
+		1028 00c5  PowerEdge 2550/2650/4600
+	00cf  AIC-7899P U160/m
+		1028 0106  PowerEdge 4600
+		1028 0121  PowerEdge 2650
+102b  Matrox Graphics, Inc.
+# DJ: I've a suspicion that 0010 is a duplicate of 0d10.
+	0010  MGA-I [Impression?]
+	0100  MGA 1064SG [Mystique]
+	0518  MGA-II [Athena]
+	0519  MGA 2064W [Millennium]
+	051a  MGA 1064SG [Mystique]
+		102b 0100  MGA-1064SG Mystique
+		102b 1100  MGA-1084SG Mystique
+		102b 1200  MGA-1084SG Mystique
+		1100 102b  MGA-1084SG Mystique
+		110a 0018  Scenic Pro C5 (D1025)
+	051b  MGA 2164W [Millennium II]
+		102b 051b  MGA-2164W Millennium II
+		102b 1100  MGA-2164W Millennium II
+		102b 1200  MGA-2164W Millennium II
+	051e  MGA 1064SG [Mystique] AGP
+	051f  MGA 2164W [Millennium II] AGP
+	0520  MGA G200
+		102b dbc2  G200 Multi-Monitor
+		102b dbc8  G200 Multi-Monitor
+		102b dbe2  G200 Multi-Monitor
+		102b dbe8  G200 Multi-Monitor
+		102b ff03  Millennium G200 SD
+		102b ff04  Marvel G200
+	0521  MGA G200 AGP
+		1014 ff03  Millennium G200 AGP
+		102b 48e9  Mystique G200 AGP
+		102b 48f8  Millennium G200 SD AGP
+		102b 4a60  Millennium G200 LE AGP
+		102b 4a64  Millennium G200 AGP
+		102b c93c  Millennium G200 AGP
+		102b c9b0  Millennium G200 AGP
+		102b c9bc  Millennium G200 AGP
+		102b ca60  Millennium G250 LE AGP
+		102b ca6c  Millennium G250 AGP
+		102b dbbc  Millennium G200 AGP
+		102b dbc2  Millennium G200 MMS (Dual G200)
+		102b dbc3  G200 Multi-Monitor
+		102b dbc8  Millennium G200 MMS (Dual G200)
+		102b dbd2  G200 Multi-Monitor
+		102b dbd3  G200 Multi-Monitor
+		102b dbd4  G200 Multi-Monitor
+		102b dbd5  G200 Multi-Monitor
+		102b dbd8  G200 Multi-Monitor
+		102b dbd9  G200 Multi-Monitor
+		102b dbe2  Millennium G200 MMS (Quad G200)
+		102b dbe3  G200 Multi-Monitor
+		102b dbe8  Millennium G200 MMS (Quad G200)
+		102b dbf2  G200 Multi-Monitor
+		102b dbf3  G200 Multi-Monitor
+		102b dbf4  G200 Multi-Monitor
+		102b dbf5  G200 Multi-Monitor
+		102b dbf8  G200 Multi-Monitor
+		102b dbf9  G200 Multi-Monitor
+		102b f806  Mystique G200 Video AGP
+		102b ff00  MGA-G200 AGP
+		102b ff02  Mystique G200 AGP
+		102b ff03  Millennium G200 AGP
+		102b ff04  Marvel G200 AGP
+		110a 0032  MGA-G200 AGP
+	0525  MGA G400 AGP
+		0e11 b16f  MGA-G400 AGP
+		102b 0328  Millennium G400 16Mb SDRAM
+		102b 0338  Millennium G400 16Mb SDRAM
+		102b 0378  Millennium G400 32Mb SDRAM
+		102b 0541  Millennium G450 Dual Head
+		102b 0542  Millennium G450 Dual Head LX
+		102b 0543  Millennium G450 Single Head LX
+		102b 0641  Millennium G450 32Mb SDRAM Dual Head
+		102b 0642  Millennium G450 32Mb SDRAM Dual Head LX
+		102b 0643  Millennium G450 32Mb SDRAM Single Head LX
+		102b 07c0  Millennium G450 Dual Head LE
+		102b 07c1  Millennium G450 SDR Dual Head LE
+		102b 0d41  Millennium G450 Dual Head PCI
+		102b 0d42  Millennium G450 Dual Head LX PCI
+		102b 0d43  Millennium G450 32Mb Dual Head PCI
+		102b 0e00  Marvel G450 eTV
+		102b 0e01  Marvel G450 eTV
+		102b 0e02  Marvel G450 eTV
+		102b 0e03  Marvel G450 eTV
+		102b 0f80  Millennium G450 Low Profile
+		102b 0f81  Millennium G450 Low Profile
+		102b 0f82  Millennium G450 Low Profile DVI
+		102b 0f83  Millennium G450 Low Profile DVI
+		102b 19d8  Millennium G400 16Mb SGRAM
+		102b 19f8  Millennium G400 32Mb SGRAM
+		102b 2159  Millennium G400 Dual Head 16Mb
+		102b 2179  Millennium G400 MAX/Dual Head 32Mb
+		102b 217d  Millennium G400 Dual Head Max
+		102b 23c0  Millennium G450
+		102b 23c1  Millennium G450
+		102b 23c2  Millennium G450 DVI
+		102b 23c3  Millennium G450 DVI
+		102b 2f58  Millennium G400
+		102b 2f78  Millennium G400
+		102b 3693  Marvel G400 AGP
+		102b 5dd0  4Sight II
+		102b 5f50  4Sight II
+		102b 5f51  4Sight II
+		102b 5f52  4Sight II
+		102b 9010  Millennium G400 Dual Head
+		1458 0400  GA-G400
+		1705 0001  Millennium G450 32MB SGRAM
+		1705 0002  Millennium G450 16MB SGRAM
+		1705 0003  Millennium G450 32MB
+		1705 0004  Millennium G450 16MB
+	0527  MGA Parhelia AGP
+		102b 0840  Parhelia 128Mb
+	0d10  MGA Ultima/Impression
+	1000  MGA G100 [Productiva]
+		102b ff01  Productiva G100
+		102b ff05  Productiva G100 Multi-Monitor
+	1001  MGA G100 [Productiva] AGP
+		102b 1001  MGA-G100 AGP
+		102b ff00  MGA-G100 AGP
+		102b ff01  MGA-G100 Productiva AGP
+		102b ff03  Millennium G100 AGP
+		102b ff04  MGA-G100 AGP
+		102b ff05  MGA-G100 Productiva AGP Multi-Monitor
+		110a 001e  MGA-G100 AGP
+	2007  MGA Mistral
+	2527  MGA G550 AGP
+		102b 0f83  Millennium G550
+		102b 0f84  Millennium G550 Dual Head DDR 32Mb
+		102b 1e41  Millennium G550
+	2537  MGA G650 AGP
+	4536  VIA Framegrabber
+	6573  Shark 10/100 Multiport SwitchNIC
+102c  Chips and Technologies
+	00b8  F64310
+	00c0  F69000 HiQVideo
+		102c 00c0  F69000 HiQVideo
+		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
+		4c53 1010  CP5/CR6 mainboard
+		4c53 1020  VR6 mainboard
+		4c53 1030  PC5 mainboard
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+	00d0  F65545
+	00d8  F65545
+	00dc  F65548
+	00e0  F65550
+	00e4  F65554
+	00e5  F65555 HiQVPro
+		0e11 b049  Armada 1700 Laptop Display Controller
+	00f0  F68554
+	00f4  F68554 HiQVision
+	00f5  F68555
+	0c30  F69030
+		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+# C5C project cancelled
+		4c53 1080  CT8 mainboard
+102d  Wyse Technology Inc.
+	50dc  3328 Audio
+102e  Olivetti Advanced Technology
+102f  Toshiba America
+	0009  r4x00
+	000a  TX3927 MIPS RISC PCI Controller
+	0020  ATM Meteor 155
+		102f 00f8  ATM Meteor 155
+	0030  TC35815CF PCI 10/100 Mbit Ethernet Controller
+	0031  TC35815CF PCI 10/100 Mbit Ethernet Controller with WOL
+	0105  TC86C001 [goku-s] IDE
+	0106  TC86C001 [goku-s] USB 1.1 Host
+	0107  TC86C001 [goku-s] USB Device Controller
+	0108  TC86C001 [goku-s] I2C/SIO/GPIO Controller
+	0180  TX4927/38 MIPS RISC PCI Controller
+	0181  TX4925 MIPS RISC PCI Controller
+	0182  TX4937 MIPS RISC PCI Controller
+1030  TMC Research
+1031  Miro Computer Products AG
+	5601  DC20 ASIC
+	5607  Video I/O & motion JPEG compressor
+	5631  Media 3D
+	6057  MiroVideo DC10/DC30+
+1032  Compaq
+1033  NEC Corporation
+	0000  Vr4181A USB Host or Function Control Unit
+	0001  PCI to 486-like bus Bridge
+	0002  PCI to VL98 Bridge
+	0003  ATM Controller
+	0004  R4000 PCI Bridge
+	0005  PCI to 486-like bus Bridge
+	0006  PC-9800 Graphic Accelerator
+	0007  PCI to UX-Bus Bridge
+	0008  PC-9800 Graphic Accelerator
+	0009  PCI to PC9800 Core-Graph Bridge
+	0016  PCI to VL Bridge
+	001a  [Nile II]
+	0021  Vrc4373 [Nile I]
+	0029  PowerVR PCX1
+	002a  PowerVR 3D
+	002c  Star Alpha 2
+	002d  PCI to C-bus Bridge
+	0035  USB
+		1179 0001  USB
+		12ee 7000  Root Hub
+		1799 0001  Root Hub
+		807d 0035  PCI-USB2 (OHCI subsystem)
+	003b  PCI to C-bus Bridge
+	003e  NAPCCARD Cardbus Controller
+	0046  PowerVR PCX2 [midas]
+	005a  Vrc5074 [Nile 4]
+	0063  Firewarden
+	0067  PowerVR Neon 250 Chipset
+		1010 0020  PowerVR Neon 250 AGP 32Mb
+		1010 0080  PowerVR Neon 250 AGP 16Mb
+		1010 0088  PowerVR Neon 250 16Mb
+		1010 0090  PowerVR Neon 250 AGP 16Mb
+		1010 0098  PowerVR Neon 250 16Mb
+		1010 00a0  PowerVR Neon 250 AGP 32Mb
+		1010 00a8  PowerVR Neon 250 32Mb
+		1010 0120  PowerVR Neon 250 AGP 32Mb
+	0072  uPD72874 IEEE1394 OHCI 1.1 3-port PHY-Link Ctrlr
+	0074  56k Voice Modem
+		1033 8014  RCV56ACF 56k Voice Modem
+	009b  Vrc5476
+	00a5  VRC4173
+	00a6  VRC5477 AC97
+	00cd  IEEE 1394 [OrangeLink] Host Controller
+		12ee 8011  Root hub
+	00ce  IEEE 1394 Host Controller
+	00df  Vr4131
+	00e0  USB 2.0
+		0ee4 3383  Sitecom IEEE 1394 / USB2.0 Combo Card
+		12ee 7001  Root hub
+		1799 0002  Root Hub
+		807d 1043  PCI-USB2 (EHCI subsystem)
+	00e7  IEEE 1394 Host Controller
+	00f2  uPD72874 IEEE1394 OHCI 1.1 3-port PHY-Link Ctrlr
+	00f3  uPD6113x Multimedia Decoder/Processor [EMMA2]
+	010c  VR7701
+1034  Framatome Connectors USA Inc.
+1035  Comp. & Comm. Research Lab
+1036  Future Domain Corp.
+	0000  TMC-18C30 [36C70]
+1037  Hitachi Micro Systems
+1038  AMP, Inc
+1039  Silicon Integrated Systems [SiS]
+	0001  Virtual PCI-to-PCI bridge (AGP)
+	0002  SG86C202
+	0006  85C501/2/3
+	0008  SiS85C503/5513 (LPC Bridge)
+	0009  ACPI
+# source: http://members.datafast.net.au/dft0802/downloads/pcidevs.txt
+	0016  SiS961/2 SMBus Controller
+	0018  SiS85C503/5513 (LPC Bridge)
+# Controller for 2 PATA and 2 SATA channels
+	0180  RAID bus controller 180 SATA/PATA  [SiS]
+	0181  SiS SATA
+	0200  5597/5598/6326 VGA
+		1039 0000  SiS5597 SVGA (Shared RAM)
+	0204  82C204
+	0205  SG86C205
+	0300  300/305 PCI/AGP VGA Display Adapter
+		107d 2720  Leadtek WinFast VR300
+	0310  315H PCI/AGP VGA Display Adapter
+	0315  315 PCI/AGP VGA Display Adapter
+	0325  315PRO PCI/AGP VGA Display Adapter
+	0330  330 [Xabre] PCI/AGP VGA Display Adapter
+	0406  85C501/2
+	0496  85C496
+	0530  530 Host
+	0540  540 Host
+	0550  550 Host
+	0597  5513C
+	0601  85C601
+	0620  620 Host
+	0630  630 Host
+	0633  633 Host
+	0635  635 Host
+	0645  SiS645 Host & Memory & AGP Controller
+	0646  SiS645DX Host & Memory & AGP Controller
+	0648  SiS 645xx
+	0650  650/M650 Host
+	0651  651 Host
+	0655  655 Host
+	0660  660 Host
+	0661  661FX/M661FX/M661MX Host
+	0730  730 Host
+	0733  733 Host
+	0735  735 Host
+	0740  740 Host
+	0741  741/741GX/M741 Host
+	0745  745 Host
+	0746  746 Host
+	0755  755 Host
+	0760  760/M760 Host
+	0900  SiS900 PCI Fast Ethernet
+		1019 0a14  K7S5A motherboard
+		1039 0900  SiS900 10/100 Ethernet Adapter
+		1043 8035  CUSI-FX motherboard
+	0961  SiS961 [MuTIOL Media IO]
+	0962  SiS962 [MuTIOL Media IO]
+	0963  SiS963 [MuTIOL Media IO]
+	0964  SiS964 [MuTIOL Media IO]
+	0965  SiS965 [MuTIOL Media IO]
+	3602  83C602
+	5107  5107
+	5300  SiS540 PCI Display Adapter
+	5315  550 PCI/AGP VGA Display Adapter
+	5401  486 PCI Chipset
+	5511  5511/5512
+	5513  5513 [IDE]
+		1019 0970  P6STP-FL motherboard
+		1039 5513  SiS5513 EIDE Controller (A,B step)
+		1043 8035  CUSI-FX motherboard
+	5517  5517
+	5571  5571
+	5581  5581 Pentium Chipset
+	5582  5582
+	5591  5591/5592 Host
+	5596  5596 Pentium Chipset
+	5597  5597 [SiS5582]
+	5600  5600 Host
+	6204  Video decoder & MPEG interface
+	6205  VGA Controller
+	6236  6236 3D-AGP
+	6300  630/730 PCI/AGP VGA Display Adapter
+		1019 0970  P6STP-FL motherboard
+		1043 8035  CUSI-FX motherboard
+	6306  530/620 PCI/AGP VGA Display Adapter
+		1039 6306  SiS530,620 GUI Accelerator+3D
+	6325  65x/M650/740 PCI/AGP VGA Display Adapter
+	6326  86C326 5598/6326
+		1039 6326  SiS6326 GUI Accelerator
+		1092 0a50  SpeedStar A50
+		1092 0a70  SpeedStar A70
+		1092 4910  SpeedStar A70
+		1092 4920  SpeedStar A70
+		1569 6326  SiS6326 GUI Accelerator
+	6330  661/741/760 PCI/AGP VGA Display Adapter
+		1039 6330  [M]661xX/[M]741[GX]/[M]760 PCI/AGP VGA Adapter
+	7001  USB 1.0 Controller
+		1019 0a14  K7S5A motherboard
+		1039 7000  Onboard USB Controller
+	7002  USB 2.0 Controller
+		1509 7002  Onboard USB Controller
+	7007  FireWire Controller
+	7012  Sound Controller
+# There are may be different modem codecs here (Intel537 compatible and incompatible)
+	7013  AC'97 Modem Controller
+	7016  SiS7016 PCI Fast Ethernet Adapter
+		1039 7016  SiS7016 10/100 Ethernet Adapter
+	7018  SiS PCI Audio Accelerator
+		1014 01b6  SiS PCI Audio Accelerator
+		1014 01b7  SiS PCI Audio Accelerator
+		1019 7018  SiS PCI Audio Accelerator
+		1025 000e  SiS PCI Audio Accelerator
+		1025 0018  SiS PCI Audio Accelerator
+		1039 7018  SiS PCI Audio Accelerator
+		1043 800b  SiS PCI Audio Accelerator
+		1054 7018  SiS PCI Audio Accelerator
+		107d 5330  SiS PCI Audio Accelerator
+		107d 5350  SiS PCI Audio Accelerator
+		1170 3209  SiS PCI Audio Accelerator
+		1462 400a  SiS PCI Audio Accelerator
+		14a4 2089  SiS PCI Audio Accelerator
+		14cd 2194  SiS PCI Audio Accelerator
+		14ff 1100  SiS PCI Audio Accelerator
+		152d 8808  SiS PCI Audio Accelerator
+		1558 1103  SiS PCI Audio Accelerator
+		1558 2200  SiS PCI Audio Accelerator
+		1563 7018  SiS PCI Audio Accelerator
+		15c5 0111  SiS PCI Audio Accelerator
+		270f a171  SiS PCI Audio Accelerator
+		a0a0 0022  SiS PCI Audio Accelerator
+	7019  SiS7019 Audio Accelerator
+103a  Seiko Epson Corporation
+103b  Tatung Co. of America
+103c  Hewlett-Packard Company
+	1005  A4977A Visualize EG
+	1006  Visualize FX6
+	1008  Visualize FX4
+	100a  Visualize FX2
+	1028  Tach TL Fibre Channel Host Adapter
+	1029  Tach XL2 Fibre Channel Host Adapter
+		107e 000f  Interphase 5560 Fibre Channel Adapter
+		9004 9210  1Gb/2Gb Family Fibre Channel Controller
+		9004 9211  1Gb/2Gb Family Fibre Channel Controller
+	102a  Tach TS Fibre Channel Host Adapter
+		107e 000e  Interphase 5540/5541 Fibre Channel Adapter
+		9004 9110  1Gb/2Gb Family Fibre Channel Controller
+		9004 9111  1Gb/2Gb Family Fibre Channel Controller
+	1030  J2585A DeskDirect 10/100VG NIC
+	1031  J2585B HP 10/100VG PCI LAN Adapter
+		103c 1040  J2973A DeskDirect 10BaseT NIC
+		103c 1041  J2585B DeskDirect 10/100VG NIC
+		103c 1042  J2970A DeskDirect 10BaseT/2 NIC
+	1040  J2973A DeskDirect 10BaseT NIC
+	1041  J2585B DeskDirect 10/100 NIC
+	1042  J2970A DeskDirect 10BaseT/2 NIC
+	1048  Diva Serial [GSP] Multiport UART
+		103c 1049  Tosca Console
+		103c 104a  Tosca Secondary
+		103c 104b  Maestro SP2
+		103c 1223  Superdome Console
+		103c 1226  Keystone SP2
+		103c 1227  Powerbar SP2
+		103c 1282  Everest SP2
+		103c 1301  Diva RMP3
+	1054  PCI Local Bus Adapter
+	1064  79C970 PCnet Ethernet Controller
+	108b  Visualize FXe
+	10c1  NetServer Smart IRQ Router
+	10ed  TopTools Remote Control
+	10f0  rio System Bus Adapter
+	10f1  rio I/O Controller
+	1200  82557B 10/100 NIC
+	1219  NetServer PCI Hot-Plug Controller
+	121a  NetServer SMIC Controller
+	121b  NetServer Legacy COM Port Decoder
+	121c  NetServer PCI COM Port Decoder
+	1229  zx1 System Bus Adapter
+	122a  zx1 I/O Controller
+	122e  zx1 Local Bus Adapter
+	127c  sx1000 I/O Controller
+	1290  Auxiliary Diva Serial Port
+	12b4  zx1 QuickSilver AGP8x Local Bus Adapter
+	2910  E2910A PCIBus Exerciser
+	2925  E2925A 32 Bit, 33 MHzPCI Exerciser & Analyzer
+103e  Solliday Engineering
+103f  Synopsys/Logic Modeling Group
+1040  Accelgraphics Inc.
+1041  Computrend
+1042  Micron
+	1000  PC Tech RZ1000
+	1001  PC Tech RZ1001
+	3000  Samurai_0
+	3010  Samurai_1
+	3020  Samurai_IDE
+1043  ASUSTeK Computer Inc.
+	0675  ISDNLink P-IN100-ST-D
+	4015  v7100 SDRAM [GeForce2 MX]
+	4021  v7100 Combo Deluxe [GeForce2 MX + TV tuner]
+	4057  v8200 GeForce 3
+	8043  v8240 PAL 128M [P4T] Motherboard
+	807b  v9280/TD [Geforce4 TI4200 8X With TV-Out and DVI]
+	80bb  v9180 Magic/T [GeForce4 MX440 AGP 8x 64MB TV-out]
+	80c5  nForce3 chipset motherboard [SK8N]
+	80df  v9520 Magic/T
+1044  Adaptec (formerly DPT)
+	1012  Domino RAID Engine
+	a400  SmartCache/Raid I-IV Controller
+	a500  PCI Bridge
+	a501  SmartRAID V Controller
+		1044 c001  PM1554U2 Ultra2 Single Channel
+		1044 c002  PM1654U2 Ultra2 Single Channel
+		1044 c003  PM1564U3 Ultra3 Single Channel
+		1044 c004  PM1564U3 Ultra3 Dual Channel
+		1044 c005  PM1554U2 Ultra2 Single Channel (NON ACPI)
+		1044 c00a  PM2554U2 Ultra2 Single Channel
+		1044 c00b  PM2654U2 Ultra2 Single Channel
+		1044 c00c  PM2664U3 Ultra3 Single Channel
+		1044 c00d  PM2664U3 Ultra3 Dual Channel
+		1044 c00e  PM2554U2 Ultra2 Single Channel (NON ACPI)
+		1044 c00f  PM2654U2 Ultra2 Single Channel (NON ACPI)
+		1044 c014  PM3754U2 Ultra2 Single Channel (NON ACPI)
+		1044 c015  PM3755U2B Ultra2 Single Channel (NON ACPI)
+		1044 c016  PM3755F Fibre Channel (NON ACPI)
+		1044 c01e  PM3757U2 Ultra2 Single Channel
+		1044 c01f  PM3757U2 Ultra2 Dual Channel
+		1044 c020  PM3767U3 Ultra3 Dual Channel
+		1044 c021  PM3767U3 Ultra3 Quad Channel
+		1044 c028  PM2865U3 Ultra3 Single Channel
+		1044 c029  PM2865U3 Ultra3 Dual Channel
+		1044 c02a  PM2865F Fibre Channel
+		1044 c03c  2000S Ultra3 Single Channel
+		1044 c03d  2000S Ultra3 Dual Channel
+		1044 c03e  2000F Fibre Channel
+		1044 c046  3000S Ultra3 Single Channel
+		1044 c047  3000S Ultra3 Dual Channel
+		1044 c048  3000F Fibre Channel
+		1044 c050  5000S Ultra3 Single Channel
+		1044 c051  5000S Ultra3 Dual Channel
+		1044 c052  5000F Fibre Channel
+		1044 c05a  2400A UDMA Four Channel
+		1044 c05b  2400A UDMA Four Channel DAC
+		1044 c064  3010S Ultra3 Dual Channel
+		1044 c065  3410S Ultra160 Four Channel
+		1044 c066  3010S Fibre Channel
+	a511  SmartRAID V Controller
+		1044 c032  ASR-2005S I2O Zero Channel
+1045  OPTi Inc.
+	a0f8  82C750 [Vendetta] USB Controller
+	c101  92C264
+	c178  92C178
+	c556  82X556 [Viper]
+	c557  82C557 [Viper-M]
+	c558  82C558 [Viper-M ISA+IDE]
+	c567  82C750 [Vendetta], device 0
+	c568  82C750 [Vendetta], device 1
+	c569  82C579 [Viper XPress+ Chipset]
+	c621  82C621 [Viper-M/N+]
+	c700  82C700 [FireStar]
+	c701  82C701 [FireStar Plus]
+	c814  82C814 [Firebridge 1]
+	c822  82C822
+	c824  82C824
+	c825  82C825 [Firebridge 2]
+	c832  82C832
+	c861  82C861
+	c895  82C895
+	c935  EV1935 ECTIVA MachOne PCIAudio
+	d568  82C825 [Firebridge 2]
+	d721  IDE [FireStar]
+1046  IPC Corporation, Ltd.
+1047  Genoa Systems Corp
+1048  Elsa AG
+	0c60  Gladiac MX
+	0d22  Quadro4 900XGL [ELSA GLoria4 900XGL]
+	1000  QuickStep 1000
+	3000  QuickStep 3000
+	8901  Gloria XL
+1049  Fountain Technologies, Inc.
+# # nee SGS Thomson Microelectronics
+104a  STMicroelectronics
+	0008  STG 2000X
+	0009  STG 1764X
+	0010  STG4000 [3D Prophet Kyro Series]
+	0209  STPC Consumer/Industrial North- and Southbridge
+	020a  STPC Atlas/ConsumerS/Consumer IIA Northbridge
+# From <http://gatekeeper.dec.com/pub/BSD/FreeBSD/FreeBSD-stable/src/share/misc/pci_vendors>
+	0210  STPC Atlas ISA Bridge
+	021a  STPC Consumer S Southbridge
+	021b  STPC Consumer IIA Southbridge
+	0500  ST70137 [Unicorn] ADSL DMT Transceiver
+	0564  STPC Client Northbridge
+	0981  21x4x DEC-Tulip compatible 10/100 Ethernet
+	1746  STG 1764X
+	2774  21x4x DEC-Tulip compatible 10/100 Ethernet
+	3520  MPEG-II decoder card
+	55cc  STPC Client Southbridge
+104b  BusLogic
+	0140  BT-946C (old) [multimaster  01]
+	1040  BT-946C (BA80C30) [MultiMaster 10]
+	8130  Flashpoint LT
+104c  Texas Instruments
+	0500  100 MBit LAN Controller
+	0508  TMS380C2X Compressor Interface
+	1000  Eagle i/f AS
+	104c  PCI1510 PC card Cardbus Controller
+	3d04  TVP4010 [Permedia]
+	3d07  TVP4020 [Permedia 2]
+		1011 4d10  Comet
+		1040 000f  AccelStar II
+		1040 0011  AccelStar II
+		1048 0a31  WINNER 2000
+		1048 0a32  GLoria Synergy
+		1048 0a35  GLoria Synergy
+		107d 2633  WinFast 3D L2300
+		1092 0127  FIRE GL 1000 PRO
+		1092 0136  FIRE GL 1000 PRO
+		1092 0141  FIRE GL 1000 PRO
+		1092 0146  FIRE GL 1000 PRO
+		1092 0148  FIRE GL 1000 PRO
+		1092 0149  FIRE GL 1000 PRO
+		1092 0152  FIRE GL 1000 PRO
+		1092 0154  FIRE GL 1000 PRO
+		1092 0155  FIRE GL 1000 PRO
+		1092 0156  FIRE GL 1000 PRO
+		1092 0157  FIRE GL 1000 PRO
+		1097 3d01  Jeronimo Pro
+		1102 100f  Graphics Blaster Extreme
+		3d3d 0100  Reference Permedia 2 3D
+	8000  PCILynx/PCILynx2 IEEE 1394 Link Layer Controller
+		e4bf 1010  CF1-1-SNARE
+		e4bf 1020  CF1-2-SNARE
+	8009  FireWire Controller
+		104d 8032  8032 OHCI i.LINK (IEEE 1394) Controller
+	8017  PCI4410 FireWire Controller
+	8019  TSB12LV23 IEEE-1394 Controller
+		11bd 000a  Studio DV500-1394
+		11bd 000e  Studio DV
+		e4bf 1010  CF2-1-CYMBAL
+	8020  TSB12LV26 IEEE-1394 Controller (Link)
+		11bd 000f  Studio DV500-1394
+	8021  TSB43AA22 IEEE-1394 Controller (PHY/Link Integrated)
+		104d 80df  Vaio PCG-FX403
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+	8022  TSB43AB22 IEEE-1394a-2000 Controller (PHY/Link)
+	8023  TSB43AB22/A IEEE-1394a-2000 Controller (PHY/Link)
+		103c 088c  nc8000 laptop
+	8024  TSB43AB23 IEEE-1394a-2000 Controller (PHY/Link)
+	8025  TSB82AA2 IEEE-1394b Link Layer Controller
+		55aa 55aa  FireWire 800 PCI Card
+	8026  TSB43AB21 IEEE-1394a-2000 Controller (PHY/Link)
+	8027  PCI4451 IEEE-1394 Controller
+		1028 00e6  PCI4451 IEEE-1394 Controller (Dell Inspiron 8100)
+	8029  PCI4510 IEEE-1394 Controller
+		1028 0163  Latitude D505
+		1071 8160  MIM2900
+	802b  PCI7410,7510,7610 OHCI-Lynx Controller
+		1028 014e  PCI7410,7510,7610 OHCI-Lynx Controller (Dell Latitude D800)
+	802e  PCI7x20 1394a-2000 OHCI Two-Port PHY/Link-Layer Controller
+	8031  Texas Instruments PCIxx21/x515 Cardbus Controller
+	8032  Texas Instruments OHCI Compliant IEEE 1394 Host Controller
+	8033  Texas Instruments PCIxx21 Integrated FlashMedia Controller
+	8034  Texas Instruments PCI6411, PCI6421, PCI6611, PCI6621, PCI7411, PCI7421, PCI7611, PCI7621 Secure Digital (SD) Controller
+	8035  Texas Instruments PCI6411, PCI6421, PCI6611, PCI6621, PCI7411, PCI7421, PCI7611, PCI7621 Smart Card Controller (SMC)
+	8201  PCI1620 Firmware Loading Function
+	8204  PCI7410,7510,7610 PCI Firmware Loading Function
+		1028 014e  Latitude D800
+	8400  ACX 100 22Mbps Wireless Interface
+		00fc 16ec  U.S. Robotics 22 Mbps Wireless PC Card (model 2210)
+		00fd 16ec  U.S. Robotics 22Mbps Wireless PCI Adapter (model 2216)
+		1186 3b00  DWL-650+ PC Card cardbus 22Mbs Wireless Adapter [AirPlus]
+		1186 3b01  DWL-520+ 22Mbps PCI Wireless Adapter
+	8401  ACX 100 22Mbps Wireless Interface
+# OK, this info is almost useless as is, but at least it's known that it's a wireless card. More info requested from reporter (whi
+	9000  Wireless Interface (of unknown type)
+	9066  ACX 111 54Mbps Wireless Interface
+	a001  TDC1570
+	a100  TDC1561
+	a102  TNETA1575 HyperSAR Plus w/PCI Host i/f & UTOPIA i/f
+	a106  TMS320C6205 Fixed Point DSP
+		175c 5000  ASI50xx Audio Adapter
+		175c 8700  ASI87xx Radio Tuner card
+	ac10  PCI1050
+	ac11  PCI1053
+	ac12  PCI1130
+	ac13  PCI1031
+	ac15  PCI1131
+	ac16  PCI1250
+		1014 0092  ThinkPad 600
+	ac17  PCI1220
+	ac18  PCI1260
+	ac19  PCI1221
+	ac1a  PCI1210
+	ac1b  PCI1450
+		0e11 b113  Armada M700
+	ac1c  PCI1225
+		0e11 b121  Armada E500
+		1028 0088  Dell  Computer Corporation  Latitude CPi A400XT
+	ac1d  PCI1251A
+	ac1e  PCI1211
+	ac1f  PCI1251B
+	ac20  TI 2030
+	ac21  PCI2031
+	ac22  PCI2032 PCI Docking Bridge
+	ac23  PCI2250 PCI-to-PCI Bridge
+	ac28  PCI2050 PCI-to-PCI Bridge
+	ac30  PCI1260 PC card Cardbus Controller
+	ac40  PCI4450 PC card Cardbus Controller
+	ac41  PCI4410 PC card Cardbus Controller
+	ac42  PCI4451 PC card Cardbus Controller
+		1028 00e6  PCI4451 PC card CardBus Controller (Dell Inspiron 8100)
+	ac44  PCI4510 PC card Cardbus Controller
+		1028 0163  Latitude D505
+		1071 8160  MIM2000
+	ac46  PCI4520 PC card Cardbus Controller
+	ac47  PCI7510 PC card Cardbus Controller
+		1028 014e  Latitude D800
+	ac4a  PCI7510,7610 PC card Cardbus Controller
+		1028 014e  Latitude D800
+	ac50  PCI1410 PC card Cardbus Controller
+	ac51  PCI1420
+		1014 023b  ThinkPad T23 (2647-4MG)
+		1028 00b1  Latitude C600
+		1028 012a  Latitude C640
+		1033 80cd  Versa Note VXi
+		10cf 1095  Lifebook C6155
+		e4bf 1000  CP2-2-HIPHOP
+	ac52  PCI1451 PC card Cardbus Controller
+	ac53  PCI1421 PC card Cardbus Controller
+	ac54  PCI1620 PC Card Controller
+	ac55  PCI1520 PC card Cardbus Controller
+		1014 0512  ThinkPad T30/T40
+	ac56  PCI1510 PC card Cardbus Controller
+		1014 0528  ThinkPad R40e (2684-HVG) Cardbus Controller
+	ac60  PCI2040 PCI to DSP Bridge Controller
+		175c 5100  ASI51xx Audio Adapter
+		175c 6100  ASI61xx Audio Adapter
+		175c 6200  ASI62xx Audio Adapter
+	ac8d  PCI 7620
+	ac8e  PCI7420 CardBus Controller
+	ac8f  PCI7420/PCI7620 Dual Socket CardBus and Smart Card Cont. w/ 1394a-2000 OHCI Two-Port  PHY/Link-Layer Cont. and SD/MS-Pro Sockets
+	fe00  FireWire Host Controller
+	fe03  12C01A FireWire Host Controller
+104d  Sony Corporation
+	8004  DTL-H2500 [Playstation development board]
+	8009  CXD1947Q i.LINK Controller
+	8039  CXD3222 i.LINK Controller
+	8056  Rockwell HCF 56K modem
+	808a  Memory Stick Controller
+104e  Oak Technology, Inc
+	0017  OTI-64017
+	0107  OTI-107 [Spitfire]
+	0109  Video Adapter
+	0111  OTI-64111 [Spitfire]
+	0217  OTI-64217
+	0317  OTI-64317
+104f  Co-time Computer Ltd
+1050  Winbond Electronics Corp
+	0000  NE2000
+	0001  W83769F
+	0105  W82C105
+	0840  W89C840
+		1050 0001  W89C840 Ethernet Adapter
+		1050 0840  W89C840 Ethernet Adapter
+	0940  W89C940
+	5a5a  W89C940F
+	6692  W6692
+	9921  W99200F MPEG-1 Video Encoder
+	9922  W99200F/W9922PF MPEG-1/2 Video Encoder
+	9970  W9970CF
+1051  Anigma, Inc.
+1052  ?Young Micro Systems
+1053  Young Micro Systems
+1054  Hitachi, Ltd
+1055  Efar Microsystems
+	9130  SLC90E66 [Victory66] IDE
+	9460  SLC90E66 [Victory66] ISA
+	9462  SLC90E66 [Victory66] USB
+	9463  SLC90E66 [Victory66] ACPI
+1056  ICL
+# Motorola made a mistake and used 1507 instead of 1057 in some chips. Please look at the 1507 entry as well when updating this.
+1057  Motorola
+	0001  MPC105 [Eagle]
+	0002  MPC106 [Grackle]
+	0003  MPC8240 [Kahlua]
+	0004  MPC107
+	0006  MPC8245 [Unity]
+	0008  MPC8540
+	0009  MPC8560
+	0100  MC145575 [HFC-PCI]
+	0431  KTI829c 100VG
+	1801  DSP56301 Digital Signal Processor
+		14fb 0101  Transas Radar Imitator Board [RIM]
+		14fb 0102  Transas Radar Imitator Board [RIM-2]
+		14fb 0202  Transas Radar Integrator Board [RIB-2]
+		14fb 0611  1 channel CAN bus Controller [CanPci-1]
+		14fb 0612  2 channels CAN bus Controller [CanPci-2]
+		14fb 0613  3 channels CAN bus Controller [CanPci-3]
+		14fb 0614  4 channels CAN bus Controller [CanPci-4]
+		14fb 0621  1 channel CAN bus Controller [CanPci2-1]
+		14fb 0622  2 channels CAN bus Controller [CanPci2-2]
+		14fb 0810  Transas VTS Radar Integrator Board [RIB-4]
+		175c 4200  ASI4215 Audio Adapter
+		175c 4300  ASI43xx Audio Adapter
+		175c 4400  ASI4401 Audio Adapter
+		ecc0 0010  Darla
+		ecc0 0020  Gina
+		ecc0 0030  Layla rev.0
+		ecc0 0031  Layla rev.1
+		ecc0 0040  Darla24 rev.0
+		ecc0 0041  Darla24 rev.1
+		ecc0 0050  Gina24 rev.0
+		ecc0 0051  Gina24 rev.1
+		ecc0 0070  Mona rev.0
+		ecc0 0071  Mona rev.1
+		ecc0 0072  Mona rev.2
+	18c0  MPC8265A/MPC8266
+	18c1  MPC8271/MPC8272
+	3410  DSP56361 Digital Signal Processor
+		ecc0 0050  Gina24 rev.0
+		ecc0 0051  Gina24 rev.1
+		ecc0 0060  Layla24
+		ecc0 0070  Mona rev.0
+		ecc0 0071  Mona rev.1
+		ecc0 0072  Mona rev.2
+		ecc0 0080  Mia rev.0
+		ecc0 0081  Mia rev.1
+		ecc0 0090  Indigo
+		ecc0 00a0  Indigo IO
+		ecc0 00b0  Indigo DJ
+		ecc0 0100  3G
+	4801  Raven
+	4802  Falcon
+	4803  Hawk
+	4806  CPX8216
+	4d68  20268
+	5600  SM56 PCI Modem
+		1057 0300  SM56 PCI Speakerphone Modem
+		1057 0301  SM56 PCI Voice Modem
+		1057 0302  SM56 PCI Fax Modem
+		1057 5600  SM56 PCI Voice modem
+		13d2 0300  SM56 PCI Speakerphone Modem
+		13d2 0301  SM56 PCI Voice modem
+		13d2 0302  SM56 PCI Fax Modem
+		1436 0300  SM56 PCI Speakerphone Modem
+		1436 0301  SM56 PCI Voice modem
+		1436 0302  SM56 PCI Fax Modem
+		144f 100c  SM56 PCI Fax Modem
+		1494 0300  SM56 PCI Speakerphone Modem
+		1494 0301  SM56 PCI Voice modem
+		14c8 0300  SM56 PCI Speakerphone Modem
+		14c8 0302  SM56 PCI Fax Modem
+		1668 0300  SM56 PCI Speakerphone Modem
+		1668 0302  SM56 PCI Fax Modem
+	5803  MPC5200
+	6400  MPC190 Security Processor (S1 family, encryption)
+	6405  MPC184 Security Processor (S1 family)
+1058  Electronics & Telecommunications RSH
+1059  Teknor Industrial Computers Inc
+105a  Promise Technology, Inc.
+# more correct description from promise linux sources
+	0d30  PDC20265 (FastTrak100 Lite/Ultra100)
+		105a 4d33  Ultra100
+	0d38  20263
+		105a 4d39  Fasttrak66
+	1275  20275
+	3318  PDC20318 (SATA150 TX4)
+	3319  PDC20319 (FastTrak S150 TX4)
+		8086 3427  S875WP1-E mainboard
+	3371  PDC20371 (FastTrak S150 TX2plus)
+	3373  PDC20378 (FastTrak 378/SATA 378)
+		1043 80f5  K8V Deluxe/PC-DL Deluxe motherboard
+		1462 702e  K8T NEO FIS2R motherboard
+	3375  PDC20375 (SATA150 TX2plus)
+	3376  PDC20376 (FastTrak 376)
+		1043 809e  A7V8X motherboard
+	3574  PDC20579 SATAII 150 IDE Controller
+	3d18  PDC20518/PDC40518 (SATAII 150 TX4)
+	3d75  PDC20575 (SATAII150 TX2plus)
+	4d30  PDC20267 (FastTrak100/Ultra100)
+		105a 4d33  Ultra100
+		105a 4d39  FastTrak100
+	4d33  20246
+		105a 4d33  20246 IDE Controller
+	4d38  PDC20262 (FastTrak66/Ultra66)
+		105a 4d30  Ultra Device on SuperTrak
+		105a 4d33  Ultra66
+		105a 4d39  FastTrak66
+	4d68  PDC20268 (Ultra100 TX2)
+		105a 4d68  Ultra100TX2
+	4d69  20269
+		105a 4d68  Ultra133TX2
+	5275  PDC20276 (MBFastTrak133 Lite)
+		105a 0275  SuperTrak SX6000 IDE
+		105a 1275  MBFastTrak133 Lite (tm) Controller (RAID mode)
+		1458 b001  MBUltra 133
+	5300  DC5300
+	6268  PDC20270 (FastTrak100 LP/TX2/TX4)
+		105a 4d68  FastTrak100 TX2
+	6269  PDC20271 (FastTrak TX2000)
+		105a 6269  FastTrak TX2/TX2000
+	6621  PDC20621 (FastTrak S150 SX4/FastTrak SX4000 lite)
+	6622  PDC20621 [SATA150 SX4] 4 Channel IDE RAID Controller
+	6626  PDC20618 (Ultra 618)
+	6629  PDC20619 (FastTrak TX4000)
+	7275  PDC20277 (SBFastTrak133 Lite)
+105b  Foxconn International, Inc.
+105c  Wipro Infotech Limited
+105d  Number 9 Computer Company
+	2309  Imagine 128
+	2339  Imagine 128-II
+		105d 0000  Imagine 128 series 2 4Mb VRAM
+		105d 0001  Imagine 128 series 2 4Mb VRAM
+		105d 0002  Imagine 128 series 2 4Mb VRAM
+		105d 0003  Imagine 128 series 2 4Mb VRAM
+		105d 0004  Imagine 128 series 2 4Mb VRAM
+		105d 0005  Imagine 128 series 2 4Mb VRAM
+		105d 0006  Imagine 128 series 2 4Mb VRAM
+		105d 0007  Imagine 128 series 2 4Mb VRAM
+		105d 0008  Imagine 128 series 2e 4Mb DRAM
+		105d 0009  Imagine 128 series 2e 4Mb DRAM
+		105d 000a  Imagine 128 series 2 8Mb VRAM
+		105d 000b  Imagine 128 series 2 8Mb H-VRAM
+		11a4 000a  Barco Metheus 5 Megapixel
+		13cc 0000  Barco Metheus 5 Megapixel
+		13cc 0004  Barco Metheus 5 Megapixel
+		13cc 0005  Barco Metheus 5 Megapixel
+		13cc 0006  Barco Metheus 5 Megapixel
+		13cc 0008  Barco Metheus 5 Megapixel
+		13cc 0009  Barco Metheus 5 Megapixel
+		13cc 000a  Barco Metheus 5 Megapixel
+		13cc 000c  Barco Metheus 5 Megapixel
+	493d  Imagine 128 T2R [Ticket to Ride]
+		11a4 000a  Barco Metheus 5 Megapixel, Dual Head
+		11a4 000b  Barco Metheus 5 Megapixel, Dual Head
+		13cc 0002  Barco Metheus 4 Megapixel, Dual Head
+		13cc 0003  Barco Metheus 5 Megapixel, Dual Head
+		13cc 0007  Barco Metheus 5 Megapixel, Dual Head
+		13cc 0008  Barco Metheus 5 Megapixel, Dual Head
+		13cc 0009  Barco Metheus 5 Megapixel, Dual Head
+		13cc 000a  Barco Metheus 5 Megapixel, Dual Head
+	5348  Revolution 4
+		105d 0037  Revolution IV-FP AGP (For SGI 1600SW)
+105e  Vtech Computers Ltd
+105f  Infotronic America Inc
+1060  United Microelectronics [UMC]
+	0001  UM82C881
+	0002  UM82C886
+	0101  UM8673F
+	0881  UM8881
+	0886  UM8886F
+	0891  UM8891A
+	1001  UM886A
+	673a  UM8886BF
+	673b  EIDE Master/DMA
+	8710  UM8710
+	886a  UM8886A
+	8881  UM8881F
+	8886  UM8886F
+	888a  UM8886A
+	8891  UM8891A
+	9017  UM9017F
+	9018  UM9018
+	9026  UM9026
+	e881  UM8881N
+	e886  UM8886N
+	e88a  UM8886N
+	e891  UM8891N
+1061  I.I.T.
+	0001  AGX016
+	0002  IIT3204/3501
+1062  Maspar Computer Corp
+1063  Ocean Office Automation
+1064  Alcatel
+1065  Texas Microsystems
+1066  PicoPower Technology
+	0000  PT80C826
+	0001  PT86C521 [Vesuvius v1] Host Bridge
+	0002  PT86C523 [Vesuvius v3] PCI-ISA Bridge Master
+	0003  PT86C524 [Nile] PCI-to-PCI Bridge
+	0004  PT86C525 [Nile-II] PCI-to-PCI Bridge
+	0005  National PC87550 System Controller
+	8002  PT86C523 [Vesuvius v3] PCI-ISA Bridge Slave
+1067  Mitsubishi Electric
+	0301  AccelGraphics AccelECLIPSE
+	0304  AccelGALAXY A2100 [OEM Evans & Sutherland]
+	0308  Tornado 3000 [OEM Evans & Sutherland]
+	1002  VG500 [VolumePro Volume Rendering Accelerator]
+1068  Diversified Technology
+1069  Mylex Corporation
+	0001  DAC960P
+	0002  DAC960PD
+	0010  DAC960PG
+	0020  DAC960LA
+	0050  AcceleRAID 352/170/160 support Device
+	b166  Gemstone chipset SCSI controller
+		1014 0242  iSeries 2872 DASD IOA
+		1014 0266  Dual Channel PCI-X U320 SCSI Adapter
+		1014 0278  Dual Channel PCI-X U320 SCSI RAID Adapter
+		1014 02d3  Dual Channel PCI-X U320 SCSI Adapter
+		1014 02d4  Dual Channel PCI-X U320 SCSI RAID Adapter
+	ba55  eXtremeRAID 1100 support Device
+	ba56  eXtremeRAID 2000/3000 support Device
+106a  Aten Research Inc
+106b  Apple Computer Inc.
+	0001  Bandit PowerPC host bridge
+	0002  Grand Central I/O
+	0003  Control Video
+	0004  PlanB Video-In
+	0007  O'Hare I/O
+	000c  DOS on Mac
+	000e  Hydra Mac I/O
+	0010  Heathrow Mac I/O
+	0017  Paddington Mac I/O
+	0018  UniNorth FireWire
+	0019  KeyLargo USB
+	001e  UniNorth Internal PCI
+	001f  UniNorth PCI
+	0020  UniNorth AGP
+	0021  UniNorth GMAC (Sun GEM)
+	0022  KeyLargo Mac I/O
+	0024  UniNorth/Pangea GMAC (Sun GEM)
+	0025  KeyLargo/Pangea Mac I/O
+	0026  KeyLargo/Pangea USB
+	0027  UniNorth/Pangea AGP
+	0028  UniNorth/Pangea PCI
+	0029  UniNorth/Pangea Internal PCI
+	002d  UniNorth 1.5 AGP
+	002e  UniNorth 1.5 PCI
+	002f  UniNorth 1.5 Internal PCI
+	0030  UniNorth/Pangea FireWire
+	0031  UniNorth 2 FireWire
+	0032  UniNorth 2 GMAC (Sun GEM)
+	0033  UniNorth 2 ATA/100
+	0034  UniNorth 2 AGP
+	0035  UniNorth 2 PCI
+	0036  UniNorth 2 Internal PCI
+	003b  UniNorth/Intrepid ATA/100
+	003e  KeyLargo/Intrepid Mac I/O
+	003f  KeyLargo/Intrepid USB
+	0040  K2 KeyLargo USB
+	0041  K2 KeyLargo Mac/IO
+	0042  K2 FireWire
+	0043  K2 ATA/100
+	0045  K2 HT-PCI Bridge
+	0046  K2 HT-PCI Bridge
+	0047  K2 HT-PCI Bridge
+	0048  K2 HT-PCI Bridge
+	0049  K2 HT-PCI Bridge
+	004b  U3 AGP
+	004c  K2 GMAC (Sun GEM)
+	004f  Shasta Mac I/O
+	0050  Shasta IDE
+	0051  Shasta (Sun GEM)
+	0052  Shasta Firewire
+	0053  Shasta PCI Bridge
+	0054  Shasta PCI Bridge
+	0055  Shasta PCI Bridge
+	0058  U3L AGP Bridge
+	1645  Tigon3 Gigabit Ethernet NIC (BCM5701)
+106c  Hynix Semiconductor
+	8801  Dual Pentium ISA/PCI Motherboard
+	8802  PowerPC ISA/PCI Motherboard
+	8803  Dual Window Graphics Accelerator
+	8804  LAN Controller
+	8805  100-BaseT LAN
+106d  Sequent Computer Systems
+106e  DFI, Inc
+106f  City Gate Development Ltd
+1070  Daewoo Telecom Ltd
+1071  Mitac
+	8160  Mitac 8060B Mobile Platform
+1072  GIT Co Ltd
+1073  Yamaha Corporation
+	0001  3D GUI Accelerator
+	0002  YGV615 [RPA3 3D-Graphics Controller]
+	0003  YMF-740
+	0004  YMF-724
+		1073 0004  YMF724-Based PCI Audio Adapter
+	0005  DS1 Audio
+		1073 0005  DS-XG PCI Audio CODEC
+	0006  DS1 Audio
+	0008  DS1 Audio
+		1073 0008  DS-XG PCI Audio CODEC
+	000a  DS1L Audio
+		1073 0004  DS-XG PCI Audio CODEC
+		1073 000a  DS-XG PCI Audio CODEC
+	000c  YMF-740C [DS-1L Audio Controller]
+		107a 000c  DS-XG PCI Audio CODEC
+	000d  YMF-724F [DS-1 Audio Controller]
+		1073 000d  DS-XG PCI Audio CODEC
+	0010  YMF-744B [DS-1S Audio Controller]
+		1073 0006  DS-XG PCI Audio CODEC
+		1073 0010  DS-XG PCI Audio CODEC
+	0012  YMF-754 [DS-1E Audio Controller]
+		1073 0012  DS-XG PCI Audio Codec
+	0020  DS-1 Audio
+	2000  DS2416 Digital Mixing Card
+		1073 2000  DS2416 Digital Mixing Card
+1074  NexGen Microsystems
+	4e78  82c500/1
+1075  Advanced Integrations Research
+1076  Chaintech Computer Co. Ltd
+1077  QLogic Corp.
+	1016  ISP10160 Single Channel Ultra3 SCSI Processor
+	1020  ISP1020 Fast-wide SCSI
+	1022  ISP1022 Fast-wide SCSI
+	1080  ISP1080 SCSI Host Adapter
+	1216  ISP12160 Dual Channel Ultra3 SCSI Processor
+		101e 8471  QLA12160 on AMI MegaRAID
+		101e 8493  QLA12160 on AMI MegaRAID
+	1240  ISP1240 SCSI Host Adapter
+	1280  ISP1280 SCSI Host Adapter
+	2020  ISP2020A Fast!SCSI Basic Adapter
+	2100  QLA2100 64-bit Fibre Channel Adapter
+		1077 0001  QLA2100 64-bit Fibre Channel Adapter
+	2200  QLA2200 64-bit Fibre Channel Adapter
+		1077 0002  QLA2200
+	2300  QLA2300 64-bit Fibre Channel Adapter
+	2312  QLA2312 Fibre Channel Adapter
+1078  Cyrix Corporation
+	0000  5510 [Grappa]
+	0001  PCI Master
+	0002  5520 [Cognac]
+	0100  5530 Legacy [Kahlua]
+	0101  5530 SMI [Kahlua]
+	0102  5530 IDE [Kahlua]
+	0103  5530 Audio [Kahlua]
+	0104  5530 Video [Kahlua]
+	0400  ZFMicro PCI Bridge
+	0401  ZFMicro Chipset SMI
+	0402  ZFMicro Chipset IDE
+	0403  ZFMicro Expansion Bus
+1079  I-Bus
+107a  NetWorth
+107b  Gateway 2000
+107c  LG Electronics [Lucky Goldstar Co. Ltd]
+107d  LeadTek Research Inc.
+	0000  P86C850
+	2134  WinFast 3D S320 II
+	2971  [GeForce FX 5900] WinFast A350 TDH MyViVo
+107e  Interphase Corporation
+	0001  5515 ATM Adapter [Flipper]
+	0002  100 VG AnyLan Controller
+	0004  5526 Fibre Channel Host Adapter
+	0005  x526 Fibre Channel Host Adapter
+	0008  5525/5575 ATM Adapter (155 Mbit) [Atlantic]
+	9003  5535-4P-BRI-ST
+	9007  5535-4P-BRI-U
+	9008  5535-1P-SR
+	900c  5535-1P-SR-ST
+	900e  5535-1P-SR-U
+	9011  5535-1P-PRI
+	9013  5535-2P-PRI
+	9023  5536-4P-BRI-ST
+	9027  5536-4P-BRI-U
+	9031  5536-1P-PRI
+	9033  5536-2P-PRI
+107f  Data Technology Corporation
+	0802  SL82C105
+1080  Contaq Microsystems
+	0600  82C599
+	c691  Cypress CY82C691
+	c693  82c693
+1081  Supermac Technology
+	0d47  Radius PCI to NuBUS Bridge
+1082  EFA Corporation of America
+1083  Forex Computer Corporation
+	0001  FR710
+1084  Parador
+1085  Tulip Computers Int.B.V.
+1086  J. Bond Computer Systems
+1087  Cache Computer
+1088  Microcomputer Systems (M) Son
+1089  Data General Corporation
+# Formerly Bit3 Computer Corp.
+108a  SBS Technologies
+	0001  VME Bridge Model 617
+	0010  VME Bridge Model 618
+	0040  dataBLIZZARD
+	3000  VME Bridge Model 2706
+108c  Oakleigh Systems Inc.
+108d  Olicom
+	0001  Token-Ring 16/4 PCI Adapter (3136/3137)
+	0002  16/4 Token Ring
+	0004  RapidFire 3139 Token-Ring 16/4 PCI Adapter
+		108d 0004  OC-3139/3140 RapidFire Token-Ring 16/4 Adapter
+	0005  GoCard 3250 Token-Ring 16/4 CardBus PC Card
+	0006  OC-3530 RapidFire Token-Ring 100
+	0007  RapidFire 3141 Token-Ring 16/4 PCI Fiber Adapter
+		108d 0007  OC-3141 RapidFire Token-Ring 16/4 Adapter
+	0008  RapidFire 3540 HSTR 100/16/4 PCI Adapter
+		108d 0008  OC-3540 RapidFire HSTR 100/16/4 Adapter
+	0011  OC-2315
+	0012  OC-2325
+	0013  OC-2183/2185
+	0014  OC-2326
+	0019  OC-2327/2250 10/100 Ethernet Adapter
+		108d 0016  OC-2327 Rapidfire 10/100 Ethernet Adapter
+		108d 0017  OC-2250 GoCard 10/100 Ethernet Adapter
+	0021  OC-6151/6152 [RapidFire ATM 155]
+	0022  ATM Adapter
+108e  Sun Microsystems Computer Corp.
+	0001  EBUS
+	1000  EBUS
+	1001  Happy Meal
+	1100  RIO EBUS
+	1101  RIO GEM
+	1102  RIO 1394
+	1103  RIO USB
+	1648  [bge] Gigabit Ethernet
+	2bad  GEM
+	5000  Simba Advanced PCI Bridge
+	5043  SunPCI Co-processor
+	8000  Psycho PCI Bus Module
+	8001  Schizo PCI Bus Module
+	8002  Schizo+ PCI Bus Module
+	a000  Ultra IIi
+	a001  Ultra IIe
+	a801  Tomatillo PCI Bus Module
+	abba  Cassini 10/100/1000
+108f  Systemsoft
+1090  Encore Computer Corporation
+1091  Intergraph Corporation
+	0020  3D graphics processor
+	0021  3D graphics processor w/Texturing
+	0040  3D graphics frame buffer
+	0041  3D graphics frame buffer
+	0060  Proprietary bus bridge
+	00e4  Powerstorm 4D50T
+	0720  Motion JPEG codec
+	07a0  Sun Expert3D-Lite Graphics Accelerator
+	1091  Sun Expert3D Graphics Accelerator
+1092  Diamond Multimedia Systems
+	00a0  Speedstar Pro SE
+	00a8  Speedstar 64
+	0550  Viper V550
+	08d4  Supra 2260 Modem
+	094c  SupraExpress 56i Pro
+	1092  Viper V330
+	6120  Maximum DVD
+	8810  Stealth SE
+	8811  Stealth 64/SE
+	8880  Stealth
+	8881  Stealth
+	88b0  Stealth 64
+	88b1  Stealth 64
+	88c0  Stealth 64
+	88c1  Stealth 64
+	88d0  Stealth 64
+	88d1  Stealth 64
+	88f0  Stealth 64
+	88f1  Stealth 64
+	9999  DMD-I0928-1 "Monster sound" sound chip
+1093  National Instruments
+	0160  PCI-DIO-96
+	0162  PCI-MIO-16XE-50
+	1170  PCI-MIO-16XE-10
+	1180  PCI-MIO-16E-1
+	1190  PCI-MIO-16E-4
+	1310  PCI-6602
+	1330  PCI-6031E
+	1350  PCI-6071E
+	14e0  PCI-6110
+	14f0  PCI-6111
+	17d0  PCI-6503
+	1870  PCI-6713
+	1880  PCI-6711
+	18b0  PCI-6052E
+	2410  PCI-6733
+	2890  PCI-6036E
+	2a60  PCI-6023E
+	2a70  PCI-6024E
+	2a80  PCI-6025E
+	2c80  PCI-6035E
+	2ca0  PCI-6034E
+	70b8  PCI-6251 [M Series - High Speed Multifunction DAQ]
+	b001  IMAQ-PCI-1408
+	b011  IMAQ-PXI-1408
+	b021  IMAQ-PCI-1424
+	b031  IMAQ-PCI-1413
+	b041  IMAQ-PCI-1407
+	b051  IMAQ-PXI-1407
+	b061  IMAQ-PCI-1411
+	b071  IMAQ-PCI-1422
+	b081  IMAQ-PXI-1422
+	b091  IMAQ-PXI-1411
+	c801  PCI-GPIB
+	c831  PCI-GPIB bridge
+1094  First International Computers [FIC]
+1095  Silicon Image, Inc. (formerly CMD Technology Inc)
+	0240  Adaptec AAR-1210SA SATA HostRAID Controller
+	0640  PCI0640
+	0643  PCI0643
+	0646  PCI0646
+	0647  PCI0647
+	0648  PCI0648
+	0649  SiI 0649 Ultra ATA/100 PCI to ATA Host Controller
+		0e11 005d  Integrated Ultra ATA-100 Dual Channel Controller
+		0e11 007e  Integrated Ultra ATA-100 IDE RAID Controller
+		101e 0649  AMI MegaRAID IDE 100 Controller
+	0650  PBC0650A
+	0670  USB0670
+		1095 0670  USB0670
+	0673  USB0673
+	0680  PCI0680 Ultra ATA-133 Host Controller
+		1095 3680  Winic W-680 (Silicon Image 680 based)
+	3112  SiI 3112 [SATALink/SATARaid] Serial ATA Controller
+		1095 3112  SiI 3112 SATALink Controller
+		1095 6112  SiI 3112 SATARaid Controller
+	3114  SiI 3114 [SATALink/SATARaid] Serial ATA Controller
+		1095 3114  SiI 3114 SATALink Controller
+		1095 6114  SiI 3114 SATARaid Controller
+	3124  SiI 3124 PCI-X Serial ATA Controller
+		1095 3124  SiI 3124 PCI-X Serial ATA Controller
+	3512  SiI 3512 [SATALink/SATARaid] Serial ATA Controller
+		1095 3512  SiI 3512 SATALink Controller
+		1095 6512  SiI 3512 SATARaid Controller
+1096  Alacron
+1097  Appian Technology
+1098  Quantum Designs (H.K.) Ltd
+	0001  QD-8500
+	0002  QD-8580
+1099  Samsung Electronics Co., Ltd
+109a  Packard Bell
+109b  Gemlight Computer Ltd.
+109c  Megachips Corporation
+109d  Zida Technologies Ltd.
+109e  Brooktree Corporation
+	0350  Bt848 Video Capture
+	0351  Bt849A Video capture
+	0369  Bt878 Video Capture
+		1002 0001  TV-Wonder
+		1002 0003  TV-Wonder/VE
+	036c  Bt879(??) Video Capture
+		13e9 0070  Win/TV (Video Section)
+	036e  Bt878 Video Capture
+		0070 13eb  WinTV Series
+		0070 ff01  Viewcast Osprey 200
+		0071 0101  DigiTV PCI
+		107d 6606  WinFast TV 2000
+		11bd 0012  PCTV pro (TV + FM stereo receiver)
+		11bd 001c  PCTV Sat (DBC receiver)
+		127a 0001  Bt878 Mediastream Controller NTSC
+		127a 0002  Bt878 Mediastream Controller PAL BG
+		127a 0003  Bt878a Mediastream Controller PAL BG
+		127a 0048  Bt878/832 Mediastream Controller
+		144f 3000  MagicTView CPH060 - Video
+		1461 0002  TV98 Series (TV/No FM/Remote)
+		1461 0003  AverMedia UltraTV PCI 350
+		1461 0004  AVerTV WDM Video Capture
+		1461 0761  AverTV DVB-T
+		14f1 0001  Bt878 Mediastream Controller NTSC
+		14f1 0002  Bt878 Mediastream Controller PAL BG
+		14f1 0003  Bt878a Mediastream Controller PAL BG
+		14f1 0048  Bt878/832 Mediastream Controller
+		1822 0001  VisionPlus DVB card
+		1851 1850  FlyVideo'98 - Video
+		1851 1851  FlyVideo II
+		1852 1852  FlyVideo'98 - Video (with FM Tuner)
+		270f fc00  Digitop DTT-1000
+		bd11 1200  PCTV pro (TV + FM stereo receiver)
+	036f  Bt879 Video Capture
+		127a 0044  Bt879 Video Capture NTSC
+		127a 0122  Bt879 Video Capture PAL I
+		127a 0144  Bt879 Video Capture NTSC
+		127a 0222  Bt879 Video Capture PAL BG
+		127a 0244  Bt879a Video Capture NTSC
+		127a 0322  Bt879 Video Capture NTSC
+		127a 0422  Bt879 Video Capture NTSC
+		127a 1122  Bt879 Video Capture PAL I
+		127a 1222  Bt879 Video Capture PAL BG
+		127a 1322  Bt879 Video Capture NTSC
+		127a 1522  Bt879a Video Capture PAL I
+		127a 1622  Bt879a Video Capture PAL BG
+		127a 1722  Bt879a Video Capture NTSC
+		14f1 0044  Bt879 Video Capture NTSC
+		14f1 0122  Bt879 Video Capture PAL I
+		14f1 0144  Bt879 Video Capture NTSC
+		14f1 0222  Bt879 Video Capture PAL BG
+		14f1 0244  Bt879a Video Capture NTSC
+		14f1 0322  Bt879 Video Capture NTSC
+		14f1 0422  Bt879 Video Capture NTSC
+		14f1 1122  Bt879 Video Capture PAL I
+		14f1 1222  Bt879 Video Capture PAL BG
+		14f1 1322  Bt879 Video Capture NTSC
+		14f1 1522  Bt879a Video Capture PAL I
+		14f1 1622  Bt879a Video Capture PAL BG
+		14f1 1722  Bt879a Video Capture NTSC
+		1851 1850  FlyVideo'98 - Video
+		1851 1851  FlyVideo II
+		1852 1852  FlyVideo'98 - Video (with FM Tuner)
+	0370  Bt880 Video Capture
+		1851 1850  FlyVideo'98
+		1851 1851  FlyVideo'98 EZ - video
+		1852 1852  FlyVideo'98 (with FM Tuner)
+	0878  Bt878 Audio Capture
+		0070 13eb  WinTV Series
+		0070 ff01  Viewcast Osprey 200
+		0071 0101  DigiTV PCI
+		1002 0001  TV-Wonder
+		1002 0003  TV-Wonder/VE
+		11bd 0012  PCTV pro (TV + FM stereo receiver, audio section)
+		11bd 001c  PCTV Sat (DBC receiver)
+		127a 0001  Bt878 Video Capture (Audio Section)
+		127a 0002  Bt878 Video Capture (Audio Section)
+		127a 0003  Bt878 Video Capture (Audio Section)
+		127a 0048  Bt878 Video Capture (Audio Section)
+		13e9 0070  Win/TV (Audio Section)
+		144f 3000  MagicTView CPH060 - Audio
+		1461 0004  AVerTV WDM Audio Capture
+		1461 0761  AVerTV DVB-T
+		14f1 0001  Bt878 Video Capture (Audio Section)
+		14f1 0002  Bt878 Video Capture (Audio Section)
+		14f1 0003  Bt878 Video Capture (Audio Section)
+		14f1 0048  Bt878 Video Capture (Audio Section)
+		1822 0001  VisionPlus DVB Card
+		270f fc00  Digitop DTT-1000
+		bd11 1200  PCTV pro (TV + FM stereo receiver, audio section)
+	0879  Bt879 Audio Capture
+		127a 0044  Bt879 Video Capture (Audio Section)
+		127a 0122  Bt879 Video Capture (Audio Section)
+		127a 0144  Bt879 Video Capture (Audio Section)
+		127a 0222  Bt879 Video Capture (Audio Section)
+		127a 0244  Bt879 Video Capture (Audio Section)
+		127a 0322  Bt879 Video Capture (Audio Section)
+		127a 0422  Bt879 Video Capture (Audio Section)
+		127a 1122  Bt879 Video Capture (Audio Section)
+		127a 1222  Bt879 Video Capture (Audio Section)
+		127a 1322  Bt879 Video Capture (Audio Section)
+		127a 1522  Bt879 Video Capture (Audio Section)
+		127a 1622  Bt879 Video Capture (Audio Section)
+		127a 1722  Bt879 Video Capture (Audio Section)
+		14f1 0044  Bt879 Video Capture (Audio Section)
+		14f1 0122  Bt879 Video Capture (Audio Section)
+		14f1 0144  Bt879 Video Capture (Audio Section)
+		14f1 0222  Bt879 Video Capture (Audio Section)
+		14f1 0244  Bt879 Video Capture (Audio Section)
+		14f1 0322  Bt879 Video Capture (Audio Section)
+		14f1 0422  Bt879 Video Capture (Audio Section)
+		14f1 1122  Bt879 Video Capture (Audio Section)
+		14f1 1222  Bt879 Video Capture (Audio Section)
+		14f1 1322  Bt879 Video Capture (Audio Section)
+		14f1 1522  Bt879 Video Capture (Audio Section)
+		14f1 1622  Bt879 Video Capture (Audio Section)
+		14f1 1722  Bt879 Video Capture (Audio Section)
+	0880  Bt880 Audio Capture
+	2115  BtV 2115 Mediastream controller
+	2125  BtV 2125 Mediastream controller
+	2164  BtV 2164
+	2165  BtV 2165
+	8230  Bt8230 ATM Segment/Reassembly Ctrlr (SRC)
+	8472  Bt8472
+	8474  Bt8474
+109f  Trigem Computer Inc.
+10a0  Meidensha Corporation
+10a1  Juko Electronics Ind. Co. Ltd
+10a2  Quantum Corporation
+10a3  Everex Systems Inc
+10a4  Globe Manufacturing Sales
+10a5  Smart Link Ltd.
+	3052  SmartPCI562 56K Modem
+	5449  SmartPCI561 modem
+10a6  Informtech Industrial Ltd.
+10a7  Benchmarq Microelectronics
+10a8  Sierra Semiconductor
+	0000  STB Horizon 64
+10a9  Silicon Graphics, Inc.
+	0001  Crosstalk to PCI Bridge
+	0002  Linc I/O controller
+	0003  IOC3 I/O controller
+	0004  O2 MACE
+	0005  RAD Audio
+	0006  HPCEX
+	0007  RPCEX
+	0008  DiVO VIP
+	0009  AceNIC Gigabit Ethernet
+		10a9 8002  AceNIC Gigabit Ethernet
+	0010  AMP Video I/O
+	0011  GRIP
+	0012  SGH PSHAC GSN
+	1001  Magic Carpet
+	1002  Lithium
+	1003  Dual JPEG 1
+	1004  Dual JPEG 2
+	1005  Dual JPEG 3
+	1006  Dual JPEG 4
+	1007  Dual JPEG 5
+	1008  Cesium
+	100a  IOC4 I/O controller
+	2001  Fibre Channel
+	2002  ASDE
+	8001  O2 1394
+	8002  G-net NT
+10aa  ACC Microelectronics
+	0000  ACCM 2188
+10ab  Digicom
+10ac  Honeywell IAC
+10ad  Symphony Labs
+	0001  W83769F
+	0003  SL82C103
+	0005  SL82C105
+	0103  SL82c103
+	0105  SL82c105
+	0565  W83C553
+10ae  Cornerstone Technology
+10af  Micro Computer Systems Inc
+10b0  CardExpert Technology
+10b1  Cabletron Systems Inc
+10b2  Raytheon Company
+10b3  Databook Inc
+	3106  DB87144
+	b106  DB87144
+10b4  STB Systems Inc
+	1b1d  Velocity 128 3D
+		10b4 237e  Velocity 4400
+10b5  PLX Technology, Inc.
+	0001  i960 PCI bus interface
+	1076  VScom 800 8 port serial adaptor
+	1077  VScom 400 4 port serial adaptor
+	1078  VScom 210 2 port serial and 1 port parallel adaptor
+	1103  VScom 200 2 port serial adaptor
+	1146  VScom 010 1 port parallel adaptor
+	1147  VScom 020 2 port parallel adaptor
+	2724  Thales PCSM Security Card
+	8516  PEX 8516  Versatile PCI Express Switch
+	8532  PEX 8532  Versatile PCI Express Switch
+	9030  PCI <-> IOBus Bridge Hot Swap
+		10b5 2862  Alpermann+Velte PCL PCI LV (3V/5V): Timecode Reader Board
+		10b5 2906  Alpermann+Velte PCI TS (3V/5V): Time Synchronisation Board
+		10b5 2940  Alpermann+Velte PCL PCI D (3V/5V): Timecode Reader Board
+		10b5 3025  Alpermann+Velte PCL PCI L (3V/5V): Timecode Reader Board
+		10b5 3068  Alpermann+Velte PCL PCI HD (3V/5V): Timecode Reader Board
+		15ed 1002  MCCS 8-port Serial Hot Swap
+		15ed 1003  MCCS 16-port Serial Hot Swap
+	9036  9036
+	9050  PCI <-> IOBus Bridge
+		10b5 1067  IXXAT CAN i165
+		10b5 1172  IK220 (Heidenhain)
+		10b5 2036  SatPak GPS
+		10b5 2221  Alpermann+Velte PCL PCI LV: Timecode Reader Board
+		10b5 2273  SH-ARC SoHard ARCnet card
+		10b5 2431  Alpermann+Velte PCL PCI D: Timecode Reader Board
+		10b5 2905  Alpermann+Velte PCI TS: Time Synchronisation Board
+		10b5 9050  MP9050
+		1498 0362  TPMC866 8 Channel Serial Card
+		1522 0001  RockForce 4 Port V.90 Data/Fax/Voice Modem
+		1522 0002  RockForce 2 Port V.90 Data/Fax/Voice Modem
+		1522 0003  RockForce 6 Port V.90 Data/Fax/Voice Modem
+		1522 0004  RockForce 8 Port V.90 Data/Fax/Voice Modem
+		1522 0010  RockForce2000 4 Port V.90 Data/Fax/Voice Modem
+		1522 0020  RockForce2000 2 Port V.90 Data/Fax/Voice Modem
+		15ed 1000  Macrolink MCCS 8-port Serial
+		15ed 1001  Macrolink MCCS 16-port Serial
+		15ed 1002  Macrolink MCCS 8-port Serial Hot Swap
+		15ed 1003  Macrolink MCCS 16-port Serial Hot Swap
+# Sorry, there was a typo
+		5654 2036  OpenSwitch 6 Telephony card
+# Sorry, there was a typo
+		5654 3132  OpenSwitch 12 Telephony card
+		5654 5634  OpenLine4 Telephony Card
+		d531 c002  PCIntelliCAN 2xSJA1000 CAN bus
+		d84d 4006  EX-4006 1P
+		d84d 4008  EX-4008 1P EPP/ECP
+		d84d 4014  EX-4014 2P
+		d84d 4018  EX-4018 3P EPP/ECP
+		d84d 4025  EX-4025 1S(16C550) RS-232
+		d84d 4027  EX-4027 1S(16C650) RS-232
+		d84d 4028  EX-4028 1S(16C850) RS-232
+		d84d 4036  EX-4036 2S(16C650) RS-232
+		d84d 4037  EX-4037 2S(16C650) RS-232
+		d84d 4038  EX-4038 2S(16C850) RS-232
+		d84d 4052  EX-4052 1S(16C550) RS-422/485
+		d84d 4053  EX-4053 2S(16C550) RS-422/485
+		d84d 4055  EX-4055 4S(16C550) RS-232
+		d84d 4058  EX-4055 4S(16C650) RS-232
+		d84d 4065  EX-4065 8S(16C550) RS-232
+		d84d 4068  EX-4068 8S(16C650) RS-232
+		d84d 4078  EX-4078 2S(16C552) RS-232+1P
+	9054  PCI <-> IOBus Bridge
+		10b5 2455  Wessex Techology PHIL-PCI
+		10b5 2696  Innes Corp AM Radcap card
+		10b5 2717  Innes Corp Auricon card
+		10b5 2844  Innes Corp TVS Encoder card
+		12d9 0002  PCI Prosody Card rev 1.5
+		16df 0011  PIKA PrimeNet MM PCI
+		16df 0012  PIKA PrimeNet MM cPCI 8
+		16df 0013  PIKA PrimeNet MM cPCI 8 (without CAS Signaling Option)
+		16df 0014  PIKA PrimeNet MM cPCI 4
+		16df 0015  PIKA Daytona MM
+		16df 0016  PIKA InLine MM
+	9056  Francois
+		10b5 2979  CellinkBlade 11 - CPCI board VoATM AAL1
+	9060  9060
+	906d  9060SD
+		125c 0640  Aries 16000P
+	906e  9060ES
+	9080  9080
+		103c 10eb  (Agilent) E2777B 83K Series PCI based Optical Communication Interface
+		103c 10ec  (Agilent) E6978-66442 PCI CIC
+		10b5 9080  9080 [real subsystem ID not set]
+		129d 0002  Aculab PCI Prosidy card
+		12d9 0002  PCI Prosody Card
+		12df 4422  4422PCI ["Do-All" Telemetry Data Aquisition System]
+	bb04  B&B 3PCIOSD1A Isolated PCI Serial
+10b6  Madge Networks
+	0001  Smart 16/4 PCI Ringnode
+	0002  Smart 16/4 PCI Ringnode Mk2
+		10b6 0002  Smart 16/4 PCI Ringnode Mk2
+		10b6 0006  16/4 CardBus Adapter
+	0003  Smart 16/4 PCI Ringnode Mk3
+		0e11 b0fd  Compaq NC4621 PCI, 4/16, WOL
+		10b6 0003  Smart 16/4 PCI Ringnode Mk3
+		10b6 0007  Presto PCI Plus Adapter
+	0004  Smart 16/4 PCI Ringnode Mk1
+	0006  16/4 Cardbus Adapter
+		10b6 0006  16/4 CardBus Adapter
+	0007  Presto PCI Adapter
+		10b6 0007  Presto PCI
+	0009  Smart 100/16/4 PCI-HS Ringnode
+		10b6 0009  Smart 100/16/4 PCI-HS Ringnode
+	000a  Smart 100/16/4 PCI Ringnode
+		10b6 000a  Smart 100/16/4 PCI Ringnode
+	000b  16/4 CardBus Adapter Mk2
+		10b6 0008  16/4 CardBus Adapter Mk2
+		10b6 000b  16/4 Cardbus Adapter Mk2
+	000c  RapidFire 3140V2 16/4 TR Adapter
+		10b6 000c  RapidFire 3140V2 16/4 TR Adapter
+	1000  Collage 25/155 ATM Client Adapter
+	1001  Collage 155 ATM Server Adapter
+10b7  3Com Corporation
+	0001  3c985 1000BaseSX (SX/TX)
+	0013  AR5212 802.11abg NIC (3CRDAG675)
+		10b7 2031  3CRDAG675 11a/b/g Wireless PCI Adapter
+	0910  3C910-A01
+	1006  MINI PCI type 3B Data Fax Modem
+	1007  Mini PCI 56k Winmodem
+		10b7 615c  Mini PCI 56K Modem
+	1201  3c982-TXM 10/100baseTX Dual Port A [Hydra]
+	1202  3c982-TXM 10/100baseTX Dual Port B [Hydra]
+	1700  3c940 10/100/1000Base-T [Marvell]
+		1043 80eb  P4P800/K8V Deluxe motherboard
+		10b7 0010  3C940 Gigabit LOM Ethernet Adapter
+		10b7 0020  3C941 Gigabit LOM Ethernet Adapter
+		147b 1407  KV8-MAX3 motherboard
+	3390  3c339 TokenLink Velocity
+	3590  3c359 TokenLink Velocity XL
+		10b7 3590  TokenLink Velocity XL Adapter (3C359/359B)
+	4500  3c450 HomePNA [Tornado]
+	5055  3c555 Laptop Hurricane
+	5057  3c575 Megahertz 10/100 LAN CardBus [Boomerang]
+		10b7 5a57  3C575 Megahertz 10/100 LAN Cardbus PC Card
+	5157  3cCFE575BT Megahertz 10/100 LAN CardBus [Cyclone]
+		10b7 5b57  3C575 Megahertz 10/100 LAN Cardbus PC Card
+	5257  3cCFE575CT CardBus [Cyclone]
+		10b7 5c57  FE575C-3Com 10/100 LAN CardBus-Fast Ethernet
+	5900  3c590 10BaseT [Vortex]
+	5920  3c592 EISA 10mbps Demon/Vortex
+	5950  3c595 100BaseTX [Vortex]
+	5951  3c595 100BaseT4 [Vortex]
+	5952  3c595 100Base-MII [Vortex]
+	5970  3c597 EISA Fast Demon/Vortex
+	5b57  3c595 Megahertz 10/100 LAN CardBus [Boomerang]
+		10b7 5b57  3C575 Megahertz 10/100 LAN Cardbus PC Card
+	6000  3CRSHPW796 [OfficeConnect Wireless CardBus]
+	6001  3com 3CRWE154G72 [Office Connect Wireless LAN Adapter]
+	6055  3c556 Hurricane CardBus [Cyclone]
+	6056  3c556B CardBus [Tornado]
+		10b7 6556  10/100 Mini PCI Ethernet Adapter
+	6560  3cCFE656 CardBus [Cyclone]
+		10b7 656a  3CCFEM656 10/100 LAN+56K Modem CardBus
+	6561  3cCFEM656 10/100 LAN+56K Modem CardBus
+		10b7 656b  3CCFEM656 10/100 LAN+56K Modem CardBus
+	6562  3cCFEM656B 10/100 LAN+Winmodem CardBus [Cyclone]
+		10b7 656b  3CCFEM656B 10/100 LAN+56K Modem CardBus
+	6563  3cCFEM656B 10/100 LAN+56K Modem CardBus
+		10b7 656b  3CCFEM656 10/100 LAN+56K Modem CardBus
+	6564  3cXFEM656C 10/100 LAN+Winmodem CardBus [Tornado]
+	7646  3cSOHO100-TX Hurricane
+	7770  3CRWE777 PCI(PLX) Wireless Adaptor [Airconnect]
+	7940  3c803 FDDILink UTP Controller
+	7980  3c804 FDDILink SAS Controller
+	7990  3c805 FDDILink DAS Controller
+	80eb  3c940B 10/100/1000Base-T
+	8811  Token ring
+	9000  3c900 10BaseT [Boomerang]
+	9001  3c900 10Mbps Combo [Boomerang]
+	9004  3c900B-TPO Etherlink XL [Cyclone]
+		10b7 9004  3C900B-TPO Etherlink XL TPO 10Mb
+	9005  3c900B-Combo Etherlink XL [Cyclone]
+		10b7 9005  3C900B-Combo Etherlink XL Combo
+	9006  3c900B-TPC Etherlink XL [Cyclone]
+	900a  3c900B-FL 10base-FL [Cyclone]
+	9050  3c905 100BaseTX [Boomerang]
+	9051  3c905 100BaseT4 [Boomerang]
+	9055  3c905B 100BaseTX [Cyclone]
+		1028 0080  3C905B Fast Etherlink XL 10/100
+		1028 0081  3C905B Fast Etherlink XL 10/100
+		1028 0082  3C905B Fast Etherlink XL 10/100
+		1028 0083  3C905B Fast Etherlink XL 10/100
+		1028 0084  3C905B Fast Etherlink XL 10/100
+		1028 0085  3C905B Fast Etherlink XL 10/100
+		1028 0086  3C905B Fast Etherlink XL 10/100
+		1028 0087  3C905B Fast Etherlink XL 10/100
+		1028 0088  3C905B Fast Etherlink XL 10/100
+		1028 0089  3C905B Fast Etherlink XL 10/100
+		1028 0090  3C905B Fast Etherlink XL 10/100
+		1028 0091  3C905B Fast Etherlink XL 10/100
+		1028 0092  3C905B Fast Etherlink XL 10/100
+		1028 0093  3C905B Fast Etherlink XL 10/100
+		1028 0094  3C905B Fast Etherlink XL 10/100
+		1028 0095  3C905B Fast Etherlink XL 10/100
+		1028 0096  3C905B Fast Etherlink XL 10/100
+		1028 0097  3C905B Fast Etherlink XL 10/100
+		1028 0098  3C905B Fast Etherlink XL 10/100
+		1028 0099  3C905B Fast Etherlink XL 10/100
+		10b7 9055  3C905B Fast Etherlink XL 10/100
+	9056  3c905B-T4 Fast EtherLink XL [Cyclone]
+	9058  3c905B Deluxe Etherlink 10/100/BNC [Cyclone]
+	905a  3c905B-FX Fast Etherlink XL FX 100baseFx [Cyclone]
+	9200  3c905C-TX/TX-M [Tornado]
+		1028 0095  3C920 Integrated Fast Ethernet Controller
+		1028 0097  3C920 Integrated Fast Ethernet Controller
+		1028 00fe  Optiplex GX240
+		1028 012a  3C920 Integrated Fast Ethernet Controller [Latitude C640]
+		10b7 1000  3C905C-TX Fast Etherlink for PC Management NIC
+		10b7 7000  10/100 Mini PCI Ethernet Adapter
+		10f1 2466  Tiger MPX S2466 (3C920 Integrated Fast Ethernet Controller)
+	9201  3C920B-EMB Integrated Fast Ethernet Controller [Tornado]
+		1043 80ab  A7N8X Deluxe onboard 3C920B-EMB Integrated Fast Ethernet Controller
+	9202  3Com 3C920B-EMB-WNM Integrated Fast Ethernet Controller
+	9210  3C920B-EMB-WNM Integrated Fast Ethernet Controller
+	9300  3CSOHO100B-TX 910-A01 [tulip]
+	9800  3c980-TX Fast Etherlink XL Server Adapter [Cyclone]
+		10b7 9800  3c980-TX Fast Etherlink XL Server Adapter
+	9805  3c980-C 10/100baseTX NIC [Python-T]
+		10b7 1201  EtherLink Server 10/100 Dual Port A
+		10b7 1202  EtherLink Server 10/100 Dual Port B
+		10b7 9805  3c980 10/100baseTX NIC [Python-T]
+		10f1 2462  Thunder K7 S2462
+	9900  3C990-TX [Typhoon]
+	9902  3CR990-TX-95 [Typhoon 56-bit]
+	9903  3CR990-TX-97 [Typhoon 168-bit]
+	9904  3C990B-TX-M/3C990BSVR [Typhoon2]
+		10b7 1000  3CR990B-TX-M [Typhoon2]
+		10b7 2000  3CR990BSVR [Typhoon2 Server]
+	9905  3CR990-FX-95/97/95 [Typhon Fiber]
+		10b7 1101  3CR990-FX-95 [Typhoon Fiber 56-bit]
+		10b7 1102  3CR990-FX-97 [Typhoon Fiber 168-bit]
+		10b7 2101  3CR990-FX-95 Server [Typhoon Fiber 56-bit]
+		10b7 2102  3CR990-FX-97 Server [Typhoon Fiber 168-bit]
+	9908  3CR990SVR95 [Typhoon Server 56-bit]
+	9909  3CR990SVR97 [Typhoon Server 168-bit]
+	990a  3C990SVR [Typhoon Server]
+	990b  3C990SVR [Typhoon Server]
+10b8  Standard Microsystems Corp [SMC]
+	0005  83c170 EPIC/100 Fast Ethernet Adapter
+		1055 e000  LANEPIC 10/100 [EVB171Q-PCI]
+		1055 e002  LANEPIC 10/100 [EVB171G-PCI]
+		10b8 a011  EtherPower II 10/100
+		10b8 a014  EtherPower II 10/100
+		10b8 a015  EtherPower II 10/100
+		10b8 a016  EtherPower II 10/100
+		10b8 a017  EtherPower II 10/100
+	0006  83c175 EPIC/100 Fast Ethernet Adapter
+		1055 e100  LANEPIC Cardbus Fast Ethernet Adapter
+		1055 e102  LANEPIC Cardbus Fast Ethernet Adapter
+		1055 e300  LANEPIC Cardbus Fast Ethernet Adapter
+		1055 e302  LANEPIC Cardbus Fast Ethernet Adapter
+		10b8 a012  LANEPIC Cardbus Fast Ethernet Adapter
+		13a2 8002  LANEPIC Cardbus Fast Ethernet Adapter
+		13a2 8006  LANEPIC Cardbus Fast Ethernet Adapter
+	1000  FDC 37c665
+	1001  FDC 37C922
+# 802.11g card
+	2802  SMC2802W [EZ Connect g]
+	a011  83C170QF
+	b106  SMC34C90
+10b9  ALi Corporation
+	0101  CMI8338/C3DX PCI Audio Device
+	0111  C-Media CMI8738/C3DX Audio Device (OEM)
+		10b9 0111  C-Media CMI8738/C3DX Audio Device (OEM)
+	0780  Multi-IO Card
+	0782  Multi-IO Card
+	1435  M1435
+	1445  M1445
+	1449  M1449
+	1451  M1451
+	1461  M1461
+	1489  M1489
+	1511  M1511 [Aladdin]
+	1512  M1512 [Aladdin]
+	1513  M1513 [Aladdin]
+	1521  M1521 [Aladdin III]
+		10b9 1521  ALI M1521 Aladdin III CPU Bridge
+	1523  M1523
+		10b9 1523  ALI M1523 ISA Bridge
+	1531  M1531 [Aladdin IV]
+	1533  M1533 PCI to ISA Bridge [Aladdin IV]
+		1014 053b  ThinkPad R40e (2684-HVG) PCI to ISA Bridge
+		10b9 1533  ALI M1533 Aladdin IV ISA Bridge
+	1541  M1541
+		10b9 1541  ALI M1541 Aladdin V/V+ AGP System Controller
+	1543  M1543
+	1563  M1563 HyperTransport South Bridge
+	1621  M1621
+	1631  ALI M1631 PCI North Bridge Aladdin Pro III
+	1632  M1632M Northbridge+Trident
+	1641  ALI M1641 PCI North Bridge Aladdin Pro IV
+	1644  M1644/M1644T Northbridge+Trident
+	1646  M1646 Northbridge+Trident
+	1647  M1647 Northbridge [MAGiK 1 / MobileMAGiK 1]
+	1651  M1651/M1651T Northbridge [Aladdin-Pro 5/5M,Aladdin-Pro 5T/5TM]
+	1671  M1671 Super P4 Northbridge [AGP4X,PCI and SDR/DDR]
+	1672  M1672 Northbridge [CyberALADDiN-P4]
+	1681  M1681 P4 Northbridge [AGP8X,HyperTransport and SDR/DDR]
+	1687  M1687 K8 Northbridge [AGP8X and HyperTransport]
+	1689  M1689 K8 Northbridge [Super K8 Single Chip]
+	3141  M3141
+	3143  M3143
+	3145  M3145
+	3147  M3147
+	3149  M3149
+	3151  M3151
+	3307  M3307
+	3309  M3309
+	3323  M3325 Video/Audio Decoder
+	5212  M4803
+	5215  MS4803
+	5217  M5217H
+	5219  M5219
+	5225  M5225
+	5228  M5228 ALi ATA/RAID Controller
+	5229  M5229 IDE
+		1014 050f  ThinkPad R30
+		1014 053d  ThinkPad R40e (2684-HVG) builtin IDE
+		103c 0024  Pavilion ze4400 builtin IDE
+		1043 8053  A7A266 Motherboard IDE
+	5235  M5225
+	5237  USB 1.1 Controller
+		1014 0540  ThinkPad R40e (2684-HVG) builtin USB
+		103c 0024  Pavilion ze4400 builtin USB
+	5239  USB 2.0 Controller
+	5243  M1541 PCI to AGP Controller
+	5246  AGP8X Controller
+	5247  PCI to AGP Controller
+	5249  M5249 HTT to PCI Bridge
+	5251  M5251 P1394 OHCI 1.0 Controller
+	5253  M5253 P1394 OHCI 1.1 Controller
+	5261  M5261 Ethernet Controller
+	5263  M5263 Ethernet Controller
+	5281  ALi M5281 Serial ATA / RAID Host Controller
+	5287  ULi 5287 SATA
+	5289  ULi 5289 SATA
+	5450  Lucent Technologies Soft Modem AMR
+	5451  M5451 PCI AC-Link Controller Audio Device
+		1014 0506  ThinkPad R30
+		1014 053e  ThinkPad R40e (2684-HVG) builtin Audio
+		103c 0024  Pavilion ze4400 builtin Audio
+		10b9 5451  HP Compaq nc4010 (DY885AA#ABN)
+	5453  M5453 PCI AC-Link Controller Modem Device
+	5455  M5455 PCI AC-Link Controller Audio Device
+	5457  M5457 AC'97 Modem Controller
+		1014 0535  ThinkPad R40e (2684-HVG) builtin modem
+		103c 0024  Pavilion ze4400 builtin Modem Device
+# Same but more usefull for driver's lookup
+	5459  SmartLink SmartPCI561 56K Modem
+# SmartLink PCI SoftModem
+	545a  SmartLink SmartPCI563 56K Modem
+	5471  M5471 Memory Stick Controller
+	5473  M5473 SD-MMC Controller
+	7101  M7101 Power Management Controller [PMU]
+		1014 0510  ThinkPad R30
+		1014 053c  ThinkPad R40e (2684-HVG) Power Management Controller
+		103c 0024  Pavilion ze4400
+10ba  Mitsubishi Electric Corp.
+	0301  AccelGraphics AccelECLIPSE
+	0304  AccelGALAXY A2100 [OEM Evans & Sutherland]
+	0308  Tornado 3000 [OEM Evans & Sutherland]
+	1002  VG500 [VolumePro Volume Rendering Accelerator]
+10bb  Dapha Electronics Corporation
+10bc  Advanced Logic Research
+10bd  Surecom Technology
+	0e34  NE-34
+10be  Tseng Labs International Co.
+10bf  Most Inc
+10c0  Boca Research Inc.
+10c1  ICM Co., Ltd.
+10c2  Auspex Systems Inc.
+10c3  Samsung Semiconductors, Inc.
+	1100  Smartether100 SC1100 LAN Adapter (i82557B)
+10c4  Award Software International Inc.
+10c5  Xerox Corporation
+10c6  Rambus Inc.
+10c7  Media Vision
+10c8  Neomagic Corporation
+	0001  NM2070 [MagicGraph 128]
+	0002  NM2090 [MagicGraph 128V]
+	0003  NM2093 [MagicGraph 128ZV]
+	0004  NM2160 [MagicGraph 128XD]
+		1014 00ba  MagicGraph 128XD
+		1025 1007  MagicGraph 128XD
+		1028 0074  MagicGraph 128XD
+		1028 0075  MagicGraph 128XD
+		1028 007d  MagicGraph 128XD
+		1028 007e  MagicGraph 128XD
+		1033 802f  MagicGraph 128XD
+		104d 801b  MagicGraph 128XD
+		104d 802f  MagicGraph 128XD
+		104d 830b  MagicGraph 128XD
+		10ba 0e00  MagicGraph 128XD
+		10c8 0004  MagicGraph 128XD
+		10cf 1029  MagicGraph 128XD
+		10f7 8308  MagicGraph 128XD
+		10f7 8309  MagicGraph 128XD
+		10f7 830b  MagicGraph 128XD
+		10f7 830d  MagicGraph 128XD
+		10f7 8312  MagicGraph 128XD
+	0005  NM2200 [MagicGraph 256AV]
+		1014 00dd  ThinkPad 570
+		1028 0088  Latitude CPi A
+	0006  NM2360 [MagicMedia 256ZX]
+	0016  NM2380 [MagicMedia 256XL+]
+		10c8 0016  MagicMedia 256XL+
+	0025  NM2230 [MagicGraph 256AV+]
+	0083  NM2093 [MagicGraph 128ZV+]
+	8005  NM2200 [MagicMedia 256AV Audio]
+		0e11 b0d1  MagicMedia 256AV Audio Device on Discovery
+		0e11 b126  MagicMedia 256AV Audio Device on Durango
+		1014 00dd  MagicMedia 256AV Audio Device on BlackTip Thinkpad
+		1025 1003  MagicMedia 256AV Audio Device on TravelMate 720
+		1028 0088  Latitude CPi A
+		1028 008f  MagicMedia 256AV Audio Device on Colorado Inspiron
+		103c 0007  MagicMedia 256AV Audio Device on Voyager II
+		103c 0008  MagicMedia 256AV Audio Device on Voyager III
+		103c 000d  MagicMedia 256AV Audio Device on Omnibook 900
+		10c8 8005  MagicMedia 256AV Audio Device on FireAnt
+		110a 8005  MagicMedia 256AV Audio Device
+		14c0 0004  MagicMedia 256AV Audio Device
+	8006  NM2360 [MagicMedia 256ZX Audio]
+	8016  NM2380 [MagicMedia 256XL+ Audio]
+10c9  Dataexpert Corporation
+10ca  Fujitsu Microelectr., Inc.
+10cb  Omron Corporation
+# nee Mentor ARC Inc
+10cc  Mai Logic Incorporated
+	0660  Articia S Host Bridge
+	0661  Articia S PCI Bridge
+10cd  Advanced System Products, Inc
+	1100  ASC1100
+	1200  ASC1200 [(abp940) Fast SCSI-II]
+	1300  ABP940-U / ABP960-U
+		10cd 1310  ASC1300 SCSI Adapter
+	2300  ABP940-UW
+	2500  ABP940-U2W
+10ce  Radius
+# nee Citicorp TTI
+10cf  Fujitsu Limited.
+	2001  mb86605
+10d1  FuturePlus Systems Corp.
+10d2  Molex Incorporated
+10d3  Jabil Circuit Inc
+10d4  Hualon Microelectronics
+10d5  Autologic Inc.
+10d6  Cetia
+10d7  BCM Advanced Research
+10d8  Advanced Peripherals Labs
+10d9  Macronix, Inc. [MXIC]
+	0431  MX98715
+	0512  MX98713
+	0531  MX987x5
+		1186 1200  DFE-540TX ProFAST 10/100 Adapter
+	8625  MX86250
+	8888  MX86200
+10da  Compaq IPG-Austin
+	0508  TC4048 Token Ring 4/16
+	3390  Tl3c3x9
+10db  Rohm LSI Systems, Inc.
+10dc  CERN/ECP/EDU
+	0001  STAR/RD24 SCI-PCI (PMC)
+	0002  TAR/RD24 SCI-PCI (PMC)
+	0021  HIPPI destination
+	0022  HIPPI source
+	10dc  ATT2C15-3 FPGA
+10dd  Evans & Sutherland
+10de  nVidia Corporation
+	0008  NV1 [EDGE 3D]
+	0009  NV1 [EDGE 3D]
+	0010  NV2 [Mutara V08]
+	0020  NV4 [RIVA TNT]
+		1043 0200  V3400 TNT
+		1048 0c18  Erazor II SGRAM
+		1048 0c1b  Erazor II
+		1092 0550  Viper V550
+		1092 0552  Viper V550
+		1092 4804  Viper V550
+		1092 4808  Viper V550
+		1092 4810  Viper V550
+		1092 4812  Viper V550
+		1092 4815  Viper V550
+		1092 4820  Viper V550 with TV out
+		1092 4822  Viper V550
+		1092 4904  Viper V550
+		1092 4914  Viper V550
+		1092 8225  Viper V550
+		10b4 273d  Velocity 4400
+		10b4 273e  Velocity 4400
+		10b4 2740  Velocity 4400
+		10de 0020  Riva TNT
+		1102 1015  Graphics Blaster CT6710
+		1102 1016  Graphics Blaster RIVA TNT
+	0028  NV5 [RIVA TNT2/TNT2 Pro]
+		1043 0200  AGP-V3800 SGRAM
+		1043 0201  AGP-V3800 SDRAM
+		1043 0205  PCI-V3800
+		1043 4000  AGP-V3800PRO
+		1048 0c21  Synergy II
+		1048 0c31  Erazor III
+		107d 2134  WinFast 3D S320 II + TV-Out
+		1092 4804  Viper V770
+		1092 4a00  Viper V770
+		1092 4a02  Viper V770 Ultra
+		1092 5a00  RIVA TNT2/TNT2 Pro
+		1092 6a02  Viper V770 Ultra
+		1092 7a02  Viper V770 Ultra
+		10de 0005  RIVA TNT2 Pro
+		10de 000f  Compaq NVIDIA TNT2 Pro
+		1102 1020  3D Blaster RIVA TNT2
+		1102 1026  3D Blaster RIVA TNT2 Digital
+		14af 5810  Maxi Gamer Xentor
+	0029  NV5 [RIVA TNT2 Ultra]
+		1043 0200  AGP-V3800 Deluxe
+		1043 0201  AGP-V3800 Ultra SDRAM
+		1043 0205  PCI-V3800 Ultra
+		1102 1021  3D Blaster RIVA TNT2 Ultra
+		1102 1029  3D Blaster RIVA TNT2 Ultra
+		1102 102f  3D Blaster RIVA TNT2 Ultra
+		14af 5820  Maxi Gamer Xentor 32
+	002a  NV5 [Riva TnT2]
+	002b  NV5 [Riva TnT2]
+	002c  NV6 [Vanta/Vanta LT]
+		1043 0200  AGP-V3800 Combat SDRAM
+		1043 0201  AGP-V3800 Combat
+		1092 6820  Viper V730
+		1102 1031  CT6938 VANTA 8MB
+		1102 1034  CT6894 VANTA 16MB
+		14af 5008  Maxi Gamer Phoenix 2
+	002d  NV5M64 [RIVA TNT2 Model 64/Model 64 Pro]
+		1043 0200  AGP-V3800M
+		1043 0201  AGP-V3800M
+		1048 0c3a  Erazor III LT
+		10de 001e  M64 AGP4x
+		1102 1023  CT6892 RIVA TNT2 Value
+		1102 1024  CT6932 RIVA TNT2 Value 32Mb
+		1102 102c  CT6931 RIVA TNT2 Value [Jumper]
+		1462 8808  MSI-8808
+		1554 1041  Pixelview RIVA TNT2 M64
+		1569 002d  Palit Microsystems Daytona TNT2 M64
+	002e  NV6 [Vanta]
+	002f  NV6 [Vanta]
+	0034  MCP04 SMBus
+	0035  MCP04 IDE
+	0036  MCP04 Serial ATA Controller
+	0037  MCP04 Ethernet Controller
+	0038  MCP04 Ethernet Controller
+	003a  MCP04 AC'97 Audio Controller
+	003b  MCP04 USB Controller
+	003c  MCP04 USB Controller
+	003d  MCP04 PCI Bridge
+	003e  MCP04 Serial ATA Controller
+	0040  nv40 [GeForce 6800 Ultra]
+	0041  NV40 [GeForce 6800]
+	0042  NV40.2
+	0043  NV40.3
+	0045  NV40 [GeForce 6800 GT]
+	0049  NV40GL
+	004e  NV40GL [Quadro FX 4000]
+	0051  CK804 ISA Bridge
+	0052  CK804 SMBus
+	0053  CK804 IDE
+	0054  CK804 Serial ATA Controller
+	0055  CK804 Serial ATA Controller
+	0056  CK804 Ethernet Controller
+	0057  CK804 Ethernet Controller
+	0059  CK804 AC'97 Audio Controller
+	005a  CK804 USB Controller
+	005b  CK804 USB Controller
+	005c  CK804 PCI Bridge
+	005d  CK804 PCIE Bridge
+	005e  CK804 Memory Controller
+	0060  nForce2 ISA Bridge
+		1043 80ad  A7N8X Mainboard
+	0064  nForce2 SMBus (MCP)
+	0065  nForce2 IDE
+	0066  nForce2 Ethernet Controller
+		1043 80a7  A7N8X Mainboard onboard nForce2 Ethernet
+	0067  nForce2 USB Controller
+		1043 0c11  A7N8X Mainboard
+	0068  nForce2 USB Controller
+		1043 0c11  A7N8X Mainboard
+	006a  nForce2 AC97 Audio Controler (MCP)
+	006b  nForce Audio Processing Unit
+		10de 006b  nForce2 MCP Audio Processing Unit
+	006c  nForce2 External PCI Bridge
+	006d  nForce2 PCI Bridge
+	006e  nForce2 FireWire (IEEE 1394) Controller
+	0084  MCP2A SMBus
+	0085  MCP2A IDE
+	0086  MCP2A Ethernet Controller
+	0087  MCP2A USB Controller
+	0088  MCP2A USB Controller
+	008a  MCP2S AC'97 Audio Controller
+	008b  MCP2A PCI Bridge
+	008c  MCP2A Ethernet Controller
+	008e  nForce2 Serial ATA Controller
+	00a0  NV5 [Aladdin TNT2]
+		14af 5810  Maxi Gamer Xentor
+	00c0  NV41.0
+	00c1  NV41.1
+	00c2  NV41.2
+	00c8  NV41.8
+	00ce  NV41GL
+	00d0  nForce3 LPC Bridge
+	00d1  nForce3 Host Bridge
+	00d2  nForce3 AGP Bridge
+	00d3  CK804 Memory Controller
+	00d4  nForce3 SMBus
+	00d5  nForce3 IDE
+	00d6  nForce3 Ethernet
+	00d7  nForce3 USB 1.1
+	00d8  nForce3 USB 2.0
+	00da  nForce3 Audio
+	00dd  nForce3 PCI Bridge
+	00df  CK8S Ethernet Controller
+	00e0  nForce3 250Gb LPC Bridge
+	00e1  nForce3 250Gb Host Bridge
+	00e2  nForce3 250Gb AGP Host to PCI Bridge
+	00e3  CK8S Serial ATA Controller (v2.5)
+	00e4  nForce 250Gb PCI System Management
+	00e5  CK8S Parallel ATA Controller (v2.5)
+	00e6  CK8S Ethernet Controller
+	00e7  CK8S USB Controller
+	00e8  nForce3 EHCI USB 2.0 Controller
+	00ea  nForce3 250Gb AC'97 Audio Controller
+	00ed  nForce3 250Gb PCI-to-PCI Bridge
+	00ee  CK8S Serial ATA Controller (v2.5)
+	00f0  NV40 [GeForce 6800/GeForce 6800 Ultra]
+	00f1  NV43 [GeForce 6600/GeForce 6600 GT]
+	00f2  NV43 [GeForce 6600 GT]
+	00f8  NV45GL [Quadro FX 3400]
+	00f9  NV40 [GeForce 6800 Ultra/GeForce 6800 GT]
+		1682 2120  GEFORCE 6800 GT PCI-E
+	00fa  NV36 [GeForce PCX 5750]
+	00fb  NV35 [GeForce PCX 5900]
+	00fc  NV37GL [Quadro FX 330/GeForce PCX 5300]
+	00fd  NV37GL [Quadro FX 330]
+	00fe  NV38GL [Quadro FX 1300]
+	00ff  NV18 [GeForce PCX 4300]
+	0100  NV10 [GeForce 256 SDR]
+		1043 0200  AGP-V6600 SGRAM
+		1043 0201  AGP-V6600 SDRAM
+		1043 4008  AGP-V6600 SGRAM
+		1043 4009  AGP-V6600 SDRAM
+		1102 102d  CT6941 GeForce 256
+		14af 5022  3D Prophet SE
+	0101  NV10DDR [GeForce 256 DDR]
+		1043 0202  AGP-V6800 DDR
+		1043 400a  AGP-V6800 DDR SGRAM
+		1043 400b  AGP-V6800 DDR SDRAM
+		107d 2822  WinFast GeForce 256
+		1102 102e  CT6971 GeForce 256 DDR
+		14af 5021  3D Prophet DDR-DVI
+	0103  NV10GL [Quadro]
+	0110  NV11 [GeForce2 MX/MX 400]
+		1043 4015  AGP-V7100 Pro
+		1043 4031  V7100 Pro with TV output
+		10de 0091  Dell OEM GeForce 2 MX 400
+		1462 8817  MSI GeForce2 MX400 Pro32S [MS-8817]
+		14af 7102  3D Prophet II MX
+		14af 7103  3D Prophet II MX Dual-Display
+	0111  NV11DDR [GeForce2 MX 100 DDR/200 DDR]
+	0112  NV11 [GeForce2 Go]
+	0113  NV11GL [Quadro2 MXR/EX]
+	0140  NV43 [MSI NX6600GT-TD128E]
+	014f  NV43 [GeForce 6200]
+	0150  NV15 [GeForce2 GTS/Pro]
+		1043 4016  V7700 AGP Video Card
+		107d 2840  WinFast GeForce2 GTS with TV output
+		107d 2842  WinFast GeForce 2 Pro
+		1462 8831  Creative GeForce2 Pro
+	0151  NV15DDR [GeForce2 Ti]
+		1043 405f  V7700Ti
+		1462 5506  Creative 3D Blaster Geforce2 Titanium
+	0152  NV15BR [GeForce2 Ultra, Bladerunner]
+		1048 0c56  GLADIAC Ultra
+	0153  NV15GL [Quadro2 Pro]
+	0170  NV17 [GeForce4 MX 460]
+	0171  NV17 [GeForce4 MX 440]
+		10b0 0002  Gainward Pro/600 TV
+		1462 8661  G4MX440-VTP
+		1462 8730  MX440SES-T (MS-8873)
+		147b 8f00  Abit Siluro GeForce4MX440
+	0172  NV17 [GeForce4 MX 420]
+	0173  NV17 [GeForce4 MX 440-SE]
+	0174  NV17 [GeForce4 440 Go]
+	0175  NV17 [GeForce4 420 Go]
+	0176  NV17 [GeForce4 420 Go 32M]
+		4c53 1090  Cx9 / Vx9 mainboard
+	0177  NV17 [GeForce4 460 Go]
+	0178  NV17GL [Quadro4 550 XGL]
+	0179  NV17 [GeForce4 440 Go 64M]
+		10de 0179  GeForce4 MX (Mac)
+	017a  NV17GL [Quadro4 200/400 NVS]
+	017b  NV17GL [Quadro4 550 XGL]
+	017c  NV17GL [Quadro4 550 GoGL]
+	017d  NV17 [GeForce4 410 Go 16M]
+	0181  NV18 [GeForce4 MX 440 AGP 8x]
+		1043 806f  V9180 Magic
+		1462 8880  MS-StarForce GeForce4 MX 440 with AGP8X
+		1462 8900  MS-8890 GeForce 4 MX440 AGP8X
+		1462 9350  MSI Geforce4 MX T8X with AGP8X
+		147b 8f0d  Siluro GF4 MX-8X
+	0182  NV18 [GeForce4 MX 440SE AGP 8x]
+	0183  NV18 [GeForce4 MX 420 AGP 8x]
+	0185  NV18 [GeForce4 MX 4000 AGP 8x]
+	0186  NV18M [GeForce4 448 Go]
+	0187  NV18M [GeForce4 488 Go]
+	0188  NV18GL [Quadro4 580 XGL]
+	018a  NV18GL [Quadro4 NVS AGP 8x]
+	018b  NV18GL [Quadro4 380 XGL]
+	018d  NV18M [GeForce4 448 Go]
+	01a0  NVCrush11 [GeForce2 MX Integrated Graphics]
+	01a4  nForce CPU bridge
+	01ab  nForce 420 Memory Controller (DDR)
+	01ac  nForce 220/420 Memory Controller
+	01ad  nForce 220/420 Memory Controller
+	01b0  nForce Audio
+	01b1  nForce Audio
+	01b2  nForce ISA Bridge
+	01b4  nForce PCI System Management
+	01b7  nForce AGP to PCI Bridge
+	01b8  nForce PCI-to-PCI bridge
+	01bc  nForce IDE
+	01c1  nForce AC'97 Modem Controller
+	01c2  nForce USB Controller
+	01c3  nForce Ethernet Controller
+	01e0  nForce2 AGP (different version?)
+	01e8  nForce2 AGP
+	01ea  nForce2 Memory Controller 0
+	01eb  nForce2 Memory Controller 1
+	01ec  nForce2 Memory Controller 2
+	01ed  nForce2 Memory Controller 3
+	01ee  nForce2 Memory Controller 4
+	01ef  nForce2 Memory Controller 5
+	01f0  NV18 [GeForce4 MX - nForce GPU]
+	0200  NV20 [GeForce3]
+		1043 402f  AGP-V8200 DDR
+	0201  NV20 [GeForce3 Ti 200]
+	0202  NV20 [GeForce3 Ti 500]
+		1043 405b  V8200 T5
+		1545 002f  Xtasy 6964
+	0203  NV20DCC [Quadro DCC]
+	0240  C51 PCI Express Bridge
+	0241  C51 PCI Express Bridge
+	0242  C51 PCI Express Bridge
+	0243  C51 PCI Express Bridge
+	0244  C51 PCI Express Bridge
+	0245  C51 PCI Express Bridge
+	0246  C51 PCI Express Bridge
+	0247  C51 PCI Express Bridge
+	0248  C51 PCI Express Bridge
+	0249  C51 PCI Express Bridge
+	024a  C51 PCI Express Bridge
+	024b  C51 PCI Express Bridge
+	024c  C51 PCI Express Bridge
+	024d  C51 PCI Express Bridge
+	024e  C51 PCI Express Bridge
+	024f  C51 PCI Express Bridge
+	0250  NV25 [GeForce4 Ti 4600]
+	0251  NV25 [GeForce4 Ti 4400]
+		1043 8023  v8440 GeForce 4 Ti4400
+	0252  NV25 [GeForce4 Ti]
+	0253  NV25 [GeForce4 Ti 4200]
+		107d 2896  WinFast A250 LE TD (Dual VGA/TV-out/DVI)
+		147b 8f09  Siluro (Dual VGA/TV-out/DVI)
+	0258  NV25GL [Quadro4 900 XGL]
+	0259  NV25GL [Quadro4 750 XGL]
+	025b  NV25GL [Quadro4 700 XGL]
+	0260  MCP51 LPC Bridge
+	0261  MCP51 LPC Bridge
+	0262  MCP51 LPC Bridge
+	0263  MCP51 LPC Bridge
+	0264  MCP51 SMBus
+	0265  MCP51 IDE
+	0266  MCP51 Serial ATA Controller
+	0267  MCP51 Serial ATA Controller
+	0268  MCP51 Ethernet Controller
+	0269  MCP51 Ethernet Controller
+	026a  MCP51 MCI
+	026b  MCP51 AC97 Audio Controller
+	026c  MCP51 High Definition Audio
+	026d  MCP51 USB Controller
+	026e  MCP51 USB Controller
+	026f  MCP51 PCI Bridge
+	0270  MCP51 Host Bridge
+	0271  MCP51 PMU
+	0272  MCP51 Memory Controller 0
+	027e  C51 Memory Controller 2
+	027f  C51 Memory Controller 3
+	0280  NV28 [GeForce4 Ti 4800]
+	0281  NV28 [GeForce4 Ti 4200 AGP 8x]
+	0282  NV28 [GeForce4 Ti 4800 SE]
+	0286  NV28 [GeForce4 Ti 4200 Go AGP 8x]
+	0288  NV28GL [Quadro4 980 XGL]
+	0289  NV28GL [Quadro4 780 XGL]
+	028c  NV28GLM [Quadro4 700 GoGL]
+	02f0  C51 Host Bridge
+	02f1  C51 Host Bridge
+	02f2  C51 Host Bridge
+	02f3  C51 Host Bridge
+	02f4  C51 Host Bridge
+	02f5  C51 Host Bridge
+	02f6  C51 Host Bridge
+	02f7  C51 Host Bridge
+	02f8  C51 Memory Controller 5
+	02f9  C51 Memory Controller 4
+	02fa  C51 Memory Controller 0
+	02fb  C51 PCI Express Bridge
+	02fc  C51 PCI Express Bridge
+	02fd  C51 PCI Express Bridge
+	02fe  C51 Memory Controller 1
+	02ff  C51 Host Bridge
+	0300  NV30 [GeForce FX]
+	0301  NV30 [GeForce FX 5800 Ultra]
+	0302  NV30 [GeForce FX 5800]
+	0308  NV30GL [Quadro FX 2000]
+	0309  NV30GL [Quadro FX 1000]
+	0311  NV31 [GeForce FX 5600 Ultra]
+	0312  NV31 [GeForce FX 5600]
+	0313  NV31
+	0314  NV31 [GeForce FX 5600XT]
+		1043 814a  V9560XT/TD
+	0316  NV31
+	0317  NV31
+	031a  NV31M [GeForce FX Go 5600]
+	031b  NV31M [GeForce FX Go5650]
+	031c  NVIDIA Quadro FX 700 Go
+	031d  NV31
+	031e  NV31
+	031f  NV31
+	0320  NV34 [GeForce FX 5200]
+	0321  NV34 [GeForce FX 5200 Ultra]
+	0322  NV34 [GeForce FX 5200]
+		1462 9171  MS-8917 (FX5200-T128)
+	0323  NV34 [GeForce FX 5200LE]
+	0324  NV34M [GeForce FX Go 5200]
+		1071 8160  MIM2000
+	0325  NV34M [GeForce FX Go5250]
+	0326  NV34 [GeForce FX 5500]
+	0327  NV34 [GeForce FX 5100]
+	0328  NV34M [GeForce FX Go 5200]
+	0329  NV34M [GeForce FX Go5200]
+	032a  NV34GL [Quadro NVS 280 PCI]
+	032b  NV34GL [Quadro FX 500/600 PCI]
+	032c  NV34GLM [GeForce FX Go 5300]
+	032d  NV34 [GeForce FX Go5100]
+	032f  NV34
+	0330  NV35 [GeForce FX 5900 Ultra]
+	0331  NV35 [GeForce FX 5900]
+		1043 8145  V9950GE
+	0332  NV35 [GeForce FX 5900XT]
+	0333  NV38 [GeForce FX 5950 Ultra]
+	0334  NV35 [GeForce FX 5900ZT]
+	0338  NV35GL [Quadro FX 3000]
+	033f  NV35GL [Quadro FX 700]
+	0341  NV36.1 [GeForce FX 5700 Ultra]
+	0342  NV36.2 [GeForce FX 5700]
+	0343  NV36 [GeForce FX 5700LE]
+	0344  NV36.4 [GeForce FX 5700VE]
+	0345  NV36.5
+	0347  NV36 [GeForce FX Go5700]
+	0348  NV36 [GeForce FX Go5700]
+	0349  NV36
+	034b  NV36
+	034c  NV36 [Quadro FX Go1000]
+	034e  NV36GL [Quadro FX 1100]
+	034f  NV36GL
+10df  Emulex Corporation
+	1ae5  LP6000 Fibre Channel Host Adapter
+	1ae6  LP 8000 Fibre Channel Host Adapter Alternate ID (JX1:2-3, JX2:1-2)
+	1ae7  LP 8000 Fibre Channel Host Adapter Alternate ID (JX1:2-3, JX2:2-3)
+	f005  LP1150e Fibre Channel Host Adapter
+	f085  LP850 Fibre Channel Host Adapter
+	f095  LP952 Fibre Channel Host Adapter
+	f098  LP982 Fibre Channel Host Adapter
+	f0a5  LP1050 Fibre Channel Host Adapter
+	f0d5  LP1150 Fibre Channel Host Adapter
+	f100  LP11000e Fibre Channel Host Adapter
+	f700  LP7000 Fibre Channel Host Adapter
+	f701  LP 7000EFibre Channel Host Adapter Alternate ID (JX1:2-3, JX2:1-2)
+	f800  LP8000 Fibre Channel Host Adapter
+	f801  LP 8000 Fibre Channel Host Adapter Alternate ID (JX1:2-3, JX2:1-2)
+	f900  LP9000 Fibre Channel Host Adapter
+	f901  LP 9000 Fibre Channel Host Adapter Alternate ID (JX1:2-3, JX2:1-2)
+	f980  LP9802 Fibre Channel Host Adapter
+	f981  LP 9802 Fibre Channel Host Adapter Alternate ID
+	f982  LP 9802 Fibre Channel Host Adapter Alternate ID
+	fa00  LP10000 Fibre Channel Host Adapter
+	fa01  LP101 Fibre Channel Host Adapter
+	fd00  LP11000 Fibre Channel Host Adapter
+10e0  Integrated Micro Solutions Inc.
+	5026  IMS5026/27/28
+	5027  IMS5027
+	5028  IMS5028
+	8849  IMS8849
+	8853  IMS8853
+	9128  IMS9128 [Twin turbo 128]
+10e1  Tekram Technology Co.,Ltd.
+	0391  TRM-S1040
+		10e1 0391  DC-315U SCSI-3 Host Adapter
+	690c  DC-690c
+	dc29  DC-290
+10e2  Aptix Corporation
+10e3  Tundra Semiconductor Corp.
+	0000  CA91C042 [Universe]
+	0860  CA91C860 [QSpan]
+	0862  CA91C862A [QSpan-II]
+	8260  CA91L8200B [Dual PCI PowerSpan II]
+	8261  CA91L8260B [Single PCI PowerSpan II]
+10e4  Tandem Computers
+10e5  Micro Industries Corporation
+10e6  Gainbery Computer Products Inc.
+10e7  Vadem
+10e8  Applied Micro Circuits Corp.
+	1072  INES GPIB-PCI (AMCC5920 based)
+	2011  Q-Motion Video Capture/Edit board
+	4750  S5930 [Matchmaker]
+	5920  S5920
+	8043  LANai4.x [Myrinet LANai interface chip]
+	8062  S5933_PARASTATION
+	807d  S5933 [Matchmaker]
+	8088  Kongsberg Spacetec Format Synchronizer
+	8089  Kongsberg Spacetec Serial Output Board
+	809c  S5933_HEPC3
+	80d7  PCI-9112
+	80d9  PCI-9118
+	80da  PCI-9812
+	811a  PCI-IEEE1355-DS-DE Interface
+	814c  Fastcom ESCC-PCI (Commtech, Inc.)
+	8170  S5933 [Matchmaker] (Chipset Development Tool)
+# sold with Roper Scientifc(Photometrics) CoolSnap HQ camera
+	81e6  Multimedia video controller
+	8291  Fastcom 232/8-PCI (Commtech, Inc.)
+	82c4  Fastcom 422/4-PCI (Commtech, Inc.)
+	82c5  Fastcom 422/2-PCI (Commtech, Inc.)
+	82c6  Fastcom IG422/1-PCI (Commtech, Inc.)
+	82c7  Fastcom IG232/2-PCI (Commtech, Inc.)
+	82ca  Fastcom 232/4-PCI (Commtech, Inc.)
+	82db  AJA HDNTV HD SDI Framestore
+	82e2  Fastcom DIO24H-PCI (Commtech, Inc.)
+	8851  S5933 on Innes Corp FM Radio Capture card
+10e9  Alps Electric Co., Ltd.
+10ea  Intergraphics Systems
+	1680  IGA-1680
+	1682  IGA-1682
+	1683  IGA-1683
+	2000  CyberPro 2000
+	2010  CyberPro 2000A
+	5000  CyberPro 5000
+	5050  CyberPro 5050
+	5202  CyberPro 5202
+# CyberPro5202 Audio Function
+	5252  CyberPro5252
+10eb  Artists Graphics
+	0101  3GA
+	8111  Twist3 Frame Grabber
+10ec  Realtek Semiconductor Co., Ltd.
+	8029  RTL-8029(AS)
+		10b8 2011  EZ-Card (SMC1208)
+		10ec 8029  RTL-8029(AS)
+		1113 1208  EN1208
+		1186 0300  DE-528
+		1259 2400  AT-2400
+	8129  RTL-8129
+		10ec 8129  RT8129 Fast Ethernet Adapter
+	8138  RT8139 (B/C) Cardbus Fast Ethernet Adapter
+		10ec 8138  RT8139 (B/C) Fast Ethernet Adapter
+	8139  RTL-8139/8139C/8139C+
+		0357 000a  TTP-Monitoring Card V2.0
+		1025 005a  TravelMate 290
+		1025 8920  ALN-325
+		1025 8921  ALN-325
+		1071 8160  MIM2000
+		10bd 0320  EP-320X-R
+		10ec 8139  RT8139
+		1113 ec01  FNC-0107TX
+		1186 1300  DFE-538TX
+		1186 1320  SN5200
+		1186 8139  DRN-32TX
+		11f6 8139  FN22-3(A) LinxPRO Ethernet Adapter
+		1259 2500  AT-2500TX
+		1259 2503  AT-2500TX/ACPI
+		1429 d010  ND010
+		1432 9130  EN-9130TX
+		1436 8139  RT8139
+		1458 e000  GA-7VM400M/7VT600 Motherboard
+		146c 1439  FE-1439TX
+		1489 6001  GF100TXRII
+		1489 6002  GF100TXRA
+		149c 139a  LFE-8139ATX
+		149c 8139  LFE-8139TX
+		14cb 0200  LNR-100 Family 10/100 Base-TX Ethernet
+		1799 5000  F5D5000 PCI Card/Desktop Network PCI Card
+		2646 0001  EtheRx
+		8e2e 7000  KF-230TX
+		8e2e 7100  KF-230TX/2
+		a0a0 0007  ALN-325C
+	8169  RTL-8169 Gigabit Ethernet
+		1259 c107  CG-LAPCIGT
+		1371 434e  ProG-2000L
+		1458 e000  GA-K8VT800 Pro Motherboard
+		1462 702c  K8T NEO 2 motherboard
+	8180  RTL8180L 802.11b MAC
+	8197  SmartLAN56 56K Modem
+10ed  Ascii Corporation
+	7310  V7310
+10ee  Xilinx Corporation
+	3fc0  RME Digi96
+	3fc1  RME Digi96/8
+	3fc2  RME Digi96/8 Pro
+	3fc3  RME Digi96/8 Pad
+	3fc4  RME Digi9652 (Hammerfall)
+	3fc5  RME Hammerfall DSP
+	3fc6  RME Hammerfall DSP MADI
+	8381  Ellips Santos Frame Grabber
+10ef  Racore Computer Products, Inc.
+	8154  M815x Token Ring Adapter
+10f0  Peritek Corporation
+10f1  Tyan Computer
+10f2  Achme Computer, Inc.
+10f3  Alaris, Inc.
+10f4  S-MOS Systems, Inc.
+10f5  NKK Corporation
+	a001  NDR4000 [NR4600 Bridge]
+10f6  Creative Electronic Systems SA
+10f7  Matsushita Electric Industrial Co., Ltd.
+10f8  Altos India Ltd
+10f9  PC Direct
+10fa  Truevision
+	000c  TARGA 1000
+10fb  Thesys Gesellschaft fr Mikroelektronik mbH
+	186f  TH 6255
+10fc  I-O Data Device, Inc.
+# What's in the cardbus end of a Sony ACR-A01 card, comes with newer Vaio CD-RW drives
+	0003  Cardbus IDE Controller
+	0005  Cardbus SCSI CBSC II
+10fd  Soyo Computer, Inc
+10fe  Fast Multimedia AG
+10ff  NCube
+1100  Jazz Multimedia
+1101  Initio Corporation
+	1060  INI-A100U2W
+	9100  INI-9100/9100W
+	9400  INI-940
+	9401  INI-950
+	9500  360P
+	9502  Initio INI-9100UW Ultra Wide SCSI Controller INIC-950P chip
+1102  Creative Labs
+	0002  SB Live! EMU10k1
+		1102 0020  CT4850 SBLive! Value
+		1102 0021  CT4620 SBLive!
+		1102 002f  SBLive! mainboard implementation
+		1102 4001  E-mu APS
+		1102 8022  CT4780 SBLive! Value
+		1102 8023  CT4790 SoundBlaster PCI512
+		1102 8024  CT4760 SBLive!
+		1102 8025  SBLive! Mainboard Implementation
+		1102 8026  CT4830 SBLive! Value
+		1102 8027  CT4832 SBLive! Value
+		1102 8028  CT4760 SBLive! OEM version
+		1102 8031  CT4831 SBLive! Value
+		1102 8040  CT4760 SBLive!
+		1102 8051  CT4850 SBLive! Value
+		1102 8061  SBLive! Player 5.1
+		1102 8064  SB Live! 5.1 Model SB0100
+		1102 8065  SBLive! 5.1 Digital Model SB0220
+		1102 8067  SBLive! 5.1 eMicro 28028
+	0004  SB Audigy
+		1102 0051  SB0090 Audigy Player
+		1102 0053  SB0090 Audigy Player/OEM
+		1102 0058  SB0090 Audigy Player/OEM
+		1102 1007  SB0240 Audigy 2 Platinum 6.1
+		1102 2002  SB Audigy 2 ZS (SB0350)
+	0006  [SB Live! Value] EMU10k1X
+	0007  SB Audigy LS
+		1102 1001  SB0310 Audigy LS
+		1102 1002  SB0312 Audigy LS
+		1102 1006  SB0410 SBLive! 24-bit
+	0008  SB0400 Audigy2 Value
+	4001  SB Audigy FireWire Port
+		1102 0010  SB Audigy FireWire Port
+	7002  SB Live! MIDI/Game Port
+		1102 0020  Gameport Joystick
+	7003  SB Audigy MIDI/Game port
+		1102 0040  SB Audigy MIDI/Game Port
+	7004  [SB Live! Value] Input device controller
+	7005  SB Audigy LS MIDI/Game port
+		1102 1001  SB0310 Audigy LS MIDI/Game port
+		1102 1002  SB0312 Audigy LS MIDI/Game port
+	8064  SB0100 [SBLive! 5.1 OEM]
+	8938  Ectiva EV1938
+		1033 80e5  SlimTower-Jim (NEC)
+		1071 7150  Mitac 7150
+		110a 5938  Siemens Scenic Mobile 510PIII
+		13bd 100c  Ceres-C (Sharp, Intel BX)
+		13bd 100d  Sharp, Intel Banister
+		13bd 100e  TwinHead P09S/P09S3 (Sharp)
+		13bd f6f1  Marlin (Sharp)
+		14ff 0e70  P88TE (TWINHEAD INTERNATIONAL Corp)
+		14ff c401  Notebook 9100/9200/2000 (TWINHEAD INTERNATIONAL Corp)
+		156d b400  G400 - Geo (AlphaTop (Taiwan))
+		156d b550  G560  (AlphaTop (Taiwan))
+		156d b560  G560  (AlphaTop (Taiwan))
+		156d b700  G700/U700  (AlphaTop (Taiwan))
+		156d b795  G795  (AlphaTop (Taiwan))
+		156d b797  G797  (AlphaTop (Taiwan))
+1103  Triones Technologies, Inc.
+	0003  HPT343
+	0004  HPT366/368/370/370A/372/372N
+		1103 0001  HPT370A
+		1103 0003  HPT343 / HPT345 / HPT363 UDMA33
+		1103 0004  HPT366 UDMA66 (r1) / HPT368 UDMA66 (r2) / HPT370 UDMA100 (r3) / HPT370 UDMA100 RAID (r4)
+		1103 0005  HPT370 UDMA100
+		1103 0006  HPT302
+		1103 0007  HPT371 UDMA133
+		1103 0008  HPT374 UDMA/ATA133 RAID Controller
+	0005  HPT372A/372N
+	0006  HPT302
+	0007  HPT371/371N
+	0008  HPT374
+	0009  HPT372N
+1104  RasterOps Corp.
+1105  Sigma Designs, Inc.
+	1105  REALmagic Xcard MPEG 1/2/3/4 DVD Decoder
+	8300  REALmagic Hollywood Plus DVD Decoder
+	8400  EM840x REALmagic DVD/MPEG-2 Audio/Video Decoder
+	8401  EM8401 REALmagic DVD/MPEG-2 A/V Decoder
+	8470  EM8470 REALmagic DVD/MPEG-4 A/V Decoder
+	8471  EM8471 REALmagic DVD/MPEG-4 A/V Decoder
+	8475  EM8475 REALmagic DVD/MPEG-4 A/V Decoder
+	8476  EM8476 REALmagic DVD/MPEG-4 A/V Decoder
+	8485  EM8485 REALmagic DVD/MPEG-4 A/V Decoder
+	8486  EM8486 REALmagic DVD/MPEG-4 A/V Decoder
+1106  VIA Technologies, Inc.
+	0102  Embedded VIA Ethernet Controller
+	0130  VT6305 1394.A Controller
+	0305  VT8363/8365 [KT133/KM133]
+		1043 8033  A7V Mainboard
+		1043 803e  A7V-E Mainboard
+		1043 8042  A7V133/A7V133-C Mainboard
+		147b a401  KT7/KT7-RAID/KT7A/KT7A-RAID Mainboard
+	0391  VT8371 [KX133]
+	0501  VT8501 [Apollo MVP4]
+	0505  VT82C505
+# Shares chip with :0576. The VT82C576M has :1571 instead of :0561.
+	0561  VT82C576MV
+	0571  VT82C586A/B/VT82C686/A/B/VT823x/A/C PIPC Bus Master IDE
+		1019 0985  P6VXA Motherboard
+		1019 0a81  L7VTA v1.0 Motherboard (KT400-8235)
+		1043 8052  VT8233A Bus Master ATA100/66/33 IDE
+		1043 808c  A7V8X motherboard
+		1043 80a1  A7V8X-X motherboard rev. 1.01
+		1043 80ed  A7V600 motherboard
+		1106 0571  VT82C586/B/VT82C686/A/B/VT8233/A/C/VT8235 PIPC Bus Master IDE
+		1179 0001  Magnia Z310
+		1297 f641  FX41 motherboard
+		1458 5002  GA-7VAX Mainboard
+		1462 7020  K8T NEO 2 motherboard
+		147b 1407  KV8-MAX3 motherboard
+		1849 0571  K7VT2 motherboard
+	0576  VT82C576 3V [Apollo Master]
+	0585  VT82C585VP [Apollo VP1/VPX]
+	0586  VT82C586/A/B PCI-to-ISA [Apollo VP]
+		1106 0000  MVP3 ISA Bridge
+	0595  VT82C595 [Apollo VP2]
+	0596  VT82C596 ISA [Mobile South]
+		1106 0000  VT82C596/A/B PCI to ISA Bridge
+		1458 0596  VT82C596/A/B PCI to ISA Bridge
+	0597  VT82C597 [Apollo VP3]
+	0598  VT82C598 [Apollo MVP3]
+	0601  VT8601 [Apollo ProMedia]
+	0605  VT8605 [ProSavage PM133]
+		1043 802c  CUV4X mainboard
+	0680  VT82C680 [Apollo P6]
+	0686  VT82C686 [Apollo Super South]
+		1019 0985  P6VXA Motherboard
+		1043 802c  CUV4X mainboard
+		1043 8033  A7V Mainboard
+		1043 803e  A7V-E Mainboard
+		1043 8040  A7M266 Mainboard
+		1043 8042  A7V133/A7V133-C Mainboard
+		1106 0000  VT82C686/A PCI to ISA Bridge
+		1106 0686  VT82C686/A PCI to ISA Bridge
+		1179 0001  Magnia Z310
+		147b a702  KG7-Lite Mainboard
+	0691  VT82C693A/694x [Apollo PRO133x]
+		1019 0985  P6VXA Motherboard
+		1179 0001  Magnia Z310
+		1458 0691  VT82C691 Apollo Pro System Controller
+	0693  VT82C693 [Apollo Pro Plus]
+	0698  VT82C693A [Apollo Pro133 AGP]
+	0926  VT82C926 [Amazon]
+	1000  VT82C570MV
+	1106  VT82C570MV
+	1571  VT82C576M/VT82C586
+	1595  VT82C595/97 [Apollo VP2/97]
+	3022  CLE266
+# This is *not* USB 2.0 as the existing entry suggests
+	3038  VT82xxxxx UHCI USB 1.1 Controller
+		0925 1234  USB Controller
+		1019 0985  P6VXA Motherboard
+		1019 0a81  L7VTA v1.0 Motherboard (KT400-8235)
+		1043 808c  VT6202 USB2.0 4 port controller
+		1043 80a1  A7V8X-X motherboard
+		1043 80ed  A7V600 motherboard
+		1179 0001  Magnia Z310
+		1458 5004  GA-7VAX Mainboard
+		1462 7020  K8T NEO 2 motherboard
+		147b 1407  KV8-MAX3 motherboard
+		182d 201d  CN-029 USB2.0 4 port PCI Card
+	3040  VT82C586B ACPI
+	3043  VT86C100A [Rhine]
+		10bd 0000  VT86C100A Fast Ethernet Adapter
+		1106 0100  VT86C100A Fast Ethernet Adapter
+		1186 1400  DFE-530TX rev A
+	3044  IEEE 1394 Host Controller
+		1025 005a  TravelMate 290
+		1458 1000  GA-7VT600-1394 Motherboard
+		1462 702d  K8T NEO 2 motherboard
+	3050  VT82C596 Power Management
+	3051  VT82C596 Power Management
+	3053  VT6105M [Rhine-III]
+	3057  VT82C686 [Apollo Super ACPI]
+		1019 0985  P6VXA Motherboard
+		1043 8033  A7V Mainboard
+		1043 803e  A7V-E Mainboard
+		1043 8040  A7M266 Mainboard
+		1043 8042  A7V133/A7V133-C Mainboard
+		1179 0001  Magnia Z310
+	3058  VT82C686 AC97 Audio Controller
+		0e11 0097  SoundMax Digital Integrated Audio
+		0e11 b194  Soundmax integrated digital audio
+		1019 0985  P6VXA Motherboard
+		1043 1106  A7V133/A7V133-C Mainboard
+		1106 4511  Onboard Audio on EP7KXA
+		1458 7600  Onboard Audio
+		1462 3091  MS-6309 Onboard Audio
+		1462 3300  MS-6330 Onboard Audio
+		15dd 7609  Onboard Audio
+	3059  VT8233/A/8235/8237 AC97 Audio Controller
+		1019 0a81  L7VTA v1.0 Motherboard (KT400-8235)
+		1043 8095  A7V8X Motherboard (Realtek ALC650 codec)
+		1043 80a1  A7V8X-X Motherboard
+		1043 80b0  A7V600/K8V Deluxe motherboard (ADI AD1980 codec [SoundMAX])
+		1106 3059  L7VMM2 Motherboard
+		1106 4161  K7VT2 motherboard
+		1297 c160  FX41 motherboard (Realtek ALC650 codec)
+		1458 a002  GA-7VAX Onboard Audio (Realtek ALC650)
+		1462 0080  K8T NEO 2 motherboard
+		1462 3800  KT266 onboard audio
+		147b 1407  KV8-MAX3 motherboard
+	3065  VT6102 [Rhine-II]
+		1043 80a1  A7V8X-X Motherboard
+		1106 0102  VT6102 [Rhine II] Embeded Ethernet Controller on VT8235
+		1186 1400  DFE-530TX rev A
+		1186 1401  DFE-530TX rev B
+		13b9 1421  LD-10/100AL PCI Fast Ethernet Adapter (rev.B)
+# This hosts more than just the Intel 537 codec, it also hosts PCtel (SIL33) and SmartLink (SIL34) codecs
+	3068  AC'97 Modem Controller
+		1462 309e  MS-6309 Saturn Motherboard
+	3074  VT8233 PCI to ISA Bridge
+		1043 8052  VT8233A
+	3091  VT8633 [Apollo Pro266]
+	3099  VT8366/A/7 [Apollo KT266/A/333]
+		1043 8064  A7V266-E Mainboard
+		1043 807f  A7V333 Mainboard
+		1849 3099  K7VT2 motherboard
+	3101  VT8653 Host Bridge
+	3102  VT8662 Host Bridge
+	3103  VT8615 Host Bridge
+	3104  USB 2.0
+		1019 0a81  L7VTA v1.0 Motherboard (KT400-8235)
+		1043 808c  A7V8X motherboard
+		1043 80a1  A7V8X-X motherboard rev 1.01
+		1043 80ed  A7V600 motherboard
+		1297 f641  FX41 motherboard
+		1458 5004  GA-7VAX Mainboard
+		1462 7020  K8T NEO 2 motherboard
+		147b 1407  KV8-MAX3 motherboard
+		182d 201d  CN-029 USB 2.0 4 port PCI Card
+	3106  VT6105 [Rhine-III]
+		1186 1403  DFE-530TX rev C
+	3108  S3 Unichrome Pro VGA Adapter
+	3109  VT8233C PCI to ISA Bridge
+	3112  VT8361 [KLE133] Host Bridge
+	3116  VT8375 [KM266/KL266] Host Bridge
+		1297 f641  FX41 motherboard
+	3118  S3 Unichrome Pro VGA Adapter
+	3119  VT6120/VT6121/VT6122 Gigabit Ethernet Adapter
+# found on EPIA M6000/9000 mainboard
+	3122  VT8623 [Apollo CLE266] integrated CastleRock graphics
+# found on EPIA M6000/9000 mainboard
+	3123  VT8623 [Apollo CLE266]
+	3128  VT8753 [P4X266 AGP]
+	3133  VT3133 Host Bridge
+	3147  VT8233A ISA Bridge
+	3148  P4M266 Host Bridge
+	3149  VIA VT6420 SATA RAID Controller
+		1043 80ed  A7V600/K8V Deluxe motherboard
+		1458 b003  GA-7VM400AM(F) Motherboard
+		1462 7020  K8T Neo 2 Motherboard
+		147b 1407  KV8-MAX3 motherboard
+	3156  P/KN266 Host Bridge
+# on ASUS P4P800
+	3164  VT6410 ATA133 RAID controller
+	3168  VT8374 P4X400 Host Controller/AGP Bridge
+	3177  VT8235 ISA Bridge
+		1019 0a81  L7VTA v1.0 Motherboard (KT400-8235)
+		1043 808c  A7V8X motherboard
+		1043 80a1  A7V8X-X motherboard
+		1297 f641  FX41 motherboard
+		1458 5001  GA-7VAX Mainboard
+		1849 3177  K7VT2 motherboard
+	3178  ProSavageDDR P4N333 Host Bridge
+	3188  VT8385 [K8T800 AGP] Host Bridge
+		1043 80a3  K8V Deluxe motherboard
+		147b 1407  KV8-MAX3 motherboard
+	3189  VT8377 [KT400/KT600 AGP] Host Bridge
+		1043 807f  A7V8X motherboard
+		1458 5000  GA-7VAX Mainboard
+	3204  K8M800
+	3205  VT8378 [KM400/A] Chipset Host Bridge
+		1458 5000  GA-7VM400M Motherboard
+	3218  K8T800M Host Bridge
+	3227  VT8237 ISA bridge [KT600/K8T800 South]
+		1043 80ed  A7V600 motherboard
+		1106 3227  DFI KT600-AL Motherboard
+		1458 5001  GA-7VT600 Motherboard
+		147b 1407  KV8-MAX3 motherboard
+	3249  VT6421 IDE RAID Controller
+	4149  VIA VT6420 (ATA133) Controller
+	5030  VT82C596 ACPI [Apollo PRO]
+	6100  VT85C100A [Rhine II]
+	7204  K8M800
+# S3 Graphics UniChrome 2D/3D Graphics with motion compensation
+	7205  VT8378 [S3 UniChrome] Integrated Video
+		1458 d000  Gigabyte GA-7VM400(A)M(F) Motherboard
+	8231  VT8231 [PCI-to-ISA Bridge]
+	8235  VT8235 ACPI
+	8305  VT8363/8365 [KT133/KM133 AGP]
+	8391  VT8371 [KX133 AGP]
+	8501  VT8501 [Apollo MVP4 AGP]
+	8596  VT82C596 [Apollo PRO AGP]
+	8597  VT82C597 [Apollo VP3 AGP]
+	8598  VT82C598/694x [Apollo MVP3/Pro133x AGP]
+		1019 0985  P6VXA Motherboard
+	8601  VT8601 [Apollo ProMedia AGP]
+	8605  VT8605 [PM133 AGP]
+	8691  VT82C691 [Apollo Pro]
+	8693  VT82C693 [Apollo Pro Plus] PCI Bridge
+	b091  VT8633 [Apollo Pro266 AGP]
+	b099  VT8366/A/7 [Apollo KT266/A/333 AGP]
+	b101  VT8653 AGP Bridge
+	b102  VT8362 AGP Bridge
+	b103  VT8615 AGP Bridge
+	b112  VT8361 [KLE133] AGP Bridge
+	b168  VT8235 PCI Bridge
+	b188  VT8237 PCI bridge [K8T800 South]
+		147b 1407  KV8-MAX3 motherboard
+	b198  VT8237 PCI Bridge
+# 32-Bit PCI bus master Ethernet MAC with standard MII interface
+	d104  VT8237 Integrated Fast Ethernet Controller
+1107  Stratus Computers
+	0576  VIA VT82C570MV [Apollo] (Wrong vendor ID!)
+1108  Proteon, Inc.
+	0100  p1690plus_AA
+	0101  p1690plus_AB
+	0105  P1690Plus
+	0108  P1690Plus
+	0138  P1690Plus
+	0139  P1690Plus
+	013c  P1690Plus
+	013d  P1690Plus
+1109  Cogent Data Technologies, Inc.
+	1400  EM110TX [EX110TX]
+110a  Siemens Nixdorf AG
+	0002  Pirahna 2-port
+	0005  Tulip controller, power management, switch extender
+	0006  FSC PINC (I/O-APIC)
+	0015  FSC Multiprocessor Interrupt Controller
+	001d  FSC Copernicus Management Controller
+	007b  FSC Remote Service Controller, mailbox device
+	007c  FSC Remote Service Controller, shared memory device
+	007d  FSC Remote Service Controller, SMIC device
+# Superfastcom-PCI (Commtech, Inc.) or DSCC4 WAN Adapter
+	2102  DSCC4 PEB/PEF 20534 DMA Supported Serial Communication Controller with 4 Channels
+	2104  Eicon Diva 2.02 compatible passive ISDN card
+	3142  SIMATIC NET CP 5613A1 (Profibus Adapter)
+	4021  SIMATIC NET CP 5512 (Profibus and MPI Cardbus Adapter)
+	4029  SIMATIC NET CP 5613A2 (Profibus Adapter)
+	4942  FPGA I-Bus Tracer for MBD
+	6120  SZB6120
+110b  Chromatic Research Inc.
+	0001  Mpact Media Processor
+	0004  Mpact 2
+110c  Mini-Max Technology, Inc.
+110d  Znyx Advanced Systems
+110e  CPU Technology
+110f  Ross Technology
+1110  Powerhouse Systems
+	6037  Firepower Powerized SMP I/O ASIC
+	6073  Firepower Powerized SMP I/O ASIC
+1111  Santa Cruz Operation
+# Also claimed to be RNS or Rockwell International, current PCISIG records list Osicom
+1112  Osicom Technologies Inc
+	2200  FDDI Adapter
+	2300  Fast Ethernet Adapter
+	2340  4 Port Fast Ethernet Adapter
+	2400  ATM Adapter
+1113  Accton Technology Corporation
+	1211  SMC2-1211TX
+		103c 1207  EN-1207D Fast Ethernet Adapter
+		1113 1211  EN-1207D Fast Ethernet Adapter
+	1216  EN-1216 Ethernet Adapter
+		1113 2242  EN2242 10/100 Ethernet Mini-PCI Card
+		111a 1020  SpeedStream 1020 PCI 10/100 Ethernet Adaptor [EN-1207F-TX ?]
+	1217  EN-1217 Ethernet Adapter
+	5105  10Mbps Network card
+	9211  EN-1207D Fast Ethernet Adapter
+		1113 9211  EN-1207D Fast Ethernet Adapter
+	9511  21x4x DEC-Tulip compatible Fast Ethernet
+	d301  CPWNA100 (Philips wireless PCMCIA)
+	ec02  SMC 1244TX v3
+1114  Atmel Corporation
+	0506  802.11b Wireless Network Adaptor (at76c506)
+1115  3D Labs
+1116  Data Translation
+	0022  DT3001
+	0023  DT3002
+	0024  DT3003
+	0025  DT3004
+	0026  DT3005
+	0027  DT3001-PGL
+	0028  DT3003-PGL
+1117  Datacube, Inc
+	9500  Max-1C SVGA card
+	9501  Max-1C image processing
+1118  Berg Electronics
+1119  ICP Vortex Computersysteme GmbH
+	0000  GDT 6000/6020/6050
+	0001  GDT 6000B/6010
+	0002  GDT 6110/6510
+	0003  GDT 6120/6520
+	0004  GDT 6530
+	0005  GDT 6550
+	0006  GDT 6117/6517
+	0007  GDT 6127/6527
+	0008  GDT 6537
+	0009  GDT 6557/6557-ECC
+	000a  GDT 6115/6515
+	000b  GDT 6125/6525
+	000c  GDT 6535
+	000d  GDT 6555
+	0010  GDT 6115/6515
+	0011  GDT 6125/6525
+	0012  GDT 6535
+	0013  GDT 6555/6555-ECC
+	0100  GDT 6117RP/6517RP
+	0101  GDT 6127RP/6527RP
+	0102  GDT 6537RP
+	0103  GDT 6557RP
+	0104  GDT 6111RP/6511RP
+	0105  GDT 6121RP/6521RP
+	0110  GDT 6117RD/6517RD
+	0111  GDT 6127RD/6527RD
+	0112  GDT 6537RD
+	0113  GDT 6557RD
+	0114  GDT 6111RD/6511RD
+	0115  GDT 6121RD/6521RD
+	0118  GDT 6118RD/6518RD/6618RD
+	0119  GDT 6128RD/6528RD/6628RD
+	011a  GDT 6538RD/6638RD
+	011b  GDT 6558RD/6658RD
+	0120  GDT 6117RP2/6517RP2
+	0121  GDT 6127RP2/6527RP2
+	0122  GDT 6537RP2
+	0123  GDT 6557RP2
+	0124  GDT 6111RP2/6511RP2
+	0125  GDT 6121RP2/6521RP2
+	0136  GDT 6113RS/6513RS
+	0137  GDT 6123RS/6523RS
+	0138  GDT 6118RS/6518RS/6618RS
+	0139  GDT 6128RS/6528RS/6628RS
+	013a  GDT 6538RS/6638RS
+	013b  GDT 6558RS/6658RS
+	013c  GDT 6533RS/6633RS
+	013d  GDT 6543RS/6643RS
+	013e  GDT 6553RS/6653RS
+	013f  GDT 6563RS/6663RS
+	0166  GDT 7113RN/7513RN/7613RN
+	0167  GDT 7123RN/7523RN/7623RN
+	0168  GDT 7118RN/7518RN/7518RN
+	0169  GDT 7128RN/7528RN/7628RN
+	016a  GDT 7538RN/7638RN
+	016b  GDT 7558RN/7658RN
+	016c  GDT 7533RN/7633RN
+	016d  GDT 7543RN/7643RN
+	016e  GDT 7553RN/7653RN
+	016f  GDT 7563RN/7663RN
+	01d6  GDT 4x13RZ
+	01d7  GDT 4x23RZ
+	01f6  GDT 8x13RZ
+	01f7  GDT 8x23RZ
+	01fc  GDT 8x33RZ
+	01fd  GDT 8x43RZ
+	01fe  GDT 8x53RZ
+	01ff  GDT 8x63RZ
+	0210  GDT 6519RD/6619RD
+	0211  GDT 6529RD/6629RD
+	0260  GDT 7519RN/7619RN
+	0261  GDT 7529RN/7629RN
+	02ff  GDT MAXRP
+	0300  GDT NEWRX
+111a  Efficient Networks, Inc
+	0000  155P-MF1 (FPGA)
+	0002  155P-MF1 (ASIC)
+	0003  ENI-25P ATM
+		111a 0000  ENI-25p Miniport ATM Adapter
+	0005  SpeedStream (LANAI)
+		111a 0001  ENI-3010 ATM
+		111a 0009  ENI-3060 ADSL (VPI=0)
+		111a 0101  ENI-3010 ATM
+		111a 0109  ENI-3060CO ADSL (VPI=0)
+		111a 0809  ENI-3060 ADSL (VPI=0 or 8)
+		111a 0909  ENI-3060CO ADSL (VPI=0 or 8)
+		111a 0a09  ENI-3060 ADSL (VPI=<0..15>)
+	0007  SpeedStream ADSL
+		111a 1001  ENI-3061 ADSL [ASIC]
+	1203  SpeedStream 1023 Wireless PCI Adapter
+111b  Teledyne Electronic Systems
+111c  Tricord Systems Inc.
+	0001  Powerbis Bridge
+111d  Integrated Device Technology, Inc.
+	0001  IDT77201/77211 155Mbps ATM SAR Controller [NICStAR]
+	0003  IDT77222/77252 155Mbps ATM MICRO ABR SAR Controller
+	0004  IDT77V252 155Mbps ATM MICRO ABR SAR Controller
+	0005  IDT77V222 155Mbps ATM MICRO ABR SAR Controller
+111e  Eldec
+111f  Precision Digital Images
+	4a47  Precision MX Video engine interface
+	5243  Frame capture bus interface
+1120  EMC Corporation
+1121  Zilog
+1122  Multi-tech Systems, Inc.
+1123  Excellent Design, Inc.
+1124  Leutron Vision AG
+1125  Eurocore
+1126  Vigra
+1127  FORE Systems Inc
+	0200  ForeRunner PCA-200 ATM
+	0210  PCA-200PC
+	0250  ATM
+	0300  ForeRunner PCA-200EPC ATM
+	0310  ATM
+	0400  ForeRunnerHE ATM Adapter
+		1127 0400  ForeRunnerHE ATM
+1129  Firmworks
+112a  Hermes Electronics Company, Ltd.
+112b  Linotype - Hell AG
+112c  Zenith Data Systems
+112d  Ravicad
+112e  Infomedia Microelectronics Inc.
+112f  Imaging Technology Inc
+	0000  MVC IC-PCI
+	0001  MVC IM-PCI Video frame grabber/processor
+1130  Computervision
+1131  Philips Semiconductors
+	1561  USB 1.1 Host Controller
+	1562  USB 2.0 Host Controller
+	3400  SmartPCI56(UCB1500) 56K Modem
+	5400  TriMedia TM1000/1100
+	5402  TriMedia TM-1300
+		1244 0f00  Fritz!Card DSL
+	7130  SAA7130 Video Broadcast Decoder
+		5168 0138  LiveView FlyVideo 2000
+	7133  SAA713X Audio+video broadcast decoder
+		5168 0138  LifeView FlyVideo 3000
+		5168 0212  LifeView FlyTV Platinum mini
+		5168 0502  LifeView FlyDVB-T Duo CardBus
+# PCI audio and video broadcast decoder (http://www.semiconductors.philips.com/pip/saa7134hl)
+	7134  SAA7134
+		1043 4842  TV-FM Card 7134
+	7135  SAA7135 Audio+video broadcast decoder
+	7145  SAA7145
+	7146  SAA7146
+		110a 0000  Fujitsu/Siemens DVB-C card rev1.5
+		110a ffff  Fujitsu/Siemens DVB-C card rev1.5
+		1131 4f56  KNC1 DVB-S Budget
+		1131 4f61  Fujitsu-Siemens Activy DVB-S Budget
+		114b 2003  DVRaptor Video Edit/Capture Card
+		11bd 0006  DV500 Overlay
+		11bd 000a  DV500 Overlay
+		11bd 000f  DV500 Overlay
+		13c2 0000  Siemens/Technotrend/Hauppauge DVB card rev1.3 or rev1.5
+		13c2 0001  Technotrend/Hauppauge DVB card rev1.3 or rev1.6
+		13c2 0002  Technotrend/Hauppauge DVB card rev2.1
+		13c2 0003  Technotrend/Hauppauge DVB card rev2.1
+		13c2 0004  Technotrend/Hauppauge DVB card rev2.1
+		13c2 0006  Technotrend/Hauppauge DVB card rev1.3 or rev1.6
+		13c2 0008  Technotrend/Hauppauge DVB-T
+		13c2 000a  Octal/Technotrend DVB-C for iTV
+		13c2 1003  Technotrend-Budget / Hauppauge WinTV-NOVA-S DVB card
+		13c2 1004  Technotrend-Budget / Hauppauge WinTV-NOVA-C DVB card
+		13c2 1005  Technotrend-Budget / Hauppauge WinTV-NOVA-T DVB card
+		13c2 100c  Technotrend-Budget / Hauppauge WinTV-NOVA-CI DVB card
+		13c2 100f  Technotrend-Budget / Hauppauge WinTV-NOVA-CI DVB card
+		13c2 1011  Technotrend-Budget / Hauppauge WinTV-NOVA-T DVB card
+		13c2 1013  SATELCO Multimedia DVB
+		13c2 1102  Technotrend/Hauppauge DVB card rev2.1
+	9730  SAA9730 Integrated Multimedia and Peripheral Controller
+		9730 0000  Integrated Multimedia and Peripheral Controller
+1132  Mitel Corp.
+# This is the new official company name. See disclaimer on www.eicon.com for details!
+1133  Eicon Networks Corporation
+	7901  EiconCard S90
+	7902  EiconCard S90
+	7911  EiconCard S91
+	7912  EiconCard S91
+	7941  EiconCard S94
+	7942  EiconCard S94
+	7943  EiconCard S94
+	7944  EiconCard S94
+	b921  EiconCard P92
+	b922  EiconCard P92
+	b923  EiconCard P92
+	e001  Diva Pro 2.0 S/T
+	e002  Diva 2.0 S/T PCI
+	e003  Diva Pro 2.0 U
+	e004  Diva 2.0 U PCI
+	e005  Diva 2.01 S/T PCI
+	e006  Diva CT S/T PCI
+	e007  Diva CT U PCI
+	e008  Diva CT Lite S/T PCI
+	e009  Diva CT Lite U PCI
+	e00a  Diva ISDN+V.90 PCI
+	e00b  Diva 2.02 PCI S/T
+	e00c  Diva 2.02 PCI U
+	e00d  Diva ISDN Pro 3.0 PCI
+	e00e  Diva ISDN+CT S/T PCI Rev 2
+	e010  Diva Server BRI-2M PCI
+		110a 0021  Fujitsu Siemens ISDN S0
+		8001 0014  Diva Server BRI-2M PCI Cornet NQ
+	e011  Diva Server BRI S/T Rev 2
+	e012  Diva Server 4BRI-8M PCI
+		8001 0014  Diva Server 4BRI-8M PCI Cornet NQ
+	e013  Diva Server 4BRI Rev 2
+		1133 1300  Diva Server V-4BRI-8
+		1133 e013  Diva Server 4BRI-8M 2.0 PCI
+		8001 0014  Diva Server 4BRI-8M 2.0 PCI Cornet NQ
+	e014  Diva Server PRI-30M PCI
+		0008 0100  Diva Server PRI-30M PCI
+		8001 0014  Diva Server PRI-30M PCI Cornet NQ
+	e015  DIVA Server PRI Rev 2
+		1133 e015  Diva Server PRI 2.0 PCI
+		8001 0014  Diva Server PRI 2.0 PCI Cornet NQ
+	e016  Diva Server Voice 4BRI PCI
+		8001 0014  Diva Server PRI Cornet NQ
+	e017  Diva Server Voice 4BRI Rev 2
+		1133 e017  Diva Server Voice 4BRI-8M 2.0 PCI
+		8001 0014  Diva Server Voice 4BRI-8M 2.0 PCI Cornet NQ
+	e018  Diva Server BRI-2M 2.0 PCI
+		1133 1800  Diva Server V-BRI-2
+		1133 e018  Diva Server BRI-2M 2.0 PCI
+		8001 0014  Diva Server BRI-2M 2.0 PCI Cornet NQ
+	e019  Diva Server Voice PRI Rev 2
+		1133 e019  Diva Server Voice PRI 2.0 PCI
+		8001 0014  Diva Server Voice PRI 2.0 PCI Cornet NQ
+	e01a  Diva Server 2FX
+	e01b  Diva Server Voice BRI-2M 2.0 PCI
+		1133 e01b  Diva Server Voice BRI-2M 2.0 PCI
+		8001 0014  Diva Server Voice BRI-2M 2.0 PCI Cornet NQ
+	e01c  Diva Server PRI Rev 3
+		1133 1c01  Diva Server PRI/E1/T1-8
+		1133 1c02  Diva Server PRI/T1-24
+		1133 1c03  Diva Server PRI/E1-30
+		1133 1c04  Diva Server PRI/E1/T1
+		1133 1c05  Diva Server V-PRI/T1-24
+		1133 1c06  Diva Server V-PRI/E1-30
+		1133 1c07  Diva Server PRI/E1/T1-8 Cornet NQ
+		1133 1c08  Diva Server PRI/T1-24 Cornet NQ
+		1133 1c09  Diva Server PRI/E1-30 Cornet NQ
+		1133 1c0a  Diva Server PRI/E1/T1 Cornet NQ
+		1133 1c0b  Diva Server V-PRI/T1-24 Cornet NQ
+		1133 1c0c  Diva Server V-PRI/E1-30 Cornet NQ
+	e01e  Diva Server 2PRI
+		1133 1e00  Diva Server V-2PRI/E1-60
+		1133 1e01  Diva Server V-2PRI/T1-48
+		1133 1e02  Diva Server 2PRI/E1-60
+		1133 1e03  Diva Server 2PRI/T1-48
+	e020  Diva Server 4PRI
+		1133 2000  Diva Server V-4PRI/E1-120
+		1133 2001  Diva Server V-4PRI/T1-96
+		1133 2002  Diva Server 4PRI/E1-120
+		1133 2003  Diva Server 4PRI/T1-96
+	e024  Diva Server Analog-4P
+		1133 2400  Diva Server V-Analog-4P
+		1133 e024  Diva Server Analog-4P
+	e028  Diva Server Analog-8P
+		1133 2800  Diva Server V-Analog-8P
+		1133 e028  Diva Server Analog-8P
+1134  Mercury Computer Systems
+	0001  Raceway Bridge
+	0002  Dual PCI to RapidIO Bridge
+1135  Fuji Xerox Co Ltd
+	0001  Printer controller
+1136  Momentum Data Systems
+1137  Cisco Systems Inc
+1138  Ziatech Corporation
+	8905  8905 [STD 32 Bridge]
+1139  Dynamic Pictures, Inc
+	0001  VGA Compatable 3D Graphics
+113a  FWB Inc
+113b  Network Computing Devices
+113c  Cyclone Microsystems, Inc.
+	0000  PCI-9060 i960 Bridge
+	0001  PCI-SDK [PCI i960 Evaluation Platform]
+	0911  PCI-911 [i960Jx-based Intelligent I/O Controller]
+	0912  PCI-912 [i960CF-based Intelligent I/O Controller]
+	0913  PCI-913
+	0914  PCI-914 [I/O Controller w/ secondary PCI bus]
+113d  Leading Edge Products Inc
+113e  Sanyo Electric Co - Computer Engineering Dept
+113f  Equinox Systems, Inc.
+	0808  SST-64P Adapter
+	1010  SST-128P Adapter
+	80c0  SST-16P DB Adapter
+	80c4  SST-16P RJ Adapter
+	80c8  SST-16P Adapter
+	8888  SST-4P Adapter
+	9090  SST-8P Adapter
+1140  Intervoice Inc
+1141  Crest Microsystem Inc
+1142  Alliance Semiconductor Corporation
+	3210  AP6410
+	6422  ProVideo 6422
+	6424  ProVideo 6424
+	6425  ProMotion AT25
+	643d  ProMotion AT3D
+1143  NetPower, Inc
+1144  Cincinnati Milacron
+	0001  Noservo controller
+1145  Workbit Corporation
+	8007  NinjaSCSI-32 Workbit
+	f007  NinjaSCSI-32 KME
+	f010  NinjaSCSI-32 Workbit
+	f012  NinjaSCSI-32 Logitec
+	f013  NinjaSCSI-32 Logitec
+	f015  NinjaSCSI-32 Melco
+1146  Force Computers
+1147  Interface Corp
+# Formerly (Schneider & Koch)
+1148  SysKonnect
+	4000  FDDI Adapter
+		0e11 b03b  Netelligent 100 FDDI DAS Fibre SC
+		0e11 b03c  Netelligent 100 FDDI SAS Fibre SC
+		0e11 b03d  Netelligent 100 FDDI DAS UTP
+		0e11 b03e  Netelligent 100 FDDI SAS UTP
+		0e11 b03f  Netelligent 100 FDDI SAS Fibre MIC
+		1148 5521  FDDI SK-5521 (SK-NET FDDI-UP)
+		1148 5522  FDDI SK-5522 (SK-NET FDDI-UP DAS)
+		1148 5541  FDDI SK-5541 (SK-NET FDDI-FP)
+		1148 5543  FDDI SK-5543 (SK-NET FDDI-LP)
+		1148 5544  FDDI SK-5544 (SK-NET FDDI-LP DAS)
+		1148 5821  FDDI SK-5821 (SK-NET FDDI-UP64)
+		1148 5822  FDDI SK-5822 (SK-NET FDDI-UP64 DAS)
+		1148 5841  FDDI SK-5841 (SK-NET FDDI-FP64)
+		1148 5843  FDDI SK-5843 (SK-NET FDDI-LP64)
+		1148 5844  FDDI SK-5844 (SK-NET FDDI-LP64 DAS)
+	4200  Token Ring adapter
+	4300  SK-98xx Gigabit Ethernet Server Adapter
+		1148 9821  SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+		1148 9822  SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+		1148 9841  SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+		1148 9842  SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+		1148 9843  SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+		1148 9844  SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+		1148 9861  SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+		1148 9862  SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
+		1148 9871  SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
+		1148 9872  SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+		1259 2970  AT-2970SX Gigabit Ethernet Adapter
+		1259 2971  AT-2970LX Gigabit Ethernet Adapter
+		1259 2972  AT-2970TX Gigabit Ethernet Adapter
+		1259 2973  AT-2971SX Gigabit Ethernet Adapter
+		1259 2974  AT-2971T Gigabit Ethernet Adapter
+		1259 2975  AT-2970SX/2SC Gigabit Ethernet Adapter
+		1259 2976  AT-2970LX/2SC Gigabit Ethernet Adapter
+		1259 2977  AT-2970TX/2TX Gigabit Ethernet Adapter
+	4320  SK-98xx V2.0 Gigabit Ethernet Adapter
+		1148 0121  Marvell RDK-8001 Adapter
+		1148 0221  Marvell RDK-8002 Adapter
+		1148 0321  Marvell RDK-8003 Adapter
+		1148 0421  Marvell RDK-8004 Adapter
+		1148 0621  Marvell RDK-8006 Adapter
+		1148 0721  Marvell RDK-8007 Adapter
+		1148 0821  Marvell RDK-8008 Adapter
+		1148 0921  Marvell RDK-8009 Adapter
+		1148 1121  Marvell RDK-8011 Adapter
+		1148 1221  Marvell RDK-8012 Adapter
+		1148 3221  SK-9521 V2.0 10/100/1000Base-T Adapter
+		1148 5021  SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
+		1148 5041  SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
+		1148 5043  SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+		1148 5051  SK-9851 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+		1148 5061  SK-9861 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+		1148 5071  SK-9871 V2.0 Gigabit Ethernet 1000Base-ZX Adapter
+		1148 9521  SK-9521 10/100/1000Base-T Adapter
+	4400  SK-9Dxx Gigabit Ethernet Adapter
+	4500  SK-9Mxx Gigabit Ethernet Adapter
+	9000  SK-9Sxx Gigabit Ethernet Server Adapter PCI-X
+	9843  [Fujitsu] Gigabit Ethernet
+	9e00  SK-9Exx 10/100/1000Base-T Adapter
+		1148 2100  SK-9E21 Server Adapter
+		1148 21d0  SK-9E21D 10/100/1000Base-T Adapter
+		1148 2200  SK-9E22 Server Adapter
+		1148 8100  SK-9E81 Server Adapter
+		1148 8200  SK-9E82 Server Adapter
+		1148 9100  SK-9E91 Server Adapter
+		1148 9200  SK-9E92 Server Adapter
+1149  Win System Corporation
+114a  VMIC
+	5579  VMIPCI-5579 (Reflective Memory Card)
+	5587  VMIPCI-5587 (Reflective Memory Card)
+	6504  VMIC PCI 7755 FPGA
+	7587  VMIVME-7587
+114b  Canopus Co., Ltd
+114c  Annabooks
+114d  IC Corporation
+114e  Nikon Systems Inc
+114f  Digi International
+	0002  AccelePort EPC
+	0003  RightSwitch SE-6
+	0004  AccelePort Xem
+	0005  AccelePort Xr
+	0006  AccelePort Xr,C/X
+	0009  AccelePort Xr/J
+	000a  AccelePort EPC/J
+	000c  DataFirePRIme T1 (1-port)
+	000d  SyncPort 2-Port (x.25/FR)
+	0011  AccelePort 8r EIA-232 (IBM)
+	0012  AccelePort 8r EIA-422
+	0013  AccelePort Xr
+	0014  AccelePort 8r EIA-422
+	0015  AccelePort Xem
+	0016  AccelePort EPC/X
+	0017  AccelePort C/X
+	001a  DataFirePRIme E1 (1-port)
+	001b  AccelePort C/X (IBM)
+	001d  DataFire RAS T1/E1/PRI
+		114f 0050  DataFire RAS E1 Adapter
+		114f 0051  DataFire RAS Dual E1 Adapter
+		114f 0052  DataFire RAS T1 Adapter
+		114f 0053  DataFire RAS Dual T1 Adapter
+	0023  AccelePort RAS
+	0024  DataFire RAS B4 ST/U
+		114f 0030  DataFire RAS BRI U Adapter
+		114f 0031  DataFire RAS BRI S/T Adapter
+	0026  AccelePort 4r 920
+	0027  AccelePort Xr 920
+	0028  ClassicBoard 4
+	0029  ClassicBoard 8
+	0034  AccelePort 2r 920
+	0035  DataFire DSP T1/E1/PRI cPCI
+	0040  AccelePort Xp
+	0042  AccelePort 2p
+	0043  AccelePort 4p
+	0044  AccelePort 8p
+	0045  AccelePort 16p
+	004e  AccelePort 32p
+	0070  Datafire Micro V IOM2 (Europe)
+	0071  Datafire Micro V (Europe)
+	0072  Datafire Micro V IOM2 (North America)
+	0073  Datafire Micro V (North America)
+	00b0  Digi Neo 4
+	00b1  Digi Neo 8
+	00c8  Digi Neo 2 DB9
+	00c9  Digi Neo 2 DB9 PRI
+	00ca  Digi Neo 2 RJ45
+	00cb  Digi Neo 2 RJ45 PRI
+	00d0  ClassicBoard 4 422
+	00d1  ClassicBoard 8 422
+	6001  Avanstar
+1150  Thinking Machines Corp
+1151  JAE Electronics Inc.
+1152  Megatek
+1153  Land Win Electronic Corp
+1154  Melco Inc
+1155  Pine Technology Ltd
+1156  Periscope Engineering
+1157  Avsys Corporation
+1158  Voarx R & D Inc
+	3011  Tokenet/vg 1001/10m anylan
+	9050  Lanfleet/Truevalue
+	9051  Lanfleet/Truevalue
+1159  Mutech Corp
+	0001  MV-1000
+115a  Harlequin Ltd
+115b  Parallax Graphics
+115c  Photron Ltd.
+115d  Xircom
+	0003  Cardbus Ethernet 10/100
+		1014 0181  10/100 EtherJet Cardbus Adapter
+		1014 1181  10/100 EtherJet Cardbus Adapter
+		1014 8181  10/100 EtherJet Cardbus Adapter
+		1014 9181  10/100 EtherJet Cardbus Adapter
+		115d 0181  Cardbus Ethernet 10/100
+		115d 1181  Cardbus Ethernet 10/100
+		1179 0181  Cardbus Ethernet 10/100
+		8086 8181  EtherExpress PRO/100 Mobile CardBus 32 Adapter
+		8086 9181  EtherExpress PRO/100 Mobile CardBus 32 Adapter
+	0005  Cardbus Ethernet 10/100
+		1014 0182  10/100 EtherJet Cardbus Adapter
+		1014 1182  10/100 EtherJet Cardbus Adapter
+		115d 0182  Cardbus Ethernet 10/100
+		115d 1182  Cardbus Ethernet 10/100
+	0007  Cardbus Ethernet 10/100
+		1014 0182  10/100 EtherJet Cardbus Adapter
+		1014 1182  10/100 EtherJet Cardbus Adapter
+		115d 0182  Cardbus Ethernet 10/100
+		115d 1182  Cardbus Ethernet 10/100
+	000b  Cardbus Ethernet 10/100
+		1014 0183  10/100 EtherJet Cardbus Adapter
+		115d 0183  Cardbus Ethernet 10/100
+	000c  Mini-PCI V.90 56k Modem
+	000f  Cardbus Ethernet 10/100
+		1014 0183  10/100 EtherJet Cardbus Adapter
+		115d 0183  Cardbus Ethernet 10/100
+	00d4  Mini-PCI K56Flex Modem
+	0101  Cardbus 56k modem
+		115d 1081  Cardbus 56k Modem
+	0103  Cardbus Ethernet + 56k Modem
+		1014 9181  Cardbus 56k Modem
+		1115 1181  Cardbus Ethernet 100 + 56k Modem
+		115d 1181  CBEM56G-100 Ethernet + 56k Modem
+		8086 9181  PRO/100 LAN + Modem56 CardBus
+115e  Peer Protocols Inc
+115f  Maxtor Corporation
+1160  Megasoft Inc
+1161  PFU Limited
+1162  OA Laboratory Co Ltd
+1163  Rendition
+	0001  Verite 1000
+	2000  Verite V2000/V2100/V2200
+		1092 2000  Stealth II S220
+1164  Advanced Peripherals Technologies
+1165  Imagraph Corporation
+	0001  Motion TPEG Recorder/Player with audio
+1166  ServerWorks
+	0000  CMIC-LE
+	0005  CNB20-LE Host Bridge
+	0006  CNB20HE Host Bridge
+	0007  CNB20-LE Host Bridge
+	0008  CNB20HE Host Bridge
+	0009  CNB20LE Host Bridge
+	0010  CIOB30
+	0011  CMIC-HE
+	0012  CMIC-WS Host Bridge (GC-LE chipset)
+	0013  CNB20-HE Host Bridge
+	0014  CMIC-LE Host Bridge (GC-LE chipset)
+	0015  CMIC-GC Host Bridge
+	0016  CMIC-GC Host Bridge
+	0017  GCNB-LE Host Bridge
+	0101  CIOB-X2 PCI-X I/O Bridge
+	0110  CIOB-E I/O Bridge with Gigabit Ethernet
+	0200  OSB4 South Bridge
+	0201  CSB5 South Bridge
+		4c53 1080  CT8 mainboard
+	0203  CSB6 South Bridge
+	0211  OSB4 IDE Controller
+	0212  CSB5 IDE Controller
+		4c53 1080  CT8 mainboard
+	0213  CSB6 RAID/IDE Controller
+	0217  CSB6 IDE Controller
+	0220  OSB4/CSB5 OHCI USB Controller
+		4c53 1080  CT8 mainboard
+	0221  CSB6 OHCI USB Controller
+	0225  CSB5 LPC bridge
+# cancelled
+		4c53 1080  CT8 mainboard
+	0227  GCLE-2 Host Bridge
+	0230  CSB5 LPC bridge
+		4c53 1080  CT8 mainboard
+	0240  K2 SATA
+	0241  K2 SATA
+	0242  K2 SATA
+1167  Mutoh Industries Inc
+1168  Thine Electronics Inc
+1169  Centre for Development of Advanced Computing
+116a  Polaris Communications
+	6100  Bus/Tag Channel
+	6800  Escon Channel
+	7100  Bus/Tag Channel
+	7800  Escon Channel
+116b  Connectware Inc
+116c  Intelligent Resources Integrated Systems
+116d  Martin-Marietta
+116e  Electronics for Imaging
+116f  Workstation Technology
+1170  Inventec Corporation
+1171  Loughborough Sound Images Plc
+1172  Altera Corporation
+1173  Adobe Systems, Inc
+1174  Bridgeport Machines
+1175  Mitron Computer Inc.
+1176  SBE Incorporated
+1177  Silicon Engineering
+1178  Alfa, Inc.
+	afa1  Fast Ethernet Adapter
+1179  Toshiba America Info Systems
+	0103  EX-IDE Type-B
+	0404  DVD Decoder card
+	0406  Tecra Video Capture device
+	0407  DVD Decoder card (Version 2)
+	0601  CPU to PCI bridge
+	0603  ToPIC95 PCI to CardBus Bridge for Notebooks
+	060a  ToPIC95
+	060f  ToPIC97
+	0617  ToPIC100 PCI to Cardbus Bridge with ZV Support
+	0618  CPU to PCI and PCI to ISA bridge
+# Claimed to be Lucent DSP1645 [Mars], but that's apparently incorrect. Does anyone know the correct ID?
+	0701  FIR Port
+	0804  TC6371AF SmartMedia Controller
+	0805  SD TypA Controller
+	0d01  FIR Port Type-DO
+		1179 0001  FIR Port Type-DO
+117a  A-Trend Technology
+117b  L G Electronics, Inc.
+117c  Atto Technology
+117d  Becton & Dickinson
+117e  T/R Systems
+117f  Integrated Circuit Systems
+1180  Ricoh Co Ltd
+	0465  RL5c465
+	0466  RL5c466
+	0475  RL5c475
+		144d c006  vpr Matrix 170B4 CardBus bridge
+	0476  RL5c476 II
+		1014 0185  ThinkPad A/T/X Series
+		104d 80df  Vaio PCG-FX403
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		14ef 0220  PCD-RP-220S
+	0477  RL5c477
+	0478  RL5c478
+		1014 0184  ThinkPad A30p (2653-64G)
+	0522  R5C522 IEEE 1394 Controller
+		1014 01cf  ThinkPad A30p (2653-64G)
+	0551  R5C551 IEEE 1394 Controller
+		144d c006  vpr Matrix 170B4
+	0552  R5C552 IEEE 1394 Controller
+		1014 0511  ThinkPad A/T/X Series
+	0576  R5C576 SD Bus Host Adapter
+	0592  R5C592 Memory Stick Bus Host Adapter
+1181  Telmatics International
+1183  Fujikura Ltd
+1184  Forks Inc
+1185  Dataworld International Ltd
+1186  D-Link System Inc
+	0100  DC21041
+	1002  DL10050 Sundance Ethernet
+		1186 1002  DFE-550TX
+		1186 1012  DFE-580TX
+	1025  AirPlus Xtreme G DWL-G650 Adapter
+	1026  AirXpert DWL-AG650 Wireless Cardbus Adapter
+	1043  AirXpert DWL-AG650 Wireless Cardbus Adapter
+	1300  RTL8139 Ethernet
+		1186 1300  DFE-538TX 10/100 Ethernet Adapter
+		1186 1301  DFE-530TX+ 10/100 Ethernet Adapter
+	1340  DFE-690TXD CardBus PC Card
+	1541  DFE-680TXD CardBus PC Card
+	1561  DRP-32TXD Cardbus PC Card
+	2027  AirPlus Xtreme G DWL-G520 Adapter
+	3203  AirPlus Xtreme G DWL-G520 Adapter
+	3300  DWL-510 2.4GHz Wireless PCI Adapter
+	3a03  AirPro DWL-A650 Wireless Cardbus Adapter(rev.B)
+	3a04  AirPro DWL-AB650 Multimode Wireless Cardbus Adapter
+	3a05  AirPro DWL-AB520 Multimode Wireless PCI Adapter
+	3a07  AirXpert DWL-AG650 Wireless Cardbus Adapter
+	3a08  AirXpert DWL-AG520 Wireless PCI Adapter
+	3a10  AirXpert DWL-AG650 Wireless Cardbus Adapter(rev.B)
+	3a11  AirXpert DWL-AG520 Wireless PCI Adapter(rev.B)
+	3a12  AirPlus DWL-G650 Wireless Cardbus Adapter(rev.C)
+	3a13  AirPlus DWL-G520 Wireless PCI Adapter(rev.B)
+	3a14  AirPremier DWL-AG530 Wireless PCI Adapter
+	3a63  AirXpert DWL-AG660 Wireless Cardbus Adapter
+	3b05  DWL-G650+ CardBus PC Card
+	4000  DL2000-based Gigabit Ethernet
+	4300  DGE-528T Gigabit Ethernet Adapter
+	4c00  Gigabit Ethernet Adapter
+		1186 4c00  DGE-530T Gigabit Ethernet Adapter
+	8400  D-Link DWL-650+ CardBus PC Card
+1187  Advanced Technology Laboratories, Inc.
+1188  Shima Seiki Manufacturing Ltd.
+1189  Matsushita Electronics Co Ltd
+118a  Hilevel Technology
+118b  Hypertec Pty Limited
+118c  Corollary, Inc
+	0014  PCIB [C-bus II to PCI bus host bridge chip]
+	1117  Intel 8-way XEON Profusion Chipset [Cache Coherency Filter]
+118d  BitFlow Inc
+	0001  Raptor-PCI framegrabber
+	0012  Model 12 Road Runner Frame Grabber
+	0014  Model 14 Road Runner Frame Grabber
+	0024  Model 24 Road Runner Frame Grabber
+	0044  Model 44 Road Runner Frame Grabber
+	0112  Model 12 Road Runner Frame Grabber
+	0114  Model 14 Road Runner Frame Grabber
+	0124  Model 24 Road Runner Frame Grabber
+	0144  Model 44 Road Runner Frame Grabber
+	0212  Model 12 Road Runner Frame Grabber
+	0214  Model 14 Road Runner Frame Grabber
+	0224  Model 24 Road Runner Frame Grabber
+	0244  Model 44 Road Runner Frame Grabber
+	0312  Model 12 Road Runner Frame Grabber
+	0314  Model 14 Road Runner Frame Grabber
+	0324  Model 24 Road Runner Frame Grabber
+	0344  Model 44 Road Runner Frame Grabber
+118e  Hermstedt GmbH
+118f  Green Logic
+1190  Tripace
+	c731  TP-910/920/940 PCI Ultra(Wide) SCSI Adapter
+1191  Artop Electronic Corp
+	0003  SCSI Cache Host Adapter
+	0004  ATP8400
+	0005  ATP850UF
+	0006  ATP860 NO-BIOS
+	0007  ATP860
+	0008  ATP865 NO-ROM
+	0009  ATP865
+	8002  AEC6710 SCSI-2 Host Adapter
+	8010  AEC6712UW SCSI
+	8020  AEC6712U SCSI
+	8030  AEC6712S SCSI
+	8040  AEC6712D SCSI
+	8050  AEC6712SUW SCSI
+	8060  AEC6712 SCSI
+	8080  AEC67160 SCSI
+	8081  AEC67160S SCSI
+	808a  AEC67162 2-ch. LVD SCSI
+1192  Densan Company Ltd
+1193  Zeitnet Inc.
+	0001  1221
+	0002  1225
+1194  Toucan Technology
+1195  Ratoc System Inc
+1196  Hytec Electronics Ltd
+1197  Gage Applied Sciences, Inc.
+	010c  CompuScope 82G 8bit 2GS/s Analog Input Card
+1198  Lambda Systems Inc
+1199  Attachmate Corporation
+119a  Mind Share, Inc.
+119b  Omega Micro Inc.
+	1221  82C092G
+119c  Information Technology Inst.
+119d  Bug, Inc. Sapporo Japan
+119e  Fujitsu Microelectronics Ltd.
+	0001  FireStream 155
+	0003  FireStream 50
+119f  Bull HN Information Systems
+11a0  Convex Computer Corporation
+11a1  Hamamatsu Photonics K.K.
+11a2  Sierra Research and Technology
+11a3  Deuretzbacher GmbH & Co. Eng. KG
+11a4  Barco Graphics NV
+11a5  Microunity Systems Eng. Inc
+11a6  Pure Data Ltd.
+11a7  Power Computing Corp.
+11a8  Systech Corp.
+11a9  InnoSys Inc.
+	4240  AMCC S933Q Intelligent Serial Card
+11aa  Actel
+# Formerly Galileo Technology, Inc.
+11ab  Marvell Technology Group Ltd.
+	0146  GT-64010/64010A System Controller
+	138f  W8300 802.11 Adapter (rev 07)
+	1fa6  Marvell W8300 802.11 Adapter
+	1fa7  88W8310 and 88W8000G [Libertas] 802.11g client chipset
+	4320  Gigabit Ethernet Controller
+		1019 0f38  Marvell 88E8001 Gigabit Ethernet Controller (ECS)
+		1019 8001  Marvell 88E8001 Gigabit Ethernet Controller (ECS)
+		1043 173c  Marvell 88E8001 Gigabit Ethernet Controller (Asus)
+		1043 811a  Marvell 88E8001 Gigabit Ethernet Controller (Asus)
+		105b 0c19  Marvell 88E8001 Gigabit Ethernet Controller (Foxconn)
+		10b8 b452  SMC EZ Card 1000 (SMC9452TXV.2)
+		11ab 0121  Marvell RDK-8001
+		11ab 0321  Marvell RDK-8003
+		11ab 1021  Marvell RDK-8010
+		11ab 5021  Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Controller (64 bit)
+		11ab 9521  Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Controller (32 bit)
+		1458 e000  Marvell 88E8001 Gigabit Ethernet Controller (Gigabyte)
+		147b 1406  Marvell 88E8001 Gigabit Ethernet Controller (Abit)
+		15d4 0047  Marvell 88E8001 Gigabit Ethernet Controller (Iwill)
+		1695 9025  Marvell 88E8001 Gigabit Ethernet Controller (Epox)
+		17f2 1c03  Marvell 88E8001 Gigabit Ethernet Controller (Albatron)
+		270f 2803  Marvell 88E8001 Gigabit Ethernet Controller (Chaintech)
+	4350  Fast Ethernet Controller
+		1179 0001  Marvell 88E8035 Fast Ethernet Controller (Toshiba)
+		11ab 3521  Marvell RDK-8035
+		1854 000d  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 000e  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 000f  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0011  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0012  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0016  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0017  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0018  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0019  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 001c  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 001e  Marvell 88E8035 Fast Ethernet Controller (LGE)
+		1854 0020  Marvell 88E8035 Fast Ethernet Controller (LGE)
+	4351  Fast Ethernet Controller
+		107b 4009  Marvell 88E8036 Fast Ethernet Controller (Wistron)
+		10f7 8338  Marvell 88E8036 Fast Ethernet Controller (Panasonic)
+		1179 0001  Marvell 88E8036 Fast Ethernet Controller (Toshiba)
+		1179 ff00  Marvell 88E8036 Fast Ethernet Controller (Compal)
+		1179 ff10  Marvell 88E8036 Fast Ethernet Controller (Inventec)
+		11ab 3621  Marvell RDK-8036
+		13d1 ac12  Abocom EFE3K - 10/100 Ethernet Expresscard
+		161f 203d  Marvell 88E8036 Fast Ethernet Controller (Arima)
+		1854 000d  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 000e  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 000f  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0011  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0012  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0016  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0017  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0018  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0019  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 001c  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 001e  Marvell 88E8036 Fast Ethernet Controller (LGE)
+		1854 0020  Marvell 88E8036 Fast Ethernet Controller (LGE)
+	4360  Gigabit Ethernet Controller
+		1043 8134  Marvell 88E8052 Gigabit Ethernet Controller (Asus)
+		107b 4009  Marvell 88E8052 Gigabit Ethernet Controller (Wistron)
+		11ab 5221  Marvell RDK-8052
+		1458 e000  Marvell 88E8052 Gigabit Ethernet Controller (Gigabyte)
+		1462 052c  Marvell 88E8052 Gigabit Ethernet Controller (MSI)
+		1849 8052  Marvell 88E8052 Gigabit Ethernet Controller (ASRock)
+		1940 e000  Marvell 88E8052 Gigabit Ethernet Controller (Gigabyte)
+		a0a0 0509  Marvell 88E8052 Gigabit Ethernet Controller (Aopen)
+	4361  Gigabit Ethernet Controller
+		107b 3015  Marvell 88E8050 Gigabit Ethernet Controller (Gateway)
+		11ab 5021  Marvell 88E8050 Gigabit Ethernet Controller (Intel)
+		8086 3063  D925XCVLK mainboard
+	4362  Gigabit Ethernet Controller
+		103c 2a0d  Marvell 88E8053 Gigabit Ethernet Controller (Asus)
+		1043 8142  Marvell 88E8053 Gigabit Ethernet Controller (Asus)
+		109f 3197  Marvell 88E8053 Gigabit Ethernet Controller (Trigem)
+		10f7 8338  Marvell 88E8053 Gigabit Ethernet Controller (Panasonic)
+		10fd a430  Marvell 88E8053 Gigabit Ethernet Controller (SOYO)
+		1179 0001  Marvell 88E8053 Gigabit Ethernet Controller (Toshiba)
+		1179 ff00  Marvell 88E8053 Gigabit Ethernet Controller (Compal)
+		1179 ff10  Marvell 88E8053 Gigabit Ethernet Controller (Inventec)
+		11ab 5321  Marvell RDK-8053
+		1297 c240  Marvell 88E8053 Gigabit Ethernet Controller (Shuttle)
+		1297 c241  Marvell 88E8053 Gigabit Ethernet Controller (Shuttle)
+		1297 c242  Marvell 88E8053 Gigabit Ethernet Controller (Shuttle)
+		1297 c243  Marvell 88E8053 Gigabit Ethernet Controller (Shuttle)
+		1297 c244  Marvell 88E8053 Gigabit Ethernet Controller (Shuttle)
+		13d1 ac11  Abocom EGE5K - Giga Ethernet Expresscard
+		1458 e000  Marvell 88E8053 Gigabit Ethernet Controller (Gigabyte)
+		1462 058c  Marvell 88E8053 Gigabit Ethernet Controller (MSI)
+		14c0 0012  Marvell 88E8053 Gigabit Ethernet Controller (Compal)
+		1558 04a0  Marvell 88E8053 Gigabit Ethernet Controller (Clevo)
+		15bd 1003  Marvell 88E8053 Gigabit Ethernet Controller (DFI)
+		161f 203c  Marvell 88E8053 Gigabit Ethernet Controller (Arima)
+		161f 203d  Marvell 88E8053 Gigabit Ethernet Controller (Arima)
+		1695 9029  Marvell 88E8053 Gigabit Ethernet Controller (Epox)
+		17f2 2c08  Marvell 88E8053 Gigabit Ethernet Controller (Albatron)
+		17ff 0585  Marvell 88E8053 Gigabit Ethernet Controller (Quanta)
+		1849 8053  Marvell 88E8053 Gigabit Ethernet Controller (ASRock)
+		1854 000b  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 000c  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 0010  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 0013  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 0014  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 0015  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 001a  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 001b  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 001d  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 001f  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 0021  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1854 0022  Marvell 88E8053 Gigabit Ethernet Controller (LGE)
+		1940 e000  Marvell 88E8053 Gigabit Ethernet Controller (Gigabyte)
+		270f 2801  Marvell 88E8053 Gigabit Ethernet Controller (Chaintech)
+		a0a0 0506  Marvell 88E8053 Gigabit Ethernet Controller (Aopen)
+	4611  GT-64115 System Controller
+	4620  GT-64120/64120A/64121A System Controller
+	4801  GT-48001
+	5005  Belkin F5D5005 Gigabit Desktop Network PCI Card
+	5040  MV88SX5040 4-port SATA I PCI-X Controller
+	5041  MV88SX5041 4-port SATA I PCI-X Controller
+	5080  MV88SX5080 8-port SATA I PCI-X Controller
+	5081  MV88SX5081 8-port SATA I PCI-X Controller
+	6041  MV88SX6041 4-port SATA II PCI-X Controller
+	6081  MV88SX6081 8-port SATA II PCI-X Controller
+	6460  MV64360/64361/64362 System Controller
+	f003  GT-64010 Primary Image Piranha Image Generator
+11ac  Canon Information Systems Research Aust.
+11ad  Lite-On Communications Inc
+	0002  LNE100TX
+		11ad 0002  LNE100TX
+		11ad 0003  LNE100TX
+		11ad f003  LNE100TX
+		11ad ffff  LNE100TX
+		1385 f004  FA310TX
+	c115  LNE100TX [Linksys EtherFast 10/100]
+		11ad c001  LNE100TX [ver 2.0]
+11ae  Aztech System Ltd
+11af  Avid Technology Inc.
+	0001  [Cinema]
+11b0  V3 Semiconductor Inc.
+	0002  V300PSC
+	0292  V292PBC [Am29030/40 Bridge]
+	0960  V96xPBC
+	c960  V96DPC
+11b1  Apricot Computers
+11b2  Eastman Kodak
+11b3  Barr Systems Inc.
+11b4  Leitch Technology International
+11b5  Radstone Technology Plc
+11b6  United Video Corp
+11b7  Motorola
+11b8  XPoint Technologies, Inc
+	0001  Quad PeerMaster
+11b9  Pathlight Technology Inc.
+	c0ed  SSA Controller
+11ba  Videotron Corp
+11bb  Pyramid Technology
+11bc  Network Peripherals Inc
+	0001  NP-PCI
+11bd  Pinnacle Systems Inc.
+11be  International Microcircuits Inc
+11bf  Astrodesign, Inc.
+11c0  Hewlett Packard
+11c1  Agere Systems (former Lucent Microelectronics)
+	0440  56k WinModem
+		1033 8015  LT WinModem 56k Data+Fax+Voice+Dsvd
+		1033 8047  LT WinModem 56k Data+Fax+Voice+Dsvd
+		1033 804f  LT WinModem 56k Data+Fax+Voice+Dsvd
+		10cf 102c  LB LT Modem V.90 56k
+		10cf 104a  BIBLO LT Modem 56k
+		10cf 105f  LB2 LT Modem V.90 56k
+		1179 0001  Internal V.90 Modem
+		11c1 0440  LT WinModem 56k Data+Fax+Voice+Dsvd
+		122d 4101  MDP7800-U Modem
+		122d 4102  MDP7800SP-U Modem
+		13e0 0040  LT WinModem 56k Data+Fax+Voice+Dsvd
+		13e0 0440  LT WinModem 56k Data+Fax+Voice+Dsvd
+		13e0 0441  LT WinModem 56k Data+Fax+Voice+Dsvd
+		13e0 0450  LT WinModem 56k Data+Fax+Voice+Dsvd
+		13e0 f100  LT WinModem 56k Data+Fax+Voice+Dsvd
+		13e0 f101  LT WinModem 56k Data+Fax+Voice+Dsvd
+		144d 2101  LT56PV Modem
+		149f 0440  LT WinModem 56k Data+Fax+Voice+Dsvd
+	0441  56k WinModem
+		1033 804d  LT WinModem 56k Data+Fax
+		1033 8065  LT WinModem 56k Data+Fax
+		1092 0440  Supra 56i
+		1179 0001  Internal V.90 Modem
+		11c1 0440  LT WinModem 56k Data+Fax
+		11c1 0441  LT WinModem 56k Data+Fax
+		122d 4100  MDP7800-U Modem
+		13e0 0040  LT WinModem 56k Data+Fax
+		13e0 0100  LT WinModem 56k Data+Fax
+		13e0 0410  LT WinModem 56k Data+Fax
+		13e0 0420  TelePath Internet 56k WinModem
+		13e0 0440  LT WinModem 56k Data+Fax
+		13e0 0443  LT WinModem 56k Data+Fax
+		13e0 f102  LT WinModem 56k Data+Fax
+		1416 9804  CommWave 56k Modem
+		141d 0440  LT WinModem 56k Data+Fax
+		144f 0441  Lucent 56k V.90 DF Modem
+		144f 0449  Lucent 56k V.90 DF Modem
+		144f 110d  Lucent Win Modem
+		1468 0441  Presario 56k V.90 DF Modem
+		1668 0440  Lucent Win Modem
+	0442  56k WinModem
+		11c1 0440  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		11c1 0442  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		13e0 0412  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		13e0 0442  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		13fc 2471  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		144d 2104  LT56PT Modem
+		144f 1104  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		149f 0440  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		1668 0440  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+	0443  LT WinModem
+	0444  LT WinModem
+	0445  LT WinModem
+		8086 2203  PRO/100+ MiniPCI (probably an Ambit U98.003.C.00 combo card)
+		8086 2204  PRO/100+ MiniPCI on Armada E500
+	0446  LT WinModem
+	0447  LT WinModem
+	0448  WinModem 56k
+		1014 0131  Lucent Win Modem
+		1033 8066  LT WinModem 56k Data+Fax+Voice+Dsvd
+		13e0 0030  56k Voice Modem
+		13e0 0040  LT WinModem 56k Data+Fax+Voice+Dsvd
+# Actiontech eth+modem card as used by Dell &c.
+		1668 2400  LT WinModem 56k (MiniPCI Ethernet+Modem)
+	0449  WinModem 56k
+		0e11 b14d  56k V.90 Modem
+		13e0 0020  LT WinModem 56k Data+Fax
+		13e0 0041  TelePath Internet 56k WinModem
+		1436 0440  Lucent Win Modem
+		144f 0449  Lucent 56k V.90 DFi Modem
+		1468 0410  IBM ThinkPad T23 (2647-4MG)
+		1468 0440  Lucent Win Modem
+		1468 0449  Presario 56k V.90 DFi Modem
+	044a  F-1156IV WinModem (V90, 56KFlex)
+		10cf 1072  LB Global LT Modem
+		13e0 0012  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		13e0 0042  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+		144f 1005  LT WinModem 56k Data+Fax+Voice+VoiceView+Dsvd
+	044b  LT WinModem
+	044c  LT WinModem
+	044d  LT WinModem
+	044e  LT WinModem
+	044f  V90 WildWire Modem
+	0450  LT WinModem
+		1033 80a8  Versa Note Vxi
+		144f 4005  Magnia SG20
+	0451  LT WinModem
+	0452  LT WinModem
+	0453  LT WinModem
+	0454  LT WinModem
+	0455  LT WinModem
+	0456  LT WinModem
+	0457  LT WinModem
+	0458  LT WinModem
+	0459  LT WinModem
+	045a  LT WinModem
+	045c  LT WinModem
+	0461  V90 WildWire Modem
+	0462  V90 WildWire Modem
+	0480  Venus Modem (V90, 56KFlex)
+	048c  V.92 56K WinModem
+# InPorte Home Internal 56k Modem/fax/answering machine/SMS Features
+	048f  V.92 56k WinModem
+	5801  USB
+	5802  USS-312 USB Controller
+# 4 port PCI USB Controller made by Agere (formely Lucent)
+	5803  USS-344S USB Controller
+	5811  FW323
+		8086 524c  D865PERL mainboard
+		dead 0800  FireWire Host Bus Adapter
+	ab10  WL60010 Wireless LAN MAC
+	ab11  WL60040 Multimode Wireles LAN MAC
+		11c1 ab12  WaveLAN 11abg Cardbus card (Model 1102)
+		11c1 ab13  WaveLAN 11abg MiniPCI card (Model 0512)
+		11c1 ab15  WaveLAN 11abg Cardbus card (Model 1106)
+		11c1 ab16  WaveLAN 11abg MiniPCI card (Model 0516)
+	ab20  ORiNOCO PCI Adapter
+	ab21  Agere Wireless PCI Adapter
+	ab30  Hermes2 Mini-PCI WaveLAN a/b/g
+		14cd 2012  Hermes2 Mini-PCI WaveLAN a/b/g
+11c2  Sand Microelectronics
+11c3  NEC Corporation
+11c4  Document Technologies, Inc
+11c5  Shiva Corporation
+11c6  Dainippon Screen Mfg. Co. Ltd
+11c7  D.C.M. Data Systems
+11c8  Dolphin Interconnect Solutions AS
+	0658  PSB32 SCI-Adapter D31x
+	d665  PSB64 SCI-Adapter D32x
+	d667  PSB66 SCI-Adapter D33x
+11c9  Magma
+	0010  16-line serial port w/- DMA
+	0011  4-line serial port w/- DMA
+11ca  LSI Systems, Inc
+11cb  Specialix Research Ltd.
+	2000  PCI_9050
+		11cb 0200  SX
+		11cb b008  I/O8+
+	4000  SUPI_1
+	8000  T225
+11cc  Michels & Kleberhoff Computer GmbH
+11cd  HAL Computer Systems, Inc.
+11ce  Netaccess
+11cf  Pioneer Electronic Corporation
+11d0  Lockheed Martin Federal Systems-Manassas
+11d1  Auravision
+	01f7  VxP524
+11d2  Intercom Inc.
+11d3  Trancell Systems Inc
+11d4  Analog Devices
+	1535  Blackfin BF535 processor
+	1805  SM56 PCI modem
+	1889  AD1889 sound chip
+11d5  Ikon Corporation
+	0115  10115
+	0117  10117
+11d6  Tekelec Telecom
+11d7  Trenton Technology, Inc.
+11d8  Image Technologies Development
+11d9  TEC Corporation
+11da  Novell
+11db  Sega Enterprises Ltd
+11dc  Questra Corporation
+11dd  Crosfield Electronics Limited
+11de  Zoran Corporation
+	6057  ZR36057PQC Video cutting chipset
+		1031 7efe  DC10 Plus
+		1031 fc00  MiroVIDEO DC50, Motion JPEG Capture/CODEC Board
+		13ca 4231  JPEG/TV Card
+	6120  ZR36120
+		1328 f001  Cinemaster C DVD Decoder
+11df  New Wave PDG
+11e0  Cray Communications A/S
+11e1  GEC Plessey Semi Inc.
+11e2  Samsung Information Systems America
+11e3  Quicklogic Corporation
+	5030  PC Watchdog
+11e4  Second Wave Inc
+11e5  IIX Consulting
+11e6  Mitsui-Zosen System Research
+11e7  Toshiba America, Elec. Company
+11e8  Digital Processing Systems Inc.
+11e9  Highwater Designs Ltd.
+11ea  Elsag Bailey
+11eb  Formation Inc.
+11ec  Coreco Inc
+11ed  Mediamatics
+11ee  Dome Imaging Systems Inc
+11ef  Nicolet Technologies B.V.
+11f0  Compu-Shack
+	4231  FDDI
+	4232  FASTline UTP Quattro
+	4233  FASTline FO
+	4234  FASTline UTP
+	4235  FASTline-II UTP
+	4236  FASTline-II FO
+	4731  GIGAline
+11f1  Symbios Logic Inc
+11f2  Picture Tel Japan K.K.
+11f3  Keithley Metrabyte
+11f4  Kinetic Systems Corporation
+	2915  CAMAC controller
+11f5  Computing Devices International
+11f6  Compex
+	0112  ENet100VG4
+	0113  FreedomLine 100
+	1401  ReadyLink 2000
+	2011  RL100-ATX 10/100
+		11f6 2011  RL100-ATX
+	2201  ReadyLink 100TX (Winbond W89C840)
+		11f6 2011  ReadyLink 100TX
+	9881  RL100TX Fast Ethernet
+11f7  Scientific Atlanta
+11f8  PMC-Sierra Inc.
+	7375  PM7375 [LASAR-155 ATM SAR]
+11f9  I-Cube Inc
+11fa  Kasan Electronics Company, Ltd.
+11fb  Datel Inc
+11fc  Silicon Magic
+11fd  High Street Consultants
+11fe  Comtrol Corporation
+	0001  RocketPort 32 port w/external I/F
+	0002  RocketPort 8 port w/external I/F
+	0003  RocketPort 16 port w/external I/F
+	0004  RocketPort 4 port w/quad cable
+	0005  RocketPort 8 port w/octa cable
+	0006  RocketPort 8 port w/RJ11 connectors
+	0007  RocketPort 4 port w/RJ11 connectors
+	0008  RocketPort 8 port w/ DB78 SNI (Siemens) connector
+	0009  RocketPort 16 port w/ DB78 SNI (Siemens) connector
+	000a  RocketPort Plus 4 port
+	000b  RocketPort Plus 8 port
+	000c  RocketModem 6 port
+	000d  RocketModem 4-port
+	000e  RocketPort Plus 2 port RS232
+	000f  RocketPort Plus 2 port RS422
+	0801  RocketPort UPCI 32 port w/external I/F
+	0802  RocketPort UPCI 8 port w/external I/F
+	0803  RocketPort UPCI 16 port w/external I/F
+	0805  RocketPort UPCI 8 port w/octa cable
+	080c  RocketModem III 8 port
+	080d  RocketModem III 4 port
+	0903  RocketPort Compact PCI 16 port w/external I/F
+	8015  RocketPort 4-port UART 16954
+11ff  Scion Corporation
+	0003  AG-5
+1200  CSS Corporation
+1201  Vista Controls Corp
+1202  Network General Corp.
+	4300  Gigabit Ethernet Adapter
+		1202 9841  SK-9841 LX
+		1202 9842  SK-9841 LX dual link
+		1202 9843  SK-9843 SX
+		1202 9844  SK-9843 SX dual link
+1203  Bayer Corporation, Agfa Division
+1204  Lattice Semiconductor Corporation
+1205  Array Corporation
+1206  Amdahl Corporation
+1208  Parsytec GmbH
+	4853  HS-Link Device
+1209  SCI Systems Inc
+120a  Synaptel
+120b  Adaptive Solutions
+120c  Technical Corp.
+120d  Compression Labs, Inc.
+120e  Cyclades Corporation
+	0100  Cyclom-Y below first megabyte
+	0101  Cyclom-Y above first megabyte
+	0102  Cyclom-4Y below first megabyte
+	0103  Cyclom-4Y above first megabyte
+	0104  Cyclom-8Y below first megabyte
+	0105  Cyclom-8Y above first megabyte
+	0200  Cyclades-Z below first megabyte
+	0201  Cyclades-Z above first megabyte
+	0300  PC300/RSV or /X21 (2 ports)
+	0301  PC300/RSV or /X21 (1 port)
+	0310  PC300/TE (2 ports)
+	0311  PC300/TE (1 port)
+	0320  PC300/TE-M (2 ports)
+	0321  PC300/TE-M (1 port)
+	0400  PC400
+120f  Essential Communications
+	0001  Roadrunner serial HIPPI
+1210  Hyperparallel Technologies
+1211  Braintech Inc
+1212  Kingston Technology Corp.
+1213  Applied Intelligent Systems, Inc.
+1214  Performance Technologies, Inc.
+1215  Interware Co., Ltd
+1216  Purup Prepress A/S
+1217  O2 Micro, Inc.
+	6729  OZ6729
+	673a  OZ6730
+	6832  OZ6832/6833 CardBus Controller
+	6836  OZ6836/6860 CardBus Controller
+	6872  OZ6812 CardBus Controller
+	6925  OZ6922 CardBus Controller
+	6933  OZ6933/711E1 CardBus/SmartCardBus Controller
+		1025 1016  Travelmate 612 TX
+	6972  OZ601/6912/711E0 CardBus/SmartCardBus Controller
+		1014 020c  ThinkPad R30
+		1179 0001  Magnia Z310
+	7110  OZ711Mx 4-in-1 MemoryCardBus Accelerator
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+	7112  OZ711EC1/M1 SmartCardBus/MemoryCardBus Controller
+	7113  OZ711EC1 SmartCardBus Controller
+	7114  OZ711M1/MC1 4-in-1 MemoryCardBus Controller
+	7134  OZ711MP1/MS1 MemoryCardBus Controller
+	71e2  OZ711E2 SmartCardBus Controller
+	7212  OZ711M2 4-in-1 MemoryCardBus Controller
+	7213  OZ6933E CardBus Controller
+	7223  OZ711M3/MC3 4-in-1 MemoryCardBus Controller
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+	7233  OZ711MP3/MS3 4-in-1 MemoryCardBus Controller
+1218  Hybricon Corp.
+1219  First Virtual Corporation
+121a  3Dfx Interactive, Inc.
+	0001  Voodoo
+	0002  Voodoo 2
+	0003  Voodoo Banshee
+		1092 0003  Monster Fusion
+		1092 4000  Monster Fusion
+		1092 4002  Monster Fusion
+		1092 4801  Monster Fusion AGP
+		1092 4803  Monster Fusion AGP
+		1092 8030  Monster Fusion
+		1092 8035  Monster Fusion AGP
+		10b0 0001  Dragon 4000
+		1102 1018  3D Blaster Banshee VE
+		121a 0001  Voodoo Banshee AGP
+		121a 0003  Voodoo Banshee AGP SGRAM
+		121a 0004  Voodoo Banshee
+		139c 0016  Raven
+		139c 0017  Raven
+		14af 0002  Maxi Gamer Phoenix
+	0004  Voodoo Banshee [Velocity 100]
+	0005  Voodoo 3
+		121a 0004  Voodoo3 AGP
+		121a 0030  Voodoo3 AGP
+		121a 0031  Voodoo3 AGP
+		121a 0034  Voodoo3 AGP
+		121a 0036  Voodoo3 2000 PCI
+		121a 0037  Voodoo3 AGP
+		121a 0038  Voodoo3 AGP
+		121a 003a  Voodoo3 AGP
+		121a 0044  Voodoo3
+		121a 004b  Velocity 100
+		121a 004c  Velocity 200
+		121a 004d  Voodoo3 AGP
+		121a 004e  Voodoo3 AGP
+		121a 0051  Voodoo3 AGP
+		121a 0052  Voodoo3 AGP
+		121a 0060  Voodoo3 3500 TV (NTSC)
+		121a 0061  Voodoo3 3500 TV (PAL)
+		121a 0062  Voodoo3 3500 TV (SECAM)
+	0009  Voodoo 4 / Voodoo 5
+		121a 0003  Voodoo5 PCI 5500
+		121a 0009  Voodoo5 AGP 5500/6000
+	0057  Voodoo 3/3000 [Avenger]
+121b  Advanced Telecommunications Modules
+121c  Nippon Texaco., Ltd
+121d  Lippert Automationstechnik GmbH
+121e  CSPI
+121f  Arcus Technology, Inc.
+1220  Ariel Corporation
+	1220  AMCC 5933 TMS320C80 DSP/Imaging board
+1221  Contec Co., Ltd
+1222  Ancor Communications, Inc.
+1223  Artesyn Communication Products
+	0003  PM/Link
+	0004  PM/T1
+	0005  PM/E1
+	0008  PM/SLS
+	0009  BajaSpan Resource Target
+	000a  BajaSpan Section 0
+	000b  BajaSpan Section 1
+	000c  BajaSpan Section 2
+	000d  BajaSpan Section 3
+	000e  PM/PPC
+1224  Interactive Images
+1225  Power I/O, Inc.
+1227  Tech-Source
+	0006  Raptor GFX 8P
+1228  Norsk Elektro Optikk A/S
+1229  Data Kinesis Inc.
+122a  Integrated Telecom
+122b  LG Industrial Systems Co., Ltd
+122c  Sican GmbH
+122d  Aztech System Ltd
+	1206  368DSP
+	1400  Trident PCI288-Q3DII (NX)
+	50dc  3328 Audio
+		122d 0001  3328 Audio
+	80da  3328 Audio
+		122d 0001  3328 Audio
+122e  Xyratex
+122f  Andrew Corporation
+1230  Fishcamp Engineering
+1231  Woodward McCoach, Inc.
+1232  GPT Limited
+1233  Bus-Tech, Inc.
+1234  Technical Corp.
+1235  Risq Modular Systems, Inc.
+1236  Sigma Designs Corporation
+	0000  RealMagic64/GX
+	6401  REALmagic 64/GX (SD 6425)
+1237  Alta Technology Corporation
+1238  Adtran
+1239  3DO Company
+123a  Visicom Laboratories, Inc.
+123b  Seeq Technology, Inc.
+123c  Century Systems, Inc.
+123d  Engineering Design Team, Inc.
+	0000  EasyConnect 8/32
+	0002  EasyConnect 8/64
+	0003  EasyIO
+123e  Simutech, Inc.
+123f  C-Cube Microsystems
+	00e4  MPEG
+	8120  E4?
+		11bd 0006  DV500 E4
+		11bd 000a  DV500 E4
+		11bd 000f  DV500 E4
+	8888  Cinemaster C 3.0 DVD Decoder
+		1002 0001  Cinemaster C 3.0 DVD Decoder
+		1002 0002  Cinemaster C 3.0 DVD Decoder
+		1328 0001  Cinemaster C 3.0 DVD Decoder
+1240  Marathon Technologies Corp.
+1241  DSC Communications
+# Formerly Jaycor Networks, Inc.
+1242  JNI Corporation
+	1560  JNIC-1560 PCI-X Fibre Channel Controller
+		1242 6562  FCX2-6562 Dual Channel PCI-X Fibre Channel Adapter
+		1242 656a  FCX-6562 PCI-X Fibre Channel Adapter
+	4643  FCI-1063 Fibre Channel Adapter
+	6562  FCX2-6562 Dual Channel PCI-X Fibre Channel Adapter
+	656a  FCX-6562 PCI-X Fibre Channel Adapter
+1243  Delphax
+1244  AVM Audiovisuelles MKTG & Computer System GmbH
+	0700  B1 ISDN
+	0800  C4 ISDN
+	0a00  A1 ISDN [Fritz]
+		1244 0a00  FRITZ!Card ISDN Controller
+	0e00  Fritz!PCI v2.0 ISDN
+	1100  C2 ISDN
+	1200  T1 ISDN
+	2700  Fritz!Card DSL SL
+	2900  Fritz!Card DSL v2.0
+1245  A.P.D., S.A.
+1246  Dipix Technologies, Inc.
+1247  Xylon Research, Inc.
+1248  Central Data Corporation
+1249  Samsung Electronics Co., Ltd.
+124a  AEG Electrocom GmbH
+124b  SBS/Greenspring Modular I/O
+	0040  PCI-40A or cPCI-200 Quad IndustryPack carrier
+		124b 9080  PCI9080 Bridge
+124c  Solitron Technologies, Inc.
+124d  Stallion Technologies, Inc.
+	0000  EasyConnection 8/32
+	0002  EasyConnection 8/64
+	0003  EasyIO
+	0004  EasyConnection/RA
+124e  Cylink
+124f  Infortrend Technology, Inc.
+	0041  IFT-2000 Series RAID Controller
+1250  Hitachi Microcomputer System Ltd
+1251  VLSI Solutions Oy
+1253  Guzik Technical Enterprises
+1254  Linear Systems Ltd.
+1255  Optibase Ltd
+	1110  MPEG Forge
+	1210  MPEG Fusion
+	2110  VideoPlex
+	2120  VideoPlex CC
+	2130  VideoQuest
+1256  Perceptive Solutions, Inc.
+	4201  PCI-2220I
+	4401  PCI-2240I
+	5201  PCI-2000
+1257  Vertex Networks, Inc.
+1258  Gilbarco, Inc.
+1259  Allied Telesyn International
+	2560  AT-2560 Fast Ethernet Adapter (i82557B)
+	a117  RTL81xx Fast Ethernet
+	a120  21x4x DEC-Tulip compatible 10/100 Ethernet
+125a  ABB Power Systems
+125b  Asix Electronics Corporation
+	1400  ALFA GFC2204 Fast Ethernet
+125c  Aurora Technologies, Inc.
+	0101  Saturn 4520P
+	0640  Aries 16000P
+125d  ESS Technology
+	0000  ES336H Fax Modem (Early Model)
+	1948  Solo?
+	1968  ES1968 Maestro 2
+		1028 0085  ES1968 Maestro-2 PCI
+		1033 8051  ES1968 Maestro-2 Audiodrive
+	1969  ES1969 Solo-1 Audiodrive
+		1014 0166  ES1969 SOLO-1 AudioDrive on IBM Aptiva Mainboard
+		125d 8888  Solo-1 Audio Adapter
+		153b 111b  Terratec 128i PCI
+	1978  ES1978 Maestro 2E
+		0e11 b112  Armada M700/E500
+		1033 803c  ES1978 Maestro-2E Audiodrive
+		1033 8058  ES1978 Maestro-2E Audiodrive
+		1092 4000  Monster Sound MX400
+		1179 0001  ES1978 Maestro-2E Audiodrive
+	1988  ES1988 Allegro-1
+		1092 4100  Sonic Impact S100
+		125d 1988  ESS Allegro-1 Audiodrive
+	1989  ESS Modem
+		125d 1989  ESS Modem
+	1998  ES1983S Maestro-3i PCI Audio Accelerator
+		1028 00b1  Latitude C600
+		1028 00e6  ES1983S Maestro-3i (Dell Inspiron 8100)
+	1999  ES1983S Maestro-3i PCI Modem Accelerator
+	199a  ES1983S Maestro-3i PCI Audio Accelerator
+	199b  ES1983S Maestro-3i PCI Modem Accelerator
+	2808  ES336H Fax Modem (Later Model)
+	2838  ES2838/2839 SuperLink Modem
+	2898  ES2898 Modem
+		125d 0424  ES56-PI Data Fax Modem
+		125d 0425  ES56T-PI Data Fax Modem
+		125d 0426  ES56V-PI Data Fax Modem
+		125d 0427  VW-PI Data Fax Modem
+		125d 0428  ES56ST-PI Data Fax Modem
+		125d 0429  ES56SV-PI Data Fax Modem
+		147a c001  ES56-PI Data Fax Modem
+		14fe 0428  ES56-PI Data Fax Modem
+		14fe 0429  ES56-PI Data Fax Modem
+125e  Specialvideo Engineering SRL
+125f  Concurrent Technologies, Inc.
+1260  Intersil Corporation
+	3872  Prism 2.5 Wavelan chipset
+		1468 0202  LAN-Express IEEE 802.11b Wireless LAN
+	3873  Prism 2.5 Wavelan chipset
+		1186 3501  DWL-520 Wireless PCI Adapter
+		1186 3700  DWL-520 Wireless PCI Adapter, Rev E1
+		1385 4105  MA311 802.11b wireless adapter
+		1668 0414  HWP01170-01 802.11b PCI Wireless Adapter
+		16a5 1601  AIR.mate PC-400 PCI Wireless LAN Adapter
+		1737 3874  WMP11 Wireless 802.11b PCI Adapter
+		8086 2513  Wireless 802.11b MiniPCI Adapter
+	3886  ISL3886 [Prism Javelin/Prism Xbow]
+		17cf 0037  Z-Com XG-901 and clones Wireless Adapter
+	3890  Intersil ISL3890 [Prism GT/Prism Duette]
+		10b8 2802  SMC2802W Wireless PCI Adapter
+		10b8 2835  SMC2835W Wireless Cardbus Adapter
+		10b8 a835  SMC2835W V2 Wireless Cardbus Adapter
+		1113 ee03  SMC2802W V2 Wireless PCI Adapter
+		1113 ee08  SMC2835W V3 EU Wireless Cardbus Adapter
+		1186 3202  DWL-G650 A1 Wireless Adapter
+		1259 c104  CG-WLCB54GT Wireless Adapter
+		1385 4800  WG511 Wireless Adapter
+		16a5 1605  ALLNET ALL0271 Wireless PCI Adapter
+		17cf 0014  Z-Com XG-600 and clones Wireless Adapter
+		17cf 0020  Z-Com XG-900 and clones Wireless Adapter
+	8130  HMP8130 NTSC/PAL Video Decoder
+	8131  HMP8131 NTSC/PAL Video Decoder
+1261  Matsushita-Kotobuki Electronics Industries, Ltd.
+1262  ES Computer Company, Ltd.
+1263  Sonic Solutions
+1264  Aval Nagasaki Corporation
+1265  Casio Computer Co., Ltd.
+1266  Microdyne Corporation
+	0001  NE10/100 Adapter (i82557B)
+	1910  NE2000Plus (RT8029) Ethernet Adapter
+		1266 1910  NE2000Plus Ethernet Adapter
+1267  S. A. Telecommunications
+	5352  PCR2101
+	5a4b  Telsat Turbo
+1268  Tektronix
+1269  Thomson-CSF/TTM
+126a  Lexmark International, Inc.
+126b  Adax, Inc.
+126c  Northern Telecom
+	1211  10/100BaseTX [RTL81xx]
+	126c  802.11b Wireless Ethernet Adapter
+126d  Splash Technology, Inc.
+126e  Sumitomo Metal Industries, Ltd.
+126f  Silicon Motion, Inc.
+	0501  SM501 VoyagerGX
+	0710  SM710 LynxEM
+	0712  SM712 LynxEM+
+	0720  SM720 Lynx3DM
+	0730  SM731 Cougar3DR
+	0810  SM810 LynxE
+	0811  SM811 LynxE
+	0820  SM820 Lynx3D
+	0910  SM910
+1270  Olympus Optical Co., Ltd.
+1271  GW Instruments
+1272  Telematics International
+1273  Hughes Network Systems
+	0002  DirecPC
+1274  Ensoniq
+	1171  ES1373 [AudioPCI] (also Creative Labs CT5803)
+	1371  ES1371 [AudioPCI-97]
+		0e11 0024  AudioPCI on Motherboard Compaq Deskpro
+		0e11 b1a7  ES1371, ES1373 AudioPCI
+		1033 80ac  ES1371, ES1373 AudioPCI
+		1042 1854  Tazer
+		107b 8054  Tabor2
+		1274 1371  Creative Sound Blaster AudioPCI64V, AudioPCI128
+		1462 6470  ES1371, ES1373 AudioPCI On Motherboard MS-6147 1.1A
+		1462 6560  ES1371, ES1373 AudioPCI On Motherboard MS-6156 1.10
+		1462 6630  ES1371, ES1373 AudioPCI On Motherboard MS-6163BX 1.0A
+		1462 6631  ES1371, ES1373 AudioPCI On Motherboard MS-6163VIA 1.0A
+		1462 6632  ES1371, ES1373 AudioPCI On Motherboard MS-6163BX 2.0A
+		1462 6633  ES1371, ES1373 AudioPCI On Motherboard MS-6163VIA 2.0A
+		1462 6820  ES1371, ES1373 AudioPCI On Motherboard MS-6182 1.00
+		1462 6822  ES1371, ES1373 AudioPCI On Motherboard MS-6182 1.00A
+		1462 6830  ES1371, ES1373 AudioPCI On Motherboard MS-6183 1.00
+		1462 6880  ES1371, ES1373 AudioPCI On Motherboard MS-6188 1.00
+		1462 6900  ES1371, ES1373 AudioPCI On Motherboard MS-6190 1.00
+		1462 6910  ES1371, ES1373 AudioPCI On Motherboard MS-6191
+		1462 6930  ES1371, ES1373 AudioPCI On Motherboard MS-6193
+		1462 6990  ES1371, ES1373 AudioPCI On Motherboard MS-6199BX 2.0A
+		1462 6991  ES1371, ES1373 AudioPCI On Motherboard MS-6199VIA 2.0A
+		14a4 2077  ES1371, ES1373 AudioPCI On Motherboard KR639
+		14a4 2105  ES1371, ES1373 AudioPCI On Motherboard MR800
+		14a4 2107  ES1371, ES1373 AudioPCI On Motherboard MR801
+		14a4 2172  ES1371, ES1373 AudioPCI On Motherboard DR739
+		1509 9902  ES1371, ES1373 AudioPCI On Motherboard KW11
+		1509 9903  ES1371, ES1373 AudioPCI On Motherboard KW31
+		1509 9904  ES1371, ES1373 AudioPCI On Motherboard KA11
+		1509 9905  ES1371, ES1373 AudioPCI On Motherboard KC13
+		152d 8801  ES1371, ES1373 AudioPCI On Motherboard CP810E
+		152d 8802  ES1371, ES1373 AudioPCI On Motherboard CP810
+		152d 8803  ES1371, ES1373 AudioPCI On Motherboard P3810E
+		152d 8804  ES1371, ES1373 AudioPCI On Motherboard P3810-S
+		152d 8805  ES1371, ES1373 AudioPCI On Motherboard P3820-S
+		270f 2001  ES1371, ES1373 AudioPCI On Motherboard 6CTR
+		270f 2200  ES1371, ES1373 AudioPCI On Motherboard 6WTX
+		270f 3000  ES1371, ES1373 AudioPCI On Motherboard 6WSV
+		270f 3100  ES1371, ES1373 AudioPCI On Motherboard 6WIV2
+		270f 3102  ES1371, ES1373 AudioPCI On Motherboard 6WIV
+		270f 7060  ES1371, ES1373 AudioPCI On Motherboard 6ASA2
+		8086 4249  ES1371, ES1373 AudioPCI On Motherboard BI440ZX
+		8086 424c  ES1371, ES1373 AudioPCI On Motherboard BL440ZX
+		8086 425a  ES1371, ES1373 AudioPCI On Motherboard BZ440ZX
+		8086 4341  ES1371, ES1373 AudioPCI On Motherboard Cayman
+		8086 4343  ES1371, ES1373 AudioPCI On Motherboard Cape Cod
+		8086 4649  ES1371, ES1373 AudioPCI On Motherboard Fire Island
+		8086 464a  ES1371, ES1373 AudioPCI On Motherboard FJ440ZX
+		8086 4d4f  ES1371, ES1373 AudioPCI On Motherboard Montreal
+		8086 4f43  ES1371, ES1373 AudioPCI On Motherboard OC440LX
+		8086 5243  ES1371, ES1373 AudioPCI On Motherboard RC440BX
+		8086 5352  ES1371, ES1373 AudioPCI On Motherboard SunRiver
+		8086 5643  ES1371, ES1373 AudioPCI On Motherboard Vancouver
+		8086 5753  ES1371, ES1373 AudioPCI On Motherboard WS440BX
+	5000  ES1370 [AudioPCI]
+	5880  5880 AudioPCI
+		1274 2000  Creative Sound Blaster AudioPCI128
+		1274 2003  Creative SoundBlaster AudioPCI 128
+		1274 5880  Creative Sound Blaster AudioPCI128
+		1274 8001  Sound Blaster 16PCI 4.1ch
+		1458 a000  5880 AudioPCI On Motherboard 6OXET
+		1462 6880  5880 AudioPCI On Motherboard MS-6188 1.00
+		270f 2001  5880 AudioPCI On Motherboard 6CTR
+		270f 2200  5880 AudioPCI On Motherboard 6WTX
+		270f 7040  5880 AudioPCI On Motherboard 6ATA4
+1275  Network Appliance Corporation
+1276  Switched Network Technologies, Inc.
+1277  Comstream
+1278  Transtech Parallel Systems Ltd.
+	0701  TPE3/TM3 PowerPC Node
+	0710  TPE5 PowerPC PCI board
+1279  Transmeta Corporation
+	0295  Northbridge
+	0395  LongRun Northbridge
+	0396  SDRAM controller
+	0397  BIOS scratchpad
+127a  Rockwell International
+	1002  HCF 56k Data/Fax Modem
+		1092 094c  SupraExpress 56i PRO [Diamond SUP2380]
+		122d 4002  HPG / MDP3858-U
+		122d 4005  MDP3858-E
+		122d 4007  MDP3858-A/-NZ
+		122d 4012  MDP3858-SA
+		122d 4017  MDP3858-W
+		122d 4018  MDP3858-W
+		127a 1002  Rockwell 56K D/F HCF Modem
+	1003  HCF 56k Data/Fax Modem
+		0e11 b0bc  229-DF Zephyr
+		0e11 b114  229-DF Cheetah
+		1033 802b  229-DF
+		13df 1003  PCI56RX Modem
+		13e0 0117  IBM
+		13e0 0147  IBM F-1156IV+/R3 Spain V.90 Modem
+		13e0 0197  IBM
+		13e0 01c7  IBM F-1156IV+/R3 WW V.90 Modem
+		13e0 01f7  IBM
+		1436 1003  IBM
+		1436 1103  IBM 5614PM3G V.90 Modem
+		1436 1602  Compaq 229-DF Ducati
+	1004  HCF 56k Data/Fax/Voice Modem
+		1048 1500  MicroLink 56k Modem
+		10cf 1059  Fujitsu 229-DFRT
+	1005  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+		1005 127a  AOpen FM56-P
+		1033 8029  229-DFSV
+		1033 8054  Modem
+		10cf 103c  Fujitsu
+		10cf 1055  Fujitsu 229-DFSV
+		10cf 1056  Fujitsu 229-DFSV
+		122d 4003  MDP3858SP-U
+		122d 4006  Packard Bell MDP3858V-E
+		122d 4008  MDP3858SP-A/SP-NZ
+		122d 4009  MDP3858SP-E
+		122d 4010  MDP3858V-U
+		122d 4011  MDP3858SP-SA
+		122d 4013  MDP3858V-A/V-NZ
+		122d 4015  MDP3858SP-W
+		122d 4016  MDP3858V-W
+		122d 4019  MDP3858V-SA
+		13df 1005  PCI56RVP Modem
+		13e0 0187  IBM
+		13e0 01a7  IBM
+		13e0 01b7  IBM DF-1156IV+/R3 Spain V.90 Modem
+		13e0 01d7  IBM DF-1156IV+/R3 WW V.90 Modem
+		1436 1005  IBM
+		1436 1105  IBM
+		1437 1105  IBM 5614PS3G V.90 Modem
+	1022  HCF 56k Modem
+		1436 1303  M3-5614PM3G V.90 Modem
+	1023  HCF 56k Data/Fax Modem
+		122d 4020  Packard Bell MDP3858-WE
+		122d 4023  MDP3858-UE
+		13e0 0247  IBM F-1156IV+/R6 Spain V.90 Modem
+		13e0 0297  IBM
+		13e0 02c7  IBM F-1156IV+/R6 WW V.90 Modem
+		1436 1203  IBM
+		1436 1303  IBM
+	1024  HCF 56k Data/Fax/Voice Modem
+	1025  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+		10cf 106a  Fujitsu 235-DFSV
+		122d 4021  Packard Bell MDP3858V-WE
+		122d 4022  MDP3858SP-WE
+		122d 4024  MDP3858V-UE
+		122d 4025  MDP3858SP-UE
+	1026  HCF 56k PCI Speakerphone Modem
+	1032  HCF 56k Modem
+	1033  HCF 56k Modem
+	1034  HCF 56k Modem
+	1035  HCF 56k PCI Speakerphone Modem
+	1036  HCF 56k Modem
+	1085  HCF 56k Volcano PCI Modem
+	2005  HCF 56k Data/Fax Modem
+		104d 8044  229-DFSV
+		104d 8045  229-DFSV
+		104d 8055  PBE/Aztech 235W-DFSV
+		104d 8056  235-DFSV
+		104d 805a  Modem
+		104d 805f  Modem
+		104d 8074  Modem
+	2013  HSF 56k Data/Fax Modem
+		1179 0001  Modem
+		1179 ff00  Modem
+	2014  HSF 56k Data/Fax/Voice Modem
+		10cf 1057  Fujitsu Citicorp III
+		122d 4050  MSP3880-U
+		122d 4055  MSP3880-W
+	2015  HSF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+		10cf 1063  Fujitsu
+		10cf 1064  Fujitsu
+		1468 2015  Fujitsu
+	2016  HSF 56k Data/Fax/Voice/Spkp Modem
+		122d 4051  MSP3880V-W
+		122d 4052  MSP3880SP-W
+		122d 4054  MSP3880V-U
+		122d 4056  MSP3880SP-U
+		122d 4057  MSP3880SP-A
+	4311  Riptide HSF 56k PCI Modem
+		127a 4311  Ring Modular? Riptide HSF RT HP Dom
+		13e0 0210  HP-GVC
+	4320  Riptide PCI Audio Controller
+		1235 4320  Riptide PCI Audio Controller
+	4321  Riptide HCF 56k PCI Modem
+		1235 4321  Hewlett Packard DF
+		1235 4324  Hewlett Packard DF
+		13e0 0210  Hewlett Packard DF
+		144d 2321  Riptide
+	4322  Riptide PCI Game Controller
+		1235 4322  Riptide PCI Game Controller
+	8234  RapidFire 616X ATM155 Adapter
+		108d 0022  RapidFire 616X ATM155 Adapter
+		108d 0027  RapidFire 616X ATM155 Adapter
+127b  Pixera Corporation
+127c  Crosspoint Solutions, Inc.
+127d  Vela Research
+127e  Winnov, L.P.
+127f  Fujifilm
+1280  Photoscript Group Ltd.
+1281  Yokogawa Electric Corporation
+1282  Davicom Semiconductor, Inc.
+	9009  Ethernet 100/10 MBit
+	9100  21x4x DEC-Tulip compatible 10/100 Ethernet
+	9102  21x4x DEC-Tulip compatible 10/100 Ethernet
+	9132  Ethernet 100/10 MBit
+1283  Integrated Technology Express, Inc.
+	673a  IT8330G
+	8212  IT/ITE8212 Dual channel ATA RAID controller (PCI version seems to be IT8212, embedded seems to be ITE8212)
+		1283 0001  IT/ITE8212 Dual channel ATA RAID controller
+	8330  IT8330G
+	8872  IT8874F PCI Dual Serial Port Controller
+	8888  IT8888F PCI to ISA Bridge with SMB
+	8889  IT8889F PCI to ISA Bridge
+	e886  IT8330G
+1284  Sahara Networks, Inc.
+1285  Platform Technologies, Inc.
+	0100  AGOGO sound chip (aka ESS Maestro 1)
+1286  Mazet GmbH
+1287  M-Pact, Inc.
+	001e  LS220D DVD Decoder
+	001f  LS220C DVD Decoder
+1288  Timestep Corporation
+1289  AVC Technology, Inc.
+128a  Asante Technologies, Inc.
+128b  Transwitch Corporation
+128c  Retix Corporation
+128d  G2 Networks, Inc.
+	0021  ATM155 Adapter
+128e  Hoontech Corporation/Samho Multi Tech Ltd.
+	0008  ST128 WSS/SB
+	0009  ST128 SAM9407
+	000a  ST128 Game Port
+	000b  ST128 MPU Port
+	000c  ST128 Ctrl Port
+128f  Tateno Dennou, Inc.
+1290  Sord Computer Corporation
+1291  NCS Computer Italia
+1292  Tritech Microelectronics Inc
+1293  Media Reality Technology
+1294  Rhetorex, Inc.
+1295  Imagenation Corporation
+1296  Kofax Image Products
+1297  Holco Enterprise Co, Ltd/Shuttle Computer
+1298  Spellcaster Telecommunications Inc.
+1299  Knowledge Technology Lab.
+129a  VMetro, inc.
+	0615  PBT-615 PCI-X Bus Analyzer
+129b  Image Access
+129c  Jaycor
+129d  Compcore Multimedia, Inc.
+129e  Victor Company of Japan, Ltd.
+129f  OEC Medical Systems, Inc.
+12a0  Allen-Bradley Company
+12a1  Simpact Associates, Inc.
+12a2  Newgen Systems Corporation
+12a3  Lucent Technologies
+	8105  T8105 H100 Digital Switch
+12a4  NTT Electronics Technology Company
+12a5  Vision Dynamics Ltd.
+12a6  Scalable Networks, Inc.
+12a7  AMO GmbH
+12a8  News Datacom
+12a9  Xiotech Corporation
+12aa  SDL Communications, Inc.
+12ab  Yuan Yuan Enterprise Co., Ltd.
+	0002  AU8830 [Vortex2] Based Sound Card With A3D Support
+	3000  MPG-200C PCI DVD Decoder Card
+12ac  Measurex Corporation
+12ad  Multidata GmbH
+12ae  Alteon Networks Inc.
+	0001  AceNIC Gigabit Ethernet
+		1014 0104  Gigabit Ethernet-SX PCI Adapter
+		12ae 0001  Gigabit Ethernet-SX (Universal)
+		1410 0104  Gigabit Ethernet-SX PCI Adapter
+	0002  AceNIC Gigabit Ethernet (Copper)
+		10a9 8002  Acenic Gigabit Ethernet
+		12ae 0002  Gigabit Ethernet-T (3C986-T)
+	00fa  Farallon PN9100-T Gigabit Ethernet
+12af  TDK USA Corp
+12b0  Jorge Scientific Corp
+12b1  GammaLink
+12b2  General Signal Networks
+12b3  Inter-Face Co Ltd
+12b4  FutureTel Inc
+12b5  Granite Systems Inc.
+12b6  Natural Microsystems
+12b7  Cognex Modular Vision Systems Div. - Acumen Inc.
+12b8  Korg
+12b9  3Com Corp, Modem Division (formerly US Robotics)
+	1006  WinModem
+		12b9 005c  USR 56k Internal Voice WinModem (Model 3472)
+		12b9 005e  USR 56k Internal WinModem (Models 662975)
+		12b9 0062  USR 56k Internal Voice WinModem (Model 662978)
+		12b9 0068  USR 56k Internal Voice WinModem (Model 5690)
+		12b9 007a  USR 56k Internal Voice WinModem (Model 662974)
+		12b9 007f  USR 56k Internal WinModem (Models 5698, 5699)
+		12b9 0080  USR 56k Internal WinModem (Models 2975, 3528)
+		12b9 0081  USR 56k Internal Voice WinModem (Models 2974, 3529)
+		12b9 0091  USR 56k Internal Voice WinModem (Model 2978)
+	1007  USR 56k Internal WinModem
+		12b9 00a3  USR 56k Internal WinModem (Model 3595)
+	1008  56K FaxModem Model 5610
+		12b9 00a2  USR 56k Internal FAX Modem (Model 2977)
+		12b9 00aa  USR 56k Internal Voice Modem (Model 2976)
+		12b9 00ab  USR 56k Internal Voice Modem (Model 5609)
+		12b9 00ac  USR 56k Internal Voice Modem (Model 3298)
+		12b9 00ad  USR 56k Internal FAX Modem (Model 5610)
+12ba  BittWare, Inc.
+12bb  Nippon Unisoft Corporation
+12bc  Array Microsystems
+12bd  Computerm Corp.
+12be  Anchor Chips Inc.
+	3041  AN3041Q CO-MEM
+	3042  AN3042Q CO-MEM Lite
+		12be 3042  Anchor Chips Lite Evaluation Board
+12bf  Fujifilm Microdevices
+12c0  Infimed
+12c1  GMM Research Corp
+12c2  Mentec Limited
+12c3  Holtek Microelectronics Inc
+	0058  PCI NE2K Ethernet
+	5598  PCI NE2K Ethernet
+12c4  Connect Tech Inc
+	0001  Blue HEAT/PCI 8 (RS232/CL/RJ11)
+	0002  Blue HEAT/PCI 4 (RS232)
+	0003  Blue HEAT/PCI 2 (RS232)
+	0004  Blue HEAT/PCI 8 (UNIV, RS485)
+	0005  Blue HEAT/PCI 4+4/6+2 (UNIV, RS232/485)
+	0006  Blue HEAT/PCI 4 (OPTO, RS485)
+	0007  Blue HEAT/PCI 2+2 (RS232/485)
+	0008  Blue HEAT/PCI 2 (OPTO, Tx, RS485)
+	0009  Blue HEAT/PCI 2+6 (RS232/485)
+	000a  Blue HEAT/PCI 8 (Tx, RS485)
+	000b  Blue HEAT/PCI 4 (Tx, RS485)
+	000c  Blue HEAT/PCI 2 (20 MHz, RS485)
+	000d  Blue HEAT/PCI 2 PTM
+	0100  NT960/PCI
+	0201  cPCI Titan - 2 Port
+	0202  cPCI Titan - 4 Port
+	0300  CTI PCI UART 2 (RS232)
+	0301  CTI PCI UART 4 (RS232)
+	0302  CTI PCI UART 8 (RS232)
+	0310  CTI PCI UART 1+1 (RS232/485)
+	0311  CTI PCI UART 2+2 (RS232/485)
+	0312  CTI PCI UART 4+4 (RS232/485)
+	0320  CTI PCI UART 2
+	0321  CTI PCI UART 4
+	0322  CTI PCI UART 8
+	0330  CTI PCI UART 2 (RS485)
+	0331  CTI PCI UART 4 (RS485)
+	0332  CTI PCI UART 8 (RS485)
+12c5  Picture Elements Incorporated
+	007e  Imaging/Scanning Subsystem Engine
+	007f  Imaging/Scanning Subsystem Engine
+	0081  PCIVST [Grayscale Thresholding Engine]
+	0085  Video Simulator/Sender
+	0086  THR2 Multi-scale Thresholder
+12c6  Mitani Corporation
+12c7  Dialogic Corp
+12c8  G Force Co, Ltd
+12c9  Gigi Operations
+12ca  Integrated Computing Engines
+12cb  Antex Electronics Corporation
+12cc  Pluto Technologies International
+12cd  Aims Lab
+12ce  Netspeed Inc.
+12cf  Prophet Systems, Inc.
+12d0  GDE Systems, Inc.
+12d1  PSITech
+12d2  NVidia / SGS Thomson (Joint Venture)
+	0008  NV1
+	0009  DAC64
+	0018  Riva128
+		1048 0c10  VICTORY Erazor
+		107b 8030  STB Velocity 128
+		1092 0350  Viper V330
+		1092 1092  Viper V330
+		10b4 1b1b  STB Velocity 128
+		10b4 1b1d  STB Velocity 128
+		10b4 1b1e  STB Velocity 128, PAL TV-Out
+		10b4 1b20  STB Velocity 128 Sapphire
+		10b4 1b21  STB Velocity 128
+		10b4 1b22  STB Velocity 128 AGP, NTSC TV-Out
+		10b4 1b23  STB Velocity 128 AGP, PAL TV-Out
+		10b4 1b27  STB Velocity 128 DVD
+		10b4 1b88  MVP Pro 128
+		10b4 222a  STB Velocity 128 AGP
+		10b4 2230  STB Velocity 128
+		10b4 2232  STB Velocity 128
+		10b4 2235  STB Velocity 128 AGP
+		2a15 54a3  3DVision-SAGP / 3DexPlorer 3000
+	0019  Riva128ZX
+	0020  TNT
+	0028  TNT2
+	0029  UTNT2
+	002c  VTNT2
+	00a0  ITNT2
+12d3  Vingmed Sound A/S
+12d4  Ulticom (Formerly DGM&S)
+	0200  T1 Card
+12d5  Equator Technologies Inc
+	0003  BSP16
+	1000  BSP15
+12d6  Analogic Corp
+12d7  Biotronic SRL
+12d8  Pericom Semiconductor
+12d9  Aculab PLC
+	0002  PCI Prosody
+	0004  cPCI Prosody
+	0005  Aculab E1/T1 PCI card
+12da  True Time Inc.
+12db  Annapolis Micro Systems, Inc
+12dc  Symicron Computer Communication Ltd.
+12dd  Management Graphics
+12de  Rainbow Technologies
+	0200  CryptoSwift CS200
+12df  SBS Technologies Inc
+12e0  Chase Research
+	0010  ST16C654 Quad UART
+	0020  ST16C654 Quad UART
+	0030  ST16C654 Quad UART
+12e1  Nintendo Co, Ltd
+12e2  Datum Inc. Bancomm-Timing Division
+12e3  Imation Corp - Medical Imaging Systems
+12e4  Brooktrout Technology Inc
+12e5  Apex Semiconductor Inc
+12e6  Cirel Systems
+12e7  Sunsgroup Corporation
+12e8  Crisc Corp
+12e9  GE Spacenet
+12ea  Zuken
+12eb  Aureal Semiconductor
+	0001  Vortex 1
+		104d 8036  AU8820 Vortex Digital Audio Processor
+		1092 2000  Sonic Impact A3D
+		1092 2100  Sonic Impact A3D
+		1092 2110  Sonic Impact A3D
+		1092 2200  Sonic Impact A3D
+		122d 1002  AU8820 Vortex Digital Audio Processor
+		12eb 0001  AU8820 Vortex Digital Audio Processor
+		5053 3355  Montego
+	0002  Vortex 2
+		104d 8049  AU8830 Vortex 3D Digital Audio Processor
+		104d 807b  AU8830 Vortex 3D Digital Audio Processor
+		1092 3000  Monster Sound II
+		1092 3001  Monster Sound II
+		1092 3002  Monster Sound II
+		1092 3003  Monster Sound II
+		1092 3004  Monster Sound II
+		12eb 0001  AU8830 Vortex 3D Digital Audio Processor
+		12eb 0002  AU8830 Vortex 3D Digital Audio Processor
+		12eb 0088  AU8830 Vortex 3D Digital Audio Processor
+		144d 3510  AU8830 Vortex 3D Digital Audio Processor
+		5053 3356  Montego II
+	0003  AU8810 Vortex Digital Audio Processor
+		104d 8049  AU8810 Vortex Digital Audio Processor
+		104d 8077  AU8810 Vortex Digital Audio Processor
+		109f 1000  AU8810 Vortex Digital Audio Processor
+		12eb 0003  AU8810 Vortex Digital Audio Processor
+		1462 6780  AU8810 Vortex Digital Audio Processor
+		14a4 2073  AU8810 Vortex Digital Audio Processor
+		14a4 2091  AU8810 Vortex Digital Audio Processor
+		14a4 2104  AU8810 Vortex Digital Audio Processor
+		14a4 2106  AU8810 Vortex Digital Audio Processor
+	8803  Vortex 56k Software Modem
+		12eb 8803  Vortex 56k Software Modem
+12ec  3A International, Inc.
+12ed  Optivision Inc.
+12ee  Orange Micro
+12ef  Vienna Systems
+12f0  Pentek
+12f1  Sorenson Vision Inc
+12f2  Gammagraphx, Inc.
+12f3  Radstone Technology
+12f4  Megatel
+12f5  Forks
+12f6  Dawson France
+12f7  Cognex
+12f8  Electronic Design GmbH
+	0002  VideoMaker
+12f9  Four Fold Ltd
+12fb  Spectrum Signal Processing
+12fc  Capital Equipment Corp
+12fd  I2S
+12fe  ESD Electronic System Design GmbH
+12ff  Lexicon
+1300  Harman International Industries Inc
+1302  Computer Sciences Corp
+1303  Innovative Integration
+1304  Juniper Networks
+1305  Netphone, Inc
+1306  Duet Technologies
+# Formerly ComputerBoards
+1307  Measurement Computing
+	0001  PCI-DAS1602/16
+	000b  PCI-DIO48H
+	000c  PCI-PDISO8
+	000d  PCI-PDISO16
+	000f  PCI-DAS1200
+	0010  PCI-DAS1602/12
+	0014  PCI-DIO24H
+	0015  PCI-DIO24H/CTR3
+	0016  PCI-DIO48H/CTR15
+	0017  PCI-DIO96H
+	0018  PCI-CTR05
+	0019  PCI-DAS1200/JR
+	001a  PCI-DAS1001
+	001b  PCI-DAS1002
+	001c  PCI-DAS1602JR/16
+	001d  PCI-DAS6402/16
+	001e  PCI-DAS6402/12
+	001f  PCI-DAS16/M1
+	0020  PCI-DDA02/12
+	0021  PCI-DDA04/12
+	0022  PCI-DDA08/12
+	0023  PCI-DDA02/16
+	0024  PCI-DDA04/16
+	0025  PCI-DDA08/16
+	0026  PCI-DAC04/12-HS
+	0027  PCI-DAC04/16-HS
+	0028  PCI-DIO24
+	0029  PCI-DAS08
+	002c  PCI-INT32
+	0033  PCI-DUAL-AC5
+	0034  PCI-DAS-TC
+	0035  PCI-DAS64/M1/16
+	0036  PCI-DAS64/M2/16
+	0037  PCI-DAS64/M3/16
+	004c  PCI-DAS1000
+	004d  PCI-QUAD04
+	0052  PCI-DAS4020/12
+	005e  PCI-DAS6025
+1308  Jato Technologies Inc.
+	0001  NetCelerator Adapter
+		1308 0001  NetCelerator Adapter
+1309  AB Semiconductor Ltd
+130a  Mitsubishi Electric Microcomputer
+130b  Colorgraphic Communications Corp
+130c  Ambex Technologies, Inc
+130d  Accelerix Inc
+130e  Yamatake-Honeywell Co. Ltd
+130f  Advanet Inc
+1310  Gespac
+1311  Videoserver, Inc
+1312  Acuity Imaging, Inc
+1313  Yaskawa Electric Co.
+1316  Teradyne Inc
+1317  Linksys
+	0981  21x4x DEC-Tulip compatible 10/100 Ethernet
+	0985  NC100 Network Everywhere Fast Ethernet 10/100
+	1985  21x4x DEC-Tulip compatible 10/100 Ethernet
+	2850  HSP MicroModem 56
+	8201  ADMtek ADM8211 802.11b Wireless Interface
+		10b8 2635  SMC2635W 802.11b (11Mbps) wireless lan pcmcia (cardbus) card
+		1317 8201  SMC2635W 802.11b (11mbps) wireless lan pcmcia (cardbus) card
+	8211  ADMtek ADM8211 802.11b Wireless Interface
+	9511  21x4x DEC-Tulip compatible 10/100 Ethernet
+1318  Packet Engines Inc.
+	0911  GNIC-II PCI Gigabit Ethernet [Hamachi]
+1319  Fortemedia, Inc
+	0801  Xwave QS3000A [FM801]
+	0802  Xwave QS3000A [FM801 game port]
+	1000  FM801 PCI Audio
+	1001  FM801 PCI Joystick
+131a  Finisar Corp.
+131c  Nippon Electro-Sensory Devices Corp
+131d  Sysmic, Inc.
+131e  Xinex Networks Inc
+131f  Siig Inc
+	1000  CyberSerial (1-port) 16550
+	1001  CyberSerial (1-port) 16650
+	1002  CyberSerial (1-port) 16850
+	1010  Duet 1S(16550)+1P
+	1011  Duet 1S(16650)+1P
+	1012  Duet 1S(16850)+1P
+	1020  CyberParallel (1-port)
+	1021  CyberParallel (2-port)
+	1030  CyberSerial (2-port) 16550
+	1031  CyberSerial (2-port) 16650
+	1032  CyberSerial (2-port) 16850
+	1034  Trio 2S(16550)+1P
+	1035  Trio 2S(16650)+1P
+	1036  Trio 2S(16850)+1P
+	1050  CyberSerial (4-port) 16550
+	1051  CyberSerial (4-port) 16650
+	1052  CyberSerial (4-port) 16850
+	2000  CyberSerial (1-port) 16550
+	2001  CyberSerial (1-port) 16650
+	2002  CyberSerial (1-port) 16850
+	2010  Duet 1S(16550)+1P
+	2011  Duet 1S(16650)+1P
+	2012  Duet 1S(16850)+1P
+	2020  CyberParallel (1-port)
+	2021  CyberParallel (2-port)
+	2030  CyberSerial (2-port) 16550
+		131f 2030  PCI Serial Card
+	2031  CyberSerial (2-port) 16650
+	2032  CyberSerial (2-port) 16850
+	2040  Trio 1S(16550)+2P
+	2041  Trio 1S(16650)+2P
+	2042  Trio 1S(16850)+2P
+	2050  CyberSerial (4-port) 16550
+	2051  CyberSerial (4-port) 16650
+	2052  CyberSerial (4-port) 16850
+	2060  Trio 2S(16550)+1P
+	2061  Trio 2S(16650)+1P
+	2062  Trio 2S(16850)+1P
+	2081  CyberSerial (8-port) ST16654
+1320  Crypto AG
+1321  Arcobel Graphics BV
+1322  MTT Co., Ltd
+1323  Dome Inc
+1324  Sphere Communications
+1325  Salix Technologies, Inc
+1326  Seachange international
+1327  Voss scientific
+1328  quadrant international
+1329  Productivity Enhancement
+132a  Microcom Inc.
+132b  Broadband Technologies
+132c  Micrel Inc
+132d  Integrated Silicon Solution, Inc.
+1330  MMC Networks
+1331  Radisys Corp.
+	0030  ENP-2611
+	8200  82600 Host Bridge
+	8201  82600 IDE
+	8202  82600 USB
+	8210  82600 PCI Bridge
+1332  Micro Memory
+	5415  MM-5415CN PCI Memory Module with Battery Backup
+	5425  MM-5425CN PCI 64/66 Memory Module with Battery Backup
+1334  Redcreek Communications, Inc
+1335  Videomail, Inc
+1337  Third Planet Publishing
+1338  BT Electronics
+133a  Vtel Corp
+133b  Softcom Microsystems
+133c  Holontech Corp
+133d  SS Technologies
+133e  Virtual Computer Corp
+133f  SCM Microsystems
+1340  Atalla Corp
+1341  Kyoto Microcomputer Co
+1342  Promax Systems Inc
+1343  Phylon Communications Inc
+1344  Crucial Technology
+1345  Arescom Inc
+1347  Odetics
+1349  Sumitomo Electric Industries, Ltd.
+134a  DTC Technology Corp.
+	0001  Domex 536
+	0002  Domex DMX3194UP SCSI Adapter
+134b  ARK Research Corp.
+134c  Chori Joho System Co. Ltd
+134d  PCTel Inc
+	2189  HSP56 MicroModem
+	2486  2304WT V.92 MDC Modem
+	7890  HSP MicroModem 56
+		134d 0001  PCT789 adapter
+	7891  HSP MicroModem 56
+		134d 0001  HSP MicroModem 56
+	7892  HSP MicroModem 56
+	7893  HSP MicroModem 56
+	7894  HSP MicroModem 56
+	7895  HSP MicroModem 56
+	7896  HSP MicroModem 56
+	7897  HSP MicroModem 56
+134e  CSTI
+134f  Algo System Co Ltd
+1350  Systec Co. Ltd
+1351  Sonix Inc
+1353  Thales Idatys
+	0002  Proserver
+	0003  PCI-FUT
+	0004  PCI-S0
+	0005  PCI-FUT-S0
+1354  Dwave System Inc
+1355  Kratos Analytical Ltd
+1356  The Logical Co
+1359  Prisa Networks
+135a  Brain Boxes
+135b  Giganet Inc
+135c  Quatech Inc
+	0010  QSC-100
+	0020  DSC-100
+	0030  DSC-200/300
+	0040  QSC-200/300
+	0050  ESC-100D
+	0060  ESC-100M
+	00f0  MPAC-100 Syncronous Serial Card (Zilog 85230)
+	0170  QSCLP-100
+	0180  DSCLP-100
+	0190  SSCLP-100
+	01a0  QSCLP-200/300
+	01b0  DSCLP-200/300
+	01c0  SSCLP-200/300
+135d  ABB Network Partner AB
+135e  Sealevel Systems Inc
+	5101  Route 56.PCI - Multi-Protocol Serial Interface (Zilog Z16C32)
+	7101  Single Port RS-232/422/485/530
+	7201  Dual Port RS-232/422/485 Interface
+	7202  Dual Port RS-232 Interface
+	7401  Four Port RS-232 Interface
+	7402  Four Port RS-422/485 Interface
+	7801  Eight Port RS-232 Interface
+	7804  Eight Port RS-232/422/485 Interface
+	8001  8001 Digital I/O Adapter
+135f  I-Data International A-S
+1360  Meinberg Funkuhren
+	0101  PCI32 DCF77 Radio Clock
+	0102  PCI509 DCF77 Radio Clock
+	0103  PCI510 DCF77 Radio Clock
+	0201  GPS167PCI GPS Receiver
+	0202  GPS168PCI GPS Receiver
+	0203  GPS169PCI GPS Receiver
+	0301  TCR510PCI IRIG Receiver
+1361  Soliton Systems K.K.
+1362  Fujifacom Corporation
+1363  Phoenix Technology Ltd
+1364  ATM Communications Inc
+1365  Hypercope GmbH
+1366  Teijin Seiki Co. Ltd
+1367  Hitachi Zosen Corporation
+1368  Skyware Corporation
+1369  Digigram
+136a  High Soft Tech
+136b  Kawasaki Steel Corporation
+	ff01  KL5A72002 Motion JPEG
+136c  Adtek System Science Co Ltd
+136d  Gigalabs Inc
+136f  Applied Magic Inc
+1370  ATL Products
+1371  CNet Technology Inc
+	434e  GigaCard Network Adapter
+		1371 434e  N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
+1373  Silicon Vision Inc
+1374  Silicom Ltd
+1375  Argosystems Inc
+1376  LMC
+1377  Electronic Equipment Production & Distribution GmbH
+1378  Telemann Co. Ltd
+1379  Asahi Kasei Microsystems Co Ltd
+137a  Mark of the Unicorn Inc
+	0001  PCI-324 Audiowire Interface
+137b  PPT Vision
+137c  Iwatsu Electric Co Ltd
+137d  Dynachip Corporation
+137e  Patriot Scientific Corporation
+137f  Japan Satellite Systems Inc
+1380  Sanritz Automation Co Ltd
+1381  Brains Co. Ltd
+1382  Marian - Electronic & Software
+	0001  ARC88 audio recording card
+	2008  Prodif 96 Pro sound system
+	2088  Marc 8 Midi sound system
+	20c8  Marc A sound system
+	4008  Marc 2 sound system
+	4010  Marc 2 Pro sound system
+	4048  Marc 4 MIDI sound system
+	4088  Marc 4 Digi sound system
+	4248  Marc X sound system
+1383  Controlnet Inc
+1384  Reality Simulation Systems Inc
+1385  Netgear
+# Note: This lists as Atheros Communications, Inc. AR5212 802.11abg NIC because of Madwifi
+	0013  WG311T
+	311a  GA511 Gigabit Ethernet
+	4100  802.11b Wireless Adapter (MA301)
+	4105  MA311 802.11b wireless adapter
+	4400  WAG511 802.11a/b/g Dual Band Wireless PC Card
+	4600  WAG511 802.11a/b/g Dual Band Wireless PC Card
+	4601  WAG511 802.11a/b/g Dual Band Wireless PC Card
+	4610  WAG511 802.11a/b/g Dual Band Wireless PC Card
+	4a00  WAG311 802.11a/g Wireless PCI Adapter
+	4c00  WG311v2 54 Mbps Wireless PCI Adapter
+	620a  GA620 Gigabit Ethernet
+	622a  GA622
+	630a  GA630 Gigabit Ethernet
+	f004  FA310TX
+1386  Video Domain Technologies
+1387  Systran Corp
+1388  Hitachi Information Technology Co Ltd
+1389  Applicom International
+	0001  PCI1500PFB [Intelligent fieldbus adaptor]
+138a  Fusion Micromedia Corp
+138b  Tokimec Inc
+138c  Silicon Reality
+138d  Future Techno Designs pte Ltd
+138e  Basler GmbH
+138f  Patapsco Designs Inc
+1390  Concept Development Inc
+1391  Development Concepts Inc
+1392  Medialight Inc
+1393  Moxa Technologies Co Ltd
+	1040  Smartio C104H/PCI
+	1141  Industrio CP-114
+	1680  Smartio C168H/PCI
+	2040  Intellio CP-204J
+	2180  Intellio C218 Turbo PCI
+	3200  Intellio C320 Turbo PCI
+1394  Level One Communications
+	0001  LXT1001 Gigabit Ethernet
+		1394 0001  NetCelerator Adapter
+1395  Ambicom Inc
+1396  Cipher Systems Inc
+1397  Cologne Chip Designs GmbH
+	2bd0  ISDN network controller [HFC-PCI]
+		1397 2bd0  ISDN Board
+		e4bf 1000  CI1-1-Harp
+1398  Clarion co. Ltd
+1399  Rios systems Co Ltd
+139a  Alacritech Inc
+	0001  Quad Port 10/100 Server Accelerator
+	0003  Single Port 10/100 Server Accelerator
+	0005  Single Port Gigabit Server Accelerator
+139b  Mediasonic Multimedia Systems Ltd
+139c  Quantum 3d Inc
+139d  EPL limited
+139e  Media4
+139f  Aethra s.r.l.
+13a0  Crystal Group Inc
+13a1  Kawasaki Heavy Industries Ltd
+13a2  Ositech Communications Inc
+13a3  Hifn Inc.
+	0005  7751 Security Processor
+	0006  6500 Public Key Processor
+	0007  7811 Security Processor
+	0012  7951 Security Processor
+	0014  78XX Security Processor
+	0016  8065 Security Processor
+	0017  8165 Security Processor
+	0018  8154 Security Processor
+	001d  7956 Security Processor
+	0020  7955 Security Processor
+13a4  Rascom Inc
+13a5  Audio Digital Imaging Inc
+13a6  Videonics Inc
+13a7  Teles AG
+13a8  Exar Corp.
+	0154  XR17C154 Quad UART
+	0158  XR17C158 Octal UART
+13a9  Siemens Medical Systems, Ultrasound Group
+13aa  Broadband Networks Inc
+13ab  Arcom Control Systems Ltd
+13ac  Motion Media Technology Ltd
+13ad  Nexus Inc
+13ae  ALD Technology Ltd
+13af  T.Sqware
+13b0  Maxspeed Corp
+13b1  Tamura corporation
+13b2  Techno Chips Co. Ltd
+13b3  Lanart Corporation
+13b4  Wellbean Co Inc
+13b5  ARM
+13b6  Dlog GmbH
+13b7  Logic Devices Inc
+13b8  Nokia Telecommunications oy
+13b9  Elecom Co Ltd
+13ba  Oxford Instruments
+13bb  Sanyo Technosound Co Ltd
+13bc  Bitran Corporation
+13bd  Sharp corporation
+13be  Miroku Jyoho Service Co. Ltd
+13bf  Sharewave Inc
+13c0  Microgate Corporation
+	0010  SyncLink Adapter v1
+	0020  SyncLink SCC Adapter
+	0030  SyncLink Multiport Adapter
+	0210  SyncLink Adapter v2
+13c1  3ware Inc
+	1000  3ware Inc 3ware 5xxx/6xxx-series PATA-RAID
+	1001  3ware Inc 3ware 7xxx/8xxx-series PATA/SATA-RAID
+		13c1 1001  3ware Inc 3ware 7xxx/8xxx-series PATA/SATA-RAID
+	1002  3ware Inc 3ware 9xxx-series SATA-RAID
+13c2  Technotrend Systemtechnik GmbH
+13c3  Janz Computer AG
+13c4  Phase Metrics
+13c5  Alphi Technology Corp
+13c6  Condor Engineering Inc
+	0520  CEI-520 A429 Card
+	0620  CEI-620 A429 Card
+	0820  CEI-820 A429 Card
+13c7  Blue Chip Technology Ltd
+13c8  Apptech Inc
+13c9  Eaton Corporation
+13ca  Iomega Corporation
+13cb  Yano Electric Co Ltd
+13cc  Metheus Corporation
+13cd  Compatible Systems Corporation
+13ce  Cocom A/S
+13cf  Studio Audio & Video Ltd
+13d0  Techsan Electronics Co Ltd
+	2103  B2C2 FlexCopII DVB chip / Technisat SkyStar2 DVB card
+	2200  B2C2 FlexCopIII DVB chip / Technisat SkyStar2 DVB card
+13d1  Abocom Systems Inc
+	ab02  ADMtek Centaur-C rev 17 [D-Link DFE-680TX] CardBus Fast Ethernet Adapter
+	ab03  21x4x DEC-Tulip compatible 10/100 Ethernet
+	ab06  RTL8139 [FE2000VX] CardBus Fast Ethernet Attached Port Adapter
+	ab08  21x4x DEC-Tulip compatible 10/100 Ethernet
+13d2  Shark Multimedia Inc
+13d3  IMC Networks
+13d4  Graphics Microsystems Inc
+13d5  Media 100 Inc
+13d6  K.I. Technology Co Ltd
+13d7  Toshiba Engineering Corporation
+13d8  Phobos corporation
+13d9  Apex PC Solutions Inc
+13da  Intresource Systems pte Ltd
+13db  Janich & Klass Computertechnik GmbH
+13dc  Netboost Corporation
+13dd  Multimedia Bundle Inc
+13de  ABB Robotics Products AB
+13df  E-Tech Inc
+	0001  PCI56RVP Modem
+		13df 0001  PCI56RVP Modem
+13e0  GVC Corporation
+13e1  Silicom Multimedia Systems Inc
+13e2  Dynamics Research Corporation
+13e3  Nest Inc
+13e4  Calculex Inc
+13e5  Telesoft Design Ltd
+13e6  Argosy research Inc
+13e7  NAC Incorporated
+13e8  Chip Express Corporation
+13e9  Intraserver Technology Inc
+13ea  Dallas Semiconductor
+13eb  Hauppauge Computer Works Inc
+13ec  Zydacron Inc
+13ed  Raytheion E-Systems
+13ee  Hayes Microcomputer Products Inc
+13ef  Coppercom Inc
+13f0  Sundance Technology Inc
+	0201  ST201 Sundance Ethernet
+13f1  Oce' - Technologies B.V.
+13f2  Ford Microelectronics Inc
+13f3  Mcdata Corporation
+13f4  Troika Networks, Inc.
+	1401  Zentai Fibre Channel Adapter
+13f5  Kansai Electric Co. Ltd
+13f6  C-Media Electronics Inc
+	0011  CMI8738
+	0100  CM8338A
+		13f6 ffff  CMI8338/C3DX PCI Audio Device
+	0101  CM8338B
+		13f6 0101  CMI8338-031 PCI Audio Device
+	0111  CM8738
+		1019 0970  P6STP-FL motherboard
+		1043 8035  CUSI-FX motherboard
+		1043 8077  CMI8738 6-channel audio controller
+		1043 80e2  CMI8738 6ch-MX
+		13f6 0111  CMI8738/C3DX PCI Audio Device
+		1681 a000  Gamesurround MUSE XL
+	0211  CM8738
+13f7  Wildfire Communications
+13f8  Ad Lib Multimedia Inc
+13f9  NTT Advanced Technology Corp.
+13fa  Pentland Systems Ltd
+13fb  Aydin Corp
+13fc  Computer Peripherals International
+13fd  Micro Science Inc
+13fe  Advantech Co. Ltd
+	1240  PCI-1240 4-channel stepper motor controller card w.  Nova Electronics MCX314
+	1600  PCI-1612 4-port RS-232/422/485 PCI Communication Card
+	1752  PCI-1752
+	1754  PCI-1754
+	1756  PCI-1756
+13ff  Silicon Spice Inc
+1400  Artx Inc
+	1401  9432 TX
+1401  CR-Systems A/S
+1402  Meilhaus Electronic GmbH
+1403  Ascor Inc
+1404  Fundamental Software Inc
+1405  Excalibur Systems Inc
+1406  Oce' Printing Systems GmbH
+1407  Lava Computer mfg Inc
+	0100  Lava Dual Serial
+	0101  Lava Quatro A
+	0102  Lava Quatro B
+	0110  Lava DSerial-PCI Port A
+	0111  Lava DSerial-PCI Port B
+	0120  Quattro-PCI A
+	0121  Quattro-PCI B
+	0180  Lava Octo A
+	0181  Lava Octo B
+	0200  Lava Port Plus
+	0201  Lava Quad A
+	0202  Lava Quad B
+	0220  Lava Quattro PCI Ports A/B
+	0221  Lava Quattro PCI Ports C/D
+	0500  Lava Single Serial
+	0600  Lava Port 650
+	8000  Lava Parallel
+	8001  Dual parallel port controller A
+	8002  Lava Dual Parallel port A
+	8003  Lava Dual Parallel port B
+	8800  BOCA Research IOPPAR
+1408  Aloka Co. Ltd
+1409  Timedia Technology Co Ltd
+	7168  PCI2S550 (Dual 16550 UART)
+140a  DSP Research Inc
+140b  Ramix Inc
+140c  Elmic Systems Inc
+140d  Matsushita Electric Works Ltd
+140e  Goepel Electronic GmbH
+140f  Salient Systems Corp
+1410  Midas lab Inc
+1411  Ikos Systems Inc
+# formerly IC Ensemble Inc.
+1412  VIA Technologies Inc.
+	1712  ICE1712 [Envy24] PCI Multi-Channel I/O Controller
+		1412 1712  Hoontech ST Audio DSP 24
+		1412 d630  M-Audio Delta 1010
+		1412 d631  M-Audio Delta DiO
+		1412 d632  M-Audio Delta 66
+		1412 d633  M-Audio Delta 44
+		1412 d634  M-Audio Delta Audiophile
+		1412 d635  M-Audio Delta TDIF
+		1412 d637  M-Audio Delta RBUS
+		1412 d638  M-Audio Delta 410
+		1412 d63b  M-Audio Delta 1010LT
+		1412 d63c  Digigram VX442
+		1416 1712  Hoontech ST Audio DSP 24 Media 7.1
+		153b 1115  EWS88 MT
+		153b 1125  EWS88 MT (Master)
+		153b 112b  EWS88 D
+		153b 112c  EWS88 D (Master)
+		153b 1130  EWX 24/96
+		153b 1138  DMX 6fire 24/96
+		153b 1151  PHASE88
+		16ce 1040  Edirol DA-2496
+	1724  VT1720/24 [Envy24PT/HT] PCI Multi-Channel Audio Controller
+		1412 1724  AMP Ltd AUDIO2000
+		1412 3630  M-Audio Revolution 7.1
+		153b 1145  Aureon 7.1 Space
+		153b 1147  Aureon 5.1 Sky
+		153b 1153  Aureon 7.1 Universe
+		270f f641  ZNF3-150
+		270f f645  ZNF3-250
+1413  Addonics
+1414  Microsoft Corporation
+1415  Oxford Semiconductor Ltd
+	8403  VScom 011H-EP1 1 port parallel adaptor
+	9501  OX16PCI954 (Quad 16950 UART) function 0
+		131f 2050  CyberPro (4-port)
+# Model IO1085, Part No: JJ-P46012
+		131f 2051  CyberSerial 4S Plus
+		15ed 2000  MCCR Serial p0-3 of 8
+		15ed 2001  MCCR Serial p0-3 of 16
+	950a  EXSYS EX-41092 Dual 16950 Serial adapter
+	950b  OXCB950 Cardbus 16950 UART
+	9510  OX16PCI954 (Quad 16950 UART) function 1 (Disabled)
+	9511  OX16PCI954 (Quad 16950 UART) function 1
+		15ed 2000  MCCR Serial p4-7 of 8
+		15ed 2001  MCCR Serial p4-15 of 16
+	9521  OX16PCI952 (Dual 16950 UART)
+1416  Multiwave Innovation pte Ltd
+1417  Convergenet Technologies Inc
+1418  Kyushu electronics systems Inc
+1419  Excel Switching Corp
+141a  Apache Micro Peripherals Inc
+141b  Zoom Telephonics Inc
+141d  Digitan Systems Inc
+141e  Fanuc Ltd
+141f  Visiontech Ltd
+1420  Psion Dacom plc
+	8002  Gold Card NetGlobal 56k+10/100Mb CardBus (Ethernet part)
+	8003  Gold Card NetGlobal 56k+10/100Mb CardBus (Modem part)
+1421  Ads Technologies Inc
+1422  Ygrec Systems Co Ltd
+1423  Custom Technology Corp.
+1424  Videoserver Connections
+1425  Chelsio Communications Inc
+1426  Storage Technology Corp.
+1427  Better On-Line Solutions
+1428  Edec Co Ltd
+1429  Unex Technology Corp.
+142a  Kingmax Technology Inc
+142b  Radiolan
+142c  Minton Optic Industry Co Ltd
+142d  Pix stream Inc
+142e  Vitec Multimedia
+	4020  VM2-2 [Video Maker 2] MPEG1/2 Encoder
+142f  Radicom Research Inc
+1430  ITT Aerospace/Communications Division
+1431  Gilat Satellite Networks
+1432  Edimax Computer Co.
+	9130  RTL81xx Fast Ethernet
+1433  Eltec Elektronik GmbH
+1435  Real Time Devices US Inc.
+1436  CIS Technology Inc
+1437  Nissin Inc Co
+1438  Atmel-dream
+1439  Outsource Engineering & Mfg. Inc
+143a  Stargate Solutions Inc
+143b  Canon Research Center, America
+143c  Amlogic Inc
+143d  Tamarack Microelectronics Inc
+143e  Jones Futurex Inc
+143f  Lightwell Co Ltd - Zax Division
+1440  ALGOL Corp.
+1441  AGIE Ltd
+1442  Phoenix Contact GmbH & Co.
+1443  Unibrain S.A.
+1444  TRW
+1445  Logical DO Ltd
+1446  Graphin Co Ltd
+1447  AIM GmBH
+1448  Alesis Studio Electronics
+1449  TUT Systems Inc
+144a  Adlink Technology
+	7296  PCI-7296
+	7432  PCI-7432
+	7433  PCI-7433
+	7434  PCI-7434
+	7841  PCI-7841
+	8133  PCI-8133
+	8164  PCI-8164
+	8554  PCI-8554
+	9111  PCI-9111
+	9113  PCI-9113
+	9114  PCI-9114
+144b  Loronix Information Systems Inc
+144c  Catalina Research Inc
+144d  Samsung Electronics Co Ltd
+144e  OLITEC
+144f  Askey Computer Corp.
+1450  Octave Communications Ind.
+1451  SP3D Chip Design GmBH
+1453  MYCOM Inc
+1454  Altiga Networks
+1455  Logic Plus Plus Inc
+1456  Advanced Hardware Architectures
+1457  Nuera Communications Inc
+1458  Giga-byte Technology
+	0c11  K8NS Pro Mainboard
+1459  DOOIN Electronics
+145a  Escalate Networks Inc
+145b  PRAIM SRL
+145c  Cryptek
+145d  Gallant Computer Inc
+145e  Aashima Technology B.V.
+145f  Baldor Electric Company
+	0001  NextMove PCI
+1460  DYNARC INC
+1461  Avermedia Technologies Inc
+1462  Micro-Star International Co., Ltd.
+# MSI CB54G Wireless PC Card that seems to use the Broadcom 4306 Chipset
+	6819  Broadcom Corporation BCM4306 802.11b/g Wireless LAN Controller [MSI CB54G]
+	6825  PCI Card wireless 11g [PC54G]
+	8725  NVIDIA NV25 [GeForce4 Ti 4600] VGA Adapter
+# MSI G4Ti4800, 128MB DDR SDRAM, TV-Out, DVI-I
+	9000  NVIDIA NV28 [GeForce4 Ti 4800] VGA Adapter
+	9110  GeFORCE FX5200
+	9119  NVIDIA NV31 [GeForce FX 5600XT] VGA Adapter
+	9591  nVidia Corporation NV36 [GeForce FX 5700LE]
+1463  Fast Corporation
+1464  Interactive Circuits & Systems Ltd
+1465  GN NETTEST Telecom DIV.
+1466  Designpro Inc.
+1467  DIGICOM SPA
+1468  AMBIT Microsystem Corp.
+1469  Cleveland Motion Controls
+146a  IFR
+146b  Parascan Technologies Ltd
+146c  Ruby Tech Corp.
+	1430  FE-1430TX Fast Ethernet PCI Adapter
+146d  Tachyon, INC.
+146e  Williams Electronics Games, Inc.
+146f  Multi Dimensional Consulting Inc
+1470  Bay Networks
+1471  Integrated Telecom Express Inc
+1472  DAIKIN Industries, Ltd
+1473  ZAPEX Technologies Inc
+1474  Doug Carson & Associates
+1475  PICAZO Communications
+1476  MORTARA Instrument Inc
+1477  Net Insight
+1478  DIATREND Corporation
+1479  TORAY Industries Inc
+147a  FORMOSA Industrial Computing
+147b  ABIT Computer Corp.
+147c  AWARE, Inc.
+147d  Interworks Computer Products
+147e  Matsushita Graphic Communication Systems, Inc.
+147f  NIHON UNISYS, Ltd.
+1480  SCII Telecom
+1481  BIOPAC Systems Inc
+1482  ISYTEC - Integrierte Systemtechnik GmBH
+1483  LABWAY Corporation
+1484  Logic Corporation
+1485  ERMA - Electronic GmBH
+1486  L3 Communications Telemetry & Instrumentation
+1487  MARQUETTE Medical Systems
+1488  KONTRON Electronik GmBH
+1489  KYE Systems Corporation
+148a  OPTO
+148b  INNOMEDIALOGIC Inc.
+148c  C.P. Technology Co. Ltd
+148d  DIGICOM Systems, Inc.
+	1003  HCF 56k Data/Fax Modem
+148e  OSI Plus Corporation
+148f  Plant Equipment, Inc.
+1490  Stone Microsystems PTY Ltd.
+1491  ZEAL Corporation
+1492  Time Logic Corporation
+1493  MAKER Communications
+1494  WINTOP Technology, Inc.
+1495  TOKAI Communications Industry Co. Ltd
+1496  JOYTECH Computer Co., Ltd.
+1497  SMA Regelsysteme GmBH
+1498  TEWS Datentechnik GmBH
+	30c8  TPCI200
+1499  EMTEC CO., Ltd
+149a  ANDOR Technology Ltd
+149b  SEIKO Instruments Inc
+149c  OVISLINK Corp.
+149d  NEWTEK Inc
+	0001  Video Toaster for PC
+149e  Mapletree Networks Inc.
+149f  LECTRON Co Ltd
+14a0  SOFTING GmBH
+14a1  Systembase Co Ltd
+14a2  Millennium Engineering Inc
+14a3  Maverick Networks
+14a4  GVC/BCM Advanced Research
+14a5  XIONICS Document Technologies Inc
+14a6  INOVA Computers GmBH & Co KG
+14a7  MYTHOS Systems Inc
+14a8  FEATRON Technologies Corporation
+14a9  HIVERTEC Inc
+14aa  Advanced MOS Technology Inc
+14ab  Mentor Graphics Corp.
+14ac  Novaweb Technologies Inc
+14ad  Time Space Radio AB
+14ae  CTI, Inc
+14af  Guillemot Corporation
+	7102  3D Prophet II MX
+14b0  BST Communication Technology Ltd
+14b1  Nextcom K.K.
+14b2  ENNOVATE Networks Inc
+14b3  XPEED Inc
+	0000  DSL NIC
+14b4  PHILIPS Business Electronics B.V.
+14b5  Creamware GmBH
+	0200  Scope
+	0300  Pulsar
+	0400  PulsarSRB
+	0600  Pulsar2
+	0800  DSP-Board
+	0900  DSP-Board
+	0a00  DSP-Board
+	0b00  DSP-Board
+14b6  Quantum Data Corp.
+14b7  PROXIM Inc
+	0001  Symphony 4110
+14b8  Techsoft Technology Co Ltd
+14b9  AIRONET Wireless Communications
+	0001  PC4800
+	0340  PC4800
+	0350  PC4800
+	4500  PC4500
+	4800  Cisco Aironet 340 802.11b Wireless LAN Adapter/Aironet PC4800
+	a504  Cisco Aironet Wireless 802.11b
+	a505  Cisco Aironet CB20a 802.11a Wireless LAN Adapter
+	a506  Cisco Aironet Mini PCI b/g
+14ba  INTERNIX Inc.
+14bb  SEMTECH Corporation
+14bc  Globespan Semiconductor Inc.
+14bd  CARDIO Control N.V.
+14be  L3 Communications
+14bf  SPIDER Communications Inc.
+14c0  COMPAL Electronics Inc
+14c1  MYRICOM Inc.
+	8043  Myrinet 2000 Scalable Cluster Interconnect
+14c2  DTK Computer
+14c3  MEDIATEK Corp.
+14c4  IWASAKI Information Systems Co Ltd
+14c5  Automation Products AB
+14c6  Data Race Inc
+14c7  Modular Technology Holdings Ltd
+14c8  Turbocomm Tech. Inc.
+14c9  ODIN Telesystems Inc
+14ca  PE Logic Corp.
+14cb  Billionton Systems Inc
+14cc  NAKAYO Telecommunications Inc
+14cd  Universal Scientific Ind.
+14ce  Whistle Communications
+14cf  TEK Microsystems Inc.
+14d0  Ericsson Axe R & D
+14d1  Computer Hi-Tech Co Ltd
+14d2  Titan Electronics Inc
+	8001  VScom 010L 1 port parallel adaptor
+	8002  VScom 020L 2 port parallel adaptor
+	8010  VScom 100L 1 port serial adaptor
+	8011  VScom 110L 1 port serial and 1 port parallel adaptor
+	8020  VScom 200L 1 port serial adaptor
+	8021  VScom 210L 2 port serial and 1 port parallel adaptor
+	8040  VScom 400L 4 port serial adaptor
+	8080  VScom 800L 8 port serial adaptor
+	a000  VScom 010H 1 port parallel adaptor
+	a001  VScom 100H 1 port serial adaptor
+	a003  VScom 400H 4 port serial adaptor
+	a004  VScom 400HF1 4 port serial adaptor
+	a005  VScom 200H 2 port serial adaptor
+	e001  VScom 010HV2 1 port parallel adaptor
+	e010  VScom 100HV2 1 port serial adaptor
+	e020  VScom 200HV2 2 port serial adaptor
+14d3  CIRTECH (UK) Ltd
+14d4  Panacom Technology Corp
+14d5  Nitsuko Corporation
+14d6  Accusys Inc
+14d7  Hirakawa Hewtech Corp
+14d8  HOPF Elektronik GmBH
+# Formerly SiPackets, Inc., formerly API NetWorks, Inc., formerly Alpha Processor, Inc.
+14d9  Alliance Semiconductor Corporation
+	0010  AP1011/SP1011 HyperTransport-PCI Bridge [Sturgeon]
+	9000  AS90L10204/10208 HyperTransport to PCI-X Bridge
+14da  National Aerospace Laboratories
+14db  AFAVLAB Technology Inc
+	2120  TK9902
+14dc  Amplicon Liveline Ltd
+	0000  PCI230
+	0001  PCI242
+	0002  PCI244
+	0003  PCI247
+	0004  PCI248
+	0005  PCI249
+	0006  PCI260
+	0007  PCI224
+	0008  PCI234
+	0009  PCI236
+	000a  PCI272
+	000b  PCI215
+14dd  Boulder Design Labs Inc
+14de  Applied Integration Corporation
+14df  ASIC Communications Corp
+14e1  INVERTEX
+14e2  INFOLIBRIA
+14e3  AMTELCO
+14e4  Broadcom Corporation
+	0800  Sentry5 Chipcommon I/O Controller
+	0804  Sentry5 PCI Bridge
+	0805  Sentry5 MIPS32 CPU
+	0806  Sentry5 Ethernet Controller
+	080b  Sentry5 Crypto Accelerator
+	080f  Sentry5 DDR/SDR RAM Controller
+	0811  Sentry5 External Interface Core
+	0816  BCM3302 Sentry5 MIPS32 CPU
+	1600  NetXtreme BCM5752 Gigabit Ethernet PCI Express
+	1644  NetXtreme BCM5700 Gigabit Ethernet
+		1014 0277  Broadcom Vigil B5700 1000Base-T
+		1028 00d1  Broadcom BCM5700
+		1028 0106  Broadcom BCM5700
+		1028 0109  Broadcom BCM5700 1000Base-T
+		1028 010a  Broadcom BCM5700 1000BaseTX
+		10b7 1000  3C996-T 1000Base-T
+		10b7 1001  3C996B-T 1000Base-T
+		10b7 1002  3C996C-T 1000Base-T
+		10b7 1003  3C997-T 1000Base-T Dual Port
+		10b7 1004  3C996-SX 1000Base-SX
+		10b7 1005  3C997-SX 1000Base-SX Dual Port
+		10b7 1008  3C942 Gigabit LOM (31X31)
+		14e4 0002  NetXtreme 1000Base-SX
+		14e4 0003  NetXtreme 1000Base-SX
+		14e4 0004  NetXtreme 1000Base-T
+		14e4 1028  NetXtreme 1000BaseTX
+		14e4 1644  BCM5700 1000Base-T
+	1645  NetXtreme BCM5701 Gigabit Ethernet
+		0e11 007c  NC7770 Gigabit Server Adapter (PCI-X, 10/100/1000-T)
+		0e11 007d  NC6770 Gigabit Server Adapter (PCI-X, 1000-SX)
+		0e11 0085  NC7780 Gigabit Server Adapter (embedded, WOL)
+		0e11 0099  NC7780 Gigabit Server Adapter (embedded, WOL)
+		0e11 009a  NC7770 Gigabit Server Adapter (PCI-X, 10/100/1000-T)
+		0e11 00c1  NC6770 Gigabit Server Adapter (PCI-X, 1000-SX)
+		1028 0121  Broadcom BCM5701 1000Base-T
+		103c 128a  HP 1000Base-T (PCI) [A7061A]
+		103c 128b  HP 1000Base-SX (PCI) [A7073A]
+		103c 12a4  HP Core Lan 1000Base-T
+		103c 12c1  HP IOX Core Lan 1000Base-T [A7109AX]
+		10a9 8010  SGI IO9 Gigabit Ethernet (Copper)
+		10a9 8011  SGI Gigabit Ethernet (Copper)
+		10a9 8012  SGI Gigabit Ethernet (Fiber)
+		10b7 1004  3C996-SX 1000Base-SX
+		10b7 1006  3C996B-T 1000Base-T
+		10b7 1007  3C1000-T 1000Base-T
+		10b7 1008  3C940-BR01 1000Base-T
+		14e4 0001  BCM5701 1000Base-T
+		14e4 0005  BCM5701 1000Base-T
+		14e4 0006  BCM5701 1000Base-T
+		14e4 0007  BCM5701 1000Base-SX
+		14e4 0008  BCM5701 1000Base-T
+		14e4 8008  BCM5701 1000Base-T
+	1646  NetXtreme BCM5702 Gigabit Ethernet
+		0e11 00bb  NC7760 1000BaseTX
+		1028 0126  Broadcom BCM5702 1000BaseTX
+		14e4 8009  BCM5702 1000BaseTX
+	1647  NetXtreme BCM5703 Gigabit Ethernet
+		0e11 0099  NC7780 1000BaseTX
+		0e11 009a  NC7770 1000BaseTX
+		10a9 8010  SGI IO9 Gigabit Ethernet (Copper)
+		14e4 0009  BCM5703 1000BaseTX
+		14e4 000a  BCM5703 1000BaseSX
+		14e4 000b  BCM5703 1000BaseTX
+		14e4 8009  BCM5703 1000BaseTX
+		14e4 800a  BCM5703 1000BaseTX
+	1648  NetXtreme BCM5704 Gigabit Ethernet
+		0e11 00cf  NC7772 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		0e11 00d0  NC7782 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		0e11 00d1  NC7783 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		10b7 2000  3C998-T Dual Port 10/100/1000 PCI-X
+		10b7 3000  3C999-T Quad Port 10/100/1000 PCI-X
+		1166 1648  NetXtreme CIOB-E 1000Base-T
+	164a  NetXtreme II BCM5706 Gigabit Ethernet
+	164d  NetXtreme BCM5702FE Gigabit Ethernet
+	1653  NetXtreme BCM5705 Gigabit Ethernet
+		0e11 00e3  NC7761 Gigabit Server Adapter
+	1654  NetXtreme BCM5705_2 Gigabit Ethernet
+		0e11 00e3  NC7761 Gigabit Server Adapter
+		103c 3100  NC1020 HP ProLiant Gigabit Server Adapter 32 PCI
+	1659  NetXtreme BCM5721 Gigabit Ethernet PCI Express
+	165d  NetXtreme BCM5705M Gigabit Ethernet
+	165e  NetXtreme BCM5705M_2 Gigabit Ethernet
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+	166e  570x 10/100 Integrated Controller
+	1677  NetXtreme BCM5751 Gigabit Ethernet PCI Express
+		1028 0179  Optiplex GX280
+	167d  NetXtreme BCM5751M Gigabit Ethernet PCI Express
+	167e  NetXtreme BCM5751F Fast Ethernet PCI Express
+	1696  NetXtreme BCM5782 Gigabit Ethernet
+		103c 12bc  HP d530 CMT (DG746A)
+		14e4 000d  NetXtreme BCM5782 1000Base-T
+	169c  NetXtreme BCM5788 Gigabit Ethernet
+	169d  NetLink BCM5789 Gigabit Ethernet PCI Express
+	16a6  NetXtreme BCM5702X Gigabit Ethernet
+		0e11 00bb  NC7760 Gigabit Server Adapter (PCI-X, 10/100/1000-T)
+		1028 0126  BCM5702 1000Base-T
+		14e4 000c  BCM5702 1000Base-T
+		14e4 8009  BCM5702 1000Base-T
+	16a7  NetXtreme BCM5703X Gigabit Ethernet
+		0e11 00ca  NC7771 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		0e11 00cb  NC7781 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		14e4 0009  NetXtreme BCM5703 1000Base-T
+		14e4 000a  NetXtreme BCM5703 1000Base-SX
+		14e4 000b  NetXtreme BCM5703 1000Base-T
+		14e4 800a  NetXtreme BCM5703 1000Base-T
+	16a8  NetXtreme BCM5704S Gigabit Ethernet
+		10b7 2001  3C998-SX Dual Port 1000-SX PCI-X
+	16aa  NetXtreme II BCM5706S Gigabit Ethernet
+	16c6  NetXtreme BCM5702A3 Gigabit Ethernet
+		10b7 1100  3C1000B-T 10/100/1000 PCI
+		14e4 000c  BCM5702 1000Base-T
+		14e4 8009  BCM5702 1000Base-T
+	16c7  NetXtreme BCM5703 Gigabit Ethernet
+		0e11 00ca  NC7771 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		0e11 00cb  NC7781 Gigabit Server Adapter (PCI-X, 10,100,1000-T)
+		103c 12c3  HP Combo FC/GigE-SX [A9782A]
+		103c 12ca  HP Combo FC/GigE-T [A9784A]
+		14e4 0009  NetXtreme BCM5703 1000Base-T
+		14e4 000a  NetXtreme BCM5703 1000Base-SX
+	16dd  NetLink BCM5781 Gigabit Ethernet PCI Express
+	16f7  NetXtreme BCM5753 Gigabit Ethernet PCI Express
+	16fd  NetXtreme BCM5753M Gigabit Ethernet PCI Express
+	16fe  NetXtreme BCM5753F Fast Ethernet PCI Express
+	170c  BCM4401-B0 100Base-TX
+	170d  NetXtreme BCM5901 100Base-TX
+		1014 0545  ThinkPad R40e (2684-HVG) builtin ethernet controller
+	170e  NetXtreme BCM5901 100Base-TX
+	3352  BCM3352
+	3360  BCM3360
+	4210  BCM4210 iLine10 HomePNA 2.0
+	4211  BCM4211 iLine10 HomePNA 2.0 + V.90 56k modem
+	4212  BCM4212 v.90 56k modem
+	4301  BCM4303 802.11b Wireless LAN Controller
+		1028 0407  TrueMobile 1180 Onboard WLAN
+		1043 0120  WL-103b Wireless LAN PC Card
+	4305  BCM4307 V.90 56k Modem
+	4306  BCM4307 Ethernet Controller
+	4307  BCM4307 802.11b Wireless LAN Controller
+	4310  BCM4310 Chipcommon I/OController
+	4312  BCM4310 UART
+	4313  BCM4310 Ethernet Controller
+	4315  BCM4310 USB Controller
+	4320  BCM4306 802.11b/g Wireless LAN Controller
+		1028 0001  TrueMobile 1300 WLAN Mini-PCI Card
+		1028 0003  Wireless 1350 WLAN Mini-PCI Card
+		1043 100f  WL-100G
+		14e4 4320  Linksys WMP54G PCI
+		1737 4320  WPC54G
+		1799 7010  Belkin F5D7010 54g Wireless Network card
+	4321  BCM4306 802.11a Wireless LAN Controller
+	4322  BCM4306 UART
+	4324  BCM4309 802.11a/b/g
+		1028 0001  Truemobile 1400
+		1028 0003  Truemobile 1450 MiniPCI
+	4325  BCM43xG 802.11b/g
+		1414 0003  Wireless Notebook Adapter MN-720
+		1414 0004  Wireless PCI Adapter MN-730
+# probably this is a correct ID...
+	4326  BCM4307 Chipcommon I/O Controller?
+	4401  BCM4401 100Base-T
+		1043 80a8  A7V8X motherboard
+	4402  BCM4402 Integrated 10/100BaseT
+	4403  BCM4402 V.90 56k Modem
+	4410  BCM4413 iLine32 HomePNA 2.0
+	4411  BCM4413 V.90 56k modem
+	4412  BCM4412 10/100BaseT
+	4430  BCM44xx CardBus iLine32 HomePNA 2.0
+	4432  BCM4432 CardBus 10/100BaseT
+	4610  BCM4610 Sentry5 PCI to SB Bridge
+	4611  BCM4610 Sentry5 iLine32 HomePNA 1.0
+	4612  BCM4610 Sentry5 V.90 56k Modem
+	4613  BCM4610 Sentry5 Ethernet Controller
+	4614  BCM4610 Sentry5 External Interface
+	4615  BCM4610 Sentry5 USB Controller
+	4704  BCM4704 PCI to SB Bridge
+	4705  BCM4704 Sentry5 802.11b Wireless LAN Controller
+	4706  BCM4704 Sentry5 Ethernet Controller
+	4707  BCM4704 Sentry5 USB Controller
+	4708  BCM4704 Crypto Accelerator
+	4710  BCM4710 Sentry5 PCI to SB Bridge
+	4711  BCM47xx Sentry5 iLine32 HomePNA 2.0
+	4712  BCM47xx V.92 56k modem
+	4713  Sentry5 Ethernet Controller
+	4714  BCM47xx Sentry5 External Interface
+	4715  Sentry5 USB Controller
+	4716  BCM47xx Sentry5 USB Host Controller
+	4717  BCM47xx Sentry5 USB Device Controller
+	4718  Sentry5 Crypto Accelerator
+	4720  BCM4712 MIPS CPU
+	5365  BCM5365P Sentry5 Host Bridge
+	5600  BCM5600 StrataSwitch 24+2 Ethernet Switch Controller
+	5605  BCM5605 StrataSwitch 24+2 Ethernet Switch Controller
+	5615  BCM5615 StrataSwitch 24+2 Ethernet Switch Controller
+	5625  BCM5625 StrataSwitch 24+2 Ethernet Switch Controller
+	5645  BCM5645 StrataSwitch 24+2 Ethernet Switch Controller
+	5670  BCM5670 8-Port 10GE Ethernet Switch Fabric
+	5680  BCM5680 G-Switch 8 Port Gigabit Ethernet Switch Controller
+	5690  BCM5690 12-port Multi-Layer Gigabit Ethernet Switch
+	5691  BCM5691 GE/10GE 8+2 Gigabit Ethernet Switch Controller
+	5820  BCM5820 Crypto Accelerator
+	5821  BCM5821 Crypto Accelerator
+	5822  BCM5822 Crypto Accelerator
+	5823  BCM5823 Crypto Accelerator
+	5824  BCM5824 Crypto Accelerator
+	5840  BCM5840 Crypto Accelerator
+	5841  BCM5841 Crypto Accelerator
+	5850  BCM5850 Crypto Accelerator
+14e5  Pixelfusion Ltd
+14e6  SHINING Technology Inc
+14e7  3CX
+14e8  RAYCER Inc
+14e9  GARNETS System CO Ltd
+14ea  Planex Communications, Inc
+	ab06  FNW-3603-TX CardBus Fast Ethernet
+	ab07  RTL81xx RealTek Ethernet
+14eb  SEIKO EPSON Corp
+14ec  ACQIRIS
+14ed  DATAKINETICS Ltd
+14ee  MASPRO KENKOH Corp
+14ef  CARRY Computer ENG. CO Ltd
+14f0  CANON RESEACH CENTRE FRANCE
+14f1  Conexant
+	1002  HCF 56k Modem
+	1003  HCF 56k Modem
+	1004  HCF 56k Modem
+	1005  HCF 56k Modem
+	1006  HCF 56k Modem
+	1022  HCF 56k Modem
+	1023  HCF 56k Modem
+	1024  HCF 56k Modem
+	1025  HCF 56k Modem
+	1026  HCF 56k Modem
+	1032  HCF 56k Modem
+	1033  HCF 56k Data/Fax Modem
+		1033 8077  NEC
+		122d 4027  Dell Zeus - MDP3880-W(B) Data Fax Modem
+		122d 4030  Dell Mercury - MDP3880-U(B) Data Fax Modem
+		122d 4034  Dell Thor - MDP3880-W(U) Data Fax Modem
+		13e0 020d  Dell Copper
+		13e0 020e  Dell Silver
+		13e0 0261  IBM
+		13e0 0290  Compaq Goldwing
+		13e0 02a0  IBM
+		13e0 02b0  IBM
+		13e0 02c0  Compaq Scooter
+		13e0 02d0  IBM
+		144f 1500  IBM P85-DF (1)
+		144f 1501  IBM P85-DF (2)
+		144f 150a  IBM P85-DF (3)
+		144f 150b  IBM P85-DF Low Profile (1)
+		144f 1510  IBM P85-DF Low Profile (2)
+	1034  HCF 56k Data/Fax/Voice Modem
+	1035  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+		10cf 1098  Fujitsu P85-DFSV
+	1036  HCF 56k Data/Fax/Voice/Spkp Modem
+		104d 8067  HCF 56k Modem
+		122d 4029  MDP3880SP-W
+		122d 4031  MDP3880SP-U
+		13e0 0209  Dell Titanium
+		13e0 020a  Dell Graphite
+		13e0 0260  Gateway Red Owl
+		13e0 0270  Gateway White Horse
+	1052  HCF 56k Data/Fax Modem (Worldwide)
+	1053  HCF 56k Data/Fax Modem (Worldwide)
+	1054  HCF 56k Data/Fax/Voice Modem (Worldwide)
+	1055  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem (Worldwide)
+	1056  HCF 56k Data/Fax/Voice/Spkp Modem (Worldwide)
+	1057  HCF 56k Data/Fax/Voice/Spkp Modem (Worldwide)
+	1059  HCF 56k Data/Fax/Voice Modem (Worldwide)
+	1063  HCF 56k Data/Fax Modem
+	1064  HCF 56k Data/Fax/Voice Modem
+	1065  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+	1066  HCF 56k Data/Fax/Voice/Spkp Modem
+		122d 4033  Dell Athena - MDP3900V-U
+	1433  HCF 56k Data/Fax Modem
+	1434  HCF 56k Data/Fax/Voice Modem
+	1435  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+	1436  HCF 56k Data/Fax Modem
+	1453  HCF 56k Data/Fax Modem
+		13e0 0240  IBM
+		13e0 0250  IBM
+		144f 1502  IBM P95-DF (1)
+		144f 1503  IBM P95-DF (2)
+	1454  HCF 56k Data/Fax/Voice Modem
+	1455  HCF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+	1456  HCF 56k Data/Fax/Voice/Spkp Modem
+		122d 4035  Dell Europa - MDP3900V-W
+		122d 4302  Dell MP3930V-W(C) MiniPCI
+	1610  ADSL AccessRunner PCI Arbitration Device
+	1611  AccessRunner PCI ADSL Interface Device
+	1620  ADSL AccessRunner V2 PCI Arbitration Device
+	1621  AccessRunner V2 PCI ADSL Interface Device
+	1622  AccessRunner V2 PCI ADSL Yukon WAN Adapter
+	1803  HCF 56k Modem
+		0e11 0023  623-LAN Grizzly
+		0e11 0043  623-LAN Yogi
+	1815  HCF 56k Modem
+		0e11 0022  Grizzly
+		0e11 0042  Yogi
+	2003  HSF 56k Data/Fax Modem
+	2004  HSF 56k Data/Fax/Voice Modem
+	2005  HSF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+	2006  HSF 56k Data/Fax/Voice/Spkp Modem
+	2013  HSF 56k Data/Fax Modem
+		0e11 b195  Bear
+		0e11 b196  Seminole 1
+		0e11 b1be  Seminole 2
+		1025 8013  Acer
+		1033 809d  NEC
+		1033 80bc  NEC
+		155d 6793  HP
+		155d 8850  E Machines
+	2014  HSF 56k Data/Fax/Voice Modem
+	2015  HSF 56k Data/Fax/Voice/Spkp (w/Handset) Modem
+	2016  HSF 56k Data/Fax/Voice/Spkp Modem
+	2043  HSF 56k Data/Fax Modem (WorldW SmartDAA)
+	2044  HSF 56k Data/Fax/Voice Modem (WorldW SmartDAA)
+	2045  HSF 56k Data/Fax/Voice/Spkp (w/Handset) Modem (WorldW SmartDAA)
+	2046  HSF 56k Data/Fax/Voice/Spkp Modem (WorldW SmartDAA)
+	2063  HSF 56k Data/Fax Modem (SmartDAA)
+	2064  HSF 56k Data/Fax/Voice Modem (SmartDAA)
+	2065  HSF 56k Data/Fax/Voice/Spkp (w/Handset) Modem (SmartDAA)
+	2066  HSF 56k Data/Fax/Voice/Spkp Modem (SmartDAA)
+	2093  HSF 56k Modem
+		155d 2f07  Legend
+	2143  HSF 56k Data/Fax/Cell Modem (Mob WorldW SmartDAA)
+	2144  HSF 56k Data/Fax/Voice/Cell Modem (Mob WorldW SmartDAA)
+	2145  HSF 56k Data/Fax/Voice/Spkp (w/HS)/Cell Modem (Mob WorldW SmartDAA)
+	2146  HSF 56k Data/Fax/Voice/Spkp/Cell Modem (Mob WorldW SmartDAA)
+	2163  HSF 56k Data/Fax/Cell Modem (Mob SmartDAA)
+	2164  HSF 56k Data/Fax/Voice/Cell Modem (Mob SmartDAA)
+	2165  HSF 56k Data/Fax/Voice/Spkp (w/HS)/Cell Modem (Mob SmartDAA)
+	2166  HSF 56k Data/Fax/Voice/Spkp/Cell Modem (Mob SmartDAA)
+	2343  HSF 56k Data/Fax CardBus Modem (Mob WorldW SmartDAA)
+	2344  HSF 56k Data/Fax/Voice CardBus Modem (Mob WorldW SmartDAA)
+	2345  HSF 56k Data/Fax/Voice/Spkp (w/HS) CardBus Modem (Mob WorldW SmartDAA)
+	2346  HSF 56k Data/Fax/Voice/Spkp CardBus Modem (Mob WorldW SmartDAA)
+	2363  HSF 56k Data/Fax CardBus Modem (Mob SmartDAA)
+	2364  HSF 56k Data/Fax/Voice CardBus Modem (Mob SmartDAA)
+	2365  HSF 56k Data/Fax/Voice/Spkp (w/HS) CardBus Modem (Mob SmartDAA)
+	2366  HSF 56k Data/Fax/Voice/Spkp CardBus Modem (Mob SmartDAA)
+	2443  HSF 56k Data/Fax Modem (Mob WorldW SmartDAA)
+		104d 8075  Modem
+		104d 8083  Modem
+		104d 8097  Modem
+	2444  HSF 56k Data/Fax/Voice Modem (Mob WorldW SmartDAA)
+	2445  HSF 56k Data/Fax/Voice/Spkp (w/HS) Modem (Mob WorldW SmartDAA)
+	2446  HSF 56k Data/Fax/Voice/Spkp Modem (Mob WorldW SmartDAA)
+	2463  HSF 56k Data/Fax Modem (Mob SmartDAA)
+	2464  HSF 56k Data/Fax/Voice Modem (Mob SmartDAA)
+	2465  HSF 56k Data/Fax/Voice/Spkp (w/HS) Modem (Mob SmartDAA)
+	2466  HSF 56k Data/Fax/Voice/Spkp Modem (Mob SmartDAA)
+	2f00  HSF 56k HSFi Modem
+		13e0 8d84  IBM HSFi V.90
+		13e0 8d85  Compaq Stinger
+		14f1 2004  Dynalink 56PMi
+	2f02  HSF 56k HSFi Data/Fax
+	2f11  HSF 56k HSFi Modem
+	8234  RS8234 ATM SAR Controller [ServiceSAR Plus]
+	8800  CX22702 DVB-T 2k/8k
+		17de 08a1  XPert DVB-T PCI BDA DVBT 23880 Video Capture
+	8802  CX23883 Broadcast Decoder
+		17de 08a1  Xpert DVB-T PCI 2388x Transport Stream Capture
+14f2  MOBILITY Electronics
+	0120  EV1000 bridge
+	0121  EV1000 Parallel port
+	0122  EV1000 Serial port
+	0123  EV1000 Keyboard controller
+	0124  EV1000 Mouse controller
+14f3  BroadLogic
+	2030  2030 DVB-S Satellite Reciever
+	2050  2050 DVB-T Terrestrial (Cable) Reciever
+	2060  2060 ATSC Terrestrial (Cable) Reciever
+14f4  TOKYO Electronic Industry CO Ltd
+14f5  SOPAC Ltd
+14f6  COYOTE Technologies LLC
+14f7  WOLF Technology Inc
+14f8  AUDIOCODES Inc
+	2077  TP-240 dual span E1 VoIP PCI card
+14f9  AG COMMUNICATIONS
+14fa  WANDEL & GOCHERMANN
+14fb  TRANSAS MARINE (UK) Ltd
+14fc  Quadrics Ltd
+	0000  QsNet Elan3 Network Adapter
+	0001  QsNetII Elan4 Network Adapter
+14fd  JAPAN Computer Industry Inc
+14fe  ARCHTEK TELECOM Corp
+14ff  TWINHEAD INTERNATIONAL Corp
+1500  DELTA Electronics, Inc
+	1360  RTL81xx RealTek Ethernet
+1501  BANKSOFT CANADA Ltd
+1502  MITSUBISHI ELECTRIC LOGISTICS SUPPORT Co Ltd
+1503  KAWASAKI LSI USA Inc
+1504  KAISER Electronics
+1505  ITA INGENIEURBURO FUR TESTAUFGABEN GmbH
+1506  CHAMELEON Systems Inc
+# Should be HTEC Ltd, but there are no known HTEC chips and 1507 is already used by mistake by Motorola (see vendor ID 1057).
+1507  Motorola ?? / HTEC
+	0001  MPC105 [Eagle]
+	0002  MPC106 [Grackle]
+	0003  MPC8240 [Kahlua]
+	0100  MC145575 [HFC-PCI]
+	0431  KTI829c 100VG
+	4801  Raven
+	4802  Falcon
+	4803  Hawk
+	4806  CPX8216
+1508  HONDA CONNECTORS/MHOTRONICS Inc
+1509  FIRST INTERNATIONAL Computer Inc
+150a  FORVUS RESEARCH Inc
+150b  YAMASHITA Systems Corp
+150c  KYOPAL CO Ltd
+150d  WARPSPPED Inc
+150e  C-PORT Corp
+150f  INTEC GmbH
+1510  BEHAVIOR TECH Computer Corp
+1511  CENTILLIUM Technology Corp
+1512  ROSUN Technologies Inc
+1513  Raychem
+1514  TFL LAN Inc
+1515  Advent design
+1516  MYSON Technology Inc
+	0800  MTD-8xx 100/10M Ethernet PCI Adapter
+	0803  SURECOM EP-320X-S 100/10M Ethernet PCI Adapter
+		1320 10bd  SURECOM EP-320X-S 100/10M Ethernet PCI Adapter
+	0891  MTD-8xx 100/10M Ethernet PCI Adapter
+1517  ECHOTEK Corp
+1518  PEP MODULAR Computers GmbH
+1519  TELEFON AKTIEBOLAGET LM Ericsson
+151a  Globetek
+	1002  PCI-1002
+	1004  PCI-1004
+	1008  PCI-1008
+151b  COMBOX Ltd
+151c  DIGITAL AUDIO LABS Inc
+	0003  Prodif T 2496
+	4000  Prodif 88
+151d  Fujitsu Computer Products Of America
+151e  MATRIX Corp
+151f  TOPIC SEMICONDUCTOR Corp
+	0000  TP560 Data/Fax/Voice 56k modem
+1520  CHAPLET System Inc
+1521  BELL Corp
+1522  MainPine Ltd
+	0100  PCI <-> IOBus Bridge
+		1522 0200  RockForceDUO 2 Port V.92/V.44 Data/Fax/Voice Modem
+		1522 0300  RockForceQUATRO 4 Port V.92/V.44 Data/Fax/Voice Modem
+		1522 0400  RockForceDUO+ 2 Port V.92/V.44 Data/Fax/Voice Modem
+		1522 0500  RockForceQUATRO+ 4 Port V.92/V.44 Data/Fax/Voice Modem
+		1522 0600  RockForce+ 2 Port V.90 Data/Fax/Voice Modem
+		1522 0700  RockForce+ 4 Port V.90 Data/Fax/Voice Modem
+		1522 0800  RockForceOCTO+ 8 Port V.92/V.44 Data/Fax/Voice Modem
+		1522 0c00  RockForceDUO+ 2 Port V.92/V.44 Data, V.34 Super-G3 Fax, Voice Modem
+		1522 0d00  RockForceQUATRO+ 4 Port V.92/V.44 Data, V.34 Super-G3 Fax, Voice Modem
+# this is a correction to a recent entry. 1522:0E00 should be 1522:1D00
+		1522 1d00  RockForceOCTO+ 8 Port V.92/V.44 Data, V.34 Super-G3 Fax, Voice Modem
+1523  MUSIC Semiconductors
+1524  ENE Technology Inc
+	0510  CB710 Memory Card Reader Controller
+	0610  PCI Smart Card Reader Controller
+	1211  CB1211 Cardbus Controller
+	1225  CB1225 Cardbus Controller
+	1410  CB1410 Cardbus Controller
+		1025 005a  TravelMate 290
+	1411  CB-710/2/4 Cardbus Controller
+	1412  CB-712/4 Cardbus Controller
+	1420  CB1420 Cardbus Controller
+	1421  CB-720/2/4 Cardbus Controller
+	1422  CB-722/4 Cardbus Controller
+1525  IMPACT Technologies
+1526  ISS, Inc
+1527  SOLECTRON
+1528  ACKSYS
+1529  AMERICAN MICROSystems Inc
+152a  QUICKTURN DESIGN Systems
+152b  FLYTECH Technology CO Ltd
+152c  MACRAIGOR Systems LLC
+152d  QUANTA Computer Inc
+152e  MELEC Inc
+152f  PHILIPS - CRYPTO
+1530  ACQIS Technology Inc
+1531  CHRYON Corp
+1532  ECHELON Corp
+1533  BALTIMORE
+1534  ROAD Corp
+1535  EVERGREEN Technologies Inc
+1537  DATALEX COMMUNCATIONS
+1538  ARALION Inc
+	0303  ARS106S Ultra ATA 133/100/66 Host Controller
+1539  ATELIER INFORMATIQUES et ELECTRONIQUE ETUDES S.A.
+153a  ONO SOKKI
+153b  TERRATEC Electronic GmbH
+	1144  Aureon 5.1
+# Terratec seems to use several IDs for the same card.
+	1147  Aureon 5.1 Sky
+	1158  Philips Semiconductors SAA7134 (rev 01) [Terratec Cinergy 600 TV]
+153c  ANTAL Electronic
+153d  FILANET Corp
+153e  TECHWELL Inc
+153f  MIPS Technologies, Inc.
+	0001  SOC-it 101 System Controller
+1540  PROVIDEO MULTIMEDIA Co Ltd
+1541  MACHONE Communications
+1542  VIVID Technology Inc
+1543  SILICON Laboratories
+	3052  Intel 537 [Winmodem]
+	4c22  Si3036 MC'97 DAA
+1544  DCM DATA Systems
+1545  VISIONTEK
+1546  IOI Technology Corp
+1547  MITUTOYO Corp
+1548  JET PROPULSION Laboratory
+1549  INTERCONNECT Systems Solutions
+154a  MAX Technologies Inc
+154b  COMPUTEX Co Ltd
+154c  VISUAL Technology Inc
+154d  PAN INTERNATIONAL Industrial Corp
+154e  SERVOTEST Ltd
+154f  STRATABEAM Technology
+1550  OPEN NETWORK Co Ltd
+1551  SMART Electronic DEVELOPMENT GmBH
+1552  RACAL AIRTECH Ltd
+1553  CHICONY Electronics Co Ltd
+1554  PROLINK Microsystems Corp
+1555  GESYTEC GmBH
+1556  PLD APPLICATIONS
+1557  MEDIASTAR Co Ltd
+1558  CLEVO/KAPOK Computer
+1559  SI LOGIC Ltd
+155a  INNOMEDIA Inc
+155b  PROTAC INTERNATIONAL Corp
+155c  Cemax-Icon Inc
+155d  Mac System Co Ltd
+155e  LP Elektronik GmbH
+155f  Perle Systems Ltd
+1560  Terayon Communications Systems
+1561  Viewgraphics Inc
+1562  Symbol Technologies
+1563  A-Trend Technology Co Ltd
+1564  Yamakatsu Electronics Industry Co Ltd
+1565  Biostar Microtech Int'l Corp
+1566  Ardent Technologies Inc
+1567  Jungsoft
+1568  DDK Electronics Inc
+1569  Palit Microsystems Inc.
+156a  Avtec Systems
+156b  2wire Inc
+156c  Vidac Electronics GmbH
+156d  Alpha-Top Corp
+156e  Alfa Inc
+156f  M-Systems Flash Disk Pioneers Ltd
+1570  Lecroy Corp
+1571  Contemporary Controls
+	a001  CCSI PCI20-485 ARCnet
+	a002  CCSI PCI20-485D ARCnet
+	a003  CCSI PCI20-485X ARCnet
+	a004  CCSI PCI20-CXB ARCnet
+	a005  CCSI PCI20-CXS ARCnet
+	a006  CCSI PCI20-FOG-SMA ARCnet
+	a007  CCSI PCI20-FOG-ST ARCnet
+	a008  CCSI PCI20-TB5 ARCnet
+	a009  CCSI PCI20-5-485 5Mbit ARCnet
+	a00a  CCSI PCI20-5-485D 5Mbit ARCnet
+	a00b  CCSI PCI20-5-485X 5Mbit ARCnet
+	a00c  CCSI PCI20-5-FOG-ST 5Mbit ARCnet
+	a00d  CCSI PCI20-5-FOG-SMA 5Mbit ARCnet
+	a201  CCSI PCI22-485 10Mbit ARCnet
+	a202  CCSI PCI22-485D 10Mbit ARCnet
+	a203  CCSI PCI22-485X 10Mbit ARCnet
+	a204  CCSI PCI22-CHB 10Mbit ARCnet
+	a205  CCSI PCI22-FOG_ST 10Mbit ARCnet
+	a206  CCSI PCI22-THB 10Mbit ARCnet
+1572  Otis Elevator Company
+1573  Lattice - Vantis
+1574  Fairchild Semiconductor
+1575  Voltaire Advanced Data Security Ltd
+1576  Viewcast COM
+1578  HITT
+	5615  VPMK3 [Video Processor Mk III]
+1579  Dual Technology Corp
+157a  Japan Elecronics Ind Inc
+157b  Star Multimedia Corp
+157c  Eurosoft (UK)
+	8001  Fix2000 PCI Y2K Compliance Card
+157d  Gemflex Networks
+157e  Transition Networks
+157f  PX Instruments Technology Ltd
+1580  Primex Aerospace Co
+1581  SEH Computertechnik GmbH
+1582  Cytec Corp
+1583  Inet Technologies Inc
+1584  Uniwill Computer Corp
+1585  Logitron
+1586  Lancast Inc
+1587  Konica Corp
+1588  Solidum Systems Corp
+1589  Atlantek Microsystems Pty Ltd
+158a  Digalog Systems Inc
+158b  Allied Data Technologies
+158c  Hitachi Semiconductor & Devices Sales Co Ltd
+158d  Point Multimedia Systems
+158e  Lara Technology Inc
+158f  Ditect Coop
+1590  3pardata Inc
+1591  ARN
+1592  Syba Tech Ltd
+	0781  Multi-IO Card
+	0782  Parallel Port Card 2xEPP
+	0783  Multi-IO Card
+	0785  Multi-IO Card
+	0786  Multi-IO Card
+	0787  Multi-IO Card
+	0788  Multi-IO Card
+	078a  Multi-IO Card
+1593  Bops Inc
+1594  Netgame Ltd
+1595  Diva Systems Corp
+1596  Folsom Research Inc
+1597  Memec Design Services
+1598  Granite Microsystems
+1599  Delta Electronics Inc
+159a  General Instrument
+159b  Faraday Technology Corp
+159c  Stratus Computer Systems
+159d  Ningbo Harrison Electronics Co Ltd
+159e  A-Max Technology Co Ltd
+159f  Galea Network Security
+15a0  Compumaster SRL
+15a1  Geocast Network Systems
+15a2  Catalyst Enterprises Inc
+	0001  TA700 PCI Bus Analyzer/Exerciser
+15a3  Italtel
+15a4  X-Net OY
+15a5  Toyota Macs Inc
+15a6  Sunlight Ultrasound Technologies Ltd
+15a7  SSE Telecom Inc
+15a8  Shanghai Communications Technologies Center
+15aa  Moreton Bay
+15ab  Bluesteel Networks Inc
+15ac  North Atlantic Instruments
+15ad  VMware Inc
+	0405  [VMware SVGA II] PCI Display Adapter
+	0710  Virtual SVGA
+	0720  VMware High-Speed Virtual NIC [vmxnet]
+15ae  Amersham Pharmacia Biotech
+15b0  Zoltrix International Ltd
+15b1  Source Technology Inc
+15b2  Mosaid Technologies Inc
+15b3  Mellanox Technologies
+	5274  MT21108 InfiniBridge
+	5a44  MT23108 InfiniHost
+	5a45  MT23108 [Infinihost HCA Flash Recovery]
+	5a46  MT23108 PCI Bridge
+	5e8c  MT24204 [InfiniHost III Lx HCA]
+	5e8d  MT24204 [InfiniHost III Lx HCA Flash Recovery]
+	6278  MT25208 InfiniHost III Ex (Tavor compatibility mode)
+	6279  MT25208 [InfiniHost III Ex HCA Flash Recovery]
+	6282  MT25208 InfiniHost III Ex
+15b4  CCI/TRIAD
+15b5  Cimetrics Inc
+15b6  Texas Memory Systems Inc
+15b7  Sandisk Corp
+15b8  ADDI-DATA GmbH
+15b9  Maestro Digital Communications
+15ba  Impacct Technology Corp
+15bb  Portwell Inc
+15bc  Agilent Technologies
+	2922  64 Bit, 133MHz PCI-X Exerciser & Protocol Checker
+	2928  64 Bit, 66MHz PCI Exerciser & Analyzer
+	2929  64 Bit, 133MHz PCI-X Analyzer & Exerciser
+15bd  DFI Inc
+15be  Sola Electronics
+15bf  High Tech Computer Corp (HTC)
+15c0  BVM Ltd
+15c1  Quantel
+15c2  Newer Technology Inc
+15c3  Taiwan Mycomp Co Ltd
+15c4  EVSX Inc
+15c5  Procomp Informatics Ltd
+	8010  1394b - 1394 Firewire 3-Port Host Adapter Card
+15c6  Technical University of Budapest
+15c7  Tateyama System Laboratory Co Ltd
+	0349  Tateyama C-PCI PLC/NC card Rev.01A
+15c8  Penta Media Co Ltd
+15c9  Serome Technology Inc
+15ca  Bitboys OY
+15cb  AG Electronics Ltd
+15cc  Hotrail Inc
+15cd  Dreamtech Co Ltd
+15ce  Genrad Inc
+15cf  Hilscher GmbH
+15d1  Infineon Technologies AG
+15d2  FIC (First International Computer Inc)
+15d3  NDS Technologies Israel Ltd
+15d4  Iwill Corp
+15d5  Tatung Co
+15d6  Entridia Corp
+15d7  Rockwell-Collins Inc
+15d8  Cybernetics Technology Co Ltd
+15d9  Super Micro Computer Inc
+15da  Cyberfirm Inc
+15db  Applied Computing Systems Inc
+15dc  Litronic Inc
+	0001  Argus 300 PCI Cryptography Module
+15dd  Sigmatel Inc
+15de  Malleable Technologies Inc
+15df  Infinilink Corp
+15e0  Cacheflow Inc
+15e1  Voice Technologies Group Inc
+15e2  Quicknet Technologies Inc
+15e3  Networth Technologies Inc
+15e4  VSN Systemen BV
+15e5  Valley technologies Inc
+15e6  Agere Inc
+15e7  Get Engineering Corp
+15e8  National Datacomm Corp
+	0130  Wireless PCI Card
+15e9  Pacific Digital Corp
+	1841  ADMA-100 DiscStaQ ATA Controller
+15ea  Tokyo Denshi Sekei K.K.
+15eb  Drsearch GmbH
+15ec  Beckhoff GmbH
+	3101  FC3101 Profibus DP 1 Channel PCI
+	5102  FC5102
+15ed  Macrolink Inc
+15ee  In Win Development Inc
+15ef  Intelligent Paradigm Inc
+15f0  B-Tree Systems Inc
+15f1  Times N Systems Inc
+15f2  Diagnostic Instruments Inc
+15f3  Digitmedia Corp
+15f4  Valuesoft
+15f5  Power Micro Research
+15f6  Extreme Packet Device Inc
+15f7  Banctec
+15f8  Koga Electronics Co
+15f9  Zenith Electronics Corp
+15fa  J.P. Axzam Corp
+15fb  Zilog Inc
+15fc  Techsan Electronics Co Ltd
+15fd  N-CUBED.NET
+15fe  Kinpo Electronics Inc
+15ff  Fastpoint Technologies Inc
+1600  Northrop Grumman - Canada Ltd
+1601  Tenta Technology
+1602  Prosys-tec Inc
+1603  Nokia Wireless Communications
+1604  Central System Research Co Ltd
+1605  Pairgain Technologies
+1606  Europop AG
+1607  Lava Semiconductor Manufacturing Inc
+1608  Automated Wagering International
+1609  Scimetric Instruments Inc
+1612  Telesynergy Research Inc.
+1619  FarSite Communications Ltd
+	0400  FarSync T2P (2 port X.21/V.35/V.24)
+	0440  FarSync T4P (4 port X.21/V.35/V.24)
+# www.rioworks.com
+161f  Rioworks
+1626  TDK Semiconductor Corp.
+	8410  RTL81xx Fast Ethernet
+1629  Kongsberg Spacetec AS
+	1003  Format synchronizer v3.0
+	2002  Fast Universal Data Output
+# This seems to occur on their 802.11b Wireless card WMP-11
+1637  Linksys
+	3874  Linksys 802.11b WMP11 PCI Wireless card
+1638  Standard Microsystems Corp [SMC]
+	1100  SMC2602W EZConnect / Addtron AWA-100 / Eumitcom PCI WL11000
+163c  Smart Link Ltd.
+	3052  SmartLink SmartPCI562 56K Modem
+	5449  SmartPCI561 Modem
+1657  Brocade Communications Systems, Inc.
+165a  Epix Inc
+	c100  PIXCI(R) CL1 Camera Link Video Capture Board [custom QL5232]
+	d200  PIXCI(R) D2X Digital Video Capture Board [custom QL5232]
+	d300  PIXCI(R) D3X Digital Video Capture Board [custom QL5232]
+165d  Hsing Tech. Enterprise Co., Ltd.
+1661  Worldspace Corp.
+1668  Actiontec Electronics Inc
+	0100  Mini-PCI bridge
+# Formerly SiByte, Inc.
+166d  Broadcom Corporation
+	0001  SiByte BCM1125/1125H/1250 System-on-a-Chip PCI
+	0002  SiByte BCM1125H/1250 System-on-a-Chip HyperTransport
+1677  Bernecker + Rainer
+	104e  5LS172.6 B&R Dual CAN Interface Card
+	12d7  5LS172.61 B&R Dual CAN Interface Card
+167b  ZyDAS Technology Corp.
+	2102  ZyDAS ZD1202
+		187e 3406  ZyAIR B-122 CardBus 11Mbs Wireless LAN Card
+1681  Hercules
+# More specs, more accurate desc.
+	0010  Hercules 3d Prophet II Ultra 64MB [ 350 MHz NV15BR core, 128-bit DDR @ 460 MHz, 1.5v AGP4x  ]
+1682  XFX Pine Group Inc.
+1688  CastleNet Technology Inc.
+	1170  WLAN 802.11b card
+168c  Atheros Communications, Inc.
+	0007  AR5000 802.11a Wireless Adapter
+	0011  AR5210 802.11a NIC
+	0012  AR5211 802.11ab NIC
+	0013  AR5212 802.11abg NIC
+		1113 d301  Philips CPWNA100 Wireless CardBus adapter
+		1186 3202  D-link DWL-G650 B3 Wireless cardbus adapter
+		1186 3203  DWL-G520 Wireless PCI Adapter
+		1186 3a13  DWL-G520 Wireless PCI Adapter rev. B
+		1186 3a94  C54C Wireless 801.11g cardbus
+		1385 4d00  Netgear WG311T Wireless PCI Adapter
+		14b7 0a60  8482-WD ORiNOCO 11a/b/g Wireless PCI Adapter
+		168c 0013  WG511T Wireless CardBus Adapter
+		168c 1025  DWL-G650B2 Wireless CardBus Adapter
+		168c 1027  Netgate NL-3054CB ARIES b/g CardBus Adapter
+		168c 2026  Netgate 5354MP ARIES a(108Mb turbo)/b/g MiniPCI Adapter
+		168c 2041  Netgate 5354MP Plus ARIES2 b/g MiniPCI Adapter
+		168c 2042  Netgate 5354MP Plus ARIES2 a/b/g MiniPCI Adapter
+	1014  AR5212 802.11abg NIC
+169c  Netcell Corporation
+	0044  SyncRAID SR3000/5000 Series SATA RAID Controllers
+16a5  Tekram Technology Co.,Ltd.
+16ab  Global Sun Technology Inc
+	1100  GL24110P
+	1101  PLX9052 PCMCIA-to-PCI Wireless LAN
+	1102  PCMCIA-to-PCI Wireless Network Bridge
+	8501  WL-8305 Wireless LAN PCI Adapter
+16ae  Safenet Inc
+	1141  SafeXcel-1141
+16b4  Aspex Semiconductor Ltd
+16be  Creatix Polymedia GmbH
+16ca  CENATEK Inc
+	0001  Rocket Drive DL
+16cd  Densitron Technologies
+16ce  Roland Corp.
+# www.pikatechnologies.com
+16df  PIKA Technologies Inc.
+16e3  European Space Agency
+	1e0f  LEON2FT Processor
+16ec  U.S. Robotics
+	00ff  USR997900 10/100 Mbps PCI Network Card
+	0116  USR997902 10/100/1000 Mbps PCI Network Card
+	3685  Wireless Access PCI Adapter Model 022415
+16ed  Sycron N. V.
+	1001  UMIO communication card
+16f3  Jetway Information Co., Ltd.
+16f4  Vweb Corp
+	8000  VW2010
+16f6  VideoTele.com, Inc.
+# www.internetmachines.com
+1702  Internet Machines Corporation (IMC)
+1705  Digital First, Inc.
+170b  NetOctave
+	0100  NSP2000-SSL crypto accelerator
+170c  YottaYotta Inc.
+# Seems to be a 2nd ID for Vitesse Semiconductor
+1725  Vitesse Semiconductor
+	7174  VSC7174 PCI/PCI-X Serial ATA Host Bus Controller
+172a  Accelerated Encryption
+1734  Fujitsu Siemens Computer GmbH
+1737  Linksys
+	0013  WMP54G Wireless Pci Card
+	0015  WMP54GS Wireless Pci Card
+	1032  Gigabit Network Adapter
+		1737 0015  EG1032 v2 Instant Gigabit Network Adapter
+	1064  Gigabit Network Adapter
+		1737 0016  EG1064 v2 Instant Gigabit Network Adapter
+	ab08  21x4x DEC-Tulip compatible 10/100 Ethernet
+	ab09  21x4x DEC-Tulip compatible 10/100 Ethernet
+173b  Altima (nee Broadcom)
+	03e8  AC1000 Gigabit Ethernet
+	03e9  AC1001 Gigabit Ethernet
+	03ea  AC9100 Gigabit Ethernet
+		173b 0001  AC1002
+	03eb  AC1003 Gigabit Ethernet
+1743  Peppercon AG
+	8139  ROL/F-100 Fast Ethernet Adapter with ROL
+1749  RLX Technologies
+174b  PC Partner Limited
+174d  WellX Telecom SA
+175c  AudioScience Inc
+175e  Sanera Systems, Inc.
+1787  Hightech Information System Ltd.
+# also used by Struck Innovative Systeme for joint developments
+1796  Research Centre Juelich
+	0001  SIS1100 [Gigabit link]
+	0002  HOTlink
+	0003  Counter Timer
+	0004  CAMAC Controller
+	0005  PROFIBUS
+	0006  AMCC HOTlink
+1797  JumpTec h, GMBH
+1799  Belkin
+	6001  Wireless PCI Card - F5D6001
+	6020  Wireless PCMCIA Card - F5D6020
+	6060  Wireless PDA Card - F5D6060
+	7000  Wireless PCI Card - F5D7000
+17a0  Genesys Logic, Inc
+	8033  GL880S USB 1.1 controller
+	8034  GL880S USB 2.0 controller
+17af  Hightech Information System Ltd.
+17b3  Hawking Technologies
+	ab08  PN672TX 10/100 Ethernet
+17b4  Indra Networks, Inc.
+	0011  WebEnhance 100 GZIP Compression Card
+17c0  Wistron Corp.
+17c2  Newisys, Inc.
+17cc  NetChip Technology, Inc
+	2280  USB 2.0
+17d3  Areca Technology Corp.
+	1110  ARC-1110 4-Port PCI-X to SATA RAID Controller
+	1120  ARC-1120 8-Port PCI-X to SATA RAID Controller
+	1130  ARC-1130 12-Port PCI-X to SATA RAID Controller
+	1160  ARC-1160 16-Port PCI-X to SATA RAID Controller
+	1210  ARC-1210 4-Port PCI-Express to SATA RAID Controller
+	1220  ARC-1220 8-Port PCI-Express to SATA RAID Controller
+	1230  ARC-1230 12-Port PCI-Express to SATA RAID Controller
+	1260  ARC-1260 16-Port PCI-Express to SATA RAID Controller
+# S2io ships 10Gb PCI-X Ethernet adapters www.s2io.com
+17d5  S2io Inc.
+	5831  Xframe 10 Gigabit Ethernet PCI-X
+		103c 12d5  HP PCI-X 133MHz 10GbE SR Fiber [AB287A]
+17de  KWorld Computer Co. Ltd.
+# http://www.connect3d.com
+17ee  Connect Components Ltd
+17fe  Linksys, A Division of Cisco Systems
+	2120  WMP11v4 802.11b PCI card
+	2220  [AirConn] INPROCOMM IPN 2220 Wireless LAN Adapter (rev 01)
+1813  Ambient Technologies Inc
+	4000  HaM controllerless modem
+		16be 0001  V9x HAM Data Fax Modem
+	4100  HaM plus Data Fax Modem
+		16be 0002  V9x HAM 1394
+1814  RaLink
+	0101  Wireless PCI Adpator RT2400 / RT2460
+		3306 1113  Quidway WL100M
+	0201  Ralink RT2500 802.11 Cardbus Reference Card
+		1371 001e  CWC-854 Wireless-G CardBus Adapter
+		1371 001f  CWM-854 Wireless-G Mini PCI Adapter
+		1371 0020  CWP-854 Wireless-G PCI Adapter
+		1458 e381  GN-WMKG 802.11b/g Wireless CardBus Adapter
+1820  InfiniCon Systems Inc.
+1822  Twinhan Technology Co. Ltd
+182d  SiteCom Europe BV
+# HFC-based ISDN card
+	3069  ISDN PCI DC-105V2
+	9790  WL-121 Wireless Network Adapter 100g+ [Ver.3]
+1830  Credence Systems Corporation
+183b  MikroM GmbH
+	08a7  MVC100 DVI
+	08a8  MVC101 SDI
+	08a9  MVC102 DVI+Audio
+1849  ASRock Incorporation
+1851  Microtune, Inc.
+1852  Anritsu Corp.
+185f  Wistron NeWeb Corp.
+1867  Topspin Communications
+	5a44  MT23108 PCI-X HCA
+	5a45  MT23108 PCI-X HCA flash recovery
+	5a46  MT23108 PCI-X HCA bridge
+	6278  MT25208 InfiniHost III Ex (Tavor compatibility mode)
+	6282  MT25208 InfiniHost III Ex
+187e  ZyXEL Communication Corporation
+1888  Varisys Ltd
+	0301  VMFX1 FPGA PMC module
+	0601  VSM2 dual PMC carrier
+	0710  VS14x series PowerPC PCI board
+	0720  VS24x series PowerPC PCI board
+# found e.g. on KNC DVB-S card
+1894  KNC One
+1896  B&B Electronics Manufacturing Company, Inc.
+18a1  Astute Networks Inc.
+18ac  DViCO Corporation
+	d810  FusionHDTV 3 Gold
+18b8  Ammasso
+	b001  AMSO 1100 iWARP/RDMA Gigabit Ethernet Coprocessor
+18bc  Info-Tek Corp.
+# assigned to Octigabay System, which has been acquired by Cray
+18c8  Cray Inc
+18c9  ARVOO Engineering BV
+18ca  XGI - Xabre Graphics Inc
+	0040  Volari V8
+18e6  MPL AG
+	0001  OSCI [Octal Serial Communication Interface]
+18f7  Commtech, Inc.
+	0001  Fastcom ESCC-PCI-335
+	0002  Fastcom 422/4-PCI-335
+	0004  Fastcom 422/2-PCI-335
+	0005  Fastcom IGESCC-PCI-ISO/1
+	000a  Fastcom 232/4-PCI-335
+18fb  Resilience Corporation
+1924  Level 5 Networks Inc.
+1966  Orad Hi-Tec Systems
+	1975  DVG64 family
+1993  Innominate Security Technologies AG
+# http://www.progeny.net
+19ae  Progeny Systems Corporation
+1a08  Sierra semiconductor
+	0000  SC15064
+1b13  Jaton Corp
+1c1c  Symphony
+	0001  82C101
+1d44  DPT
+	a400  PM2x24/PM3224
+1de1  Tekram Technology Co.,Ltd.
+	0391  TRM-S1040
+	2020  DC-390
+	690c  690c
+	dc29  DC290
+1fc0  Tumsan Oy
+	0300  E2200 Dual E1/Rawpipe Card
+2000  Smart Link Ltd.
+2001  Temporal Research Ltd
+2003  Smart Link Ltd.
+2004  Smart Link Ltd.
+21c3  21st Century Computer Corp.
+2348  Racore
+	2010  8142 100VG/AnyLAN
+2646  Kingston Technologies
+270b  Xantel Corporation
+270f  Chaintech Computer Co. Ltd
+2711  AVID Technology Inc.
+2a15  3D Vision(???)
+3000  Hansol Electronics Inc.
+3142  Post Impression Systems.
+3388  Hint Corp
+	0013  HiNT HC4 PCI to ISDN bridge, Multimedia audio controller
+	0014  HiNT HC4 PCI to ISDN bridge, Network controller
+	0020  HB6 Universal PCI-PCI bridge (transparent mode)
+	0021  HB6 Universal PCI-PCI bridge (non-transparent mode)
+		4c53 1050  CT7 mainboard
+		4c53 1080  CT8 mainboard
+		4c53 10a0  CA3/CR3 mainboard
+		4c53 3010  PPCI mezzanine (32-bit PMC)
+		4c53 3011  PPCI mezzanine (64-bit PMC)
+	0022  HiNT HB4 PCI-PCI Bridge (PCI6150)
+	0026  HB2 PCI-PCI Bridge
+	101a  E.Band [AudioTrak Inca88]
+	101b  E.Band [AudioTrak Inca88]
+	8011  VXPro II Chipset
+		3388 8011  VXPro II Chipset CPU to PCI Bridge
+	8012  VXPro II Chipset
+		3388 8012  VXPro II Chipset PCI to ISA Bridge
+	8013  VXPro II IDE
+		3388 8013  VXPro II Chipset EIDE Controller
+3411  Quantum Designs (H.K.) Inc
+3513  ARCOM Control Systems Ltd
+3842  eVga.com. Corp.
+38ef  4Links
+3d3d  3DLabs
+	0001  GLINT 300SX
+	0002  GLINT 500TX
+	0003  GLINT Delta
+	0004  Permedia
+	0005  Permedia
+	0006  GLINT MX
+	0007  3D Extreme
+	0008  GLINT Gamma G1
+	0009  Permedia II 2D+3D
+		1040 0011  AccelStar II
+		13e9 1000  6221L-4U
+		3d3d 0100  AccelStar II 3D Accelerator
+		3d3d 0111  Permedia 3:16
+		3d3d 0114  Santa Ana
+		3d3d 0116  Oxygen GVX1
+		3d3d 0119  Scirocco
+		3d3d 0120  Santa Ana PCL
+		3d3d 0125  Oxygen VX1
+		3d3d 0127  Permedia3 Create!
+	000a  GLINT R3
+		3d3d 0121  Oxygen VX1
+	000c  GLINT R3 [Oxygen VX1]
+		3d3d 0144  Oxygen VX1-4X AGP [Permedia 4]
+	000d  GLint R4 rev A
+	0011  GLint R4 rev B
+	0012  GLint R5 rev A
+	0013  GLint R5 rev B
+	0020  VP10 visual processor
+# P10 generic II
+	0022  VP10 visual processor
+	0024  VP9 visual processor
+	0100  Permedia II 2D+3D
+	07a1  Wildcat III 6210
+	07a2  Sun XVR-500 Graphics Accelerator
+	07a3  Wildcat IV 7210
+	1004  Permedia
+	3d04  Permedia
+	ffff  Glint VGA
+4005  Avance Logic Inc.
+	0300  ALS300 PCI Audio Device
+	0308  ALS300+ PCI Audio Device
+	0309  PCI Input Controller
+	1064  ALG-2064
+	2064  ALG-2064i
+	2128  ALG-2364A GUI Accelerator
+	2301  ALG-2301
+	2302  ALG-2302
+	2303  AVG-2302 GUI Accelerator
+	2364  ALG-2364A
+	2464  ALG-2464
+	2501  ALG-2564A/25128A
+	4000  ALS4000 Audio Chipset
+		4005 4000  ALS4000 Audio Chipset
+	4710  ALC200/200P
+4033  Addtron Technology Co, Inc.
+	1360  RTL8139 Ethernet
+4143  Digital Equipment Corp
+4144  Alpha Data
+	0044  ADM-XRCIIPro
+416c  Aladdin Knowledge Systems
+	0100  AladdinCARD
+	0200  CPC
+4444  Internext Compression Inc
+	0016  iTVC16 (CX23416) MPEG-2 Encoder
+		0070 4009  WinTV PVR 250
+		0070 8003  WinTV PVR 150
+	0803  iTVC15 MPEG-2 Encoder
+		0070 4000  WinTV PVR-350
+		0070 4001  WinTV PVR-250
+# video capture card
+		1461 a3cf  M179
+4468  Bridgeport machines
+4594  Cogetec Informatique Inc
+45fb  Baldor Electric Company
+4680  Umax Computer Corp
+4843  Hercules Computer Technology Inc
+4916  RedCreek Communications Inc
+	1960  RedCreek PCI adapter
+4943  Growth Networks
+494f  ACCES I/O Products, Inc.
+	10e8  LPCI-COM-8SM
+4978  Axil Computer Inc
+4a14  NetVin
+	5000  NV5000SC
+		4a14 5000  RT8029-Based Ethernet Adapter
+4b10  Buslogic Inc.
+4c48  LUNG HWA Electronics
+4c53  SBS Technologies
+	0000  PLUSTEST device
+		4c53 3000  PLUSTEST card (PC104+)
+		4c53 3001  PLUSTEST card (PMC)
+	0001  PLUSTEST-MM device
+		4c53 3002  PLUSTEST-MM card (PMC)
+4ca1  Seanix Technology Inc
+4d51  MediaQ Inc.
+	0200  MQ-200
+4d54  Microtechnica Co Ltd
+4ddc  ILC Data Device Corp
+	0100  DD-42924I5-300 (ARINC 429 Data Bus)
+	0801  BU-65570I1 MIL-STD-1553 Test and Simulation
+	0802  BU-65570I2 MIL-STD-1553 Test and Simulation
+	0811  BU-65572I1 MIL-STD-1553 Test and Simulation
+	0812  BU-65572I2 MIL-STD-1553 Test and Simulation
+	0881  BU-65570T1 MIL-STD-1553 Test and Simulation
+	0882  BU-65570T2 MIL-STD-1553 Test and Simulation
+	0891  BU-65572T1 MIL-STD-1553 Test and Simulation
+	0892  BU-65572T2 MIL-STD-1553 Test and Simulation
+	0901  BU-65565C1 MIL-STD-1553 Data Bus
+	0902  BU-65565C2 MIL-STD-1553 Data Bus
+	0903  BU-65565C3 MIL-STD-1553 Data Bus
+	0904  BU-65565C4 MIL-STD-1553 Data Bus
+	0b01  BU-65569I1 MIL-STD-1553 Data Bus
+	0b02  BU-65569I2 MIL-STD-1553 Data Bus
+	0b03  BU-65569I3 MIL-STD-1553 Data Bus
+	0b04  BU-65569I4 MIL-STD-1553 Data Bus
+5046  GemTek Technology Corporation
+	1001  PCI Radio
+5053  Voyetra Technologies
+	2010  Daytona Audio Adapter
+5136  S S Technologies
+5143  Qualcomm Inc
+5145  Ensoniq (Old)
+	3031  Concert AudioPCI
+5168  Animation Technologies Inc.
+5301  Alliance Semiconductor Corp.
+	0001  ProMotion aT3D
+5333  S3 Inc.
+	0551  Plato/PX (system)
+	5631  86c325 [ViRGE]
+	8800  86c866 [Vision 866]
+	8801  86c964 [Vision 964]
+	8810  86c764_0 [Trio 32 vers 0]
+	8811  86c764/765 [Trio32/64/64V+]
+	8812  86cM65 [Aurora64V+]
+	8813  86c764_3 [Trio 32/64 vers 3]
+	8814  86c767 [Trio 64UV+]
+	8815  86cM65 [Aurora 128]
+	883d  86c988 [ViRGE/VX]
+	8870  FireGL
+	8880  86c868 [Vision 868 VRAM] vers 0
+	8881  86c868 [Vision 868 VRAM] vers 1
+	8882  86c868 [Vision 868 VRAM] vers 2
+	8883  86c868 [Vision 868 VRAM] vers 3
+	88b0  86c928 [Vision 928 VRAM] vers 0
+	88b1  86c928 [Vision 928 VRAM] vers 1
+	88b2  86c928 [Vision 928 VRAM] vers 2
+	88b3  86c928 [Vision 928 VRAM] vers 3
+	88c0  86c864 [Vision 864 DRAM] vers 0
+	88c1  86c864 [Vision 864 DRAM] vers 1
+	88c2  86c864 [Vision 864-P DRAM] vers 2
+	88c3  86c864 [Vision 864-P DRAM] vers 3
+	88d0  86c964 [Vision 964 VRAM] vers 0
+	88d1  86c964 [Vision 964 VRAM] vers 1
+	88d2  86c964 [Vision 964-P VRAM] vers 2
+	88d3  86c964 [Vision 964-P VRAM] vers 3
+	88f0  86c968 [Vision 968 VRAM] rev 0
+	88f1  86c968 [Vision 968 VRAM] rev 1
+	88f2  86c968 [Vision 968 VRAM] rev 2
+	88f3  86c968 [Vision 968 VRAM] rev 3
+	8900  86c755 [Trio 64V2/DX]
+		5333 8900  86C775 Trio64V2/DX
+	8901  86c775/86c785 [Trio 64V2/DX or /GX]
+		5333 8901  86C775 Trio64V2/DX, 86C785 Trio64V2/GX
+	8902  Plato/PX
+	8903  Trio 3D business multimedia
+	8904  Trio 64 3D
+		1014 00db  Integrated Trio3D
+		5333 8904  86C365 Trio3D AGP
+	8905  Trio 64V+ family
+	8906  Trio 64V+ family
+	8907  Trio 64V+ family
+	8908  Trio 64V+ family
+	8909  Trio 64V+ family
+	890a  Trio 64V+ family
+	890b  Trio 64V+ family
+	890c  Trio 64V+ family
+	890d  Trio 64V+ family
+	890e  Trio 64V+ family
+	890f  Trio 64V+ family
+	8a01  ViRGE/DX or /GX
+		0e11 b032  ViRGE/GX
+		10b4 1617  Nitro 3D
+		10b4 1717  Nitro 3D
+		5333 8a01  ViRGE/DX
+	8a10  ViRGE/GX2
+		1092 8a10  Stealth 3D 4000
+	8a13  86c368 [Trio 3D/2X]
+		5333 8a13  Trio3D/2X
+	8a20  86c794 [Savage 3D]
+		5333 8a20  86C391 Savage3D
+	8a21  86c390 [Savage 3D/MV]
+		5333 8a21  86C390 Savage3D/MV
+	8a22  Savage 4
+		1033 8068  Savage 4
+		1033 8069  Savage 4
+		1033 8110  Savage4 LT
+		105d 0018  SR9 8Mb SDRAM
+		105d 002a  SR9 Pro 16Mb SDRAM
+		105d 003a  SR9 Pro 32Mb SDRAM
+		105d 092f  SR9 Pro+ 16Mb SGRAM
+		1092 4207  Stealth III S540
+		1092 4800  Stealth III S540
+		1092 4807  SpeedStar A90
+		1092 4808  Stealth III S540
+		1092 4809  Stealth III S540
+		1092 480e  Stealth III S540
+		1092 4904  Stealth III S520
+		1092 4905  SpeedStar A200
+		1092 4a09  Stealth III S540
+		1092 4a0b  Stealth III S540 Xtreme
+		1092 4a0f  Stealth III S540
+		1092 4e01  Stealth III S540
+		1102 101d  3d Blaster Savage 4
+		1102 101e  3d Blaster Savage 4
+		5333 8100  86C394-397 Savage4 SDRAM 100
+		5333 8110  86C394-397 Savage4 SDRAM 110
+		5333 8125  86C394-397 Savage4 SDRAM 125
+		5333 8143  86C394-397 Savage4 SDRAM 143
+		5333 8a22  86C394-397 Savage4
+		5333 8a2e  86C394-397 Savage4 32bit
+		5333 9125  86C394-397 Savage4 SGRAM 125
+		5333 9143  86C394-397 Savage4 SGRAM 143
+	8a23  Savage 4
+	8a25  ProSavage PM133
+	8a26  ProSavage KM133
+	8c00  ViRGE/M3
+	8c01  ViRGE/MX
+		1179 0001  ViRGE/MX
+	8c02  ViRGE/MX+
+	8c03  ViRGE/MX+MV
+	8c10  86C270-294 Savage/MX-MV
+	8c11  82C270-294 Savage/MX
+	8c12  86C270-294 Savage/IX-MV
+		1014 017f  ThinkPad T20
+		1179 0001  86C584 SuperSavage/IXC Toshiba
+	8c13  86C270-294 Savage/IX
+		1179 0001  Magnia Z310
+	8c22  SuperSavage MX/128
+	8c24  SuperSavage MX/64
+	8c26  SuperSavage MX/64C
+	8c2a  SuperSavage IX/128 SDR
+	8c2b  SuperSavage IX/128 DDR
+	8c2c  SuperSavage IX/64 SDR
+	8c2d  SuperSavage IX/64 DDR
+	8c2e  SuperSavage IX/C SDR
+		1014 01fc  ThinkPad T23 (2647-4MG)
+	8c2f  SuperSavage IX/C DDR
+	8d01  86C380 [ProSavageDDR K4M266]
+	8d02  VT8636A [ProSavage KN133] AGP4X VGA Controller (TwisterK)
+	8d03  VT8751 [ProSavageDDR P4M266]
+	8d04  VT8375 [ProSavage8 KM266/KL266]
+	9102  86C410 Savage 2000
+		1092 5932  Viper II Z200
+		1092 5934  Viper II Z200
+		1092 5952  Viper II Z200
+		1092 5954  Viper II Z200
+		1092 5a35  Viper II Z200
+		1092 5a37  Viper II Z200
+		1092 5a55  Viper II Z200
+		1092 5a57  Viper II Z200
+	ca00  SonicVibes
+544c  Teralogic Inc
+	0350  TL880-based HDTV/ATSC tuner
+5455  Technische University Berlin
+	4458  S5933
+5519  Cnet Technologies, Inc.
+5544  Dunord Technologies
+	0001  I-30xx Scanner Interface
+5555  Genroco, Inc
+	0003  TURBOstor HFP-832 [HiPPI NIC]
+5654  VoiceTronix Pty Ltd
+	3132  OpenSwitch12
+5700  Netpower
+5851  Exacq Technologies
+6356  UltraStor
+6374  c't Magazin fr Computertechnik
+	6773  GPPCI
+6409  Logitec Corp.
+6666  Decision Computer International Co.
+	0001  PCCOM4
+	0002  PCCOM8
+7604  O.N. Electronic Co Ltd.
+7bde  MIDAC Corporation
+7fed  PowerTV
+8008  Quancom Electronic GmbH
+	0010  WDOG1 [PCI-Watchdog 1]
+	0011  PWDOG2 [PCI-Watchdog 2]
+# Wrong ID used in subsystem ID of AsusTek PCI-USB2 PCI card.
+807d  Asustek Computer, Inc.
+8086  Intel Corporation
+	0007  82379AB
+	0008  Extended Express System Support Controller
+		0008 1000  WorldMark 4300 INCA ASIC
+	0039  21145 Fast Ethernet
+	0122  82437FX
+	0309  80303 I/O Processor PCI-to-PCI Bridge
+	030d  80312 I/O Companion Chip PCI-to-PCI Bridge
+	0326  6700/6702PXH I/OxAPIC Interrupt Controller A
+	0327  6700PXH I/OxAPIC Interrupt Controller B
+	0329  6700PXH PCI Express-to-PCI Bridge A
+	032a  6700PXH PCI Express-to-PCI Bridge B
+	032c  6702PXH PCI Express-to-PCI Bridge A
+# A-segment bridge
+	0330  80332 [Dobson] I/O processor
+# A-segment IOAPIC
+	0331  80332 [Dobson] I/O processor
+# B-segment bridge
+	0332  80332 [Dobson] I/O processor
+# B-segment IOAPIC
+	0333  80332 [Dobson] I/O processor
+# Address Translation Unit (ATU)
+	0334  80332 [Dobson] I/O processor
+# PCI-X bridge
+	0335  80331 [Lindsay] I/O processor
+# Address Translation Unit (ATU)
+	0336  80331 [Lindsay] I/O processor
+# A-segment bridge
+	0340  41210 [Lanai] Serial to Parallel PCI Bridge
+# B-segment bridge
+	0341  41210 [Lanai] Serial to Parallel PCI Bridge
+	0482  82375EB/SB PCI to EISA Bridge
+	0483  82424TX/ZX [Saturn] CPU to PCI bridge
+	0484  82378ZB/IB, 82379AB (SIO, SIO.A) PCI to ISA Bridge
+	0486  82425EX/ZX [Aries] PCIset with ISA bridge
+	04a3  82434LX/NX [Mercury/Neptune] Processor to PCI bridge
+	04d0  82437FX [Triton FX]
+	0500  E8870 Processor bus control
+	0501  E8870 Memory controller
+# and registers common to both SPs
+	0502  E8870 Scalability Port 0
+# and global performance monitoring
+	0503  E8870 Scalability Port 1
+	0510  E8870IO Hub Interface Port 0 registers (8-bit compatibility port)
+	0511  E8870IO Hub Interface Port 1 registers
+	0512  E8870IO Hub Interface Port 2 registers
+	0513  E8870IO Hub Interface Port 3 registers
+	0514  E8870IO Hub Interface Port 4 registers
+	0515  E8870IO General SIOH registers
+	0516  E8870IO RAS registers
+	0530  E8870SP Scalability Port 0 registers
+	0531  E8870SP Scalability Port 1 registers
+	0532  E8870SP Scalability Port 2 registers
+	0533  E8870SP Scalability Port 3 registers
+	0534  E8870SP Scalability Port 4 registers
+	0535  E8870SP Scalability Port 5 registers
+# (bi-interleave 0) and global registers that are neither per-port nor per-interleave
+	0536  E8870SP Interleave registers 0 and 1
+# (bi-interleave 1)
+	0537  E8870SP Interleave registers 2 and 3
+	0600  RAID Controller
+		8086 01c1  ICP Vortex GDT8546RZ
+		8086 01f7  SCRU32
+# uninitialized SRCU32 RAID Controller
+	061f  80303 I/O Processor
+	0960  80960RP [i960 RP Microprocessor/Bridge]
+	0962  80960RM [i960RM Bridge]
+	0964  80960RP [i960 RP Microprocessor/Bridge]
+	1000  82542 Gigabit Ethernet Controller
+		0e11 b0df  NC1632 Gigabit Ethernet Adapter (1000-SX)
+		0e11 b0e0  NC1633 Gigabit Ethernet Adapter (1000-LX)
+		0e11 b123  NC1634 Gigabit Ethernet Adapter (1000-SX)
+		1014 0119  Netfinity Gigabit Ethernet SX Adapter
+		8086 1000  PRO/1000 Gigabit Server Adapter
+	1001  82543GC Gigabit Ethernet Controller (Fiber)
+		0e11 004a  NC6136 Gigabit Server Adapter
+		1014 01ea  Netfinity Gigabit Ethernet SX Adapter
+		8086 1002  PRO/1000 F Server Adapter
+		8086 1003  PRO/1000 F Server Adapter
+	1002  Pro 100 LAN+Modem 56 Cardbus II
+		8086 200e  Pro 100 LAN+Modem 56 Cardbus II
+		8086 2013  Pro 100 SR Mobile Combo Adapter
+		8086 2017  Pro 100 S Combo Mobile Adapter
+	1004  82543GC Gigabit Ethernet Controller (Copper)
+		0e11 0049  NC7132 Gigabit Upgrade Module
+		0e11 b1a4  NC7131 Gigabit Server Adapter
+		1014 10f2  Gigabit Ethernet Server Adapter
+		8086 1004  PRO/1000 T Server Adapter
+		8086 2004  PRO/1000 T Server Adapter
+	1008  82544EI Gigabit Ethernet Controller (Copper)
+		1014 0269  iSeries 1000/100/10 Ethernet Adapter
+		1028 011c  PRO/1000 XT Network Connection
+		8086 1107  PRO/1000 XT Server Adapter
+		8086 2107  PRO/1000 XT Server Adapter
+		8086 2110  PRO/1000 XT Server Adapter
+		8086 3108  PRO/1000 XT Network Connection
+	1009  82544EI Gigabit Ethernet Controller (Fiber)
+		1014 0268  iSeries Gigabit Ethernet Adapter
+		8086 1109  PRO/1000 XF Server Adapter
+		8086 2109  PRO/1000 XF Server Adapter
+	100c  82544GC Gigabit Ethernet Controller (Copper)
+		8086 1112  PRO/1000 T Desktop Adapter
+		8086 2112  PRO/1000 T Desktop Adapter
+	100d  82544GC Gigabit Ethernet Controller (LOM)
+		1028 0123  PRO/1000 XT Network Connection
+		1079 891f  82544GC Based Network Connection
+		4c53 1080  CT8 mainboard
+		8086 110d  82544GC Based Network Connection
+	100e  82540EM Gigabit Ethernet Controller
+		1014 0265  PRO/1000 MT Network Connection
+		1014 0267  PRO/1000 MT Network Connection
+		1014 026a  PRO/1000 MT Network Connection
+		1028 002e  Optiplex GX260
+		1028 0151  PRO/1000 MT Network Connection
+		107b 8920  PRO/1000 MT Desktop Adapter
+		8086 001e  PRO/1000 MT Desktop Adapter
+		8086 002e  PRO/1000 MT Desktop Adapter
+	100f  82545EM Gigabit Ethernet Controller (Copper)
+		1014 0269  iSeries 1000/100/10 Ethernet Adapter
+		1014 028e  PRO/1000 MT Network Connection
+		8086 1000  PRO/1000 MT Network Connection
+		8086 1001  PRO/1000 MT Server Adapter
+	1010  82546EB Gigabit Ethernet Controller (Copper)
+		1014 027c  PRO/1000 MT Dual Port Network Adapter
+		18fb 7872  RESlink-X
+		4c53 1080  CT8 mainboard
+		4c53 10a0  CA3/CR3 mainboard
+		8086 1011  PRO/1000 MT Dual Port Server Adapter
+		8086 101a  PRO/1000 MT Dual Port Network Adapter
+		8086 3424  SE7501HG2 Mainboard
+	1011  82545EM Gigabit Ethernet Controller (Fiber)
+		1014 0268  iSeries Gigabit Ethernet Adapter
+		8086 1002  PRO/1000 MF Server Adapter
+		8086 1003  PRO/1000 MF Server Adapter (LX)
+	1012  82546EB Gigabit Ethernet Controller (Fiber)
+		8086 1012  PRO/1000 MF Dual Port Server Adapter
+	1013  82541EI Gigabit Ethernet Controller (Copper)
+		8086 0013  PRO/1000 MT Network Connection
+		8086 1013  IBM ThinkCentre Network Card
+		8086 1113  PRO/1000 MT Desktop Adapter
+	1014  82541ER Gigabit Ethernet Controller
+	1015  82540EM Gigabit Ethernet Controller (LOM)
+	1016  82540EP Gigabit Ethernet Controller (LOM)
+		1014 052c  PRO/1000 MT Mobile Connection
+		1179 0001  PRO/1000 MT Mobile Connection
+		8086 1016  PRO/1000 MT Mobile Connection
+	1017  82540EP Gigabit Ethernet Controller (LOM)
+		8086 1017  PR0/1000 MT Desktop Connection
+# Update controller name from 82541EP to 82541EI
+	1018  82541EI Gigabit Ethernet Controller
+		8086 1018  PRO/1000 MT Desktop Adapter
+	1019  82547EI Gigabit Ethernet Controller (LOM)
+		1458 1019  GA-8IPE1000 Pro2 motherboard (865PE)
+		1458 e000  Intel Gigabit Ethernet (Kenai II)
+		8086 1019  PRO/1000 CT Desktop Connection
+		8086 301f  D865PERL mainboard
+		8086 3427  S875WP1-E mainboard
+	101d  82546EB Gigabit Ethernet Controller
+		8086 1000  PRO/1000 MT Quad Port Server Adapter
+	101e  82540EP Gigabit Ethernet Controller (Mobile)
+		1014 0549  PRO/1000 MT Mobile Connection
+		1179 0001  PRO/1000 MT Mobile Connection
+		8086 101e  PRO/1000 MT Mobile Connection
+	1026  82545GM Gigabit Ethernet Controller
+		8086 1000  PRO/1000 MT Server Connection
+		8086 1001  PRO/1000 MT Server Adapter
+		8086 1002  PRO/1000 MT Server Adapter
+		8086 1026  PRO/1000 MT Server Connection
+	1027  82545GM Gigabit Ethernet Controller
+		8086 1001  PRO/1000 MF Server Adapter(LX)
+		8086 1002  PRO/1000 MF Server Adapter(LX)
+		8086 1003  PRO/1000 MF Server Adapter(LX)
+		8086 1027  PRO/1000 MF Server Adapter
+	1028  82545GM Gigabit Ethernet Controller
+		8086 1028  PRO/1000 MB Server Adapter
+	1029  82559 Ethernet Controller
+	1030  82559 InBusiness 10/100
+	1031  82801CAM (ICH3) PRO/100 VE (LOM) Ethernet Controller
+		1014 0209  ThinkPad A/T/X Series
+		104d 80e7  Vaio PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		107b 5350  EtherExpress PRO/100 VE
+		1179 0001  EtherExpress PRO/100 VE
+		144d c000  EtherExpress PRO/100 VE
+		144d c001  EtherExpress PRO/100 VE
+		144d c003  EtherExpress PRO/100 VE
+		144d c006  vpr Matrix 170B4
+	1032  82801CAM (ICH3) PRO/100 VE Ethernet Controller
+	1033  82801CAM (ICH3) PRO/100 VM (LOM) Ethernet Controller
+	1034  82801CAM (ICH3) PRO/100 VM Ethernet Controller
+	1035  82801CAM (ICH3)/82562EH (LOM)  Ethernet Controller
+	1036  82801CAM (ICH3) 82562EH Ethernet Controller
+	1037  82801CAM (ICH3) Chipset Ethernet Controller
+	1038  82801CAM (ICH3) PRO/100 VM (KM) Ethernet Controller
+	1039  82801DB PRO/100 VE (LOM) Ethernet Controller
+		1014 0267  NetVista A30p
+	103a  82801DB PRO/100 VE (CNR) Ethernet Controller
+	103b  82801DB PRO/100 VM (LOM) Ethernet Controller
+	103c  82801DB PRO/100 VM (CNR) Ethernet Controller
+	103d  82801DB PRO/100 VE (MOB) Ethernet Controller
+	103e  82801DB PRO/100 VM (MOB) Ethernet Controller
+	1040  536EP Data Fax Modem
+		16be 1040  V.9X DSP Data Fax Modem
+	1043  PRO/Wireless LAN 2100 3B Mini PCI Adapter
+		8086 2527  MIM2000/Centrino
+	1048  PRO/10GbE LR Server Adapter
+		8086 a01f  PRO/10GbE LR Server Adapter
+		8086 a11f  PRO/10GbE LR Server Adapter
+	1050  82562EZ 10/100 Ethernet Controller
+		1462 728c  865PE Neo2 (MS-6728)
+		1462 758c  MS-6758 (875P Neo)
+		8086 3020  D865PERL mainboard
+		8086 3427  S875WP1-E mainboard
+	1051  82801EB/ER (ICH5/ICH5R) integrated LAN Controller
+	1059  82551QM Ethernet Controller
+# ICH-6 Component
+	1064  82562ET/EZ/GT/GZ - PRO/100 VE (LOM) Ethernet Controller
+# ICH-6 Component
+	1065  82562ET/EZ/GT/GZ - PRO/100 VE Ethernet Controller
+# ICH-6 Component
+	1066  82562 EM/EX/GX - PRO/100 VM (LOM) Ethernet Controller
+# ICH-6 Component
+	1067  82562 EM/EX/GX - PRO/100 VM Ethernet Controller
+# ICH-6 Component
+	1068  82562ET/EZ/GT/GZ - PRO/100 VE (LOM) Ethernet Controller Mobile
+# ICH-6 Component
+	1069  82562 EM/EX/GX - PRO/100 VM (LOM) Ethernet Controller Mobile
+# ICH-6 Component
+	106a  82562G \t- PRO/100 VE (LOM) Ethernet Controller
+# ICH-6 Component
+	106b  82562G \t- PRO/100 VE Ethernet Controller Mobile
+	1075  82547GI Gigabit Ethernet Controller
+		1028 0165  PowerEdge 750
+		8086 0075  PRO/1000 CT Network Connection
+		8086 1075  PRO/1000 CT Network Connection
+	1076  82541GI/PI Gigabit Ethernet Controller
+		1028 0165  PowerEdge 750
+		8086 0076  PRO/1000 MT Network Connection
+		8086 1076  PRO/1000 MT Network Connection
+		8086 1176  PRO/1000 MT Desktop Adapter
+		8086 1276  PRO/1000 MT Desktop Adapter
+	1077  82541GI Gigabit Ethernet Controller
+		1179 0001  PRO/1000 MT Mobile Connection
+		8086 0077  PRO/1000 MT Mobile Connection
+		8086 1077  PRO/1000 MT Mobile Connection
+	1078  82541EI Gigabit Ethernet Controller
+		8086 1078  PRO/1000 MT Network Connection
+	1079  82546GB Gigabit Ethernet Controller
+		103c 12a6  HP Dual Port 1000Base-T [A9900A]
+		103c 12cf  HP Core Dual Port 1000Base-T [AB352A]
+		4c53 1090  Cx9 / Vx9 mainboard
+		4c53 10b0  CL9 mainboard
+		8086 0079  PRO/1000 MT Dual Port Network Connection
+		8086 1079  PRO/1000 MT Dual Port Network Connection
+		8086 1179  PRO/1000 MT Dual Port Network Connection
+		8086 117a  PRO/1000 MT Dual Port Server Adapter
+	107a  82546GB Gigabit Ethernet Controller
+		103c 12a8  HP Dual Port 1000base-SX [A9899A]
+		8086 107a  PRO/1000 MF Dual Port Server Adapter
+		8086 127a  PRO/1000 MF Dual Port Server Adapter
+	107b  82546GB Gigabit Ethernet Controller
+		8086 007b  PRO/1000 MB Dual Port Server Connection
+		8086 107b  PRO/1000 MB Dual Port Server Connection
+	1107  PRO/1000 MF Server Adapter (LX)
+	1130  82815 815 Chipset Host Bridge and Memory Controller Hub
+		1025 1016  Travelmate 612 TX
+		1043 8027  TUSL2-C Mainboard
+		104d 80df  Vaio PCG-FX403
+		8086 4532  D815EEA2 mainboard
+		8086 4557  D815EGEW Mainboard
+	1131  82815 815 Chipset AGP Bridge
+	1132  82815 CGC [Chipset Graphics Controller]
+		1025 1016  Travelmate 612 TX
+		104d 80df  Vaio PCG-FX403
+		8086 4532  D815EEA2 Mainboard
+		8086 4557  D815EGEW Mainboard
+	1161  82806AA PCI64 Hub Advanced Programmable Interrupt Controller
+		8086 1161  82806AA PCI64 Hub APIC
+	1162  Xscale 80200 Big Endian Companion Chip
+	1200  Intel IXP1200 Network Processor
+		172a 0000  AEP SSL Accelerator
+	1209  8255xER/82551IT Fast Ethernet Controller
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+		4c53 1070  PC6 mainboard
+	1221  82092AA PCI to PCMCIA Bridge
+	1222  82092AA IDE Controller
+	1223  SAA7116
+	1225  82452KX/GX [Orion]
+	1226  82596 PRO/10 PCI
+	1227  82865 EtherExpress PRO/100A
+	1228  82556 EtherExpress PRO/100 Smart
+# the revision field differentiates between them (1-3 is 82557, 4-5 is 82558, 6-8 is 82559, 9 is 82559ER)
+	1229  82557/8/9 [Ethernet Pro 100]
+		0e11 3001  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 3002  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 3003  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 3004  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 3005  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 3006  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 3007  82559 Fast Ethernet LOM with Alert on LAN*
+		0e11 b01e  NC3120 Fast Ethernet NIC
+		0e11 b01f  NC3122 Fast Ethernet NIC (dual port)
+		0e11 b02f  NC1120 Ethernet NIC
+		0e11 b04a  Netelligent 10/100TX NIC with Wake on LAN
+		0e11 b0c6  NC3161 Fast Ethernet NIC (embedded, WOL)
+		0e11 b0c7  NC3160 Fast Ethernet NIC (embedded)
+		0e11 b0d7  NC3121 Fast Ethernet NIC (WOL)
+		0e11 b0dd  NC3131 Fast Ethernet NIC (dual port)
+		0e11 b0de  NC3132 Fast Ethernet Module (dual port)
+		0e11 b0e1  NC3133 Fast Ethernet Module (100-FX)
+		0e11 b134  NC3163 Fast Ethernet NIC (embedded, WOL)
+		0e11 b13c  NC3162 Fast Ethernet NIC (embedded)
+		0e11 b144  NC3123 Fast Ethernet NIC (WOL)
+		0e11 b163  NC3134 Fast Ethernet NIC (dual port)
+		0e11 b164  NC3135 Fast Ethernet Upgrade Module (dual port)
+		0e11 b1a4  NC7131 Gigabit Server Adapter
+		1014 005c  82558B Ethernet Pro 10/100
+		1014 01bc  82559 Fast Ethernet LAN On Motherboard
+		1014 01f1  10/100 Ethernet Server Adapter
+		1014 01f2  10/100 Ethernet Server Adapter
+		1014 0207  Ethernet Pro/100 S
+		1014 0232  10/100 Dual Port Server Adapter
+		1014 023a  ThinkPad R30
+		1014 105c  Netfinity 10/100
+		1014 2205  ThinkPad A22p
+		1014 305c  10/100 EtherJet Management Adapter
+		1014 405c  10/100 EtherJet Adapter with Alert on LAN
+		1014 505c  10/100 EtherJet Secure Management Adapter
+		1014 605c  10/100 EtherJet Secure Management Adapter
+		1014 705c  10/100 Netfinity 10/100 Ethernet Security Adapter
+		1014 805c  10/100 Netfinity 10/100 Ethernet Security Adapter
+		1028 009b  PowerEdge 2500/2550
+		1028 00ce  PowerEdge 1400
+		1033 8000  PC-9821X-B06
+		1033 8016  PK-UG-X006
+		1033 801f  PK-UG-X006
+		1033 8026  PK-UG-X006
+		1033 8063  82559-based Fast Ethernet Adapter
+		1033 8064  82559-based Fast Ethernet Adapter
+		103c 10c0  NetServer 10/100TX
+		103c 10c3  NetServer 10/100TX
+		103c 10ca  NetServer 10/100TX
+		103c 10cb  NetServer 10/100TX
+		103c 10e3  NetServer 10/100TX
+		103c 10e4  NetServer 10/100TX
+		103c 1200  NetServer 10/100TX
+		10c3 1100  SmartEther100 SC1100
+		10cf 1115  8255x-based Ethernet Adapter (10/100)
+		10cf 1143  8255x-based Ethernet Adapter (10/100)
+		1179 0001  8255x-based Ethernet Adapter (10/100)
+		1179 0002  PCI FastEther LAN on Docker
+		1179 0003  8255x-based Fast Ethernet
+		1259 2560  AT-2560 100
+		1259 2561  AT-2560 100 FX Ethernet Adapter
+		1266 0001  NE10/100 Adapter
+		13e9 1000  6221L-4U
+		144d 2501  SEM-2000 MiniPCI LAN Adapter
+		144d 2502  SEM-2100IL MiniPCI LAN Adapter
+		1668 1100  EtherExpress PRO/100B (TX) (MiniPCI Ethernet+Modem)
+		4c53 1080  CT8 mainboard
+		8086 0001  EtherExpress PRO/100B (TX)
+		8086 0002  EtherExpress PRO/100B (T4)
+		8086 0003  EtherExpress PRO/10+
+		8086 0004  EtherExpress PRO/100 WfM
+		8086 0005  82557 10/100
+		8086 0006  82557 10/100 with Wake on LAN
+		8086 0007  82558 10/100 Adapter
+		8086 0008  82558 10/100 with Wake on LAN
+		8086 0009  EtherExpress PRO/100+
+		8086 000a  EtherExpress PRO/100+ Management Adapter
+		8086 000b  EtherExpress PRO/100+
+		8086 000c  EtherExpress PRO/100+ Management Adapter
+		8086 000d  EtherExpress PRO/100+ Alert On LAN II* Adapter
+		8086 000e  EtherExpress PRO/100+ Management Adapter with Alert On LAN*
+		8086 000f  EtherExpress PRO/100 Desktop Adapter
+		8086 0010  EtherExpress PRO/100 S Management Adapter
+		8086 0011  EtherExpress PRO/100 S Management Adapter
+		8086 0012  EtherExpress PRO/100 S Advanced Management Adapter (D)
+		8086 0013  EtherExpress PRO/100 S Advanced Management Adapter (E)
+		8086 0030  EtherExpress PRO/100  Management Adapter with Alert On LAN* GC
+		8086 0031  EtherExpress PRO/100 Desktop Adapter
+		8086 0040  EtherExpress PRO/100 S Desktop Adapter
+		8086 0041  EtherExpress PRO/100 S Desktop Adapter
+		8086 0042  EtherExpress PRO/100 Desktop Adapter
+		8086 0050  EtherExpress PRO/100 S Desktop Adapter
+		8086 1009  EtherExpress PRO/100+ Server Adapter
+		8086 100c  EtherExpress PRO/100+ Server Adapter (PILA8470B)
+		8086 1012  EtherExpress PRO/100 S Server Adapter (D)
+		8086 1013  EtherExpress PRO/100 S Server Adapter (E)
+		8086 1015  EtherExpress PRO/100 S Dual Port Server Adapter
+		8086 1017  EtherExpress PRO/100+ Dual Port Server Adapter
+		8086 1030  EtherExpress PRO/100+ Management Adapter with Alert On LAN* G Server
+		8086 1040  EtherExpress PRO/100 S Server Adapter
+		8086 1041  EtherExpress PRO/100 S Server Adapter
+		8086 1042  EtherExpress PRO/100 Server Adapter
+		8086 1050  EtherExpress PRO/100 S Server Adapter
+		8086 1051  EtherExpress PRO/100 Server Adapter
+		8086 1052  EtherExpress PRO/100 Server Adapter
+		8086 10f0  EtherExpress PRO/100+ Dual Port Adapter
+		8086 2009  EtherExpress PRO/100 S Mobile Adapter
+		8086 200d  EtherExpress PRO/100 Cardbus
+		8086 200e  EtherExpress PRO/100 LAN+V90 Cardbus Modem
+		8086 200f  EtherExpress PRO/100 SR Mobile Adapter
+		8086 2010  EtherExpress PRO/100 S Mobile Combo Adapter
+		8086 2013  EtherExpress PRO/100 SR Mobile Combo Adapter
+		8086 2016  EtherExpress PRO/100 S Mobile Adapter
+		8086 2017  EtherExpress PRO/100 S Combo Mobile Adapter
+		8086 2018  EtherExpress PRO/100 SR Mobile Adapter
+		8086 2019  EtherExpress PRO/100 SR Combo Mobile Adapter
+		8086 2101  EtherExpress PRO/100 P Mobile Adapter
+		8086 2102  EtherExpress PRO/100 SP Mobile Adapter
+		8086 2103  EtherExpress PRO/100 SP Mobile Adapter
+		8086 2104  EtherExpress PRO/100 SP Mobile Adapter
+		8086 2105  EtherExpress PRO/100 SP Mobile Adapter
+		8086 2106  EtherExpress PRO/100 P Mobile Adapter
+		8086 2107  EtherExpress PRO/100 Network Connection
+		8086 2108  EtherExpress PRO/100 Network Connection
+		8086 2200  EtherExpress PRO/100 P Mobile Combo Adapter
+		8086 2201  EtherExpress PRO/100 P Mobile Combo Adapter
+		8086 2202  EtherExpress PRO/100 SP Mobile Combo Adapter
+		8086 2203  EtherExpress PRO/100+ MiniPCI
+		8086 2204  EtherExpress PRO/100+ MiniPCI
+		8086 2205  EtherExpress PRO/100 SP Mobile Combo Adapter
+		8086 2206  EtherExpress PRO/100 SP Mobile Combo Adapter
+		8086 2207  EtherExpress PRO/100 SP Mobile Combo Adapter
+		8086 2208  EtherExpress PRO/100 P Mobile Combo Adapter
+		8086 2402  EtherExpress PRO/100+ MiniPCI
+		8086 2407  EtherExpress PRO/100+ MiniPCI
+		8086 2408  EtherExpress PRO/100+ MiniPCI
+		8086 2409  EtherExpress PRO/100+ MiniPCI
+		8086 240f  EtherExpress PRO/100+ MiniPCI
+		8086 2410  EtherExpress PRO/100+ MiniPCI
+		8086 2411  EtherExpress PRO/100+ MiniPCI
+		8086 2412  EtherExpress PRO/100+ MiniPCI
+		8086 2413  EtherExpress PRO/100+ MiniPCI
+		8086 3000  82559 Fast Ethernet LAN on Motherboard
+		8086 3001  82559 Fast Ethernet LOM with Basic Alert on LAN*
+		8086 3002  82559 Fast Ethernet LOM with Alert on LAN II*
+		8086 3006  EtherExpress PRO/100 S Network Connection
+		8086 3007  EtherExpress PRO/100 S Network Connection
+		8086 3008  EtherExpress PRO/100 Network Connection
+		8086 3010  EtherExpress PRO/100 S Network Connection
+		8086 3011  EtherExpress PRO/100 S Network Connection
+		8086 3012  EtherExpress PRO/100 Network Connection
+		8086 3411  SDS2 Mainboard
+	122d  430FX - 82437FX TSC [Triton I]
+	122e  82371FB PIIX ISA [Triton I]
+	1230  82371FB PIIX IDE [Triton I]
+	1231  DSVD Modem
+	1234  430MX - 82371MX Mobile PCI I/O IDE Xcelerator (MPIIX)
+	1235  430MX - 82437MX Mob. System Ctrlr (MTSC) & 82438MX Data Path (MTDP)
+	1237  440FX - 82441FX PMC [Natoma]
+	1239  82371FB PIIX IDE Interface
+	123b  82380PB PCI to PCI Docking Bridge
+	123c  82380AB (MISA) Mobile PCI-to-ISA Bridge
+	123d  683053 Programmable Interrupt Device
+# in" hidden" mode
+	123e  82466GX (IHPC) Integrated Hot-Plug Controller
+	123f  82466GX Integrated Hot-Plug Controller (IHPC)
+	1240  82752 (752) AGP Graphics Accelerator
+	124b  82380FB (MPCI2) Mobile Docking Controller
+	1250  430HX - 82439HX TXC [Triton II]
+	1360  82806AA PCI64 Hub PCI Bridge
+	1361  82806AA PCI64 Hub Controller (HRes)
+		8086 1361  82806AA PCI64 Hub Controller (HRes)
+		8086 8000  82806AA PCI64 Hub Controller (HRes)
+	1460  82870P2 P64H2 Hub PCI Bridge
+	1461  82870P2 P64H2 I/OxAPIC
+		15d9 3480  P4DP6
+		4c53 1090  Cx9 / Vx9 mainboard
+	1462  82870P2 P64H2 Hot Plug Controller
+	1960  80960RP [i960RP Microprocessor]
+		101e 0431  MegaRAID 431 RAID Controller
+		101e 0438  MegaRAID 438 Ultra2 LVD RAID Controller
+		101e 0466  MegaRAID 466 Express Plus RAID Controller
+		101e 0467  MegaRAID 467 Enterprise 1500 RAID Controller
+		101e 0490  MegaRAID 490 Express 300 RAID Controller
+		101e 0762  MegaRAID 762 Express RAID Controller
+		101e 09a0  PowerEdge Expandable RAID Controller 2/SC
+		1028 0467  PowerEdge Expandable RAID Controller 2/DC
+		1028 1111  PowerEdge Expandable RAID Controller 2/SC
+		103c 03a2  MegaRAID
+		103c 10c6  MegaRAID 438, HP NetRAID-3Si
+		103c 10c7  MegaRAID T5, Integrated HP NetRAID
+		103c 10cc  MegaRAID, Integrated HP NetRAID
+		103c 10cd  HP NetRAID-1Si
+		105a 0000  SuperTrak
+		105a 2168  SuperTrak Pro
+		105a 5168  SuperTrak66/100
+		1111 1111  MegaRAID 466, PowerEdge Expandable RAID Controller 2/SC
+		1111 1112  PowerEdge Expandable RAID Controller 2/SC
+		113c 03a2  MegaRAID
+		e4bf 1010  CG1-RADIO
+		e4bf 1020  CU2-QUARTET
+		e4bf 1040  CU1-CHORUS
+		e4bf 3100  CX1-BAND
+	1962  80960RM [i960RM Microprocessor]
+		105a 0000  SuperTrak SX6000 I2O CPU
+	1a21  82840 840 (Carmel) Chipset Host Bridge (Hub A)
+	1a23  82840 840 (Carmel) Chipset AGP Bridge
+	1a24  82840 840 (Carmel) Chipset PCI Bridge (Hub B)
+	1a30  82845 845 (Brookdale) Chipset Host Bridge
+		1028 010e  Optiplex GX240
+	1a31  82845 845 (Brookdale) Chipset AGP Bridge
+	2410  82801AA ISA Bridge (LPC)
+	2411  82801AA IDE
+	2412  82801AA USB
+	2413  82801AA SMBus
+	2415  82801AA AC'97 Audio
+		1028 0095  Precision Workstation 220 Integrated Digital Audio
+		11d4 0040  SoundMAX Integrated Digital Audio
+		11d4 0048  SoundMAX Integrated Digital Audio
+		11d4 5340  SoundMAX Integrated Digital Audio
+	2416  82801AA AC'97 Modem
+	2418  82801AA PCI Bridge
+	2420  82801AB ISA Bridge (LPC)
+	2421  82801AB IDE
+	2422  82801AB USB
+	2423  82801AB SMBus
+	2425  82801AB AC'97 Audio
+		11d4 0040  SoundMAX Integrated Digital Audio
+		11d4 0048  SoundMAX Integrated Digital Audio
+	2426  82801AB AC'97 Modem
+	2428  82801AB PCI Bridge
+	2440  82801BA ISA Bridge (LPC)
+	2442  82801BA/BAM USB (Hub #1)
+		1014 01c6  Netvista A40/A40p
+		1025 1016  Travelmate 612 TX
+		1028 010e  Optiplex GX240
+		1043 8027  TUSL2-C Mainboard
+		104d 80df  Vaio PCG-FX403
+		147b 0507  TH7II-RAID
+		8086 4532  D815EEA2 mainboard
+		8086 4557  D815EGEW Mainboard
+	2443  82801BA/BAM SMBus
+		1014 01c6  Netvista A40/A40p
+		1025 1016  Travelmate 612 TX
+		1028 010e  Optiplex GX240
+		1043 8027  TUSL2-C Mainboard
+		104d 80df  Vaio PCG-FX403
+		147b 0507  TH7II-RAID
+		8086 4532  D815EEA2 mainboard
+		8086 4557  D815EGEW Mainboard
+	2444  82801BA/BAM USB (Hub #2)
+		1025 1016  Travelmate 612 TX
+		1028 010e  Optiplex GX240
+		1043 8027  TUSL2-C Mainboard
+		104d 80df  Vaio PCG-FX403
+		147b 0507  TH7II-RAID
+		8086 4532  D815EEA2 mainboard
+	2445  82801BA/BAM AC'97 Audio
+		1014 01c6  Netvista A40/A40p
+		1025 1016  Travelmate 612 TX
+		104d 80df  Vaio PCG-FX403
+		1462 3370  STAC9721 AC
+		147b 0507  TH7II-RAID
+		8086 4557  D815EGEW Mainboard
+	2446  82801BA/BAM AC'97 Modem
+		1025 1016  Travelmate 612 TX
+		104d 80df  Vaio PCG-FX403
+	2448  82801 Mobile PCI Bridge
+	2449  82801BA/BAM/CA/CAM Ethernet Controller
+		0e11 0012  EtherExpress PRO/100 VM
+		0e11 0091  EtherExpress PRO/100 VE
+		1014 01ce  EtherExpress PRO/100 VE
+		1014 01dc  EtherExpress PRO/100 VE
+		1014 01eb  EtherExpress PRO/100 VE
+		1014 01ec  EtherExpress PRO/100 VE
+		1014 0202  EtherExpress PRO/100 VE
+		1014 0205  EtherExpress PRO/100 VE
+		1014 0217  EtherExpress PRO/100 VE
+		1014 0234  EtherExpress PRO/100 VE
+		1014 023d  EtherExpress PRO/100 VE
+		1014 0244  EtherExpress PRO/100 VE
+		1014 0245  EtherExpress PRO/100 VE
+		1014 0265  PRO/100 VE Desktop Connection
+		1014 0267  PRO/100 VE Desktop Connection
+		1014 026a  PRO/100 VE Desktop Connection
+		109f 315d  EtherExpress PRO/100 VE
+		109f 3181  EtherExpress PRO/100 VE
+		1179 ff01  PRO/100 VE Network Connection
+		1186 7801  EtherExpress PRO/100 VE
+		144d 2602  HomePNA 1M CNR
+		8086 3010  EtherExpress PRO/100 VE
+		8086 3011  EtherExpress PRO/100 VM
+		8086 3012  82562EH based Phoneline
+		8086 3013  EtherExpress PRO/100 VE
+		8086 3014  EtherExpress PRO/100 VM
+		8086 3015  82562EH based Phoneline
+		8086 3016  EtherExpress PRO/100 P Mobile Combo
+		8086 3017  EtherExpress PRO/100 P Mobile
+		8086 3018  EtherExpress PRO/100
+	244a  82801BAM IDE U100
+		1025 1016  Travelmate 612TX
+		104d 80df  Vaio PCG-FX403
+	244b  82801BA IDE U100
+		1014 01c6  Netvista A40/A40p
+		1028 010e  Optiplex GX240
+		1043 8027  TUSL2-C Mainboard
+		147b 0507  TH7II-RAID
+		8086 4532  D815EEA2 mainboard
+		8086 4557  D815EGEW Mainboard
+	244c  82801BAM ISA Bridge (LPC)
+	244e  82801 PCI Bridge
+		1014 0267  NetVista A30p
+	2450  82801E ISA Bridge (LPC)
+	2452  82801E USB
+	2453  82801E SMBus
+	2459  82801E Ethernet Controller 0
+	245b  82801E IDE U100
+	245d  82801E Ethernet Controller 1
+	245e  82801E PCI Bridge
+	2480  82801CA LPC Interface Controller
+	2482  82801CA/CAM USB (Hub #1)
+		1014 0220  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		15d9 3480  P4DP6
+		8086 1958  vpr Matrix 170B4
+		8086 3424  SE7501HG2 Mainboard
+		8086 4541  Latitude C640
+	2483  82801CA/CAM SMBus Controller
+		1014 0220  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		15d9 3480  P4DP6
+		8086 1958  vpr Matrix 170B4
+	2484  82801CA/CAM USB (Hub #2)
+		1014 0220  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		15d9 3480  P4DP6
+		8086 1958  vpr Matrix 170B4
+	2485  82801CA/CAM AC'97 Audio Controller
+		1013 5959  Crystal WMD Audio Codec
+		1014 0222  ThinkPad T23 (2647-4MG) or A30/A30p (2652/2653)
+		1014 0508  ThinkPad T30
+		1014 051c  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		144d c006  vpr Matrix 170B4
+	2486  82801CA/CAM AC'97 Modem Controller
+		1014 0223  ThinkPad A/T/X Series
+		1014 0503  ThinkPad R31 2656BBG
+		1014 051a  ThinkPad A/T/X Series
+		101f 1025  Acer 620 Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		1179 0001  Toshiba Satellite 1110 Z15 internal Modem
+		134d 4c21  Dell Inspiron 2100 internal modem
+		144d 2115  vpr Matrix 170B4 internal modem
+		14f1 5421  MD56ORD V.92 MDC Modem
+	2487  82801CA/CAM USB (Hub #3)
+		1014 0220  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		15d9 3480  P4DP6
+		8086 1958  vpr Matrix 170B4
+	248a  82801CAM IDE U100
+		1014 0220  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+		8086 1958  vpr Matrix 170B4
+		8086 4541  Latitude C640
+	248b  82801CA Ultra ATA Storage Controller
+		15d9 3480  P4DP6
+	248c  82801CAM ISA Bridge (LPC)
+	24c0  82801DB/DBL (ICH4/ICH4-L) LPC Interface Bridge
+		1014 0267  NetVista A30p
+		1462 5800  845PE Max (MS-6580)
+	24c1  82801DBL (ICH4-L) IDE Controller
+	24c2  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #1
+		1014 0267  NetVista A30p
+		1025 005a  TravelMate 290
+		1028 0126  Optiplex GX260
+		1028 0163  Latitude D505
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+		1462 5800  845PE Max (MS-6580)
+		1509 2990  Averatec 5110H laptop
+		4c53 1090  Cx9 / Vx9 mainboard
+	24c3  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) SMBus Controller
+		1014 0267  NetVista A30p
+		1025 005a  TravelMate 290
+		1028 0126  Optiplex GX260
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+		1458 24c2  GA-8PE667 Ultra
+		1462 5800  845PE Max (MS-6580)
+		4c53 1090  Cx9 / Vx9 mainboard
+	24c4  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #2
+		1014 0267  NetVista A30p
+		1025 005a  TravelMate 290
+		1028 0126  Optiplex GX260
+		1028 0163  Latitude D505
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+		1462 5800  845PE Max (MS-6580)
+		1509 2990  Averatec 5110H
+		4c53 1090  Cx9 / Vx9 mainboard
+	24c5  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) AC'97 Audio Controller
+		0e11 00b8  Analog Devices Inc. codec [SoundMAX]
+		1014 0267  NetVista A30p
+		1025 005a  TravelMate 290
+		1028 0163  Latitude D505
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+		1458 a002  GA-8PE667 Ultra
+		1462 5800  845PE Max (MS-6580)
+	24c6  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) AC'97 Modem Controller
+		1025 005a  TravelMate 290
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+	24c7  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #3
+		1014 0267  NetVista A30p
+		1025 005a  TravelMate 290
+		1028 0126  Optiplex GX260
+		1028 0163  Latitude D505
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+		1462 5800  845PE Max (MS-6580)
+		1509 2990  Averatec 5110H
+		4c53 1090  Cx9 / Vx9 mainboard
+	24ca  82801DBM (ICH4-M) IDE Controller
+		1025 005a  TravelMate 290
+		1028 0163  Latitude D505
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+	24cb  82801DB (ICH4) IDE Controller
+		1014 0267  NetVista A30p
+		1028 0126  Optiplex GX260
+		1458 24c2  GA-8PE667 Ultra
+		1462 5800  845PE Max (MS-6580)
+		4c53 1090  Cx9 / Vx9 mainboard
+	24cc  82801DBM (ICH4-M) LPC Interface Bridge
+	24cd  82801DB/DBM (ICH4/ICH4-M) USB2 EHCI Controller
+		1014 0267  NetVista A30p
+		1025 005a  TravelMate 290
+		1028 0126  Optiplex GX260
+		1028 0163  Latitude D505
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+		1071 8160  MIM2000
+		1462 3981  845PE Max (MS-6580)
+		1509 1968  Averatec 5110H
+		4c53 1090  Cx9 / Vx9 mainboard
+	24d0  82801EB/ER (ICH5/ICH5R) LPC Interface Bridge
+	24d1  82801EB (ICH5) SATA Controller
+		103c 12bc  d530 CMT (DG746A)
+		1458 24d1  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24d2  82801EB/ER (ICH5/ICH5R) USB UHCI Controller #1
+		1028 0183  PowerEdge 1800
+		103c 12bc  d530 CMT (DG746A)
+		1043 80a6  P4P800 Mainboard
+		1458 24d2  GA-8IPE1000/8KNXP motherboard
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24d3  82801EB/ER (ICH5/ICH5R) SMBus Controller
+		1043 80a6  P4P800 Mainboard
+		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24d4  82801EB/ER (ICH5/ICH5R) USB UHCI Controller #2
+		1028 0183  PowerEdge 1800
+		103c 12bc  d530 CMT (DG746A)
+		1043 80a6  P4P800 Mainboard
+		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24d5  82801EB/ER (ICH5/ICH5R) AC'97 Audio Controller
+		103c 12bc  Analog Devices codec [SoundMAX Integrated Digital Audio]
+		1043 80f3  P4P800 Mainboard
+# Again, I suppose they use the same in different subsystems
+		1458 a002  GA-8IPE1000/8KNXP motherboard
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 a000  D865PERL mainboard
+		8086 e000  D865PERL mainboard
+	24d6  82801EB/ER (ICH5/ICH5R) AC'97 Modem Controller
+	24d7  82801EB/ER (ICH5/ICH5R) USB UHCI #3
+		1028 0183  PowerEdge 1800
+		103c 12bc  d530 CMT (DG746A)
+		1043 80a6  P4P800 Mainboard
+		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24db  82801EB/ER (ICH5/ICH5R) IDE Controller
+		103c 12bc  d530 CMT (DG746A)
+		1043 80a6  P4P800 Mainboard
+		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		1462 7580  MSI 875P
+		8086 24db  P4C800 Mainboard
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24dc  82801EB (ICH5) LPC Interface Bridge
+	24dd  82801EB/ER (ICH5/ICH5R) USB2 EHCI Controller
+		1028 0183  PowerEdge 1800
+		103c 12bc  d530 CMT (DG746A)
+		1043 80a6  P4P800 Mainboard
+		1458 5006  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24de  82801EB/ER (ICH5/ICH5R) USB UHCI Controller #4
+		1043 80a6  P4P800 Mainboard
+		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
+		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
+		8086 524c  D865PERL mainboard
+	24df  82801ER (ICH5R) SATA Controller
+	2500  82820 820 (Camino) Chipset Host Bridge (MCH)
+		1028 0095  Precision Workstation 220 Chipset
+		1043 801c  P3C-2000 system chipset
+	2501  82820 820 (Camino) Chipset Host Bridge (MCH)
+		1043 801c  P3C-2000 system chipset
+	250b  82820 820 (Camino) Chipset Host Bridge
+	250f  82820 820 (Camino) Chipset AGP Bridge
+	2520  82805AA MTH Memory Translator Hub
+	2521  82804AA MRH-S Memory Repeater Hub for SDRAM
+	2530  82850 850 (Tehama) Chipset Host Bridge (MCH)
+		147b 0507  TH7II-RAID
+	2531  82860 860 (Wombat) Chipset Host Bridge (MCH)
+	2532  82850 850 (Tehama) Chipset AGP Bridge
+	2533  82860 860 (Wombat) Chipset AGP Bridge
+	2534  82860 860 (Wombat) Chipset PCI Bridge
+	2540  E7500 Memory Controller Hub
+		15d9 3480  P4DP6
+	2541  E7500/E7501 Host RASUM Controller
+		15d9 3480  P4DP6
+		4c53 1090  Cx9 / Vx9 mainboard
+		8086 3424  SE7501HG2 Mainboard
+	2543  E7500/E7501 Hub Interface B PCI-to-PCI Bridge
+	2544  E7500/E7501 Hub Interface B RASUM Controller
+		4c53 1090  Cx9 / Vx9 mainboard
+	2545  E7500/E7501 Hub Interface C PCI-to-PCI Bridge
+	2546  E7500/E7501 Hub Interface C RASUM Controller
+	2547  E7500/E7501 Hub Interface D PCI-to-PCI Bridge
+	2548  E7500/E7501 Hub Interface D RASUM Controller
+	254c  E7501 Memory Controller Hub
+		4c53 1090  Cx9 / Vx9 mainboard
+		8086 3424  SE7501HG2 Mainboard
+	2550  E7505 Memory Controller Hub
+	2551  E7505/E7205 Series RAS Controller
+	2552  E7505/E7205 PCI-to-AGP Bridge
+	2553  E7505 Hub Interface B PCI-to-PCI Bridge
+	2554  E7505 Hub Interface B PCI-to-PCI Bridge RAS Controller
+	255d  E7205 Memory Controller Hub
+	2560  82845G/GL[Brookdale-G]/GE/PE DRAM Controller/Host-Hub Interface
+		1028 0126  Optiplex GX260
+		1458 2560  GA-8PE667 Ultra
+		1462 5800  845PE Max (MS-6580)
+	2561  82845G/GL[Brookdale-G]/GE/PE Host-to-AGP Bridge
+	2562  82845G/GL[Brookdale-G]/GE Chipset Integrated Graphics Device
+		1014 0267  NetVista A30p
+	2570  82865G/PE/P DRAM Controller/Host-Hub Interface
+		1043 80f2  P4P800 Mainboard
+		1458 2570  GA-8IPE1000 Pro2 motherboard (865PE)
+	2571  82865G/PE/P PCI to AGP Controller
+	2572  82865G Integrated Graphics Controller
+	2573  82865G/PE/P PCI to CSA Bridge
+	2576  82865G/PE/P Processor to I/O Memory Interface
+	2578  82875P/E7210 Memory Controller Hub
+		1458 2578  GA-8KNXP motherboard (875P)
+		1462 7580  MS-6758 (875P Neo)
+# Motherboard P4SCE
+		15d9 4580  Super Micro Computer Inc. P4SCE
+	2579  82875P Processor to AGP Controller
+	257b  82875P/E7210 Processor to PCI to CSA Bridge
+	257e  82875P/E7210 Processor to I/O Memory Interface
+	2580  915G/P/GV/GL/PL/910GL Processor to I/O Controller
+	2581  915G/P/GV/GL/PL/910GL PCI Express Root Port
+	2582  82915G/GV/910GL Express Chipset Family Graphics Controller
+		1028 1079  Optiplex GX280
+	2584  925X/XE Memory Controller Hub
+	2585  925X/XE PCI Express Root Port
+	2588  E7220/E7221 Memory Controller Hub
+	2589  E7220/E7221 PCI Express Root Port
+	258a  E7221 Integrated Graphics Controller
+	2590  Mobile 915GM/PM/GMS/910GML Express Processor to DRAM Controller
+	2591  Mobile 915GM/PM Express PCI Express Root Port
+	2592  Mobile 915GM/GMS/910GML Express Graphics Controller
+	25a1  6300ESB LPC Interface Controller
+	25a2  6300ESB PATA Storage Controller
+		4c53 10b0  CL9 mainboard
+	25a3  6300ESB SATA Storage Controller
+		4c53 10b0  CL9 mainboard
+	25a4  6300ESB SMBus Controller
+		4c53 10b0  CL9 mainboard
+	25a6  6300ESB AC'97 Audio Controller
+		4c53 10b0  CL9 mainboard
+	25a7  6300ESB AC'97 Modem Controller
+	25a9  6300ESB USB Universal Host Controller
+		4c53 10b0  CL9 mainboard
+	25aa  6300ESB USB Universal Host Controller
+		4c53 10b0  CL9 mainboard
+	25ab  6300ESB Watchdog Timer
+		4c53 10b0  CL9 mainboard
+	25ac  6300ESB I/O Advanced Programmable Interrupt Controller
+		4c53 10b0  CL9 mainboard
+	25ad  6300ESB USB2 Enhanced Host Controller
+	25ae  6300ESB 64-bit PCI-X Bridge
+	25b0  6300ESB SATA RAID Controller
+	2600  E8500 Hub Interface
+	2601  E8500 PCI Express x4 Port D
+	2602  E8500 PCI Express x4 Port C0
+	2603  E8500 PCI Express x4 Port C1
+	2604  E8500 PCI Express x4 Port B0
+	2605  E8500 PCI Express x4 Port B1
+	2606  E8500 PCI Express x4 Port A0
+	2607  E8500 PCI Express x4 Port A1
+	2608  E8500 PCI Express x8 Port C
+	2609  E8500 PCI Express x8 Port B
+	260a  E8500 PCI Express x8 Port A
+	260c  E8500 IMI Registers
+	2610  E8500 System Bus, Boot, and Interrupt Registers
+	2611  E8500 Address Mapping Registers
+	2612  E8500 RAS Registers
+	2613  E8500 Reserved Registers
+	2614  E8500 Reserved Registers
+	2615  E8500 Miscellaneous Registers
+	2617  E8500 Reserved Registers
+	2618  E8500 Reserved Registers
+	2619  E8500 Reserved Registers
+	261a  E8500 Reserved Registers
+	261b  E8500 Reserved Registers
+	261c  E8500 Reserved Registers
+	261d  E8500 Reserved Registers
+	261e  E8500 Reserved Registers
+	2620  E8500 eXternal Memory Bridge
+	2621  E8500 XMB Miscellaneous Registers
+	2622  E8500 XMB Memory Interleaving Registers
+	2623  E8500 XMB DDR Initialization and Calibration
+	2624  E8500 XMB Reserved Registers
+	2625  E8500 XMB Reserved Registers
+	2626  E8500 XMB Reserved Registers
+	2627  E8500 XMB Reserved Registers
+	2640  82801FB/FR (ICH6/ICH6R) LPC Interface Bridge
+	2641  82801FBM (ICH6M) LPC Interface Bridge
+	2642  82801FW/FRW (ICH6W/ICH6RW) LPC Interface Bridge
+	2651  82801FB/FW (ICH6/ICH6W) SATA Controller
+		1028 0179  Optiplex GX280
+	2652  82801FR/FRW (ICH6R/ICH6RW) SATA Controller
+	2653  82801FBM (ICH6M) SATA Controller
+	2658  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1
+		1028 0179  Optiplex GX280
+	2659  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #2
+		1028 0179  Optiplex GX280
+	265a  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #3
+		1028 0179  Optiplex GX280
+	265b  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #4
+		1028 0179  Optiplex GX280
+	265c  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB2 EHCI Controller
+		1028 0179  Optiplex GX280
+	2660  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1
+	2662  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 2
+	2664  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 3
+	2666  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 4
+	2668  82801FB/FBM/FR/FW/FRW (ICH6 Family) High Definition Audio Controller
+	266a  82801FB/FBM/FR/FW/FRW (ICH6 Family) SMBus Controller
+		1028 0179  Optiplex GX280
+	266c  82801FB/FBM/FR/FW/FRW (ICH6 Family) LAN Controller
+	266d  82801FB/FBM/FR/FW/FRW (ICH6 Family) AC'97 Modem Controller
+	266e  82801FB/FBM/FR/FW/FRW (ICH6 Family) AC'97 Audio Controller
+		1028 0179  Optiplex GX280
+	266f  82801FB/FBM/FR/FW/FRW (ICH6 Family) IDE Controller
+	2770  Memory Controller Hub
+	2771  PCI Express Graphics Port
+	2772  Integrated Graphics Controller
+	2774  Workstation Memory Controller Hub
+	2775  PCI Express Graphics Port
+	2776  Integrated Graphics Controller
+	2778  Server Memory Controller Hub
+	2779  PCI Express Root Port
+	2782  82915G Express Chipset Family Graphics Controller
+	2792  Mobile 915GM/GMS/910GML Express Graphics Controller
+	27b8  I/O Controller Hub LPC
+	27b9  Mobile I/O Controller Hub LPC
+	27c0  I/O Controller Hub SATA cc=IDE
+	27c1  I/O Controller Hub SATA cc=AHCI
+	27c3  I/O Controller Hub SATA cc=RAID
+	27c4  Mobile I/O Controller Hub SATA cc=IDE
+	27c5  Mobile I/O Controller Hub SATA cc=AHCI
+	27c8  I/O Controller Hub UHCI USB #1
+	27c9  I/O Controller Hub UHCI USB #2
+	27ca  I/O Controller Hub UHCI USB #3
+	27cb  I/O Controller Hub UHCI USB #4
+	27cc  I/O Controller Hub EHCI USB
+	27d0  I/O Controller Hub PCI Express Port 1
+	27d2  I/O Controller Hub PCI Express Port 2
+	27d4  I/O Controller Hub PCI Express Port 3
+	27d6  I/O Controller Hub PCI Express Port 4
+	27d8  I/O Controller Hub High Definition Audio
+	27da  I/O Controller Hub SMBus
+	27dc  I/O Controller Hub LAN
+	27dd  I/O Controller Hub AC'97 Modem
+	27de  I/O Controller Hub AC'97 Audio
+	27df  I/O Controller Hub PATA
+	27e0  I/O Controller Hub PCI Express Port 5
+	27e2  I/O Controller Hub PCI Express Port 6
+	3092  Integrated RAID
+	3200  GD31244 PCI-X SATA HBA
+	3340  82855PM Processor to I/O Controller
+		1025 005a  TravelMate 290
+		103c 088c  nc8000 laptop
+		103c 0890  nc6000 laptop
+	3341  82855PM Processor to AGP Controller
+	3575  82830 830 Chipset Host Bridge
+		1014 021d  ThinkPad A/T/X Series
+		104d 80e7  VAIO PCG-GR214EP/GR214MP/GR215MP/GR314MP/GR315MP
+	3576  82830 830 Chipset AGP Bridge
+	3577  82830 CGC [Chipset Graphics Controller]
+		1014 0513  ThinkPad A/T/X Series
+	3578  82830 830 Chipset Host Bridge
+	3580  82852/82855 GM/GME/PM/GMV Processor to I/O Controller
+		1028 0163  Latitude D505
+		4c53 10b0  CL9 mainboard
+	3581  82852/82855 GM/GME/PM/GMV Processor to AGP Controller
+	3582  82852/855GM Integrated Graphics Device
+		1028 0163  Latitude D505
+		4c53 10b0  CL9 mainboard
+	3584  82852/82855 GM/GME/PM/GMV Processor to I/O Controller
+		1028 0163  Latitude D505
+		4c53 10b0  CL9 mainboard
+	3585  82852/82855 GM/GME/PM/GMV Processor to I/O Controller
+		1028 0163  Latitude D505
+		4c53 10b0  CL9 mainboard
+	3590  E7520 Memory Controller Hub
+	3591  E7525/E7520 Error Reporting Registers
+	3592  E7320 Memory Controller Hub
+	3593  E7320 Error Reporting Registers
+	3594  E7520 DMA Controller
+	3595  E7525/E7520/E7320 PCI Express Port A
+	3596  E7525/E7520/E7320 PCI Express Port A1
+	3597  E7525/E7520 PCI Express Port B
+	3598  E7520 PCI Express Port B1
+	3599  E7520 PCI Express Port C
+	359a  E7520 PCI Express Port C1
+	359b  E7525/E7520/E7320 Extended Configuration Registers
+	359e  E7525 Memory Controller Hub
+	4220  PRO/Wireless 2200BG
+	4223  PRO/Wireless 2915ABG MiniPCI Adapter
+	5200  EtherExpress PRO/100 Intelligent Server
+	5201  EtherExpress PRO/100 Intelligent Server
+		8086 0001  EtherExpress PRO/100 Server Ethernet Adapter
+	530d  80310 IOP [IO Processor]
+	7000  82371SB PIIX3 ISA [Natoma/Triton II]
+	7010  82371SB PIIX3 IDE [Natoma/Triton II]
+	7020  82371SB PIIX3 USB [Natoma/Triton II]
+	7030  430VX - 82437VX TVX [Triton VX]
+	7050  Intel Intercast Video Capture Card
+	7100  430TX - 82439TX MTXC
+	7110  82371AB/EB/MB PIIX4 ISA
+		15ad 1976  virtualHW v3
+	7111  82371AB/EB/MB PIIX4 IDE
+		15ad 1976  virtualHW v3
+	7112  82371AB/EB/MB PIIX4 USB
+		15ad 1976  virtualHW v3
+	7113  82371AB/EB/MB PIIX4 ACPI
+		15ad 1976  virtualHW v3
+	7120  82810 GMCH [Graphics Memory Controller Hub]
+		4c53 1040  CL7 mainboard
+		4c53 1060  PC7 mainboard
+	7121  82810 CGC [Chipset Graphics Controller]
+		4c53 1040  CL7 mainboard
+		4c53 1060  PC7 mainboard
+		8086 4341  Cayman (CA810) Mainboard
+	7122  82810 DC-100 GMCH [Graphics Memory Controller Hub]
+	7123  82810 DC-100 CGC [Chipset Graphics Controller]
+	7124  82810E DC-133 GMCH [Graphics Memory Controller Hub]
+	7125  82810E DC-133 CGC [Chipset Graphics Controller]
+	7126  82810 DC-133 System and Graphics Controller
+	7128  82810-M DC-100 System and Graphics Controller
+	712a  82810-M DC-133 System and Graphics Controller
+	7180  440LX/EX - 82443LX/EX Host bridge
+	7181  440LX/EX - 82443LX/EX AGP bridge
+	7190  440BX/ZX/DX - 82443BX/ZX/DX Host bridge
+		0e11 0500  Armada 1750 Laptop System Chipset
+		0e11 b110  Armada M700/E500
+		1179 0001  Toshiba Tecra 8100 Laptop System Chipset
+		15ad 1976  virtualHW v3
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+	7191  440BX/ZX/DX - 82443BX/ZX/DX AGP bridge
+	7192  440BX/ZX/DX - 82443BX/ZX/DX Host bridge (AGP disabled)
+		0e11 0460  Armada 1700 Laptop System Chipset
+		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
+	7194  82440MX Host Bridge
+		1033 0000  Versa Note Vxi
+		4c53 10a0  CA3/CR3 mainboard
+	7195  82440MX AC'97 Audio Controller
+		1033 80cc  Versa Note VXi
+		10cf 1099  QSound_SigmaTel Stac97 PCI Audio
+		11d4 0040  SoundMAX Integrated Digital Audio
+		11d4 0048  SoundMAX Integrated Digital Audio
+	7196  82440MX AC'97 Modem Controller
+	7198  82440MX ISA Bridge
+	7199  82440MX EIDE Controller
+	719a  82440MX USB Universal Host Controller
+	719b  82440MX Power Management Controller
+	71a0  440GX - 82443GX Host bridge
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+	71a1  440GX - 82443GX AGP bridge
+	71a2  440GX - 82443GX Host bridge (AGP disabled)
+		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
+	7600  82372FB PIIX5 ISA
+	7601  82372FB PIIX5 IDE
+	7602  82372FB PIIX5 USB
+	7603  82372FB PIIX5 SMBus
+	7800  82740 (i740) AGP Graphics Accelerator
+		003d 0008  Starfighter AGP
+		003d 000b  Starfighter AGP
+		1092 0100  Stealth II G460
+		10b4 201a  Lightspeed 740
+		10b4 202f  Lightspeed 740
+		8086 0000  Terminator 2x/i
+		8086 0100  Intel740 Graphics Accelerator
+	84c4  450KX/GX [Orion] - 82454KX/GX PCI bridge
+	84c5  450KX/GX [Orion] - 82453KX/GX Memory controller
+	84ca  450NX - 82451NX Memory & I/O Controller
+	84cb  450NX - 82454NX/84460GX PCI Expander Bridge
+	84e0  460GX - 84460GX System Address Controller (SAC)
+	84e1  460GX - 84460GX System Data Controller (SDC)
+	84e2  460GX - 84460GX AGP Bridge (GXB function 2)
+	84e3  460GX - 84460GX Memory Address Controller (MAC)
+	84e4  460GX - 84460GX Memory Data Controller (MDC)
+	84e6  460GX - 82466GX Wide and fast PCI eXpander Bridge (WXB)
+	84ea  460GX - 84460GX AGP Bridge (GXB function 1)
+	8500  IXP4XX - Intel Network Processor family. IXP420, IXP421, IXP422, IXP425 and IXC1100
+		1993 0dee  mGuard-PCI AV#1
+		1993 0def  mGuard-PCI AV#0
+	9000  IXP2000 Family Network Processor
+	9001  IXP2400 Network Processor
+	9004  IXP2800 Network Processor
+	9621  Integrated RAID
+	9622  Integrated RAID
+	9641  Integrated RAID
+	96a1  Integrated RAID
+# retail verson
+	a01f  PRO/10GbE LR Server Adapter
+# OEM version
+	a11f  PRO/10GbE LR Server Adapter
+	b152  21152 PCI-to-PCI Bridge
+# observed, and documented in Intel revision note; new mask of 1011:0026
+	b154  21154 PCI-to-PCI Bridge
+	b555  21555 Non transparent PCI-to-PCI Bridge
+		12d9 000a  PCI VoIP Gateway
+		4c53 1050  CT7 mainboard
+		4c53 1051  CE7 mainboard
+		e4bf 1000  CC8-1-BLUES
+	ffff  450NX/GX [Orion] - 82453KX/GX Memory controller [BUG]
+8401  TRENDware International Inc.
+8800  Trigem Computer Inc.
+	2008  Video assistent component
+8866  T-Square Design Inc.
+8888  Silicon Magic
+# 8c4a is not Winbond but there is a board misprogrammed
+8c4a  Winbond
+	1980  W89C940 misprogrammed [ne2k]
+8e0e  Computone Corporation
+8e2e  KTI
+	3000  ET32P2
+9004  Adaptec
+	0078  AHA-2940U_CN
+	1078  AIC-7810
+	1160  AIC-1160 [Family Fibre Channel Adapter]
+	2178  AIC-7821
+	3860  AHA-2930CU
+	3b78  AHA-4844W/4844UW
+	5075  AIC-755x
+	5078  AHA-7850
+		9004 7850  AHA-2904/Integrated AIC-7850
+	5175  AIC-755x
+	5178  AIC-7851
+	5275  AIC-755x
+	5278  AIC-7852
+	5375  AIC-755x
+	5378  AIC-7850
+	5475  AIC-755x
+	5478  AIC-7850
+	5575  AVA-2930
+	5578  AIC-7855
+	5647  ANA-7711 TCP Offload Engine
+		9004 7710  ANA-7711F TCP Offload Engine - Optical
+		9004 7711  ANA-7711LP TCP Offload Engine - Copper
+	5675  AIC-755x
+	5678  AIC-7856
+	5775  AIC-755x
+	5778  AIC-7850
+	5800  AIC-5800
+	5900  ANA-5910/5930/5940 ATM155 & 25 LAN Adapter
+	5905  ANA-5910A/5930A/5940A ATM Adapter
+	6038  AIC-3860
+	6075  AIC-1480 / APA-1480
+		9004 7560  AIC-1480 / APA-1480 Cardbus
+	6078  AIC-7860
+	6178  AIC-7861
+		9004 7861  AHA-2940AU Single
+	6278  AIC-7860
+	6378  AIC-7860
+	6478  AIC-786x
+	6578  AIC-786x
+	6678  AIC-786x
+	6778  AIC-786x
+	6915  ANA620xx/ANA69011A
+		9004 0008  ANA69011A/TX 10/100
+		9004 0009  ANA69011A/TX 10/100
+		9004 0010  ANA62022 2-port 10/100
+		9004 0018  ANA62044 4-port 10/100
+		9004 0019  ANA62044 4-port 10/100
+		9004 0020  ANA62022 2-port 10/100
+		9004 0028  ANA69011A/TX 10/100
+		9004 8008  ANA69011A/TX 64 bit 10/100
+		9004 8009  ANA69011A/TX 64 bit 10/100
+		9004 8010  ANA62022 2-port 64 bit 10/100
+		9004 8018  ANA62044 4-port 64 bit 10/100
+		9004 8019  ANA62044 4-port 64 bit 10/100
+		9004 8020  ANA62022 2-port 64 bit 10/100
+		9004 8028  ANA69011A/TX 64 bit 10/100
+	7078  AHA-294x / AIC-7870
+	7178  AHA-2940/2940W / AIC-7871
+	7278  AHA-3940/3940W / AIC-7872
+	7378  AHA-3985 / AIC-7873
+	7478  AHA-2944/2944W / AIC-7874
+	7578  AHA-3944/3944W / AIC-7875
+	7678  AHA-4944W/UW / AIC-7876
+	7710  ANA-7711F Network Accelerator Card (NAC) - Optical
+	7711  ANA-7711C Network Accelerator Card (NAC) - Copper
+	7778  AIC-787x
+	7810  AIC-7810
+	7815  AIC-7815 RAID+Memory Controller IC
+		9004 7815  ARO-1130U2 RAID Controller
+		9004 7840  AIC-7815 RAID+Memory Controller IC
+	7850  AIC-7850
+	7855  AHA-2930
+	7860  AIC-7860
+	7870  AIC-7870
+	7871  AHA-2940
+	7872  AHA-3940
+	7873  AHA-3980
+	7874  AHA-2944
+	7880  AIC-7880P
+	7890  AIC-7890
+	7891  AIC-789x
+	7892  AIC-789x
+	7893  AIC-789x
+	7894  AIC-789x
+	7895  AHA-2940U/UW / AHA-39xx / AIC-7895
+		9004 7890  AHA-2940U/2940UW Dual AHA-394xAU/AUW/AUWD AIC-7895B
+		9004 7891  AHA-2940U/2940UW Dual
+		9004 7892  AHA-3940AU/AUW/AUWD/UWD
+		9004 7894  AHA-3944AUWD
+		9004 7895  AHA-2940U/2940UW Dual AHA-394xAU/AUW/AUWD AIC-7895B
+		9004 7896  AHA-2940U/2940UW Dual AHA-394xAU/AUW/AUWD AIC-7895B
+		9004 7897  AHA-2940U/2940UW Dual AHA-394xAU/AUW/AUWD AIC-7895B
+	7896  AIC-789x
+	7897  AIC-789x
+	8078  AIC-7880U
+		9004 7880  AIC-7880P Ultra/Ultra Wide SCSI Chipset
+	8178  AHA-2940U/UW/D / AIC-7881U
+		9004 7881  AHA-2940UW SCSI Host Adapter
+	8278  AHA-3940U/UW/UWD / AIC-7882U
+	8378  AHA-3940U/UW / AIC-7883U
+	8478  AHA-2944UW / AIC-7884U
+	8578  AHA-3944U/UWD / AIC-7885
+	8678  AHA-4944UW / AIC-7886
+	8778  AHA-2940UW Pro / AIC-788x
+		9004 7887  2940UW Pro Ultra-Wide SCSI Controller
+	8878  AHA-2930UW / AIC-7888
+		9004 7888  AHA-2930UW SCSI Controller
+	8b78  ABA-1030
+	ec78  AHA-4944W/UW
+9005  Adaptec
+	0010  AHA-2940U2/U2W
+		9005 2180  AHA-2940U2 SCSI Controller
+		9005 8100  AHA-2940U2B SCSI Controller
+		9005 a100  AHA-2940U2B SCSI Controller
+		9005 a180  AHA-2940U2W SCSI Controller
+		9005 e100  AHA-2950U2B SCSI Controller
+	0011  AHA-2930U2
+	0013  78902
+		9005 0003  AAA-131U2 Array1000 1 Channel RAID Controller
+		9005 000f  AIC7890_ARO
+	001f  AHA-2940U2/U2W / 7890/7891
+		9005 000f  2940U2W SCSI Controller
+		9005 a180  2940U2W SCSI Controller
+	0020  AIC-7890
+	002f  AIC-7890
+	0030  AIC-7890
+	003f  AIC-7890
+	0050  AHA-3940U2x/395U2x
+		9005 f500  AHA-3950U2B
+		9005 ffff  AHA-3950U2B
+	0051  AHA-3950U2D
+		9005 b500  AHA-3950U2D
+	0053  AIC-7896 SCSI Controller
+		9005 ffff  AIC-7896 SCSI Controller mainboard implementation
+	005f  AIC-7896U2/7897U2
+	0080  AIC-7892A U160/m
+		0e11 e2a0  Compaq 64-Bit/66MHz Wide Ultra3 SCSI Adapter
+		9005 6220  AHA-29160C
+		9005 62a0  29160N Ultra160 SCSI Controller
+		9005 e220  29160LP Low Profile Ultra160 SCSI Controller
+		9005 e2a0  29160 Ultra160 SCSI Controller
+	0081  AIC-7892B U160/m
+		9005 62a1  19160 Ultra160 SCSI Controller
+	0083  AIC-7892D U160/m
+	008f  AIC-7892P U160/m
+		1179 0001  Magnia Z310
+		15d9 9005  Onboard SCSI Host Adapter
+	00c0  AHA-3960D / AIC-7899A U160/m
+		0e11 f620  Compaq 64-Bit/66MHz Dual Channel Wide Ultra3 SCSI Adapter
+		9005 f620  AHA-3960D U160/m
+	00c1  AIC-7899B U160/m
+	00c3  AIC-7899D U160/m
+	00c5  RAID subsystem HBA
+		1028 00c5  PowerEdge 2400,2500,2550,4400
+	00cf  AIC-7899P U160/m
+		1028 00ce  PowerEdge 1400
+		1028 00d1  PowerEdge 2550
+		1028 00d9  PowerEdge 2500
+		10f1 2462  Thunder K7 S2462
+		15d9 9005  Onboard SCSI Host Adapter
+		8086 3411  SDS2 Mainboard
+	0250  ServeRAID Controller
+		1014 0279  ServeRAID-xx
+		1014 028c  ServeRAID-xx
+# from kernel sources
+	0279  ServeRAID 6M
+	0283  AAC-RAID
+		9005 0283  Catapult
+	0284  AAC-RAID
+		9005 0284  Tomcat
+	0285  AAC-RAID
+		0e11 0295  SATA 6Ch (Bearcat)
+		1014 02f2  ServeRAID 8i
+		1028 0287  PowerEdge Expandable RAID Controller 320/DC
+		1028 0291  CERC SATA RAID 2 PCI SATA 6ch (DellCorsair)
+		103c 3227  AAR-2610SA
+		17aa 0286  Legend S220 (Legend Crusader)
+		17aa 0287  Legend S230 (Legend Vulcan)
+		9005 0285  2200S (Vulcan)
+		9005 0286  2120S (Crusader)
+		9005 0287  2200S (Vulcan-2m)
+		9005 0288  3230S (Harrier)
+		9005 0289  3240S (Tornado)
+		9005 028a  ASR-2020S PCI-X ZCR (Skyhawk)
+		9005 028b  ASR-2020S SO-DIMM PCI-X ZCR (Terminator)
+		9005 0290  AAR-2410SA PCI SATA 4ch (Jaguar II)
+		9005 0292  AAR-2810SA PCI SATA 8ch (Corsair-8)
+		9005 0293  AAR-21610SA PCI SATA 16ch (Corsair-16)
+		9005 0294  ESD SO-DIMM PCI-X SATA ZCR (Prowler)
+	0286  AAC-RAID (Rocket)
+		9005 028c  ASR-2230S + ASR-2230SLP PCI-X (Lancer)
+	0503  Scamp chipset SCSI controller
+		1014 02BF  Quad Channel PCI-X DDR U320 SCSI RAID Adapter (571E)
+	8000  ASC-29320A U320
+	800f  AIC-7901 U320
+	8010  ASC-39320 U320
+	8011  ASC-32320D U320
+		0e11 00ac  ASC-39320D U320
+		9005 0041  ASC-39320D U320
+	8012  ASC-29320 U320
+	8013  ASC-29320B U320
+	8014  ASC-29320LP U320
+	8015  ASC-39320B U320
+	8016  ASC-39320A U320
+	8017  ASC-29320ALP U320
+	801c  ASC-39320D U320
+	801d  AIC-7902B U320
+	801e  AIC-7901A U320
+	801f  AIC-7902 U320
+	8080  ASC-29320A U320 w/HostRAID
+	808f  AIC-7901 U320 w/HostRAID
+	8090  ASC-39320 U320 w/HostRAID
+	8091  ASC-39320D U320 w/HostRAID
+	8092  ASC-29320 U320 w/HostRAID
+	8093  ASC-29320B U320 w/HostRAID
+	8094  ASC-29320LP U320 w/HostRAID
+	8095  ASC-39320(B) U320 w/HostRAID
+	8096  ASC-39320A U320 w/HostRAID
+	8097  ASC-29320ALP U320 w/HostRAID
+	809c  ASC-39320D(B) U320 w/HostRAID
+	809d  AIC-7902(B) U320 w/HostRAID
+	809e  AIC-7901A U320 w/HostRAID
+	809f  AIC-7902 U320 w/HostRAID
+907f  Atronics
+	2015  IDE-2015PL
+919a  Gigapixel Corp
+9412  Holtek
+	6565  6565
+9699  Omni Media Technology Inc
+	6565  6565
+9710  NetMos Technology
+	7780  USB IRDA-port
+	9705  PCI 9705 Parallel Port
+	9715  PCI 9715 Dual Parallel Port
+	9735  PCI 9735 Multi-I/O Controller
+		1000 0002  0P2S (2 serial)
+		1000 0012  1P2S (1 parallel + 2 serial)
+	9745  PCI 9745 Multi-I/O Controller
+		1000 0002  0P2S (2 serial)
+		1000 0012  1P2S (1 parallel + 2 serial)
+	9755  PCI 9755 Parallel Port and ISA Bridge
+	9805  PCI 9805 Parallel Port
+	9815  PCI 9815 Dual Parallel Port
+		1000 0020  2P0S (2 port parallel adaptor)
+	9835  PCI 9835 Multi-I/O Controller
+		1000 0002  0P2S (16C550 UART)
+		1000 0012  1P2S
+	9845  PCI 9845 Multi-I/O Controller
+		1000 0004  0P4S (4 port 16550A serial card)
+		1000 0006  0P6S (6 port 16550A serial card)
+		1000 0014  1P4S (4 port 16550A serial card + parallel)
+	9855  PCI 9855 Multi-I/O Controller
+		1000 0014  1P4S
+9902  Stargen Inc.
+	0001  SG2010 PCI over Starfabric Bridge
+	0002  SG2010 PCI to Starfabric Gateway
+	0003  SG1010 Starfabric Switch and PCI Bridge
+a0a0  AOPEN Inc.
+a0f1  UNISYS Corporation
+a200  NEC Corporation
+a259  Hewlett Packard
+a25b  Hewlett Packard GmbH PL24-MKT
+a304  Sony
+a727  3Com Corporation
+	0013  3CRPAG175 Wireless PC Card
+aa42  Scitex Digital Video
+ac1e  Digital Receiver Technology Inc
+ac3d  Actuality Systems
+aecb  Adrienne Electronics Corporation
+b1b3  Shiva Europe Limited
+# Pinnacle should be 11bd, but they got it wrong several times --mj
+bd11  Pinnacle Systems, Inc. (Wrong ID)
+c001  TSI Telsys
+c0a9  Micron/Crucial Technology
+c0de  Motorola
+c0fe  Motion Engineering, Inc.
+ca50  Varian Australia Pty Ltd
+cafe  Chrysalis-ITS
+cccc  Catapult Communications
+cddd  Tyzx, Inc.
+	0101  DeepSea 1 High Speed Stereo Vision Frame Grabber
+	0200  DeepSea 2 High Speed Stereo Vision Frame Grabber
+d4d4  Dy4 Systems Inc
+	0601  PCI Mezzanine Card
+d531  I+ME ACTIA GmbH
+d84d  Exsys
+dead  Indigita Corporation
+deaf  Middle Digital Inc.
+	9050  PC Weasel Virtual VGA
+	9051  PC Weasel Serial Port
+	9052  PC Weasel Watchdog Timer
+e000  Winbond
+	e000  W89C940
+# see also : http://www.schoenfeld.de/inside/Inside_CWMK3.txt maybe a misuse of TJN id or it use the TJN 3XX chip for other applic
+e159  Tiger Jet Network Inc.
+	0001  Tiger3XX Modem/ISDN interface
+		0059 0001  128k ISDN-S/T Adapter
+		0059 0003  128k ISDN-U Adapter
+	0002  Tiger100APC ISDN chipset
+e4bf  EKF Elektronik GmbH
+# Innovative and scalable network IC vendor
+e55e  Essence Technology, Inc.
+ea01  Eagle Technology
+# The main chip of all these devices is by Xilinx -> It could also be a Xilinx ID.
+ea60  RME
+	9896  Digi32
+	9897  Digi32 Pro
+	9898  Digi32/8
+eabb  Aashima Technology B.V.
+eace  Endace Measurement Systems, Ltd
+	3100  DAG 3.10 OC-3/OC-12
+	3200  DAG 3.2x OC-3/OC-12
+	320e  DAG 3.2E Fast Ethernet
+	340e  DAG 3.4E Fast Ethernet
+	341e  DAG 3.41E Fast Ethernet
+	3500  DAG 3.5 OC-3/OC-12
+	351c  DAG 3.5ECM Fast Ethernet
+	4100  DAG 4.10 OC-48
+	4110  DAG 4.11 OC-48
+	4220  DAG 4.2 OC-48
+	422e  DAG 4.2E Dual Gigabit Ethernet
+ec80  Belkin Corporation
+	ec00  F5D6000
+ecc0  Echo Digital Audio Corporation
+edd8  ARK Logic Inc
+	a091  1000PV [Stingray]
+	a099  2000PV [Stingray]
+	a0a1  2000MT
+	a0a9  2000MI
+f1d0  AJA Video
+# All boards I have seen have this ID not efac, though all docs say efac...
+	cafe  KONA SD SMPTE 259M I/O
+	efac  KONA SD SMPTE 259M I/O
+	facd  KONA HD SMPTE 292M I/O
+fa57  Interagon AS
+	0001  PMC [Pattern Matching Chip]
+febd  Ultraview Corp.
+feda  Broadcom Inc (nee Epigram)
+	a0fa  BCM4210 iLine10 HomePNA 2.0
+	a10e  BCM4230 iLine10 HomePNA 2.0
+# IT & Telecom company, develops PCI Trunk cards <www.fedetec.es>
+fede  Fedetec Inc.
+	0003  TABIC PCI v3
+fffe  VMWare Inc
+	0405  Virtual SVGA 4.0
+	0710  Virtual SVGA
+ffff  Illegal Vendor ID
+
+
+# List of known device classes, subclasses and programming interfaces
+
+# Syntax:
+# C class	class_name
+#	subclass	subclass_name  		<-- single tab
+#		prog-if  prog-if_name  	<-- two tabs
+
+C 00  Unclassified device
+	00  Non-VGA unclassified device
+	01  VGA compatible unclassified device
+C 01  Mass storage controller
+	00  SCSI storage controller
+	01  IDE interface
+	02  Floppy disk controller
+	03  IPI bus controller
+	04  RAID bus controller
+	80  Unknown mass storage controller
+C 02  Network controller
+	00  Ethernet controller
+	01  Token ring network controller
+	02  FDDI network controller
+	03  ATM network controller
+	04  ISDN controller
+	80  Network controller
+C 03  Display controller
+	00  VGA compatible controller
+		00  VGA
+		01  8514
+	01  XGA compatible controller
+	02  3D controller
+	80  Display controller
+C 04  Multimedia controller
+	00  Multimedia video controller
+	01  Multimedia audio controller
+	02  Computer telephony device
+	80  Multimedia controller
+C 05  Memory controller
+	00  RAM memory
+	01  FLASH memory
+	80  Memory controller
+C 06  Bridge
+	00  Host bridge
+	01  ISA bridge
+	02  EISA bridge
+	03  MicroChannel bridge
+	04  PCI bridge
+		00  Normal decode
+		01  Subtractive decode
+	05  PCMCIA bridge
+	06  NuBus bridge
+	07  CardBus bridge
+	08  RACEway bridge
+		00  Transparent mode
+		01  Endpoint mode
+	09  Semi-transparent PCI-to-PCI bridge
+		40  Primary bus towards host CPU
+		80  Secondary bus towards host CPU
+	0a  InfiniBand to PCI host bridge
+	80  Bridge
+C 07  Communication controller
+	00  Serial controller
+		00  8250
+		01  16450
+		02  16550
+		03  16650
+		04  16750
+		05  16850
+		06  16950
+	01  Parallel controller
+		00  SPP
+		01  BiDir
+		02  ECP
+		03  IEEE1284
+		fe  IEEE1284 Target
+	02  Multiport serial controller
+	03  Modem
+		00  Generic
+		01  Hayes/16450
+		02  Hayes/16550
+		03  Hayes/16650
+		04  Hayes/16750
+	80  Communication controller
+C 08  Generic system peripheral
+	00  PIC
+		00  8259
+		01  ISA PIC
+		02  EISA PIC
+		10  IO-APIC
+		20  IO(X)-APIC
+	01  DMA controller
+		00  8237
+		01  ISA DMA
+		02  EISA DMA
+	02  Timer
+		00  8254
+		01  ISA Timer
+		02  EISA Timers
+	03  RTC
+		00  Generic
+		01  ISA RTC
+	04  PCI Hot-plug controller
+	80  System peripheral
+C 09  Input device controller
+	00  Keyboard controller
+	01  Digitizer Pen
+	02  Mouse controller
+	03  Scanner controller
+	04  Gameport controller
+		00  Generic
+		10  Extended
+	80  Input device controller
+C 0a  Docking station
+	00  Generic Docking Station
+	80  Docking Station
+C 0b  Processor
+	00  386
+	01  486
+	02  Pentium
+	10  Alpha
+	20  Power PC
+	30  MIPS
+	40  Co-processor
+C 0c  Serial bus controller
+	00  FireWire (IEEE 1394)
+		00  Generic
+		10  OHCI
+	01  ACCESS Bus
+	02  SSA
+	03  USB Controller
+		00  UHCI
+		10  OHCI
+		20  EHCI
+		80  Unspecified
+		fe  USB Device
+	04  Fibre Channel
+	05  SMBus
+	06  InfiniBand
+C 0d  Wireless controller
+	00  IRDA controller
+	01  Consumer IR controller
+	10  RF controller
+	80  Wireless controller
+C 0e  Intelligent controller
+	00  I2O
+C 0f  Satellite communications controller
+	00  Satellite TV controller
+	01  Satellite audio communication controller
+	03  Satellite voice communication controller
+	04  Satellite data communication controller
+C 10  Encryption controller
+	00  Network and computing encryption device
+	10  Entertainment encryption device
+	80  Encryption controller
+C 11  Signal processing controller
+	00  DPIO module
+	01  Performance counters
+	10  Communication synchronizer
+	80  Signal processing controller
diff -Naur linux-2.6.14/drivers/pcmcia/au1000_db1x00.c linux-mips-2.6.14.orig/drivers/pcmcia/au1000_db1x00.c
--- linux-2.6.14/drivers/pcmcia/au1000_db1x00.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/au1000_db1x00.c	2005-11-17 11:43:24.000000000 -0800
@@ -30,6 +30,7 @@
  *
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -40,7 +41,15 @@
 #include <asm/irq.h>
 #include <asm/signal.h>
 #include <asm/mach-au1x00/au1000.h>
-#include <asm/mach-db1x00/db1x00.h>
+
+#if defined(CONFIG_MIPS_DB1200)
+	#include <db1200.h>
+#elif defined(CONFIG_MIPS_PB1200)
+	#include <pb1200.h>
+#else
+	#include <asm/mach-db1x00/db1x00.h>
+	static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+#endif
 
 #include "au1000_generic.h"
 
@@ -50,7 +59,6 @@
 #define debug(x,args...)
 #endif
 
-static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 
 struct au1000_pcmcia_socket au1000_pcmcia_socket[PCMCIA_NUM_SOCKS];
 extern int au1x00_pcmcia_socket_probe(struct device *, struct pcmcia_low_level *, int, int);
@@ -59,6 +67,8 @@
 {
 #ifdef CONFIG_MIPS_DB1550
 	skt->irq = skt->nr ? AU1000_GPIO_5 : AU1000_GPIO_3;
+#elif defined(CONFIG_MIPS_DB1200) || defined(CONFIG_MIPS_PB1200)
+	skt->irq = skt->nr ? BOARD_PC1_INT : BOARD_PC0_INT;
 #else
 	skt->irq = skt->nr ? AU1000_GPIO_5 : AU1000_GPIO_2;
 #endif
@@ -85,11 +95,19 @@
 	switch (skt->nr) {
 	case 0:
 		vs = bcsr->status & 0x3;
+#if defined(CONFIG_MIPS_DB1200) || defined(CONFIG_MIPS_PB1200)
+		inserted = BOARD_CARD_INSERTED(0);
+#else
 		inserted = !(bcsr->status & (1<<4));
+#endif
 		break;
 	case 1:
 		vs = (bcsr->status & 0xC)>>2;
+#if defined(CONFIG_MIPS_DB1200) || defined(CONFIG_MIPS_PB1200) 
+		inserted = BOARD_CARD_INSERTED(1);
+#else
 		inserted = !(bcsr->status & (1<<5));
+#endif
 		break;
 	default:/* should never happen */
 		return;
diff -Naur linux-2.6.14/drivers/pcmcia/au1000_generic.c linux-mips-2.6.14.orig/drivers/pcmcia/au1000_generic.c
--- linux-2.6.14/drivers/pcmcia/au1000_generic.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/au1000_generic.c	2005-11-17 11:43:24.000000000 -0800
@@ -390,6 +390,7 @@
 
 		skt->socket.resource_ops = &pccard_static_ops;
 		skt->socket.ops = &au1x00_pcmcia_operations;
+		skt->socket.resource_ops = &pccard_static_ops;
 		skt->socket.owner = ops->owner;
 		skt->socket.dev.dev = dev;
 
@@ -490,7 +491,7 @@
 		flush_scheduled_work();
 		skt->ops->hw_shutdown(skt);
 		au1x00_pcmcia_config_skt(skt, &dead_socket);
-		iounmap(skt->virt_io);
+		iounmap(skt->virt_io + (u32)mips_io_port_base);
 		skt->virt_io = NULL;
 	}
 
@@ -545,10 +546,6 @@
 	.resume		= au1x00_drv_pcmcia_resume
 };
 
-static struct platform_device au1x00_device = {
-	.name = "au1x00-pcmcia",
-	.id = 0,
-};
 
 /* au1x00_pcmcia_init()
  *
@@ -562,7 +559,6 @@
 	int error = 0;
 	if ((error = driver_register(&au1x00_pcmcia_driver)))
 		return error;
-	platform_device_register(&au1x00_device);
 	return error;
 }
 
@@ -573,7 +569,6 @@
 static void __exit au1x00_pcmcia_exit(void)
 {
 	driver_unregister(&au1x00_pcmcia_driver);
-	platform_device_unregister(&au1x00_device);
 }
 
 module_init(au1x00_pcmcia_init);
diff -Naur linux-2.6.14/drivers/pcmcia/au1000_generic.h linux-mips-2.6.14.orig/drivers/pcmcia/au1000_generic.h
--- linux-2.6.14/drivers/pcmcia/au1000_generic.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/au1000_generic.h	2005-11-17 11:43:24.000000000 -0800
@@ -22,6 +22,8 @@
 #define __ASM_AU1000_PCMCIA_H
 
 /* include the world */
+#include <linux/config.h>
+
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/ss.h>
@@ -44,13 +46,13 @@
 /* pcmcia socket 1 needs external glue logic so the memory map
  * differs from board to board.
  */
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_PB1550)
+#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_PB1550) || defined(CONFIG_MIPS_PB1200)
 #define AU1X_SOCK1_IO        0xF08000000
 #define AU1X_SOCK1_PHYS_ATTR 0xF48000000
 #define AU1X_SOCK1_PHYS_MEM  0xF88000000
 #define AU1X_SOCK1_PSEUDO_PHYS_ATTR 0xF4800000
 #define AU1X_SOCK1_PSEUDO_PHYS_MEM  0xF8800000
-#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550)
+#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550) || defined(CONFIG_MIPS_DB1200)
 #define AU1X_SOCK1_IO        0xF04000000
 #define AU1X_SOCK1_PHYS_ATTR 0xF44000000
 #define AU1X_SOCK1_PHYS_MEM  0xF84000000
diff -Naur linux-2.6.14/drivers/pcmcia/au1000_pb1x00.c linux-mips-2.6.14.orig/drivers/pcmcia/au1000_pb1x00.c
--- linux-2.6.14/drivers/pcmcia/au1000_pb1x00.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/au1000_pb1x00.c	2005-11-17 11:43:24.000000000 -0800
@@ -21,6 +21,7 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
  */
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/delay.h>
diff -Naur linux-2.6.14/drivers/pcmcia/au1000_xxs1500.c linux-mips-2.6.14.orig/drivers/pcmcia/au1000_xxs1500.c
--- linux-2.6.14/drivers/pcmcia/au1000_xxs1500.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/au1000_xxs1500.c	2005-11-17 11:43:24.000000000 -0800
@@ -23,11 +23,10 @@
  *
  * ########################################################################
  *
- *
+ * 
  */
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/config.h>
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/kernel.h>
diff -Naur linux-2.6.14/drivers/pcmcia/Makefile linux-mips-2.6.14.orig/drivers/pcmcia/Makefile
--- linux-2.6.14/drivers/pcmcia/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/Makefile	2005-11-17 11:43:24.000000000 -0800
@@ -42,12 +42,14 @@
 au1x00_ss-y					+= au1000_generic.o
 au1x00_ss-$(CONFIG_MIPS_PB1000)			+= au1000_pb1x00.o
 au1x00_ss-$(CONFIG_MIPS_PB1100)			+= au1000_pb1x00.o
+au1x00_ss-$(CONFIG_MIPS_PB1200)			+= au1000_db1x00.o
 au1x00_ss-$(CONFIG_MIPS_PB1500)			+= au1000_pb1x00.o
 au1x00_ss-$(CONFIG_MIPS_DB1000)			+= au1000_db1x00.o
 au1x00_ss-$(CONFIG_MIPS_DB1100)			+= au1000_db1x00.o
+au1x00_ss-$(CONFIG_MIPS_DB1200)                 += au1000_db1x00.o
 au1x00_ss-$(CONFIG_MIPS_DB1500)			+= au1000_db1x00.o
 au1x00_ss-$(CONFIG_MIPS_DB1550)			+= au1000_db1x00.o
-au1x00_ss-$(CONFIG_MIPS_XXS1500)               += au1000_xxs1500.o
+au1x00_ss-$(CONFIG_MIPS_XXS1500)	 	+= au1000_xxs1500.o
 
 sa1111_cs-y					+= sa1111_generic.o
 sa1111_cs-$(CONFIG_ASSABET_NEPONSET)		+= sa1100_neponset.o
diff -Naur linux-2.6.14/drivers/pcmcia/vrc4171_card.c linux-mips-2.6.14.orig/drivers/pcmcia/vrc4171_card.c
--- linux-2.6.14/drivers/pcmcia/vrc4171_card.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/vrc4171_card.c	2005-11-17 11:43:24.000000000 -0800
@@ -1,7 +1,7 @@
 /*
  * vrc4171_card.c, NEC VRC4171 Card Controller driver for Socket Services.
  *
- * Copyright (C) 2003-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ * Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -26,6 +26,7 @@
 #include <linux/types.h>
 
 #include <asm/io.h>
+#include <asm/vr41xx/vrc4171.h>
 
 #include <pcmcia/ss.h>
 
@@ -47,6 +48,7 @@
 
 #define CARD_CONTROLLER_INDEX	0x03e0
 #define CARD_CONTROLLER_DATA	0x03e1
+#define CARD_CONTROLLER_SIZE	2
  /* Power register */
   #define VPP_GET_VCC		0x01
   #define POWER_ENABLE		0x10
@@ -67,40 +69,18 @@
   #define IRQPM_EN		0x08
   #define CLRPMIRQ		0x10
 
-#define INTERRUPT_STATUS	0x05fa
- #define IRQ_A			0x02
- #define IRQ_B			0x04
-
-#define CONFIGURATION1		0x05fe
- #define SLOTB_CONFIG		0xc000
- #define SLOTB_NONE		0x0000
- #define SLOTB_PCCARD		0x4000
- #define SLOTB_CF		0x8000
- #define SLOTB_FLASHROM		0xc000
-
-#define CARD_CONTROLLER_START	CARD_CONTROLLER_INDEX
-#define CARD_CONTROLLER_END	CARD_CONTROLLER_DATA
-
 #define IO_MAX_MAPS	2
 #define MEM_MAX_MAPS	5
 
-typedef enum {
+enum {
 	SLOT_PROBE = 0,
 	SLOT_NOPROBE_IO,
 	SLOT_NOPROBE_MEM,
-	SLOT_NOPROBE_ALL,
-	SLOT_INITIALIZED,
-} vrc4171_slot_t;
-
-typedef enum {
-	SLOTB_IS_NONE,
-	SLOTB_IS_PCCARD,
-	SLOTB_IS_CF,
-	SLOTB_IS_FLASHROM,
-} vrc4171_slotb_t;
+	SLOT_NOPROBE_ALL
+};
 
 typedef struct vrc4171_socket {
-	vrc4171_slot_t slot;
+	int noprobe;
 	struct pcmcia_socket pcmcia_socket;
 	char name[24];
 	int csc_irq;
@@ -108,65 +88,10 @@
 } vrc4171_socket_t;
 
 static vrc4171_socket_t vrc4171_sockets[CARD_MAX_SLOTS];
-static vrc4171_slotb_t vrc4171_slotb = SLOTB_IS_NONE;
-static char vrc4171_card_name[] = "NEC VRC4171 Card Controller";
+static int vrc4171_slotb = SLOTB_IS_NONE;
 static unsigned int vrc4171_irq;
 static uint16_t vrc4171_irq_mask = 0xdeb8;
 
-static struct resource vrc4171_card_resource[3] = {
-	{	.name		= vrc4171_card_name,
-		.start		= CARD_CONTROLLER_START,
-		.end		= CARD_CONTROLLER_END,
-		.flags		= IORESOURCE_IO,	},
-	{	.name		= vrc4171_card_name,
-		.start		= INTERRUPT_STATUS,
-		.end		= INTERRUPT_STATUS,
-		.flags		= IORESOURCE_IO,	},
-	{	.name		= vrc4171_card_name,
-		.start		= CONFIGURATION1,
-		.end		= CONFIGURATION1,
-		.flags		= IORESOURCE_IO,	},
-};
-
-static struct platform_device vrc4171_card_device = {
-	.name		= vrc4171_card_name,
-	.id		= 0,
-	.num_resources	= 3,
-	.resource	= vrc4171_card_resource,
-};
-
-static inline uint16_t vrc4171_get_irq_status(void)
-{
-	return inw(INTERRUPT_STATUS);
-}
-
-static inline void vrc4171_set_multifunction_pin(vrc4171_slotb_t config)
-{
-	uint16_t config1;
-
-	config1 = inw(CONFIGURATION1);
-	config1 &= ~SLOTB_CONFIG;
-
-	switch (config) {
-	case SLOTB_IS_NONE:
-		config1 |= SLOTB_NONE;
-		break;
-	case SLOTB_IS_PCCARD:
-		config1 |= SLOTB_PCCARD;
-		break;
-	case SLOTB_IS_CF:
-		config1 |= SLOTB_CF;
-		break;
-	case SLOTB_IS_FLASHROM:
-		config1 |= SLOTB_FLASHROM;
-		break;
-	default:
-		break;
-	}
-
-	outw(config1, CONFIGURATION1);
-}
-
 static inline uint8_t exca_read_byte(int slot, uint8_t index)
 {
 	if (slot == CARD_SLOTB)
@@ -356,9 +281,9 @@
 		if (cscint & I365_CSC_STSCHG)
 			state->flags |= SS_STSCHG;
 	} else {
-		if (cscint & I365_CSC_BVD1)
+		if (cscint & I365_CSC_BVD1)  
 			state->csc_mask |= SS_BATDEAD;
-		if (cscint & I365_CSC_BVD2)
+		if (cscint & I365_CSC_BVD2)  
 			state->csc_mask |= SS_BATWARN;
 	}
 	if (cscint & I365_CSC_READY)
@@ -495,9 +420,9 @@
 
 	if (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||
 	    mem == NULL || mem->map >= MEM_MAX_MAPS ||
-	    mem->res->start < CARD_MEM_START || mem->res->start > CARD_MEM_END ||
-	    mem->res->end < CARD_MEM_START || mem->res->end > CARD_MEM_END ||
-	    mem->res->start > mem->res->end ||
+	    mem->sys_start < CARD_MEM_START || mem->sys_start > CARD_MEM_END ||
+	    mem->sys_stop < CARD_MEM_START || mem->sys_stop > CARD_MEM_END ||
+	    mem->sys_start > mem->sys_stop ||
 	    mem->card_start > CARD_MAX_MEM_OFFSET ||
 	    mem->speed > CARD_MAX_MEM_SPEED)
 		return -EINVAL;
@@ -511,12 +436,12 @@
 		exca_write_byte(slot, I365_ADDRWIN, addrwin);
 	}
 
-	start = (mem->res->start >> 12) & 0x3fff;
+	start = (mem->sys_start >> 12) & 0x3fff;
 	if (mem->flags & MAP_16BIT)
 		start |= I365_MEM_16BIT;
 	exca_write_word(slot, I365_MEM(map)+I365_W_START, start);
 
-	stop = (mem->res->end >> 12) & 0x3fff;
+	stop = (mem->sys_stop >> 12) & 0x3fff;
 	switch (mem->speed) {
 	case 0:
 		break;
@@ -593,7 +518,7 @@
 	status = vrc4171_get_irq_status();
 	if (status & IRQ_A) {
 		socket = &vrc4171_sockets[CARD_SLOTA];
-		if (socket->slot == SLOT_INITIALIZED) {
+		if (socket->noprobe == SLOT_PROBE) {
 			if (status & (1 << socket->csc_irq)) {
 				events = get_events(CARD_SLOTA);
 				if (events != 0) {
@@ -606,7 +531,7 @@
 
 	if (status & IRQ_B) {
 		socket = &vrc4171_sockets[CARD_SLOTB];
-		if (socket->slot == SLOT_INITIALIZED) {
+		if (socket->noprobe == SLOT_PROBE) {
 			if (status & (1 << socket->csc_irq)) {
 				events = get_events(CARD_SLOTB);
 				if (events != 0) {
@@ -633,71 +558,63 @@
 	vrc4171_irq_mask &= ~(1 << irq);
 }
 
-static int __devinit vrc4171_add_sockets(void)
+static int __devinit vrc4171_add_socket(int slot)
 {
 	vrc4171_socket_t *socket;
-	int slot, retval;
+	int retval;
 
-	for (slot = 0; slot < CARD_MAX_SLOTS; slot++) {
-		if (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)
-			continue;
+	if (slot >= CARD_MAX_SLOTS)
+		return -EINVAL;
 
-		socket = &vrc4171_sockets[slot];
-		if (socket->slot != SLOT_PROBE) {
-			uint8_t addrwin;
-
-			switch (socket->slot) {
-			case SLOT_NOPROBE_MEM:
-				addrwin = exca_read_byte(slot, I365_ADDRWIN);
-				addrwin &= 0x1f;
-				exca_write_byte(slot, I365_ADDRWIN, addrwin);
-				break;
-			case SLOT_NOPROBE_IO:
-				addrwin = exca_read_byte(slot, I365_ADDRWIN);
-				addrwin &= 0xc0;
-				exca_write_byte(slot, I365_ADDRWIN, addrwin);
-				break;
-			default:
-				break;
-			}
+	socket = &vrc4171_sockets[slot];
+	if (socket->noprobe != SLOT_PROBE) {
+		uint8_t addrwin;
 
-			reserve_using_irq(slot);
-			continue;
+		switch (socket->noprobe) {
+		case SLOT_NOPROBE_MEM:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0x1f;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		case SLOT_NOPROBE_IO:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0xc0;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		default:
+			break;
 		}
 
-		sprintf(socket->name, "NEC VRC4171 Card Slot %1c", 'A' + slot);
-		socket->pcmcia_socket.dev.dev = &vrc4171_card_device.dev;
-		socket->pcmcia_socket.ops = &vrc4171_pccard_operations;
-		socket->pcmcia_socket.owner = THIS_MODULE;
+		reserve_using_irq(slot);
 
-		retval = pcmcia_register_socket(&socket->pcmcia_socket);
-		if (retval < 0)
-			return retval;
+		return 0;
+	}
 
-		exca_write_byte(slot, I365_ADDRWIN, 0);
-		exca_write_byte(slot, GLOBAL_CONTROL, 0);
+	sprintf(socket->name, "NEC VRC4171 Card Slot %1c", 'A' + slot);
 
-		socket->slot = SLOT_INITIALIZED;
-	}
+	socket->pcmcia_socket.ops = &vrc4171_pccard_operations;
+
+	retval = pcmcia_register_socket(&socket->pcmcia_socket);
+	if (retval != 0)
+		return retval;
+
+	exca_write_byte(slot, I365_ADDRWIN, 0);
+
+	exca_write_byte(slot, GLOBAL_CONTROL, 0);
 
 	return 0;
 }
 
-static void vrc4171_remove_sockets(void)
+static void vrc4171_remove_socket(int slot)
 {
 	vrc4171_socket_t *socket;
-	int slot;
 
-	for (slot = 0; slot < CARD_MAX_SLOTS; slot++) {
-		if (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)
-			continue;
+	if (slot >= CARD_MAX_SLOTS)
+		return;
 
-		socket = &vrc4171_sockets[slot];
-		if (socket->slot == SLOT_INITIALIZED)
-			pcmcia_unregister_socket(&socket->pcmcia_socket);
+	socket = &vrc4171_sockets[slot];
 
-		socket->slot = SLOT_PROBE;
-	}
+	pcmcia_unregister_socket(&socket->pcmcia_socket);
 }
 
 static int __devinit vrc4171_card_setup(char *options)
@@ -721,13 +638,13 @@
 		options += 6;
 		if (*options != '\0') {
 			if (strncmp(options, "memnoprobe", 10) == 0) {
-				vrc4171_sockets[CARD_SLOTA].slot = SLOT_NOPROBE_MEM;
+				vrc4171_sockets[CARD_SLOTA].noprobe = SLOT_NOPROBE_MEM;
 				options += 10;
 			} else if (strncmp(options, "ionoprobe", 9) == 0) {
-				vrc4171_sockets[CARD_SLOTA].slot = SLOT_NOPROBE_IO;
+				vrc4171_sockets[CARD_SLOTA].noprobe = SLOT_NOPROBE_IO;
 				options += 9;
 			} else if ( strncmp(options, "noprobe", 7) == 0) {
-				vrc4171_sockets[CARD_SLOTA].slot = SLOT_NOPROBE_ALL;
+				vrc4171_sockets[CARD_SLOTA].noprobe = SLOT_NOPROBE_ALL;
 				options += 7;
 			}
 
@@ -761,11 +678,11 @@
 			options++;
 
 			if (strncmp(options, "memnoprobe", 10) == 0)
-				vrc4171_sockets[CARD_SLOTB].slot = SLOT_NOPROBE_MEM;
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOT_NOPROBE_MEM;
 			if (strncmp(options, "ionoprobe", 9) == 0)
-				vrc4171_sockets[CARD_SLOTB].slot = SLOT_NOPROBE_IO;
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOT_NOPROBE_IO;
 			if (strncmp(options, "noprobe", 7) == 0)
-				vrc4171_sockets[CARD_SLOTB].slot = SLOT_NOPROBE_ALL;
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOT_NOPROBE_ALL;
 		}
 	}
 
@@ -774,72 +691,47 @@
 
 __setup("vrc4171_card=", vrc4171_card_setup);
 
-static int vrc4171_card_suspend(struct device *dev, pm_message_t state, u32 level)
-{
-	int retval = 0;
-
-	if (level == SUSPEND_SAVE_STATE)
-		retval = pcmcia_socket_dev_suspend(dev, state);
-
-	return retval;
-}
-
-static int vrc4171_card_resume(struct device *dev, u32 level)
-{
-	int retval = 0;
-
-	if (level == RESUME_RESTORE_STATE)
-		retval = pcmcia_socket_dev_resume(dev);
-
-	return retval;
-}
-
-static struct device_driver vrc4171_card_driver = {
-	.name		= vrc4171_card_name,
-	.bus		= &platform_bus_type,
-	.suspend	= vrc4171_card_suspend,
-	.resume		= vrc4171_card_resume,
-};
-
 static int __devinit vrc4171_card_init(void)
 {
-	int retval;
+	int retval, slot;
 
-	retval = driver_register(&vrc4171_card_driver);
-	if (retval < 0)
-		return retval;
+	vrc4171_set_multifunction_pin(vrc4171_slotb);
 
-	retval = platform_device_register(&vrc4171_card_device);
-	if (retval < 0) {
-		driver_unregister(&vrc4171_card_driver);
-		return retval;
-	}
+	if (request_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE,
+	                       "NEC VRC4171 Card Controller") == NULL)
+		return -EBUSY;
 
-	vrc4171_set_multifunction_pin(vrc4171_slotb);
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++) {
+		if (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)
+			break;
 
-	retval = vrc4171_add_sockets();
-	if (retval == 0)
-		retval = request_irq(vrc4171_irq, pccard_interrupt, SA_SHIRQ,
-		                     vrc4171_card_name, vrc4171_sockets);
+		retval = vrc4171_add_socket(slot);
+		if (retval != 0)
+			return retval;
+	}
 
+	retval = request_irq(vrc4171_irq, pccard_interrupt, SA_SHIRQ,
+	                     "NEC VRC4171 Card Controller", vrc4171_sockets);
 	if (retval < 0) {
-		vrc4171_remove_sockets();
-		platform_device_unregister(&vrc4171_card_device);
-		driver_unregister(&vrc4171_card_driver);
+		for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+			vrc4171_remove_socket(slot);
+
 		return retval;
 	}
 
-	printk(KERN_INFO "%s, connected to IRQ %d\n", vrc4171_card_driver.name, vrc4171_irq);
+	printk(KERN_INFO "NEC VRC4171 Card Controller, connected to IRQ %d\n", vrc4171_irq);
 
 	return 0;
 }
 
 static void __devexit vrc4171_card_exit(void)
 {
-	free_irq(vrc4171_irq, vrc4171_sockets);
-	vrc4171_remove_sockets();
-	platform_device_unregister(&vrc4171_card_device);
-	driver_unregister(&vrc4171_card_driver);
+	int slot;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+		vrc4171_remove_socket(slot);
+
+	release_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE);
 }
 
 module_init(vrc4171_card_init);
diff -Naur linux-2.6.14/drivers/pcmcia/vrc4173_cardu.c linux-mips-2.6.14.orig/drivers/pcmcia/vrc4173_cardu.c
--- linux-2.6.14/drivers/pcmcia/vrc4173_cardu.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/pcmcia/vrc4173_cardu.c	2005-11-17 11:43:24.000000000 -0800
@@ -614,4 +614,3 @@
 
 module_init(vrc4173_cardu_init);
 module_exit(vrc4173_cardu_exit);
-MODULE_DEVICE_TABLE(pci, vrc4173_cardu_id_table);
diff -Naur linux-2.6.14/drivers/scsi/dec_esp.c linux-mips-2.6.14.orig/drivers/scsi/dec_esp.c
--- linux-2.6.14/drivers/scsi/dec_esp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/dec_esp.c	2005-11-17 11:43:36.000000000 -0800
@@ -18,7 +18,7 @@
  * 20001005	- Initialization fixes for 2.4.0-test9
  * 			  Florian Lohoff <flo@rfc822.org>
  *
- *	Copyright (C) 2002, 2003  Maciej W. Rozycki
+ *	Copyright (C) 2002, 2003, 2005  Maciej W. Rozycki
  */
 
 #include <linux/kernel.h>
@@ -41,6 +41,7 @@
 #include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/ioasic_ints.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/system.h>
 #include <asm/dec/tc.h>
 
 #define DEC_SCSI_SREG 0
@@ -54,7 +55,7 @@
 
 static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
 static void dma_drain(struct NCR_ESP *esp);
-static int  dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd *sp);
+static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd * sp);
 static void dma_dump_state(struct NCR_ESP *esp);
 static void dma_init_read(struct NCR_ESP *esp, u32 vaddress, int length);
 static void dma_init_write(struct NCR_ESP *esp, u32 vaddress, int length);
@@ -63,9 +64,9 @@
 static int  dma_irq_p(struct NCR_ESP *esp);
 static int  dma_ports_p(struct NCR_ESP *esp);
 static void dma_setup(struct NCR_ESP *esp, u32 addr, int count, int write);
-static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp);
-static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, struct scsi_cmnd * sp);
-static void dma_advance_sg(struct scsi_cmnd * sp);
+static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp);
+static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, Scsi_Cmnd * sp);
+static void dma_advance_sg(Scsi_Cmnd * sp);
 
 static void pmaz_dma_drain(struct NCR_ESP *esp);
 static void pmaz_dma_init_read(struct NCR_ESP *esp, u32 vaddress, int length);
@@ -73,7 +74,7 @@
 static void pmaz_dma_ints_off(struct NCR_ESP *esp);
 static void pmaz_dma_ints_on(struct NCR_ESP *esp);
 static void pmaz_dma_setup(struct NCR_ESP *esp, u32 addr, int count, int write);
-static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp);
+static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp);
 
 #define TC_ESP_RAM_SIZE 0x20000
 #define ESP_TGT_DMA_SIZE ((TC_ESP_RAM_SIZE/7) & ~(sizeof(int)-1))
@@ -97,7 +98,7 @@
 static irqreturn_t scsi_dma_err_int(int, void *, struct pt_regs *);
 static irqreturn_t scsi_dma_int(int, void *, struct pt_regs *);
 
-static int dec_esp_detect(struct scsi_host_template * tpnt);
+int dec_esp_detect(Scsi_Host_Template * tpnt);
 
 static int dec_esp_release(struct Scsi_Host *shost)
 {
@@ -109,9 +110,9 @@
 	return 0;
 }
 
-static struct scsi_host_template driver_template = {
+static Scsi_Host_Template driver_template = {
 	.proc_name		= "dec_esp",
-	.proc_info		= esp_proc_info,
+	.proc_info		= &esp_proc_info,
 	.name			= "NCR53C94",
 	.detect			= dec_esp_detect,
 	.slave_alloc		= esp_slave_alloc,
@@ -132,7 +133,7 @@
 #include "scsi_module.c"
 
 /***************************************************************** Detection */
-static int dec_esp_detect(Scsi_Host_Template * tpnt)
+int dec_esp_detect(Scsi_Host_Template * tpnt)
 {
 	struct NCR_ESP *esp;
 	struct ConfigDev *esp_dev;
@@ -183,7 +184,8 @@
 		esp->dregs = 0;
 
 		/* ESP register base */
-		esp->eregs = (struct ESP_regs *) (system_base + IOASIC_SCSI);
+		esp->eregs = (void *)CKSEG1ADDR(dec_kn_slot_base +
+						IOASIC_SCSI);
 
 		/* Set the command buffer */
 		esp->esp_command = (volatile unsigned char *) cmd_buffer;
@@ -228,10 +230,11 @@
 			mem_start = get_tc_base_addr(slot);
 
 			/* Store base addr into esp struct */
-			esp->slot = PHYSADDR(mem_start);
+			esp->slot = mem_start;
 
 			esp->dregs = 0;
-			esp->eregs = (struct ESP_regs *) (mem_start + DEC_SCSI_SREG);
+			esp->eregs = (void *)CKSEG1ADDR(mem_start +
+							DEC_SCSI_SREG);
 			esp->do_pio_cmds = 1;
 
 			/* Set the command buffer */
@@ -376,7 +379,7 @@
 	}
 }
 
-static int dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static int dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	return sp->SCp.this_residual;
 }
@@ -488,12 +491,12 @@
 		dma_init_write(esp, addr, count);
 }
 
-static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	sp->SCp.ptr = (char *)virt_to_phys(sp->request_buffer);
 }
 
-static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	int sz = sp->SCp.buffers_residual;
 	struct scatterlist *sg = sp->SCp.buffer;
@@ -505,7 +508,7 @@
 	sp->SCp.ptr = (char *)(sp->SCp.buffer->dma_address);
 }
 
-static void dma_advance_sg(struct scsi_cmnd * sp)
+static void dma_advance_sg(Scsi_Cmnd * sp)
 {
 	sp->SCp.ptr = (char *)(sp->SCp.buffer->dma_address);
 }
@@ -513,14 +516,15 @@
 static void pmaz_dma_drain(struct NCR_ESP *esp)
 {
 	memcpy(phys_to_virt(esp_virt_buffer),
-		(void *)KSEG1ADDR(esp->slot + DEC_SCSI_SRAM + ESP_TGT_DMA_SIZE),
-		scsi_current_length);
+	       (void *)CKSEG1ADDR(esp->slot + DEC_SCSI_SRAM +
+				  ESP_TGT_DMA_SIZE),
+	       scsi_current_length);
 }
 
 static void pmaz_dma_init_read(struct NCR_ESP *esp, u32 vaddress, int length)
 {
 	volatile u32 *dmareg =
-		(volatile u32 *)KSEG1ADDR(esp->slot + DEC_SCSI_DMAREG);
+		(volatile u32 *)CKSEG1ADDR(esp->slot + DEC_SCSI_DMAREG);
 
 	if (length > ESP_TGT_DMA_SIZE)
 		length = ESP_TGT_DMA_SIZE;
@@ -536,9 +540,10 @@
 static void pmaz_dma_init_write(struct NCR_ESP *esp, u32 vaddress, int length)
 {
 	volatile u32 *dmareg =
-		(volatile u32 *)KSEG1ADDR(esp->slot + DEC_SCSI_DMAREG);
+		(volatile u32 *)CKSEG1ADDR(esp->slot + DEC_SCSI_DMAREG);
 
-	memcpy((void *)KSEG1ADDR(esp->slot + DEC_SCSI_SRAM + ESP_TGT_DMA_SIZE),
+	memcpy((void *)CKSEG1ADDR(esp->slot + DEC_SCSI_SRAM +
+				  ESP_TGT_DMA_SIZE),
 	       phys_to_virt(vaddress), length);
 
 	wmb();
@@ -567,7 +572,7 @@
 		pmaz_dma_init_write(esp, addr, count);
 }
 
-static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	sp->SCp.ptr = (char *)virt_to_phys(sp->request_buffer);
 }
diff -Naur linux-2.6.14/drivers/scsi/jazz_esp.c linux-mips-2.6.14.orig/drivers/scsi/jazz_esp.c
--- linux-2.6.14/drivers/scsi/jazz_esp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/jazz_esp.c	2005-11-17 11:43:36.000000000 -0800
@@ -28,7 +28,7 @@
 #include <asm/pgtable.h>
 
 static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
-static int  dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd *sp);
+static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp);
 static void dma_dump_state(struct NCR_ESP *esp);
 static void dma_init_read(struct NCR_ESP *esp, __u32 vaddress, int length);
 static void dma_init_write(struct NCR_ESP *esp, __u32 vaddress, int length);
@@ -37,11 +37,11 @@
 static int  dma_irq_p(struct NCR_ESP *esp);
 static int  dma_ports_p(struct NCR_ESP *esp);
 static void dma_setup(struct NCR_ESP *esp, __u32 addr, int count, int write);
-static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_advance_sg (struct scsi_cmnd *sp);
+static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_advance_sg (Scsi_Cmnd *sp);
 static void dma_led_off(struct NCR_ESP *);
 static void dma_led_on(struct NCR_ESP *);
 
@@ -87,7 +87,7 @@
 #include "scsi_module.c"
 
 /***************************************************************** Detection */
-static int jazz_esp_detect(struct scsi_host_template *tpnt)
+int jazz_esp_detect(Scsi_Host_Template *tpnt)
 {
     struct NCR_ESP *esp;
     struct ConfigDev *esp_dev;
@@ -180,7 +180,7 @@
     return fifo_count;
 }
 
-static int dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static int dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     /*
      * maximum DMA size is 1MB
@@ -253,13 +253,13 @@
     }
 }
 
-static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     sp->SCp.have_data_in = vdma_alloc(CPHYSADDR(sp->SCp.buffer), sp->SCp.this_residual);
     sp->SCp.ptr = (char *)((unsigned long)sp->SCp.have_data_in);
 }
 
-static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     int sz = sp->SCp.buffers_residual;
     struct scatterlist *sg = (struct scatterlist *) sp->SCp.buffer;
@@ -271,12 +271,12 @@
     sp->SCp.ptr=(char *)(sp->SCp.buffer->dma_address);
 }    
 
-static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     vdma_free(sp->SCp.have_data_in);
 }
 
-static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     int sz = sp->use_sg - 1;
     struct scatterlist *sg = (struct scatterlist *)sp->buffer;
@@ -287,7 +287,7 @@
     }
 }
 
-static void dma_advance_sg (struct scsi_cmnd *sp)
+static void dma_advance_sg (Scsi_Cmnd *sp)
 {
     sp->SCp.ptr = (char *)(sp->SCp.buffer->dma_address);
 }
@@ -308,22 +308,3 @@
 #endif    
 }
 
-static struct scsi_host_template driver_template = {
-	.proc_name		= "jazz_esp",
-	.proc_info		= esp_proc_info,
-	.name			= "ESP 100/100a/200",
-	.detect			= jazz_esp_detect,
-	.slave_alloc		= esp_slave_alloc,
-	.slave_destroy		= esp_slave_destroy,
-	.release		= jazz_esp_release,
-	.info			= esp_info,
-	.queuecommand		= esp_queue,
-	.eh_abort_handler	= esp_abort,
-	.eh_bus_reset_handler	= esp_reset,
-	.can_queue		= 7,
-	.this_id		= 7,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
-	.use_clustering		= DISABLE_CLUSTERING,
-};
-#include "scsi_module.c"
diff -Naur linux-2.6.14/drivers/scsi/NCR53C9x.h linux-mips-2.6.14.orig/drivers/scsi/NCR53C9x.h
--- linux-2.6.14/drivers/scsi/NCR53C9x.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/NCR53C9x.h	2005-11-17 11:43:25.000000000 -0800
@@ -145,12 +145,7 @@
 
 #ifndef MULTIPLE_PAD_SIZES
 
-#ifdef CONFIG_CPU_HAS_WB
-#include <asm/wbflush.h>
-#define esp_write(__reg, __val) do{(__reg) = (__val); wbflush();} while(0)
-#else
-#define esp_write(__reg, __val) ((__reg) = (__val))
-#endif
+#define esp_write(__reg, __val) do{(__reg) = (__val); iob();} while(0)
 #define esp_read(__reg) (__reg)
 
 struct ESP_regs {
diff -Naur linux-2.6.14/drivers/scsi/qlogicisp.c linux-mips-2.6.14.orig/drivers/scsi/qlogicisp.c
--- linux-2.6.14/drivers/scsi/qlogicisp.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/qlogicisp.c	2005-11-17 11:43:38.000000000 -0800
@@ -192,14 +192,8 @@
 #define REQUEST_QUEUE_WAKEUP		0x8005
 #define EXECUTION_TIMEOUT_RESET		0x8006
 
-#ifdef CONFIG_QL_ISP_A64
-#define IOCB_SEGS                       2
-#define CONTINUATION_SEGS               5
-#define MAX_CONTINUATION_ENTRIES        254
-#else
 #define IOCB_SEGS                       4
 #define CONTINUATION_SEGS               7
-#endif /* CONFIG_QL_ISP_A64 */
 
 struct Entry_header {
 	u_char	entry_type;
@@ -209,13 +203,8 @@
 };
 
 /* entry header type commands */
-#ifdef CONFIG_QL_ISP_A64
-#define ENTRY_COMMAND           9
-#define ENTRY_CONTINUATION      0xa
-#else
 #define ENTRY_COMMAND		1
 #define ENTRY_CONTINUATION	2
-#endif /* CONFIG_QL_ISP_A64 */
 
 #define ENTRY_STATUS		3
 #define ENTRY_MARKER		4
@@ -229,9 +218,6 @@
 
 struct dataseg {
 	u_int			d_base;
-#ifdef CONFIG_QL_ISP_A64
-	u_int                   d_base_hi;
-#endif
 	u_int			d_count;
 };
 
@@ -246,10 +232,6 @@
 	u_short			time_out;
 	u_short			segment_cnt;
 	u_char			cdb[12];
-#ifdef CONFIG_QL_ISP_A64
-	u_int                   rsvd1;
-	u_int                   rsvd2;
-#endif
 	struct dataseg		dataseg[IOCB_SEGS];
 };
 
@@ -277,9 +259,7 @@
 
 struct Continuation_Entry {
 	struct Entry_header	hdr;
-#ifndef CONFIG_QL_ISP_A64
 	u_int			reserved;
-#endif
 	struct dataseg		dataseg[CONTINUATION_SEGS];
 };
 
@@ -424,11 +404,6 @@
 #define MBOX_WRITE_FOUR_RAM_WORDS	0x0041
 #define MBOX_EXEC_BIOS_IOCB		0x0042
 
-#ifdef CONFIG_QL_ISP_A64
-#define MBOX_CMD_INIT_REQUEST_QUEUE_64      0x0052
-#define MBOX_CMD_INIT_RESPONSE_QUEUE_64     0x0053
-#endif /* CONFIG_QL_ISP_A64 */
-
 #include "qlogicisp_asm.c"
 
 #define PACKB(a, b)			(((a)<<4)|(b))
@@ -501,25 +476,6 @@
 	PACKB(1, 2),	/* MBOX_RETURN_BIOS_BLOCK_ADDR */
 	PACKB(6, 1),	/* MBOX_WRITE_FOUR_RAM_WORDS */
 	PACKB(2, 3)	/* MBOX_EXEC_BIOS_IOCB */
-#ifdef CONFIG_QL_ISP_A64
-	,PACKB(0, 0),	/* 0x0043 */
-	PACKB(0, 0),	/* 0x0044 */
-	PACKB(0, 0),	/* 0x0045 */
-	PACKB(0, 0),	/* 0x0046 */
-	PACKB(0, 0),	/* 0x0047 */
-	PACKB(0, 0),	/* 0x0048 */
-	PACKB(0, 0),	/* 0x0049 */
-	PACKB(0, 0),	/* 0x004a */
-	PACKB(0, 0),	/* 0x004b */
-	PACKB(0, 0),	/* 0x004c */
-	PACKB(0, 0),	/* 0x004d */
-	PACKB(0, 0),	/* 0x004e */
-	PACKB(0, 0),	/* 0x004f */
-	PACKB(0, 0),	/* 0x0050 */
-	PACKB(0, 0),	/* 0x0051 */
-	PACKB(8, 8),	/* MBOX_CMD_INIT_REQUEST_QUEUE_64 (0x0052) */
-	PACKB(8, 8)	/* MBOX_CMD_INIT_RESPONSE_QUEUE_64 (0x0053) */
-#endif /* CONFIG_QL_ISP_A64 */
 };
 
 #define MAX_MBOX_COMMAND	(sizeof(mbox_param)/sizeof(u_short))
@@ -887,9 +843,6 @@
 		for (i = 0; i < n; i++) {
 			dma_addr = sg_dma_address(sg);
 			ds[i].d_base  = cpu_to_le32((u32) dma_addr);
-#ifdef CONFIG_QL_ISP_A64
-			ds[i].d_base_hi = cpu_to_le32((u32) (dma_addr>>32));
-#endif /* CONFIG_QL_ISP_A64 */
 			ds[i].d_count = cpu_to_le32(sg_dma_len(sg));
 			++sg;
 		}
@@ -910,9 +863,7 @@
 			cont->hdr.entry_cnt  = 0;
 			cont->hdr.sys_def_1  = 0;
 			cont->hdr.flags      = 0;
-#ifndef CONFIG_QL_ISP_A64
 			cont->reserved = 0;
-#endif
 			ds = cont->dataseg;
 			n = sg_count;
 			if (n > CONTINUATION_SEGS)
@@ -920,9 +871,6 @@
 			for (i = 0; i < n; ++i) {
 				dma_addr = sg_dma_address(sg);
 				ds[i].d_base = cpu_to_le32((u32) dma_addr);
-#ifdef CONFIG_QL_ISP_A64
-				ds[i].d_base_hi = cpu_to_le32((u32)(dma_addr>>32));
-#endif /* CONFIG_QL_ISP_A64 */
 				ds[i].d_count = cpu_to_le32(sg_dma_len(sg));
 				++sg;
 			}
@@ -938,18 +886,11 @@
 
 		cmd->dataseg[0].d_base =
 			cpu_to_le32((u32) dma_addr);
-#ifdef CONFIG_QL_ISP_A64
-		cmd->dataseg[0].d_base_hi =
-			cpu_to_le32((u32) (dma_addr>>32));
-#endif /* CONFIG_QL_ISP_A64 */
 		cmd->dataseg[0].d_count =
 			cpu_to_le32((u32)Cmnd->request_bufflen);
 		cmd->segment_cnt = cpu_to_le16(1);
 	} else {
 		cmd->dataseg[0].d_base = 0;
-#ifdef CONFIG_QL_ISP_A64
-		cmd->dataseg[0].d_base_hi = 0;
-#endif /* CONFIG_QL_ISP_A64 */
 		cmd->dataseg[0].d_count = 0;
 		cmd->segment_cnt = cpu_to_le16(1); /* Shouldn't this be 0? */
 	}
@@ -1069,11 +1010,7 @@
 				     Cmnd->sc_data_direction);
 		else if (Cmnd->request_bufflen)
 			pci_unmap_single(hostdata->pci_dev,
-#ifdef CONFIG_QL_ISP_A64
-					 (dma_addr_t)((long)Cmnd->SCp.ptr),
-#else
 					 (u32)((long)Cmnd->SCp.ptr),
-#endif
 					 Cmnd->request_bufflen,
 					 Cmnd->sc_data_direction);
 
@@ -1624,13 +1561,8 @@
 static int isp1020_load_parameters(struct Scsi_Host *host)
 {
 	int i, k;
-#ifdef CONFIG_QL_ISP_A64
-	u_long queue_addr;
-	u_short param[8];
-#else
 	u_int queue_addr;
 	u_short param[6];
-#endif
 	u_short isp_cfg1, hwrev;
 	struct isp1020_hostdata *hostdata =
 		(struct isp1020_hostdata *) host->hostdata;
@@ -1757,20 +1689,12 @@
 	}
 
 	queue_addr = hostdata->res_dma;
-#ifdef CONFIG_QL_ISP_A64
-	param[0] = MBOX_CMD_INIT_RESPONSE_QUEUE_64;
-#else
 	param[0] = MBOX_INIT_RES_QUEUE;
-#endif
 	param[1] = RES_QUEUE_LEN + 1;
 	param[2] = (u_short) (queue_addr >> 16);
 	param[3] = (u_short) (queue_addr & 0xffff);
 	param[4] = 0;
 	param[5] = 0;
-#ifdef CONFIG_QL_ISP_A64
-	param[6] = (u_short) (queue_addr >> 48);
-	param[7] = (u_short) (queue_addr >> 32);
-#endif
 
 	isp1020_mbox_command(host, param);
 
@@ -1780,22 +1704,12 @@
 	}
 
 	queue_addr = hostdata->req_dma;
-#ifdef CONFIG_QL_ISP_A64
-	param[0] = MBOX_CMD_INIT_REQUEST_QUEUE_64;
-#else
 	param[0] = MBOX_INIT_REQ_QUEUE;
-#endif
 	param[1] = QLOGICISP_REQ_QUEUE_LEN + 1;
 	param[2] = (u_short) (queue_addr >> 16);
 	param[3] = (u_short) (queue_addr & 0xffff);
 	param[4] = 0;
 
-#ifdef CONFIG_QL_ISP_A64
-	param[5] = 0;
-	param[6] = (u_short) (queue_addr >> 48);
-	param[7] = (u_short) (queue_addr >> 32);
-#endif
-
 	isp1020_mbox_command(host, param);
 
 	if (param[0] != MBOX_COMMAND_COMPLETE) {
diff -Naur linux-2.6.14/drivers/scsi/sgiwd93.c linux-mips-2.6.14.orig/drivers/scsi/sgiwd93.c
--- linux-2.6.14/drivers/scsi/sgiwd93.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/sgiwd93.c	2005-11-17 11:43:38.000000000 -0800
@@ -33,7 +33,6 @@
 #include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "wd33c93.h"
-#include "sgiwd93.h"
 
 #include <linux/stat.h>
 
@@ -335,10 +334,10 @@
 	.eh_abort_handler	= wd33c93_abort,
 	.eh_bus_reset_handler	= sgiwd93_bus_reset,
 	.eh_host_reset_handler	= wd33c93_host_reset,
-	.can_queue		= CAN_QUEUE,
+	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= CMD_PER_LUN,
+	.cmd_per_lun		= 8,
 	.use_clustering		= DISABLE_CLUSTERING,
 };
 #include "scsi_module.c"
diff -Naur linux-2.6.14/drivers/scsi/sgiwd93.h linux-mips-2.6.14.orig/drivers/scsi/sgiwd93.h
--- linux-2.6.14/drivers/scsi/sgiwd93.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/sgiwd93.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,24 +0,0 @@
-/* $Id: sgiwd93.h,v 1.5 1998/08/25 09:18:50 ralf Exp $
- * sgiwd93.h: SGI WD93 scsi definitions.
- *
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- */
-#ifndef _SGIWD93_H
-#define _SGIWD93_H
-
-#ifndef CMD_PER_LUN
-#define CMD_PER_LUN 8
-#endif
-
-#ifndef CAN_QUEUE
-#define CAN_QUEUE   16
-#endif
-
-int sgiwd93_detect(Scsi_Host_Template *);
-int sgiwd93_release(struct Scsi_Host *instance);
-const char *wd33c93_info(void);
-int wd33c93_queuecommand(Scsi_Cmnd *, void (*done)(Scsi_Cmnd *));
-int wd33c93_abort(Scsi_Cmnd *);
-int wd33c93_host_reset(Scsi_Cmnd * SCpnt);
-
-#endif /* !(_SGIWD93_H) */
diff -Naur linux-2.6.14/drivers/scsi/sym53c8xx_defs.h linux-mips-2.6.14.orig/drivers/scsi/sym53c8xx_defs.h
--- linux-2.6.14/drivers/scsi/sym53c8xx_defs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/scsi/sym53c8xx_defs.h	2005-11-17 11:43:38.000000000 -0800
@@ -314,9 +314,19 @@
 #define	writew_b2l	__raw_writew
 #define	writel_b2l	__raw_writel
 #define	readw_raw	__raw_readw
-#define	readl_raw	__raw_readl
+#define	readl_raw(a)	__raw_readl((unsigned long)(a))
 #define	writew_raw	__raw_writew
-#define	writel_raw	__raw_writel
+#define	writel_raw(v,a)	__raw_writel(v,(unsigned long)(a))
+#else /* Other big-endian */
+#elif defined(__mips__)
+#define readw_l2b	readw
+#define readl_l2b	readl
+#define writew_b2l	writew
+#define writel_b2l	writel
+#define inw_l2b 	inw
+#define inl_l2b 	inl
+#define outw_b2l	outw
+#define outl_b2l	outl
 #else	/* Other big-endian */
 #define	readw_l2b	readw
 #define	readl_l2b	readl
diff -Naur linux-2.6.14/drivers/serial/8250.c linux-mips-2.6.14.orig/drivers/serial/8250.c
--- linux-2.6.14/drivers/serial/8250.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/8250.c	2005-11-17 11:43:39.000000000 -0800
@@ -2141,8 +2141,10 @@
 	unsigned int ier;
 	int i;
 
+	spin_lock(&up->port.lock); 
+
 	/*
-	 *	First save the UER then disable the interrupts
+	 *	First save the IER then disable the interrupts
 	 */
 	ier = serial_in(up, UART_IER);
 
@@ -2174,6 +2176,8 @@
 	 */
 	wait_for_xmitr(up);
 	serial_out(up, UART_IER, ier);
+
+	spin_unlock(&up->port.lock);
 }
 
 static int serial8250_console_setup(struct console *co, char *options)
diff -Naur linux-2.6.14/drivers/serial/au1x00_uart.c linux-mips-2.6.14.orig/drivers/serial/au1x00_uart.c
--- linux-2.6.14/drivers/serial/au1x00_uart.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/au1x00_uart.c	2005-11-17 11:43:39.000000000 -0800
@@ -67,30 +67,7 @@
 #define is_real_interrupt(irq)	((irq) != 0)
 
 static struct old_serial_port old_serial_port[] = {
-	{	.baud_base = 0,
-		.iomem_base = (u8 *)UART0_ADDR,
-		.irq = AU1000_UART0_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2,
-	}, {
-		.baud_base = 0,
-		.iomem_base = (u8 *)UART1_ADDR,
-		.irq = AU1000_UART1_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2
-	}, {
-		.baud_base = 0,
-		.iomem_base = (u8 *)UART2_ADDR,
-		.irq = AU1000_UART2_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2
-	}, {
-		.baud_base = 0,
-		.iomem_base = (u8 *)UART3_ADDR,
-		.irq = AU1000_UART3_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2
-	}
+	SERIAL_PORT_DFNS
 };
 
 #define UART_NR	ARRAY_SIZE(old_serial_port)
@@ -194,7 +171,7 @@
 	(void)serial_in(up, UART_RX);
 	serial_outp(up, UART_IER, 0);
 
- out:	
+ out:
 	spin_unlock_irqrestore(&up->port.lock, flags);
 //	restore_flags(flags);
 	DEBUG_AUTOCONF("type=%s\n", uart_config[up->port.type].name);
@@ -798,9 +775,8 @@
 	/*
 	 * Ask the core to calculate the divisor for us.
 	 */
-	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
 	quot = serial8250_get_divisor(port, baud);
-	quot = 0x35; /* FIXME */
 
 	/*
 	 * Work around a bug in the Oxford Semiconductor 952 rev B
@@ -866,6 +842,7 @@
 
 	serial_out(up, UART_IER, up->ier);
 	serial_outp(up, 0x28, quot & 0xffff);
+	serial_out(up, UART_LCR, cval);			/* reset DLAB */
 	up->lcr = cval;					/* Save LCR */
 	if (up->port.type != PORT_16750) {
 		if (fcr & UART_FCR_ENABLE_FIFO) {
@@ -1068,7 +1045,7 @@
 	     i++, up++) {
 		up->port.iobase   = old_serial_port[i].port;
 		up->port.irq      = old_serial_port[i].irq;
-		up->port.uartclk  = get_au1x00_uart_baud_base();
+		up->port.uartclk  = get_au1x00_uart_baud_base() * 16;
 		up->port.flags    = old_serial_port[i].flags;
 		up->port.hub6     = old_serial_port[i].hub6;
 		up->port.membase  = old_serial_port[i].iomem_base;
@@ -1206,7 +1183,7 @@
 	return uart_set_options(port, co, baud, parity, bits, flow);
 }
 
-extern struct uart_driver serial8250_reg;
+static struct uart_driver serial8250_reg;
 static struct console serial8250_console = {
 	.name		= "ttyS",
 	.write		= serial8250_console_write,
diff -Naur linux-2.6.14/drivers/serial/dz.c linux-mips-2.6.14.orig/drivers/serial/dz.c
--- linux-2.6.14/drivers/serial/dz.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/dz.c	2005-11-17 11:43:39.000000000 -0800
@@ -1,9 +1,9 @@
 /*
- * dz.c: Serial port driver for DECStations equiped 
+ * dz.c: Serial port driver for DECStations equiped
  *       with the DZ chipset.
  *
- * Copyright (C) 1998 Olivier A. D. Lebaillif 
- *             
+ * Copyright (C) 1998 Olivier A. D. Lebaillif
+ *
  * Email: olivier.lebaillif@ifrsys.com
  *
  * [31-AUG-98] triemer
@@ -11,14 +11,14 @@
  * removed base_addr code - moving address assignment to setup.c
  * Changed name of dz_init to rs_init to be consistent with tc code
  * [13-NOV-98] triemer fixed code to receive characters
- *    after patches by harald to irq code.  
+ *    after patches by harald to irq code.
  * [09-JAN-99] triemer minor fix for schedule - due to removal of timeout
  *            field from "current" - somewhere between 2.1.121 and 2.1.131
  Qua Jun 27 15:02:26 BRT 2001
  * [27-JUN-2001] Arnaldo Carvalho de Melo <acme@conectiva.com.br> - cleanups
- *  
- * Parts (C) 1999 David Airlie, airlied@linux.ie 
- * [07-SEP-99] Bugfixes 
+ *
+ * Parts (C) 1999 David Airlie, airlied@linux.ie
+ * [07-SEP-99] Bugfixes
  *
  * [06-Jan-2002] Russell King <rmk@arm.linux.org.uk>
  * Converted to new serial core
@@ -64,7 +64,7 @@
 
 #ifdef DEBUG_DZ
 /*
- * debugging code to send out chars via prom 
+ * debugging code to send out chars via prom
  */
 static void debug_console(const char *s, int count)
 {
@@ -82,7 +82,7 @@
  * ------------------------------------------------------------
  * dz_in () and dz_out ()
  *
- * These routines are used to access the registers of the DZ 
+ * These routines are used to access the registers of the DZ
  * chip, hiding relocation differences between implementation.
  * ------------------------------------------------------------
  */
@@ -106,8 +106,8 @@
  * ------------------------------------------------------------
  * rs_stop () and rs_start ()
  *
- * These routines are called before setting or resetting 
- * tty->stopped. They enable or disable transmitter interrupts, 
+ * These routines are called before setting or resetting
+ * tty->stopped. They enable or disable transmitter interrupts,
  * as necessary.
  * ------------------------------------------------------------
  */
@@ -156,17 +156,17 @@
 
 /*
  * ------------------------------------------------------------
- * Here starts the interrupt handling routines.  All of the 
- * following subroutines are declared as inline and are folded 
- * into dz_interrupt.  They were separated out for readability's 
- * sake. 
+ * Here starts the interrupt handling routines.  All of the
+ * following subroutines are declared as inline and are folded
+ * into dz_interrupt.  They were separated out for readability's
+ * sake.
  *
  * Note: rs_interrupt() is a "fast" interrupt, which means that it
  * runs with interrupts turned off.  People who may want to modify
  * rs_interrupt() should try to keep the interrupt handler as fast as
  * possible.  After you are done making modifications, it is not a bad
  * idea to do:
- * 
+ *
  *	make drivers/serial/dz.s
  *
  * and look at the resulting assemble code in dz.s.
@@ -403,7 +403,7 @@
  * startup ()
  *
  * various initialization tasks
- * ------------------------------------------------------------------- 
+ * -------------------------------------------------------------------
  */
 static int dz_startup(struct uart_port *uport)
 {
@@ -430,13 +430,13 @@
 	return 0;
 }
 
-/* 
+/*
  * -------------------------------------------------------------------
  * shutdown ()
  *
  * This routine will shutdown a serial port; interrupts are disabled, and
  * DTR is dropped if the hangup on close termio flag is on.
- * ------------------------------------------------------------------- 
+ * -------------------------------------------------------------------
  */
 static void dz_shutdown(struct uart_port *uport)
 {
@@ -451,7 +451,7 @@
  *          release the bus after transmitting. This must be done when
  *          the transmit shift register is empty, not be done when the
  *          transmit holding register is empty.  This functionality
- *          allows an RS485 driver to be written in user space. 
+ *          allows an RS485 driver to be written in user space.
  */
 static unsigned int dz_tx_empty(struct uart_port *uport)
 {
@@ -645,9 +645,9 @@
 
 	if (mips_machtype == MACH_DS23100 ||
 	    mips_machtype == MACH_DS5100)
-		base = (unsigned long) KN01_DZ11_BASE;
+		base = CKSEG1ADDR(KN01_SLOT_BASE + KN01_DZ11);
 	else
-		base = (unsigned long) KN02_DZ11_BASE;
+		base = CKSEG1ADDR(KN02_SLOT_BASE + KN02_DZ11);
 
 	for (i = 0, dport = dz_ports; i < DZ_NB_PORT; i++, dport++) {
 		spin_lock_init(&dport->port.lock);
@@ -695,13 +695,13 @@
 
 	spin_unlock_irqrestore(&dport->port.lock, flags);
 }
-/* 
+/*
  * -------------------------------------------------------------------
  * dz_console_print ()
  *
  * dz_console_print is registered for printk.
  * The console must be locked when we get here.
- * ------------------------------------------------------------------- 
+ * -------------------------------------------------------------------
  */
 static void dz_console_print(struct console *cons,
 			     const char *str,
diff -Naur linux-2.6.14/drivers/serial/ip22zilog.c linux-mips-2.6.14.orig/drivers/serial/ip22zilog.c
--- linux-2.6.14/drivers/serial/ip22zilog.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/ip22zilog.c	2005-11-17 11:43:39.000000000 -0800
@@ -215,7 +215,7 @@
 	/* Lower and upper byte of baud rate generator divisor.  */
 	write_zsreg(channel, R12, regs[R12]);
 	write_zsreg(channel, R13, regs[R13]);
-	
+
 	/* Now rewrite R14, with BRENAB (if set).  */
 	write_zsreg(channel, R14, regs[R14]);
 
@@ -585,7 +585,7 @@
 	else
 		clear_bits |= DTR;
 
-	/* NOTE: Not subject to 'transmitter active' rule.  */ 
+	/* NOTE: Not subject to 'transmitter active' rule.  */
 	up->curregs[R5] |= set_bits;
 	up->curregs[R5] &= ~clear_bits;
 	write_zsreg(channel, R5, up->curregs[R5]);
@@ -668,7 +668,7 @@
 	if (new_reg != up->curregs[R15]) {
 		up->curregs[R15] = new_reg;
 
-		/* NOTE: Not subject to 'transmitter active' rule.  */ 
+		/* NOTE: Not subject to 'transmitter active' rule.  */
 		write_zsreg(channel, R15, up->curregs[R15]);
 	}
 }
@@ -694,7 +694,7 @@
 	if (new_reg != up->curregs[R5]) {
 		up->curregs[R5] = new_reg;
 
-		/* NOTE: Not subject to 'transmitter active' rule.  */ 
+		/* NOTE: Not subject to 'transmitter active' rule.  */
 		write_zsreg(channel, R5, up->curregs[R5]);
 	}
 
@@ -882,6 +882,7 @@
 	up->cflag = termios->c_cflag;
 
 	ip22zilog_maybe_update_regs(up, ZILOG_CHANNEL_FROM_PORT(port));
+	uart_update_timeout(port, termios->c_cflag, baud);
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 }
@@ -1048,6 +1049,8 @@
 	}
 
 	con->cflag = cflag | CS8;			/* 8N1 */
+
+	uart_update_timeout(&ip22zilog_port_table[con->index].port, cflag, baud);
 }
 
 static int __init ip22zilog_console_setup(struct console *con, char *options)
diff -Naur linux-2.6.14/drivers/serial/ip3106_uart.c linux-mips-2.6.14.orig/drivers/serial/ip3106_uart.c
--- linux-2.6.14/drivers/serial/ip3106_uart.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/serial/ip3106_uart.c	2005-11-17 11:43:39.000000000 -0800
@@ -0,0 +1,912 @@
+/*
+ * Initially based on linux-2.4.20_mvl31-pnx8xx0/drivers/char/serial_pnx8550.c
+ *
+ * Complete rewrite to drivers/serial/pnx8550_uart.c by
+ * Embedded Alley Solutions, source@embeddedalley.com as part of the
+ * PNX8550 2.6 port, and then drivers/serial/ip3106_uart.c to work
+ * with other Philips SoCs.
+ *
+ * Existing copyrights from files used to write this driver:
+ * Author: Per Hallsmark per.hallsmark@mvista.com
+ *
+ * and
+ *
+ * Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ * Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ */
+
+#include <linux/config.h>
+
+#if defined(CONFIG_SERIAL_IP3106_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_ip3106.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <uart.h>
+
+/* We've been assigned a range on the "Low-density serial ports" major */
+#define SERIAL_IP3106_MAJOR	204
+#define MINOR_START		5
+
+#define NR_PORTS		2
+
+#define IP3106_ISR_PASS_LIMIT	256
+
+/*
+ * Convert from ignore_status_mask or read_status_mask to FIFO
+ * and interrupt status bits
+ */
+#define SM_TO_FIFO(x)	((x) >> 10)
+#define SM_TO_ISTAT(x)	((x) & 0x000001ff)
+#define FIFO_TO_SM(x)	((x) << 10)
+#define ISTAT_TO_SM(x)	((x) & 0x000001ff)
+
+/*
+ * This is the size of our serial port register set.
+ */
+#define UART_PORT_SIZE	0x1000
+
+/*
+ * This determines how often we check the modem status signals
+ * for any change.  They generally aren't connected to an IRQ
+ * so we have to poll them.  We also check immediately before
+ * filling the TX fifo incase CTS has been dropped.
+ */
+#define MCTRL_TIMEOUT	(250*HZ/1000)
+
+
+extern struct ip3106_port ip3106_ports[];
+
+static inline int serial_in(struct ip3106_port *sport, int offset)
+{
+	return (__raw_readl(sport->port.membase + offset));
+}
+
+static inline void serial_out(struct ip3106_port *sport, int offset, int value)
+{
+	__raw_writel(value, sport->port.membase + offset);
+}
+
+/*
+ * Handle any change of modem status signal since we were last called.
+ */
+static void ip3106_mctrl_check(struct ip3106_port *sport)
+{
+	unsigned int status, changed;
+
+	status = sport->port.ops->get_mctrl(&sport->port);
+	changed = status ^ sport->old_status;
+
+	if (changed == 0)
+		return;
+
+	sport->old_status = status;
+
+	if (changed & TIOCM_RI)
+		sport->port.icount.rng++;
+	if (changed & TIOCM_DSR)
+		sport->port.icount.dsr++;
+	if (changed & TIOCM_CAR)
+		uart_handle_dcd_change(&sport->port, status & TIOCM_CAR);
+	if (changed & TIOCM_CTS)
+		uart_handle_cts_change(&sport->port, status & TIOCM_CTS);
+
+	wake_up_interruptible(&sport->port.info->delta_msr_wait);
+}
+
+/*
+ * This is our per-port timeout handler, for checking the
+ * modem status signals.
+ */
+static void ip3106_timeout(unsigned long data)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)data;
+	unsigned long flags;
+
+	if (sport->port.info) {
+		spin_lock_irqsave(&sport->port.lock, flags);
+		ip3106_mctrl_check(sport);
+		spin_unlock_irqrestore(&sport->port.lock, flags);
+
+		mod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);
+	}
+}
+
+/*
+ * interrupts disabled on entry
+ */
+static void ip3106_stop_tx(struct uart_port *port, unsigned int tty_stop)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	u32 ien;
+
+	/* Disable TX intr */
+	ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, ien & ~IP3106_UART_INT_ALLTX);
+
+	/* Clear all pending TX intr */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLTX);
+}
+
+/*
+ * interrupts may not be disabled on entry
+ */
+static void ip3106_start_tx(struct uart_port *port, unsigned int tty_start)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned long flags;
+	u32 ien;
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+	/* Clear all pending TX intr */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLTX);
+
+	/* Enable TX intr */
+	ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, ien | IP3106_UART_INT_ALLTX);
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+/*
+ * Interrupts enabled
+ */
+static void ip3106_stop_rx(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	u32 ien;
+
+	/* Disable RX intr */
+	ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, ien & ~IP3106_UART_INT_ALLRX);
+
+	/* Clear all pending RX intr */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLRX);
+}
+
+/*
+ * Set the modem control timer to fire immediately.
+ */
+static void ip3106_enable_ms(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	mod_timer(&sport->timer, jiffies);
+}
+
+static void
+ip3106_rx_chars(struct ip3106_port *sport, struct pt_regs *regs)
+{
+	struct tty_struct *tty = sport->port.info->tty;
+	unsigned int status, ch, flg, ignored = 0;
+
+	status = FIFO_TO_SM(serial_in(sport, IP3106_FIFO)) |
+		 ISTAT_TO_SM(serial_in(sport, IP3106_ISTAT));
+	while (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFIFO)) {
+		ch = serial_in(sport, IP3106_FIFO);
+
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		sport->port.icount.rx++;
+
+		flg = TTY_NORMAL;
+
+		/*
+		 * note that the error handling code is
+		 * out of the main execution path
+		 */
+		if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFE |
+					IP3106_UART_FIFO_RXPAR))
+			goto handle_error;
+
+		if (uart_handle_sysrq_char(&sport->port, ch, regs))
+			goto ignore_char;
+
+	error_return:
+		tty_insert_flip_char(tty, ch, flg);
+	ignore_char:
+		serial_out(sport, IP3106_LCR, serial_in(sport, IP3106_LCR) |
+				IP3106_UART_LCR_RX_NEXT);
+		status = FIFO_TO_SM(serial_in(sport, IP3106_FIFO)) |
+			 ISTAT_TO_SM(serial_in(sport, IP3106_ISTAT));
+	}
+ out:
+	tty_flip_buffer_push(tty);
+	return;
+
+ handle_error:
+	if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXPAR))
+		sport->port.icount.parity++;
+	else if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFE))
+		sport->port.icount.frame++;
+	if (status & ISTAT_TO_SM(IP3106_UART_INT_RXOVRN))
+		sport->port.icount.overrun++;
+
+	if (status & sport->port.ignore_status_mask) {
+		if (++ignored > 100)
+			goto out;
+		goto ignore_char;
+	}
+
+//	status &= sport->port.read_status_mask;
+
+	if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXPAR))
+		flg = TTY_PARITY;
+	else if (status & FIFO_TO_SM(IP3106_UART_FIFO_RXFE))
+		flg = TTY_FRAME;
+
+	if (status & ISTAT_TO_SM(IP3106_UART_INT_RXOVRN)) {
+		/*
+		 * overrun does *not* affect the character
+		 * we read from the FIFO
+		 */
+		tty_insert_flip_char(tty, ch, flg);
+		ch = 0;
+		flg = TTY_OVERRUN;
+	}
+#ifdef SUPPORT_SYSRQ
+	sport->port.sysrq = 0;
+#endif
+	goto error_return;
+}
+
+static void ip3106_tx_chars(struct ip3106_port *sport)
+{
+	struct circ_buf *xmit = &sport->port.info->xmit;
+
+	if (sport->port.x_char) {
+		serial_out(sport, IP3106_FIFO, sport->port.x_char);
+		sport->port.icount.tx++;
+		sport->port.x_char = 0;
+		return;
+	}
+
+	/*
+	 * Check the modem control lines before
+	 * transmitting anything.
+	 */
+	ip3106_mctrl_check(sport);
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {
+		ip3106_stop_tx(&sport->port, 0);
+		return;
+	}
+
+	/*
+	 * TX while bytes available
+	 */
+	while (((serial_in(sport, IP3106_FIFO) &
+					IP3106_UART_FIFO_TXFIFO) >> 16) < 16) {
+		serial_out(sport, IP3106_FIFO, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		sport->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&sport->port);
+
+	if (uart_circ_empty(xmit))
+		ip3106_stop_tx(&sport->port, 0);
+}
+
+static irqreturn_t ip3106_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct ip3106_port *sport = dev_id;
+	unsigned int status;
+
+	spin_lock(&sport->port.lock);
+	/* Get the interrupts */
+	status  = serial_in(sport, IP3106_ISTAT) & serial_in(sport, IP3106_IEN);
+
+	/* RX Receiver Holding Register Overrun */
+	if (status & IP3106_UART_INT_RXOVRN) {
+		sport->port.icount.overrun++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_RXOVRN);
+	}
+
+	/* RX Frame Error */
+	if (status & IP3106_UART_INT_FRERR) {
+		sport->port.icount.frame++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_FRERR);
+	}
+
+	/* Break signal received */
+	if (status & IP3106_UART_INT_BREAK) {
+		sport->port.icount.brk++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_BREAK);
+	}
+
+	/* RX Parity Error */
+	if (status & IP3106_UART_INT_PARITY) {
+		sport->port.icount.parity++;
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_PARITY);
+	}
+
+	/* Byte received */
+	if (status & IP3106_UART_INT_RX) {
+		ip3106_rx_chars(sport, regs);
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_RX);
+	}
+
+	/* TX holding register empty - transmit a byte */
+	if (status & IP3106_UART_INT_TX) {
+		ip3106_tx_chars(sport);
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_TX);
+	}
+
+	/* TX shift register and holding register empty  */
+	if (status & IP3106_UART_INT_EMPTY) {
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_EMPTY);
+	}
+
+	/* Receiver time out */
+	if (status & IP3106_UART_INT_RCVTO) {
+		serial_out(sport, IP3106_ICLR, IP3106_UART_INT_RCVTO);
+	}
+	spin_unlock(&sport->port.lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Return TIOCSER_TEMT when transmitter is not busy.
+ */
+static unsigned int ip3106_tx_empty(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	return serial_in(sport, IP3106_FIFO) & IP3106_UART_FIFO_TXFIFO_STA ? 0 : TIOCSER_TEMT;
+}
+
+static unsigned int ip3106_get_mctrl(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned int mctrl = TIOCM_DSR;
+	unsigned int msr;
+
+	/* REVISIT */
+
+	msr = serial_in(sport, IP3106_MCR);
+
+	mctrl |= msr & IP3106_UART_MCR_CTS ? TIOCM_CTS : 0;
+	mctrl |= msr & IP3106_UART_MCR_DCD ? TIOCM_CAR : 0;
+
+	return mctrl;
+}
+
+static void ip3106_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+#if	0	/* FIXME */
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned int msr;
+#endif
+}
+
+/*
+ * Interrupts always disabled.
+ */
+static void ip3106_break_ctl(struct uart_port *port, int break_state)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned long flags;
+	unsigned int lcr;
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+	lcr = serial_in(sport, IP3106_LCR);
+	if (break_state == -1)
+		lcr |= IP3106_UART_LCR_TXBREAK;
+	else
+		lcr &= ~IP3106_UART_LCR_TXBREAK;
+	serial_out(sport, IP3106_LCR, lcr);
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+static int ip3106_startup(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	int retval;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(sport->port.irq, ip3106_int, 0,
+			     "ip3106-uart", sport);
+	if (retval)
+		return retval;
+
+	/*
+	 * Finally, clear and enable interrupts
+	 */
+
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLRX |
+			     IP3106_UART_INT_ALLTX);
+
+	serial_out(sport, IP3106_IEN, serial_in(sport, IP3106_IEN) |
+			    IP3106_UART_INT_ALLRX |
+			    IP3106_UART_INT_ALLTX);
+
+	/*
+	 * Enable modem status interrupts
+	 */
+	spin_lock_irq(&sport->port.lock);
+	ip3106_enable_ms(&sport->port);
+	spin_unlock_irq(&sport->port.lock);
+
+	return 0;
+}
+
+static void ip3106_shutdown(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	/*
+	 * Stop our timer.
+	 */
+	del_timer_sync(&sport->timer);
+
+	/*
+	 * Disable all interrupts, port and break condition.
+	 */
+	serial_out(sport, IP3106_IEN, 0);
+
+	/*
+	 * Reset the Tx and Rx FIFOS
+	 */
+	serial_out(sport, IP3106_LCR, serial_in(sport, IP3106_LCR) |
+			    IP3106_UART_LCR_TX_RST |
+			    IP3106_UART_LCR_RX_RST);
+
+	/*
+	 * Clear all interrupts
+	 */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_ALLRX |
+			     IP3106_UART_INT_ALLTX);
+
+	/*
+	 * Free the interrupt
+	 */
+	free_irq(sport->port.irq, sport);
+}
+
+static void
+ip3106_set_termios(struct uart_port *port, struct termios *termios,
+		   struct termios *old)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	unsigned long flags;
+	unsigned int lcr_fcr, old_ien, baud, quot;
+	unsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;
+
+	/*
+	 * We only support CS7 and CS8.
+	 */
+	while ((termios->c_cflag & CSIZE) != CS7 &&
+	       (termios->c_cflag & CSIZE) != CS8) {
+		termios->c_cflag &= ~CSIZE;
+		termios->c_cflag |= old_csize;
+		old_csize = CS8;
+	}
+
+	if ((termios->c_cflag & CSIZE) == CS8)
+		lcr_fcr = IP3106_UART_LCR_8BIT;
+	else
+		lcr_fcr = 0;
+
+	if (termios->c_cflag & CSTOPB)
+		lcr_fcr |= IP3106_UART_LCR_2STOPB;
+	if (termios->c_cflag & PARENB) {
+		lcr_fcr |= IP3106_UART_LCR_PAREN;
+		if (!(termios->c_cflag & PARODD))
+			lcr_fcr |= IP3106_UART_LCR_PAREVN;
+	}
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	spin_lock_irqsave(&sport->port.lock, flags);
+
+#if	0	/* REVISIT */
+	sport->port.read_status_mask &= UTSR0_TO_SM(UTSR0_TFS);
+	sport->port.read_status_mask |= UTSR1_TO_SM(UTSR1_ROR);
+	if (termios->c_iflag & INPCK)
+		sport->port.read_status_mask |=
+				UTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		sport->port.read_status_mask |=
+				UTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);
+
+	/*
+	 * Characters to ignore
+	 */
+	sport->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		sport->port.ignore_status_mask |=
+				UTSR1_TO_SM(UTSR1_FRE | UTSR1_PRE);
+	if (termios->c_iflag & IGNBRK) {
+		sport->port.ignore_status_mask |=
+				UTSR0_TO_SM(UTSR0_RBB | UTSR0_REB);
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			sport->port.ignore_status_mask |=
+				UTSR1_TO_SM(UTSR1_ROR);
+	}
+#endif
+
+	del_timer_sync(&sport->timer);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * disable interrupts and drain transmitter
+	 */
+	old_ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, old_ien & ~(IP3106_UART_INT_ALLTX |
+					IP3106_UART_INT_ALLRX));
+
+	while (serial_in(sport, IP3106_FIFO) & IP3106_UART_FIFO_TXFIFO_STA)
+		barrier();
+
+	/* then, disable everything */
+	serial_out(sport, IP3106_IEN, 0);
+
+	/* Reset the Rx and Tx FIFOs too */
+	lcr_fcr |= IP3106_UART_LCR_TX_RST;
+	lcr_fcr |= IP3106_UART_LCR_RX_RST;
+
+	/* set the parity, stop bits and data size */
+	serial_out(sport, IP3106_LCR, lcr_fcr);
+
+	/* set the baud rate */
+	quot -= 1;
+	serial_out(sport, IP3106_BAUD, quot);
+
+	serial_out(sport, IP3106_ICLR, -1);
+
+	serial_out(sport, IP3106_IEN, old_ien);
+
+	if (UART_ENABLE_MS(&sport->port, termios->c_cflag))
+		ip3106_enable_ms(&sport->port);
+
+	spin_unlock_irqrestore(&sport->port.lock, flags);
+}
+
+static const char *ip3106_type(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	return sport->port.type == PORT_IP3106 ? "IP3106" : NULL;
+}
+
+/*
+ * Release the memory region(s) being used by 'port'.
+ */
+static void ip3106_release_port(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	release_mem_region(sport->port.mapbase, UART_PORT_SIZE);
+}
+
+/*
+ * Request the memory region(s) being used by 'port'.
+ */
+static int ip3106_request_port(struct uart_port *port)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	return request_mem_region(sport->port.mapbase, UART_PORT_SIZE,
+			"ip3106-uart") != NULL ? 0 : -EBUSY;
+}
+
+/*
+ * Configure/autoconfigure the port.
+ */
+static void ip3106_config_port(struct uart_port *port, int flags)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+
+	if (flags & UART_CONFIG_TYPE &&
+	    ip3106_request_port(&sport->port) == 0)
+		sport->port.type = PORT_IP3106;
+}
+
+/*
+ * Verify the new serial_struct (for TIOCSSERIAL).
+ * The only change we allow are to the flags and type, and
+ * even then only between PORT_IP3106 and PORT_UNKNOWN
+ */
+static int
+ip3106_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	struct ip3106_port *sport = (struct ip3106_port *)port;
+	int ret = 0;
+
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_IP3106)
+		ret = -EINVAL;
+	if (sport->port.irq != ser->irq)
+		ret = -EINVAL;
+	if (ser->io_type != SERIAL_IO_MEM)
+		ret = -EINVAL;
+	if (sport->port.uartclk / 16 != ser->baud_base)
+		ret = -EINVAL;
+	if ((void *)sport->port.mapbase != ser->iomem_base)
+		ret = -EINVAL;
+	if (sport->port.iobase != ser->port)
+		ret = -EINVAL;
+	if (ser->hub6 != 0)
+		ret = -EINVAL;
+	return ret;
+}
+
+struct uart_ops ip3106_pops = {
+	.tx_empty	= ip3106_tx_empty,
+	.set_mctrl	= ip3106_set_mctrl,
+	.get_mctrl	= ip3106_get_mctrl,
+	.stop_tx	= ip3106_stop_tx,
+	.start_tx	= ip3106_start_tx,
+	.stop_rx	= ip3106_stop_rx,
+	.enable_ms	= ip3106_enable_ms,
+	.break_ctl	= ip3106_break_ctl,
+	.startup	= ip3106_startup,
+	.shutdown	= ip3106_shutdown,
+	.set_termios	= ip3106_set_termios,
+	.type		= ip3106_type,
+	.release_port	= ip3106_release_port,
+	.request_port	= ip3106_request_port,
+	.config_port	= ip3106_config_port,
+	.verify_port	= ip3106_verify_port,
+};
+
+
+/*
+ * Setup the IP3106 serial ports.
+ *
+ * Note also that we support "console=ttySx" where "x" is either 0 or 1.
+ */
+static void __init ip3106_init_ports(void)
+{
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < NR_PORTS; i++) {
+		init_timer(&ip3106_ports[i].timer);
+		ip3106_ports[i].timer.function = ip3106_timeout;
+		ip3106_ports[i].timer.data     = (unsigned long)&ip3106_ports[i];
+	}
+}
+
+#ifdef CONFIG_SERIAL_IP3106_CONSOLE
+
+/*
+ * Interrupts are disabled on entering
+ */
+static void
+ip3106_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct ip3106_port *sport = &ip3106_ports[co->index];
+	unsigned int old_ien, status, i;
+
+	/*
+	 *	First, save IEN and then disable interrupts
+	 */
+	old_ien = serial_in(sport, IP3106_IEN);
+	serial_out(sport, IP3106_IEN, old_ien & ~(IP3106_UART_INT_ALLTX |
+					IP3106_UART_INT_ALLRX));
+
+	/*
+	 *	Now, do each character
+	 */
+	for (i = 0; i < count; i++) {
+		do {
+			/* Wait for UART_TX register to empty */
+			status = serial_in(sport, IP3106_FIFO);
+		} while (status & IP3106_UART_FIFO_TXFIFO);
+		serial_out(sport, IP3106_FIFO, s[i]);
+		if (s[i] == '\n') {
+			do {
+				status = serial_in(sport, IP3106_FIFO);
+			} while (status & IP3106_UART_FIFO_TXFIFO);
+			serial_out(sport, IP3106_FIFO, '\r');
+		}
+	}
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore IEN
+	 */
+	do {
+		/* Wait for UART_TX register to empty */
+		status = serial_in(sport, IP3106_FIFO);
+	} while (status & IP3106_UART_FIFO_TXFIFO);
+
+	/* Clear TX and EMPTY interrupt */
+	serial_out(sport, IP3106_ICLR, IP3106_UART_INT_TX |
+			     IP3106_UART_INT_EMPTY);
+
+	serial_out(sport, IP3106_IEN, old_ien);
+}
+
+static int __init
+ip3106_console_setup(struct console *co, char *options)
+{
+	struct ip3106_port *sport;
+	int baud = 38400;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index == -1 || co->index >= NR_PORTS)
+		co->index = 0;
+	sport = &ip3106_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&sport->port, co, baud, parity, bits, flow);
+}
+
+extern struct uart_driver ip3106_reg;
+static struct console ip3106_console = {
+	.name		= "ttyS",
+	.write		= ip3106_console_write,
+	.device		= uart_console_device,
+	.setup		= ip3106_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &ip3106_reg,
+};
+
+static int __init ip3106_rs_console_init(void)
+{
+	ip3106_init_ports();
+	register_console(&ip3106_console);
+	return 0;
+}
+console_initcall(ip3106_rs_console_init);
+
+#define IP3106_CONSOLE	&ip3106_console
+#else
+#define IP3106_CONSOLE	NULL
+#endif
+
+static struct uart_driver ip3106_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "ttyS",
+	.dev_name		= "ttyS",
+	.devfs_name		= "tts/",
+	.major			= SERIAL_IP3106_MAJOR,
+	.minor			= MINOR_START,
+	.nr			= NR_PORTS,
+	.cons			= IP3106_CONSOLE,
+};
+
+static int ip3106_serial_suspend(struct device *_dev, u32 state, u32 level)
+{
+	struct ip3106_port *sport = dev_get_drvdata(_dev);
+
+	if (sport && level == SUSPEND_DISABLE)
+		uart_suspend_port(&ip3106_reg, &sport->port);
+
+	return 0;
+}
+
+static int ip3106_serial_resume(struct device *_dev, u32 level)
+{
+	struct ip3106_port *sport = dev_get_drvdata(_dev);
+
+	if (sport && level == RESUME_ENABLE)
+		uart_resume_port(&ip3106_reg, &sport->port);
+
+	return 0;
+}
+
+static int ip3106_serial_probe(struct device *_dev)
+{
+	struct platform_device *dev = to_platform_device(_dev);
+	struct resource *res = dev->resource;
+	int i;
+
+	for (i = 0; i < dev->num_resources; i++, res++) {
+		if (!(res->flags & IORESOURCE_MEM))
+			continue;
+
+		for (i = 0; i < NR_PORTS; i++) {
+			if (ip3106_ports[i].port.mapbase != res->start)
+				continue;
+
+			ip3106_ports[i].port.dev = _dev;
+			uart_add_one_port(&ip3106_reg, &ip3106_ports[i].port);
+			dev_set_drvdata(_dev, &ip3106_ports[i]);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int ip3106_serial_remove(struct device *_dev)
+{
+	struct ip3106_port *sport = dev_get_drvdata(_dev);
+
+	dev_set_drvdata(_dev, NULL);
+
+	if (sport)
+		uart_remove_one_port(&ip3106_reg, &sport->port);
+
+	return 0;
+}
+
+static struct device_driver ip3106_serial_driver = {
+	.name		= "ip3106-uart",
+	.bus		= &platform_bus_type,
+	.probe		= ip3106_serial_probe,
+	.remove		= ip3106_serial_remove,
+	.suspend	= ip3106_serial_suspend,
+	.resume		= ip3106_serial_resume,
+};
+
+static int __init ip3106_serial_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Serial: IP3106 driver $Revision: 1.2 $\n");
+
+	ip3106_init_ports();
+
+	ret = uart_register_driver(&ip3106_reg);
+	if (ret == 0) {
+		ret = driver_register(&ip3106_serial_driver);
+		if (ret)
+			uart_unregister_driver(&ip3106_reg);
+	}
+	return ret;
+}
+
+static void __exit ip3106_serial_exit(void)
+{
+	driver_unregister(&ip3106_serial_driver);
+	uart_unregister_driver(&ip3106_reg);
+}
+
+module_init(ip3106_serial_init);
+module_exit(ip3106_serial_exit);
+
+MODULE_AUTHOR("Embedded Alley Solutions, Inc.");
+MODULE_DESCRIPTION("IP3106 generic serial port driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_CHARDEV_MAJOR(SERIAL_IP3106_MAJOR);
diff -Naur linux-2.6.14/drivers/serial/Kconfig linux-mips-2.6.14.orig/drivers/serial/Kconfig
--- linux-2.6.14/drivers/serial/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/Kconfig	2005-11-17 11:43:39.000000000 -0800
@@ -608,6 +608,25 @@
 	  If you have an Alchemy AU1X00 processor (MIPS based) and you want
 	  to use a console on a serial port, say Y.  Otherwise, say N.
 
+config SERIAL_IP3106
+	bool "Enable IP3106 UART Support (Philips PNX 8xx0 SoCs)"
+	depends on MIPS && (SOC_PNX8550 || SOC_PNX8330)
+	select SERIAL_CORE
+	help
+	  If you have a Philips SoC with an IP 3106 UART in it, such as
+	  the PNX8550 or PNX8330 (MIPS based) and you want to use
+	  serial ports, say Y.  Otherwise, say N.
+
+config SERIAL_IP3106_CONSOLE
+	bool "Enable PNX8XX0 serial console"
+	depends on SERIAL_IP3106
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you have a Philips SoC with an IP 3106 UART in it, such as
+	  the PNX8550 or PNX8330 (MIPS based) and you want to use
+	  a serial console, say Y.
+	  Otherwise, say N.
+
 config SERIAL_CORE
 	tristate
 
diff -Naur linux-2.6.14/drivers/serial/Makefile linux-mips-2.6.14.orig/drivers/serial/Makefile
--- linux-2.6.14/drivers/serial/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/Makefile	2005-11-17 11:43:39.000000000 -0800
@@ -42,6 +42,7 @@
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
 obj-$(CONFIG_SERIAL_LH7A40X) += serial_lh7a40x.o
 obj-$(CONFIG_SERIAL_AU1X00) += au1x00_uart.o
+obj-$(CONFIG_SERIAL_IP3106) += ip3106_uart.o
 obj-$(CONFIG_SERIAL_DZ) += dz.o
 obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
 obj-$(CONFIG_SERIAL_SGI_L1_CONSOLE) += sn_console.o
@@ -54,5 +55,4 @@
 obj-$(CONFIG_ETRAX_SERIAL) += crisv10.o
 obj-$(CONFIG_SERIAL_JSM) += jsm/
 obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
-obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
 obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
diff -Naur linux-2.6.14/drivers/serial/vr41xx_siu.c linux-mips-2.6.14.orig/drivers/serial/vr41xx_siu.c
--- linux-2.6.14/drivers/serial/vr41xx_siu.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/serial/vr41xx_siu.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,1050 +0,0 @@
-/*
- *  Driver for NEC VR4100 series Serial Interface Unit.
- *
- *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  Based on drivers/serial/8250.c, by Russell King.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/config.h>
-
-#if defined(CONFIG_SERIAL_VR41XX_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
-#define SUPPORT_SYSRQ
-#endif
-
-#include <linux/console.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/serial.h>
-#include <linux/serial_core.h>
-#include <linux/serial_reg.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-
-#include <asm/io.h>
-#include <asm/vr41xx/siu.h>
-#include <asm/vr41xx/vr41xx.h>
-
-#define SIU_PORTS_MAX	2
-#define SIU_BAUD_BASE	1152000
-#define SIU_MAJOR	204
-#define SIU_MINOR_BASE	82
-
-#define RX_MAX_COUNT	256
-#define TX_MAX_COUNT	15
-
-#define SIUIRSEL	0x08
- #define TMICMODE	0x20
- #define TMICTX		0x10
- #define IRMSEL		0x0c
- #define IRMSEL_HP	0x08
- #define IRMSEL_TEMIC	0x04
- #define IRMSEL_SHARP	0x00
- #define IRUSESEL	0x02
- #define SIRSEL		0x01
-
-struct siu_port {
-	unsigned int type;
-	unsigned int irq;
-	unsigned long start;
-};
-
-static const struct siu_port siu_type1_ports[] = {
-	{	.type		= PORT_VR41XX_SIU,
-		.irq		= SIU_IRQ,
-		.start		= 0x0c000000UL,		},
-};
-
-#define SIU_TYPE1_NR_PORTS	(sizeof(siu_type1_ports) / sizeof(struct siu_port))
-
-static const struct siu_port siu_type2_ports[] = {
-	{	.type		= PORT_VR41XX_SIU,
-		.irq		= SIU_IRQ,
-		.start		= 0x0f000800UL,		},
-	{	.type		= PORT_VR41XX_DSIU,
-		.irq		= DSIU_IRQ,
-		.start		= 0x0f000820UL,		},
-};
-
-#define SIU_TYPE2_NR_PORTS	(sizeof(siu_type2_ports) / sizeof(struct siu_port))
-
-static struct uart_port siu_uart_ports[SIU_PORTS_MAX];
-static uint8_t lsr_break_flag[SIU_PORTS_MAX];
-
-#define siu_read(port, offset)		readb((port)->membase + (offset))
-#define siu_write(port, offset, value)	writeb((value), (port)->membase + (offset))
-
-void vr41xx_select_siu_interface(siu_interface_t interface)
-{
-	struct uart_port *port;
-	unsigned long flags;
-	uint8_t irsel;
-
-	port = &siu_uart_ports[0];
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	irsel = siu_read(port, SIUIRSEL);
-	if (interface == SIU_INTERFACE_IRDA)
-		irsel |= SIRSEL;
-	else
-		irsel &= ~SIRSEL;
-	siu_write(port, SIUIRSEL, irsel);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-EXPORT_SYMBOL_GPL(vr41xx_select_siu_interface);
-
-void vr41xx_use_irda(irda_use_t use)
-{
-	struct uart_port *port;
-	unsigned long flags;
-	uint8_t irsel;
-
-	port = &siu_uart_ports[0];
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	irsel = siu_read(port, SIUIRSEL);
-	if (use == FIR_USE_IRDA)
-		irsel |= IRUSESEL;
-	else
-		irsel &= ~IRUSESEL;
-	siu_write(port, SIUIRSEL, irsel);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-EXPORT_SYMBOL_GPL(vr41xx_use_irda);
-
-void vr41xx_select_irda_module(irda_module_t module, irda_speed_t speed)
-{
-	struct uart_port *port;
-	unsigned long flags;
-	uint8_t irsel;
-
-	port = &siu_uart_ports[0];
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	irsel = siu_read(port, SIUIRSEL);
-	irsel &= ~(IRMSEL | TMICTX | TMICMODE);
-	switch (module) {
-	case SHARP_IRDA:
-		irsel |= IRMSEL_SHARP;
-		break;
-	case TEMIC_IRDA:
-		irsel |= IRMSEL_TEMIC | TMICMODE;
-		if (speed == IRDA_TX_4MBPS)
-			irsel |= TMICTX;
-		break;
-	case HP_IRDA:
-		irsel |= IRMSEL_HP;
-		break;
-	default:
-		break;
-	}
-	siu_write(port, SIUIRSEL, irsel);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-EXPORT_SYMBOL_GPL(vr41xx_select_irda_module);
-
-static inline void siu_clear_fifo(struct uart_port *port)
-{
-	siu_write(port, UART_FCR, UART_FCR_ENABLE_FIFO);
-	siu_write(port, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |
-	                          UART_FCR_CLEAR_XMIT);
-	siu_write(port, UART_FCR, 0);
-}
-
-static inline int siu_probe_ports(void)
-{
-	switch (current_cpu_data.cputype) {
-	case CPU_VR4111:
-	case CPU_VR4121:
-		return SIU_TYPE1_NR_PORTS;
-	case CPU_VR4122:
-	case CPU_VR4131:
-	case CPU_VR4133:
-		return SIU_TYPE2_NR_PORTS;
-	}
-
-	return 0;
-}
-
-static inline unsigned long siu_port_size(struct uart_port *port)
-{
-	switch (port->type) {
-	case PORT_VR41XX_SIU:
-		return 11UL;
-	case PORT_VR41XX_DSIU:
-		return 8UL;
-	}
-
-	return 0;
-}
-
-static inline unsigned int siu_check_type(struct uart_port *port)
-{
-	switch (current_cpu_data.cputype) {
-	case CPU_VR4111:
-	case CPU_VR4121:
-		if (port->line == 0)
-			return PORT_VR41XX_SIU;
-		break;
-	case CPU_VR4122:
-	case CPU_VR4131:
-	case CPU_VR4133:
-		if (port->line == 0)
-			return PORT_VR41XX_SIU;
-		else if (port->line == 1)
-			return PORT_VR41XX_DSIU;
-		break;
-	}
-
-	return PORT_UNKNOWN;
-}
-
-static inline const char *siu_type_name(struct uart_port *port)
-{
-	switch (port->type) {
-	case PORT_VR41XX_SIU:
-		return "SIU";
-	case PORT_VR41XX_DSIU:
-		return "DSIU";
-	}
-
-	return NULL;
-}
-
-static unsigned int siu_tx_empty(struct uart_port *port)
-{
-	uint8_t lsr;
-
-	lsr = siu_read(port, UART_LSR);
-	if (lsr & UART_LSR_TEMT)
-		return TIOCSER_TEMT;
-
-	return 0;
-}
-
-static void siu_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-	uint8_t mcr = 0;
-
-	if (mctrl & TIOCM_DTR)
-		mcr |= UART_MCR_DTR;
-	if (mctrl & TIOCM_RTS)
-		mcr |= UART_MCR_RTS;
-	if (mctrl & TIOCM_OUT1)
-		mcr |= UART_MCR_OUT1;
-	if (mctrl & TIOCM_OUT2)
-		mcr |= UART_MCR_OUT2;
-	if (mctrl & TIOCM_LOOP)
-		mcr |= UART_MCR_LOOP;
-
-	siu_write(port, UART_MCR, mcr);
-}
-
-static unsigned int siu_get_mctrl(struct uart_port *port)
-{
-	uint8_t msr;
-	unsigned int mctrl = 0;
-
-	msr = siu_read(port, UART_MSR);
-	if (msr & UART_MSR_DCD)
-		mctrl |= TIOCM_CAR;
-	if (msr & UART_MSR_RI)
-		mctrl |= TIOCM_RNG;
-	if (msr & UART_MSR_DSR)
-		mctrl |= TIOCM_DSR;
-	if (msr & UART_MSR_CTS)
-		mctrl |= TIOCM_CTS;
-
-	return mctrl;
-}
-
-static void siu_stop_tx(struct uart_port *port)
-{
-	unsigned long flags;
-	uint8_t ier;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	ier = siu_read(port, UART_IER);
-	ier &= ~UART_IER_THRI;
-	siu_write(port, UART_IER, ier);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-static void siu_start_tx(struct uart_port *port)
-{
-	unsigned long flags;
-	uint8_t ier;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	ier = siu_read(port, UART_IER);
-	ier |= UART_IER_THRI;
-	siu_write(port, UART_IER, ier);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-static void siu_stop_rx(struct uart_port *port)
-{
-	unsigned long flags;
-	uint8_t ier;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	ier = siu_read(port, UART_IER);
-	ier &= ~UART_IER_RLSI;
-	siu_write(port, UART_IER, ier);
-
-	port->read_status_mask &= ~UART_LSR_DR;
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-static void siu_enable_ms(struct uart_port *port)
-{
-	unsigned long flags;
-	uint8_t ier;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	ier = siu_read(port, UART_IER);
-	ier |= UART_IER_MSI;
-	siu_write(port, UART_IER, ier);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-static void siu_break_ctl(struct uart_port *port, int ctl)
-{
-	unsigned long flags;
-	uint8_t lcr;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	lcr = siu_read(port, UART_LCR);
-	if (ctl == -1)
-		lcr |= UART_LCR_SBC;
-	else
-		lcr &= ~UART_LCR_SBC;
-	siu_write(port, UART_LCR, lcr);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-static inline void receive_chars(struct uart_port *port, uint8_t *status,
-                                 struct pt_regs *regs)
-{
-	struct tty_struct *tty;
-	uint8_t lsr, ch;
-	char flag;
-	int max_count = RX_MAX_COUNT;
-
-	tty = port->info->tty;
-	lsr = *status;
-
-	do {
-		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
-			if (tty->low_latency)
-				tty_flip_buffer_push(tty);
-		}
-
-		ch = siu_read(port, UART_RX);
-		port->icount.rx++;
-		flag = TTY_NORMAL;
-
-#ifdef CONFIG_SERIAL_VR41XX_CONSOLE
-		lsr |= lsr_break_flag[port->line];
-		lsr_break_flag[port->line] = 0;
-#endif
-		if (unlikely(lsr & (UART_LSR_BI | UART_LSR_FE |
-		                    UART_LSR_PE | UART_LSR_OE))) {
-			if (lsr & UART_LSR_BI) {
-				lsr &= ~(UART_LSR_FE | UART_LSR_PE);
-				port->icount.brk++;
-
-				if (uart_handle_break(port))
-					goto ignore_char;
-			}
-
-			if (lsr & UART_LSR_FE)
-				port->icount.frame++;
-			if (lsr & UART_LSR_PE)
-				port->icount.parity++;
-			if (lsr & UART_LSR_OE)
-				port->icount.overrun++;
-
-			lsr &= port->read_status_mask;
-			if (lsr & UART_LSR_BI)
-				flag = TTY_BREAK;
-			if (lsr & UART_LSR_FE)
-				flag = TTY_FRAME;
-			if (lsr & UART_LSR_PE)
-				flag = TTY_PARITY;
-		}
-
-		if (uart_handle_sysrq_char(port, ch, regs))
-			goto ignore_char;
-
-		uart_insert_char(port, lsr, UART_LSR_OE, ch, flag);
-
-	ignore_char:
-		lsr = siu_read(port, UART_LSR);
-	} while ((lsr & UART_LSR_DR) && (max_count-- > 0));
-
-	tty_flip_buffer_push(tty);
-
-	*status = lsr;
-}
-
-static inline void check_modem_status(struct uart_port *port)
-{
-	uint8_t msr;
-
-	msr = siu_read(port, UART_MSR);
-	if ((msr & UART_MSR_ANY_DELTA) == 0)
-		return;
-	if (msr & UART_MSR_DDCD)
-		uart_handle_dcd_change(port, msr & UART_MSR_DCD);
-	if (msr & UART_MSR_TERI)
-		port->icount.rng++;
-	if (msr & UART_MSR_DDSR)
-		port->icount.dsr++;
-	if (msr & UART_MSR_DCTS)
-		uart_handle_cts_change(port, msr & UART_MSR_CTS);
-
-	wake_up_interruptible(&port->info->delta_msr_wait);
-}
-
-static inline void transmit_chars(struct uart_port *port)
-{
-	struct circ_buf *xmit;
-	int max_count = TX_MAX_COUNT;
-
-	xmit = &port->info->xmit;
-
-	if (port->x_char) {
-		siu_write(port, UART_TX, port->x_char);
-		port->icount.tx++;
-		port->x_char = 0;
-		return;
-	}
-
-	if (uart_circ_empty(xmit) || uart_tx_stopped(port)) {
-		siu_stop_tx(port);
-		return;
-	}
-
-	do {
-		siu_write(port, UART_TX, xmit->buf[xmit->tail]);
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		port->icount.tx++;
-		if (uart_circ_empty(xmit))
-			break;
-	} while (max_count-- > 0);
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(port);
-
-	if (uart_circ_empty(xmit))
-		siu_stop_tx(port);
-}
-
-static irqreturn_t siu_interrupt(int irq, void *dev_id, struct pt_regs *regs)
-{
-	struct uart_port *port;
-	uint8_t iir, lsr;
-
-	port = (struct uart_port *)dev_id;
-
-	iir = siu_read(port, UART_IIR);
-	if (iir & UART_IIR_NO_INT)
-		return IRQ_NONE;
-
-	lsr = siu_read(port, UART_LSR);
-	if (lsr & UART_LSR_DR)
-		receive_chars(port, &lsr, regs);
-
-	check_modem_status(port);
-
-	if (lsr & UART_LSR_THRE)
-		transmit_chars(port);
-
-	return IRQ_HANDLED;
-}
-
-static int siu_startup(struct uart_port *port)
-{
-	int retval;
-
-	if (port->membase == NULL)
-		return -ENODEV;
-
-	siu_clear_fifo(port);
-
-	(void)siu_read(port, UART_LSR);
-	(void)siu_read(port, UART_RX);
-	(void)siu_read(port, UART_IIR);
-	(void)siu_read(port, UART_MSR);
-
-	if (siu_read(port, UART_LSR) == 0xff)
-		return -ENODEV;
-
-	retval = request_irq(port->irq, siu_interrupt, 0, siu_type_name(port), port);
-	if (retval)
-		return retval;
-
-	if (port->type == PORT_VR41XX_DSIU)
-		vr41xx_enable_dsiuint(DSIUINT_ALL);
-
-	siu_write(port, UART_LCR, UART_LCR_WLEN8);
-
-	spin_lock_irq(&port->lock);
-	siu_set_mctrl(port, port->mctrl);
-	spin_unlock_irq(&port->lock);
-
-	siu_write(port, UART_IER, UART_IER_RLSI | UART_IER_RDI);
-
-	(void)siu_read(port, UART_LSR);
-	(void)siu_read(port, UART_RX);
-	(void)siu_read(port, UART_IIR);
-	(void)siu_read(port, UART_MSR);
-
-	return 0;
-}
-
-static void siu_shutdown(struct uart_port *port)
-{
-	unsigned long flags;
-	uint8_t lcr;
-
-	siu_write(port, UART_IER, 0);
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	port->mctrl &= ~TIOCM_OUT2;
-	siu_set_mctrl(port, port->mctrl);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-
-	lcr = siu_read(port, UART_LCR);
-	lcr &= ~UART_LCR_SBC;
-	siu_write(port, UART_LCR, lcr);
-
-	siu_clear_fifo(port);
-
-	(void)siu_read(port, UART_RX);
-
-	if (port->type == PORT_VR41XX_DSIU)
-		vr41xx_disable_dsiuint(DSIUINT_ALL);
-
-	free_irq(port->irq, port);
-}
-
-static void siu_set_termios(struct uart_port *port, struct termios *new,
-                            struct termios *old)
-{
-	tcflag_t c_cflag, c_iflag;
-	uint8_t lcr, fcr, ier;
-	unsigned int baud, quot;
-	unsigned long flags;
-
-	c_cflag = new->c_cflag;
-	switch (c_cflag & CSIZE) {
-	case CS5:
-		lcr = UART_LCR_WLEN5;
-		break;
-	case CS6:
-		lcr = UART_LCR_WLEN6;
-		break;
-	case CS7:
-		lcr = UART_LCR_WLEN7;
-		break;
-	default:
-		lcr = UART_LCR_WLEN8;
-		break;
-	}
-
-	if (c_cflag & CSTOPB)
-		lcr |= UART_LCR_STOP;
-	if (c_cflag & PARENB)
-		lcr |= UART_LCR_PARITY;
-	if ((c_cflag & PARODD) != PARODD)
-		lcr |= UART_LCR_EPAR;
-	if (c_cflag & CMSPAR)
-		lcr |= UART_LCR_SPAR;
-
-	baud = uart_get_baud_rate(port, new, old, 0, port->uartclk/16);
-	quot = uart_get_divisor(port, baud);
-
-	fcr = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	uart_update_timeout(port, c_cflag, baud);
-
-	c_iflag = new->c_iflag;
-
-	port->read_status_mask = UART_LSR_THRE | UART_LSR_OE | UART_LSR_DR;
-	if (c_iflag & INPCK)
-		port->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
-	if (c_iflag & (BRKINT | PARMRK))
-		port->read_status_mask |= UART_LSR_BI;
-
-	port->ignore_status_mask = 0;
-	if (c_iflag & IGNPAR)
-		port->ignore_status_mask |= UART_LSR_FE | UART_LSR_PE;
-	if (c_iflag & IGNBRK) {
-		port->ignore_status_mask |= UART_LSR_BI;
-		if (c_iflag & IGNPAR)
-			port->ignore_status_mask |= UART_LSR_OE;
-	}
-
-	if ((c_cflag & CREAD) == 0)
-		port->ignore_status_mask |= UART_LSR_DR;
-
-	ier = siu_read(port, UART_IER);
-	ier &= ~UART_IER_MSI;
-	if (UART_ENABLE_MS(port, c_cflag))
-		ier |= UART_IER_MSI;
-	siu_write(port, UART_IER, ier);
-
-	siu_write(port, UART_LCR, lcr | UART_LCR_DLAB);
-
-	siu_write(port, UART_DLL, (uint8_t)quot);
-	siu_write(port, UART_DLM, (uint8_t)(quot >> 8));
-
-	siu_write(port, UART_LCR, lcr);
-
-	siu_write(port, UART_FCR, fcr);
-
-	siu_set_mctrl(port, port->mctrl);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-static void siu_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
-{
-	switch (state) {
-	case 0:
-		switch (port->type) {
-		case PORT_VR41XX_SIU:
-			vr41xx_supply_clock(SIU_CLOCK);
-			break;
-		case PORT_VR41XX_DSIU:
-			vr41xx_supply_clock(DSIU_CLOCK);
-			break;
-		}
-		break;
-	case 3:
-		switch (port->type) {
-		case PORT_VR41XX_SIU:
-			vr41xx_mask_clock(SIU_CLOCK);
-			break;
-		case PORT_VR41XX_DSIU:
-			vr41xx_mask_clock(DSIU_CLOCK);
-			break;
-		}
-		break;
-	}
-}
-
-static const char *siu_type(struct uart_port *port)
-{
-	return siu_type_name(port);
-}
-
-static void siu_release_port(struct uart_port *port)
-{
-	unsigned long size;
-
-	if (port->flags	& UPF_IOREMAP) {
-		iounmap(port->membase);
-		port->membase = NULL;
-	}
-
-	size = siu_port_size(port);
-	release_mem_region(port->mapbase, size);
-}
-
-static int siu_request_port(struct uart_port *port)
-{
-	unsigned long size;
-	struct resource *res;
-
-	size = siu_port_size(port);
-	res = request_mem_region(port->mapbase, size, siu_type_name(port));
-	if (res == NULL)
-		return -EBUSY;
-
-	if (port->flags & UPF_IOREMAP) {
-		port->membase = ioremap(port->mapbase, size);
-		if (port->membase == NULL) {
-			release_resource(res);
-			return -ENOMEM;
-		}
-	}
-
-	return 0;
-}
-
-static void siu_config_port(struct uart_port *port, int flags)
-{
-	if (flags & UART_CONFIG_TYPE) {
-		port->type = siu_check_type(port);
-		(void)siu_request_port(port);
-	}
-}
-
-static int siu_verify_port(struct uart_port *port, struct serial_struct *serial)
-{
-	if (port->type != PORT_VR41XX_SIU && port->type != PORT_VR41XX_DSIU)
-		return -EINVAL;
-	if (port->irq != serial->irq)
-		return -EINVAL;
-	if (port->iotype != serial->io_type)
-		return -EINVAL;
-	if (port->mapbase != (unsigned long)serial->iomem_base)
-		return -EINVAL;
-
-	return 0;
-}
-
-static struct uart_ops siu_uart_ops = {
-	.tx_empty	= siu_tx_empty,
-	.set_mctrl	= siu_set_mctrl,
-	.get_mctrl	= siu_get_mctrl,
-	.stop_tx	= siu_stop_tx,
-	.start_tx	= siu_start_tx,
-	.stop_rx	= siu_stop_rx,
-	.enable_ms	= siu_enable_ms,
-	.break_ctl	= siu_break_ctl,
-	.startup	= siu_startup,
-	.shutdown	= siu_shutdown,
-	.set_termios	= siu_set_termios,
-	.pm		= siu_pm,
-	.type		= siu_type,
-	.release_port	= siu_release_port,
-	.request_port	= siu_request_port,
-	.config_port	= siu_config_port,
-	.verify_port	= siu_verify_port,
-};
-
-static int siu_init_ports(void)
-{
-	const struct siu_port *siu;
-	struct uart_port *port;
-	int i, num;
-
-	switch (current_cpu_data.cputype) {
-	case CPU_VR4111:
-	case CPU_VR4121:
-		siu = siu_type1_ports;
-		break;
-	case CPU_VR4122:
-	case CPU_VR4131:
-	case CPU_VR4133:
-		siu = siu_type2_ports;
-		break;
-	default:
-		return 0;
-	}
-
-	port = siu_uart_ports;
-	num = siu_probe_ports();
-	for (i = 0; i < num; i++) {
-		spin_lock_init(&port->lock);
-		port->irq = siu->irq;
-		port->uartclk = SIU_BAUD_BASE * 16;
-		port->fifosize = 16;
-		port->regshift = 0;
-		port->iotype = UPIO_MEM;
-		port->flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;
-		port->type = siu->type;
-		port->line = i;
-		port->mapbase = siu->start;
-		siu++;
-		port++;
-	}
-
-	return num;
-}
-
-#ifdef CONFIG_SERIAL_VR41XX_CONSOLE
-
-#define BOTH_EMPTY	(UART_LSR_TEMT | UART_LSR_THRE)
-
-static void wait_for_xmitr(struct uart_port *port)
-{
-	int timeout = 10000;
-	uint8_t lsr, msr;
-
-	do {
-		lsr = siu_read(port, UART_LSR);
-		if (lsr & UART_LSR_BI)
-			lsr_break_flag[port->line] = UART_LSR_BI;
-
-		if ((lsr & BOTH_EMPTY) == BOTH_EMPTY)
-			break;
-	} while (timeout-- > 0);
-
-	if (port->flags & UPF_CONS_FLOW) {
-		timeout = 1000000;
-
-		do {
-			msr = siu_read(port, UART_MSR);
-			if ((msr & UART_MSR_CTS) != 0)
-				break;
-		} while (timeout-- > 0);
-	}
-}
-
-static void siu_console_write(struct console *con, const char *s, unsigned count)
-{
-	struct uart_port *port;
-	uint8_t ier;
-	unsigned i;
-
-	port = &siu_uart_ports[con->index];
-
-	ier = siu_read(port, UART_IER);
-	siu_write(port, UART_IER, 0);
-
-	for (i = 0; i < count && *s != '\0'; i++, s++) {
-		wait_for_xmitr(port);
-		siu_write(port, UART_TX, *s);
-		if (*s == '\n') {
-			wait_for_xmitr(port);
-			siu_write(port, UART_TX, '\r');
-		}
-	}
-
-	wait_for_xmitr(port);
-	siu_write(port, UART_IER, ier);
-}
-
-static int siu_console_setup(struct console *con, char *options)
-{
-	struct uart_port *port;
-	int baud = 9600;
-	int parity = 'n';
-	int bits = 8;
-	int flow = 'n';
-
-	if (con->index >= SIU_PORTS_MAX)
-		con->index = 0;
-
-	port = &siu_uart_ports[con->index];
-	if (port->membase == NULL) {
-		if (port->mapbase == 0)
-			return -ENODEV;
-		port->membase = ioremap(port->mapbase, siu_port_size(port));
-	}
-
-	vr41xx_select_siu_interface(SIU_INTERFACE_RS232C);
-
-	if (options != NULL)
-		uart_parse_options(options, &baud, &parity, &bits, &flow);
-
-	return uart_set_options(port, con, baud, parity, bits, flow);
-}
-
-static struct uart_driver siu_uart_driver;
-
-static struct console siu_console = {
-	.name	= "ttyVR",
-	.write	= siu_console_write,
-	.device	= uart_console_device,
-	.setup	= siu_console_setup,
-	.flags	= CON_PRINTBUFFER,
-	.index	= -1,
-	.data	= &siu_uart_driver,
-};
-
-static int __devinit siu_console_init(void)
-{
-	struct uart_port *port;
-	int num, i;
-
-	num = siu_init_ports();
-	if (num <= 0)
-		return -ENODEV;
-
-	for (i = 0; i < num; i++) {
-		port = &siu_uart_ports[i];
-		port->ops = &siu_uart_ops;
-	}
-
-	register_console(&siu_console);
-
-	return 0;
-}
-
-console_initcall(siu_console_init);
-
-#define SERIAL_VR41XX_CONSOLE	&siu_console
-#else
-#define SERIAL_VR41XX_CONSOLE	NULL
-#endif
-
-static struct uart_driver siu_uart_driver = {
-	.owner		= THIS_MODULE,
-	.driver_name	= "SIU",
-	.dev_name	= "ttyVR",
-	.devfs_name	= "ttvr/",
-	.major		= SIU_MAJOR,
-	.minor		= SIU_MINOR_BASE,
-	.cons		= SERIAL_VR41XX_CONSOLE,
-};
-
-static int siu_probe(struct device *dev)
-{
-	struct uart_port *port;
-	int num, i, retval;
-
-	num = siu_init_ports();
-	if (num <= 0)
-		return -ENODEV;
-
-	siu_uart_driver.nr = num;
-	retval = uart_register_driver(&siu_uart_driver);
-	if (retval)
-		return retval;
-
-	for (i = 0; i < num; i++) {
-		port = &siu_uart_ports[i];
-		port->ops = &siu_uart_ops;
-		port->dev = dev;
-
-		retval = uart_add_one_port(&siu_uart_driver, port);
-		if (retval < 0) {
-			port->dev = NULL;
-			break;
-		}
-	}
-
-	if (i == 0 && retval < 0) {
-		uart_unregister_driver(&siu_uart_driver);
-		return retval;
-	}
-
-	return 0;
-}
-
-static int siu_remove(struct device *dev)
-{
-	struct uart_port *port;
-	int i;
-
-	for (i = 0; i < siu_uart_driver.nr; i++) {
-		port = &siu_uart_ports[i];
-		if (port->dev == dev) {
-			uart_remove_one_port(&siu_uart_driver, port);
-			port->dev = NULL;
-		}
-	}
-
-	uart_unregister_driver(&siu_uart_driver);
-
-	return 0;
-}
-
-static int siu_suspend(struct device *dev, pm_message_t state, u32 level)
-{
-	struct uart_port *port;
-	int i;
-
-	if (level != SUSPEND_DISABLE)
-		return 0;
-
-	for (i = 0; i < siu_uart_driver.nr; i++) {
-		port = &siu_uart_ports[i];
-		if ((port->type == PORT_VR41XX_SIU ||
-		     port->type == PORT_VR41XX_DSIU) && port->dev == dev)
-			uart_suspend_port(&siu_uart_driver, port);
-
-	}
-
-	return 0;
-}
-
-static int siu_resume(struct device *dev, u32 level)
-{
-	struct uart_port *port;
-	int i;
-
-	if (level != RESUME_ENABLE)
-		return 0;
-
-	for (i = 0; i < siu_uart_driver.nr; i++) {
-		port = &siu_uart_ports[i];
-		if ((port->type == PORT_VR41XX_SIU ||
-		     port->type == PORT_VR41XX_DSIU) && port->dev == dev)
-			uart_resume_port(&siu_uart_driver, port);
-	}
-
-	return 0;
-}
-
-static struct platform_device *siu_platform_device;
-
-static struct device_driver siu_device_driver = {
-	.name		= "SIU",
-	.bus		= &platform_bus_type,
-	.probe		= siu_probe,
-	.remove		= siu_remove,
-	.suspend	= siu_suspend,
-	.resume		= siu_resume,
-};
-
-static int __devinit vr41xx_siu_init(void)
-{
-	int retval;
-
-	siu_platform_device = platform_device_register_simple("SIU", -1, NULL, 0);
-	if (IS_ERR(siu_platform_device))
-		return PTR_ERR(siu_platform_device);
-
-	retval = driver_register(&siu_device_driver);
-	if (retval < 0)
-		platform_device_unregister(siu_platform_device);
-
-	return retval;
-}
-
-static void __devexit vr41xx_siu_exit(void)
-{
-	driver_unregister(&siu_device_driver);
-
-	platform_device_unregister(siu_platform_device);
-}
-
-module_init(vr41xx_siu_init);
-module_exit(vr41xx_siu_exit);
diff -Naur linux-2.6.14/drivers/tc/tc.c linux-mips-2.6.14.orig/drivers/tc/tc.c
--- linux-2.6.14/drivers/tc/tc.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/tc/tc.c	2005-11-17 11:43:39.000000000 -0800
@@ -8,33 +8,31 @@
  * for more details.
  *
  * Copyright (c) Harald Koerfgen, 1998
- * Copyright (c) 2001, 2003  Maciej W. Rozycki
+ * Copyright (c) 2001, 2003, 2005  Maciej W. Rozycki
  */
-#include <linux/string.h>
 #include <linux/init.h>
-#include <linux/ioport.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/string.h>
+#include <linux/types.h>
 
 #include <asm/addrspace.h>
+#include <asm/bug.h>
 #include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/paccess.h>
+
 #include <asm/dec/machtype.h>
 #include <asm/dec/prom.h>
 #include <asm/dec/tcinfo.h>
 #include <asm/dec/tcmodule.h>
 #include <asm/dec/interrupts.h>
-#include <asm/paccess.h>
-#include <asm/ptrace.h>
-
-#define TC_DEBUG
 
 MODULE_LICENSE("GPL");
 slot_info tc_bus[MAX_SLOT];
 static int num_tcslots;
 static tcinfo *info;
 
-unsigned long system_base;
-
 /*
  * Interface to the world. Read comment in include/asm-mips/tc.h.
  */
@@ -97,13 +95,16 @@
 static void __init tc_probe(unsigned long startaddr, unsigned long size,
 			    int slots)
 {
+	unsigned long slotaddr;
 	int i, slot, err;
 	long offset;
-	unsigned char pattern[4];
-	unsigned char *module;
+	u8 pattern[4];
+	volatile u8 *module;
 
 	for (slot = 0; slot < slots; slot++) {
-		module = (char *)(startaddr + slot * size);
+		slotaddr = startaddr + slot * size;
+		module = ioremap_nocache(slotaddr, size);
+		BUG_ON(!module);
 
 		offset = OLDCARD;
 
@@ -112,8 +113,10 @@
 		err |= get_dbe(pattern[1], module + OLDCARD + TC_PATTERN1);
 		err |= get_dbe(pattern[2], module + OLDCARD + TC_PATTERN2);
 		err |= get_dbe(pattern[3], module + OLDCARD + TC_PATTERN3);
-		if (err)
+		if (err) {
+			iounmap(module);
 			continue;
+		}
 
 		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
 		    pattern[2] != 0xaa || pattern[3] != 0xff) {
@@ -124,16 +127,20 @@
 			err |= get_dbe(pattern[1], module + TC_PATTERN1);
 			err |= get_dbe(pattern[2], module + TC_PATTERN2);
 			err |= get_dbe(pattern[3], module + TC_PATTERN3);
-			if (err)
+			if (err) {
+				iounmap(module);
 				continue;
+			}
 		}
 
 		if (pattern[0] != 0x55 || pattern[1] != 0x00 ||
-		    pattern[2] != 0xaa || pattern[3] != 0xff)
+		    pattern[2] != 0xaa || pattern[3] != 0xff) {
+			iounmap(module);
 			continue;
+		}
 
-		tc_bus[slot].base_addr = (unsigned long)module;
-		for(i = 0; i < 8; i++) {
+		tc_bus[slot].base_addr = slotaddr;
+		for (i = 0; i < 8; i++) {
 			tc_bus[slot].firmware[i] =
 				module[TC_FIRM_VER + offset + 4 * i];
 			tc_bus[slot].vendor[i] =
@@ -171,13 +178,15 @@
 			tc_bus[slot].interrupt = -1;
 			break;
 		}
+
+		iounmap(module);
 	}
 }
 
 /*
  * the main entry
  */
-void __init tc_init(void)
+static int __init tc_init(void)
 {
 	int tc_clock;
 	int i;
@@ -185,7 +194,7 @@
 	unsigned long slot_size;
 
 	if (!TURBOCHANNEL)
-		return;
+		return 0;
 
 	for (i = 0; i < MAX_SLOT; i++) {
 		tc_bus[i].base_addr = 0;
@@ -196,8 +205,8 @@
 		tc_bus[i].flags = FREE;
 	}
 
-	info = (tcinfo *) rex_gettcinfo();
-	slot0addr = (unsigned long)KSEG1ADDR(rex_slot_address(0));
+	info = rex_gettcinfo();
+	slot0addr = CPHYSADDR((long)rex_slot_address(0));
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
@@ -216,37 +225,24 @@
 
 	tc_clock = 10000 / info->clk_period;
 
-	if (TURBOCHANNEL && info->slot_size && slot0addr) {
-		printk("TURBOchannel rev. %1d at %2d.%1d MHz ", info->revision,
-			tc_clock / 10, tc_clock % 10);
-		printk("(with%s parity)\n", info->parity ? "" : "out");
+	if (info->slot_size && slot0addr) {
+		pr_info("TURBOchannel rev. %d at %d.%d MHz (with%s parity)\n",
+			info->revision, tc_clock / 10, tc_clock % 10,
+			info->parity ? "" : "out");
 
 		slot_size = info->slot_size << 20;
 
 		tc_probe(slot0addr, slot_size, num_tcslots);
 
-  		/*
-  		 * All TURBOchannel DECstations have the onboard devices
- 		 * where the (num_tcslots + 0 or 1 on DS5k/xx) Option Module
- 		 * would be.
- 		 */
- 		if(mips_machtype == MACH_DS5000_XX)
- 			i = 1;
-		else
- 			i = 0;
-
- 	        system_base = slot0addr + slot_size * (num_tcslots + i);
-
-#ifdef TC_DEBUG
-		for (i = 0; i < num_tcslots; i++)
-			if (tc_bus[i].base_addr) {
-				printk("    slot %d: ", i);
-				printk("%s %s %s\n", tc_bus[i].vendor,
-					tc_bus[i].name, tc_bus[i].firmware);
-			}
-#endif
-		ioport_resource.end = KSEG2 - 1;
+		for (i = 0; i < num_tcslots; i++) {
+			if (!tc_bus[i].base_addr)
+				continue;
+			pr_info("    slot %d: %s %s %s\n", i, tc_bus[i].vendor,
+				tc_bus[i].name, tc_bus[i].firmware);
+		}
 	}
+
+	return 0;
 }
 
 subsys_initcall(tc_init);
@@ -257,4 +253,3 @@
 EXPORT_SYMBOL(get_tc_base_addr);
 EXPORT_SYMBOL(get_tc_irq_nr);
 EXPORT_SYMBOL(get_tc_speed);
-EXPORT_SYMBOL(system_base);
diff -Naur linux-2.6.14/drivers/tc/zs.c linux-mips-2.6.14.orig/drivers/tc/zs.c
--- linux-2.6.14/drivers/tc/zs.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/tc/zs.c	2005-11-17 11:43:39.000000000 -0800
@@ -6,7 +6,7 @@
  *
  * DECstation changes
  * Copyright (C) 1998-2000 Harald Koerfgen
- * Copyright (C) 2000, 2001, 2002, 2003, 2004  Maciej W. Rozycki
+ * Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005  Maciej W. Rozycki
  *
  * For the rest of the code the original Copyright applies:
  * Copyright (C) 1996 Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
@@ -55,6 +55,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/spinlock.h>
 #ifdef CONFIG_SERIAL_DEC_CONSOLE
 #include <linux/console.h>
 #endif
@@ -63,16 +64,15 @@
 #include <asm/pgtable.h>
 #include <asm/irq.h>
 #include <asm/system.h>
-#include <asm/uaccess.h>
 #include <asm/bootinfo.h>
-#include <asm/dec/serial.h>
 
-#ifdef CONFIG_MACH_DECSTATION
 #include <asm/dec/interrupts.h>
+#include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
+#include <asm/dec/system.h>
 #include <asm/dec/tc.h>
-#include <asm/dec/ioasic_addrs.h>
-#endif
+
 #ifdef CONFIG_KGDB
 #include <asm/kgdb.h>
 #endif
@@ -128,6 +128,8 @@
 
 #define BUS_PRESENT (DS_BUS_PRESENT)
 
+DEFINE_SPINLOCK(zs_lock);
+
 struct dec_zschannel zs_channels[NUM_CHANNELS];
 struct dec_serial zs_soft[NUM_CHANNELS];
 int zs_channels_found;
@@ -159,8 +161,6 @@
 	0				/* write 15 */
 };
 
-DECLARE_TASK_QUEUE(tq_zs_serial);
-
 static struct tty_driver *serial_driver;
 
 /* serial subtype definitions */
@@ -192,18 +192,6 @@
 static void change_speed(struct dec_serial *info);
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout);
 
-/*
- * tmp_buf is used as a temporary buffer by serial_write.  We need to
- * lock it in case the copy_from_user blocks while swapping in a page,
- * and some other program tries to do a serial write at the same time.
- * Since the lock will only come under contention when the system is
- * swapping and available memory is low, it makes sense to share one
- * buffer across all the serial ports, since it significantly saves
- * memory if large numbers of serial ports are open.
- */
-static unsigned char tmp_buf[4096]; /* This is cheating */
-static DECLARE_MUTEX(tmp_buf_sem);
-
 static inline int serial_paranoia_check(struct dec_serial *info,
 					char *name, const char *routine)
 {
@@ -306,8 +294,7 @@
 {
         unsigned long flags;
 
-
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 	if (info->zs_channel != info->zs_chan_a) {
 		if (set) {
 			info->zs_chan_a->curregs[5] |= (which & (RTS | DTR));
@@ -316,7 +303,7 @@
 		}
 		write_zsreg(info->zs_chan_a, 5, info->zs_chan_a->curregs[5]);
 	}
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 /* Utility routines for the Zilog */
@@ -357,12 +344,10 @@
  * This routine is used by the interrupt handler to schedule
  * processing in the software interrupt portion of the driver.
  */
-static _INLINE_ void rs_sched_event(struct dec_serial *info,
-				  int event)
+static _INLINE_ void rs_sched_event(struct dec_serial *info, int event)
 {
 	info->event |= 1 << event;
-	queue_task(&info->tqueue, &tq_zs_serial);
-	mark_bh(SERIAL_BH);
+	tasklet_schedule(&info->tlet);
 }
 
 static _INLINE_ void receive_chars(struct dec_serial *info,
@@ -509,9 +494,10 @@
 /*
  * This is the serial driver's generic interrupt routine
  */
-void rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t rs_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct dec_serial *info = (struct dec_serial *) dev_id;
+	irqreturn_t status = IRQ_NONE;
 	unsigned char zs_intreg;
 	int shift;
 
@@ -533,6 +519,8 @@
 		if ((zs_intreg & CHAN_IRQMASK) == 0)
 			break;
 
+		status = IRQ_HANDLED;
+
 		if (zs_intreg & CHBRxIP) {
 			receive_chars(info, regs);
 		}
@@ -546,6 +534,8 @@
 
 	/* Why do we need this ? */
 	write_zsreg(info->zs_channel, 0, RES_H_IUS);
+
+	return status;
 }
 
 #ifdef ZS_DEBUG_REGS
@@ -590,12 +580,12 @@
 		return;
 
 #if 1
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 	if (info->zs_channel->curregs[5] & TxENAB) {
 		info->zs_channel->curregs[5] &= ~TxENAB;
 		write_zsreg(info->zs_channel, 5, info->zs_channel->curregs[5]);
 	}
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 #endif
 }
 
@@ -607,7 +597,7 @@
 	if (serial_paranoia_check(info, tty->name, "rs_start"))
 		return;
 
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 #if 1
 	if (info->xmit_cnt && info->xmit_buf && !(info->zs_channel->curregs[5] & TxENAB)) {
 		info->zs_channel->curregs[5] |= TxENAB;
@@ -618,7 +608,7 @@
 		transmit_chars(info);
 	}
 #endif
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 /*
@@ -630,12 +620,8 @@
  * interrupt driver proper are done; the interrupt driver schedules
  * them using rs_sched_event(), and they get done here.
  */
-static void do_serial_bh(void)
-{
-	run_task_queue(&tq_zs_serial);
-}
 
-static void do_softint(void *private_)
+static void do_softint(unsigned long private_)
 {
 	struct dec_serial	*info = (struct dec_serial *) private_;
 	struct tty_struct	*tty;
@@ -646,10 +632,11 @@
 
 	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event)) {
 		tty_wakeup(tty);
+		wake_up_interruptible(&tty->write_wait);
 	}
 }
 
-int zs_startup(struct dec_serial * info)
+static int zs_startup(struct dec_serial * info)
 {
 	unsigned long flags;
 
@@ -662,7 +649,7 @@
 			return -ENOMEM;
 	}
 
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 
 #ifdef SERIAL_DEBUG_OPEN
 	printk("starting up ttyS%d (irq %d)...", info->line, info->irq);
@@ -718,7 +705,7 @@
 	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
 
 	info->flags |= ZILOG_INITIALIZED;
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 	return 0;
 }
 
@@ -738,7 +725,7 @@
 	       info->irq);
 #endif
 
-	save_flags(flags); cli(); /* Disable interrupts */
+	spin_lock_irqsave(&zs_lock, flags);
 
 	if (info->xmit_buf) {
 		free_page((unsigned long) info->xmit_buf);
@@ -761,7 +748,7 @@
 		set_bit(TTY_IO_ERROR, &info->tty->flags);
 
 	info->flags &= ~ZILOG_INITIALIZED;
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 /*
@@ -797,7 +784,7 @@
 			i += 15;
 	}
 
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 	info->zs_baud = baud_table[i];
 	if (info->zs_baud) {
 		brg = BPS_TO_BRG(info->zs_baud, zs_parms->clock/info->clk_divisor);
@@ -870,7 +857,7 @@
 	/* Load up the new values */
 	load_zsregs(info->zs_channel, info->zs_channel->curregs);
 
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 static void rs_flush_chars(struct tty_struct *tty)
@@ -886,9 +873,9 @@
 		return;
 
 	/* Enable transmitter */
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 	transmit_chars(info);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 static int rs_write(struct tty_struct * tty,
@@ -904,26 +891,17 @@
 	if (!tty || !info->xmit_buf)
 		return 0;
 
-	save_flags(flags);
 	while (1) {
-		cli();
+		spin_lock_irqsave(&zs_lock, flags);
 		c = min(count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				   SERIAL_XMIT_SIZE - info->xmit_head));
 		if (c <= 0)
 			break;
 
-		if (from_user) {
-			down(&tmp_buf_sem);
-			copy_from_user(tmp_buf, buf, c);
-			c = min(c, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
-				       SERIAL_XMIT_SIZE - info->xmit_head));
-			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
-			up(&tmp_buf_sem);
-		} else
-			memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		memcpy(info->xmit_buf + info->xmit_head, buf, c);
 		info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE-1);
 		info->xmit_cnt += c;
-		restore_flags(flags);
+		spin_unlock_irqrestore(&zs_lock, flags);
 		buf += c;
 		count -= c;
 		total += c;
@@ -932,7 +910,7 @@
 	if (info->xmit_cnt && !tty->stopped && !info->tx_stopped
 	    && !info->tx_active)
 		transmit_chars(info);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 	return total;
 }
 
@@ -964,9 +942,9 @@
 
 	if (serial_paranoia_check(info, tty->name, "rs_flush_buffer"))
 		return;
-	cli();
+	spin_lock_irq(&zs_lock);
 	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-	sti();
+	spin_unlock_irq(&zs_lock);
 	tty_wakeup(tty);
 }
 
@@ -994,11 +972,11 @@
 		return;
 
 	if (I_IXOFF(tty)) {
-		save_flags(flags); cli();
+		spin_lock_irqsave(&zs_lock, flags);
 		info->x_char = STOP_CHAR(tty);
 		if (!info->tx_active)
 			transmit_chars(info);
-		restore_flags(flags);
+		spin_unlock_irqrestore(&zs_lock, flags);
 	}
 
 	if (C_CRTSCTS(tty)) {
@@ -1022,7 +1000,7 @@
 		return;
 
 	if (I_IXOFF(tty)) {
-		save_flags(flags); cli();
+		spin_lock_irqsave(&zs_lock, flags);
 		if (info->x_char)
 			info->x_char = 0;
 		else {
@@ -1030,7 +1008,7 @@
 			if (!info->tx_active)
 				transmit_chars(info);
 		}
-		restore_flags(flags);
+		spin_unlock_irqrestore(&zs_lock, flags);
 	}
 
 	if (C_CRTSCTS(tty)) {
@@ -1123,9 +1101,9 @@
 {
 	unsigned char status;
 
-	cli();
+	spin_lock(&zs_lock);
 	status = read_zsreg(info->zs_channel, 0);
-	sti();
+	spin_unlock_irq(&zs_lock);
 	put_user(status,value);
 	return 0;
 }
@@ -1148,11 +1126,11 @@
 	if (info->zs_channel == info->zs_chan_a)
 		result = 0;
 	else {
-		cli();
+		spin_lock(&zs_lock);
 		control = info->zs_chan_a->curregs[5];
 		status_a = read_zsreg(info->zs_chan_a, 0);
 		status_b = read_zsreg(info->zs_channel, 0);
-		sti();
+		spin_unlock_irq(&zs_lock);
 		result =  ((control  & RTS) ? TIOCM_RTS: 0)
 			| ((control  & DTR) ? TIOCM_DTR: 0)
 			| ((status_b & DCD) ? TIOCM_CAR: 0)
@@ -1167,8 +1145,6 @@
                        unsigned int set, unsigned int clear)
 {
 	struct dec_serial * info = (struct dec_serial *)tty->driver_data;
-	int error;
-	unsigned int arg, bits;
 
 	if (info->hook)
 		return -ENODEV;
@@ -1182,8 +1158,7 @@
 	if (info->zs_channel == info->zs_chan_a)
 		return 0;
 
-	get_user(arg, value);
-	cli();
+	spin_lock(&zs_lock);
 	if (set & TIOCM_RTS)
 		info->zs_chan_a->curregs[5] |= RTS;
 	if (set & TIOCM_DTR)
@@ -1193,7 +1168,7 @@
 	if (clear & TIOCM_DTR)
 		info->zs_chan_a->curregs[5] &= ~DTR;
 	write_zsreg(info->zs_chan_a, 5, info->zs_chan_a->curregs[5]);
-	sti();
+	spin_unlock_irq(&zs_lock);
 	return 0;
 }
 
@@ -1210,19 +1185,18 @@
 	if (!info->port)
 		return;
 
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 	if (break_state == -1)
 		info->zs_channel->curregs[5] |= SND_BRK;
 	else
 		info->zs_channel->curregs[5] &= ~SND_BRK;
 	write_zsreg(info->zs_channel, 5, info->zs_channel->curregs[5]);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 static int rs_ioctl(struct tty_struct *tty, struct file * file,
 		    unsigned int cmd, unsigned long arg)
 {
-	int error;
 	struct dec_serial * info = (struct dec_serial *)tty->driver_data;
 
 	if (info->hook)
@@ -1299,10 +1273,10 @@
 	if (!info || serial_paranoia_check(info, tty->name, "rs_close"))
 		return;
 
-	save_flags(flags); cli();
+	spin_lock_irqsave(&zs_lock, flags);
 
 	if (tty_hung_up_p(filp)) {
-		restore_flags(flags);
+		spin_unlock_irqrestore(&zs_lock, flags);
 		return;
 	}
 
@@ -1327,7 +1301,7 @@
 		info->count = 0;
 	}
 	if (info->count) {
-		restore_flags(flags);
+		spin_unlock_irqrestore(&zs_lock, flags);
 		return;
 	}
 	info->flags |= ZILOG_CLOSING;
@@ -1370,7 +1344,7 @@
 	}
 	info->flags &= ~(ZILOG_NORMAL_ACTIVE|ZILOG_CLOSING);
 	wake_up_interruptible(&info->close_wait);
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 /*
@@ -1410,7 +1384,7 @@
 /*
  * rs_hangup() --- called by tty_hangup() when a hangup is signaled.
  */
-void rs_hangup(struct tty_struct *tty)
+static void rs_hangup(struct tty_struct *tty)
 {
 	struct dec_serial * info = (struct dec_serial *)tty->driver_data;
 
@@ -1478,16 +1452,16 @@
 	printk("block_til_ready before block: ttyS%d, count = %d\n",
 	       info->line, info->count);
 #endif
-	cli();
+	spin_lock(&zs_lock);
 	if (!tty_hung_up_p(filp))
 		info->count--;
-	sti();
+	spin_unlock_irq(&zs_lock);
 	info->blocked_open++;
 	while (1) {
-		cli();
+		spin_lock(&zs_lock);
 		if (tty->termios->c_cflag & CBAUD)
 			zs_rtsdtr(info, RTS | DTR, 1);
-		sti();
+		spin_unlock_irq(&zs_lock);
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (tty_hung_up_p(filp) ||
 		    !(info->flags & ZILOG_INITIALIZED)) {
@@ -1535,7 +1509,7 @@
  * the IRQ chain.   It also performs the serial-specific
  * initialization for the tty structure.
  */
-int rs_open(struct tty_struct *tty, struct file * filp)
+static int rs_open(struct tty_struct *tty, struct file * filp)
 {
 	struct dec_serial	*info;
 	int 			retval, line;
@@ -1628,30 +1602,22 @@
 		return;
 	}
 
-	/*
-	 * When serial console is activated, tc_init has not been called yet
-	 * and system_base is undefined. Unfortunately we have to hardcode
-	 * system_base for this case :-(. HK
-	 */
 	switch(mips_machtype) {
 #ifdef CONFIG_MACH_DECSTATION
 	case MACH_DS5000_2X0:
 	case MACH_DS5900:
-		system_base = KSEG1ADDR(0x1f800000);
 		n_chips = 2;
 		zs_parms = &ds_parms;
 		zs_parms->irq0 = dec_interrupt[DEC_IRQ_SCC0];
 		zs_parms->irq1 = dec_interrupt[DEC_IRQ_SCC1];
 		break;
 	case MACH_DS5000_1XX:
-		system_base = KSEG1ADDR(0x1c000000);
 		n_chips = 2;
 		zs_parms = &ds_parms;
 		zs_parms->irq0 = dec_interrupt[DEC_IRQ_SCC0];
 		zs_parms->irq1 = dec_interrupt[DEC_IRQ_SCC1];
 		break;
 	case MACH_DS5000_XX:
-		system_base = KSEG1ADDR(0x1c000000);
 		n_chips = 1;
 		zs_parms = &ds_parms;
 		zs_parms->irq0 = dec_interrupt[DEC_IRQ_SCC0];
@@ -1673,10 +1639,10 @@
 			 * The sccs reside on the high byte of the 16 bit IOBUS
 			 */
 			zs_channels[n_channels].control =
-				(volatile unsigned char *)system_base +
+				(volatile void *)CKSEG1ADDR(dec_kn_slot_base +
 			  (0 == chip ? zs_parms->scc0 : zs_parms->scc1) +
 			  (0 == channel ? zs_parms->channel_a_offset :
-			                  zs_parms->channel_b_offset);
+			                  zs_parms->channel_b_offset));
 			zs_channels[n_channels].data =
 				zs_channels[n_channels].control + 4;
 
@@ -1726,7 +1692,7 @@
 		}
 	}
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&zs_lock, flags);
 	for (n = 0; n < zs_channels_found; n++) {
 		if (n % 2 == 0) {
 			write_zsreg(zs_soft[n].zs_chan_a, R9, FHWRES);
@@ -1736,7 +1702,7 @@
 		load_zsregs(zs_soft[n].zs_channel,
 			    zs_soft[n].zs_channel->curregs);
 	}
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 }
 
 static struct tty_operations serial_ops = {
@@ -1769,9 +1735,6 @@
 	if(!BUS_PRESENT)
 		return -ENODEV;
 
-	/* Setup base handler, and timer table. */
-	init_bh(SERIAL_BH, do_serial_bh);
-
 	/* Find out how many Z8530 SCCs we have */
 	if (zs_chain == 0)
 		probe_sccs();
@@ -1820,8 +1783,7 @@
 		info->event = 0;
 		info->count = 0;
 		info->blocked_open = 0;
-		info->tqueue.routine = do_softint;
-		info->tqueue.data = info;
+		tasklet_init(&info->tlet, do_softint, (unsigned long)info);
 		init_waitqueue_head(&info->open_wait);
 		init_waitqueue_head(&info->close_wait);
 		printk("ttyS%02d at 0x%08x (irq = %d) is a Z85C30 SCC\n",
@@ -1853,8 +1815,7 @@
 /*
  * polling I/O routines
  */
-static int
-zs_poll_tx_char(void *handle, unsigned char ch)
+static int zs_poll_tx_char(void *handle, unsigned char ch)
 {
 	struct dec_serial *info = handle;
 	struct dec_zschannel *chan = info->zs_channel;
@@ -1877,8 +1838,7 @@
 		return -ENODEV;
 }
 
-static int
-zs_poll_rx_char(void *handle)
+static int zs_poll_rx_char(void *handle)
 {
 	struct dec_serial *info = handle;
         struct dec_zschannel *chan = info->zs_channel;
@@ -2057,7 +2017,7 @@
 	}
 	co->cflag = cflag;
 
-	save_and_cli(flags);
+	spin_lock_irqsave(&zs_lock, flags);
 
 	/*
 	 * Set up the baud rate generator.
@@ -2112,7 +2072,7 @@
 	zs_soft[co->index].clk_divisor = clk_divisor;
 	zs_soft[co->index].zs_baud = get_zsbaud(&zs_soft[co->index]);
 
-	restore_flags(flags);
+	spin_unlock_irqrestore(&zs_lock, flags);
 
 	return 0;
 }
@@ -2249,5 +2209,3 @@
 	set_debug_traps(); /* init stub */
 }
 #endif /* ifdef CONFIG_KGDB */
-
-
diff -Naur linux-2.6.14/drivers/tc/zs.h linux-mips-2.6.14.orig/drivers/tc/zs.h
--- linux-2.6.14/drivers/tc/zs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/tc/zs.h	2005-11-17 11:43:39.000000000 -0800
@@ -6,14 +6,14 @@
  *
  * Copyright (C) 1996 Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
- * Copyright (C) 2004  Maciej W. Rozycki
+ * Copyright (C) 2004, 2005  Maciej W. Rozycki
  */
 #ifndef _DECSERIAL_H
 #define _DECSERIAL_H
 
 #include <asm/dec/serial.h>
 
-#define NUM_ZSREGS    16
+#define NUM_ZSREGS 16
 
 struct serial_struct {
 	int	type;
@@ -139,8 +139,7 @@
 	int			xmit_head;
 	int			xmit_tail;
 	int			xmit_cnt;
-	struct tq_struct	tqueue;
-	struct tq_struct	tqueue_hangup;
+	struct tasklet_struct	tlet;
 	wait_queue_head_t	open_wait;
 	wait_queue_head_t	close_wait;
 };
@@ -282,7 +281,7 @@
 #define	DLC	4	/* Disable Lower Chain */
 #define	MIE	8	/* Master Interrupt Enable */
 #define	STATHI	0x10	/* Status high */
-#define SOFTACK 0x20    /* Software Interrupt Acknowledge */
+#define	SOFTACK	0x20	/* Software Interrupt Acknowledge */
 #define	NORESET	0	/* No reset on write to R9 */
 #define	CHRB	0x40	/* Reset channel B */
 #define	CHRA	0x80	/* Reset channel A */
@@ -395,8 +394,8 @@
 /* Read Register 15 (value of WR 15) */
 
 /* Misc macros */
-#define ZS_CLEARERR(channel)    (write_zsreg(channel, 0, ERR_RES))
-#define ZS_CLEARFIFO(channel)   do { volatile unsigned char garbage; \
+#define ZS_CLEARERR(channel)	(write_zsreg(channel, 0, ERR_RES))
+#define ZS_CLEARFIFO(channel)	do { volatile unsigned char garbage; \
 				     garbage = read_zsdata(channel); \
 				     garbage = read_zsdata(channel); \
 				     garbage = read_zsdata(channel); \
diff -Naur linux-2.6.14/drivers/usb/gadget/net2280.c linux-mips-2.6.14.orig/drivers/usb/gadget/net2280.c
--- linux-2.6.14/drivers/usb/gadget/net2280.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/usb/gadget/net2280.c	2005-11-17 11:43:39.000000000 -0800
@@ -448,7 +448,8 @@
 #elif	defined(CONFIG_PPC) && !defined(CONFIG_NOT_COHERENT_CACHE)
 #define USE_KMALLOC
 
-#elif	defined(CONFIG_MIPS) && !defined(CONFIG_DMA_NONCOHERENT)
+#elif	defined(CONFIG_MIPS) && \
+	(defined(CONFIG_DMA_COHERENT) || defined(CONFIG_DMA_IP27))
 #define USE_KMALLOC
 
 /* FIXME there are other cases, including an x86-64 one ...  */
diff -Naur linux-2.6.14/drivers/usb/host/ohci-au1xxx.c linux-mips-2.6.14.orig/drivers/usb/host/ohci-au1xxx.c
--- linux-2.6.14/drivers/usb/host/ohci-au1xxx.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/usb/host/ohci-au1xxx.c	2005-11-17 11:43:46.000000000 -0800
@@ -89,12 +89,12 @@
 	int retval;
 	struct usb_hcd *hcd;
 
-	if(dev->resource[1].flags != IORESOURCE_IRQ) {
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
 		pr_debug ("resource[1] is not IORESOURCE_IRQ");
-		return -ENOMEM;
+		retval = -ENOMEM;
 	}
 
-	hcd = usb_create_hcd(driver, &dev->dev, "au1xxx");
+	hcd = usb_create_hcd(driver, &dev->dev, "Au1xxx");
 	if (!hcd)
 		return -ENOMEM;
 	hcd->rsrc_start = dev->resource[0].start;
diff -Naur linux-2.6.14/drivers/usb/host/ohci-hcd.c linux-mips-2.6.14.orig/drivers/usb/host/ohci-hcd.c
--- linux-2.6.14/drivers/usb/host/ohci-hcd.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/usb/host/ohci-hcd.c	2005-11-17 11:43:46.000000000 -0800
@@ -909,6 +909,10 @@
 #include "ohci-au1xxx.c"
 #endif
 
+#ifdef CONFIG_PNX8550
+#include "ohci-pnx8550.c"
+#endif
+
 #ifdef CONFIG_USB_OHCI_HCD_PPC_SOC
 #include "ohci-ppc-soc.c"
 #endif
diff -Naur linux-2.6.14/drivers/usb/host/ohci-pnx8550.c linux-mips-2.6.14.orig/drivers/usb/host/ohci-pnx8550.c
--- linux-2.6.14/drivers/usb/host/ohci-pnx8550.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/usb/host/ohci-pnx8550.c	2005-11-17 11:43:46.000000000 -0800
@@ -0,0 +1,277 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ * (C) Copyright 2005 Embedded Alley Solutions, Inc.
+ *
+ * Bus Glue for PNX8550
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Russell King et al.
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ *
+ * Modified for pxa27x from ohci-lh7a404.c
+ *  by Nick Bane <nick@cecomputing.co.uk> 26-8-2004
+ *
+ * Modified for PNX8550 from ohci-pxa27x.c
+ *  by Embedded Alley Solutions, Inc. 
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/device.h>
+#include <asm/mach-pnx8550/usb.h>
+#include <asm/mach-pnx8550/int.h>
+#include <asm/mach-pnx8550/pci.h>
+
+#ifndef CONFIG_PNX8550
+#error "This file is PNX8550 bus glue.  CONFIG_PNX8550 must be defined."
+#endif
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void pnx8550_start_hc(struct platform_device *dev)
+{
+	/*
+	 * Set register CLK48CTL to enable and 48MHz
+	 */
+	outl(0x00000003, PCI_BASE | 0x0004770c);
+
+	/*
+	 * Set register CLK12CTL to enable and 48MHz
+	 */
+	outl(0x00000003, PCI_BASE | 0x00047710);
+
+	udelay(100);
+}
+
+static void pnx8550_stop_hc(struct platform_device *dev)
+{
+	udelay(10);
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+
+/**
+ * usb_hcd_pnx8550_probe - initialize pnx8550-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_hcd_pnx8550_probe (const struct hc_driver *driver,
+			  struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug ("resource[1] is not IORESOURCE_IRQ");
+		return -ENOMEM;
+	}
+
+	hcd = usb_create_hcd (driver, &dev->dev, "pnx8550");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	pnx8550_start_hc(dev);
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, SA_INTERRUPT);
+	if (retval == 0)
+		return retval;
+
+	pnx8550_stop_hc(dev);
+	iounmap(hcd->regs);
+ err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+ err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_pnx8550_remove - shutdown processing for pnx8550-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_pnx8550_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_hcd_pnx8550_remove (struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	pnx8550_stop_hc(dev);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit
+ohci_pnx8550_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int		ret;
+
+	ohci_dbg (ohci, "ohci_pnx8550_start, ohci:%p", ohci);
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run (ohci)) < 0) {
+		err ("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ohci_pnx8550_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"PNX8550 OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_pnx8550_start,
+	.stop =			ohci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef  CONFIG_USB_SUSPEND
+	.hub_suspend =		ohci_hub_suspend,
+	.hub_resume =		ohci_hub_resume,
+#endif
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_pnx8550_drv_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	int ret;
+
+	pr_debug ("In ohci_hcd_pnx8550_drv_probe");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_hcd_pnx8550_probe(&ohci_pnx8550_hc_driver, pdev);
+	return ret;
+}
+
+static int ohci_hcd_pnx8550_drv_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+
+	usb_hcd_pnx8550_remove(hcd, pdev);
+	return 0;
+}
+
+static int ohci_hcd_pnx8550_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+//	struct platform_device *pdev = to_platform_device(dev);
+//	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	printk("%s: not implemented yet\n", __FUNCTION__);
+
+	return 0;
+}
+
+static int ohci_hcd_pnx8550_drv_resume(struct device *dev, u32 state)
+{
+//	struct platform_device *pdev = to_platform_device(dev);
+//	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	printk("%s: not implemented yet\n", __FUNCTION__);
+
+	return 0;
+}
+
+
+static struct device_driver ohci_hcd_pnx8550_driver = {
+	.name		= "pnx8550-ohci",
+	.bus		= &platform_bus_type,
+	.probe		= ohci_hcd_pnx8550_drv_probe,
+	.remove		= ohci_hcd_pnx8550_drv_remove,
+	.suspend	= ohci_hcd_pnx8550_drv_suspend, 
+	.resume		= ohci_hcd_pnx8550_drv_resume, 
+};
+
+static int __init ohci_hcd_pnx8550_init (void)
+{
+	pr_debug (DRIVER_INFO " (pnx8550)");
+	pr_debug ("block sizes: ed %d td %d\n",
+		sizeof (struct ed), sizeof (struct td));
+
+	return driver_register(&ohci_hcd_pnx8550_driver);
+}
+
+static void __exit ohci_hcd_pnx8550_cleanup (void)
+{
+	driver_unregister(&ohci_hcd_pnx8550_driver);
+}
+
+module_init (ohci_hcd_pnx8550_init);
+module_exit (ohci_hcd_pnx8550_cleanup);
diff -Naur linux-2.6.14/drivers/video/au1100fb.c linux-mips-2.6.14.orig/drivers/video/au1100fb.c
--- linux-2.6.14/drivers/video/au1100fb.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/video/au1100fb.c	2005-11-17 11:43:49.000000000 -0800
@@ -2,6 +2,11 @@
  * BRIEF MODULE DESCRIPTION
  *	Au1100 LCD Driver.
  *
+ * Rewritten for 2.6 by Embedded Alley Solutions
+ * 	<source@embeddedalley.com>, based on submissions by 
+ *  	Karl Lessard <klessard@sunrisetelecom.com>
+ *  	<c.pellegrin@exadron.com>
+ *
  * Copyright 2002 MontaVista Software
  * Author: MontaVista Software, Inc.
  *		ppopov@mvista.com or source@mvista.com
@@ -34,297 +39,253 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/mm.h>
-#include <linux/tty.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
 #include <linux/fb.h>
 #include <linux/init.h>
-#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/dma-mapping.h>
 
-#include <asm/au1000.h>
-#include <asm/pb1100.h>
-#include "au1100fb.h"
+#include <asm/mach-au1x00/au1000.h>
 
-#include <video/fbcon.h>
-#include <video/fbcon-mfb.h>
-#include <video/fbcon-cfb2.h>
-#include <video/fbcon-cfb4.h>
-#include <video/fbcon-cfb8.h>
-#include <video/fbcon-cfb16.h>
+#define DEBUG 0
 
-/*
+#include "au1100fb.h"
+
+/* 
  * Sanity check. If this is a new Au1100 based board, search for
  * the PB1100 ifdefs to make sure you modify the code accordingly.
  */
-#if defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_HYDROGEN3)
+#if defined(CONFIG_MIPS_PB1100)
+  #include <asm/mach-pb1x00/pb1100.h>
+#elif defined(CONFIG_MIPS_DB1100)
+  #include <asm/mach-db1x00/db1x00.h>
 #else
-error Unknown Au1100 board
+  #error "Unknown Au1100 board, Au1100 FB driver not supported"
 #endif
 
-#define CMAPSIZE 16
+#define DRIVER_NAME "au1100fb"
+#define DRIVER_DESC "LCD controller driver for AU1100 processors"
 
-static int my_lcd_index; /* default is zero */
-struct known_lcd_panels *p_lcd;
-AU1100_LCD *p_lcd_reg = (AU1100_LCD *)AU1100_LCD_ADDR;
-
-struct au1100fb_info {
-	struct fb_info_gen gen;
-	unsigned long fb_virt_start;
-	unsigned long fb_size;
-	unsigned long fb_phys;
-	int mmaped;
-	int nohwcursor;
+#define to_au1100fb_device(_info) \
+	  (_info ? container_of(_info, struct au1100fb_device, info) : NULL);
 
-	struct { unsigned red, green, blue, pad; } palette[256];
+/* Bitfields format supported by the controller. Note that the order of formats 
+ * SHOULD be the same as in the LCD_CONTROL_SBPPF field, so we can retrieve the
+ * right pixel format by doing rgb_bitfields[LCD_CONTROL_SBPPF_XXX >> LCD_CONTROL_SBPPF]
+ */
+struct fb_bitfield rgb_bitfields[][4] = 
+{
+  	/*     Red, 	   Green, 	 Blue, 	     Transp   */
+	{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+	{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+	{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },
+	{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },
+	{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },
 
-#if defined(FBCON_HAS_CFB16)
-	u16 fbcon_cmap16[16];
-#endif
+	/* The last is used to describe 12bpp format */
+	{ { 8, 4, 0 },  { 4, 4, 0 }, { 0, 4, 0 }, { 0, 0, 0 } },
 };
 
-
-struct au1100fb_par {
-        struct fb_var_screeninfo var;
-
-	int line_length;  // in bytes
-	int cmap_len;     // color-map length
+static struct fb_fix_screeninfo au1100fb_fix __initdata = {
+	.id		= "AU1100 FB",
+	.xpanstep 	= 1,
+	.ypanstep 	= 1,
+	.type		= FB_TYPE_PACKED_PIXELS,
+	.accel		= FB_ACCEL_NONE,
 };
 
-
-static struct au1100fb_info fb_info;
-static struct au1100fb_par current_par;
-static struct display disp;
-
-int au1100fb_init(void);
-void au1100fb_setup(char *options, int *ints);
-static int au1100fb_mmap(struct fb_info *fb, struct file *file,
-		struct vm_area_struct *vma);
-static int au1100_blank(int blank_mode, struct fb_info_gen *info);
-static int au1100fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
-			  u_long arg, int con, struct fb_info *info);
-
-void au1100_nocursor(struct display *p, int mode, int xx, int yy){};
-
-static struct fb_ops au1100fb_ops = {
-	.owner		= THIS_MODULE,
-	.fb_get_fix	= fbgen_get_fix,
-	.fb_get_var	= fbgen_get_var,
-	.fb_set_var	= fbgen_set_var,
-	.fb_get_cmap	= fbgen_get_cmap,
-	.fb_set_cmap	= fbgen_set_cmap,
-	.fb_pan_display	= fbgen_pan_display,
-        .fb_ioctl	= au1100fb_ioctl,
-	.fb_mmap	= au1100fb_mmap,
+static struct fb_var_screeninfo au1100fb_var __initdata = {
+	.activate	= FB_ACTIVATE_NOW,
+	.height		= -1,
+	.width		= -1,
+	.vmode		= FB_VMODE_NONINTERLACED,
 };
 
-static void au1100_detect(void)
-{
-	/*
-	 *  This function should detect the current video mode settings
-	 *  and store it as the default video mode
-	 */
+static struct au1100fb_drv_info drv_info;
 
-	/*
-	 * Yeh, well, we're not going to change any settings so we're
-	 * always stuck with the default ...
+/*
+ * Set hardware with var settings. This will enable the controller with a specific
+ * mode, normally validated with the fb_check_var method
 	 */
-
-}
-
-static int au1100_encode_fix(struct fb_fix_screeninfo *fix,
-		const void *_par, struct fb_info_gen *_info)
-{
-        struct au1100fb_info *info = (struct au1100fb_info *) _info;
-        struct au1100fb_par *par = (struct au1100fb_par *) _par;
-	struct fb_var_screeninfo *var = &par->var;
-
-	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
-
-	fix->smem_start = info->fb_phys;
-	fix->smem_len = info->fb_size;
-	fix->type = FB_TYPE_PACKED_PIXELS;
-	fix->type_aux = 0;
-        fix->visual = (var->bits_per_pixel == 8) ?
-	       	FB_VISUAL_PSEUDOCOLOR	: FB_VISUAL_TRUECOLOR;
-	fix->ywrapstep = 0;
-	fix->xpanstep = 1;
-	fix->ypanstep = 1;
-	fix->line_length = current_par.line_length;
-	return 0;
-}
-
-static void set_color_bitfields(struct fb_var_screeninfo *var)
-{
-	switch (var->bits_per_pixel) {
-	case 8:
-		var->red.offset = 0;
-		var->red.length = 8;
-		var->green.offset = 0;
-		var->green.length = 8;
-		var->blue.offset = 0;
-		var->blue.length = 8;
-		var->transp.offset = 0;
-		var->transp.length = 0;
-		break;
-	case 16:	/* RGB 565 */
-		var->red.offset = 11;
-		var->red.length = 5;
-		var->green.offset = 5;
-		var->green.length = 6;
-		var->blue.offset = 0;
-		var->blue.length = 5;
-		var->transp.offset = 0;
-		var->transp.length = 0;
-		break;
-	}
-
-	var->red.msb_right = 0;
-	var->green.msb_right = 0;
-	var->blue.msb_right = 0;
-	var->transp.msb_right = 0;
-}
-
-static int au1100_decode_var(const struct fb_var_screeninfo *var,
-		void *_par, struct fb_info_gen *_info)
+int au1100fb_setmode(struct au1100fb_device *fbdev)
 {
+	struct fb_info *info = &fbdev->info;
+	u32 words;
+	int index;
 
-	struct au1100fb_par *par = (struct au1100fb_par *)_par;
-
-	/*
-	 * Don't allow setting any of these yet: xres and yres don't
-	 * make sense for LCD panels.
-	 */
-	if (var->xres != p_lcd->xres ||
-	    var->yres != p_lcd->yres ||
-	    var->xres != p_lcd->xres ||
-	    var->yres != p_lcd->yres) {
-		return -EINVAL;
-	}
-	if(var->bits_per_pixel != p_lcd->bpp) {
+	if (!fbdev)
 		return -EINVAL;
-	}
-
-	memset(par, 0, sizeof(struct au1100fb_par));
-	par->var = *var;
-
-	/* FIXME */
-	switch (var->bits_per_pixel) {
-		case 8:
-			par->var.bits_per_pixel = 8;
-			break;
-		case 16:
-			par->var.bits_per_pixel = 16;
-			break;
-		default:
-			printk("color depth %d bpp not supported\n",
-					var->bits_per_pixel);
-			return -EINVAL;
 
+	/* Update var-dependent FB info */
+	if (panel_is_active(fbdev->panel) || panel_is_color(fbdev->panel)) {
+		if (info->var.bits_per_pixel <= 8) {
+			/* palettized */
+			info->var.red.offset    = 0;
+			info->var.red.length    = info->var.bits_per_pixel;
+			info->var.red.msb_right = 0;
+
+			info->var.green.offset  = 0;
+			info->var.green.length  = info->var.bits_per_pixel;
+			info->var.green.msb_right = 0;
+
+			info->var.blue.offset   = 0;
+			info->var.blue.length   = info->var.bits_per_pixel;
+			info->var.blue.msb_right = 0;
+
+			info->var.transp.offset = 0;
+			info->var.transp.length = 0;
+			info->var.transp.msb_right = 0;
+
+			info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+			info->fix.line_length = info->var.xres_virtual / 
+							(8/info->var.bits_per_pixel);
+		} else {
+			/* non-palettized */
+			index = (fbdev->panel->control_base & LCD_CONTROL_SBPPF_MASK) >> LCD_CONTROL_SBPPF_BIT;
+			info->var.red = rgb_bitfields[index][0];
+			info->var.green = rgb_bitfields[index][1];
+			info->var.blue = rgb_bitfields[index][2];
+			info->var.transp = rgb_bitfields[index][3];
+
+			info->fix.visual = FB_VISUAL_TRUECOLOR;
+			info->fix.line_length = info->var.xres_virtual << 1; /* depth=16 */
+	}
+	} else {
+		/* mono */
+		info->fix.visual = FB_VISUAL_MONO10;
+		info->fix.line_length = info->var.xres_virtual / 8;
+	}
+
+	info->screen_size = info->fix.line_length * info->var.yres_virtual;
+	
+	/* Determine BPP mode and format */
+	fbdev->regs->lcd_control = fbdev->panel->control_base |
+			    ((info->var.rotate/90) << LCD_CONTROL_SM_BIT);
+
+	fbdev->regs->lcd_intenable = 0;
+	fbdev->regs->lcd_intstatus = 0;
+
+	fbdev->regs->lcd_horztiming = fbdev->panel->horztiming;
+
+	fbdev->regs->lcd_verttiming = fbdev->panel->verttiming;
+
+	fbdev->regs->lcd_clkcontrol = fbdev->panel->clkcontrol_base;
+
+	fbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(fbdev->fb_phys);
+
+	if (panel_is_dual(fbdev->panel)) {
+		/* Second panel display seconf half of screen if possible,
+		 * otherwise display the same as the first panel */
+		if (info->var.yres_virtual >= (info->var.yres << 1)) {
+			fbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys +
+							  (info->fix.line_length * 
+						          (info->var.yres_virtual >> 1)));
+		} else {
+			fbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys);
+		}
 	}
-	set_color_bitfields(&par->var);
-	par->cmap_len = (par->var.bits_per_pixel == 8) ? 256 : 16;
-	return 0;
-}
-
-static int au1100_encode_var(struct fb_var_screeninfo *var,
-		const void *par, struct fb_info_gen *_info)
-{
-
-	*var = ((struct au1100fb_par *)par)->var;
-	return 0;
-}
-
-static void
-au1100_get_par(void *_par, struct fb_info_gen *_info)
-{
-	*(struct au1100fb_par *)_par = current_par;
-}
-
-static void au1100_set_par(const void *par, struct fb_info_gen *info)
-{
-	/* nothing to do: we don't change any settings */
-}
-
-static int au1100_getcolreg(unsigned regno, unsigned *red, unsigned *green,
-			 unsigned *blue, unsigned *transp,
-			 struct fb_info *info)
-{
 
-	struct au1100fb_info* i = (struct au1100fb_info*)info;
-
-	if (regno > 255)
-		return 1;
+	words = info->fix.line_length / sizeof(u32);
+	if (!info->var.rotate || (info->var.rotate == 180)) {
+		words *= info->var.yres_virtual;
+		if (info->var.rotate /* 180 */) {
+			words -= (words % 8); /* should be divisable by 8 */
+		}
+	}
+	fbdev->regs->lcd_words = LCD_WRD_WRDS_N(words);
 
-	*red    = i->palette[regno].red;
-	*green  = i->palette[regno].green;
-	*blue   = i->palette[regno].blue;
-	*transp = 0;
+	fbdev->regs->lcd_pwmdiv = 0;
+	fbdev->regs->lcd_pwmhi = 0;
+   
+	/* Resume controller */
+	fbdev->regs->lcd_control |= LCD_CONTROL_GO;
 
 	return 0;
 }
 
-static int au1100_setcolreg(unsigned regno, unsigned red, unsigned green,
-			 unsigned blue, unsigned transp,
-			 struct fb_info *info)
+/* fb_setcolreg
+ * Set color in LCD palette.
+ */
+int au1100fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)
 {
-	struct au1100fb_info* i = (struct au1100fb_info *)info;
-	u32 rgbcol;
+	struct au1100fb_device *fbdev = to_au1100fb_device(fbi);
+	u32 *palette = fbdev->regs->lcd_pallettebase;
+	u32 value;
 
-	if (regno > 255)
-		return 1;
+	if (regno > (AU1100_LCD_NBR_PALETTE_ENTRIES - 1))
+		return -EINVAL;
 
-	i->palette[regno].red    = red;
-	i->palette[regno].green  = green;
-	i->palette[regno].blue   = blue;
+	if (fbi->var.grayscale) {
+		/* Convert color to grayscale */
+		red = green = blue = 
+			(19595 * red + 38470 * green + 7471 * blue) >> 16;
+	}
+   
+	if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
+		/* Place color in the pseudopalette */
+		if (regno > 16)
+			return -EINVAL;
+   
+		palette = (u32*)fbi->pseudo_palette;
 
-	switch(p_lcd->bpp) {
-#ifdef FBCON_HAS_CFB8
-	case 8:
-		red >>= 10;
-		green >>= 10;
-		blue >>= 10;
-		p_lcd_reg->lcd_pallettebase[regno] = (blue&0x1f) |
-			((green&0x3f)<<5) | ((red&0x1f)<<11);
-		break;
-#endif
-#ifdef FBCON_HAS_CFB16
-	case 16:
-		i->fbcon_cmap16[regno] =
-			((red & 0xf800) >> 0) |
-			((green & 0xfc00) >> 5) |
-			((blue & 0xf800) >> 11);
-		break;
-#endif
-	default:
-		break;
+		red   >>= (16 - fbi->var.red.length);
+		green >>= (16 - fbi->var.green.length);
+		blue  >>= (16 - fbi->var.blue.length);
+	
+		value = (red   << fbi->var.red.offset) 	|	
+			(green << fbi->var.green.offset)|
+			(blue  << fbi->var.blue.offset);
+		value &= 0xFFFF;
+
+	} else if (panel_is_active(fbdev->panel)) {
+		/* COLOR TFT PALLETTIZED (use RGB 565) */
+		value = (red & 0xF800)|((green >> 5) & 0x07E0)|((blue >> 11) & 0x001F);
+		value &= 0xFFFF;
+
+	} else if (panel_is_color(fbdev->panel)) {
+		/* COLOR STN MODE */
+		value = (((panel_swap_rgb(fbdev->panel) ? blue : red) >> 12) & 0x000F) | 
+			((green >> 8) & 0x00F0) | 
+			(((panel_swap_rgb(fbdev->panel) ? red : blue) >> 4) & 0x0F00);
+		value &= 0xFFF;
+	} else {
+		/* MONOCHROME MODE */
+		value = (green >> 12) & 0x000F;
+		value &= 0xF;
 	}
 
+	palette[regno] = value;
+	
 	return 0;
 }
 
-
-static int  au1100_blank(int blank_mode, struct fb_info_gen *_info)
+/* fb_blank
+ * Blank the screen. Depending on the mode, the screen will be
+ * activated with the backlight color, or desactivated
+ */
+int au1100fb_fb_blank(int blank_mode, struct fb_info *fbi)
 {
+	struct au1100fb_device *fbdev = to_au1100fb_device(fbi);
+
+	print_dbg("fb_blank %d %p", blank_mode, fbi);
 
 	switch (blank_mode) {
+
 	case VESA_NO_BLANKING:
-		/* turn on panel */
-		//printk("turn on panel\n");
+			/* Turn on panel */
+			fbdev->regs->lcd_control |= LCD_CONTROL_GO;
 #ifdef CONFIG_MIPS_PB1100
-		p_lcd_reg->lcd_control |= LCD_CONTROL_GO;
-		au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight,
+			if (drv_info.panel_idx == 1) {
+				au_writew(au_readw(PB1100_G_CONTROL) 
+					  | (PB1100_G_CONTROL_BL | PB1100_G_CONTROL_VDD), 
 			PB1100_G_CONTROL);
-#endif
-#ifdef CONFIG_MIPS_HYDROGEN3
-		/*  Turn controller & power supply on,  GPIO213 */
-		au_writel(0x20002000, 0xB1700008);
-		au_writel(0x00040000, 0xB1900108);
-		au_writel(0x01000100, 0xB1700008);
+			}
 #endif
 		au_sync();
 		break;
@@ -332,65 +293,105 @@
 	case VESA_VSYNC_SUSPEND:
 	case VESA_HSYNC_SUSPEND:
 	case VESA_POWERDOWN:
-		/* turn off panel */
-		//printk("turn off panel\n");
+			/* Turn off panel */
+			fbdev->regs->lcd_control &= ~LCD_CONTROL_GO;
 #ifdef CONFIG_MIPS_PB1100
-		au_writew(au_readw(PB1100_G_CONTROL) & ~p_lcd->mode_backlight,
+			if (drv_info.panel_idx == 1) {
+				au_writew(au_readw(PB1100_G_CONTROL) 
+				  	  & ~(PB1100_G_CONTROL_BL | PB1100_G_CONTROL_VDD),
 			PB1100_G_CONTROL);
-		p_lcd_reg->lcd_control &= ~LCD_CONTROL_GO;
+			}
 #endif
 		au_sync();
 		break;
-	default:
+	default: 
 		break;
 
 	}
 	return 0;
 }
 
-static void au1100_set_disp(const void *unused, struct display *disp,
-			 struct fb_info_gen *info)
+/* fb_pan_display
+ * Pan display in x and/or y as specified
+ */
+int au1100fb_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)
 {
-	disp->screen_base = (char *)fb_info.fb_virt_start;
+	struct au1100fb_device *fbdev = to_au1100fb_device(fbi);
+	int dy;
 
-	switch (disp->var.bits_per_pixel) {
-#ifdef FBCON_HAS_CFB8
-	case 8:
-		disp->dispsw = &fbcon_cfb8;
-		if (fb_info.nohwcursor)
-			fbcon_cfb8.cursor = au1100_nocursor;
-		break;
-#endif
-#ifdef FBCON_HAS_CFB16
-	case 16:
-		disp->dispsw = &fbcon_cfb16;
-		disp->dispsw_data = fb_info.fbcon_cmap16;
-		if (fb_info.nohwcursor)
-			fbcon_cfb16.cursor = au1100_nocursor;
-		break;
-#endif
-	default:
-		disp->dispsw = &fbcon_dummy;
-		disp->dispsw_data = NULL;
-		break;
+	print_dbg("fb_pan_display %p %p", var, fbi);
+
+	if (!var || !fbdev) {
+		return -EINVAL;
+	}
+
+	if (var->xoffset - fbi->var.xoffset) {
+		/* No support for X panning for now! */
+		return -EINVAL;
+	}
+			
+	print_dbg("fb_pan_display 2 %p %p", var, fbi);
+	dy = var->yoffset - fbi->var.yoffset;
+	if (dy) {
+
+		u32 dmaaddr;
+
+		print_dbg("Panning screen of %d lines", dy);
+
+		dmaaddr = fbdev->regs->lcd_dmaaddr0;
+		dmaaddr += (fbi->fix.line_length * dy);
+
+		/* TODO: Wait for current frame to finished */
+		fbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);
+
+		if (panel_is_dual(fbdev->panel)) {
+			dmaaddr = fbdev->regs->lcd_dmaaddr1;
+			dmaaddr += (fbi->fix.line_length * dy);
+			fbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);
+	}
+	}
+	print_dbg("fb_pan_display 3 %p %p", var, fbi);
+
+	return 0;
+}
+
+/* fb_rotate
+ * Rotate the display of this angle. This doesn't seems to be used by the core,
+ * but as our hardware supports it, so why not implementing it...
+ */
+void au1100fb_fb_rotate(struct fb_info *fbi, int angle)
+{
+	struct au1100fb_device *fbdev = to_au1100fb_device(fbi);
+
+	print_dbg("fb_rotate %p %d", fbi, angle);
+
+	if (fbdev && (angle > 0) && !(angle % 90)) {
+
+		fbdev->regs->lcd_control &= ~LCD_CONTROL_GO;
+
+		fbdev->regs->lcd_control &= ~(LCD_CONTROL_SM_MASK);
+		fbdev->regs->lcd_control |= ((angle/90) << LCD_CONTROL_SM_BIT);
+
+		fbdev->regs->lcd_control |= LCD_CONTROL_GO;
 	}
 }
 
-static int
-au1100fb_mmap(struct fb_info *_fb,
-	     struct file *file,
-	     struct vm_area_struct *vma)
+/* fb_mmap
+ * Map video memory in user space. We don't use the generic fb_mmap method mainly
+ * to allow the use of the TLB streaming flag (CCA=6)
+ */
+int au1100fb_fb_mmap(struct fb_info *fbi, struct file *file, struct vm_area_struct *vma)
 {
+	struct au1100fb_device *fbdev = to_au1100fb_device(fbi);
 	unsigned int len;
 	unsigned long start=0, off;
-	struct au1100fb_info *fb = (struct au1100fb_info *)_fb;
 
 	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
 		return -EINVAL;
 	}
-
-	start = fb_info.fb_phys & PAGE_MASK;
-	len = PAGE_ALIGN((start & ~PAGE_MASK) + fb_info.fb_size);
+    
+	start = fbdev->fb_phys & PAGE_MASK;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);
 
 	off = vma->vm_pgoff << PAGE_SHIFT;
 
@@ -401,276 +402,310 @@
 	off += start;
 	vma->vm_pgoff = off >> PAGE_SHIFT;
 
-	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
-	//pgprot_val(vma->vm_page_prot) |= _CACHE_CACHABLE_NONCOHERENT;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 	pgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6
 
-	/* This is an IO map - tell maydump to skip this VMA */
 	vma->vm_flags |= VM_IO;
-
-	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+    
+	if (io_remap_page_range(vma, vma->vm_start, off,
 				vma->vm_end - vma->vm_start,
 				vma->vm_page_prot)) {
 		return -EAGAIN;
 	}
 
-	fb->mmaped = 1;
 	return 0;
 }
 
-int au1100_pan_display(const struct fb_var_screeninfo *var,
-		       struct fb_info_gen *info)
+static struct fb_ops au1100fb_ops = 
 {
-	return 0;
-}
+	.owner			= THIS_MODULE,
+	.fb_setcolreg		= au1100fb_fb_setcolreg,
+	.fb_blank		= au1100fb_fb_blank,
+	.fb_pan_display		= au1100fb_fb_pan_display,
+	.fb_fillrect		= cfb_fillrect,
+	.fb_copyarea		= cfb_copyarea,
+	.fb_imageblit		= cfb_imageblit,
+	.fb_cursor		= soft_cursor,
+	.fb_rotate		= au1100fb_fb_rotate,
+	.fb_mmap		= au1100fb_fb_mmap,
+};
 
-static int au1100fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
-			  u_long arg, int con, struct fb_info *info)
-{
-	/* nothing to do yet */
-	return -EINVAL;
-}
 
-static struct fbgen_hwswitch au1100_switch = {
-	au1100_detect,
-	au1100_encode_fix,
-	au1100_decode_var,
-	au1100_encode_var,
-	au1100_get_par,
-	au1100_set_par,
-	au1100_getcolreg,
-	au1100_setcolreg,
-	au1100_pan_display,
-	au1100_blank,
-	au1100_set_disp
-};
+/*-------------------------------------------------------------------------*/
 
+/* AU1100 LCD controller device driver */
 
-int au1100_setmode(void)
+int au1100fb_drv_probe(struct device *dev)
 {
-	int words;
+	struct au1100fb_device *fbdev = NULL;
+	struct resource *regs_res;
+	unsigned long page;
+	u32 sys_clksrc;
 
-	/* FIXME Need to accomodate for swivel mode and 12bpp, <8bpp*/
-	switch (p_lcd->mode_control & LCD_CONTROL_SM)
-	{
-		case LCD_CONTROL_SM_0:
-		case LCD_CONTROL_SM_180:
-		words = (p_lcd->xres * p_lcd->yres * p_lcd->bpp) / 32;
-			break;
-		case LCD_CONTROL_SM_90:
-		case LCD_CONTROL_SM_270:
-			/* is this correct? */
-		words = (p_lcd->xres * p_lcd->bpp) / 8;
-			break;
-		default:
-			printk("mode_control reg not initialized\n");
+	if (!dev)
 			return -EINVAL;
-	}
 
-	/*
-	 * Setup LCD controller
-	 */
+	/* Allocate new device private */
+	if (!(fbdev = kmalloc(sizeof(struct au1100fb_device), GFP_KERNEL))) {
+		print_err("fail to allocate device private record");
+		return -ENOMEM;
+	}
+	memset((void*)fbdev, 0, sizeof(struct au1100fb_device));
 
-	p_lcd_reg->lcd_control = p_lcd->mode_control;
-	p_lcd_reg->lcd_intstatus = 0;
-	p_lcd_reg->lcd_intenable = 0;
-	p_lcd_reg->lcd_horztiming = p_lcd->mode_horztiming;
-	p_lcd_reg->lcd_verttiming = p_lcd->mode_verttiming;
-	p_lcd_reg->lcd_clkcontrol = p_lcd->mode_clkcontrol;
-	p_lcd_reg->lcd_words = words - 1;
-	p_lcd_reg->lcd_dmaaddr0 = fb_info.fb_phys;
+	fbdev->panel = &known_lcd_panels[drv_info.panel_idx];
 
-	/* turn on panel */
-#ifdef CONFIG_MIPS_PB1100
-	au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight,
-			PB1100_G_CONTROL);
-#endif
-#ifdef CONFIG_MIPS_HYDROGEN3
-	/*  Turn controller & power supply on,  GPIO213 */
-	au_writel(0x20002000, 0xB1700008);
-	au_writel(0x00040000, 0xB1900108);
-	au_writel(0x01000100, 0xB1700008);
-#endif
+	dev_set_drvdata(dev, (void*)fbdev);
 
-	p_lcd_reg->lcd_control |= LCD_CONTROL_GO;
+	/* Allocate region for our registers and map them */
+	if (!(regs_res = platform_get_resource(to_platform_device(dev), 
+					IORESOURCE_MEM, 0))) {
+		print_err("fail to retrieve registers resource");
+		return -EFAULT;
+	}
 
-	return 0;
-}
+	au1100fb_fix.mmio_start = regs_res->start;
+	au1100fb_fix.mmio_len = regs_res->end - regs_res->start + 1;
 
+	if (!request_mem_region(au1100fb_fix.mmio_start, au1100fb_fix.mmio_len, 
+				DRIVER_NAME)) {
+		print_err("fail to lock memory region at 0x%08x", 
+				au1100fb_fix.mmio_start);
+		return -EBUSY;
+	}
 
-int __init au1100fb_init(void)
-{
-	uint32 sys_clksrc;
-	unsigned long page;
+	fbdev->regs = (struct au1100fb_regs*)KSEG1ADDR(au1100fb_fix.mmio_start);
 
-	/*
-	* Get the panel information/display mode and update the registry
-	*/
-	p_lcd = &panels[my_lcd_index];
-
-	switch (p_lcd->mode_control & LCD_CONTROL_SM)
-	{
-		case LCD_CONTROL_SM_0:
-		case LCD_CONTROL_SM_180:
-		p_lcd->xres =
-			(p_lcd->mode_horztiming & LCD_HORZTIMING_PPL) + 1;
-		p_lcd->yres =
-			(p_lcd->mode_verttiming & LCD_VERTTIMING_LPP) + 1;
-			break;
-		case LCD_CONTROL_SM_90:
-		case LCD_CONTROL_SM_270:
-		p_lcd->yres =
-			(p_lcd->mode_horztiming & LCD_HORZTIMING_PPL) + 1;
-		p_lcd->xres =
-			(p_lcd->mode_verttiming & LCD_VERTTIMING_LPP) + 1;
-			break;
-	}
+	print_dbg("Register memory map at %p", fbdev->regs);
+	print_dbg("phys=0x%08x, size=%d", fbdev->regs_phys, fbdev->regs_len);
 
-	/*
-	 * Panel dimensions x bpp must be divisible by 32
-	 */
-	if (((p_lcd->yres * p_lcd->bpp) % 32) != 0)
-		printk("VERT %% 32\n");
-	if (((p_lcd->xres * p_lcd->bpp) % 32) != 0)
-		printk("HORZ %% 32\n");
 
-	/*
-	 * Allocate LCD framebuffer from system memory
-	 */
-	fb_info.fb_size = (p_lcd->xres * p_lcd->yres * p_lcd->bpp) / 8;
 
-	current_par.var.xres = p_lcd->xres;
-	current_par.var.xres_virtual = p_lcd->xres;
-	current_par.var.yres = p_lcd->yres;
-	current_par.var.yres_virtual = p_lcd->yres;
-	current_par.var.bits_per_pixel = p_lcd->bpp;
-
-	/* FIX!!! only works for 8/16 bpp */
-	current_par.line_length = p_lcd->xres * p_lcd->bpp / 8; /* in bytes */
-	fb_info.fb_virt_start = (unsigned long )
-		__get_free_pages(GFP_ATOMIC | GFP_DMA,
-				get_order(fb_info.fb_size + 0x1000));
-	if (!fb_info.fb_virt_start) {
-		printk("Unable to allocate fb memory\n");
+	/* Allocate the framebuffer to the maximum screen size * nbr of video buffers */
+	fbdev->fb_len = fbdev->panel->xres * fbdev->panel->yres *
+		  	(fbdev->panel->bpp >> 3) * AU1100FB_NBR_VIDEO_BUFFERS;
+	
+	fbdev->fb_mem = dma_alloc_coherent(dev, PAGE_ALIGN(fbdev->fb_len), 
+					&fbdev->fb_phys, GFP_KERNEL);
+	if (!fbdev->fb_mem) {
+		print_err("fail to allocate frambuffer (size: %dK))", 
+			  fbdev->fb_len / 1024);
 		return -ENOMEM;
 	}
-	fb_info.fb_phys = virt_to_bus((void *)fb_info.fb_virt_start);
+
+	au1100fb_fix.smem_start = fbdev->fb_phys;
+	au1100fb_fix.smem_len = fbdev->fb_len;
 
 	/*
 	 * Set page reserved so that mmap will work. This is necessary
 	 * since we'll be remapping normal memory.
 	 */
-	for (page = fb_info.fb_virt_start;
-	     page < PAGE_ALIGN(fb_info.fb_virt_start + fb_info.fb_size);
+	for (page = (unsigned long)fbdev->fb_mem;
+	     page < PAGE_ALIGN((unsigned long)fbdev->fb_mem + fbdev->fb_len); 
 	     page += PAGE_SIZE) {
+#if CONFIG_DMA_NONCOHERENT
+		SetPageReserved(virt_to_page(CAC_ADDR(page)));
+#else
 		SetPageReserved(virt_to_page(page));
+#endif
 	}
 
-	memset((void *)fb_info.fb_virt_start, 0, fb_info.fb_size);
+	print_dbg("Framebuffer memory map at %p", fbdev->fb_mem);
+	print_dbg("phys=0x%08x, size=%dK", fbdev->fb_phys, fbdev->fb_len / 1024);
 
-	/* set freqctrl now to allow more time to stabilize */
-	/* zero-out out LCD bits */
-	sys_clksrc = au_readl(SYS_CLKSRC) & ~0x000003e0;
-	sys_clksrc |= p_lcd->mode_toyclksrc;
-	au_writel(sys_clksrc, SYS_CLKSRC);
-
-	/* FIXME add check to make sure auxpll is what is expected! */
-	au1100_setmode();
-
-	fb_info.gen.parsize = sizeof(struct au1100fb_par);
-	fb_info.gen.fbhw = &au1100_switch;
-
-	strcpy(fb_info.gen.info.modename, "Au1100 LCD");
-	fb_info.gen.info.changevar = NULL;
-	fb_info.gen.info.node = -1;
-
-	fb_info.gen.info.fbops = &au1100fb_ops;
-	fb_info.gen.info.disp = &disp;
-	fb_info.gen.info.switch_con = &fbgen_switch;
-	fb_info.gen.info.updatevar = &fbgen_update_var;
-	fb_info.gen.info.blank = &fbgen_blank;
-	fb_info.gen.info.flags = FBINFO_FLAG_DEFAULT;
-
-	/* This should give a reasonable default video mode */
-	fbgen_get_var(&disp.var, -1, &fb_info.gen.info);
-	fbgen_do_set_var(&disp.var, 1, &fb_info.gen);
-	fbgen_set_disp(-1, &fb_info.gen);
-	fbgen_install_cmap(0, &fb_info.gen);
-	if (register_framebuffer(&fb_info.gen.info) < 0)
-		return -EINVAL;
-	printk(KERN_INFO "fb%d: %s frame buffer device\n",
-			GET_FB_IDX(fb_info.gen.info.node),
-			fb_info.gen.info.modename);
+	/* Setup LCD clock to AUX (48 MHz) */
+	sys_clksrc = au_readl(SYS_CLKSRC) & ~(SYS_CS_ML_MASK | SYS_CS_DL | SYS_CS_CL);
+	au_writel((sys_clksrc | (1 << SYS_CS_ML_BIT)), SYS_CLKSRC);
+
+	/* load the panel info into the var struct */
+	au1100fb_var.bits_per_pixel = fbdev->panel->bpp;
+	au1100fb_var.xres = fbdev->panel->xres;
+	au1100fb_var.xres_virtual = au1100fb_var.xres;
+	au1100fb_var.yres = fbdev->panel->yres;
+	au1100fb_var.yres_virtual = au1100fb_var.yres;
+
+	fbdev->info.screen_base = fbdev->fb_mem;
+	fbdev->info.fbops = &au1100fb_ops;
+	fbdev->info.fix = au1100fb_fix;
+
+	if (!(fbdev->info.pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	memset(fbdev->info.pseudo_palette, 0, sizeof(u32) * 16);
+
+	if (fb_alloc_cmap(&fbdev->info.cmap, AU1100_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {
+		print_err("Fail to allocate colormap (%d entries)",
+			   AU1100_LCD_NBR_PALETTE_ENTRIES);
+		kfree(fbdev->info.pseudo_palette);
+		return -EFAULT;
+	}
+
+	fbdev->info.var = au1100fb_var;
+
+	/* Set h/w registers */
+	au1100fb_setmode(fbdev);
+
+	/* Register new framebuffer */
+	if (register_framebuffer(&fbdev->info) < 0) {
+		print_err("cannot register new framebuffer");
+		goto failed;
+	}
 
 	return 0;
-}
 
+failed:
+	if (fbdev->regs) {
+		release_mem_region(fbdev->regs_phys, fbdev->regs_len);
+	}
+	if (fbdev->fb_mem) {
+		dma_free_noncoherent(dev, fbdev->fb_len, fbdev->fb_mem, fbdev->fb_phys);
+	}
+	if (fbdev->info.cmap.len != 0) {
+		fb_dealloc_cmap(&fbdev->info.cmap);
+	}
+	kfree(fbdev);
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
 
-void au1100fb_cleanup(struct fb_info *info)
+int au1100fb_drv_remove(struct device *dev)
 {
-	unregister_framebuffer(info);
+	struct au1100fb_device *fbdev = NULL;
+
+	if (!dev)
+		return -ENODEV;
+
+	fbdev = (struct au1100fb_device*) dev_get_drvdata(dev);
+
+#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)
+	au1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);
+#endif
+	fbdev->regs->lcd_control &= ~LCD_CONTROL_GO;
+
+	/* Clean up all probe data */
+	unregister_framebuffer(&fbdev->info);
+
+	release_mem_region(fbdev->regs_phys, fbdev->regs_len);
+
+	dma_free_coherent(dev, PAGE_ALIGN(fbdev->fb_len), fbdev->fb_mem, fbdev->fb_phys);
+
+	fb_dealloc_cmap(&fbdev->info.cmap);
+	kfree(fbdev->info.pseudo_palette);
+	kfree((void*)fbdev);
+
+	return 0;
 }
 
+int au1100fb_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	/* TODO */
+	return 0;
+}
 
-void au1100fb_setup(char *options, int *ints)
+int au1100fb_drv_resume(struct device *dev, u32 level)
 {
-	char* this_opt;
-	int i;
-	int num_panels = sizeof(panels)/sizeof(struct known_lcd_panels);
+	/* TODO */
+	return 0;
+}
 
+static struct device_driver au1100fb_driver = {
+	.name		= "au1100-lcd",
+	.bus		= &platform_bus_type,
+
+	.probe		= au1100fb_drv_probe,
+        .remove		= au1100fb_drv_remove,
+	.suspend	= au1100fb_drv_suspend,
+        .resume		= au1100fb_drv_resume,
+};
+    
+/*-------------------------------------------------------------------------*/
 
-	if (!options || !*options)
-		return;
+/* Kernel driver */
+    
+int au1100fb_setup(char *options)
+{
+	char* this_opt;
+	int num_panels = ARRAY_SIZE(known_lcd_panels);
+	char* mode = NULL;
+	int panel_idx = 0;
+
+	if (num_panels <= 0) {
+		print_err("No LCD panels supported by driver!");
+		return -EFAULT;
+			}
 
-	for(this_opt=strtok(options, ","); this_opt;
-	    this_opt=strtok(NULL, ",")) {
+	if (options) {
+		while ((this_opt = strsep(&options,",")) != NULL) {
+			/* Panel option */
 		if (!strncmp(this_opt, "panel:", 6)) {
-#if defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_DB1100)
-			/* Read Pb1100 Switch S10 ? */
-			if (!strncmp(this_opt+6, "s10", 3))
-			{
-				int panel;
-				panel = *(volatile int *)0xAE000008; /* BCSR SWITCHES */
-				panel >>= 8;
-				panel &= 0x0F;
-				if (panel >= num_panels) panel = 0;
-				my_lcd_index = panel;
-			}
-			else
-#endif
-			/* Get the panel name, everything else if fixed */
-			for (i=0; i<num_panels; i++) {
-				if (!strncmp(this_opt+6, panels[i].panel_name,
+				int i;
+				this_opt += 6;
+				for (i = 0; i < num_panels; i++) {
+					if (!strncmp(this_opt,
+					      	     known_lcd_panels[i].name, 
 							strlen(this_opt))) {
-					my_lcd_index = i;
+						panel_idx = i;
 					break;
 				}
 			}
+				if (i >= num_panels) {
+ 					print_warn("Panel %s not supported!", this_opt);
+				}
+			}
+			/* Mode option (only option that start with digit) */
+			else if (isdigit(this_opt[0])) {
+				mode = kmalloc(strlen(this_opt) + 1, GFP_KERNEL);
+				strncpy(mode, this_opt, strlen(this_opt) + 1);
+			}
+			/* Unsupported option */
+			else {
+				print_warn("Unsupported option \"%s\"", this_opt);
 		}
-		else if (!strncmp(this_opt, "nohwcursor", 10)) {
-			printk("nohwcursor\n");
-			fb_info.nohwcursor = 1;
 		}
-	}
+	} 
 
-	printk("au1100fb: Panel %d %s\n", my_lcd_index,
-		panels[my_lcd_index].panel_name);
-}
+	drv_info.panel_idx = panel_idx;
+	drv_info.opt_mode = mode;
 
+	print_info("Panel=%s Mode=%s",
+			known_lcd_panels[drv_info.panel_idx].name,
+		      	drv_info.opt_mode ? drv_info.opt_mode : "default");
 
+	return 0;
+}
 
-#ifdef MODULE
-MODULE_LICENSE("GPL");
-int init_module(void)
+int __init au1100fb_init(void)
 {
-	return au1100fb_init();
+	char* options;
+	int ret;
+	
+	print_info("" DRIVER_DESC "");
+	
+	memset(&drv_info, 0, sizeof(drv_info));
+
+	if (fb_get_options(DRIVER_NAME, &options))
+		return -ENODEV;
+
+	/* Setup driver with options */
+	ret = au1100fb_setup(options);
+	if (ret < 0) {
+		print_err("Fail to setup driver");
+		return ret;
+	}
+
+	return driver_register(&au1100fb_driver);
 }
 
-void cleanup_module(void)
+void __exit au1100fb_cleanup(void)
 {
-	au1100fb_cleanup(void);
+	driver_unregister(&au1100fb_driver);
+
+	if (drv_info.opt_mode)
+		kfree(drv_info.opt_mode);
 }
 
-MODULE_AUTHOR("Pete Popov <ppopov@mvista.com>");
-MODULE_DESCRIPTION("Au1100 LCD framebuffer device driver");
-#endif /* MODULE */
+module_init(au1100fb_init);
+module_exit(au1100fb_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/drivers/video/au1100fb.h linux-mips-2.6.14.orig/drivers/video/au1100fb.h
--- linux-2.6.14/drivers/video/au1100fb.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/video/au1100fb.h	2005-11-17 11:43:49.000000000 -0800
@@ -30,352 +30,352 @@
 #ifndef _AU1100LCD_H
 #define _AU1100LCD_H
 
+#include <asm/mach-au1x00/au1000.h>
+
+#define print_err(f, arg...) printk(KERN_ERR DRIVER_NAME ": " f "\n", ## arg)
+#define print_warn(f, arg...) printk(KERN_WARNING DRIVER_NAME ": " f "\n", ## arg)
+#define print_info(f, arg...) printk(KERN_INFO DRIVER_NAME ": " f "\n", ## arg)
+
+#if DEBUG
+#define print_dbg(f, arg...) printk(__FILE__ ": " f "\n", ## arg)
+#else
+#define print_dbg(f, arg...) do {} while (0)
+#endif
+
+#if defined(__BIG_ENDIAN)
+#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_11
+#else
+#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_00
+#endif
+#define LCD_CONTROL_DEFAULT_SBPPF LCD_CONTROL_SBPPF_565
+
 /********************************************************************/
-#define uint32 unsigned long
-typedef volatile struct
-{
-	uint32	lcd_control;
-	uint32	lcd_intstatus;
-	uint32	lcd_intenable;
-	uint32	lcd_horztiming;
-	uint32	lcd_verttiming;
-	uint32	lcd_clkcontrol;
-	uint32	lcd_dmaaddr0;
-	uint32	lcd_dmaaddr1;
-	uint32	lcd_words;
-	uint32	lcd_pwmdiv;
-	uint32	lcd_pwmhi;
-	uint32	reserved[(0x0400-0x002C)/4];
-	uint32	lcd_pallettebase[256];
 
-} AU1100_LCD;
+/* LCD controller restrictions */
+#define AU1100_LCD_MAX_XRES	800
+#define AU1100_LCD_MAX_YRES	600
+#define AU1100_LCD_MAX_BPP	16
+#define AU1100_LCD_MAX_CLK	48000000
+#define AU1100_LCD_NBR_PALETTE_ENTRIES 256
+
+/* Default number of visible screen buffer to allocate */
+#define AU1100FB_NBR_VIDEO_BUFFERS 4
 
 /********************************************************************/
 
-#define AU1100_LCD_ADDR		0xB5000000
+struct au1100fb_panel
+{
+	const char name[25];		/* Full name <vendor>_<model> */
 
-/*
- * Register bit definitions
- */
+	u32   	control_base;		/* Mode-independent control values */
+	u32	clkcontrol_base;	/* Panel pixclock preferences */
 
-/* lcd_control */
-#define LCD_CONTROL_SBPPF		(7<<18)
-#define LCD_CONTROL_SBPPF_655	(0<<18)
-#define LCD_CONTROL_SBPPF_565	(1<<18)
-#define LCD_CONTROL_SBPPF_556	(2<<18)
-#define LCD_CONTROL_SBPPF_1555	(3<<18)
-#define LCD_CONTROL_SBPPF_5551	(4<<18)
-#define LCD_CONTROL_WP			(1<<17)
-#define LCD_CONTROL_WD			(1<<16)
-#define LCD_CONTROL_C			(1<<15)
-#define LCD_CONTROL_SM			(3<<13)
-#define LCD_CONTROL_SM_0		(0<<13)
-#define LCD_CONTROL_SM_90		(1<<13)
-#define LCD_CONTROL_SM_180		(2<<13)
-#define LCD_CONTROL_SM_270		(3<<13)
-#define LCD_CONTROL_DB			(1<<12)
-#define LCD_CONTROL_CCO			(1<<11)
-#define LCD_CONTROL_DP			(1<<10)
-#define LCD_CONTROL_PO			(3<<8)
-#define LCD_CONTROL_PO_00		(0<<8)
-#define LCD_CONTROL_PO_01		(1<<8)
-#define LCD_CONTROL_PO_10		(2<<8)
-#define LCD_CONTROL_PO_11		(3<<8)
-#define LCD_CONTROL_MPI			(1<<7)
-#define LCD_CONTROL_PT			(1<<6)
-#define LCD_CONTROL_PC			(1<<5)
-#define LCD_CONTROL_BPP			(7<<1)
-#define LCD_CONTROL_BPP_1		(0<<1)
-#define LCD_CONTROL_BPP_2		(1<<1)
-#define LCD_CONTROL_BPP_4		(2<<1)
-#define LCD_CONTROL_BPP_8		(3<<1)
-#define LCD_CONTROL_BPP_12		(4<<1)
-#define LCD_CONTROL_BPP_16		(5<<1)
-#define LCD_CONTROL_GO			(1<<0)
-
-/* lcd_intstatus, lcd_intenable */
-#define LCD_INT_SD				(1<<7)
-#define LCD_INT_OF				(1<<6)
-#define LCD_INT_UF				(1<<5)
-#define LCD_INT_SA				(1<<3)
-#define LCD_INT_SS				(1<<2)
-#define LCD_INT_S1				(1<<1)
-#define LCD_INT_S0				(1<<0)
-
-/* lcd_horztiming */
-#define LCD_HORZTIMING_HN2		(255<<24)
-#define LCD_HORZTIMING_HN2_N(N)	(((N)-1)<<24)
-#define LCD_HORZTIMING_HN1		(255<<16)
-#define LCD_HORZTIMING_HN1_N(N)	(((N)-1)<<16)
-#define LCD_HORZTIMING_HPW		(63<<10)
-#define LCD_HORZTIMING_HPW_N(N)	(((N)-1)<<10)
-#define LCD_HORZTIMING_PPL		(1023<<0)
-#define LCD_HORZTIMING_PPL_N(N)	(((N)-1)<<0)
-
-/* lcd_verttiming */
-#define LCD_VERTTIMING_VN2		(255<<24)
-#define LCD_VERTTIMING_VN2_N(N)	(((N)-1)<<24)
-#define LCD_VERTTIMING_VN1		(255<<16)
-#define LCD_VERTTIMING_VN1_N(N)	(((N)-1)<<16)
-#define LCD_VERTTIMING_VPW		(63<<10)
-#define LCD_VERTTIMING_VPW_N(N)	(((N)-1)<<10)
-#define LCD_VERTTIMING_LPP		(1023<<0)
-#define LCD_VERTTIMING_LPP_N(N)	(((N)-1)<<0)
-
-/* lcd_clkcontrol */
-#define LCD_CLKCONTROL_IB		(1<<18)
-#define LCD_CLKCONTROL_IC		(1<<17)
-#define LCD_CLKCONTROL_IH		(1<<16)
-#define LCD_CLKCONTROL_IV		(1<<15)
-#define LCD_CLKCONTROL_BF		(31<<10)
-#define LCD_CLKCONTROL_BF_N(N)	(((N)-1)<<10)
-#define LCD_CLKCONTROL_PCD		(1023<<0)
-#define LCD_CLKCONTROL_PCD_N(N)	((N)<<0)
-
-/* lcd_pwmdiv */
-#define LCD_PWMDIV_EN			(1<<12)
-#define LCD_PWMDIV_PWMDIV		(2047<<0)
-#define LCD_PWMDIV_PWMDIV_N(N)	(((N)-1)<<0)
-
-/* lcd_pwmhi */
-#define LCD_PWMHI_PWMHI1		(2047<<12)
-#define LCD_PWMHI_PWMHI1_N(N)	((N)<<12)
-#define LCD_PWMHI_PWMHI0		(2047<<0)
-#define LCD_PWMHI_PWMHI0_N(N)	((N)<<0)
-
-/* lcd_pallettebase - MONOCHROME */
-#define LCD_PALLETTE_MONO_MI		(15<<0)
-#define LCD_PALLETTE_MONO_MI_N(N)	((N)<<0)
-
-/* lcd_pallettebase - COLOR */
-#define LCD_PALLETTE_COLOR_BI		(15<<8)
-#define LCD_PALLETTE_COLOR_BI_N(N)	((N)<<8)
-#define LCD_PALLETTE_COLOR_GI		(15<<4)
-#define LCD_PALLETTE_COLOR_GI_N(N)	((N)<<4)
-#define LCD_PALLETTE_COLOR_RI		(15<<0)
-#define LCD_PALLETTE_COLOR_RI_N(N)	((N)<<0)
-
-/* lcd_palletebase - COLOR TFT PALLETIZED */
-#define LCD_PALLETTE_TFT_DC			(65535<<0)
-#define LCD_PALLETTE_TFT_DC_N(N)	((N)<<0)
+	u32	horztiming;
+	u32	verttiming;
 
-/********************************************************************/
+	u32	xres;		/* Maximum horizontal resolution */
+	u32 	yres;		/* Maximum vertical resolution */
+	u32 	bpp;		/* Maximum depth supported */
+};
 
-struct known_lcd_panels
+struct au1100fb_regs 
 {
-	uint32 xres;
-	uint32 yres;
-	uint32 bpp;
-	unsigned char  panel_name[256];
-	uint32 mode_control;
-	uint32 mode_horztiming;
-	uint32 mode_verttiming;
-	uint32 mode_clkcontrol;
-	uint32 mode_pwmdiv;
-	uint32 mode_pwmhi;
-	uint32 mode_toyclksrc;
-	uint32 mode_backlight;
+	u32  lcd_control;
+	u32  lcd_intstatus;
+	u32  lcd_intenable;
+	u32  lcd_horztiming;
+	u32  lcd_verttiming;
+	u32  lcd_clkcontrol;
+	u32  lcd_dmaaddr0;
+	u32  lcd_dmaaddr1;
+	u32  lcd_words;
+	u32  lcd_pwmdiv;
+	u32  lcd_pwmhi;
+	u32  reserved[(0x0400-0x002C)/4];
+	u32  lcd_pallettebase[256];
+};
+
+struct au1100fb_device {
+
+	struct fb_info info;			/* FB driver info record */
+
+	struct au1100fb_panel 	*panel;		/* Panel connected to this device */
 
+	struct au1100fb_regs* 	regs;		/* Registers memory map */
+	size_t       		regs_len;
+	unsigned int 		regs_phys;
+
+	unsigned char* 		fb_mem;		/* FrameBuffer memory map */
+	size_t	      		fb_len;
+	dma_addr_t    		fb_phys;
 };
 
-#if defined(__BIG_ENDIAN)
-#define LCD_DEFAULT_PIX_FORMAT LCD_CONTROL_PO_11
-#else
-#define LCD_DEFAULT_PIX_FORMAT LCD_CONTROL_PO_00
-#endif
+/********************************************************************/
 
-/*
- * The fb driver assumes that AUX PLL is at 48MHz.  That can
- * cover up to 800x600 resolution; if you need higher resolution,
- * you should modify the driver as needed, not just this structure.
+#define LCD_CONTROL                (AU1100_LCD_BASE + 0x0)
+  #define LCD_CONTROL_SBB_BIT      21
+  #define LCD_CONTROL_SBB_MASK     (0x3 << LCD_CONTROL_SBB_BIT)
+    #define LCD_CONTROL_SBB_1        (0 << LCD_CONTROL_SBB_BIT)
+    #define LCD_CONTROL_SBB_2        (1 << LCD_CONTROL_SBB_BIT)
+    #define LCD_CONTROL_SBB_3        (2 << LCD_CONTROL_SBB_BIT)
+    #define LCD_CONTROL_SBB_4        (3 << LCD_CONTROL_SBB_BIT)
+  #define LCD_CONTROL_SBPPF_BIT    18
+  #define LCD_CONTROL_SBPPF_MASK   (0x7 << LCD_CONTROL_SBPPF_BIT)
+    #define LCD_CONTROL_SBPPF_655    (0 << LCD_CONTROL_SBPPF_BIT)
+    #define LCD_CONTROL_SBPPF_565    (1 << LCD_CONTROL_SBPPF_BIT)
+    #define LCD_CONTROL_SBPPF_556    (2 << LCD_CONTROL_SBPPF_BIT)
+    #define LCD_CONTROL_SBPPF_1555   (3 << LCD_CONTROL_SBPPF_BIT)
+    #define LCD_CONTROL_SBPPF_5551   (4 << LCD_CONTROL_SBPPF_BIT)
+  #define LCD_CONTROL_WP           (1<<17)
+  #define LCD_CONTROL_WD           (1<<16)
+  #define LCD_CONTROL_C            (1<<15)
+  #define LCD_CONTROL_SM_BIT       13
+  #define LCD_CONTROL_SM_MASK      (0x3 << LCD_CONTROL_SM_BIT)
+    #define LCD_CONTROL_SM_0         (0 << LCD_CONTROL_SM_BIT)
+    #define LCD_CONTROL_SM_90        (1 << LCD_CONTROL_SM_BIT)
+    #define LCD_CONTROL_SM_180       (2 << LCD_CONTROL_SM_BIT)
+    #define LCD_CONTROL_SM_270       (3 << LCD_CONTROL_SM_BIT)
+  #define LCD_CONTROL_DB           (1<<12)
+  #define LCD_CONTROL_CCO          (1<<11)
+  #define LCD_CONTROL_DP           (1<<10)
+  #define LCD_CONTROL_PO_BIT       8
+  #define LCD_CONTROL_PO_MASK      (0x3 << LCD_CONTROL_PO_BIT)
+    #define LCD_CONTROL_PO_00        (0 << LCD_CONTROL_PO_BIT)
+    #define LCD_CONTROL_PO_01        (1 << LCD_CONTROL_PO_BIT)
+    #define LCD_CONTROL_PO_10        (2 << LCD_CONTROL_PO_BIT)
+    #define LCD_CONTROL_PO_11        (3 << LCD_CONTROL_PO_BIT)
+  #define LCD_CONTROL_MPI          (1<<7)
+  #define LCD_CONTROL_PT           (1<<6)
+  #define LCD_CONTROL_PC           (1<<5)
+  #define LCD_CONTROL_BPP_BIT      1
+  #define LCD_CONTROL_BPP_MASK     (0x7 << LCD_CONTROL_BPP_BIT)
+    #define LCD_CONTROL_BPP_1        (0 << LCD_CONTROL_BPP_BIT)
+    #define LCD_CONTROL_BPP_2        (1 << LCD_CONTROL_BPP_BIT)
+    #define LCD_CONTROL_BPP_4        (2 << LCD_CONTROL_BPP_BIT)
+    #define LCD_CONTROL_BPP_8        (3 << LCD_CONTROL_BPP_BIT)
+    #define LCD_CONTROL_BPP_12       (4 << LCD_CONTROL_BPP_BIT)
+    #define LCD_CONTROL_BPP_16       (5 << LCD_CONTROL_BPP_BIT)
+  #define LCD_CONTROL_GO           (1<<0)
+
+#define LCD_INTSTATUS              (AU1100_LCD_BASE + 0x4)
+#define LCD_INTENABLE              (AU1100_LCD_BASE + 0x8)
+  #define LCD_INT_SD               (1<<7)
+  #define LCD_INT_OF               (1<<6)
+  #define LCD_INT_UF               (1<<5)
+  #define LCD_INT_SA               (1<<3)
+  #define LCD_INT_SS               (1<<2)
+  #define LCD_INT_S1               (1<<1)
+  #define LCD_INT_S0               (1<<0)
+
+#define LCD_HORZTIMING             (AU1100_LCD_BASE + 0xC)
+  #define LCD_HORZTIMING_HN2_BIT   24
+  #define LCD_HORZTIMING_HN2_MASK  (0xFF << LCD_HORZTIMING_HN2_BIT)
+  #define LCD_HORZTIMING_HN2_N(N)  ((((N)-1) << LCD_HORZTIMING_HN2_BIT) & LCD_HORZTIMING_HN2_MASK)
+  #define LCD_HORZTIMING_HN1_BIT   16
+  #define LCD_HORZTIMING_HN1_MASK  (0xFF << LCD_HORZTIMING_HN1_BIT)
+  #define LCD_HORZTIMING_HN1_N(N)  ((((N)-1) << LCD_HORZTIMING_HN1_BIT) & LCD_HORZTIMING_HN1_MASK)
+  #define LCD_HORZTIMING_HPW_BIT   10
+  #define LCD_HORZTIMING_HPW_MASK  (0x3F << LCD_HORZTIMING_HPW_BIT)
+  #define LCD_HORZTIMING_HPW_N(N)  ((((N)-1) << LCD_HORZTIMING_HPW_BIT) & LCD_HORZTIMING_HPW_MASK)
+  #define LCD_HORZTIMING_PPL_BIT   0
+  #define LCD_HORZTIMING_PPL_MASK  (0x3FF << LCD_HORZTIMING_PPL_BIT)
+  #define LCD_HORZTIMING_PPL_N(N)  ((((N)-1) << LCD_HORZTIMING_PPL_BIT) & LCD_HORZTIMING_PPL_MASK)
+
+#define LCD_VERTTIMING             (AU1100_LCD_BASE + 0x10)
+  #define LCD_VERTTIMING_VN2_BIT   24
+  #define LCD_VERTTIMING_VN2_MASK  (0xFF << LCD_VERTTIMING_VN2_BIT)
+  #define LCD_VERTTIMING_VN2_N(N)  ((((N)-1) << LCD_VERTTIMING_VN2_BIT) & LCD_VERTTIMING_VN2_MASK)
+  #define LCD_VERTTIMING_VN1_BIT   16
+  #define LCD_VERTTIMING_VN1_MASK  (0xFF << LCD_VERTTIMING_VN1_BIT)
+  #define LCD_VERTTIMING_VN1_N(N)  ((((N)-1) << LCD_VERTTIMING_VN1_BIT) & LCD_VERTTIMING_VN1_MASK)
+  #define LCD_VERTTIMING_VPW_BIT   10
+  #define LCD_VERTTIMING_VPW_MASK  (0x3F << LCD_VERTTIMING_VPW_BIT)
+  #define LCD_VERTTIMING_VPW_N(N)  ((((N)-1) << LCD_VERTTIMING_VPW_BIT) & LCD_VERTTIMING_VPW_MASK)
+  #define LCD_VERTTIMING_LPP_BIT   0
+  #define LCD_VERTTIMING_LPP_MASK  (0x3FF << LCD_VERTTIMING_LPP_BIT)
+  #define LCD_VERTTIMING_LPP_N(N)  ((((N)-1) << LCD_VERTTIMING_LPP_BIT) & LCD_VERTTIMING_LPP_MASK)
+
+#define LCD_CLKCONTROL             (AU1100_LCD_BASE + 0x14)
+  #define LCD_CLKCONTROL_IB        (1<<18)
+  #define LCD_CLKCONTROL_IC        (1<<17)
+  #define LCD_CLKCONTROL_IH        (1<<16)
+  #define LCD_CLKCONTROL_IV        (1<<15)
+  #define LCD_CLKCONTROL_BF_BIT    10
+  #define LCD_CLKCONTROL_BF_MASK   (0x1F << LCD_CLKCONTROL_BF_BIT)
+  #define LCD_CLKCONTROL_BF_N(N)   ((((N)-1) << LCD_CLKCONTROL_BF_BIT) & LCD_CLKCONTROL_BF_MASK)
+  #define LCD_CLKCONTROL_PCD_BIT   0
+  #define LCD_CLKCONTROL_PCD_MASK  (0x3FF << LCD_CLKCONTROL_PCD_BIT)
+  #define LCD_CLKCONTROL_PCD_N(N)  (((N) << LCD_CLKCONTROL_PCD_BIT) & LCD_CLKCONTROL_PCD_MASK)
+
+#define LCD_DMAADDR0               (AU1100_LCD_BASE + 0x18)
+#define LCD_DMAADDR1               (AU1100_LCD_BASE + 0x1C)
+  #define LCD_DMA_SA_BIT           5
+  #define LCD_DMA_SA_MASK          (0x7FFFFFF << LCD_DMA_SA_BIT)
+  #define LCD_DMA_SA_N(N)          ((N) & LCD_DMA_SA_MASK)
+
+#define LCD_WORDS                  (AU1100_LCD_BASE + 0x20)
+  #define LCD_WRD_WRDS_BIT         0
+  #define LCD_WRD_WRDS_MASK        (0xFFFFFFFF << LCD_WRD_WRDS_BIT)
+  #define LCD_WRD_WRDS_N(N)        ((((N)-1) << LCD_WRD_WRDS_BIT) & LCD_WRD_WRDS_MASK)
+
+#define LCD_PWMDIV                 (AU1100_LCD_BASE + 0x24)
+  #define LCD_PWMDIV_EN            (1<<12)
+  #define LCD_PWMDIV_PWMDIV_BIT    0
+  #define LCD_PWMDIV_PWMDIV_MASK   (0xFFF << LCD_PWMDIV_PWMDIV_BIT)
+  #define LCD_PWMDIV_PWMDIV_N(N)   ((((N)-1) << LCD_PWMDIV_PWMDIV_BIT) & LCD_PWMDIV_PWMDIV_MASK)
+
+#define LCD_PWMHI                  (AU1100_LCD_BASE + 0x28)
+  #define LCD_PWMHI_PWMHI1_BIT     12
+  #define LCD_PWMHI_PWMHI1_MASK    (0xFFF << LCD_PWMHI_PWMHI1_BIT)
+  #define LCD_PWMHI_PWMHI1_N(N)    (((N) << LCD_PWMHI_PWMHI1_BIT) & LCD_PWMHI_PWMHI1_MASK)
+  #define LCD_PWMHI_PWMHI0_BIT     0
+  #define LCD_PWMHI_PWMHI0_MASK    (0xFFF << LCD_PWMHI_PWMHI0_BIT)
+  #define LCD_PWMHI_PWMHI0_N(N)    (((N) << LCD_PWMHI_PWMHI0_BIT) & LCD_PWMHI_PWMHI0_MASK)
+
+#define LCD_PALLETTEBASE                (AU1100_LCD_BASE + 0x400)
+  #define LCD_PALLETTE_MONO_MI_BIT      0
+  #define LCD_PALLETTE_MONO_MI_MASK     (0xF << LCD_PALLETTE_MONO_MI_BIT)
+  #define LCD_PALLETTE_MONO_MI_N(N)     (((N)<< LCD_PALLETTE_MONO_MI_BIT) & LCD_PALLETTE_MONO_MI_MASK)
+
+  #define LCD_PALLETTE_COLOR_RI_BIT     8
+  #define LCD_PALLETTE_COLOR_RI_MASK    (0xF << LCD_PALLETTE_COLOR_RI_BIT)
+  #define LCD_PALLETTE_COLOR_RI_N(N)    (((N)<< LCD_PALLETTE_COLOR_RI_BIT) & LCD_PALLETTE_COLOR_RI_MASK)
+  #define LCD_PALLETTE_COLOR_GI_BIT     4
+  #define LCD_PALLETTE_COLOR_GI_MASK    (0xF << LCD_PALLETTE_COLOR_GI_BIT)
+  #define LCD_PALLETTE_COLOR_GI_N(N)    (((N)<< LCD_PALLETTE_COLOR_GI_BIT) & LCD_PALLETTE_COLOR_GI_MASK)
+  #define LCD_PALLETTE_COLOR_BI_BIT     0
+  #define LCD_PALLETTE_COLOR_BI_MASK    (0xF << LCD_PALLETTE_COLOR_BI_BIT)
+  #define LCD_PALLETTE_COLOR_BI_N(N)    (((N)<< LCD_PALLETTE_COLOR_BI_BIT) & LCD_PALLETTE_COLOR_BI_MASK)
+
+  #define LCD_PALLETTE_TFT_DC_BIT       0
+  #define LCD_PALLETTE_TFT_DC_MASK      (0xFFFF << LCD_PALLETTE_TFT_DC_BIT)
+  #define LCD_PALLETTE_TFT_DC_N(N)      (((N)<< LCD_PALLETTE_TFT_DC_BIT) & LCD_PALLETTE_TFT_DC_MASK)
+
+/********************************************************************/
+
+/* List of panels known to work with the AU1100 LCD controller.
+ * To add a new panel, enter the same specifications as the
+ * Generic_TFT one, and MAKE SURE that it doesn't conflicts 
+ * with the controller restrictions. Restrictions are:
+ *
+ * STN color panels: max_bpp <= 12
+ * STN mono panels: max_bpp <= 4
+ * TFT panels: max_bpp <= 16
+ * max_xres <= 800
+ * max_yres <= 600
  */
-struct known_lcd_panels panels[] =
+static struct au1100fb_panel known_lcd_panels[] =
 {
-	{ /* 0: Pb1100 LCDA: Sharp 320x240 TFT panel */
-		320, /* xres */
-		240, /* yres */
-		16,  /* bpp  */
-
-		"Sharp_320x240_16",
-		/* mode_control */
+	/* 800x600x16bpp CRT */
+	[0] = {
+		.name = "CRT_800x600_16",
+		.xres = 800,
+		.yres = 600,
+		.bpp = 16,
+		.control_base =	0x0004886A | 
+			LCD_CONTROL_DEFAULT_PO | LCD_CONTROL_DEFAULT_SBPPF |
+			LCD_CONTROL_BPP_16,
+		.clkcontrol_base = 0x00020000,
+		.horztiming = 0x005aff1f,
+		.verttiming = 0x16000e57,
+	},
+	/* just the standard LCD */
+	[1] = {
+		.name = "WWPC LCD",
+		.xres = 240,
+		.yres = 320,
+		.bpp = 16,
+		.control_base = 0x0006806A,
+		.horztiming = 0x0A1010EF,
+		.verttiming = 0x0301013F,
+		.clkcontrol_base = 0x00018001,
+	},
+	/* Sharp 320x240 TFT panel */
+	[2] = {
+		.name = "Sharp_LQ038Q5DR01",
+		.xres = 320,
+		.yres = 240,
+		.bpp = 16,
+		.control_base =
 		( LCD_CONTROL_SBPPF_565
-		/*LCD_CONTROL_WP*/
-		/*LCD_CONTROL_WD*/
 		| LCD_CONTROL_C
 		| LCD_CONTROL_SM_0
-		/*LCD_CONTROL_DB*/
-		/*LCD_CONTROL_CCO*/
-		/*LCD_CONTROL_DP*/
-		| LCD_DEFAULT_PIX_FORMAT
-		/*LCD_CONTROL_MPI*/
+			| LCD_CONTROL_DEFAULT_PO
 		| LCD_CONTROL_PT
 		| LCD_CONTROL_PC
 		| LCD_CONTROL_BPP_16 ),
-
-		/* mode_horztiming */
+		.horztiming =
 		( LCD_HORZTIMING_HN2_N(8)
 		| LCD_HORZTIMING_HN1_N(60)
 		| LCD_HORZTIMING_HPW_N(12)
 		| LCD_HORZTIMING_PPL_N(320) ),
-
-		/* mode_verttiming */
+		.verttiming =
 		( LCD_VERTTIMING_VN2_N(5)
 		| LCD_VERTTIMING_VN1_N(17)
 		| LCD_VERTTIMING_VPW_N(1)
 		| LCD_VERTTIMING_LPP_N(240) ),
-
-		/* mode_clkcontrol */
-		( 0
-		/*LCD_CLKCONTROL_IB*/
-		/*LCD_CLKCONTROL_IC*/
-		/*LCD_CLKCONTROL_IH*/
-		/*LCD_CLKCONTROL_IV*/
-		| LCD_CLKCONTROL_PCD_N(1) ),
-
-		/* mode_pwmdiv */
-		0,
-
-		/* mode_pwmhi */
-		0,
-
-		/* mode_toyclksrc */
-		((1<<7) | (1<<6) | (1<<5)),
-
-		/* mode_backlight */
-		6
+		.clkcontrol_base = LCD_CLKCONTROL_PCD_N(1),
 	},
 
-	{ /* 1: Pb1100 LCDC 640x480 TFT panel */
-		640, /* xres */
-		480, /* yres */
-		16,  /* bpp  */
-
-		"Generic_640x480_16",
-
-		/* mode_control */
-		0x004806a | LCD_DEFAULT_PIX_FORMAT,
-
-		/* mode_horztiming */
-		0x3434d67f,
-
-		/* mode_verttiming */
-		0x0e0e39df,
-
-		/* mode_clkcontrol */
-		( 0
-		/*LCD_CLKCONTROL_IB*/
-		/*LCD_CLKCONTROL_IC*/
-		/*LCD_CLKCONTROL_IH*/
-		/*LCD_CLKCONTROL_IV*/
-		| LCD_CLKCONTROL_PCD_N(1) ),
-
-		/* mode_pwmdiv */
-		0,
-
-		/* mode_pwmhi */
-		0,
-
-		/* mode_toyclksrc */
-		((1<<7) | (1<<6) | (0<<5)),
-
-		/* mode_backlight */
-		7
+	/* Hitachi SP14Q005 and possibly others */
+	[3] = {
+		.name = "Hitachi_SP14Qxxx",
+		.xres = 320,
+		.yres = 240,
+		.bpp = 4,
+		.control_base =
+			( LCD_CONTROL_C
+			| LCD_CONTROL_BPP_4 ),
+		.horztiming =
+			( LCD_HORZTIMING_HN2_N(1)
+			| LCD_HORZTIMING_HN1_N(1)
+			| LCD_HORZTIMING_HPW_N(1)
+			| LCD_HORZTIMING_PPL_N(320) ),
+		.verttiming =
+			( LCD_VERTTIMING_VN2_N(1)
+			| LCD_VERTTIMING_VN1_N(1)
+			| LCD_VERTTIMING_VPW_N(1)
+			| LCD_VERTTIMING_LPP_N(240) ),
+		.clkcontrol_base = LCD_CLKCONTROL_PCD_N(4),
 	},
 
-	{ /* 2: Pb1100 LCDB 640x480 PrimeView TFT panel */
-		640, /* xres */
-		480, /* yres */
-		16,  /* bpp  */
-
-		"PrimeView_640x480_16",
-
-		/* mode_control */
-		0x0004886a | LCD_DEFAULT_PIX_FORMAT,
-
-		/* mode_horztiming */
-		0x0e4bfe7f,
-
-		/* mode_verttiming */
-		0x210805df,
-
-		/* mode_clkcontrol */
-		0x00038001,
-
-		/* mode_pwmdiv */
-		0,
-
-		/* mode_pwmhi */
-		0,
-
-		/* mode_toyclksrc */
-		((1<<7) | (1<<6) | (0<<5)),
-
-		/* mode_backlight */
-		7
+	/* Generic 640x480 TFT panel */
+	[4] = {
+		.name = "TFT_640x480_16",
+		.xres = 640,
+		.yres = 480,
+		.bpp = 16,
+		.control_base = 0x004806a | LCD_CONTROL_DEFAULT_PO,
+		.horztiming = 0x3434d67f,
+		.verttiming = 0x0e0e39df,
+		.clkcontrol_base = LCD_CLKCONTROL_PCD_N(1),
 	},
 
-	{ /* 3: Pb1100 800x600x16bpp NEON CRT */
-		800, /* xres */
-		600, /* yres */
-		16,  /* bpp */
-
-		"NEON_800x600_16",
-
-		/* mode_control */
-		0x0004886A | LCD_DEFAULT_PIX_FORMAT,
-
-		/* mode_horztiming */
-		0x005AFF1F,
-
-		/* mode_verttiming */
-		0x16000E57,
-
-		/* mode_clkcontrol */
-		0x00020000,
-
-		/* mode_pwmdiv */
-		0,
-
-		/* mode_pwmhi */
-		0,
-
-		/* mode_toyclksrc */
-		((1<<7) | (1<<6) | (0<<5)),
-
-		/* mode_backlight */
-		7
+	 /* Pb1100 LCDB 640x480 PrimeView TFT panel */
+	[5] = {
+		.name = "PrimeView_640x480_16",
+		.xres = 640,
+		.yres = 480,
+		.bpp = 16,
+		.control_base = 0x0004886a | LCD_CONTROL_DEFAULT_PO,
+		.horztiming = 0x0e4bfe7f,
+		.verttiming = 0x210805df,
+		.clkcontrol_base = 0x00038001,
 	},
+};
 
-	{ /* 4: Pb1100 640x480x16bpp NEON CRT */
-		640, /* xres */
-		480, /* yres */
-		16,  /* bpp */
-
-		"NEON_640x480_16",
-
-		/* mode_control */
-		0x0004886A | LCD_DEFAULT_PIX_FORMAT,
-
-		/* mode_horztiming */
-		0x0052E27F,
-
-		/* mode_verttiming */
-		0x18000DDF,
-
-		/* mode_clkcontrol */
-		0x00020000,
+struct au1100fb_drv_info {
+	int	panel_idx;
+	char 	*opt_mode;
+};
 
-		/* mode_pwmdiv */
-		0,
+/********************************************************************/
 
-		/* mode_pwmhi */
-		0,
+/* Inline helpers */
 
-		/* mode_toyclksrc */
-		((1<<7) | (1<<6) | (0<<5)),
+#define panel_is_dual(panel)  (panel->control_base & LCD_CONTROL_DP)
+#define panel_is_active(panel)(panel->control_base & LCD_CONTROL_PT)
+#define panel_is_color(panel) (panel->control_base & LCD_CONTROL_PC)
+#define panel_swap_rgb(panel) (panel->control_base & LCD_CONTROL_CCO)
 
-		/* mode_backlight */
-		7
-	},
-};
 #endif /* _AU1100LCD_H */
diff -Naur linux-2.6.14/drivers/video/au1200fb.c linux-mips-2.6.14.orig/drivers/video/au1200fb.c
--- linux-2.6.14/drivers/video/au1200fb.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/video/au1200fb.c	2005-11-17 11:43:49.000000000 -0800
@@ -0,0 +1,1940 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1200 LCD Driver.
+ *
+ * Copyright 2004-2005 AMD
+ * Author: AMD
+ *
+ * Based on:
+ * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device
+ *  Created 28 Dec 1997 by Geert Uytterhoeven
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/mach-au1x00/au1000.h>
+#include "au1200fb.h"
+
+#ifdef CONFIG_PM
+#include <asm/mach-au1x00/au1xxx_pm.h>
+#endif
+
+#ifndef CONFIG_FB_AU1200_DEVS
+#define CONFIG_FB_AU1200_DEVS 4
+#endif
+
+#define DRIVER_NAME "au1200fb"
+#define DRIVER_DESC "LCD controller driver for AU1200 processors"
+
+#define DEBUG 1
+
+#define print_err(f, arg...) printk(KERN_ERR DRIVER_NAME ": " f "\n", ## arg)
+#define print_warn(f, arg...) printk(KERN_WARNING DRIVER_NAME ": " f "\n", ## arg)
+#define print_info(f, arg...) printk(KERN_INFO DRIVER_NAME ": " f "\n", ## arg)
+
+#if DEBUG
+#define print_dbg(f, arg...) printk(KERN_DEBUG __FILE__ ": " f "\n", ## arg)
+#else
+#define print_dbg(f, arg...) do {} while (0)
+#endif
+
+
+#define AU1200_LCD_FB_IOCTL 0x46FF
+
+#define AU1200_LCD_SET_SCREEN 1
+#define AU1200_LCD_GET_SCREEN 2
+#define AU1200_LCD_SET_WINDOW 3
+#define AU1200_LCD_GET_WINDOW 4
+#define AU1200_LCD_SET_PANEL  5
+#define AU1200_LCD_GET_PANEL  6
+
+#define SCREEN_SIZE		    (1<< 1)
+#define SCREEN_BACKCOLOR    (1<< 2)
+#define SCREEN_BRIGHTNESS   (1<< 3)
+#define SCREEN_COLORKEY     (1<< 4)
+#define SCREEN_MASK         (1<< 5)
+typedef struct au1200_lcd_global_regs_t
+{
+    unsigned int flags;
+    unsigned int xsize;
+    unsigned int ysize;
+    unsigned int backcolor;
+    unsigned int brightness;
+	unsigned int colorkey;
+	unsigned int mask;
+    unsigned int panel_choice;
+    char panel_desc[80];
+
+} au1200_lcd_global_regs_t;
+
+#define WIN_POSITION            (1<< 0)
+#define WIN_ALPHA_COLOR         (1<< 1)
+#define WIN_ALPHA_MODE          (1<< 2)
+#define WIN_PRIORITY            (1<< 3)
+#define WIN_CHANNEL             (1<< 4)
+#define WIN_BUFFER_FORMAT       (1<< 5)
+#define WIN_COLOR_ORDER         (1<< 6)
+#define WIN_PIXEL_ORDER         (1<< 7)
+#define WIN_SIZE                (1<< 8)
+#define WIN_COLORKEY_MODE       (1<< 9)
+#define WIN_DOUBLE_BUFFER_MODE  (1<< 10)
+#define WIN_RAM_ARRAY_MODE      (1<< 11)
+#define WIN_BUFFER_SCALE        (1<< 12)
+#define WIN_ENABLE	            (1<< 13)
+
+typedef struct au1200_lcd_window_regs_t
+{
+    unsigned int flags;
+    unsigned int xpos;
+    unsigned int ypos;
+    unsigned int alpha_color;
+    unsigned int alpha_mode;
+    unsigned int priority;
+    unsigned int channel;
+    unsigned int buffer_format;
+    unsigned int color_order;
+    unsigned int pixel_order;
+    unsigned int xsize;
+    unsigned int ysize;
+    unsigned int colorkey_mode;
+    unsigned int double_buffer_mode;
+    unsigned int ram_array_mode;
+    unsigned int xscale;
+    unsigned int yscale;
+    unsigned int enable;
+} au1200_lcd_window_regs_t;
+
+
+typedef struct au1200_lcd_iodata_t
+{
+
+    unsigned int subcmd;
+    au1200_lcd_global_regs_t global;
+    au1200_lcd_window_regs_t window;
+
+} au1200_lcd_iodata_t;
+
+#if defined(__BIG_ENDIAN)
+#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_11
+#else
+#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_00
+#endif
+#define LCD_CONTROL_DEFAULT_SBPPF LCD_CONTROL_SBPPF_565
+
+/* Private, per-framebuffer management information (independent of the panel itself) */
+struct au1200fb_device {
+	struct fb_info fb_info;			/* FB driver info record */
+
+	int					plane;
+	unsigned char* 		fb_mem;		/* FrameBuffer memory map */
+	unsigned int		fb_len;
+	dma_addr_t    		fb_phys;
+};
+
+static struct au1200fb_device _au1200fb_devices[CONFIG_FB_AU1200_DEVS];
+/********************************************************************/
+
+/* LCD controller restrictions */
+#define AU1200_LCD_MAX_XRES	1280
+#define AU1200_LCD_MAX_YRES	1024
+#define AU1200_LCD_MAX_BPP	32
+#define AU1200_LCD_MAX_CLK	96000000 /* fixme: this needs to go away ? */
+#define AU1200_LCD_NBR_PALETTE_ENTRIES 256
+
+/* Default number of visible screen buffer to allocate */
+#define AU1200FB_NBR_VIDEO_BUFFERS 1
+
+/********************************************************************/
+
+AU1200_LCD *lcd = (AU1200_LCD *)AU1200_LCD_ADDR;
+static int window_index = 2; /* default is zero */
+static int panel_index = 2; /* default is zero */
+static struct window_settings *win;
+static struct panel_settings *panel;
+static int noblanking = 1;
+static int nohwcursor = 0;
+
+struct window_settings
+{
+	unsigned char name[64];
+	uint32 mode_backcolor;
+	uint32 mode_colorkey;
+	uint32 mode_colorkeymsk;
+	struct
+	{
+		int xres;
+		int yres;
+		int xpos;
+		int ypos;
+		uint32 mode_winctrl1; /* winctrl1[FRM,CCO,PO,PIPE] */
+		uint32 mode_winenable;
+	} w[4];
+};
+
+#if defined(__BIG_ENDIAN)
+#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_00
+#else
+#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_01
+#endif
+
+extern int board_au1200fb_panel_init (void);
+extern int board_au1200fb_panel_shutdown (void);
+
+#ifdef CONFIG_PM 
+int au1200fb_pm_callback(au1xxx_power_dev_t *dev, 
+		au1xxx_request_t request, void *data);
+au1xxx_power_dev_t *LCD_pm_dev;
+#endif
+
+/*
+ * Default window configurations
+ */
+static struct window_settings windows[] =
+{
+	{ /* Index 0 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 100, 100, 100, 100,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ LCD_WINENABLE_WEN1,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+
+	{ /* Index 1 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 320, 240, 5, 5,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_24BPP |
+				LCD_WINCTRL1_PO_00,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 
+				| LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 100, 100, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 | 
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 200, 25, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+	{ /* Index 2 */
+		"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx",
+		/* mode_backcolor	*/ 0x006600ff,
+		/* mode_colorkey,msk*/ 0, 0,
+		{
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ LCD_WINENABLE_WEN0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP,
+			/* mode_winenable*/ 0,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_32BPP |
+				LCD_WINCTRL1_PO_00|LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,
+			},
+			{
+			/* xres, yres, xpos, ypos */ 0, 0, 0, 0,
+			/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |
+				LCD_WINCTRL1_PO_16BPP |
+				LCD_WINCTRL1_PIPE,
+			/* mode_winenable*/ 0,
+			},
+		},
+	},
+	/* Need VGA 640 @ 24bpp, @ 32bpp */
+	/* Need VGA 800 @ 24bpp, @ 32bpp */
+	/* Need VGA 1024 @ 24bpp, @ 32bpp */
+} ;
+
+/*
+ * Controller configurations for various panels.
+ */
+
+struct panel_settings
+{
+	const char name[25];		/* Full name <vendor>_<model> */
+
+	struct 	fb_monspecs monspecs; 	/* FB monitor specs */
+
+	/* panel timings */
+	uint32 mode_screen;
+	uint32 mode_horztiming;
+	uint32 mode_verttiming;
+	uint32 mode_clkcontrol;
+	uint32 mode_pwmdiv;
+	uint32 mode_pwmhi;
+	uint32 mode_outmask;
+	uint32 mode_fifoctrl;
+	uint32 mode_toyclksrc;
+	uint32 mode_backlight;
+	uint32 mode_auxpll;
+	int (*device_init)(void);
+	int (*device_shutdown)(void);
+#define Xres min_xres
+#define Yres min_yres
+	u32	min_xres;		/* Minimum horizontal resolution */
+	u32	max_xres;		/* Maximum horizontal resolution */
+	u32 	min_yres;		/* Minimum vertical resolution */
+	u32 	max_yres;		/* Maximum vertical resolution */
+};
+
+/********************************************************************/
+/* fixme: Maybe a modedb for the CRT ? otherwise panels should be as-is */
+
+/* List of panels known to work with the AU1200 LCD controller.
+ * To add a new panel, enter the same specifications as the
+ * Generic_TFT one, and MAKE SURE that it doesn't conflicts 
+ * with the controller restrictions. Restrictions are:
+ *
+ * STN color panels: max_bpp <= 12
+ * STN mono panels: max_bpp <= 4
+ * TFT panels: max_bpp <= 16
+ * max_xres <= 800
+ * max_yres <= 600
+ */
+static struct panel_settings known_lcd_panels[] =
+{
+	[0] = { /* QVGA 320x240 H:33.3kHz V:110Hz */
+		.name = "QVGA_320x240",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000, 
+			.hfmax = 70000,
+			.vfmin = 60, 
+			.vfmax = 60, 
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(320) | 
+			LCD_SCREEN_SY_N(240),
+		.mode_horztiming	= 0x00c4623b,
+		.mode_verttiming	= 0x00502814,
+		.mode_clkcontrol	= 0x00020002, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		320, 320,
+		240, 240,
+	},
+
+	[1] = { /* VGA 640x480 H:30.3kHz V:58Hz */
+		.name = "VGA_640x480",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x13f9df80,
+		.mode_horztiming	= 0x003c5859,
+		.mode_verttiming	= 0x00741201,
+		.mode_clkcontrol	= 0x00020001, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		640, 480,
+		640, 480,
+	},
+
+	[2] = { /* SVGA 800x600 H:46.1kHz V:69Hz */
+		.name = "SVGA_800x600",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x18fa5780,
+		.mode_horztiming	= 0x00dc7e77,
+		.mode_verttiming	= 0x00584805,
+		.mode_clkcontrol	= 0x00020000, /* /2=48Mhz */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		800, 800,
+		600, 600,
+	},
+
+	[3] = { /* XVGA 1024x768 H:56.2kHz V:70Hz */
+		.name = "XVGA_1024x768",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x1ffaff80,
+		.mode_horztiming	= 0x007d0e57,
+		.mode_verttiming	= 0x00740a01,
+		.mode_clkcontrol	= 0x000A0000, /* /1 */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 6, /* 72MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		1024, 1024,
+		768, 768,
+	},
+
+	[4] = { /* XVGA XVGA 1280x1024 H:68.5kHz V:65Hz */
+		.name = "XVGA_1280x1024",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x27fbff80,
+		.mode_horztiming	= 0x00cdb2c7,
+		.mode_verttiming	= 0x00600002,
+		.mode_clkcontrol	= 0x000A0000, /* /1 */
+		.mode_pwmdiv		= 0x00000000,
+		.mode_pwmhi		= 0x00000000,
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 10, /* 120MHz AUXPLL */
+		.device_init		= NULL,
+		.device_shutdown	= NULL,
+		1280, 1280,
+		1024, 1024,
+	},
+
+	[5] = { /* Samsung 1024x768 TFT */
+		.name = "Samsung_1024x768_TFT",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= 0x1ffaff80,
+		.mode_horztiming	= 0x018cc677,
+		.mode_verttiming	= 0x00241217,
+		.mode_clkcontrol	= 0x00000000, /* SCB 0x1 /4=24Mhz */
+		.mode_pwmdiv		= 0x8000063f, /* SCB 0x0 */
+		.mode_pwmhi		= 0x03400000, /* SCB 0x0 */
+		.mode_outmask	= 0x00FFFFFF,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		1024, 1024,
+		768, 768,
+	},
+
+	[6] = { /* Toshiba 640x480 TFT */
+		.name = "Toshiba_640x480_TFT",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,
+			.hfmax = 70000,
+			.vfmin = 60,
+			.vfmax = 60,
+			.dclkmin = 6000000,
+			.dclkmax = 28000000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(640) | 
+			LCD_SCREEN_SY_N(480),
+		.mode_horztiming	= LCD_HORZTIMING_HPW_N(96) | 
+			LCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(51),
+		.mode_verttiming	= LCD_VERTTIMING_VPW_N(2) | 
+			LCD_VERTTIMING_VND1_N(11) | LCD_VERTTIMING_VND2_N(32),
+		.mode_clkcontrol	= 0x00000000, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x8000063f,
+		.mode_pwmhi		= 0x03400000,
+		.mode_outmask	= 0x00fcfcfc,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		640, 480,
+		640, 480,
+	},
+
+	[7] = { /* Sharp 320x240 TFT */
+		.name = "Sharp_320x240_TFT",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 12500,
+			.hfmax = 20000,
+			.vfmin = 38,
+			.vfmax = 81,
+			.dclkmin = 4500000,
+			.dclkmax = 6800000,
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(320) | 
+			LCD_SCREEN_SY_N(240),
+		.mode_horztiming	= LCD_HORZTIMING_HPW_N(60) | 
+			LCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(2),
+		.mode_verttiming	= LCD_VERTTIMING_VPW_N(2) | 
+			LCD_VERTTIMING_VND1_N(2) | LCD_VERTTIMING_VND2_N(5),
+		.mode_clkcontrol	= LCD_CLKCONTROL_PCD_N(7), /*16=6Mhz*/
+		.mode_pwmdiv		= 0x8000063f,
+		.mode_pwmhi		= 0x03400000,
+		.mode_outmask	= 0x00fcfcfc,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		320, 320,
+		240, 240,
+	},
+
+	[8] = { /* Toppoly TD070WGCB2 7" 856x480 TFT */
+		.name = "Toppoly_TD070WGCB2",
+		.monspecs = {
+			.modedb = NULL,
+			.modedb_len = 0,
+			.hfmin = 30000,	
+			.hfmax = 70000, 
+			.vfmin = 60, 
+			.vfmax = 60, 
+			.dclkmin = 6000000, 
+			.dclkmax = 28000000, 
+			.input = FB_DISP_RGB,
+		},
+		.mode_screen		= LCD_SCREEN_SX_N(856) | 
+			LCD_SCREEN_SY_N(480),
+		.mode_horztiming	= LCD_HORZTIMING_HND2_N(43) | 
+			LCD_HORZTIMING_HND1_N(43) | LCD_HORZTIMING_HPW_N(114),
+		.mode_verttiming	= LCD_VERTTIMING_VND2_N(20) | 
+			LCD_VERTTIMING_VND1_N(21) | LCD_VERTTIMING_VPW_N(4),
+		.mode_clkcontrol	= 0x00020001, /* /4=24Mhz */
+		.mode_pwmdiv		= 0x8000063f,
+		.mode_pwmhi		= 0x03400000,
+		.mode_outmask	= 0x00fcfcfc,
+		.mode_fifoctrl	= 0x2f2f2f2f,
+		.mode_toyclksrc	= 0x00000004, /* AUXPLL directly */
+		.mode_backlight	= 0x00000000,
+		.mode_auxpll		= 8, /* 96MHz AUXPLL */
+		.device_init		= board_au1200fb_panel_init,
+		.device_shutdown	= board_au1200fb_panel_shutdown,
+		856, 856,
+		480, 480,
+	},
+};
+
+#define NUM_PANELS (sizeof(known_lcd_panels) / sizeof(struct panel_settings))
+
+/********************************************************************/
+
+static int set_brightness(unsigned int brightness)
+{
+	unsigned int hi1, divider;
+
+	/* limit brightness pwm duty to >= 30/1600 */
+	if (brightness < 30) {
+		brightness = 30;
+	}
+	divider = (lcd->pwmdiv & 0x3FFFF) + 1;
+	hi1 = (lcd->pwmhi >> 16) + 1;
+	hi1 = (((brightness & 0xFF)+1) * divider >> 8);
+	lcd->pwmhi &= 0xFFFF;
+	lcd->pwmhi |= (hi1 << 16);
+
+	return brightness;
+}
+
+static int
+winbpp (unsigned int winctrl1)
+{
+	/* how many bits are needed for each pixel format */
+	switch (winctrl1 & LCD_WINCTRL1_FRM)
+	{
+		case LCD_WINCTRL1_FRM_1BPP: return 1; break;
+		case LCD_WINCTRL1_FRM_2BPP: return 2; break;
+		case LCD_WINCTRL1_FRM_4BPP: return 4; break;
+		case LCD_WINCTRL1_FRM_8BPP: return 8; break;
+		case LCD_WINCTRL1_FRM_12BPP: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP655: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP565: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPP556: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPI1555: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPI5551: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPA1555: return 16; break;
+		case LCD_WINCTRL1_FRM_16BPPA5551: return 16; break;
+		case LCD_WINCTRL1_FRM_24BPP: return 32; break;
+		case LCD_WINCTRL1_FRM_32BPP: return 32; break;
+		default: return 0; break;
+	}
+}
+
+static int
+fbinfo2index (struct fb_info *fb_info)
+{
+	int i;
+	for (i = 0; i < CONFIG_FB_AU1200_DEVS; ++i)
+	{
+		if (fb_info == (struct fb_info *)(&_au1200fb_devices[i].fb_info))
+			return i;
+	}
+	printk("au1200fb: ERROR: fbinfo2index failed!\n");
+	return -1;
+}
+
+static int au1200_setlocation (struct au1200fb_device *fbdev, int plane, int xpos, int ypos)
+{
+	uint32 winctrl0, winctrl1, winenable, fb_offset = 0;
+	int xsz, ysz;
+
+	/* FIX!!! NOT CHECKING FOR COMPLETE OFFSCREEN YET */
+
+	winctrl0 = lcd->window[plane].winctrl0;
+	winctrl1 = lcd->window[plane].winctrl1;
+	winctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);
+	winctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);
+
+	/* Check for off-screen adjustments */
+	xsz = win->w[plane].xres;
+	ysz = win->w[plane].yres;
+	if ((xpos + win->w[plane].xres) > panel->Xres)
+	{
+		/* Off-screen to the right */
+		xsz = panel->Xres - xpos; /* off by 1 ??? */
+		/*printk("off screen right\n");*/
+	}
+
+	if ((ypos + win->w[plane].yres) > panel->Yres)
+	{
+		/* Off-screen to the bottom */
+		ysz = panel->Yres - ypos; /* off by 1 ??? */
+		/*printk("off screen bottom\n");*/
+	}
+
+	if (xpos < 0)
+	{
+		/* Off-screen to the left */
+		xsz = win->w[plane].xres + xpos;
+		fb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);
+		xpos = 0;
+		/*printk("off screen left\n");*/
+	}
+
+	if (ypos < 0)
+	{
+		/* Off-screen to the top */
+		ysz = win->w[plane].yres + ypos;
+		/* fixme: fb_offset += ((0-ypos)*fb_pars[plane].line_length); */
+		ypos = 0;
+		/*printk("off screen top\n");*/
+	}
+
+	/* record settings */
+	win->w[plane].xpos = xpos;
+	win->w[plane].ypos = ypos;
+
+	xsz -= 1;
+	ysz -= 1;
+	winctrl0 |= (xpos << 21);
+	winctrl0 |= (ypos << 10);
+	winctrl1 |= (xsz << 11);
+	winctrl1 |= (ysz << 0);
+
+	/* Disable the window while making changes, then restore WINEN */
+	winenable = lcd->winenable & (1 << plane);
+	au_sync();
+	lcd->winenable &= ~(1 << plane);
+	lcd->window[plane].winctrl0 = winctrl0;
+	lcd->window[plane].winctrl1 = winctrl1;
+	lcd->window[plane].winbuf0 =
+	lcd->window[plane].winbuf1 = fbdev->fb_phys;
+	lcd->window[plane].winbufctrl = 0; /* select winbuf0 */
+	lcd->winenable |= winenable;
+	au_sync();
+
+	return 0;
+}
+
+static void au1200_setpanel (struct panel_settings *newpanel)
+{
+	/*
+	 * Perform global setup/init of LCD controller
+	 */
+	uint32 winenable;
+
+	/* Make sure all windows disabled */
+	winenable = lcd->winenable;
+	lcd->winenable = 0;
+	au_sync();
+	/*
+	 * Ensure everything is disabled before reconfiguring
+	 */
+	if (lcd->screen & LCD_SCREEN_SEN)
+	{
+		/* Wait for vertical sync period */
+		lcd->intstatus = LCD_INT_SS;
+		while ((lcd->intstatus & LCD_INT_SS) == 0) {
+			au_sync();
+		}
+		
+		lcd->screen &= ~LCD_SCREEN_SEN;	/*disable the controller*/
+		
+		do
+		{
+			lcd->intstatus = lcd->intstatus; /*clear interrupts*/
+			au_sync();
+		}
+		/*wait for controller to shut down*/
+		while ((lcd->intstatus & LCD_INT_SD) == 0);
+		
+		/* Call shutdown of current panel (if up) */
+		/* this must occur last, because if an external clock is driving
+		    the controller, the clock cannot be turned off before first
+			shutting down the controller.
+		 */
+		if (panel->device_shutdown != NULL) panel->device_shutdown();
+	}
+
+	/* Newpanel == NULL indicates a shutdown operation only */
+	if (newpanel == NULL)
+		return;
+
+	panel = newpanel;
+	
+	printk("Panel(%s), %dx%d\n", panel->name, panel->Xres, panel->Yres);
+
+	/*
+	 * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)
+	 */
+	if (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))
+	{
+		uint32 sys_clksrc;
+		au_writel(panel->mode_auxpll, SYS_AUXPLL);
+		sys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f; 
+		sys_clksrc |= panel->mode_toyclksrc;
+		au_writel(sys_clksrc, SYS_CLKSRC);
+	}
+
+	/*
+	 * Configure panel timings
+	 */
+	lcd->screen = panel->mode_screen;
+	lcd->horztiming = panel->mode_horztiming;
+	lcd->verttiming = panel->mode_verttiming;
+	lcd->clkcontrol = panel->mode_clkcontrol;
+	lcd->pwmdiv = panel->mode_pwmdiv;
+	lcd->pwmhi = panel->mode_pwmhi;
+	lcd->outmask = panel->mode_outmask;
+	lcd->fifoctrl = panel->mode_fifoctrl;
+	au_sync();
+
+	/* fixme: Check window settings to make sure still valid 
+	 * for new geometry */
+#if 0
+	au1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);
+	au1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);
+	au1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);
+	au1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);
+#endif
+	lcd->winenable = winenable;
+
+	/*
+	 * Re-enable screen now that it is configured
+	 */
+	lcd->screen |= LCD_SCREEN_SEN;
+	au_sync();
+
+	/* Call init of panel */
+	if (panel->device_init != NULL) panel->device_init();
+
+	/* FIX!!!! not appropriate on panel change!!! Global setup/init */
+	lcd->intenable = 0;
+	lcd->intstatus = ~0;
+	lcd->backcolor = win->mode_backcolor;
+
+	/* Setup Color Key - FIX!!! */
+	lcd->colorkey = win->mode_colorkey;
+	lcd->colorkeymsk = win->mode_colorkeymsk;
+
+	/* Setup HWCursor - FIX!!! Need to support this eventually */
+	lcd->hwc.cursorctrl = 0;
+	lcd->hwc.cursorpos = 0;
+	lcd->hwc.cursorcolor0 = 0;
+	lcd->hwc.cursorcolor1 = 0;
+	lcd->hwc.cursorcolor2 = 0;
+	lcd->hwc.cursorcolor3 = 0;
+
+
+#if 0
+#define D(X) printk("%25s: %08X\n", #X, X)
+	D(lcd->screen);
+	D(lcd->horztiming);
+	D(lcd->verttiming);
+	D(lcd->clkcontrol);
+	D(lcd->pwmdiv);
+	D(lcd->pwmhi);
+	D(lcd->outmask);
+	D(lcd->fifoctrl);
+	D(lcd->window[0].winctrl0);
+	D(lcd->window[0].winctrl1);
+	D(lcd->window[0].winctrl2);
+	D(lcd->window[0].winbuf0);
+	D(lcd->window[0].winbuf1);
+	D(lcd->window[0].winbufctrl);
+	D(lcd->window[1].winctrl0);
+	D(lcd->window[1].winctrl1);
+	D(lcd->window[1].winctrl2);
+	D(lcd->window[1].winbuf0);
+	D(lcd->window[1].winbuf1);
+	D(lcd->window[1].winbufctrl);
+	D(lcd->window[2].winctrl0);
+	D(lcd->window[2].winctrl1);
+	D(lcd->window[2].winctrl2);
+	D(lcd->window[2].winbuf0);
+	D(lcd->window[2].winbuf1);
+	D(lcd->window[2].winbufctrl);
+	D(lcd->window[3].winctrl0);
+	D(lcd->window[3].winctrl1);
+	D(lcd->window[3].winctrl2);
+	D(lcd->window[3].winbuf0);
+	D(lcd->window[3].winbuf1);
+	D(lcd->window[3].winbufctrl);
+	D(lcd->winenable);
+	D(lcd->intenable);
+	D(lcd->intstatus);
+	D(lcd->backcolor);
+	D(lcd->winenable);
+	D(lcd->colorkey);
+    D(lcd->colorkeymsk);
+	D(lcd->hwc.cursorctrl);
+	D(lcd->hwc.cursorpos);
+	D(lcd->hwc.cursorcolor0);
+	D(lcd->hwc.cursorcolor1);
+	D(lcd->hwc.cursorcolor2);
+	D(lcd->hwc.cursorcolor3);
+#endif
+}
+
+static void au1200_setmode(struct au1200fb_device *fbdev)
+{
+	int plane = fbdev->plane;
+	/* Window/plane setup */
+	lcd->window[plane].winctrl1 = ( 0
+		| LCD_WINCTRL1_PRI_N(plane)
+		| win->w[plane].mode_winctrl1 /* FRM,CCO,PO,PIPE */
+		) ;
+
+	au1200_setlocation(fbdev, plane, win->w[plane].xpos, win->w[plane].ypos);
+
+	lcd->window[plane].winctrl2 = ( 0
+		| LCD_WINCTRL2_CKMODE_00
+		| LCD_WINCTRL2_DBM
+		| LCD_WINCTRL2_BX_N( fbdev->fb_info.fix.line_length)
+		| LCD_WINCTRL2_SCX_1
+		| LCD_WINCTRL2_SCY_1
+		) ;
+	lcd->winenable |= win->w[plane].mode_winenable;
+	au_sync();
+}
+
+
+/* Inline helpers */
+
+/*#define panel_is_dual(panel)  ((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/
+/*#define panel_is_active(panel)((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/
+
+#define panel_is_color(panel) ((panel->mode_screen & LCD_SCREEN_PT) <= LCD_SCREEN_PT_CDSTN)
+
+/* Bitfields format supported by the controller. */
+struct fb_bitfield rgb_bitfields[][4] = 
+{
+  	/*     Red, 	   Green, 	 Blue, 	     Transp   */
+	[LCD_WINCTRL1_FRM_16BPP655 >> 25] =
+		{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPP565 >> 25] =
+		{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPP556 >> 25] =
+		{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPI1555 >> 25] =
+		{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPI5551 >> 25] =
+		{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPA1555 >> 25] =
+		{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },
+
+	[LCD_WINCTRL1_FRM_16BPPA5551 >> 25] =
+		{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },
+
+	[LCD_WINCTRL1_FRM_24BPP >> 25] =
+		{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 0, 0, 0 } },
+
+	[LCD_WINCTRL1_FRM_32BPP >> 25] =
+		{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 24, 0, 0 } },
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Helpers */
+	
+static void 
+au1200fb_update_fbinfo(struct fb_info *fbi)
+{
+	/* FIX!!!! This also needs to take the window pixel format into account!!! */
+
+	/* Update var-dependent FB info */
+	if (panel_is_color(panel)) {
+		if (fbi->var.bits_per_pixel <= 8) {
+			/* palettized */
+			fbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+			fbi->fix.line_length = fbi->var.xres_virtual / 
+				(8/fbi->var.bits_per_pixel);
+		} else {
+			/* non-palettized */
+			fbi->fix.visual = FB_VISUAL_TRUECOLOR;
+			fbi->fix.line_length = fbi->var.xres_virtual * (fbi->var.bits_per_pixel / 8); 
+		}
+	} else {
+		/* mono FIX!!! mono 8 and 4 bits */
+		fbi->fix.visual = FB_VISUAL_MONO10;
+		fbi->fix.line_length = fbi->var.xres_virtual / 8;
+	}
+
+	fbi->screen_size = fbi->fix.line_length * fbi->var.yres_virtual;
+	print_dbg("line length: %d\n", fbi->fix.line_length);
+	print_dbg("bits_per_pixel: %d\n", fbi->var.bits_per_pixel);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* AU1200 framebuffer driver */
+
+int au1200fb_fb_open(struct fb_info *fbi, int user)
+{
+	return 0;
+}
+
+int au1200fb_fb_release(struct fb_info *fbi, int user)
+{
+	return 0;
+}
+
+/* fb_check_var
+ * Validate var settings with hardware restrictions and modify it if necessary 
+ */
+int au1200fb_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	struct au1200fb_device *fbdev = (struct au1200fb_device *)fbi;
+	u32 pixclock;
+	int screen_size, plane;
+
+	plane = fbdev->plane;
+
+	/* Make sure that the mode respect all LCD controller and 
+	 * panel restrictions. */
+	var->xres = win->w[plane].xres;
+	var->yres = win->w[plane].yres;
+	
+	/* No need for virtual resolution support */
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+
+	var->bits_per_pixel = winbpp(win->w[plane].mode_winctrl1);
+
+	screen_size = var->xres_virtual * var->yres_virtual;
+	if (var->bits_per_pixel > 8) screen_size *= (var->bits_per_pixel / 8);  
+	else screen_size /= (8/var->bits_per_pixel);
+
+	if (fbdev->fb_len < screen_size)
+		return -EINVAL; /* Virtual screen is to big, abort */
+
+	/* FIX!!!! what are the implicaitons of ignoring this for windows ??? */
+	/* The max LCD clock is fixed to 48MHz (value of AUX_CLK). The pixel
+	 * clock can only be obtain by dividing this value by an even integer.
+	 * Fallback to a slower pixel clock if necessary. */
+	pixclock = max((u32)(PICOS2KHZ(var->pixclock) * 1000), fbi->monspecs.dclkmin);
+	pixclock = min(pixclock, min(fbi->monspecs.dclkmax, (u32)AU1200_LCD_MAX_CLK/2));
+
+	if (AU1200_LCD_MAX_CLK % pixclock) {
+		int diff = AU1200_LCD_MAX_CLK % pixclock;
+		pixclock -= diff;
+	}
+
+	var->pixclock = KHZ2PICOS(pixclock/1000);
+#if 0
+	if (!panel_is_active(panel)) {
+		int pcd = AU1200_LCD_MAX_CLK / (pixclock * 2) - 1;
+
+		if (!panel_is_color(panel) 
+			&& (panel->control_base & LCD_CONTROL_MPI) && (pcd < 3)) {
+			/* STN 8bit mono panel support is up to 6MHz pixclock */
+			var->pixclock = KHZ2PICOS(6000);
+		} else if (!pcd) {
+			/* Other STN panel support is up to 12MHz  */
+			var->pixclock = KHZ2PICOS(12000);
+		}
+	}
+#endif
+	/* Set bitfield accordingly */
+	switch (var->bits_per_pixel) {
+		case 16:
+		{
+			/* 16bpp True color.  
+			 * These must be set to MATCH WINCTRL[FORM] */
+			int idx;
+			idx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;
+			var->red    = rgb_bitfields[idx][0];
+			var->green  = rgb_bitfields[idx][1];
+			var->blue   = rgb_bitfields[idx][2];
+			var->transp = rgb_bitfields[idx][3];
+			break;
+		}
+
+		case 32:
+		{
+			/* 32bpp True color.  
+			 * These must be set to MATCH WINCTRL[FORM] */
+			int idx;
+			idx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;
+			var->red    = rgb_bitfields[idx][0];
+			var->green  = rgb_bitfields[idx][1];
+			var->blue   = rgb_bitfields[idx][2];
+			var->transp = rgb_bitfields[idx][3];
+			break;
+		}
+		default:
+			print_dbg("Unsupported depth %dbpp", var->bits_per_pixel);
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* fb_set_par 
+ * Set hardware with var settings. This will enable the controller with a 
+ * specific mode, normally validated with the fb_check_var method
+ */
+int au1200fb_fb_set_par(struct fb_info *fbi)
+{
+	struct au1200fb_device *fbdev = (struct au1200fb_device *)fbi;
+
+	au1200fb_update_fbinfo(fbi);
+	au1200_setmode(fbdev);
+
+	return 0;
+}
+
+/* fb_setcolreg
+ * Set color in LCD palette.
+ */
+int au1200fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)
+{
+	u32 *palette = lcd->palette;
+	u32 value;
+
+	if (regno > (AU1200_LCD_NBR_PALETTE_ENTRIES - 1))
+		return -EINVAL;
+
+	if (fbi->var.grayscale) {
+		/* Convert color to grayscale */
+		red = green = blue = 
+			(19595 * red + 38470 * green + 7471 * blue) >> 16;
+	}
+
+	if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
+		/* Place color in the pseudopalette */
+		if (regno > 16)
+			return -EINVAL;
+   
+		palette = (u32*)fbi->pseudo_palette;
+
+		red   >>= (16 - fbi->var.red.length);
+		green >>= (16 - fbi->var.green.length);
+		blue  >>= (16 - fbi->var.blue.length);
+	
+		value = (red   << fbi->var.red.offset) 	|	
+			(green << fbi->var.green.offset)|
+			(blue  << fbi->var.blue.offset);
+		value &= 0xFFFF;
+
+	} else if (1 /*FIX!!! panel_is_active(fbdev->panel)*/) {
+		/* COLOR TFT PALLETTIZED (use RGB 565) */
+		value = (red & 0xF800)|((green >> 5) & 
+				0x07E0)|((blue >> 11) & 0x001F);
+		value &= 0xFFFF;
+
+	} else if (0 /*panel_is_color(fbdev->panel)*/) {
+		/* COLOR STN MODE */
+		value = 0x1234;
+		value &= 0xFFF;
+	} else {
+		/* MONOCHROME MODE */
+		value = (green >> 12) & 0x000F;
+		value &= 0xF;
+	}
+
+	palette[regno] = value;
+	
+	return 0;
+}
+
+/* fb_blank
+ * Blank the screen. Depending on the mode, the screen will be
+ * activated with the backlight color, or desactivated
+ */
+int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)
+{
+	/* Short-circuit screen blanking */
+	if (noblanking)
+		return 0;
+
+	switch (blank_mode) {
+
+	case VESA_NO_BLANKING:
+		/* printk("turn on panel\n"); */
+		au1200_setpanel(panel);
+		break;
+
+	case VESA_VSYNC_SUSPEND:
+	case VESA_HSYNC_SUSPEND:
+	case VESA_POWERDOWN:
+		/* printk("turn off panel\n"); */
+		au1200_setpanel(NULL);
+		break;
+	default: 
+		break;
+
+	}
+	return 0;
+}
+
+/* fb_mmap
+ * Map video memory in user space. We don't use the generic fb_mmap 
+ * method mainly to allow the use of the TLB streaming flag (CCA=6)
+ */
+int au1200fb_fb_mmap(struct fb_info *fbi, struct file *file, struct vm_area_struct *vma)
+{
+	unsigned int len;
+	unsigned long start=0, off;
+	struct au1200fb_device *fbdev = (struct au1200fb_device *)fbi;
+
+#ifdef CONFIG_PM
+	au1xxx_pm_access(LCD_pm_dev);
+#endif
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
+		return -EINVAL;
+	}
+    
+	start = fbdev->fb_phys & PAGE_MASK;
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		return -EINVAL;
+	}
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	pgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */
+
+	vma->vm_flags |= VM_IO;
+    
+	if (io_remap_page_range(vma, vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+void set_global(u_int cmd, au1200_lcd_global_regs_t *pdata) {
+
+	unsigned int hi1, divider;
+	
+	/* SCREEN_SIZE: user cannot reset size, must switch panel choice */
+	
+	if (pdata->flags & SCREEN_BACKCOLOR)
+		lcd->backcolor = pdata->backcolor;
+	
+	if (pdata->flags & SCREEN_BRIGHTNESS) {
+	
+		// limit brightness pwm duty to >= 30/1600
+		if (pdata->brightness < 30) {
+			pdata->brightness = 30;
+		}
+		divider = (lcd->pwmdiv & 0x3FFFF) + 1;
+		hi1 = (lcd->pwmhi >> 16) + 1;
+		hi1 = (((pdata->brightness & 0xFF)+1) * divider >> 8);
+		lcd->pwmhi &= 0xFFFF;
+		lcd->pwmhi |= (hi1 << 16);
+	}
+	
+	if (pdata->flags & SCREEN_COLORKEY)
+		lcd->colorkey = pdata->colorkey;
+	
+	if (pdata->flags & SCREEN_MASK)
+		lcd->colorkeymsk = pdata->mask;
+	au_sync();
+}
+
+void get_global(u_int cmd, au1200_lcd_global_regs_t *pdata) {
+	unsigned int hi1, divider;
+	
+	pdata->xsize = ((lcd->screen & LCD_SCREEN_SX) >> 19) + 1;
+	pdata->ysize = ((lcd->screen & LCD_SCREEN_SY) >> 8) + 1;
+	
+	pdata->backcolor = lcd->backcolor;
+	pdata->colorkey = lcd->colorkey;
+	pdata->mask = lcd->colorkeymsk;
+	
+	// brightness
+	hi1 = (lcd->pwmhi >> 16) + 1;
+	divider = (lcd->pwmdiv & 0x3FFFF) + 1;
+	pdata->brightness = ((hi1 << 8) / divider) - 1;
+	au_sync();
+}
+
+void print_global(au1200_lcd_global_regs_t *pdata) {
+
+	printk("pdata->xsize %x\n", pdata->xsize);
+	printk("pdata->ysize %x\n", pdata->ysize);
+	printk("pdata->backcolor %x\n", pdata->backcolor);
+	printk("pdata->brightness %x\n", pdata->brightness);
+	printk("pdata->colorkey %x\n", pdata->colorkey);
+	printk("pdata->mask %x\n", pdata->mask);
+}
+
+void set_window(unsigned int plane, au1200_lcd_window_regs_t *pdata) {
+	
+	unsigned int val, bpp;
+	
+	/* Window control register 0 */
+	if (pdata->flags & WIN_POSITION) {
+		val = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_OX | 
+				LCD_WINCTRL0_OY);
+		val |= ((pdata->xpos << 21) & LCD_WINCTRL0_OX);
+		val |= ((pdata->ypos << 10) & LCD_WINCTRL0_OY);
+		lcd->window[plane].winctrl0 = val;
+	}
+	if (pdata->flags & WIN_ALPHA_COLOR) {
+		val = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_A);
+		val |= ((pdata->alpha_color << 2) & LCD_WINCTRL0_A);
+		lcd->window[plane].winctrl0 = val;
+	}
+	if (pdata->flags & WIN_ALPHA_MODE) {
+		val = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_AEN);
+		val |= ((pdata->alpha_mode << 1) & LCD_WINCTRL0_AEN);
+		lcd->window[plane].winctrl0 = val;
+	}
+	
+	/* Window control register 1 */
+	if (pdata->flags & WIN_PRIORITY) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PRI);
+		val |= ((pdata->priority << 30) & LCD_WINCTRL1_PRI);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_CHANNEL) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PIPE);
+		val |= ((pdata->channel << 29) & LCD_WINCTRL1_PIPE);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_BUFFER_FORMAT) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_FRM);
+		val |= ((pdata->buffer_format << 25) & LCD_WINCTRL1_FRM);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_COLOR_ORDER) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_CCO);
+		val |= ((pdata->color_order << 24) & LCD_WINCTRL1_CCO);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_PIXEL_ORDER) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PO);
+		val |= ((pdata->pixel_order << 22) & LCD_WINCTRL1_PO);
+		lcd->window[plane].winctrl1 = val;
+	}
+	if (pdata->flags & WIN_SIZE) {
+		val = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_SZX | 
+				LCD_WINCTRL1_SZY);
+		val |= (((pdata->xsize << 11) - 1) & LCD_WINCTRL1_SZX);
+		val |= (((pdata->ysize) - 1) & LCD_WINCTRL1_SZY);
+		lcd->window[plane].winctrl1 = val;
+		/* program buffer line width */
+		bpp = winbpp(val) / 8;
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_BX);
+		val |= (((pdata->xsize * bpp) << 8) & LCD_WINCTRL2_BX);
+		lcd->window[plane].winctrl2 = val;
+	}
+	
+	/* Window control register 2 */
+	if (pdata->flags & WIN_COLORKEY_MODE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_CKMODE);
+		val |= ((pdata->colorkey_mode << 24) & LCD_WINCTRL2_CKMODE);
+		lcd->window[plane].winctrl2 = val;
+	}
+	if (pdata->flags & WIN_DOUBLE_BUFFER_MODE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_DBM);
+		val |= ((pdata->double_buffer_mode << 23) & LCD_WINCTRL2_DBM);
+		lcd->window[plane].winctrl2 = val;
+	}
+	if (pdata->flags & WIN_RAM_ARRAY_MODE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_RAM);
+		val |= ((pdata->ram_array_mode << 21) & LCD_WINCTRL2_RAM);
+		lcd->window[plane].winctrl2 = val;
+	}
+	
+	/* Buffer line width programmed with WIN_SIZE */
+	
+	if (pdata->flags & WIN_BUFFER_SCALE) {
+		val = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_SCX | 
+				LCD_WINCTRL2_SCY);
+		val |= ((pdata->xsize << 11) & LCD_WINCTRL2_SCX);
+		val |= ((pdata->ysize) & LCD_WINCTRL2_SCY);
+		lcd->window[plane].winctrl2 = val;
+	}
+	
+	if (pdata->flags & WIN_ENABLE) {
+		val = lcd->winenable;
+		val &= ~(1<<plane);
+		val |= (pdata->enable & 1) << plane;
+		lcd->winenable = val;
+	}
+	au_sync();
+}
+
+void get_window(unsigned int plane, au1200_lcd_window_regs_t *pdata) {
+
+	/* Window control register 0 */
+	pdata->xpos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;
+	pdata->ypos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;
+	pdata->alpha_color = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_A) >> 2;
+	pdata->alpha_mode = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_AEN) >> 1;
+	
+	/* Window control register 1 */
+	pdata->priority = (lcd->window[plane].winctrl1& LCD_WINCTRL1_PRI) >> 30;
+	pdata->channel = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PIPE) >> 29;
+	pdata->buffer_format = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_FRM) >> 25;
+	pdata->color_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_CCO) >> 24;
+	pdata->pixel_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PO) >> 22;
+	pdata->xsize = ((lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11) + 1;
+	pdata->ysize = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZY) + 1;
+	
+	/* Window control register 2 */
+	pdata->colorkey_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_CKMODE) >> 24;
+	pdata->double_buffer_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_DBM) >> 23;
+	pdata->ram_array_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_RAM) >> 21;
+	
+	pdata->enable = (lcd->winenable >> plane) & 1;
+	au_sync();
+}
+
+static int au1200fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
+			  u_long arg, struct fb_info *info)
+{
+	int plane;
+	int val;
+
+#ifdef CONFIG_PM
+	au1xxx_pm_access(LCD_pm_dev);
+#endif
+	
+	plane = fbinfo2index(info);
+	print_dbg("au1200fb: ioctl %d on plane %d\n", cmd, plane);
+	
+	if (cmd == AU1200_LCD_FB_IOCTL) {
+		au1200_lcd_iodata_t iodata;
+	
+		if (copy_from_user(&iodata, (void *) arg, sizeof(au1200_lcd_iodata_t)))
+			return -EFAULT;
+	
+		print_dbg("FB IOCTL called\n");
+	
+		switch (iodata.subcmd)
+		{
+	
+		case AU1200_LCD_SET_SCREEN:
+			print_dbg("AU1200_LCD_SET_SCREEN\n");
+			set_global(cmd, &iodata.global);
+			break;
+	
+		case AU1200_LCD_GET_SCREEN:
+			print_dbg("AU1200_LCD_GET_SCREEN\n");
+			get_global(cmd, &iodata.global);
+			break;
+	
+		case AU1200_LCD_SET_WINDOW:
+			print_dbg("AU1200_LCD_SET_WINDOW\n");
+			set_window(plane, &iodata.window);
+			break;
+	
+		case AU1200_LCD_GET_WINDOW:
+			print_dbg("AU1200_LCD_GET_WINDOW\n");
+			get_window(plane, &iodata.window);
+			break;
+	
+		case AU1200_LCD_SET_PANEL:
+			print_dbg("AU1200_LCD_SET_PANEL\n");
+			if ((iodata.global.panel_choice >= 0) && 
+					(iodata.global.panel_choice < 
+					 NUM_PANELS))
+			{
+				struct panel_settings *newpanel;
+				panel_index = iodata.global.panel_choice;
+				newpanel = &known_lcd_panels[panel_index];
+				au1200_setpanel(newpanel);
+			}
+			break;
+	
+		case AU1200_LCD_GET_PANEL:
+			print_dbg("AU1200_LCD_GET_PANEL\n");
+			iodata.global.panel_choice = panel_index;
+			break;
+	
+		default:
+			return -EINVAL;
+		}
+	
+		val = copy_to_user((void *) arg, &iodata, sizeof(au1200_lcd_iodata_t));
+		if (val) {
+			print_dbg("error: could not copy %d bytes\n", val);
+			return -EFAULT;
+		}
+	}
+	
+return 0;
+}
+
+
+static struct fb_ops au1200fb_fb_ops = 
+{
+	.owner			= THIS_MODULE,
+	.fb_open		= au1200fb_fb_open,
+	.fb_release		= au1200fb_fb_release,
+	.fb_check_var	= au1200fb_fb_check_var,
+	.fb_set_par		= au1200fb_fb_set_par,
+	.fb_setcolreg	= au1200fb_fb_setcolreg,
+	.fb_blank		= au1200fb_fb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor		= soft_cursor,
+	.fb_sync		= NULL,
+	.fb_ioctl		= au1200fb_ioctl,
+	.fb_mmap		= au1200fb_fb_mmap,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static irqreturn_t au1200fb_handle_irq(int irq, void* dev_id, struct pt_regs *regs)
+{
+	/* Nothing to do for now, just clear any pending interrupt */
+	lcd->intstatus = lcd->intstatus;
+	au_sync();
+	return IRQ_HANDLED;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* AU1200 LCD device probe helpers */
+
+static int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)
+{
+	struct fb_info *fbi = &fbdev->fb_info;
+	int bpp;
+	
+	memset(fbi, 0, sizeof(struct fb_info));
+	fbi->fbops = &au1200fb_fb_ops;
+	
+	bpp = winbpp(win->w[fbdev->plane].mode_winctrl1);
+
+	/* Copy monitor specs from panel data */
+	/* fixme: we're setting up LCD controller windows, so these dont give a
+	damn as to what the monitor specs are (the panel itself does, but that
+	isnt done here...so maybe need a generic catchall monitor setting??? */
+	memcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));
+
+	/* We first try the user mode passed in argument. If that failed, 
+	 * or if no one has been specified, we default to the first mode of the 
+	 * panel list. Note that after this call, var data will be set */
+	if (!fb_find_mode(&fbi->var, 
+			  fbi, 
+			  NULL, /* drv_info.opt_mode, */
+			  fbi->monspecs.modedb, 
+			  fbi->monspecs.modedb_len,
+			  fbi->monspecs.modedb, 
+			  bpp)) {
+
+		print_err("Cannot find valid mode for panel %s", panel->name);
+		return -EFAULT;
+	}
+
+	fbi->pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL);
+	if (!fbi->pseudo_palette) {
+		return -ENOMEM;
+	}
+	memset(fbi->pseudo_palette, 0, sizeof(u32) * 16);
+
+	if (fb_alloc_cmap(&fbi->cmap, AU1200_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {
+		print_err("Fail to allocate colormap (%d entries)",
+			   AU1200_LCD_NBR_PALETTE_ENTRIES);
+		kfree(fbi->pseudo_palette);
+		return -EFAULT;
+	}
+
+	strncpy(fbi->fix.id, "AU1200", sizeof(fbi->fix.id));
+	fbi->fix.smem_start = fbdev->fb_phys;
+	fbi->fix.smem_len = fbdev->fb_len;
+	fbi->fix.type = FB_TYPE_PACKED_PIXELS;
+	fbi->fix.xpanstep = 1;
+	fbi->fix.ypanstep = 1;
+	fbi->fix.mmio_start = 0;
+	fbi->fix.mmio_len = 0;
+	fbi->fix.accel = FB_ACCEL_NONE;
+
+	fbi->screen_base = fbdev->fb_mem;
+
+	au1200fb_update_fbinfo(fbi);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* AU1200 LCD controller device driver */
+
+int au1200fb_drv_probe(struct device *dev)
+{
+	struct au1200fb_device *fbdev;
+	unsigned long page;
+	int bpp, plane, ret;
+
+	if (!dev)
+		return -EINVAL;
+
+	for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane)
+	{
+		bpp = winbpp(win->w[plane].mode_winctrl1);
+		if (win->w[plane].xres == 0)
+			win->w[plane].xres = panel->Xres;
+		if (win->w[plane].yres == 0)
+			win->w[plane].yres = panel->Yres;
+
+		fbdev = &_au1200fb_devices[plane];
+		memset((void *)fbdev, 0, sizeof(struct au1200fb_device));
+		fbdev->plane = plane;
+
+		/* Allocate the framebuffer to the maximum screen size */
+		fbdev->fb_len = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;
+
+		fbdev->fb_mem = dma_alloc_noncoherent(dev, 
+				PAGE_ALIGN(fbdev->fb_len), 
+				&fbdev->fb_phys, GFP_KERNEL);
+		if (!fbdev->fb_mem) {
+			print_err("fail to allocate frambuffer (size: %dK))", 
+				  fbdev->fb_len / 1024);
+			return -ENOMEM;
+		}
+
+		/*
+		 * Set page reserved so that mmap will work. This is necessary
+		 * since we'll be remapping normal memory.
+		 */
+		for (page = (unsigned long)fbdev->fb_phys;
+		     page < PAGE_ALIGN((unsigned long)fbdev->fb_phys + 
+			     fbdev->fb_len);
+		     page += PAGE_SIZE) {
+			SetPageReserved(pfn_to_page(page >> PAGE_SHIFT)); /* LCD DMA is NOT coherent on Au1200 */
+		}
+		print_dbg("Framebuffer memory map at %p", fbdev->fb_mem);
+		print_dbg("phys=0x%08x, size=%dK", fbdev->fb_phys, fbdev->fb_len / 1024);
+
+		/* Init FB data */
+		if ((ret = au1200fb_init_fbinfo(fbdev)) < 0)
+			goto failed;
+
+		/* Register new framebuffer */
+		if ((ret = register_framebuffer(&fbdev->fb_info)) < 0) {
+			print_err("cannot register new framebuffer");
+			goto failed;
+		}
+		
+		au1200fb_fb_set_par(&fbdev->fb_info);
+
+#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)
+		if (plane == 0)
+			if (fb_prepare_logo(&fbdev->fb_info)) {
+				/* Start display and show logo on boot */
+				fb_set_cmap(&fbdev->fb_info.cmap, 
+						&fbdev->fb_info);
+
+				fb_show_logo(&fbdev->fb_info);
+			}
+#endif
+	}
+
+	/* Now hook interrupt too */
+	if ((ret = request_irq(AU1200_LCD_INT, au1200fb_handle_irq,
+		 	  SA_INTERRUPT | SA_SHIRQ, "lcd", (void *)dev)) < 0) {
+		print_err("fail to request interrupt line %d (err: %d)",
+			  AU1200_LCD_INT, ret);
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	/* NOTE: This only does the current plane/window that failed; others are still active */
+	if (fbdev->fb_mem)
+		dma_free_noncoherent(dev, PAGE_ALIGN(fbdev->fb_len), 
+				fbdev->fb_mem, fbdev->fb_phys);
+	if (fbdev->fb_info.cmap.len != 0)
+		fb_dealloc_cmap(&fbdev->fb_info.cmap);
+	if (fbdev->fb_info.pseudo_palette)
+		kfree(fbdev->fb_info.pseudo_palette);
+	if (plane == 0)
+		free_irq(AU1200_LCD_INT, (void*)dev);
+	return ret;
+}
+
+int au1200fb_drv_remove(struct device *dev)
+{
+	struct au1200fb_device *fbdev;
+	int plane;
+
+	if (!dev)
+		return -ENODEV;
+
+	/* Turn off the panel */
+	au1200_setpanel(NULL);
+
+	for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane)
+	{
+		fbdev = &_au1200fb_devices[plane];
+
+		/* Clean up all probe data */
+		unregister_framebuffer(&fbdev->fb_info);
+		if (fbdev->fb_mem)
+			dma_free_noncoherent(dev, PAGE_ALIGN(fbdev->fb_len), 
+					fbdev->fb_mem, fbdev->fb_phys);
+		if (fbdev->fb_info.cmap.len != 0)
+			fb_dealloc_cmap(&fbdev->fb_info.cmap);
+		if (fbdev->fb_info.pseudo_palette)
+			kfree(fbdev->fb_info.pseudo_palette);
+	}
+
+	free_irq(AU1200_LCD_INT, (void *)dev);
+
+	return 0;
+}
+
+int au1200fb_drv_suspend(struct device *dev, u32 state, u32 level)
+{
+	/* TODO */
+	return 0;
+}
+
+int au1200fb_drv_resume(struct device *dev, u32 level)
+{
+	/* TODO */
+	return 0;
+}
+
+static struct device_driver au1200fb_driver = {
+	.name		= "au1200-lcd",
+	.bus		= &platform_bus_type,
+	.probe		= au1200fb_drv_probe,
+	.remove		= au1200fb_drv_remove,
+	.suspend	= au1200fb_drv_suspend,
+	.resume		= au1200fb_drv_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Kernel driver */
+
+static void au1200fb_setup(void)
+{
+	char* options = NULL;
+	char* this_opt;
+	int num_panels = ARRAY_SIZE(known_lcd_panels);
+	int panel_idx = -1;
+
+	fb_get_options(DRIVER_NAME, &options);
+
+	if (options) {
+		while ((this_opt = strsep(&options,",")) != NULL) {
+			/* Panel option - can be panel name, 
+			 * "bs" for board-switch, or number/index */
+			if (!strncmp(this_opt, "panel:", 6)) {
+				int i;
+				long int li;
+				char *endptr;
+				this_opt += 6;
+				/* First check for index, which allows 
+				 * to short circuit this mess */
+				li = simple_strtol(this_opt, &endptr, 0);
+				if (*endptr == '\0') {
+					panel_idx = (int)li;
+				}
+				else if (strcmp(this_opt, "bs") == 0) {
+					extern int board_au1200fb_panel(void);
+					panel_idx = board_au1200fb_panel();
+				}
+
+				else
+				for (i = 0; i < num_panels; i++) {
+					if (!strcmp(this_opt, known_lcd_panels[i].name)) {
+						panel_idx = i;
+						break;
+					}
+				}
+
+				if ((panel_idx < 0) || (panel_idx >= num_panels)) {
+						print_warn("Panel %s not supported!", this_opt);
+				}
+				else
+					panel_index = panel_idx;
+			}
+
+			else if (strncmp(this_opt, "nohwcursor", 10) == 0) {
+				nohwcursor = 1;
+			}
+
+			/* Unsupported option */
+			else {
+				print_warn("Unsupported option \"%s\"", this_opt);
+			}
+		}
+	} 
+}
+
+#ifdef CONFIG_PM
+int au1200fb_pm_callback(au1xxx_power_dev_t *dev, 
+		au1xxx_request_t request, void *data) {
+	int retval = -1;
+	unsigned int d = 0;
+	unsigned int brightness = 0;
+
+	if (request == AU1XXX_PM_SLEEP) {
+		board_au1200fb_panel_shutdown();
+	}
+	else if (request == AU1XXX_PM_WAKEUP) {
+		if(dev->prev_state == SLEEP_STATE)
+		{
+			int plane;
+			au1200_setpanel(panel);
+			for (plane = 0; plane < CONFIG_FB_AU1200_DEVS; ++plane) 	{
+				struct au1200fb_device *fbdev;
+				fbdev = &_au1200fb_devices[plane];
+				au1200fb_fb_set_par(&fbdev->fb_info);
+			}
+		}
+
+		d = *((unsigned int*)data);
+		if(d <=10) brightness = 26;
+		else if(d<=20) brightness = 51;
+		else if(d<=30) brightness = 77;
+		else if(d<=40) brightness = 102;
+		else if(d<=50) brightness = 128;
+		else if(d<=60) brightness = 153;
+		else if(d<=70) brightness = 179;
+		else if(d<=80) brightness = 204;
+		else if(d<=90) brightness = 230;
+		else brightness = 255;
+		set_brightness(brightness);
+	}
+	else if (request == AU1XXX_PM_GETSTATUS) {
+		return dev->cur_state;
+	}
+	else if (request == AU1XXX_PM_ACCESS) {
+		if (dev->cur_state != SLEEP_STATE)
+			return retval;
+		else {
+			au1200_setpanel(panel);
+		}
+	}
+	else if (request == AU1XXX_PM_IDLE) {
+	}
+	else if (request == AU1XXX_PM_CLEANUP) {
+	}
+
+	return retval; 
+}
+#endif
+
+int __init au1200fb_init(void)
+{
+	print_info("" DRIVER_DESC "");
+	
+	/* Setup driver with options */
+	au1200fb_setup();
+
+	/* Point to the panel selected */
+	panel = &known_lcd_panels[panel_index];
+	win = &windows[window_index];
+
+	printk(DRIVER_NAME ": Panel %d %s\n", panel_index, panel->name);
+	printk(DRIVER_NAME ": Win %d %s\n", window_index, win->name);
+
+	/* Kickstart the panel, the framebuffers/windows come soon enough */
+	au1200_setpanel(panel);
+
+	#ifdef CONFIG_PM
+	LCD_pm_dev = new_au1xxx_power_device("LCD", &au1200fb_pm_callback, NULL);
+	if ( LCD_pm_dev == NULL)
+		printk(KERN_INFO "Unable to create a power management device entry for the au1200fb.\n");
+	else
+		printk(KERN_INFO "Power management device entry for the au1200fb loaded.\n");
+	#endif
+
+	return driver_register(&au1200fb_driver);
+}
+
+void __exit au1200fb_cleanup(void)
+{
+	driver_unregister(&au1200fb_driver);
+}
+
+module_init(au1200fb_init);
+module_exit(au1200fb_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.14/drivers/video/au1200fb.h linux-mips-2.6.14.orig/drivers/video/au1200fb.h
--- linux-2.6.14/drivers/video/au1200fb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/video/au1200fb.h	2005-11-17 11:43:49.000000000 -0800
@@ -0,0 +1,288 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Hardware definitions for the Au1200 LCD controller
+ *
+ * Copyright 2004 AMD
+ * Author:	AMD
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AU1200LCD_H
+#define _AU1200LCD_H
+
+/********************************************************************/
+#define AU1200_LCD_ADDR		0xB5000000
+
+#define uint8 unsigned char
+#define uint32 unsigned int
+
+typedef volatile struct
+{
+	uint32	reserved0;
+	uint32	screen;
+	uint32	backcolor;
+	uint32	horztiming;
+	uint32	verttiming;
+	uint32	clkcontrol;
+	uint32	pwmdiv;
+	uint32	pwmhi;
+	uint32	reserved1;
+	uint32	winenable;
+	uint32	colorkey;
+	uint32	colorkeymsk;
+	struct
+	{
+		uint32	cursorctrl;
+		uint32	cursorpos;
+		uint32	cursorcolor0;
+		uint32	cursorcolor1;
+		uint32	cursorcolor2;
+		uint32	cursorcolor3;
+	} hwc;
+	uint32	intstatus;
+	uint32	intenable;
+	uint32	outmask;
+	uint32	fifoctrl;
+	uint32	reserved2[(0x0100-0x0058)/4];
+	struct
+	{
+		uint32	winctrl0;
+		uint32	winctrl1;
+		uint32	winctrl2;
+		uint32	winbuf0;
+		uint32	winbuf1;
+		uint32	winbufctrl;
+		uint32	winreserved0;
+		uint32	winreserved1;
+	} window[4];
+
+	uint32	reserved3[(0x0400-0x0180)/4];
+
+	uint32	palette[(0x0800-0x0400)/4];
+
+	uint8	cursorpattern[256];
+
+} AU1200_LCD;
+
+/* lcd_screen */
+#define LCD_SCREEN_SEN		(1<<31)
+#define LCD_SCREEN_SX		(0x07FF<<19)
+#define LCD_SCREEN_SY		(0x07FF<< 8)
+#define LCD_SCREEN_SWP		(1<<7)
+#define LCD_SCREEN_SWD		(1<<6)
+#define LCD_SCREEN_PT		(7<<0)
+#define LCD_SCREEN_PT_TFT	(0<<0)
+#define LCD_SCREEN_SX_N(WIDTH)	((WIDTH-1)<<19)
+#define LCD_SCREEN_SY_N(HEIGHT)	((HEIGHT-1)<<8)
+#define LCD_SCREEN_PT_CSTN	(1<<0)
+#define LCD_SCREEN_PT_CDSTN	(2<<0)
+#define LCD_SCREEN_PT_M8STN	(3<<0)
+#define LCD_SCREEN_PT_M4STN	(4<<0)
+
+/* lcd_backcolor */
+#define LCD_BACKCOLOR_SBGR		(0xFF<<16)
+#define LCD_BACKCOLOR_SBGG		(0xFF<<8)
+#define LCD_BACKCOLOR_SBGB		(0xFF<<0)
+#define LCD_BACKCOLOR_SBGR_N(N)	((N)<<16)
+#define LCD_BACKCOLOR_SBGG_N(N)	((N)<<8)
+#define LCD_BACKCOLOR_SBGB_N(N)	((N)<<0)
+
+/* lcd_winenable */
+#define LCD_WINENABLE_WEN3		(1<<3)
+#define LCD_WINENABLE_WEN2		(1<<2)
+#define LCD_WINENABLE_WEN1		(1<<1)
+#define LCD_WINENABLE_WEN0		(1<<0)
+
+/* lcd_colorkey */
+#define LCD_COLORKEY_CKR		(0xFF<<16)
+#define LCD_COLORKEY_CKG		(0xFF<<8)
+#define LCD_COLORKEY_CKB		(0xFF<<0)
+#define LCD_COLORKEY_CKR_N(N)	((N)<<16)
+#define LCD_COLORKEY_CKG_N(N)	((N)<<8)
+#define LCD_COLORKEY_CKB_N(N)	((N)<<0)
+
+/* lcd_colorkeymsk */
+#define LCD_COLORKEYMSK_CKMR		(0xFF<<16)
+#define LCD_COLORKEYMSK_CKMG		(0xFF<<8)
+#define LCD_COLORKEYMSK_CKMB		(0xFF<<0)
+#define LCD_COLORKEYMSK_CKMR_N(N)	((N)<<16)
+#define LCD_COLORKEYMSK_CKMG_N(N)	((N)<<8)
+#define LCD_COLORKEYMSK_CKMB_N(N)	((N)<<0)
+
+/* lcd windows control 0 */
+#define LCD_WINCTRL0_OX		(0x07FF<<21)
+#define LCD_WINCTRL0_OY		(0x07FF<<10)
+#define LCD_WINCTRL0_A		(0x00FF<<2)
+#define LCD_WINCTRL0_AEN	(1<<1)
+#define LCD_WINCTRL0_OX_N(N) ((N)<<21)
+#define LCD_WINCTRL0_OY_N(N) ((N)<<10)
+#define LCD_WINCTRL0_A_N(N) ((N)<<2)
+
+/* lcd windows control 1 */
+#define LCD_WINCTRL1_PRI	(3<<30)
+#define LCD_WINCTRL1_PIPE	(1<<29)
+#define LCD_WINCTRL1_FRM	(0xF<<25)
+#define LCD_WINCTRL1_CCO	(1<<24)
+#define LCD_WINCTRL1_PO		(3<<22)
+#define LCD_WINCTRL1_SZX	(0x07FF<<11)
+#define LCD_WINCTRL1_SZY	(0x07FF<<0)
+#define LCD_WINCTRL1_FRM_1BPP	(0<<25)
+#define LCD_WINCTRL1_FRM_2BPP	(1<<25)
+#define LCD_WINCTRL1_FRM_4BPP	(2<<25)
+#define LCD_WINCTRL1_FRM_8BPP	(3<<25)
+#define LCD_WINCTRL1_FRM_12BPP	(4<<25)
+#define LCD_WINCTRL1_FRM_16BPP655	(5<<25)
+#define LCD_WINCTRL1_FRM_16BPP565	(6<<25)
+#define LCD_WINCTRL1_FRM_16BPP556	(7<<25)
+#define LCD_WINCTRL1_FRM_16BPPI1555	(8<<25)
+#define LCD_WINCTRL1_FRM_16BPPI5551	(9<<25)
+#define LCD_WINCTRL1_FRM_16BPPA1555	(10<<25)
+#define LCD_WINCTRL1_FRM_16BPPA5551	(11<<25)
+#define LCD_WINCTRL1_FRM_24BPP		(12<<25)
+#define LCD_WINCTRL1_FRM_32BPP		(13<<25)
+#define LCD_WINCTRL1_PRI_N(N)	((N)<<30)
+#define LCD_WINCTRL1_PO_00		(0<<22)
+#define LCD_WINCTRL1_PO_01		(1<<22)
+#define LCD_WINCTRL1_PO_10		(2<<22)
+#define LCD_WINCTRL1_PO_11		(3<<22)
+#define LCD_WINCTRL1_SZX_N(N)	((N-1)<<11)
+#define LCD_WINCTRL1_SZY_N(N)	((N-1)<<0)
+
+/* lcd windows control 2 */
+#define LCD_WINCTRL2_CKMODE		(3<<24)
+#define LCD_WINCTRL2_DBM		(1<<23)
+#define LCD_WINCTRL2_RAM		(3<<21)
+#define LCD_WINCTRL2_BX			(0x1FFF<<8)
+#define LCD_WINCTRL2_SCX		(0xF<<4)
+#define LCD_WINCTRL2_SCY		(0xF<<0)
+#define LCD_WINCTRL2_CKMODE_00		(0<<24)
+#define LCD_WINCTRL2_CKMODE_01		(1<<24)
+#define LCD_WINCTRL2_CKMODE_10		(2<<24)
+#define LCD_WINCTRL2_CKMODE_11		(3<<24)
+#define LCD_WINCTRL2_RAM_NONE		(0<<21)
+#define LCD_WINCTRL2_RAM_PALETTE	(1<<21)
+#define LCD_WINCTRL2_RAM_GAMMA		(2<<21)
+#define LCD_WINCTRL2_RAM_BUFFER		(3<<21)
+#define LCD_WINCTRL2_BX_N(N)	((N)<<8)
+#define LCD_WINCTRL2_SCX_1		(0<<4)
+#define LCD_WINCTRL2_SCX_2		(1<<4)
+#define LCD_WINCTRL2_SCX_4		(2<<4)
+#define LCD_WINCTRL2_SCY_1		(0<<0)
+#define LCD_WINCTRL2_SCY_2		(1<<0)
+#define LCD_WINCTRL2_SCY_4		(2<<0)
+
+/* lcd windows buffer control */
+#define LCD_WINBUFCTRL_DB		(1<<1)
+#define LCD_WINBUFCTRL_DBN		(1<<0)
+
+/* lcd_intstatus, lcd_intenable */
+#define LCD_INT_IFO				(0xF<<14)
+#define LCD_INT_IFU				(0xF<<10)
+#define LCD_INT_OFO				(1<<9)
+#define LCD_INT_OFU				(1<<8)
+#define LCD_INT_WAIT			(1<<3)
+#define LCD_INT_SD				(1<<2)
+#define LCD_INT_SA				(1<<1)
+#define LCD_INT_SS				(1<<0)
+
+/* lcd_horztiming */
+#define LCD_HORZTIMING_HND2		(0x1FF<<18)
+#define LCD_HORZTIMING_HND1		(0x1FF<<9)
+#define LCD_HORZTIMING_HPW		(0x1FF<<0)
+#define LCD_HORZTIMING_HND2_N(N)(((N)-1)<<18)
+#define LCD_HORZTIMING_HND1_N(N)(((N)-1)<<9)
+#define LCD_HORZTIMING_HPW_N(N)	(((N)-1)<<0)
+
+/* lcd_verttiming */
+#define LCD_VERTTIMING_VND2		(0x1FF<<18)
+#define LCD_VERTTIMING_VND1		(0x1FF<<9)
+#define LCD_VERTTIMING_VPW		(0x1FF<<0)
+#define LCD_VERTTIMING_VND2_N(N)(((N)-1)<<18)
+#define LCD_VERTTIMING_VND1_N(N)(((N)-1)<<9)
+#define LCD_VERTTIMING_VPW_N(N)	(((N)-1)<<0)
+
+/* lcd_clkcontrol */
+#define LCD_CLKCONTROL_EXT		(1<<22)
+#define LCD_CLKCONTROL_DELAY	(3<<20)
+#define LCD_CLKCONTROL_CDD		(1<<19)
+#define LCD_CLKCONTROL_IB		(1<<18)
+#define LCD_CLKCONTROL_IC		(1<<17)
+#define LCD_CLKCONTROL_IH		(1<<16)
+#define LCD_CLKCONTROL_IV		(1<<15)
+#define LCD_CLKCONTROL_BF		(0x1F<<10)
+#define LCD_CLKCONTROL_PCD		(0x3FF<<0)
+#define LCD_CLKCONTROL_BF_N(N)	(((N)-1)<<10)
+#define LCD_CLKCONTROL_PCD_N(N)	((N)<<0)
+
+/* lcd_pwmdiv */
+#define LCD_PWMDIV_EN			(1<<31)
+#define LCD_PWMDIV_PWMDIV		(0x1FFFF<<0)
+#define LCD_PWMDIV_PWMDIV_N(N)	((N)<<0)
+
+/* lcd_pwmhi */
+#define LCD_PWMHI_PWMHI1		(0xFFFF<<16)
+#define LCD_PWMHI_PWMHI0		(0xFFFF<<0)
+#define LCD_PWMHI_PWMHI1_N(N)	((N)<<16)
+#define LCD_PWMHI_PWMHI0_N(N)	((N)<<0)
+
+/* lcd_hwccon */
+#define LCD_HWCCON_EN			(1<<0)
+
+/* lcd_cursorpos */
+#define LCD_CURSORPOS_HWCXOFF		(0x1F<<27)
+#define LCD_CURSORPOS_HWCXPOS		(0x07FF<<16)
+#define LCD_CURSORPOS_HWCYOFF		(0x1F<<11)
+#define LCD_CURSORPOS_HWCYPOS		(0x07FF<<0)
+#define LCD_CURSORPOS_HWCXOFF_N(N)	((N)<<27)
+#define LCD_CURSORPOS_HWCXPOS_N(N)	((N)<<16)
+#define LCD_CURSORPOS_HWCYOFF_N(N)	((N)<<11)
+#define LCD_CURSORPOS_HWCYPOS_N(N)	((N)<<0)
+
+/* lcd_cursorcolor */
+#define LCD_CURSORCOLOR_HWCA		(0xFF<<24)
+#define LCD_CURSORCOLOR_HWCR		(0xFF<<16)
+#define LCD_CURSORCOLOR_HWCG		(0xFF<<8)
+#define LCD_CURSORCOLOR_HWCB		(0xFF<<0)
+#define LCD_CURSORCOLOR_HWCA_N(N)	((N)<<24)
+#define LCD_CURSORCOLOR_HWCR_N(N)	((N)<<16)
+#define LCD_CURSORCOLOR_HWCG_N(N)	((N)<<8)
+#define LCD_CURSORCOLOR_HWCB_N(N)	((N)<<0)
+
+/* lcd_fifoctrl */
+#define LCD_FIFOCTRL_F3IF		(1<<29)
+#define LCD_FIFOCTRL_F3REQ		(0x1F<<24)
+#define LCD_FIFOCTRL_F2IF		(1<<29)
+#define LCD_FIFOCTRL_F2REQ		(0x1F<<16)
+#define LCD_FIFOCTRL_F1IF		(1<<29)
+#define LCD_FIFOCTRL_F1REQ		(0x1F<<8)
+#define LCD_FIFOCTRL_F0IF		(1<<29)
+#define LCD_FIFOCTRL_F0REQ		(0x1F<<0)
+#define LCD_FIFOCTRL_F3REQ_N(N)	((N-1)<<24)
+#define LCD_FIFOCTRL_F2REQ_N(N)	((N-1)<<16)
+#define LCD_FIFOCTRL_F1REQ_N(N)	((N-1)<<8)
+#define LCD_FIFOCTRL_F0REQ_N(N)	((N-1)<<0)
+
+/* lcd_outmask */
+#define LCD_OUTMASK_MASK		(0x00FFFFFF)
+
+/********************************************************************/
+#endif /* _AU1200LCD_H */
diff -Naur linux-2.6.14/drivers/video/console/newport_con.c linux-mips-2.6.14.orig/drivers/video/console/newport_con.c
--- linux-2.6.14/drivers/video/console/newport_con.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/video/console/newport_con.c	2005-11-17 11:43:49.000000000 -0800
@@ -32,7 +32,6 @@
 #include <linux/font.h>
 
 
-extern struct font_desc font_vga_8x16;
 extern unsigned long sgi_gfxaddr;
 
 #define FONT_DATA ((unsigned char *)font_vga_8x16.data)
diff -Naur linux-2.6.14/drivers/video/epson1356fb.c linux-mips-2.6.14.orig/drivers/video/epson1356fb.c
--- linux-2.6.14/drivers/video/epson1356fb.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/video/epson1356fb.c	2005-11-17 11:43:49.000000000 -0800
@@ -0,0 +1,3117 @@
+/*
+ *      epson1356fb.c  --  Epson SED1356 Framebuffer Driver
+ *
+ * Copyright 2001, 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * 
+ * TODO:
+ *
+ *  Revision history
+ *    03.12.2001  0.1   Initial release
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/selection.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/nvram.h>
+#include <linux/kd.h>
+#include <linux/vt_kern.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/timer.h>
+#include <linux/pagemap.h>
+
+#include <asm/pgalloc.h>
+#include <asm/uaccess.h>
+#include <asm/tlb.h>
+
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#include <linux/spinlock.h>
+
+#include <linux/e1356fb.h>
+
+#ifdef CONFIG_MIPS_AU1000
+#include <asm/au1000.h>
+#endif
+
+#define E1356FB_DEBUG 1
+#undef E1356FB_VERBOSE_DEBUG
+#undef SHADOW_FRAME_BUFFER
+#include "epson1356fb.h"
+
+static char *options;
+MODULE_PARM(options, "s");
+
+/*
+ *  Frame buffer device API
+ */
+static int e1356fb_open(struct fb_info *fb, int user);
+static int e1356fb_release(struct fb_info *fb, int user);
+static int e1356fb_get_fix(struct fb_fix_screeninfo* fix, 
+			   int con,
+			   struct fb_info* fb);
+static int e1356fb_get_var(struct fb_var_screeninfo* var, 
+			   int con,
+			   struct fb_info* fb);
+static int e1356fb_set_var(struct fb_var_screeninfo* var,
+			   int con,
+			   struct fb_info* fb);
+static int e1356fb_pan_display(struct fb_var_screeninfo* var, 
+			       int con,
+			       struct fb_info* fb);
+static int e1356fb_get_cmap(struct fb_cmap *cmap, 
+			    int kspc, 
+			    int con,
+			    struct fb_info* info);
+static int e1356fb_set_cmap(struct fb_cmap* cmap, 
+			    int kspc, 
+			    int con,
+			    struct fb_info* info);
+static int e1356fb_ioctl(struct inode* inode, 
+			 struct file* file, 
+			 u_int cmd,
+			 u_long arg, 
+			 int con, 
+			 struct fb_info* info);
+static int e1356fb_mmap(struct fb_info *info,
+			struct file *file,
+			struct vm_area_struct *vma);
+
+/*
+ *  Interface to the low level console driver
+ */
+static int  e1356fb_switch_con(int con, 
+			       struct fb_info* fb);
+static int  e1356fb_updatevar(int con, 
+			      struct fb_info* fb);
+static void e1356fb_blank(int blank, 
+			  struct fb_info* fb);
+
+/*
+ *  Internal routines
+ */
+static void e1356fb_set_par(const struct e1356fb_par* par,
+			    struct fb_info_e1356* 
+			    info);
+static int  e1356fb_var_to_par(const struct fb_var_screeninfo *var,
+			       struct e1356fb_par* par,
+			       const struct fb_info_e1356* info);
+static int  e1356fb_par_to_var(struct fb_var_screeninfo* var,
+			       struct e1356fb_par* par,
+			       const struct fb_info_e1356* info);
+static int  e1356fb_encode_fix(struct fb_fix_screeninfo* fix,
+			       const struct e1356fb_par* par,
+			       const struct fb_info_e1356* info);
+static void e1356fb_set_dispsw(struct display* disp, 
+			       struct fb_info_e1356* info,
+			       int bpp, 
+			       int accel);
+static int  e1356fb_getcolreg(u_int regno,
+			      u_int* red, 
+			      u_int* green, 
+			      u_int* blue,
+			      u_int* transp, 
+			      struct fb_info* fb);
+static int  e1356fb_setcolreg(u_int regno, 
+			      u_int red, 
+			      u_int green, 
+			      u_int blue,
+			      u_int transp, 
+			      struct fb_info* fb);
+static void  e1356fb_install_cmap(struct display *d, 
+				  struct fb_info *info);
+
+static void e1356fb_hwcursor_init(struct fb_info_e1356* info);
+static void e1356fb_createcursorshape(struct display* p);
+static void e1356fb_createcursor(struct display * p);  
+
+/*
+ * do_xxx: Hardware-specific functions
+ */
+static void  do_pan_var(struct fb_var_screeninfo* var,
+			struct fb_info_e1356* i);
+static void  do_flashcursor(unsigned long ptr);
+static void  doBlt_Move(const struct e1356fb_par* par,
+			struct fb_info_e1356* i,
+			blt_info_t* blt);
+static void  doBlt_SolidFill(const struct e1356fb_par* par,
+			     struct fb_info_e1356* i,
+			     blt_info_t* blt);
+
+/*
+ *  Interface used by the world
+ */
+int e1356fb_init(void);
+void e1356fb_setup(char *options, int *ints);
+
+static int currcon = 0;
+
+static struct fb_ops e1356fb_ops = {
+	.owner	= THIS_MODULE,
+	.fb_open        = e1356fb_open,
+	.fb_release     = e1356fb_release,
+	.fb_get_fix	= e1356fb_get_fix,
+	.fb_get_var	= e1356fb_get_var,
+	.fb_set_var	= e1356fb_set_var,
+	.fb_get_cmap    = e1356fb_get_cmap,
+	.fb_set_cmap    = e1356fb_set_cmap,
+	.fb_pan_display = e1356fb_pan_display,
+	.fb_mmap        = e1356fb_mmap,
+};
+
+#define PCI_VENDOR_ID_EPSON         0x10f4
+#define PCI_DEVICE_ID_EPSON_SDU1356 0x1300
+
+
+static struct fb_info_e1356 fb_info;
+static struct e1356fb_fix boot_fix; // boot options
+static struct e1356fb_par boot_par; // boot options
+
+static int e1356_remap_page_range(unsigned long from, phys_t phys_addr, unsigned long size, pgprot_t prot);
+
+
+/* ------------------------------------------------------------------------- 
+ *                      Hardware-specific funcions
+ * ------------------------------------------------------------------------- */
+
+/*
+ * The SED1356 has only a 16-bit wide data bus, so some embedded
+ * implementations with 32-bit CPU's (Alchemy Pb1000) may not
+ * correctly emulate a 32-bit write to the framebuffer by splitting
+ * the write into two seperate 16-bit writes. So it is safest to
+ * only do byte or half-word writes to the fb. This routine assumes
+ * fbaddr is atleast aligned on a half-word boundary.
+ */
+static inline void
+fbfill(u16* fbaddr, u8 val, int size)
+{
+	u16 valw = (u16)val | ((u16)val << 8);
+	for ( ; size >= 2; size -= 2)
+		writew(valw, fbaddr++);
+	if (size)
+		writeb(val, (u8*)fbaddr);
+}
+
+static inline int
+e1356_wait_bitclr(u8* reg, u8 bit, int timeout)
+{
+	while (readb(reg) & bit) {
+		udelay(10);
+		if (!--timeout)
+			break;
+	}
+	return timeout;
+}
+
+static inline int
+e1356_wait_bitset(u8* reg, u8 bit, int timeout)
+{
+	while (!(readb(reg) & bit)) {
+		udelay(10);
+		if (!--timeout)
+			break;
+	}
+	return timeout;
+}
+
+
+static struct fb_videomode panel_modedb[] = {
+	{
+		/* 320x240 @ 109 Hz, 33.3 kHz hsync */
+		NULL, 109, 320, 240, KHZ2PICOS(MAX_PIXCLOCK/3),
+		16, 16, 32, 24, 48, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 640x480 @ 84 Hz, 48.1 kHz hsync */
+		NULL, 84, 640, 480, KHZ2PICOS(MAX_PIXCLOCK/1),
+		96, 32, 32, 48, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 800x600 @ 76 Hz, 46.3 kHz hsync */
+		NULL, 76, 800, 600, KHZ2PICOS(MAX_PIXCLOCK/1),
+		32, 10, 1, 1, 22, 1,
+		0, FB_VMODE_NONINTERLACED
+	}
+};
+static struct fb_videomode crt_modedb[] = {
+	{
+		/* 320x240 @ 84 Hz, 31.25 kHz hsync */
+		NULL, 84, 320, 240, KHZ2PICOS(MAX_PIXCLOCK/2),
+		128, 128, 60, 60, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 320x240 @ 109 Hz, 33.3 kHz hsync */
+		NULL, 109, 320, 240, KHZ2PICOS(MAX_PIXCLOCK/3),
+		16, 16, 32, 24, 48, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 512x384 @ 77 Hz, 31.25 kHz hsync */
+		NULL, 77, 512, 384, KHZ2PICOS(MAX_PIXCLOCK/2),
+		48, 16, 16, 1, 64, 3,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 640x400 @ 88 Hz, 43.1 kHz hsync */
+		NULL, 88, 640, 400, KHZ2PICOS(MAX_PIXCLOCK/1),
+		128, 96, 32, 48, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 640x480 @ 84 Hz, 48.1 kHz hsync */
+		NULL, 84, 640, 480, KHZ2PICOS(MAX_PIXCLOCK/1),
+		96, 32, 32, 48, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 768x576 @ 62 Hz, 38.5 kHz hsync */
+		NULL, 62, 768, 576, KHZ2PICOS(MAX_PIXCLOCK/1),
+		144, 16, 28, 6, 112, 4,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 800x600 @ 60 Hz, 37.9 kHz hsync */
+		NULL, 60, 800, 600, KHZ2PICOS(MAX_PIXCLOCK/1),
+		88, 40, 23, 1, 128, 4,
+		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED
+	}
+};
+
+static struct fb_videomode ntsc_modedb[] = {
+	{
+		/* 640x480 @ 62 Hz, requires flicker filter */
+		//NULL, 62, 640, 480, 34921, 213, 57, 20, 2, 0, 0,
+		NULL, 62, 640, 480, KHZ2PICOS(2*NTSC_PIXCLOCK),
+		200, 70, 15, 7, 0, 0,
+		FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED
+	}
+};
+static struct fb_videomode pal_modedb[] = {
+	{
+		/* 640x480 @ 56 Hz, requires flicker filter */
+		NULL, 56, 640, 480, KHZ2PICOS(2*PAL_PIXCLOCK),
+		350, 145, 49, 23, 0, 0,
+		FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED
+	}
+};
+
+
+static inline void
+fb_videomode_to_var(struct fb_videomode* mode,
+		    struct fb_var_screeninfo*var)
+{
+	var->xres = mode->xres;
+	var->yres = mode->yres;
+	var->pixclock = mode->pixclock;
+	var->left_margin = mode->left_margin;
+	var->right_margin = mode->right_margin;
+	var->upper_margin = mode->upper_margin;
+	var->lower_margin = mode->lower_margin;
+	var->hsync_len = mode->hsync_len;
+	var->vsync_len = mode->vsync_len;
+	var->sync = mode->sync;
+	var->vmode = mode->vmode;
+}
+
+
+static int
+e1356fb_get_mode(const struct fb_info_e1356 *info,
+		 int xres,
+		 int yres,
+		 struct fb_videomode ** modedb,
+		 struct fb_videomode ** mode)
+{
+	struct fb_videomode * ret;
+	int i, dbsize;
+
+	if (IS_PANEL(info->fix.disp_type)) {
+		ret = panel_modedb;
+		dbsize = sizeof(panel_modedb)/sizeof(struct fb_videomode);
+	} else if (info->fix.disp_type == DISP_TYPE_CRT) {
+		ret = crt_modedb;
+		dbsize = sizeof(crt_modedb)/sizeof(struct fb_videomode);
+	} else if (info->fix.disp_type == DISP_TYPE_NTSC) {
+		ret = ntsc_modedb;
+		dbsize = sizeof(ntsc_modedb)/sizeof(struct fb_videomode);
+	} else {
+		ret = pal_modedb;
+		dbsize = sizeof(pal_modedb)/sizeof(struct fb_videomode);
+	}
+	
+	if (modedb)
+		*modedb = ret;
+	for (i=0; i<dbsize; i++) {
+		if (xres == ret[i].xres && yres == ret[i].yres) {
+			*mode = &ret[i];
+			break;
+		}
+	}
+	if (i == dbsize)
+		return -EINVAL;
+	return dbsize;
+}
+
+
+
+#ifdef E1356FB_VERBOSE_DEBUG
+static void
+dump_par(const struct e1356fb_par* par)
+{
+	DPRINTK("width:       %d\n", par->width);
+	DPRINTK("height:      %d\n", par->height);
+	DPRINTK("width_virt:  %d\n", par->width_virt);
+	DPRINTK("height_virt: %d\n", par->height_virt);
+	DPRINTK("bpp:         %d\n", par->bpp);
+	DPRINTK("pixclock:    %d\n", par->ipclk.pixclk);
+	DPRINTK("horiz_ndp:   %d\n", par->horiz_ndp);
+	DPRINTK("vert_ndp:    %d\n", par->vert_ndp);
+	DPRINTK("hsync_pol:   %d\n", par->hsync_pol);
+	DPRINTK("hsync_start: %d\n", par->hsync_start);
+	DPRINTK("hsync_width: %d\n", par->hsync_width);
+	DPRINTK("vsync_pol:   %d\n", par->vsync_pol);
+	DPRINTK("vsync_start: %d\n", par->vsync_start);
+	DPRINTK("vsync_width: %d\n", par->vsync_width);
+	DPRINTK("cmap_len:    %d\n", par->cmap_len);
+}
+
+static void
+dump_display_regs(reg_dispcfg_t* dispcfg, reg_dispmode_t* dispmode)
+{
+	DPRINTK("hdw:            0x%02x\n", readb(&dispcfg->hdw));
+	DPRINTK("hndp:           0x%02x\n", readb(&dispcfg->hndp));
+	DPRINTK("hsync_start:    0x%02x\n", readb(&dispcfg->hsync_start));
+	DPRINTK("hsync_pulse:    0x%02x\n", readb(&dispcfg->hsync_pulse));
+	DPRINTK("vdh0:           0x%02x\n", readb(&dispcfg->vdh0));
+	DPRINTK("vdh1:           0x%02x\n", readb(&dispcfg->vdh1));
+	DPRINTK("vndp:           0x%02x\n", readb(&dispcfg->vndp));
+	DPRINTK("vsync_start:    0x%02x\n", readb(&dispcfg->vsync_start));
+	DPRINTK("vsync_pulse:    0x%02x\n", readb(&dispcfg->vsync_pulse));
+	DPRINTK("tv_output_ctrl: 0x%02x\n\n", readb(&dispcfg->tv_output_ctrl));
+
+	DPRINTK("disp_mode:        0x%02x\n", readb(&dispmode->disp_mode));
+	DPRINTK("lcd_misc:         0x%02x\n", readb(&dispmode->lcd_misc));
+	DPRINTK("start_addr0:      0x%02x\n", readb(&dispmode->start_addr0));
+	DPRINTK("start_addr1:      0x%02x\n", readb(&dispmode->start_addr1));
+	DPRINTK("start_addr2:      0x%02x\n", readb(&dispmode->start_addr2));
+	DPRINTK("mem_addr_offset0: 0x%02x\n", readb(&dispmode->mem_addr_offset0));
+	DPRINTK("mem_addr_offset1: 0x%02x\n", readb(&dispmode->mem_addr_offset1));
+	DPRINTK("pixel_panning:    0x%02x\n", readb(&dispmode->pixel_panning));
+	DPRINTK("fifo_high_thresh: 0x%02x\n", readb(&dispmode->fifo_high_thresh));
+	DPRINTK("fifo_low_thresh:  0x%02x\n", readb(&dispmode->fifo_low_thresh));
+}
+
+static void
+dump_fb(u8* base, int len)
+{
+	int i;
+	DPRINTK("FB memory dump, start 0x%p, len %d", base, len);
+	for (i=0; i<len; i++) {
+		if (!(i%16))
+			printk("\n%p: %02x ", &base[i], readb(&base[i]));
+		else
+			printk("%02x ", readb(&base[i]));
+	}
+	printk("\n");
+}
+
+#endif // E1356FB_VERBOSE_DEBUG
+
+
+
+// Input:  ipclk->clksrc, ipclk->pixclk_d
+// Output: ipclk->pixclk, ipclk->error, and ipclk->divisor
+static int
+get_nearest_pixclk_div(pixclock_info_t* ipclk, int x2)
+{
+	int pixclk_d = ipclk->pixclk_d;
+	int clksrc = ipclk->clksrc;
+
+	if (x2) clksrc *= 2;
+
+	if (clksrc < (3*pixclk_d+1)/2)
+		ipclk->divisor = 1;
+	else if (clksrc < (5*pixclk_d+1)/2)
+		ipclk->divisor = 2;
+	else if (clksrc < (7*pixclk_d+1)/2)
+		ipclk->divisor = 3;
+	else if (clksrc < (9*pixclk_d+1)/2)
+		ipclk->divisor = 4;
+	else
+		return -ENXIO;
+
+	ipclk->pixclk = clksrc / ipclk->divisor;
+	ipclk->error = (100*(pixclk_d - ipclk->pixclk)) / pixclk_d;
+	return 0;
+}
+
+static int
+e1356_calc_pixclock(const struct fb_info_e1356 *info,
+		    pixclock_info_t* ipclk)
+{
+	int src_sel=-1, flicker_mult=0;
+	pixclock_info_t test, ret;
+    
+	if (ipclk->pixclk > info->max_pixclock)
+		return -ENXIO;
+
+	test.pixclk_d = ipclk->pixclk_d;
+	ret.error = 100;
+	
+	if (IS_TV(info->fix.disp_type) &&
+	    (info->fix.tv_filt & TV_FILT_FLICKER))
+		flicker_mult = 0x80;
+	
+	test.clksrc = info->fix.busclk;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x01;
+	}
+
+	test.clksrc = info->fix.mclk;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x03;
+	}
+
+	test.clksrc = info->fix.clki;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x00;
+	}
+
+	test.clksrc = info->fix.clki2;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x02;
+	}
+
+	if (ret.error > MAX_PCLK_ERROR_LOWER ||
+	    ret.error < MAX_PCLK_ERROR_HIGHER)
+		return -ENXIO;
+    
+	ret.pixclk_bits = flicker_mult | ((ret.divisor-1)<<4) | src_sel;
+	*ipclk = ret;
+	return 0;
+}
+
+static inline int
+e1356_engine_wait_complete(reg_bitblt_t* bltreg)
+{
+	return e1356_wait_bitclr(&bltreg->ctrl0, 0x80, 5000);
+}
+static inline int
+e1356_engine_wait_busy(reg_bitblt_t* bltreg)
+{
+	return e1356_wait_bitset(&bltreg->ctrl0, 0x80, 5000);
+}
+
+static void
+e1356fb_engine_init(const struct e1356fb_par* par,
+		    struct fb_info_e1356* info)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+    
+	e1356_engine_wait_complete(bltreg);
+
+	writeb(0, &bltreg->ctrl0);
+	writeb(0, &bltreg->ctrl1);
+	writeb(0, &bltreg->rop_code);
+	writeb(0, &bltreg->operation);
+	writeb(0, &bltreg->src_start_addr0);
+	writeb(0, &bltreg->src_start_addr1);
+	writeb(0, &bltreg->src_start_addr2);
+	writeb(0, &bltreg->dest_start_addr0);
+	writeb(0, &bltreg->dest_start_addr1);
+	writeb(0, &bltreg->dest_start_addr2);
+	writew(0, &bltreg->mem_addr_offset0);
+	writew(0, &bltreg->width0);
+	writew(0, &bltreg->height0);
+	writew(0, &bltreg->bg_color0);
+	writew(0, &bltreg->fg_color0);
+}
+
+
+static void doBlt_Write(const struct e1356fb_par* par,
+			struct fb_info_e1356* info,
+			blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	int nWords, nTotalWords;
+	u32 srcphase, dstAddr;
+	u16* w16;
+	u32 stride = par->width_virt * par->Bpp;
+
+	dstAddr = blt->dst_x * par->Bpp + blt->dst_y * stride;
+	srcphase = (u32)blt->src & 1;
+    
+	if (blt->attribute & BLT_ATTR_TRANSPARENT)
+		writew(blt->bg_color, &bltreg->bg_color0);
+	else
+		writeb(blt->rop, &bltreg->rop_code);
+    
+	writeb(blt->operation, &bltreg->operation);
+	writeb((u8)srcphase, &bltreg->src_start_addr0);
+	writew(stride/2, &bltreg->mem_addr_offset0);
+
+	writeb(dstAddr, &bltreg->dest_start_addr0);
+	writeb(dstAddr>>8, &bltreg->dest_start_addr1);
+	writeb(dstAddr>>16, &bltreg->dest_start_addr2);
+
+	writew(blt->dst_width-1, &bltreg->width0);
+	writew(blt->dst_height-1, &bltreg->height0);
+
+	// program color format operation
+	writeb(par->bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+
+	// start it up
+	writeb(0x80, &bltreg->ctrl0);
+
+	// wait for it to actually start
+	e1356_engine_wait_busy(bltreg);
+
+	// calculate the number of 16 bit words per one blt line
+
+	nWords = srcphase + ((blt->dst_width - srcphase)*par->Bpp + 1) / 2;
+	nTotalWords = nWords*blt->dst_height;
+	w16 = (u16*)((u32)blt->src & 0xfffffffe);   // Word aligned
+
+	while (nTotalWords > 0) {
+		int j, nFIFO;
+		u8 ctrl0;
+
+		// read the FIFO status
+		ctrl0 = readb(&bltreg->ctrl0);
+
+		if ((ctrl0 & 0x30) == 0x20)
+			// FIFO is at least half full, but not full
+			nFIFO = 1;
+		else if ((ctrl0 & 0x40) == 0)
+			// FIFO is empty
+			nFIFO = 16;
+		else
+			// FIFO is full
+			continue;
+
+		for (j = 0; j < nFIFO && nTotalWords > 0; j++,nTotalWords--)
+			writew(*w16++, info->reg.bitblt_data);
+	}
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+static void
+doBlt_SolidFill(const struct e1356fb_par* par,
+		struct fb_info_e1356* info,
+		blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	u32 width = blt->dst_width, height = blt->dst_height;
+	u32 stride = par->width_virt * par->Bpp;
+	u32 dest_addr = (blt->dst_y * stride) + (blt->dst_x * par->Bpp);
+
+	if (width == 0 || height == 0)
+		return;
+
+	// program dest address
+	writeb(dest_addr & 0x00ff, &bltreg->dest_start_addr0);
+	writeb((dest_addr>>8) & 0x00ff, &bltreg->dest_start_addr1);
+	writeb((dest_addr>>16) & 0x00ff, &bltreg->dest_start_addr2);
+
+	// program width and height of solid-fill blit
+	writew(width-1, &bltreg->width0);
+	writew(height-1, &bltreg->height0);
+
+	// program color of fill
+	writew(blt->fg_color, &bltreg->fg_color0);
+	// select solid-fill BLIT
+	writeb(BLT_SOLID_FILL, &bltreg->operation);
+	// program color format operation
+	writeb(par->bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+	// program BLIT memory offset
+	writew(stride/2, &bltreg->mem_addr_offset0);
+
+	// start it up (self completes)
+	writeb(0x80, &bltreg->ctrl0);
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+static void
+doBlt_Move(const struct e1356fb_par* par,
+	   struct fb_info_e1356* info,
+	   blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	int neg_dir=0;
+	u32 dest_addr, src_addr;
+	u32 bpp = par->bpp;
+	u32 stride = par->width_virt * par->Bpp; // virt line length in bytes
+	u32 srcx = blt->src_x, srcy = blt->src_y;
+	u32 dstx = blt->dst_x, dsty = blt->dst_y;
+	u32 width = blt->dst_width, height = blt->dst_height;
+    
+	if (width == 0 || height == 0)
+		return;
+   
+	src_addr = srcx*par->Bpp + srcy*stride;
+	dest_addr = dstx*par->Bpp + dsty*stride;
+
+	/*
+	 * See if regions overlap and dest region is beyond source region.
+	 * If so, we need to do a move BLT in negative direction. Only applies
+	 * if the BLT is not transparent.
+	 */
+	if (!(blt->attribute & BLT_ATTR_TRANSPARENT)) {
+		if ((srcx + width  > dstx) && (srcx < dstx + width) &&
+		    (srcy + height > dsty) && (srcy < dsty + height) &&
+		    (dest_addr > src_addr)) {
+			neg_dir = 1;
+			// negative direction : get the coords of lower right corner
+			src_addr += stride * (height-1) + par->Bpp * (width-1);
+			dest_addr += stride * (height-1) + par->Bpp * (width-1);
+		}
+	}
+    
+	// program BLIT memory offset
+	writew(stride/2, &bltreg->mem_addr_offset0);
+
+	// program src and dest addresses
+	writeb(src_addr & 0x00ff, &bltreg->src_start_addr0);
+	writeb((src_addr>>8) & 0x00ff, &bltreg->src_start_addr1);
+	writeb((src_addr>>16) & 0x00ff, &bltreg->src_start_addr2);
+	writeb(dest_addr & 0x00ff, &bltreg->dest_start_addr0);
+	writeb((dest_addr>>8) & 0x00ff, &bltreg->dest_start_addr1);
+	writeb((dest_addr>>16) & 0x00ff, &bltreg->dest_start_addr2);
+
+	// program width and height of blit
+	writew(width-1, &bltreg->width0);
+	writew(height-1, &bltreg->height0);
+
+	// program color format operation
+	writeb(bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+
+	// set the blt type
+	if (blt->attribute & BLT_ATTR_TRANSPARENT) {
+		writew(blt->bg_color, &bltreg->bg_color0);
+		writeb(BLT_MOVE_POS_TRANSP, &bltreg->operation); 
+	} else {
+		writeb(blt->rop, &bltreg->rop_code);
+		// select pos/neg move BLIT
+		writeb(neg_dir ? BLT_MOVE_NEG_ROP : BLT_MOVE_POS_ROP,
+		       &bltreg->operation); 
+	}
+
+	// start it up (self completes)
+	writeb(0x80, &bltreg->ctrl0);
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+static void doBlt_ColorExpand(const struct e1356fb_par* par,
+			      struct fb_info_e1356* info,
+			      blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	int i, j, nWords, Sx, Sy;
+	u32 dstAddr;
+	u16* wpt, *wpt1;
+	u32 stride = par->width_virt * par->Bpp;
+
+	if (blt->dst_width == 0 || blt->dst_height == 0)
+		return;
+
+	Sx = blt->src_x;
+	Sy = blt->src_y;
+
+	writeb((7 - Sx%8), &bltreg->rop_code);
+
+	writeb(blt->operation, &bltreg->operation);
+
+	writeb((u8)(Sx & 1), &bltreg->src_start_addr0);
+
+	dstAddr = blt->dst_x*par->Bpp + blt->dst_y * stride;
+	writeb(dstAddr, &bltreg->dest_start_addr0);
+	writeb(dstAddr>>8, &bltreg->dest_start_addr1);
+	writeb(dstAddr>>16, &bltreg->dest_start_addr2);
+
+	// program color format operation
+	writeb(par->bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+	writew(stride/2, &bltreg->mem_addr_offset0);
+	writew(blt->dst_width-1, &bltreg->width0);
+	writew(blt->dst_height-1, &bltreg->height0);
+	writew(blt->bg_color, &bltreg->bg_color0);
+	writew(blt->fg_color, &bltreg->fg_color0);
+
+	// start it up
+	writeb(0x80, &bltreg->ctrl0);
+
+	// wait for it to actually start
+	e1356_engine_wait_busy(bltreg);
+
+	// calculate the number of 16 bit words per one blt line
+
+	nWords = (Sx%16 + blt->dst_width + 15)/16;
+
+	wpt = blt->src + (Sy*blt->srcstride + Sx/16)/2;
+
+	for (i = 0; i < blt->dst_height; i++) {
+		wpt1 = wpt;
+
+		for (j = 0; j < nWords; j++) {
+			// loop until FIFO becomes empty...
+			e1356_wait_bitclr(&bltreg->ctrl0, 0x40, 10000);
+			writew(*wpt1++, info->reg.bitblt_data);
+		}
+	
+		wpt += blt->srcstride/2;
+	}
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+/*
+ * The BitBLT operation dispatcher
+ */
+static int
+doBlt(const struct e1356fb_par* par,
+      struct fb_info_e1356* info,
+      blt_info_t* blt)
+{
+	/*
+	 * Make sure we're not reentering in the middle of an
+	 * active BitBLT operation. ALWAYS call this dispatcher
+	 * and not one of the above BLT routines directly, or you
+	 * run the risk of overlapping BLT operations, which can
+	 * cause complete system hangs.
+     */
+	if (readb(&info->reg.bitblt->ctrl0) & 0x80)
+		return -ENXIO;
+    
+	switch (blt->operation) {
+	case BLT_MOVE_POS_ROP:
+	case BLT_MOVE_NEG_ROP:
+	case BLT_MOVE_POS_TRANSP:
+		doBlt_Move(par, info, blt);
+		break;
+	case BLT_COLOR_EXP:
+	case BLT_COLOR_EXP_TRANSP:
+		doBlt_ColorExpand(par, info, blt);
+		break;
+	case BLT_SOLID_FILL:
+		doBlt_SolidFill(par, info, blt);
+		break;
+	case BLT_WRITE_ROP:
+	case BLT_WRITE_TRANSP:
+		doBlt_Write(par, info, blt);
+		break;
+	case BLT_READ:
+	case BLT_PAT_FILL_ROP:
+	case BLT_PAT_FILL_TRANSP:
+	case BLT_MOVE_COLOR_EXP:
+	case BLT_MOVE_COLOR_EXP_TRANSP:
+		DPRINTK("BitBLT operation 0x%02x not implemented yet\n",
+			blt->operation);
+		return -ENXIO;
+	default:
+		DPRINTK("Unknown BitBLT operation 0x%02x\n", blt->operation);
+		return -ENXIO;
+	}
+    
+	return 0;
+}
+
+
+// Initializes blt->src and blt->srcstride
+static void fill_putcs_buffer(struct display *p,
+			      blt_info_t* blt,
+			      const unsigned short* str,
+			      int count)
+{   
+	int row, i, j;
+	u8* b1, *b2;
+	u32 fw = fontwidth(p);
+	u32 fwb = (fw + 7) >> 3;
+	u32 fh = fontheight(p);
+	int bytesPerChar = fwb * fh;
+
+	if (count*bytesPerChar > PAGE_SIZE) {
+		// Truncate the string if it overflows putcs_buffer, which is
+		// one page in size.
+		count = PAGE_SIZE/bytesPerChar - 1;
+	}
+
+	blt->srcstride = (fwb*count + 1) & ~1; //round up to be even
+	
+	b1 = (u8*)blt->src;
+
+	for (row = 0; row < fh; row++) {
+		b2 = b1;
+		for (i = 0; i < count; i++) {
+			for (j=0; j<fwb; j++)
+				*b2++ = p->fontdata[(str[i] & p->charmask) *
+						   bytesPerChar +
+						   row*fwb + j];
+		}
+		b1 += blt->srcstride;
+	}
+}
+
+
+/*
+ * Set the color of a palette entry in 8bpp mode 
+ */
+static inline void
+do_setpalentry(reg_lut_t* lut, unsigned regno,
+	       u8 r, u8 g, u8 b)
+{
+	writeb(0x00, &lut->mode);
+	writeb((u8)regno, &lut->addr);
+	writeb(r&0xf0, &lut->data);
+	writeb(g&0xf0, &lut->data);
+	writeb(b&0xf0, &lut->data);
+}
+
+   
+static void
+do_pan_var(struct fb_var_screeninfo* var, struct fb_info_e1356* info)
+{
+	u32 pixel_start, start_addr;
+	u8 pixel_pan;
+	struct e1356fb_par* par = &info->current_par;
+	reg_misc_t* misc = info->reg.misc;
+	reg_dispmode_t* dispmode = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_mode : info->reg.crttv_mode;
+	
+	pixel_start = var->yoffset * par->width_virt + var->xoffset;
+	start_addr = (pixel_start * par->Bpp) / 2;
+	pixel_pan = (par->bpp == 8) ? (u8)(pixel_start & 1) : 0;
+    
+	if (readb(&misc->disp_mode) != 0) {
+		reg_dispcfg_t* dispcfg = (IS_PANEL(info->fix.disp_type)) ?
+			info->reg.lcd_cfg : info->reg.crttv_cfg;
+
+		// wait for the end of the current VNDP
+		e1356_wait_bitclr(&dispcfg->vndp, 0x80, 5000);
+		// now wait for the start of a new VNDP
+		e1356_wait_bitset(&dispcfg->vndp, 0x80, 5000);
+	}
+    
+	writeb((u8)(start_addr & 0xff), &dispmode->start_addr0);
+	writeb((u8)((start_addr>>8) & 0xff), &dispmode->start_addr1);
+	writeb((u8)((start_addr>>16) & 0xff), &dispmode->start_addr2);
+	writeb(pixel_pan, &dispmode->pixel_panning);
+}
+
+
+/*
+ * Invert the hardware cursor image (timerfunc)  
+ */
+static void
+do_flashcursor(unsigned long ptr)
+{
+	u8 curs_ctrl;
+	struct fb_info_e1356* info = (struct fb_info_e1356 *)ptr;
+	reg_inkcurs_t* inkcurs = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_inkcurs : info->reg.crttv_inkcurs;
+
+	spin_lock(&info->cursor.lock);
+	// toggle cursor enable bit
+	curs_ctrl = readb(&inkcurs->ctrl);
+	writeb((curs_ctrl ^ 0x01) & 0x01, &inkcurs->ctrl);
+	info->cursor.timer.expires = jiffies+HZ/2;
+	add_timer(&info->cursor.timer);
+	spin_unlock(&info->cursor.lock);
+}
+
+#ifdef SHADOW_FRAME_BUFFER
+/*
+ * Write BLT the shadow frame buffer to the real fb (timerfunc)  
+ */
+static void
+do_write_shadow_fb(unsigned long ptr)
+{
+	blt_info_t blt;
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)ptr;
+	struct fb_info* fb = &info->fb_info;
+	struct e1356fb_par* par = &info->current_par;
+	u32 stride = par->width_virt * par->Bpp;
+
+	unsigned long j_start = jiffies;
+    
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = par->width;
+	blt.dst_height = par->height;
+	blt.dst_y = fb->var.yoffset;
+	blt.dst_x = fb->var.xoffset;
+	blt.operation = BLT_WRITE_ROP;
+	blt.rop = 0x0c; // ROP: destination = source
+	blt.src = (u16*)(info->shadow.fb + blt.dst_x * par->Bpp +
+			 blt.dst_y * stride);
+
+	doBlt(par, info, &blt);
+    
+	info->shadow.timer.expires = jiffies+HZ/2;
+	add_timer(&info->shadow.timer);
+
+	//DPRINTK("delta jiffies = %ld\n", jiffies - j_start);
+}
+#endif
+
+
+/* ------------------------------------------------------------------------- 
+ *              Hardware independent part, interface to the world
+ * ------------------------------------------------------------------------- */
+
+static void
+e1356_cfbX_clear_margins(struct vc_data* conp, struct display* p,
+			 int bottom_only)
+{
+	blt_info_t blt;
+	unsigned int cw=fontwidth(p);
+	unsigned int ch=fontheight(p);
+	unsigned int rw=p->var.xres % cw;
+	unsigned int bh=p->var.yres % ch;
+	unsigned int rs=p->var.xres - rw;
+	unsigned int bs=p->var.yres - bh;
+
+	//DPRINTK("\n");
+
+	if (!bottom_only && rw) { 
+		blt.dst_x = p->var.xoffset+rs;
+		blt.dst_y = p->var.yoffset;
+		blt.dst_height = p->var.yres;
+		blt.dst_width = rw;
+		blt.attribute = 0;
+		blt.fg_color = 0;
+		blt.operation = BLT_SOLID_FILL;
+		doBlt (&fb_info.current_par, &fb_info, &blt);
+	}
+    
+	if (bh) { 
+		blt.dst_x = p->var.xoffset;
+		blt.dst_y = p->var.yoffset+bs;
+		blt.dst_height = bh;
+		blt.dst_width = rs;
+		blt.attribute = 0;
+		blt.fg_color = 0;
+		blt.operation = BLT_SOLID_FILL;
+		doBlt (&fb_info.current_par, &fb_info, &blt);
+	}
+}
+
+static void
+e1356_cfbX_bmove(struct display* p, 
+		 int sy, 
+		 int sx, 
+		 int dy,
+		 int dx, 
+		 int height, 
+		 int width)
+{
+	blt_info_t blt;
+    
+	//DPRINTK("(%d,%d) to (%d,%d) size (%d,%d)\n", sx,sy,dx,dy,width,height);
+
+	blt.src_x = fontwidth_x8(p)*sx;
+	blt.src_y = fontheight(p)*sy;
+	blt.dst_x = fontwidth_x8(p)*dx;
+	blt.dst_y = fontheight(p)*dy;
+	blt.src_height = blt.dst_height = fontheight(p)*height;
+	blt.src_width = blt.dst_width = fontwidth_x8(p)*width;
+	blt.attribute = 0;
+	blt.rop = 0x0c;
+	/*
+	 * The move BLT routine will actually decide between a pos/neg
+	 * move BLT. This is just so that the BLT dispatcher knows to
+	 * call the move BLT routine.
+	 */
+	blt.operation = BLT_MOVE_POS_ROP;
+
+	doBlt (&fb_info.current_par, &fb_info, &blt);
+}
+
+static void
+e1356_cfb8_putc(struct vc_data* conp,
+		struct display* p,
+		int c, int yy,int xx)
+{   
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+	u16 cs = (u16)c;
+
+	fgx = attr_fgcol(p, c);
+	bgx = attr_bgcol(p, c);
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, &cs, 1);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+
+}
+
+static void
+e1356_cfb16_putc(struct vc_data* conp,
+		 struct display* p,
+		 int c, int yy,int xx)
+{   
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+	u16 cs = (u16)c;
+    
+	fgx = ((u16*)p->dispsw_data)[attr_fgcol(p,c)];
+	bgx = ((u16*)p->dispsw_data)[attr_bgcol(p,c)];
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, &cs, 1);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+}
+
+
+static void
+e1356_cfb8_putcs(struct vc_data* conp,
+		 struct display* p,
+		 const unsigned short *s,int count,int yy,int xx)
+{
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+
+	//DPRINTK("\n");
+
+	fgx=attr_fgcol(p, *s);
+	bgx=attr_bgcol(p, *s);
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = count * fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, s, count);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+}
+
+static void
+e1356_cfb16_putcs(struct vc_data* conp,
+		  struct display* p,
+		  const unsigned short *s,int count,int yy,int xx)
+{
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+
+	//DPRINTK("\n");
+
+	fgx=((u16*)p->dispsw_data)[attr_fgcol(p,*s)];
+	bgx=((u16*)p->dispsw_data)[attr_bgcol(p,*s)];
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = count * fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, s, count);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+}
+
+
+static void
+e1356_cfb8_clear(struct vc_data* conp, 
+		 struct display* p, 
+		 int sy,
+		 int sx, 
+		 int height, 
+		 int width)
+{
+	blt_info_t blt;
+	u32 bg = attr_bgcol_ec(p,conp);
+
+	//DPRINTK("(%d,%d) size (%d,%d)\n", sx,sy,width,height);
+
+	blt.dst_x = fontwidth_x8(p)*sx;
+	blt.dst_y = fontheight(p)*sy;
+	blt.dst_height = fontheight(p)*height;
+	blt.dst_width = fontwidth_x8(p)*width;
+	blt.attribute = 0;
+	blt.fg_color = bg;
+	blt.operation = BLT_SOLID_FILL;
+
+	doBlt (&fb_info.current_par, &fb_info, &blt);
+}
+
+static void
+e1356_cfb16_clear(struct vc_data* conp, 
+		  struct display* p, 
+		  int sy,
+		  int sx, 
+		  int height, 
+		  int width)
+{
+	blt_info_t blt;
+	u32 bg = ((u16*)p->dispsw_data)[attr_bgcol_ec(p,conp)];
+
+	//DPRINTK("(%d,%d) size (%d,%d)\n", sx,sy,width,height);
+
+	blt.dst_x = fontwidth_x8(p)*sx;
+	blt.dst_y = fontheight(p)*sy;
+	blt.dst_height = fontheight(p)*height;
+	blt.dst_width = fontwidth_x8(p)*width;
+	blt.attribute = 0;
+	blt.fg_color = bg;
+	blt.operation = BLT_SOLID_FILL;
+
+	doBlt (&fb_info.current_par, &fb_info, &blt);
+}
+
+
+static void
+e1356_cfbX_revc(struct display *p, int xx, int yy)
+{
+	// not used if h/w cursor
+	//DPRINTK("\n");
+}
+
+static void
+e1356_cfbX_cursor(struct display *p, int mode, int x, int y) 
+{
+	unsigned long flags;
+	struct fb_info_e1356 *info=(struct fb_info_e1356 *)p->fb_info;
+	reg_inkcurs_t* inkcurs = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_inkcurs : info->reg.crttv_inkcurs;
+    
+	//DPRINTK("\n");
+
+	if (mode == CM_ERASE) {
+		if (info->cursor.state != CM_ERASE) {
+			spin_lock_irqsave(&info->cursor.lock,flags);
+			info->cursor.state = CM_ERASE;
+			del_timer(&(info->cursor.timer));
+			writeb(0x00, &inkcurs->ctrl);
+			spin_unlock_irqrestore(&info->cursor.lock,flags);
+		}
+		return;
+	}
+    
+	if ((p->conp->vc_cursor_type & CUR_HWMASK) != info->cursor.type)
+		e1356fb_createcursor(p);
+    
+	x *= fontwidth_x8(p);
+	y *= fontheight(p);
+	x -= p->var.xoffset;
+	y -= p->var.yoffset;
+    
+	spin_lock_irqsave(&info->cursor.lock,flags);
+	if ((x != info->cursor.x) || (y != info->cursor.y) ||
+	    (info->cursor.redraw)) {
+		info->cursor.x = x;
+		info->cursor.y = y;
+		info->cursor.redraw = 0;
+		writeb(0x01, &inkcurs->ctrl);
+		writew(x, &inkcurs->x_pos0);
+		writew(y, &inkcurs->y_pos0);
+		/* fix cursor color - XFree86 forgets to restore it properly */
+		writeb(0x00, &inkcurs->blue0);
+		writeb(0x00, &inkcurs->green0);
+		writeb(0x00, &inkcurs->red0);
+		writeb(0x1f, &inkcurs->blue1);
+		writeb(0x3f, &inkcurs->green1);
+		writeb(0x1f, &inkcurs->red1);
+	}
+
+	info->cursor.state = CM_DRAW;
+	mod_timer(&info->cursor.timer, jiffies+HZ/2);
+	spin_unlock_irqrestore(&info->cursor.lock,flags);
+}
+
+#ifdef FBCON_HAS_CFB8
+static struct display_switch fbcon_e1356_8 = {
+	.setup		= fbcon_cfb8_setup, 
+	.bmove		= e1356_cfbX_bmove, 
+	.clear		= e1356_cfb8_clear, 
+	.putc		= e1356_cfb8_putc,
+	.putcs		= e1356_cfb8_putcs, 
+	.revc		= e1356_cfbX_revc,   
+	.cursor		= e1356_cfbX_cursor, 
+	.clear_margins	= e1356_cfbX_clear_margins,
+	.fontwidthmask	= FONTWIDTHRANGE(6,16)
+};
+#endif
+
+#ifdef FBCON_HAS_CFB16
+static struct display_switch fbcon_e1356_16 = {
+	.setup		= fbcon_cfb16_setup, 
+	.bmove		= e1356_cfbX_bmove, 
+	.clear		= e1356_cfb16_clear, 
+	.putc		= e1356_cfb16_putc,
+	.putcs		= e1356_cfb16_putcs, 
+	.revc		= e1356_cfbX_revc, 
+	.cursor		= e1356_cfbX_cursor, 
+	.clear_margins	= e1356_cfbX_clear_margins,
+	.fontwidthmask	= FONTWIDTHRANGE(6,16)
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static void
+e1356fb_set_par(const struct e1356fb_par* par,
+		struct fb_info_e1356* info)
+{
+	reg_dispcfg_t* dispcfg=NULL;
+	reg_dispmode_t* dispmode=NULL;
+	u8* pclk_cfg=NULL;
+	u8 width, hndp=0, hsync_start=0, hsync_width=0;
+	u8 vndp, vsync_start, vsync_width=0, display_mode;
+	u8 main_display_mode=0;
+	u16 height, addr_offset;
+	int disp_type = info->fix.disp_type;
+
+	DPRINTK("%dx%d-%dbpp @ %d Hz, %d kHz hsync\n",
+		par->width, par->height, par->bpp,
+		par->vsync_freq, (((2*par->hsync_freq)/1000)+1)/2);
+#ifdef E1356FB_VERBOSE_DEBUG
+	dump_par(par);
+#endif
+    
+	info->current_par = *par;
+
+	width = (par->width >> 3) - 1;
+	display_mode = (par->bpp == 8) ? 0x03 : 0x05;
+	addr_offset = (par->width_virt * par->Bpp) / 2;
+	vsync_start = (disp_type == DISP_TYPE_LCD) ? 0 : par->vsync_start - 1;
+	height = par->height - 1;
+	vndp = par->vert_ndp - 1;
+
+	switch (disp_type) {
+	case DISP_TYPE_LCD:
+		dispcfg = info->reg.lcd_cfg;
+		dispmode = info->reg.lcd_mode;
+		pclk_cfg = &info->reg.clk_cfg->lcd_pclk_cfg;
+		hndp = (par->horiz_ndp >> 3) - 1;
+		hsync_start = 0;
+		hsync_width = par->hsync_pol ? 0x00 : 0x80;
+		vsync_width = par->vsync_pol ? 0x00 : 0x80;
+		main_display_mode = 0x01;
+		break;
+	case DISP_TYPE_TFT:
+		dispcfg = info->reg.lcd_cfg;
+		dispmode = info->reg.lcd_mode;
+		pclk_cfg = &info->reg.clk_cfg->lcd_pclk_cfg;
+		hndp = (par->horiz_ndp >> 3) - 1;
+		hsync_start = (par->bpp == 8) ?
+			(par->hsync_start - 4) >> 3 :
+				(par->hsync_start - 6) >> 3;
+		hsync_width =
+			(par->hsync_pol ? 0x80 : 0x00) |
+			((par->hsync_width >> 3) - 1);
+		vsync_width =
+			(par->vsync_pol ? 0x80 : 0x00) |
+			(par->vsync_width - 1);
+		main_display_mode = 0x01;
+		break;
+	case DISP_TYPE_CRT:
+		dispcfg = info->reg.crttv_cfg;
+		dispmode = info->reg.crttv_mode;
+		pclk_cfg = &info->reg.clk_cfg->crttv_pclk_cfg;
+		hndp = (par->horiz_ndp >> 3) - 1;
+		hsync_start = (par->bpp == 8) ?
+			(par->hsync_start - 3) >> 3 :
+				(par->hsync_start - 5) >> 3;
+		hsync_width =
+			(par->hsync_pol ? 0x80 : 0x00) |
+			((par->hsync_width >> 3) - 1);
+		vsync_width =
+			(par->vsync_pol ? 0x80 : 0x00) |
+			(par->vsync_width - 1);
+		main_display_mode = 0x02;
+		break;
+	case DISP_TYPE_NTSC:
+	case DISP_TYPE_PAL:
+		dispcfg = info->reg.crttv_cfg;
+		dispmode = info->reg.crttv_mode;
+		pclk_cfg = &info->reg.clk_cfg->crttv_pclk_cfg;
+		hndp = (disp_type == DISP_TYPE_PAL) ?
+			(par->horiz_ndp - 7) >> 3 :
+				(par->horiz_ndp - 6) >> 3;
+		hsync_start = (par->bpp == 8) ?
+			(par->hsync_start + 7) >> 3 :
+				(par->hsync_start + 5) >> 3;
+		hsync_width = 0;
+		vsync_width = 0;
+		main_display_mode = (info->fix.tv_filt & TV_FILT_FLICKER) ?
+			0x06 : 0x04;
+		break;
+	}
+
+	// Blast the regs!
+	// note: reset panning/scrolling (set start-addr and
+	// pixel pan regs to 0). Panning is handled by pan_display.
+
+	e1356_engine_wait_complete(info->reg.bitblt);
+
+	// disable display while initializing
+	writeb(0, &info->reg.misc->disp_mode);
+
+	writeb(par->ipclk.pixclk_bits, pclk_cfg);
+
+	writeb(width, &dispcfg->hdw);
+	writeb(hndp, &dispcfg->hndp);
+	writeb(hsync_start, &dispcfg->hsync_start);
+	writeb(hsync_width, &dispcfg->hsync_pulse);
+	writew(height, &dispcfg->vdh0);
+	writeb(vndp, &dispcfg->vndp);
+	writeb(vsync_start, &dispcfg->vsync_start);
+	writeb(vsync_width, &dispcfg->vsync_pulse);
+
+	writeb(display_mode, &dispmode->disp_mode);
+	if (info->fix.mmunalign && info->mmaped)
+		writeb(1, &dispmode->start_addr0);
+	else
+		writeb(0, &dispmode->start_addr0);
+	writeb(0, &dispmode->start_addr1);
+	writeb(0, &dispmode->start_addr2);
+	writew(addr_offset, &dispmode->mem_addr_offset0);
+	writeb(0, &dispmode->pixel_panning);
+
+	// reset BitBlt engine
+	e1356fb_engine_init(par, info);
+
+#ifdef E1356FB_VERBOSE_DEBUG
+	dump_display_regs(dispcfg, dispmode);
+#endif
+
+	/* clear out framebuffer memory */
+	fbfill(fb_info.membase_virt, 0, fb_info.fb_size);
+	// finally, enable display!
+	writeb(main_display_mode, &info->reg.misc->disp_mode); 
+}
+
+
+static int
+e1356fb_verify_timing(struct e1356fb_par* par,
+		      const struct fb_info_e1356* info)
+{
+	int disp_type = info->fix.disp_type;
+
+	// timing boundary checks
+	if (par->horiz_ndp > max_hndp[disp_type]) {
+		DPRINTK("horiz_ndp too big: %d\n", par->horiz_ndp);
+		return -EINVAL;
+	}
+	if (par->vert_ndp > max_vndp[disp_type]) {
+		DPRINTK("vert_ndp too big: %d\n", par->vert_ndp);
+		return -EINVAL;
+	}
+
+	if (disp_type != DISP_TYPE_LCD) {
+		if (par->hsync_start >
+		    max_hsync_start[(par->bpp==16)][disp_type]) {
+			DPRINTK("hsync_start too big: %d\n",
+				par->hsync_start);
+			return -EINVAL;
+		}
+		if (par->vsync_start > max_vsync_start[disp_type]) {
+			DPRINTK("vsync_start too big: %d\n",
+				par->vsync_start);
+			return -EINVAL;
+		}
+		if (!IS_TV(disp_type)) {
+			if (par->hsync_width > max_hsync_width[disp_type]) {
+				DPRINTK("hsync_width too big: %d\n",
+					par->hsync_width);
+				return -EINVAL;
+			}
+			if (par->vsync_width > max_vsync_width[disp_type]) {
+				DPRINTK("vsync_width too big: %d\n",
+					par->vsync_width);
+				return -EINVAL;
+			}
+		}
+	}
+
+	if (IS_TV(disp_type)) {
+		int tv_pixclk = (disp_type == DISP_TYPE_NTSC) ?
+			NTSC_PIXCLOCK : PAL_PIXCLOCK;
+		if (info->fix.tv_filt & TV_FILT_FLICKER)
+			tv_pixclk *= 2;
+		
+		if (par->ipclk.pixclk_d != tv_pixclk) {
+			DPRINTK("invalid TV pixel clock %u kHz\n",
+				par->ipclk.pixclk_d);
+			return -EINVAL;
+		}
+	}
+	
+	if (e1356_calc_pixclock(info, &par->ipclk) < 0) {
+		DPRINTK("can't set pixel clock %u kHz\n",
+			par->ipclk.pixclk_d);
+		return -EINVAL;
+	}
+ 
+#ifdef E1356FB_VERBOSE_DEBUG
+	DPRINTK("desired pixclock = %d kHz, actual = %d kHz, error = %d%%\n",
+		par->ipclk.pixclk_d, par->ipclk.pixclk, par->ipclk.error);
+#endif
+    
+	if (disp_type != DISP_TYPE_LCD) {
+		if (par->horiz_ndp < par->hsync_start + par->hsync_width) {
+			DPRINTK("invalid horiz. timing\n");
+			return -EINVAL;
+		}
+		if (par->vert_ndp < par->vsync_start + par->vsync_width) {
+			DPRINTK("invalid vert. timing\n");
+			return -EINVAL;
+		}
+
+		// SED1356 Hardware Functional Spec, section 13.5
+		if (disp_type == DISP_TYPE_NTSC &&
+		    ((par->width + par->horiz_ndp != 910) ||
+		     (par->height + 2*par->vert_ndp+1 != 525))) {
+			DPRINTK("invalid NTSC timing\n");
+			return -EINVAL;
+		} else if (disp_type == DISP_TYPE_PAL &&
+			   ((par->width + par->horiz_ndp != 1135) ||
+			    (par->height + 2*par->vert_ndp+1 != 625))) {
+			DPRINTK("invalid PAL timing\n");
+			return -EINVAL;
+		}
+	}
+    
+	par->hsync_freq = (1000 * par->ipclk.pixclk) /
+		(par->width + par->horiz_ndp);
+	par->vsync_freq = par->hsync_freq / (par->height + par->vert_ndp);
+	
+	if (par->hsync_freq < 30000 || par->hsync_freq > 90000) {
+		DPRINTK("hsync freq too %s: %u Hz\n",
+			par->hsync_freq < 30000 ? "low" : "high",
+			par->hsync_freq);
+		return -EINVAL;
+	}
+	if (par->vsync_freq < 50 || par->vsync_freq > 110) {
+		DPRINTK("vsync freq too %s: %u Hz\n",
+			par->vsync_freq < 50 ? "low" : "high",
+			par->vsync_freq);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+e1356fb_verify_par(struct e1356fb_par* par,
+		   const struct fb_info_e1356* info)
+{
+	int disp_type = info->fix.disp_type;
+    
+	if (par->bpp != 8 && par->bpp != 16) {
+		DPRINTK("depth not supported: %u bpp\n", par->bpp);
+		return -EINVAL;
+	}
+
+	if (par->width > par->width_virt) {
+		DPRINTK("virtual x resolution < physical x resolution not possible\n");
+		return -EINVAL;
+	}
+
+	if (par->height > par->height_virt) {
+		DPRINTK("virtual y resolution < physical y resolution not possible\n");
+		return -EINVAL;
+	}
+
+	if (par->width < 320 || par->width > 1024) {
+		DPRINTK("width not supported: %u\n", par->width);
+		return -EINVAL;
+	}
+
+	if ((disp_type == DISP_TYPE_LCD && (par->width % 16)) ||
+	    (disp_type == DISP_TYPE_TFT && (par->width % 8))) {
+		DPRINTK("invalid width for panel type: %u\n", par->width);
+		return -EINVAL;
+	}
+
+	if (par->height < 200 || par->height > 1024) {
+		DPRINTK("height not supported: %u\n", par->height);
+		return -EINVAL;
+	}
+
+	if (par->width_virt * par->height_virt * par->Bpp >
+	    info->fb_size) {
+		DPRINTK("not enough memory for virtual screen (%ux%ux%u)\n",
+			par->width_virt, par->height_virt, par->bpp);
+		return -EINVAL;
+	}
+
+	return e1356fb_verify_timing(par, info);
+}
+
+
+static int
+e1356fb_var_to_par(const struct fb_var_screeninfo* var,
+		   struct e1356fb_par* par,
+		   const struct fb_info_e1356* info)
+{
+	if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		DPRINTK("interlace not supported\n");
+		return -EINVAL;
+	}
+
+	memset(par, 0, sizeof(struct e1356fb_par));
+
+	par->width       = (var->xres + 15) & ~15; /* could sometimes be 8 */
+	par->width_virt  = var->xres_virtual;
+	par->height      = var->yres;
+	par->height_virt = var->yres_virtual;
+	par->bpp         = var->bits_per_pixel;
+	par->Bpp         = (par->bpp + 7) >> 3;
+
+	par->ipclk.pixclk_d = PICOS2KHZ(var->pixclock);
+
+	par->hsync_start = var->right_margin;
+	par->hsync_width = var->hsync_len;
+
+	par->vsync_start = var->lower_margin;
+	par->vsync_width = var->vsync_len;
+
+	par->horiz_ndp = var->left_margin + var->right_margin + var->hsync_len;
+	par->vert_ndp = var->upper_margin + var->lower_margin + var->vsync_len;
+
+	par->hsync_pol = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? 1 : 0;
+	par->vsync_pol = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? 1 : 0;
+
+	par->cmap_len  = (par->bpp == 8) ? 256 : 16;
+
+	return e1356fb_verify_par(par, info);
+}
+
+static int
+e1356fb_par_to_var(struct fb_var_screeninfo* var,
+		   struct e1356fb_par* par,
+		   const struct fb_info_e1356* info)
+{
+	struct fb_var_screeninfo v;
+	int ret;
+    
+	// First, make sure par is valid.
+	if ((ret = e1356fb_verify_par(par, info)))
+		return ret;
+
+	memset(&v, 0, sizeof(struct fb_var_screeninfo));
+	v.xres_virtual   = par->width_virt;
+	v.yres_virtual   = par->height_virt;
+	v.xres           = par->width;
+	v.yres           = par->height;
+	v.right_margin   = par->hsync_start;
+	v.hsync_len      = par->hsync_width;
+	v.left_margin    = par->horiz_ndp - par->hsync_start - par->hsync_width;
+	v.lower_margin   = par->vsync_start;
+	v.vsync_len      = par->vsync_width;
+	v.upper_margin   = par->vert_ndp - par->vsync_start - par->vsync_width;
+	v.bits_per_pixel = par->bpp;
+
+	switch(par->bpp) {
+	case 8:
+		v.red.offset = v.green.offset = v.blue.offset = 0;
+		v.red.length = v.green.length = v.blue.length = 4;
+		break;
+	case 16:
+		v.red.offset   = 11;
+		v.red.length   = 5;
+		v.green.offset = 5;
+		v.green.length = 6;
+		v.blue.offset  = 0;
+		v.blue.length  = 5;
+		break;
+	}
+
+	v.height = v.width = -1;
+	v.pixclock = KHZ2PICOS(par->ipclk.pixclk);
+
+	if (par->hsync_pol)
+		v.sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (par->vsync_pol)
+		v.sync |= FB_SYNC_VERT_HIGH_ACT;
+
+	*var = v;
+	return 0;
+}
+
+static int
+e1356fb_encode_fix(struct fb_fix_screeninfo*  fix,
+		   const struct e1356fb_par*   par,
+		   const struct fb_info_e1356* info)
+{
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+    
+	strcpy(fix->id, "Epson SED1356");
+	fix->smem_start  = info->fix.membase_phys;
+	fix->smem_len    = info->fb_size;
+	fix->mmio_start  = info->fix.regbase_phys;
+	fix->mmio_len    = info->regbase_size;
+	fix->accel       = FB_ACCEL_EPSON_SED1356;
+	fix->type        = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux    = 0;
+	fix->line_length = par->width_virt * par->Bpp;
+	fix->visual      =
+		(par->bpp == 8) ? FB_VISUAL_PSEUDOCOLOR	: FB_VISUAL_TRUECOLOR;
+    
+	fix->xpanstep    = info->fix.nopan ? 0 : 1;
+	fix->ypanstep    = info->fix.nopan ? 0 : 1;
+	fix->ywrapstep   = 0;
+    
+	return 0;
+}
+
+static int e1356fb_open(struct fb_info *fb, int user)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+        if (user) {
+                info->open++;
+	}
+
+	return 0;
+}
+
+static int e1356fb_release(struct fb_info *fb, int user)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+        if (user && info->open) {
+                info->open--;
+		if (info->open == 0)
+                        info->mmaped = 0;
+	}
+
+	return 0;
+}
+
+static int
+e1356fb_get_fix(struct fb_fix_screeninfo *fix, 
+		int con,
+		struct fb_info *fb)
+{
+	const struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par par;
+
+	//DPRINTK("\n");
+
+	if (con == -1)
+		par = info->current_par;
+	else
+		e1356fb_var_to_par(&fb_display[con].var, &par, info);
+	e1356fb_encode_fix(fix, &par, info);
+	return 0;
+}
+
+static int
+e1356fb_get_var(struct fb_var_screeninfo *var, 
+		int con,
+		struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+
+	//DPRINTK("\n");
+
+	if (con == -1)
+		e1356fb_par_to_var(var, &info->current_par, info);
+	else
+		*var = fb_display[con].var;
+	return 0;
+}
+ 
+static void
+e1356fb_set_dispsw(struct display *disp, 
+		   struct fb_info_e1356 *info,
+		   int bpp, 
+		   int accel)
+{
+	struct e1356fb_fix* fix = &info->fix;
+	//DPRINTK("\n");
+
+	if (disp->dispsw && disp->conp) 
+		fb_con.con_cursor(disp->conp, CM_ERASE);
+	switch (bpp) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		disp->dispsw = fix->noaccel ? &fbcon_cfb8 : &fbcon_e1356_8;
+		if (fix->nohwcursor)
+			fbcon_e1356_8.cursor = NULL;
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		disp->dispsw = fix->noaccel ? &fbcon_cfb16 : &fbcon_e1356_16;
+		disp->dispsw_data = info->fbcon_cmap16;
+		if (fix->nohwcursor)
+			fbcon_e1356_16.cursor = NULL;
+		break;
+#endif
+	default:
+		disp->dispsw = &fbcon_dummy;
+	}
+   
+}
+
+static int
+e1356fb_set_var(struct fb_var_screeninfo *var, 
+		int con,
+		struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par par;
+	struct display *display;
+	int oldxres, oldyres, oldvxres, oldvyres, oldbpp, oldaccel, accel, err;
+	int activate = var->activate;
+	int j,k;
+    
+	DPRINTK("\n");
+	
+	if (con >= 0)
+		display = &fb_display[con];
+	else
+		display = fb->disp;	/* used during initialization */
+   
+	if ((err = e1356fb_var_to_par(var, &par, info))) {
+		struct fb_videomode *dm;
+		/*
+		 * this mode didn't pass the tests. Try the
+		 * corresponding mode from our own modedb.
+		 */
+		DPRINTK("req mode failed, trying SED1356 %dx%d mode\n",
+			var->xres, var->yres);
+		if (e1356fb_get_mode(info, var->xres,
+				     var->yres, NULL, &dm) < 0) {
+			DPRINTK("no SED1356 %dx%d mode found, failed\n",
+				var->xres, var->yres);
+			return err;
+		}
+		fb_videomode_to_var(dm, var);
+		if ((err = e1356fb_var_to_par(var, &par, info))) {
+			DPRINTK("SED1356 %dx%d mode failed\n",
+				var->xres, var->yres);
+			return err;
+		}
+	}
+	
+	if (info->fix.tv_filt & TV_FILT_FLICKER)
+		printk("e1356fb: TV flicker filter enabled\n");
+    
+	e1356fb_par_to_var(var, &par, info);
+   
+	if ((activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {
+		oldxres  = display->var.xres;
+		oldyres  = display->var.yres;
+		oldvxres = display->var.xres_virtual;
+		oldvyres = display->var.yres_virtual;
+		oldbpp   = display->var.bits_per_pixel;
+		oldaccel = display->var.accel_flags;
+		display->var = *var;
+		if (con < 0                         ||
+		    oldxres  != var->xres           || 
+		    oldyres  != var->yres           ||
+		    oldvxres != var->xres_virtual   || 
+		    oldvyres != var->yres_virtual   ||
+		    oldbpp   != var->bits_per_pixel || 
+		    oldaccel != var->accel_flags) {
+			struct fb_fix_screeninfo fix;
+	    
+			e1356fb_encode_fix(&fix, &par, info);
+			display->screen_base    = info->membase_virt;
+			display->visual         = fix.visual;
+			display->type           = fix.type;
+			display->type_aux       = fix.type_aux;
+			display->ypanstep       = fix.ypanstep;
+			display->ywrapstep      = fix.ywrapstep;
+			display->line_length    = fix.line_length;
+			display->next_line      = fix.line_length;
+			display->can_soft_blank = 1;
+			display->inverse        = 0;
+			accel = var->accel_flags & FB_ACCELF_TEXT;
+			e1356fb_set_dispsw(display, info, par.bpp, accel);
+	 
+			if (info->fix.nopan)
+				display->scrollmode = SCROLL_YREDRAW;
+	
+			if (info->fb_info.changevar)
+				(*info->fb_info.changevar)(con);
+		}
+		if (var->bits_per_pixel==8)
+			for(j = 0; j < 16; j++) {
+				k = color_table[j];
+				fb_info.palette[j].red   = default_red[k];
+				fb_info.palette[j].green = default_grn[k];
+				fb_info.palette[j].blue  = default_blu[k];
+			}
+      
+		del_timer(&(info->cursor.timer)); 
+		fb_info.cursor.state=CM_ERASE;
+	
+		if (!info->fb_info.display_fg ||
+		    info->fb_info.display_fg->vc_num == con || con < 0)
+			e1356fb_set_par(&par, info);
+
+		if (!info->fix.nohwcursor) 
+			if (display && display->conp)
+				e1356fb_createcursor( display );
+		info->cursor.redraw = 1;
+
+		if (oldbpp != var->bits_per_pixel || con < 0) {
+			if ((err = fb_alloc_cmap(&display->cmap, 0, 0)))
+				return err;
+			e1356fb_install_cmap(display, &(info->fb_info));
+		}
+	}
+  
+	return 0;
+}
+
+static int
+e1356fb_pan_display(struct fb_var_screeninfo* var, 
+		    int con,
+		    struct fb_info* fb)
+{
+	struct fb_info_e1356* info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par* par = &info->current_par;
+    
+	//DPRINTK("\n");
+
+	if (info->fix.nopan)
+		return -EINVAL;
+
+	if ((int)var->xoffset < 0 ||
+	    var->xoffset + par->width > par->width_virt ||
+	    (int)var->yoffset < 0 ||
+	    var->yoffset + par->height > par->height_virt)
+		return -EINVAL;
+    
+	if (con == currcon)
+		do_pan_var(var, info);
+    
+	fb_display[con].var.xoffset = var->xoffset;
+	fb_display[con].var.yoffset = var->yoffset; 
+
+	return 0;
+}
+
+static int
+e1356fb_get_cmap(struct fb_cmap *cmap, 
+		 int kspc, 
+		 int con,
+		 struct fb_info *fb)
+{
+	struct fb_info_e1356* info = (struct fb_info_e1356*)fb;
+	struct display *d = (con<0) ? fb->disp : fb_display + con;
+   
+	//DPRINTK("\n");
+
+	if (con == currcon) {
+		/* current console? */
+		return fb_get_cmap(cmap, kspc, e1356fb_getcolreg, fb);
+	} else if (d->cmap.len) {
+		/* non default colormap? */
+		fb_copy_cmap(&d->cmap, cmap, kspc ? 0 : 2);
+	} else {
+		fb_copy_cmap(fb_default_cmap(info->current_par.cmap_len),
+			     cmap, kspc ? 0 : 2);
+	}
+	return 0;
+}
+
+static int
+e1356fb_set_cmap(struct fb_cmap *cmap, 
+		 int kspc, 
+		 int con,
+		 struct fb_info *fb)
+{
+	struct display *d = (con<0) ? fb->disp : fb_display + con;
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	int cmap_len = (info->current_par.bpp == 8) ? 256 : 16;
+
+	//DPRINTK("\n");
+
+	if (d->cmap.len!=cmap_len) {
+		int err;
+		if ((err = fb_alloc_cmap(&d->cmap, cmap_len, 0)))
+			return err;
+	}
+    
+	if (con == currcon) {
+		/* current console? */
+		return fb_set_cmap(cmap, kspc, e1356fb_setcolreg, fb);
+	} else {
+		fb_copy_cmap(cmap, &d->cmap, kspc ? 0 : 1);
+	}
+	return 0;
+}
+
+static int
+e1356fb_mmap(struct fb_info *fb,
+	     struct file *file,
+	     struct vm_area_struct *vma)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	unsigned int len;
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
+	u64 start=0, off;
+#else
+	unsigned long start=0, off;
+#endif
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
+		DPRINTK("invalid vma->vm_pgoff\n");
+		return -EINVAL;
+	}
+    
+#ifdef SHADOW_FRAME_BUFFER
+	if (!info->shadow.fb) {
+		int order = 0;
+		while (info->fb_size > (PAGE_SIZE * (1 << order)))
+			order++;
+		info->shadow.fb = (void*)__get_free_pages(GFP_KERNEL, order);
+		if (!info->shadow.fb) {
+			DPRINTK("shadow fb alloc failed\n");
+			return -ENXIO;
+		}
+		memset(info->shadow.fb, 0, info->fb_size);
+		init_timer(&info->shadow.timer);
+		info->shadow.timer.function = do_write_shadow_fb;
+		info->shadow.timer.data = (unsigned long)info;
+	}
+	mod_timer(&info->shadow.timer, jiffies+HZ/2);
+	start = virt_to_phys(info->shadow.fb) & PAGE_MASK;
+#else
+	start = info->fix.membase_phys & PAGE_MASK;
+#endif
+
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fb_size);
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+    
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		DPRINTK("invalid vma\n");
+		return -EINVAL;
+	}
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+#ifdef SHADOW_FRAME_BUFFER
+	vma->vm_flags |= VM_RESERVED;
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_UNCACHED;
+#else
+	pgprot_val(vma->vm_page_prot) |= _CACHE_UNCACHED;
+#endif
+
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO;
+	// FIXME: shouldn't have to do this. If the pages are marked writeable,
+	// the TLB fault handlers should set these.
+	pgprot_val(vma->vm_page_prot) |= (_PAGE_DIRTY | _PAGE_VALID);
+    
+	/*
+	 * The SED1356 has only a 16-bit wide data bus, and some
+	 * embedded platforms, such as the Pb1000, do not automatically
+	 * split 32-bit word accesses to the framebuffer into
+	 * seperate half-word accesses. Hence the upper half-word
+	 * never gets to the framebuffer. The following solution is
+	 * to intentionally return a non-32-bit-aligned VA. As long
+	 * as the user app assumes (and doesn't check) that the returned
+	 * VA is 32-bit aligned, all (assumed aligned) 32-bit accesses
+	 * will actually be unaligned and will get trapped by the MIPS
+	 * unaligned exception handler. This handler will emulate the
+	 * load/store instructions by splitting up the load/store
+	 * into two 16-bit load/stores. (This emulation is currently
+	 * enabled by default, but may be disabled in the future, when
+	 * alignment problems in user-level programs get fixed. When
+	 * that happens, this solution won't work anymore, unless the
+	 * process that mmap's the fb also calls sysmips(MIPS_FIXADE, 1),
+	 * which turns address-error emulation back on).
+	 *
+	 * Furthermore, this solution only seems to work for TinyX
+	 * (Xfbdev). Others, like Qt/E, do snoop the returned VA
+	 * and compensate, or do originally unaligned 32-bit accesses
+	 * which then become aligned, hence breaking this solution.
+	 */
+	if (info->fix.mmunalign)
+		vma->vm_start += 2;
+	
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
+	if (e1356_remap_page_range(vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+#else
+	if (io_remap_page_range(vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+#endif
+
+	info->mmaped = 1;
+	return 0;
+}
+
+
+int __init
+e1356fb_init(void)
+{
+	struct fb_var_screeninfo var;
+	struct e1356fb_fix * epfix = &fb_info.fix;
+	e1356_reg_t* reg;
+	void* regbase;
+	char* name = "SED1356";
+	int periodMCLK, periodBCLK;
+	int dram_timing, rr_div, mclk_src;
+	u8 rev_code, btmp, mclk_cfg;
+
+	if (options) {
+		e1356fb_setup(options, 0);
+	}
+
+	// clear out fb_info
+	memset(&fb_info, 0, sizeof(struct fb_info_e1356));
+
+	// copy boot options
+	fb_info.fix = boot_fix;
+	fb_info.default_par = boot_par;
+
+	fb_info.regbase_size = E1356_REG_SIZE;
+
+	if (!epfix->system) {
+		printk(KERN_ERR "e1356/86fb: no valid system found\n");
+		return -ENODEV;
+	}
+
+	if (epfix->system == SYS_SDU1356) {
+		// it's the SDU1356B0C PCI eval card.
+		struct pci_dev *pdev = NULL;
+		if (!pci_present())   /* No PCI bus in this machine! */
+			return -ENODEV;
+		if (!(pdev = pci_find_device(PCI_VENDOR_ID_EPSON,
+					     PCI_DEVICE_ID_EPSON_SDU1356, pdev)))
+			return -ENODEV;
+		if (pci_enable_device(pdev))
+			return -ENODEV;
+		epfix->regbase_phys = pci_resource_start(pdev, 0);
+		epfix->membase_phys = epfix->regbase_phys + E1356_REG_SIZE;
+	}
+	
+	fb_info.regbase_virt = ioremap_nocache(epfix->regbase_phys,
+					       E1356_REG_SIZE);
+
+	if (!fb_info.regbase_virt) {
+		printk("e1356fb: Can't remap %s register area.\n", name);
+		return -ENXIO;
+	}
+
+	regbase = fb_info.regbase_virt;
+	reg = &fb_info.reg;
+    
+	// Initialize the register pointers
+	reg->basic =         (reg_basic_t*)   (regbase + REG_BASE_BASIC);
+	reg->genio =         (reg_genio_t*)   (regbase + REG_BASE_GENIO);
+	reg->md_cfg =        (reg_mdcfg_t*)   (regbase + REG_BASE_MDCFG);
+	reg->clk_cfg =       (reg_clkcfg_t*)  (regbase + REG_BASE_CLKCFG);
+	reg->mem_cfg =       (reg_memcfg_t*)  (regbase + REG_BASE_MEMCFG);
+	reg->panel_cfg =     (reg_panelcfg_t*)(regbase + REG_BASE_PANELCFG);
+	reg->lcd_cfg =       (reg_dispcfg_t*) (regbase + REG_BASE_LCD_DISPCFG);
+	reg->crttv_cfg =     (reg_dispcfg_t*) (regbase + REG_BASE_CRTTV_DISPCFG);
+	reg->lcd_mode =      (reg_dispmode_t*)(regbase + REG_BASE_LCD_DISPMODE);
+	reg->crttv_mode =    (reg_dispmode_t*)(regbase + REG_BASE_CRTTV_DISPMODE);
+	reg->lcd_inkcurs =   (reg_inkcurs_t*) (regbase + REG_BASE_LCD_INKCURS);
+	reg->crttv_inkcurs = (reg_inkcurs_t*) (regbase + REG_BASE_CRTTV_INKCURS);
+	reg->bitblt =        (reg_bitblt_t*)  (regbase + REG_BASE_BITBLT);
+	reg->lut =           (reg_lut_t*)     (regbase + REG_BASE_LUT);
+	reg->pwr_save =      (reg_pwrsave_t*) (regbase + REG_BASE_PWRSAVE);
+	reg->misc =          (reg_misc_t*)    (regbase + REG_BASE_MISC);
+	reg->mediaplug =     (reg_mediaplug_t*)(regbase + REG_BASE_MEDIAPLUG);
+	reg->bitblt_data =   (u16*)           (regbase + REG_BASE_BITBLT_DATA);
+    
+	// Enable all register access
+	writeb(0, &reg->basic->misc);
+
+	rev_code = readb(&reg->basic->rev_code);
+	if ((rev_code >> 2) == 0x04) {
+		printk("Found EPSON1356 Display Controller\n");
+	}
+	else if ((rev_code >> 2) == 0x07) {
+		printk("Found EPSON13806 Display Controller\n");
+	}
+	else {
+		iounmap(fb_info.regbase_virt);
+		printk("e1356/806fb: %s not found, rev_code=0x%02x.\n",
+		       name, rev_code);
+		return -ENODEV;
+	}
+
+	fb_info.chip_rev = rev_code & 0x03;
+
+	// Determine frame-buffer size
+	switch (readb(&reg->md_cfg->md_cfg_stat0) >> 6) {
+	case 0:
+	case 2:
+		fb_info.fb_size = 0x80000;   /* 512K bytes */
+		break;
+	case 1:
+		if ((rev_code >> 2) == 7) /* 806 */
+			fb_info.fb_size = 0x140000;  /* 1.2M bytes */
+		else
+			fb_info.fb_size = 0x200000;  /* 2M bytes */
+		break;
+	default:
+		fb_info.fb_size = 0x200000;  /* 2M bytes */
+		break;
+	}
+
+	fb_info.membase_virt = ioremap_nocache(epfix->membase_phys,
+					       fb_info.fb_size);
+    
+	if (!fb_info.membase_virt) {
+		printk("e1356fb: Can't remap %s framebuffer.\n", name);
+		iounmap(fb_info.regbase_virt);
+		return -ENXIO;
+	}
+    
+	printk("e1356/806fb: Detected  %dKB framebuffer\n", 
+			(unsigned)fb_info.fb_size/1000);
+
+#ifdef CONFIG_MTRR
+	if (!epfix->nomtrr) {
+		fb_info.mtrr_idx = mtrr_add(epfix->membase_phys, fb_info.fb_size,
+					    MTRR_TYPE_WRCOMB, 1);
+		printk("e1356fb: MTRR's turned on\n");
+	}
+#endif
+    
+	if (!boot_fix.noaccel) {
+		/*
+		  Allocate a page for string BLTs. A 4K page is
+		  enough for a 256 character string at an 8x16 font.
+		*/
+		fb_info.putcs_buffer = (void*)__get_free_pages(GFP_KERNEL, 0);
+		if (fb_info.putcs_buffer == NULL) {
+			printk("e1356fb: Can't allocate putcs buffer\n");
+			goto unmap_ret_enxio;
+		}
+	}
+
+	// Begin SED1356 initialization
+
+	// disable display while initializing
+	writeb(0, &reg->misc->disp_mode);
+	// Set the GPIO1 and 2 to inputs
+	writeb(0, &reg->genio->gpio_cfg);
+	writeb(0, &reg->genio->gpio_ctrl);
+	if (fb_info.chip_rev == 7) /* 806 */
+		writeb(0, &reg->genio->gpio_ctrl2);
+
+	/*
+	 * Program the clocks
+	 */
+
+#ifdef CONFIG_MIPS_AU1000
+	if ((epfix->system == SYS_PB1000) || (epfix->system == SYS_PB1500))
+		epfix->busclk = get_au1000_lcd_clock();
+#endif
+	
+	if (epfix->busclk > 80000) {
+		printk("e1356fb: specified busclk too high\n");
+		goto ret_enxio;
+	}
+
+	epfix->mclk = mclk_cfg = 0;
+	if (epfix->system == SYS_PB1500) {
+		epfix->mclk = epfix->busclk;
+		mclk_cfg = 0x01;
+	}
+	else {
+		// Find the highest allowable MCLK
+		if (epfix->busclk <= MAX_PIXCLOCK && 
+				epfix->busclk > epfix->mclk) {
+			epfix->mclk = epfix->busclk;
+			mclk_cfg = 0x01;
+		}
+		if (epfix->clki <= MAX_PIXCLOCK && epfix->clki > epfix->mclk) {
+			epfix->mclk = epfix->clki;
+			mclk_cfg = 0x00;
+		}
+		if (epfix->busclk/2 <= MAX_PIXCLOCK && 
+				epfix->busclk/2 > epfix->mclk) {
+			epfix->mclk = epfix->busclk/2;
+			mclk_cfg = 0x11;
+		}
+		if (epfix->clki/2 <= MAX_PIXCLOCK && 
+				epfix->clki/2 > epfix->mclk) {
+			epfix->mclk = epfix->clki/2;
+			mclk_cfg = 0x10;
+		}
+	}
+	
+	if (!epfix->mclk) {
+		printk("e1356fb: couldn't find an allowable MCLK!\n");
+		goto ret_enxio;
+	}
+
+	// When changing mclk src, you must first set bit 4 to 1.
+	writeb(readb(&reg->clk_cfg->mem_clk_cfg) | 0x10,
+	       &reg->clk_cfg->mem_clk_cfg);
+	writeb(mclk_cfg, &reg->clk_cfg->mem_clk_cfg);
+
+	printk("e1356fb: clocks (kHz): busclk=%d mclk=%d clki=%d clki2=%d\n",
+	       epfix->busclk, epfix->mclk, epfix->clki, epfix->clki2);
+
+	// Set max pixel clock
+	switch (epfix->disp_type) {
+	case DISP_TYPE_LCD:
+	case DISP_TYPE_TFT:
+	case DISP_TYPE_CRT:
+		fb_info.max_pixclock = epfix->mclk;
+		break;
+	case DISP_TYPE_NTSC:
+	case DISP_TYPE_PAL:
+		fb_info.max_pixclock = (epfix->disp_type == DISP_TYPE_NTSC) ?
+			NTSC_PIXCLOCK : PAL_PIXCLOCK;
+		if (epfix->tv_filt & TV_FILT_FLICKER)
+			fb_info.max_pixclock *= 2;
+		break;
+	default:
+		printk("e1356fb: invalid specified display type\n");
+		goto ret_enxio;
+	}
+
+	periodMCLK = 1000000L / epfix->mclk;   // in nano-seconds
+	periodBCLK = 1000000L / epfix->busclk; // in nano-seconds
+	if (readb(&reg->md_cfg->md_cfg_stat1) & (1<<4))
+		periodBCLK *= 2;
+    
+	if ((epfix->system == SYS_PB1000) || (epfix->system == SYS_PB1500))
+		writeb(0x00, &reg->clk_cfg->cpu2mem_wait_sel);
+	else if (periodMCLK - 4 > periodBCLK)
+		writeb(0x02, &reg->clk_cfg->cpu2mem_wait_sel);
+	else if (2*periodMCLK - 4 > periodBCLK)
+		writeb(0x01, &reg->clk_cfg->cpu2mem_wait_sel);
+	else
+		writeb(0x00, &reg->clk_cfg->cpu2mem_wait_sel);
+
+	// Program memory config
+	if (epfix->mem_type < MEM_TYPE_EDO_2CAS ||
+	    epfix->mem_type > MEM_TYPE_EMBEDDED_SDRAM) {
+		printk("e1356fb: bad memory type specified\n");
+		goto ret_enxio;
+	}
+	writeb((u8)epfix->mem_type, &reg->mem_cfg->mem_cfg);
+
+	// calc closest refresh rate
+	rr_div = 7;
+	mclk_src = (mclk_cfg & 1) ? epfix->busclk : epfix->clki;
+	while ((mclk_src >> (6 + rr_div)) < epfix->mem_refresh)
+		if (--rr_div < 0) {
+			printk("e1356fb: can't set specified refresh rate\n");
+			goto ret_enxio;
+		}
+    
+	DPRINTK("refresh rate = %d kHz\n", (mclk_src >> (6 + rr_div)));
+
+	// add Suspend-Mode Refresh bits
+	if (epfix->mem_smr < MEM_SMR_CBR || epfix->mem_smr > MEM_SMR_NONE) {
+		printk("e1356fb: invalid specified suspend-mode refresh type\n");
+		goto ret_enxio;
+	}
+	writeb(rr_div | (epfix->mem_smr << 6), &reg->mem_cfg->dram_refresh);
+
+	// set DRAM speed
+	switch (epfix->mem_speed) {
+	case 50:
+		dram_timing = epfix->mclk >= 33000 ? 0x0101 : 0x0212;
+		break;
+	case 60:
+		if (epfix->mclk >= 30000)
+			dram_timing = 0x0101;
+		else if (epfix->mclk >= 25000)
+			dram_timing =
+				(epfix->mem_type == MEM_TYPE_EDO_2CAS ||
+				 epfix->mem_type == MEM_TYPE_EDO_2WE) ?
+				0x0212 : 0x0101;
+		else
+			dram_timing = 0x0212;
+		break;
+	case 70:
+		if (epfix->mclk >= 30000)
+			dram_timing = 0x0000;
+		else if (epfix->mclk >= 25000)
+			dram_timing = 0x0101;
+		else
+			dram_timing =
+				(epfix->mem_type == MEM_TYPE_EDO_2CAS ||
+				 epfix->mem_type == MEM_TYPE_EDO_2WE) ?
+				0x0212 : 0x0211;
+		break;
+	case 80:
+		if (epfix->mclk >= 25000)
+			dram_timing = 0x0100;
+		else
+			dram_timing = 0x0101;
+		break;
+	default:
+		printk("e1356fb: invalid specified memory speed\n");
+		goto ret_enxio;
+	}
+
+	writew(dram_timing, &reg->mem_cfg->dram_timings_ctrl0);
+    
+	currcon = -1;
+	if (!epfix->nohwcursor)
+		e1356fb_hwcursor_init(&fb_info);
+    
+	init_timer(&fb_info.cursor.timer);
+	fb_info.cursor.timer.function = do_flashcursor; 
+	fb_info.cursor.timer.data = (unsigned long)(&fb_info);
+	fb_info.cursor.state = CM_ERASE;
+	spin_lock_init(&fb_info.cursor.lock);
+    
+	strcpy(fb_info.fb_info.modename, "Epson "); 
+	strcat(fb_info.fb_info.modename, name);
+	fb_info.fb_info.changevar  = NULL;
+	fb_info.fb_info.node       = -1;
+
+	fb_info.fb_info.fbops      = &e1356fb_ops;
+	fb_info.fb_info.disp       = &fb_info.disp;
+	strcpy(fb_info.fb_info.fontname, epfix->fontname);
+	fb_info.fb_info.switch_con = &e1356fb_switch_con;
+	fb_info.fb_info.updatevar  = &e1356fb_updatevar;
+	fb_info.fb_info.blank      = &e1356fb_blank;
+	fb_info.fb_info.flags      = FBINFO_FLAG_DEFAULT;
+    
+	// Set-up display
+	// clear out unused stuff
+	writeb(0, &reg->panel_cfg->mod_rate);
+	writeb(0x01, &reg->lcd_mode->lcd_misc);
+	writeb(0, &reg->lcd_mode->fifo_high_thresh);
+	writeb(0, &reg->lcd_mode->fifo_low_thresh);
+	writeb(0, &reg->crttv_mode->fifo_high_thresh);
+	writeb(0, &reg->crttv_mode->fifo_low_thresh);
+    
+	switch (epfix->disp_type) {
+	case DISP_TYPE_LCD:
+		switch (epfix->panel_width) {
+		case 4: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x04); break;
+		case 8: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x14); break;
+		case 16: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x24); break;
+		default:
+			printk("e1356fb: invalid specified LCD panel data width\n");
+			goto ret_enxio;
+		}
+		writeb(btmp, &reg->panel_cfg->panel_type);
+		break;
+	case DISP_TYPE_TFT:
+		switch (epfix->panel_width) {
+		case 9: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x05); break;
+		case 12: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x15); break;
+		case 18: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x25); break;
+		default:
+			printk("e1356fb: invalid specified TFT panel data width\n");
+			goto ret_enxio;
+		}
+		writeb(btmp, &reg->panel_cfg->panel_type);
+		break;
+	case DISP_TYPE_CRT:
+		writeb(0x00, &reg->crttv_cfg->tv_output_ctrl);
+		break;
+	case DISP_TYPE_NTSC:
+	case DISP_TYPE_PAL:
+		if (epfix->tv_fmt < TV_FMT_COMPOSITE ||
+		    epfix->tv_fmt > TV_FMT_S_VIDEO) {
+			printk("e1356fb: invalid specified TV output format\n");
+			goto ret_enxio;
+		}
+		btmp = epfix->disp_type == DISP_TYPE_PAL ? 0x01 : 0x00;
+		btmp |= (epfix->tv_fmt == TV_FMT_S_VIDEO ? 0x02 : 0x00);
+		btmp |= ((epfix->tv_filt & TV_FILT_LUM) ? 0x10 : 0x00);
+		btmp |= ((epfix->tv_filt & TV_FILT_CHROM) ? 0x20 : 0x00);
+		writeb(btmp, &reg->crttv_cfg->tv_output_ctrl);
+		break;
+	}
+
+	memset(&var, 0, sizeof(var));
+	/*
+	 * If mode_option wasn't given at boot, assume all the boot
+	 * option timing parameters were specified individually, in
+	 * which case we convert par_to_var instead of calling
+	 * fb_find_mode.
+	 */
+	if (epfix->mode_option) {
+		struct fb_videomode* modedb, *dm;
+		int dbsize = e1356fb_get_mode(&fb_info, 640, 480, &modedb, &dm);
+
+		// first try the generic modedb
+		if (!fb_find_mode(&var, &fb_info.fb_info, epfix->mode_option,
+				  NULL, 0, NULL, boot_par.bpp)) {
+			printk("e1356fb: mode %s failed, trying e1356 modedb\n",
+			       epfix->mode_option);
+			// didn't work in generic modedb, try ours
+			if (!fb_find_mode(&var, &fb_info.fb_info,
+					  epfix->mode_option,
+					  modedb, dbsize, dm, boot_par.bpp)) {
+				printk("e1356fb: mode %s failed e1356 modedb too, sorry\n",
+				       epfix->mode_option);
+				
+				goto ret_enxio;
+			}
+		}
+
+		var.xres_virtual = boot_par.width_virt ?
+			boot_par.width_virt : boot_par.width;
+		var.yres_virtual = boot_par.height_virt ?
+			boot_par.height_virt : boot_par.height;
+	} else {
+		if (e1356fb_par_to_var(&var, &fb_info.default_par, &fb_info)) {
+			printk("e1356fb: boot option mode failed\n");
+			goto ret_enxio;
+		}
+	}
+    
+	if (boot_fix.noaccel)
+		var.accel_flags &= ~FB_ACCELF_TEXT;
+	else
+		var.accel_flags |= FB_ACCELF_TEXT;
+    
+	if (e1356fb_var_to_par(&var, &fb_info.default_par, &fb_info)) {
+		/*
+		 * Can't use the mode from the mode db or the default
+		 * mode or the boot options - give up
+		 */
+		printk("e1356fb: mode failed var_to_par\n");
+		goto ret_enxio;
+	}
+    
+	fb_info.disp.screen_base    = fb_info.membase_virt;
+	fb_info.disp.var            = var; // struct copy
+    
+	// here's where the screen is actually initialized and enabled
+	if (e1356fb_set_var(&var, -1, &fb_info.fb_info)) {
+		printk("e1356fb: can't set video mode\n");
+		goto ret_enxio;
+	}
+    
+	writeb(0, &reg->pwr_save->cfg);     // disable power-save mode
+	writeb(0, &reg->misc->cpu2mem_watchdog); // disable watchdog timer
+
+#ifdef E1356FB_VERBOSE_DEBUG
+	dump_fb(fb_info.membase_virt + 0x100000, 512);
+#endif
+
+	if (register_framebuffer(&fb_info.fb_info) < 0) {
+		writeb(0, &reg->misc->disp_mode); 
+		printk("e1356fb: can't register framebuffer\n");
+		goto ret_enxio;
+	}
+    
+	printk("fb%d: %s frame buffer device\n", 
+	       GET_FB_IDX(fb_info.fb_info.node),
+	       fb_info.fb_info.modename);
+    
+    
+	return 0;
+
+ ret_enxio:
+	free_pages((unsigned long)fb_info.putcs_buffer, 0);
+ unmap_ret_enxio:
+	iounmap(fb_info.regbase_virt);
+	iounmap(fb_info.membase_virt);
+	return -ENXIO;
+}
+
+/**
+ *	e1356fb_exit - Driver cleanup
+ *
+ *	Releases all resources allocated during the
+ *	course of the driver's lifetime.
+ *
+ *	FIXME - do results of fb_alloc_cmap need disposal?
+ */
+static void __exit
+e1356fb_exit (void)
+{
+	unregister_framebuffer(&fb_info.fb_info);
+	del_timer_sync(&fb_info.cursor.timer);
+
+#ifdef CONFIG_MTRR
+	if (!fb_info.fix.nomtrr) {
+		mtrr_del(fb_info.mtrr_idx, fb_info.fix.membase_phys,
+			 fb_info.fb_size);
+		printk("fb: MTRR's  turned off\n");
+	}
+#endif
+
+	free_pages((unsigned long)fb_info.putcs_buffer, 0);
+	iounmap(fb_info.regbase_virt);
+	iounmap(fb_info.membase_virt);
+}
+
+MODULE_AUTHOR("Steve Longerbeam <stevel@mvista.com>");
+MODULE_DESCRIPTION("SED1356 framebuffer device driver");
+
+#ifdef MODULE
+module_init(e1356fb_init);
+#endif
+module_exit(e1356fb_exit);
+
+
+void
+e1356fb_setup(char *options, int *ints)
+{
+	char* this_opt;
+    
+	memset(&boot_fix, 0, sizeof(struct e1356fb_fix));
+	memset(&boot_par, 0, sizeof(struct e1356fb_par));
+	boot_fix.system = -1;
+    
+	if (!options || !*options)
+		return;
+    
+	for(this_opt=strtok(options, ","); this_opt;
+	    this_opt=strtok(NULL, ",")) {
+		if (!strncmp(this_opt, "noaccel", 7)) {
+			boot_fix.noaccel = 1;
+		} else if (!strncmp(this_opt, "nopan", 5)) {
+			boot_fix.nopan = 1;
+		} else if (!strncmp(this_opt, "nohwcursor", 10)) {
+			boot_fix.nohwcursor = 1;
+		} else if (!strncmp(this_opt, "mmunalign:", 10)) {
+			boot_fix.mmunalign = simple_strtoul(this_opt+10,
+							    NULL, 0);
+#ifdef CONFIG_MTRR
+		} else if (!strncmp(this_opt, "nomtrr", 6)) {
+			boot_fix.nomtrr = 1;
+#endif
+		} else if (!strncmp(this_opt, "font:", 5)) {
+			strncpy(boot_fix.fontname, this_opt+5,
+				sizeof(boot_fix.fontname)-1);
+		} else if (!strncmp(this_opt, "regbase:", 8)) {
+			boot_fix.regbase_phys = simple_strtoul(this_opt+8,
+							       NULL, 0);
+		} else if (!strncmp(this_opt, "membase:", 8)) {
+			boot_fix.membase_phys = simple_strtoul(this_opt+8,
+							       NULL, 0);
+		} else if (!strncmp(this_opt, "memsp:", 6)) {
+			boot_fix.mem_speed = simple_strtoul(this_opt+6,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "memtyp:", 7)) {
+			boot_fix.mem_type = simple_strtoul(this_opt+7,
+							   NULL, 0);
+		} else if (!strncmp(this_opt, "memref:", 7)) {
+			boot_fix.mem_refresh = simple_strtoul(this_opt+7,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "memsmr:", 7)) {
+			boot_fix.mem_smr = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "busclk:", 7)) {
+			boot_fix.busclk = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "clki:", 5)) {
+			boot_fix.clki = simple_strtoul(this_opt+5, NULL, 0);
+		} else if (!strncmp(this_opt, "clki2:", 6)) {
+			boot_fix.clki2 = simple_strtoul(this_opt+6, NULL, 0);
+		} else if (!strncmp(this_opt, "display:", 8)) {
+			if (!strncmp(this_opt+8, "lcd", 3))
+				boot_fix.disp_type = DISP_TYPE_LCD;
+			else if (!strncmp(this_opt+8, "tft", 3))
+				boot_fix.disp_type = DISP_TYPE_TFT;
+			else if (!strncmp(this_opt+8, "crt", 3))
+				boot_fix.disp_type = DISP_TYPE_CRT;
+			else if (!strncmp(this_opt+8, "pal", 3))
+				boot_fix.disp_type = DISP_TYPE_PAL;
+			else if (!strncmp(this_opt+8, "ntsc", 4))
+				boot_fix.disp_type = DISP_TYPE_NTSC;
+		} else if (!strncmp(this_opt, "width:", 6)) {
+			boot_par.width = simple_strtoul(this_opt+6, NULL, 0);
+		} else if (!strncmp(this_opt, "height:", 7)) {
+			boot_par.height = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "bpp:", 4)) {
+			boot_par.bpp = simple_strtoul(this_opt+4, NULL, 0);
+			boot_par.cmap_len = (boot_par.bpp == 8) ? 256 : 16;
+		} else if (!strncmp(this_opt, "elpanel:", 8)) {
+			boot_fix.panel_el = simple_strtoul(this_opt+8,
+							   NULL, 0);
+		} else if (!strncmp(this_opt, "pdataw:", 7)) {
+			boot_fix.panel_width = simple_strtoul(this_opt+7,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "hndp:", 5)) {
+			boot_par.horiz_ndp = simple_strtoul(this_opt+5,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "vndp:", 5)) {
+			boot_par.vert_ndp = simple_strtoul(this_opt+5,
+							   NULL, 0);
+		} else if (!strncmp(this_opt, "hspol:", 6)) {
+			boot_par.hsync_pol = simple_strtoul(this_opt+6,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "vspol:", 6)) {
+			boot_par.vsync_pol = simple_strtoul(this_opt+6,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "hsstart:", 8)) {
+			boot_par.hsync_start = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "hswidth:", 8)) {
+			boot_par.hsync_width = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "vsstart:", 8)) {
+			boot_par.vsync_start = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "vswidth:", 8)) {
+			boot_par.vsync_width = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "tvfilt:", 7)) {
+			boot_fix.tv_filt = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "tvfmt:", 6)) {
+			boot_fix.tv_fmt = simple_strtoul(this_opt+6, NULL, 0);
+		} else if (!strncmp(this_opt, "system:", 7)) {
+			if (!strncmp(this_opt+7, "pb1000", 10)) {
+				boot_fix = systems[SYS_PB1000].fix;
+				boot_par = systems[SYS_PB1000].par;
+			} else if (!strncmp(this_opt+7, "pb1500", 7)) {
+				boot_fix = systems[SYS_PB1500].fix;
+				boot_par = systems[SYS_PB1500].par;
+			} else if (!strncmp(this_opt+7, "sdu1356", 7)) {
+				boot_fix = systems[SYS_SDU1356].fix;
+				boot_par = systems[SYS_SDU1356].par;
+			} else if (!strncmp(this_opt+7, "clio1050", 7)) {
+				boot_fix = systems[SYS_CLIO1050].fix;
+				boot_par = systems[SYS_CLIO1050].par;
+			}
+		} else {
+			boot_fix.mode_option = this_opt;
+		}
+	} 
+}
+
+
+/*
+ * FIXME: switching consoles could be dangerous. What if switching
+ * from a panel to a CRT/TV, or vice versa? More needs to be
+ * done here.
+ */
+static int
+e1356fb_switch_con(int con, struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par par;
+	int old_con = currcon;
+	int set_par = 1;
+
+	//DPRINTK("\n");
+
+	/* Do we have to save the colormap? */
+	if (currcon>=0)
+		if (fb_display[currcon].cmap.len)
+			fb_get_cmap(&fb_display[currcon].cmap, 1,
+				    e1356fb_getcolreg, fb);
+   
+	currcon = con;
+	fb_display[currcon].var.activate = FB_ACTIVATE_NOW; 
+	e1356fb_var_to_par(&fb_display[con].var, &par, info);
+	if (old_con>=0 && vt_cons[old_con]->vc_mode!=KD_GRAPHICS) {
+		/* check if we have to change video registers */
+		struct e1356fb_par old_par;
+		e1356fb_var_to_par(&fb_display[old_con].var, &old_par, info);
+		if (!memcmp(&par,&old_par,sizeof(par)))
+			set_par = 0;	/* avoid flicker */
+	}
+	if (set_par)
+		e1356fb_set_par(&par, info);
+    
+	if (fb_display[con].dispsw && fb_display[con].conp)
+		fb_con.con_cursor(fb_display[con].conp, CM_ERASE);
+   
+	del_timer(&(info->cursor.timer));
+	fb_info.cursor.state=CM_ERASE; 
+   
+	if (!info->fix.nohwcursor) 
+		if (fb_display[con].conp)
+			e1356fb_createcursor( &fb_display[con] );
+   
+	info->cursor.redraw=1;
+   
+	e1356fb_set_dispsw(&fb_display[con], 
+			   info, 
+			   par.bpp,
+			   fb_display[con].var.accel_flags & FB_ACCELF_TEXT);
+   
+	e1356fb_install_cmap(&fb_display[con], fb);
+	e1356fb_updatevar(con, fb);
+   
+	return 1;
+}
+
+/* 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */
+static void
+e1356fb_blank(int blank, struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	reg_dispmode_t* dispmode = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_mode : info->reg.crttv_mode;
+	reg_pwrsave_t* pwrsave = info->reg.pwr_save;
+
+	//DPRINTK("\n");
+
+	switch (blank) {
+	case 0:
+		// Get out of power save mode
+		writeb(0x00, &pwrsave->cfg);
+		writeb(readb(&dispmode->disp_mode) & ~0x80,
+		       &dispmode->disp_mode);
+		break;
+	case 1:
+		// Get out of power save mode
+		writeb(0x00, &pwrsave->cfg);
+		writeb(readb(&dispmode->disp_mode) | 0x80,
+		       &dispmode->disp_mode);
+		break;
+		// No support for turning off horiz or vert sync, so just treat
+		// it as a power off.
+	case 2:
+	case 3:
+	case 4:
+		writeb(0x01, &pwrsave->cfg);
+		break;
+	}
+}
+
+
+static int
+e1356fb_updatevar(int con, struct fb_info* fb)
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)fb;
+
+	//DPRINTK("\n");
+
+	if ((con==currcon) && (!i->fix.nopan)) 
+		do_pan_var(&fb_display[con].var,i);
+	return 0;
+}
+
+static int
+e1356fb_getcolreg(unsigned        regno, 
+		  unsigned*       red, 
+		  unsigned*       green,
+		  unsigned*       blue, 
+		  unsigned*       transp,
+		  struct fb_info* fb)
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)fb;
+
+	if (regno > i->current_par.cmap_len)
+		return 1;
+   
+	*red    = i->palette[regno].red; 
+	*green  = i->palette[regno].green; 
+	*blue   = i->palette[regno].blue; 
+	*transp = 0;
+   
+	return 0;
+}
+
+static int
+e1356fb_setcolreg(unsigned        regno, 
+		  unsigned        red, 
+		  unsigned        green,
+		  unsigned        blue, 
+		  unsigned        transp,
+		  struct fb_info* info)
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)info;
+
+	if (regno > 255)
+		return 1;
+
+	i->palette[regno].red    = red;
+	i->palette[regno].green  = green;
+	i->palette[regno].blue   = blue;
+   
+	switch(i->current_par.bpp) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		do_setpalentry(i->reg.lut, regno,
+			       (u8)(red>>8), (u8)(green>>8), (u8)(blue>>8));
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		i->fbcon_cmap16[regno] = (regno << 10) | (regno << 5) | regno;
+		break;
+#endif
+	default:
+		DPRINTK("bad depth %u\n", i->current_par.bpp);
+		break;
+	}
+	return 0;
+}
+
+static void
+e1356fb_install_cmap(struct display *d, struct fb_info *info) 
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)info;
+
+	//DPRINTK("\n");
+
+	if (d->cmap.len) {
+		fb_set_cmap(&(d->cmap), 1, e1356fb_setcolreg, info);
+	} else {
+		fb_set_cmap(fb_default_cmap(i->current_par.cmap_len), 1,
+			    e1356fb_setcolreg, info);
+	}
+}
+
+static void
+e1356fb_createcursorshape(struct display* p) 
+{
+	int h,u;
+   
+	h = fontheight(p);
+
+	fb_info.cursor.type = p->conp->vc_cursor_type & CUR_HWMASK;
+
+	switch (fb_info.cursor.type) {
+	case CUR_NONE: 
+		u = h; 
+		break;
+	case CUR_UNDERLINE: 
+		u = h - 2; 
+		break;
+	case CUR_LOWER_THIRD: 
+		u = (h * 2) / 3; 
+		break;
+	case CUR_LOWER_HALF: 
+		u = h / 2; 
+		break;
+	case CUR_TWO_THIRDS: 
+		u = h / 3; 
+		break;
+	case CUR_BLOCK:
+	default:
+		u = 0;
+		break;
+	}
+    
+	fb_info.cursor.w = fontwidth_x8(p);
+	fb_info.cursor.u = u;
+	fb_info.cursor.h = h;
+}
+   
+static void
+e1356fb_createcursor(struct display *p)
+{
+	void* memcursor;
+	int y, w, h, u;
+    
+	e1356fb_createcursorshape(p);
+
+	h = fb_info.cursor.h;
+	w = fb_info.cursor.w;
+	u = fb_info.cursor.u;
+	memcursor = fb_info.membase_virt + fb_info.fb_size;
+
+	// write cursor to display memory
+	for (y=0; y<64; y++) {
+		if (y >= h || y < u) {
+			fbfill((u16*)memcursor, 0xaa, 16); // b/g
+		} else {
+			fbfill((u16*)memcursor, 0xff, w/4); // inverted b/g
+			fbfill((u16*)memcursor + w/4, 0xaa, (64 - w)/4); // b/g
+		}
+		memcursor += 16;
+	}
+}
+   
+static void
+e1356fb_hwcursor_init(struct fb_info_e1356* info)
+{
+	reg_inkcurs_t* inkcurs = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_inkcurs : info->reg.crttv_inkcurs;
+
+	fb_info.fb_size -= 1024;
+	// program cursor base address
+	writeb(0x00, &inkcurs->start_addr);
+	printk("e1356fb: reserving 1024 bytes for the hwcursor at %p\n",
+	       fb_info.membase_virt + fb_info.fb_size);
+}
+
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
+
+/*
+ * Return indicates whether a page was freed so caller can adjust rss
+ */
+static inline void forget_pte(pte_t page)
+{
+	if (!pte_none(page)) {
+		printk("forget_pte: old mapping existed!\n");
+		BUG();
+	}
+}
+
+/*
+ * maps a range of physical memory into the requested pages. the old
+ * mappings are removed. any references to nonexistent pages results
+ * in null mappings (currently treated as "copy-on-access")
+ */
+static inline void e1356_remap_pte_range(pte_t * pte, unsigned long address, unsigned long size,
+	phys_t phys_addr, pgprot_t prot)
+{
+	unsigned long end;
+
+	address &= ~PMD_MASK;
+	end = address + size;
+	if (end > PMD_SIZE)
+		end = PMD_SIZE;
+	do {
+		struct page *page;
+		pte_t oldpage;
+		oldpage = ptep_get_and_clear(pte);
+
+		page = virt_to_page(__va(phys_addr));
+		if ((!VALID_PAGE(page)) || PageReserved(page))
+ 			set_pte(pte, mk_pte_phys(phys_addr, prot));
+		forget_pte(oldpage);
+		address += PAGE_SIZE;
+		phys_addr += PAGE_SIZE;
+		pte++;
+	} while (address && (address < end));
+}
+
+static inline int e1356_remap_pmd_range(struct mm_struct *mm, pmd_t * pmd, unsigned long address, unsigned long size,
+	phys_t phys_addr, pgprot_t prot)
+{
+	unsigned long end;
+
+	address &= ~PGDIR_MASK;
+	end = address + size;
+	if (end > PGDIR_SIZE)
+		end = PGDIR_SIZE;
+	phys_addr -= address;
+	do {
+		pte_t * pte = pte_alloc(mm, pmd, address);
+		if (!pte)
+			return -ENOMEM;
+		e1356_remap_pte_range(pte, address, end - address, address + phys_addr, prot);
+		address = (address + PMD_SIZE) & PMD_MASK;
+		pmd++;
+	} while (address && (address < end));
+	return 0;
+}
+
+/*  Note: this is only safe if the mm semaphore is held when called. */
+static int e1356_remap_page_range(unsigned long from, phys_t phys_addr, unsigned long size, pgprot_t prot)
+{
+	int error = 0;
+	pgd_t * dir;
+	phys_t beg = from;
+	phys_t end = from + size;
+	struct mm_struct *mm = current->mm;
+
+	phys_addr -= from;
+	dir = pgd_offset(mm, from);
+	flush_cache_range(mm, beg, end);
+	if (from >= end)
+		BUG();
+
+	spin_lock(&mm->page_table_lock);
+	do {
+		pmd_t *pmd = pmd_alloc(mm, dir, from);
+		error = -ENOMEM;
+		if (!pmd)
+			break;
+		error = e1356_remap_pmd_range(mm, pmd, from, end - from, phys_addr + from, prot);
+		if (error)
+			break;
+		from = (from + PGDIR_SIZE) & PGDIR_MASK;
+		dir++;
+	} while (from && (from < end));
+	spin_unlock(&mm->page_table_lock);
+	flush_tlb_range(mm, beg, end);
+	return error;
+}
+#endif
diff -Naur linux-2.6.14/drivers/video/epson1356fb.h linux-mips-2.6.14.orig/drivers/video/epson1356fb.h
--- linux-2.6.14/drivers/video/epson1356fb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/video/epson1356fb.h	2005-11-17 11:43:49.000000000 -0800
@@ -0,0 +1,646 @@
+/*
+ *      epson1356fb.h  --  Epson SED1356 Framebuffer Driver
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef E1356FB_DEBUG
+#define DPRINTK(a,b...) printk(KERN_DEBUG "e1356fb: %s: " a, __FUNCTION__ , ## b)
+#else
+#define DPRINTK(a,b...)
+#endif 
+
+#define E1356_REG_SIZE  0x200000
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+#define MAX_PIXCLOCK  40000 // KHz
+#define NTSC_PIXCLOCK 14318 // KHz
+#define PAL_PIXCLOCK  17734 // KHz
+
+/*
+ * Maximum percent errors between desired pixel clock and
+ * supported pixel clock. Lower-than and higher-than desired
+ * clock percent errors.
+ */
+#define MAX_PCLK_ERROR_LOWER  10
+#define MAX_PCLK_ERROR_HIGHER -1
+
+#define fontwidth_x8(p) (((fontwidth(p) + 7) >> 3) << 3)
+
+/*
+ * Register Structures
+ */
+
+// Basic
+#define REG_BASE_BASIC     0x00
+typedef struct {
+	u8 rev_code;           // 00
+	u8 misc;               // 01
+} reg_basic_t;
+
+// General IO Pins
+#define REG_BASE_GENIO     0x04
+typedef struct {
+	u8 gpio_cfg;           // 04
+	u8 gpio_cfg2;          // 05 SED13806
+	u8 spacer[2];          // 06
+	u8 gpio_ctrl;          // 08
+	u8 gpio_ctrl2;         // 09 SED13806
+} reg_genio_t;
+
+// MD Config Readback
+#define REG_BASE_MDCFG     0x0c
+typedef struct {
+	u8 md_cfg_stat0;       // 0C
+	u8 md_cfg_stat1;       // 0D
+} reg_mdcfg_t;
+
+// Clock Config
+#define REG_BASE_CLKCFG    0x10
+typedef struct {
+	u8 mem_clk_cfg;        // 10
+	u8 spacer1[3];         // 11
+	u8 lcd_pclk_cfg;       // 14
+	u8 spacer2[3];         // 15
+	u8 crttv_pclk_cfg;     // 18
+	u8 spacer3[3];         // 19
+	u8 mpclk_cfg;          // 1C
+	u8 spacer4;            // 1D
+	u8 cpu2mem_wait_sel;   // 1E
+} reg_clkcfg_t;
+
+// Memory Config
+#define REG_BASE_MEMCFG    0x20
+typedef struct {
+	u8 mem_cfg;            // 20
+	u8 dram_refresh;       // 21
+	u8 spacer[8];          // 22
+	u8 dram_timings_ctrl0; // 2A
+	u8 dram_timings_ctrl1; // 2B
+} reg_memcfg_t;
+
+// Panel Config
+#define REG_BASE_PANELCFG  0x30
+typedef struct {
+	u8 panel_type;         // 30
+	u8 mod_rate;           // 31
+} reg_panelcfg_t;
+
+// LCD and CRTTV Display Config
+#define REG_BASE_LCD_DISPCFG   0x32
+#define REG_BASE_CRTTV_DISPCFG 0x50
+typedef struct {
+	u8 hdw;                // 32 or 50
+	u8 spacer1;            // 33 or 51
+	u8 hndp;               // 34 or 52
+	u8 hsync_start;        // 35 or 53
+	u8 hsync_pulse;        // 36 or 54
+	u8 spacer2;            // 37 or 55
+	u8 vdh0;               // 38 or 56
+	u8 vdh1;               // 39 or 57
+	u8 vndp;               // 3A or 58
+	u8 vsync_start;        // 3B or 59
+	u8 vsync_pulse;        // 3C or 5A
+	u8 tv_output_ctrl;     // 5B (TV only)
+} reg_dispcfg_t;
+
+// LCD and CRTTV Display Mode
+#define REG_BASE_LCD_DISPMODE   0x40
+#define REG_BASE_CRTTV_DISPMODE 0x60
+typedef struct {
+	u8 disp_mode;          // 40 or 60
+	u8 lcd_misc;           // 41 (LCD only)
+	u8 start_addr0;        // 42 or 62
+	u8 start_addr1;        // 43 or 63
+	u8 start_addr2;        // 44 or 64
+	u8 spacer1;            // 45 or 65
+	u8 mem_addr_offset0;   // 46 or 66
+	u8 mem_addr_offset1;   // 47 or 67
+	u8 pixel_panning;      // 48 or 68
+	u8 spacer2;            // 49 or 69
+	u8 fifo_high_thresh;   // 4A or 6A
+	u8 fifo_low_thresh;    // 4B or 6B
+} reg_dispmode_t;
+
+// LCD and CRTTV Ink/Cursor
+#define REG_BASE_LCD_INKCURS   0x70
+#define REG_BASE_CRTTV_INKCURS 0x80
+typedef struct {
+	u8 ctrl;               // 70 or 80
+	u8 start_addr;         // 71 or 81
+	u8 x_pos0;             // 72 or 82
+	u8 x_pos1;             // 73 or 83
+	u8 y_pos0;             // 74 or 84
+	u8 y_pos1;             // 75 or 85
+	u8 blue0;              // 76 or 86
+	u8 green0;             // 77 or 87
+	u8 red0;               // 78 or 88
+	u8 spacer1;            // 79 or 89
+	u8 blue1;              // 7A or 8A
+	u8 green1;             // 7B or 8B
+	u8 red1;               // 7C or 8C
+	u8 spacer2;            // 7D or 8D
+	u8 fifo;               // 7E or 8E
+} reg_inkcurs_t;
+
+// BitBlt Config
+#define REG_BASE_BITBLT        0x100
+typedef struct {
+	u8 ctrl0;              // 100
+	u8 ctrl1;              // 101
+	u8 rop_code;           // 102
+	u8 operation;          // 103
+	u8 src_start_addr0;    // 104
+	u8 src_start_addr1;    // 105
+	u8 src_start_addr2;    // 106
+	u8 spacer1;            // 107
+	u8 dest_start_addr0;   // 108
+	u8 dest_start_addr1;   // 109
+	u8 dest_start_addr2;   // 10A
+	u8 spacer2;            // 10B
+	u8 mem_addr_offset0;   // 10C
+	u8 mem_addr_offset1;   // 10D
+	u8 spacer3[2];         // 10E
+	u8 width0;             // 110
+	u8 width1;             // 111
+	u8 height0;            // 112
+	u8 height1;            // 113
+	u8 bg_color0;          // 114
+	u8 bg_color1;          // 115
+	u8 spacer4[2];         // 116
+	u8 fg_color0;          // 118
+	u8 fg_color1;          // 119
+} reg_bitblt_t;
+
+// LUT
+#define REG_BASE_LUT           0x1e0
+typedef struct {
+	u8 mode;               // 1E0
+	u8 spacer1;            // 1E1
+	u8 addr;               // 1E2
+	u8 spacer2;            // 1E3
+	u8 data;               // 1E4
+} reg_lut_t;
+
+// Power Save Config
+#define REG_BASE_PWRSAVE       0x1f0
+typedef struct {
+	u8 cfg;                // 1F0
+	u8 status;             // 1F1
+} reg_pwrsave_t;
+
+// Misc
+#define REG_BASE_MISC          0x1f4
+typedef struct {
+	u8 cpu2mem_watchdog;   // 1F4
+	u8 spacer[7];          // 1F5
+	u8 disp_mode;          // 1FC
+} reg_misc_t;
+
+// MediaPlug
+#define REG_BASE_MEDIAPLUG     0x1000
+typedef struct {
+	u8 lcmd;               // 1000
+	u8 spacer1;            // 1001
+	u8 reserved_lcmd;      // 1002
+	u8 spacer2;            // 1003
+	u8 cmd;                // 1004
+	u8 spacer3;            // 1005
+	u8 reserved_cmd;       // 1006
+	u8 spacer4;            // 1007
+	u8 data;               // 1008
+} reg_mediaplug_t;
+
+// BitBlt data register. 16-bit access only
+#define REG_BASE_BITBLT_DATA   0x100000
+
+typedef struct {
+	reg_basic_t* basic;
+	reg_genio_t* genio;
+	reg_mdcfg_t* md_cfg;
+	reg_clkcfg_t* clk_cfg;
+	reg_memcfg_t* mem_cfg;
+	reg_panelcfg_t* panel_cfg;
+	reg_dispcfg_t* lcd_cfg;
+	reg_dispcfg_t* crttv_cfg;
+	reg_dispmode_t* lcd_mode;
+	reg_dispmode_t* crttv_mode;
+	reg_inkcurs_t* lcd_inkcurs;
+	reg_inkcurs_t* crttv_inkcurs;
+	reg_bitblt_t* bitblt;
+	reg_lut_t* lut;
+	reg_pwrsave_t* pwr_save;
+	reg_misc_t* misc;
+	reg_mediaplug_t* mediaplug;
+	u16* bitblt_data;
+} e1356_reg_t;
+
+
+/*--------------------------------------------------------*/
+
+enum mem_type_t {
+	MEM_TYPE_EDO_2CAS = 0,
+	MEM_TYPE_FPM_2CAS,
+	MEM_TYPE_EDO_2WE,
+	MEM_TYPE_FPM_2WE,
+	MEM_TYPE_EMBEDDED_SDRAM = 0x80
+};
+
+enum mem_smr_t {
+	MEM_SMR_CBR = 0,
+	MEM_SMR_SELF,
+	MEM_SMR_NONE
+};
+
+enum disp_type_t {
+	DISP_TYPE_LCD = 0,
+	DISP_TYPE_TFT,
+	DISP_TYPE_CRT,
+	DISP_TYPE_PAL,
+	DISP_TYPE_NTSC
+};
+
+/*
+ * Maximum timing values, as determined by the SED1356 register
+ * field sizes. All are indexed by display type, except
+ * max_hsync_start which is first indexed by color depth,
+ * then by display type.
+ */
+static const int max_hndp[5] = {256, 256, 512, 511, 510};
+static const int max_hsync_start[2][5] = {
+	{0, 252, 507, 505, 505}, // 8 bpp
+	{0, 254, 509, 507, 507}  // 16 bpp
+};
+static const int max_hsync_width[5] = {0, 128, 128, 0, 0};
+static const int max_vndp[5] = {64, 64, 128, 128, 128};
+static const int max_vsync_start[5] = {0, 64, 128, 128, 128};
+static const int max_vsync_width[5] = {0, 8, 8, 0, 0};
+
+#define IS_PANEL(disp_type) \
+    (disp_type == DISP_TYPE_LCD || disp_type == DISP_TYPE_TFT)
+#define IS_CRT(disp_type) (disp_type == DISP_TYPE_CRT)
+#define IS_TV(disp_type) \
+    (disp_type == DISP_TYPE_NTSC || disp_type == DISP_TYPE_PAL)
+
+
+enum tv_filters_t {
+	TV_FILT_LUM = 1,
+	TV_FILT_CHROM = 2,
+	TV_FILT_FLICKER = 4
+};
+
+enum tv_format_t {
+	TV_FMT_COMPOSITE = 0,
+	TV_FMT_S_VIDEO
+};
+
+
+struct e1356fb_fix {
+	int system;       // the number of a pre-packaged system
+	u64 regbase_phys; // phys start address of registers
+	u64 membase_phys; // phys start address of fb memory
+
+	// Memory parameters
+	int mem_speed;    // speed: 50, 60, 70, or 80 (nsec)
+	int mem_type;     // mem type: EDO-2CAS, FPM-2CAS, EDO-2WE, FPM-2WE
+	int mem_refresh;  // refresh rate in KHz
+	int mem_smr;      // suspend mode refresh: CAS_BEFORE_RAS, SELF, or NONE
+	// Clocks
+	int busclk;       // BUSCLK frequency, in KHz
+	int mclk;         // MCLK freq, in KHz, will either be BUSCLK or BUSCLK/2
+	int clki;         // CLKI frequency, in KHz
+	int clki2;        // CLKI2 frequency, in KHz
+
+	int disp_type;    // LCD, TFT, CRT, PAL, or NTSC
+
+	// TV Options
+	u8  tv_filt;      // TV Filter mask, LUM, CHROM, and FLICKER
+	int tv_fmt;       // TV output format, COMPOSITE or S_VIDEO
+    
+	// Panel (LCD,TFT) Options
+	int panel_el;     // enable support for EL-type panels
+	int panel_width;  // Panel data width: LCD: 4/8/16, TFT: 9/12/18
+    
+	// Misc
+	int noaccel;
+	int nopan;
+#ifdef CONFIG_MTRR
+	int nomtrr;
+#endif
+	int nohwcursor;
+	int mmunalign;    // force unaligned returned VA in mmap()
+	char fontname[40];
+
+	char *mode_option;
+};
+
+
+typedef struct {
+	int pixclk_d;     // Desired Pixel Clock, KHz
+	int pixclk;       // Closest supported clock to desired clock, KHz
+	int error;        // percent error between pixclock and pixclock_d
+	int clksrc;       // equal to busclk, mclk, clki, or clki2, KHz
+	int divisor;      // pixclk = clksrc/divisor, where divisor = 1,2,3, or 4
+	u8  pixclk_bits;  // pixclock register value for above settings
+} pixclock_info_t;
+
+
+struct e1356fb_par {
+	int width;
+	int height;
+	int width_virt;   // Width in pixels
+	int height_virt;  // Height in lines
+	int bpp;          // bits-per-pixel
+	int Bpp;          // Bytes-per-pixel
+
+	// Timing
+	pixclock_info_t ipclk;
+	int horiz_ndp;    // Horiz. Non-Display Period, pixels
+	int vert_ndp;     // Vert. Non-Display Period, lines
+	int hsync_pol;    // Polarity of horiz. sync signal (HRTC for CRT/TV,
+	// FPLINE for TFT). 0=active lo, 1=active hi
+	int hsync_start;  // Horiz. Sync Start position, pixels
+	int hsync_width;  // Horiz. Sync Pulse width, pixels
+	int hsync_freq;   // calculated horizontal sync frequency
+	int vsync_pol;    // Polarity of vert. sync signal (VRTC for CRT/TV,
+	// FPFRAME for TFT). 0=active lo, 1=active hi
+	int vsync_start;  // Vert. Sync Start position, lines
+	int vsync_width;  // Vert. Sync Pulse width, lines
+	int vsync_freq;   // calculated vertical sync frequency
+
+	int cmap_len;     // color-map length
+};
+
+
+
+struct fb_info_e1356 {
+	struct fb_info fb_info;
+
+	void *regbase_virt;
+	unsigned long regbase_size;
+	void *membase_virt;
+	unsigned long fb_size;
+
+	e1356_reg_t reg;
+
+	void* putcs_buffer;
+    
+	int max_pixclock;   // Max supported pixel clock, KHz
+	int open, mmaped;   // open count, is mmap'ed
+	
+	u8 chip_rev;
+    
+#ifdef CONFIG_MTRR
+	int mtrr_idx;
+#endif
+
+#ifdef SHADOW_FRAME_BUFFER
+	struct {
+		void* fb;
+		struct timer_list timer;
+	} shadow;
+#endif
+
+	struct { unsigned red, green, blue, pad; } palette[256];
+	struct display disp;
+
+#if defined(FBCON_HAS_CFB16)
+	u16 fbcon_cmap16[16];
+#endif
+    
+	struct {
+		int type;
+		int state;
+		int w,h,u;
+		int x,y,redraw;
+		unsigned long enable,disable;
+		struct timer_list timer;
+		spinlock_t lock; 
+	} cursor;
+ 
+	struct e1356fb_fix fix;
+	struct e1356fb_par default_par;
+	struct e1356fb_par current_par;
+};
+
+
+// The following are boot options for particular SED1356-based target systems
+
+enum {
+	SYS_NULL,
+	SYS_PB1000,
+	SYS_PB1500,
+	SYS_SDU1356,
+	SYS_CLIO1050,
+	NUM_SYSTEMS // must be last
+};
+
+static struct {
+	struct e1356fb_fix fix;
+	struct e1356fb_par par;
+} systems[NUM_SYSTEMS] = {
+
+	/*
+	 * NULL system to help us detect missing options
+ 	 * when the driver is compiled as a module.
+	 */
+	{
+		{   // fix
+			SYS_NULL,
+		},
+		{   // par
+		}
+	},
+
+	/*
+	 * Alchemy Pb1000 evaluation board, SED1356
+	 */
+	{
+		{   // fix
+			SYS_PB1000,
+			/*
+			 * Note!: these are "pseudo" physical addresses;
+			 * the SED1356 is not actually mapped here, but rather
+			 * at the 36-bit address of 0xE 0000 0000. There is an
+			 * ugly hack in the Au1000 TLB refill handler that will
+			 * translate pte_t's in the range 0xE000 0000 -->
+			 * 0xEFFF FFFF to the 36-bit range 0xE 0000 0000 -->
+			 * 0xE 0FFF FFFF. The long-term solution is to support
+			 * 36-bit physical addresses in linux-mips32 mm, since
+			 * the mips32 specification specifically supports this.
+			 */
+			0xE00000000, 0xE00200000,
+			60, MEM_TYPE_EDO_2CAS, 64, MEM_SMR_CBR,
+			0, 0,   // BUSCLK and MCLK are calculated at run-time
+			40000, 14318, // CLKI, CLKI2
+#ifdef CONFIG_PB1000_CRT
+			DISP_TYPE_CRT,
+			0, 0, // TV Options
+			0, 0, // Panel options
+#elif defined (CONFIG_PB1000_NTSC)
+			DISP_TYPE_NTSC,
+			TV_FILT_FLICKER|TV_FILT_LUM|TV_FILT_CHROM,
+			TV_FMT_COMPOSITE,
+			0, 0, // Panel options
+#elif defined (CONFIG_PB1000_TFT)
+			DISP_TYPE_TFT,
+			0, 0, // TV Options
+			0, 12, // Panel options, EL panel?, data width?
+#else
+			DISP_TYPE_PAL,
+			TV_FILT_FLICKER|TV_FILT_LUM|TV_FILT_CHROM,
+			TV_FMT_COMPOSITE,
+			0, 0, // Panel options
+#endif
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"800x600@60"
+		},
+		{   // par
+			0, 0, 800, 600, 8, 1,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			256
+		}
+	},
+
+	/*
+	 * Alchemy Pb1500 evaluation board, SED13806
+	 */
+	{
+		{   // fix
+			SYS_PB1500,
+			/*
+			 * Note!: these are "pseudo" physical addresses;
+			 * the SED1356 is not actually mapped here, but rather
+			 * at the 36-bit address of 0xE 0000 0000. There is an
+			 * ugly hack in the Au1000 TLB refill handler that will
+			 * translate pte_t's in the range 0xE000 0000 -->
+			 * 0xEFFF FFFF to the 36-bit range 0xE 0000 0000 -->
+			 * 0xE 0FFF FFFF. The long-term solution is to support
+			 * 36-bit physical addresses in linux-mips32 mm, since
+			 * the mips32 specification specifically supports this.
+			 */
+			0xE1B000000, 0xE1B200000,
+			50, MEM_TYPE_EMBEDDED_SDRAM, 64, MEM_SMR_CBR,
+			0, 0,   // BUSCLK and MCLK are calculated at run-time
+			40000, 14318, // CLKI, CLKI2
+#ifdef CONFIG_PB1500_CRT
+			DISP_TYPE_CRT,
+			0, 0, // TV Options
+			0, 0, // Panel options
+#else
+			DISP_TYPE_TFT,
+			0, 0, // TV Options
+			0, 12, // Panel options, EL panel?, data width?
+#endif
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"800x600@60"
+		},
+		{   // par
+			0, 0, 800, 600, 8, 1,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			256
+		}
+	},
+
+	/*
+	 * Epson SDU1356B0C PCI eval card. These settings assume the
+	 * card is configured for PCI, the MediaPlug is disabled,
+	 * and the onboard clock synthesizer is at the power-up
+	 * clock settings.
+	 */
+	{
+		{   // fix
+			SYS_SDU1356,
+			0x0, 0x0,  // addresses obtained from PCI config space
+			// FIXME: just guess for now
+			60, MEM_TYPE_EDO_2CAS, 64, MEM_SMR_CBR,
+			33000, 0, 40000, 25175, // BUSCLK, MCLK, CLKI, CLKI2
+			DISP_TYPE_CRT,
+			0, 0,
+			0, 0,
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"800x600@60"
+		},
+		{   // par
+			0, 0, 1024, 768, 8, 1,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			256
+		}
+	},
+
+	/*
+	 * Vadem Clio 1050 - this is for the benefit of the Linux-VR project.
+	 * FIXME: Most of these settings are just guesses, until I can get a
+	 * Clio 1050 and dump the registers that WinCE has setup.
+	 */
+	{
+		{   // fix
+			SYS_CLIO1050,
+			0x0a000000, 0x0a200000,
+			60, MEM_TYPE_EDO_2CAS, 64, MEM_SMR_CBR,
+			40000, 40000, 14318, 14318,
+			DISP_TYPE_TFT,
+			0, 0,
+			0, 16,
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"640x480@85"
+		},
+		{   // par
+			0, 0, 1024, 768, 16, 2,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			16
+		}
+	}
+};
diff -Naur linux-2.6.14/drivers/video/gbefb.c linux-mips-2.6.14.orig/drivers/video/gbefb.c
--- linux-2.6.14/drivers/video/gbefb.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/video/gbefb.c	2005-11-17 11:43:50.000000000 -0800
@@ -1126,7 +1126,7 @@
 	gbefb_setup(options);
 #endif
 
-	if (!request_mem_region(GBE_BASE, sizeof(struct sgi_gbe), "GBE")) {
+	if (!request_region(GBE_BASE, sizeof(struct sgi_gbe), "GBE")) {
 		printk(KERN_ERR "gbefb: couldn't reserve mmio region\n");
 		ret = -EBUSY;
 		goto out_release_framebuffer;
@@ -1152,12 +1152,24 @@
 	if (gbe_mem_phys) {
 		/* memory was allocated at boot time */
 		gbe_mem = ioremap_nocache(gbe_mem_phys, gbe_mem_size);
+		if (!gbe_mem) {
+			printk(KERN_ERR "gbefb: couldn't map framebuffer\n");
+			ret = -ENOMEM;
+			goto out_tiles_free;
+		}
+
 		gbe_dma_addr = 0;
 	} else {
 		/* try to allocate memory with the classical allocator
 		 * this has high chance to fail on low memory machines */
 		gbe_mem = dma_alloc_coherent(NULL, gbe_mem_size, &gbe_dma_addr,
 					     GFP_KERNEL);
+		if (!gbe_mem) {
+			printk(KERN_ERR "gbefb: couldn't allocate framebuffer memory\n");
+			ret = -ENOMEM;
+			goto out_tiles_free;
+		}
+
 		gbe_mem_phys = (unsigned long) gbe_dma_addr;
 	}
 
@@ -1165,12 +1177,6 @@
 	mtrr_add(gbe_mem_phys, gbe_mem_size, MTRR_TYPE_WRCOMB, 1);
 #endif
 
-	if (!gbe_mem) {
-		printk(KERN_ERR "gbefb: couldn't map framebuffer\n");
-		ret = -ENXIO;
-		goto out_tiles_free;
-	}
-
 	/* map framebuffer memory into tiles table */
 	for (i = 0; i < (gbe_mem_size >> TILE_SHIFT); i++)
 		gbe_tiles.cpu[i] = (gbe_mem_phys >> TILE_SHIFT) + i;
diff -Naur linux-2.6.14/drivers/video/Kconfig linux-mips-2.6.14.orig/drivers/video/Kconfig
--- linux-2.6.14/drivers/video/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/video/Kconfig	2005-11-17 11:43:49.000000000 -0800
@@ -1186,6 +1186,19 @@
 	  Please read the <file:Documentation/fb/README-sstfb.txt> for supported
 	  options and other important info  support.
 
+config FB_SMIVGX
+	tristate "Silicon Motion VoyagerGX support"
+	depends on FB && PCI && (MIPS || EXPERIMENTAL)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_SOFT_CURSOR
+	---help---
+	  This drivers supports SMI VoyagerGX 501 based PCI boards
+	  The default settings drive both a CRT and LCD.  The CRT
+	  can be turned off by passing in the no_crt option
+	
+
 config FB_CYBLA
 	tristate "Cyberblade/i1 support"
 	depends on FB && PCI
@@ -1284,7 +1297,27 @@
 
 config FB_AU1100
 	bool "Au1100 LCD Driver"
-	depends on (FB = y) && EXPERIMENTAL && PCI && MIPS && MIPS_PB1100=y
+	depends on FB && MIPS && SOC_AU1100
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_SOFT_CURSOR
+	help
+	  This is the framebuffer driver for the AMD Au1100 SOC.  It can drive
+	  various panels and CRTs by passing in kernel cmd line option
+	  au1100fb:panel=<name>.
+
+config FB_AU1200
+	bool "Au1200 LCD Driver"
+	depends on FB && MIPS && SOC_AU1200
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	select FB_SOFT_CURSOR
+	help
+	  This is the framebuffer driver for the AMD Au1200 SOC.  It can drive
+	  various panels and CRTs by passing in kernel cmd line option
+	  au1200fb:panel=<name>.
 
 source "drivers/video/geode/Kconfig"
 
@@ -1376,7 +1409,7 @@
 
 config FB_PMAG_AA
 	bool "PMAG-AA TURBOchannel framebuffer support"
-	depends on (FB = y) && MACH_DECSTATION && TC
+	depends on (FB = y) && TC
  	select FB_CFB_FILLRECT
  	select FB_CFB_COPYAREA
  	select FB_CFB_IMAGEBLIT
@@ -1387,7 +1420,7 @@
 
 config FB_PMAG_BA
 	bool "PMAG-BA TURBOchannel framebuffer support"
-	depends on (FB = y) && MACH_DECSTATION && TC
+	depends on (FB = y) && TC
  	select FB_CFB_FILLRECT
  	select FB_CFB_COPYAREA
  	select FB_CFB_IMAGEBLIT
@@ -1398,19 +1431,19 @@
 
 config FB_PMAGB_B
 	bool "PMAGB-B TURBOchannel framebuffer support"
-	depends on (FB = y) && MACH_DECSTATION && TC
+	depends on (FB = y) && TC
  	select FB_CFB_FILLRECT
  	select FB_CFB_COPYAREA
  	select FB_CFB_IMAGEBLIT
 	select FB_SOFT_CURSOR
 	help
 	  Support for the PMAGB-B TURBOchannel framebuffer card used mainly
-	  in the MIPS-based DECstation series. The card is currently only
-	  supported in 1280x1024x8 mode.
+	  in the MIPS-based DECstation series. The card is currently only 
+	  supported in 1280x1024x8 mode.  
 
 config FB_MAXINE
 	bool "Maxine (Personal DECstation) onboard framebuffer support"
-	depends on (FB = y) && MACH_DECSTATION && TC
+	depends on (FB = y) && MACH_DECSTATION
  	select FB_CFB_FILLRECT
  	select FB_CFB_COPYAREA
  	select FB_CFB_IMAGEBLIT
diff -Naur linux-2.6.14/drivers/video/Makefile linux-mips-2.6.14.orig/drivers/video/Makefile
--- linux-2.6.14/drivers/video/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/drivers/video/Makefile	2005-11-17 11:43:49.000000000 -0800
@@ -86,7 +86,8 @@
 obj-$(CONFIG_FB_ASILIANT)	  += asiliantfb.o
 obj-$(CONFIG_FB_PXA)		  += pxafb.o
 obj-$(CONFIG_FB_W100)		  += w100fb.o
-obj-$(CONFIG_FB_AU1100)		  += au1100fb.o fbgen.o
+obj-$(CONFIG_FB_AU1100)		  += au1100fb.o
+obj-$(CONFIG_FB_AU1200)		  += au1200fb.o
 obj-$(CONFIG_FB_PMAG_AA)	  += pmag-aa-fb.o
 obj-$(CONFIG_FB_PMAG_BA)	  += pmag-ba-fb.o
 obj-$(CONFIG_FB_PMAGB_B)	  += pmagb-b-fb.o
@@ -94,6 +95,7 @@
 obj-$(CONFIG_FB_TX3912)		  += tx3912fb.o
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
+obj-$(CONFIG_FB_SMIVGX)		  += smivgxfb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 
 # Platform or fallback drivers go here
diff -Naur linux-2.6.14/drivers/video/smivgxfb.c linux-mips-2.6.14.orig/drivers/video/smivgxfb.c
--- linux-2.6.14/drivers/video/smivgxfb.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/video/smivgxfb.c	2005-11-17 11:43:50.000000000 -0800
@@ -0,0 +1,316 @@
+/***************************************************************************
+ *  Silicon Motion VoyaagerGX framebuffer driver
+ *
+ * 	ported to 2.6 by Embedded Alley Solutions, Inc
+ * 	Copyright (C) 2005 Embedded Alley Solutions, Inc
+ *
+ * 		based on
+    copyright            : (C) 2001 by Szu-Tao Huang
+    email                : johuang@siliconmotion.com
+    Updated to SM501 by Eric.Devolder@amd.com and dan@embeddededge.com
+    for the AMD Mirage Portable Tablet.  20 Oct 2003
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+static char *SMIRegs;		// point to virtual Memory Map IO starting address
+static char *SMILFB;		// point to virtual video memory starting address
+
+static struct fb_fix_screeninfo smifb_fix __initdata = {
+	.id =		"smivgx",
+	.type =		FB_TYPE_PACKED_PIXELS,
+	.visual =	FB_VISUAL_TRUECOLOR,
+	.ywrapstep = 	0,
+	.xpanstep = 	1,
+	.ypanstep = 	1,
+	.line_length	= 1024 * 2, /* (bbp * xres)/8 */
+	.accel =	FB_ACCEL_NONE,
+};
+
+static struct fb_var_screeninfo smifb_var = {
+	.xres           = 1024,
+	.yres           = 768,
+	.xres_virtual   = 1024,
+	.yres_virtual   = 768,
+	.bits_per_pixel = 16,
+	.red            = { 11, 5, 0 },
+	.green          = {  5, 6, 0 },
+	.blue           = {  0, 5, 0 },
+	.activate       = FB_ACTIVATE_NOW,
+	.height         = -1,
+	.width          = -1,
+	.vmode          = FB_VMODE_NONINTERLACED,
+};      
+
+
+static struct fb_info info;
+
+#include "smivgxfb.h"
+
+static int initdone = 0;
+static int crt_out = 1;
+
+
+static int
+smi_setcolreg(unsigned regno, unsigned red, unsigned green,
+	unsigned blue, unsigned transp,
+	struct fb_info *info)
+{
+	if (regno > 255)
+		return 1;
+
+	((u16 *)(info->pseudo_palette))[regno] = 
+		    ((red & 0xf800) >> 0) |
+		    ((green & 0xfc00) >> 5) |
+		    ((blue & 0xf800) >> 11);
+
+	return 0;
+}
+
+/* This function still needs lots of work to generically support
+ * different output devices (CRT or LCD) and resolutions.
+ * Currently hard-coded for 1024x768 LCD panel.
+ */
+void
+smi_setmode(void)
+{
+	if (initdone)
+		return;
+
+	initdone = 1;
+
+	/* Just blast in some control values based upon the chip
+	 * documentation.  We use the internal memory, I don't know
+	 * how to determine the amount available yet.
+	 */
+	smi_mmiowl(0x07F127C2, DRAM_CTRL);
+	smi_mmiowl(0x02000020, PANEL_HWC_ADDRESS);
+	smi_mmiowl(0x007FF800, PANEL_HWC_ADDRESS);
+	smi_mmiowl(0x00021827, POWER_MODE1_GATE);
+	smi_mmiowl(0x011A0A09, POWER_MODE1_CLOCK);
+	smi_mmiowl(0x00000001, POWER_MODE_CTRL);
+	smi_mmiowl(0x80000000, PANEL_FB_ADDRESS);
+	smi_mmiowl(0x08000800, PANEL_FB_WIDTH);
+	smi_mmiowl(0x04000000, PANEL_WINDOW_WIDTH);
+	smi_mmiowl(0x03000000, PANEL_WINDOW_HEIGHT);
+	smi_mmiowl(0x00000000, PANEL_PLANE_TL);
+	smi_mmiowl(0x02FF03FF, PANEL_PLANE_BR);
+	smi_mmiowl(0x05D003FF, PANEL_HORIZONTAL_TOTAL);
+	smi_mmiowl(0x00C80424, PANEL_HORIZONTAL_SYNC);
+	smi_mmiowl(0x032502FF, PANEL_VERTICAL_TOTAL);
+	smi_mmiowl(0x00060302, PANEL_VERTICAL_SYNC);
+	smi_mmiowl(0x00013905, PANEL_DISPLAY_CTRL);
+	smi_mmiowl(0x01013105, PANEL_DISPLAY_CTRL);
+	waitforvsync();
+	smi_mmiowl(0x03013905, PANEL_DISPLAY_CTRL);
+	waitforvsync();
+	smi_mmiowl(0x07013905, PANEL_DISPLAY_CTRL);
+	waitforvsync();
+	smi_mmiowl(0x0F013905, PANEL_DISPLAY_CTRL);
+	smi_mmiowl(0x0002187F, POWER_MODE1_GATE);
+	smi_mmiowl(0x01011801, POWER_MODE1_CLOCK);
+	smi_mmiowl(0x00000001, POWER_MODE_CTRL);
+
+	smi_mmiowl(0x80000000, PANEL_FB_ADDRESS);
+	smi_mmiowl(0x00000000, PANEL_PAN_CTRL);
+	smi_mmiowl(0x00000000, PANEL_COLOR_KEY);
+
+	if (crt_out) {
+		/* Just sent the panel out to the CRT for now.
+		*/
+		smi_mmiowl(0x80000000, CRT_FB_ADDRESS);
+		smi_mmiowl(0x08000800, CRT_FB_WIDTH);
+		smi_mmiowl(0x05D003FF, CRT_HORIZONTAL_TOTAL);
+		smi_mmiowl(0x00C80424, CRT_HORIZONTAL_SYNC);
+		smi_mmiowl(0x032502FF, CRT_VERTICAL_TOTAL);
+		smi_mmiowl(0x00060302, CRT_VERTICAL_SYNC);
+		smi_mmiowl(0x007FF800, CRT_HWC_ADDRESS);
+		smi_mmiowl(0x00010305, CRT_DISPLAY_CTRL);
+		smi_mmiowl(0x00000001, MISC_CTRL);
+	}
+
+}
+
+/*
+ * Unmap in the memory mapped IO registers
+ *
+ */
+
+static void __devinit smi_unmap_mmio(void)
+{
+	if (SMIRegs) {
+		iounmap(SMIRegs);
+		SMIRegs = NULL;
+	}
+}
+
+
+/*
+ * Unmap in the screen memory
+ *
+ */
+static void __devinit smi_unmap_smem(void)
+{
+	if (SMILFB) {
+		iounmap(SMILFB);
+		SMILFB = NULL;
+	}
+}
+
+void
+vgxfb_setup (char *options)
+{
+    
+	if (!options || !*options)
+		return;
+
+	/* The only thing I'm looking for right now is to disable a
+	 * CRT output that mirrors the panel display.
+	 */
+	if (strcmp(options, "no_crt") == 0)
+		crt_out = 0;
+
+	return;
+}
+
+static struct fb_ops smifb_ops = {
+	.owner =		THIS_MODULE,
+	.fb_setcolreg =		smi_setcolreg,
+	.fb_fillrect =		cfb_fillrect,
+	.fb_copyarea =		cfb_copyarea,
+	.fb_imageblit =		cfb_imageblit,
+	.fb_cursor =		soft_cursor,
+};
+
+static int __devinit vgx_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int err;
+
+	/* Enable the chip.
+	*/
+	err = pci_enable_device(dev);
+	if (err)
+		return err;
+
+
+	/* Set up MMIO space.
+	*/
+	smifb_fix.mmio_start = pci_resource_start(dev,1);
+	smifb_fix.mmio_len = 0x00200000;
+	SMIRegs = ioremap(smifb_fix.mmio_start, smifb_fix.mmio_len);
+
+	/* Set up framebuffer.  It's a 64M space, various amount of
+	 * internal memory.  I don't know how to determine the real
+	 * amount of memory (yet).
+	 */
+	smifb_fix.smem_start = pci_resource_start(dev,0);
+	smifb_fix.smem_len = 0x00800000;
+	SMILFB = ioremap(smifb_fix.smem_start, smifb_fix.smem_len);
+
+	memset((void *)SMILFB, 0, smifb_fix.smem_len);
+
+	info.screen_base = SMILFB;
+	info.fbops = &smifb_ops;
+	info.fix = smifb_fix;
+
+	info.flags = FBINFO_FLAG_DEFAULT;
+
+	info.pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL);
+	if (!info.pseudo_palette) {
+		return -ENOMEM;
+	}
+	memset((void *)info.pseudo_palette, 0, sizeof(u32) *16);
+
+	fb_alloc_cmap(&info.cmap,256,0);
+
+	smi_setmode();
+
+	info.var = smifb_var;
+
+	if (register_framebuffer(&info) < 0)
+		goto failed;
+
+	return 0;
+
+failed:
+	smi_unmap_smem();
+	smi_unmap_mmio();
+
+	return err;
+}
+
+static void __devexit vgx_pci_remove(struct pci_dev *dev)
+{
+	unregister_framebuffer(&info);
+	smi_unmap_smem();
+	smi_unmap_mmio();
+}
+
+/*
+ * Rev. AA is 0x501, Rev. B is 0x510.
+ */
+static struct pci_device_id vgx_devices[] = {
+	{0x126f, 0x510, PCI_ANY_ID, PCI_ANY_ID,0,0,0},
+	{0x126f, 0x501, PCI_ANY_ID, PCI_ANY_ID,0,0,0},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, vgx_devices);
+
+static struct pci_driver vgxfb_pci_driver = {
+	.name	= "vgxfb",
+	.id_table= vgx_devices,
+	.probe	= vgx_pci_probe,
+	.remove	= __devexit_p(vgx_pci_remove),
+};
+
+int __init vgxfb_init(void)
+{
+	char *option = NULL;
+
+	if (fb_get_options("vgxfb", &option))
+		return -ENODEV;
+	vgxfb_setup(option);
+
+	printk("Silicon Motion Inc. VOYAGER Init complete.\n");
+	return pci_module_init(&vgxfb_pci_driver);
+}
+
+void __exit vgxfb_exit(void)
+{
+	pci_unregister_driver(&vgxfb_pci_driver);
+}
+
+module_init(vgxfb_init);
+module_exit(vgxfb_exit);
+
+MODULE_AUTHOR("");
+MODULE_DESCRIPTION("Framebuffer driver for SMI Voyager");
+MODULE_LICENSE("GPL");
+
diff -Naur linux-2.6.14/drivers/video/smivgxfb.h linux-mips-2.6.14.orig/drivers/video/smivgxfb.h
--- linux-2.6.14/drivers/video/smivgxfb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/drivers/video/smivgxfb.h	2005-11-17 11:43:50.000000000 -0800
@@ -0,0 +1,128 @@
+/***************************************************************************
+ * Silicon Motion VoyagerGX  framebuffer driver
+ *
+ * 	port to 2.6 by Embedded Alley Solutions, Inc
+ * 	Copyright (C) 2005 Embedded Alley Solutions, Inc
+ *
+ * 		based on:
+    copyright            : (C) 2001 by Szu-Tao Huang
+    email                : johuang@siliconmotion.com
+    
+    Updated to SM501 by Eric.Devolder@amd.com and dan@embeddededge.com
+    for the AMD Mirage Portable Tablet.  20 Oct 2003
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <linux/config.h>
+
+#define smi_mmiowb(dat,reg)	writeb(dat, (SMIRegs + reg))
+#define smi_mmioww(dat,reg)	writew(dat, (SMIRegs + reg))
+#define smi_mmiowl(dat,reg)	writel(dat, (SMIRegs + reg))
+
+#define smi_mmiorb(reg)	        readb(SMIRegs + reg)
+#define smi_mmiorw(reg)	        readw(SMIRegs + reg)
+#define smi_mmiorl(reg)	        readl(SMIRegs + reg)
+
+#define NR_PALETTE      256
+
+/* Address space offsets for various control/status registers.
+*/
+#define MISC_CTRL			0x000004
+#define GPIO_LO_CTRL			0x000008
+#define GPIO_HI_CTRL			0x00000c
+#define DRAM_CTRL			0x000010
+#define CURRENT_POWER_GATE		0x000038
+#define CURRENT_POWER_CLOCK		0x00003C
+#define POWER_MODE1_GATE                0x000048
+#define POWER_MODE1_CLOCK               0x00004C
+#define POWER_MODE_CTRL			0x000054
+
+#define GPIO_DATA_LO			0x010000
+#define GPIO_DATA_HI			0x010004
+#define GPIO_DATA_DIR_LO		0x010008
+#define GPIO_DATA_DIR_HI		0x01000c
+#define I2C_BYTE_COUNT			0x010040
+#define I2C_CONTROL			0x010041
+#define I2C_STATUS_RESET		0x010042
+#define I2C_SLAVE_ADDRESS		0x010043
+#define I2C_DATA			0x010044
+
+#define DE_COLOR_COMPARE		0x100020
+#define DE_COLOR_COMPARE_MASK		0x100024
+#define DE_MASKS			0x100028
+#define DE_WRAP				0x10004C
+
+#define PANEL_DISPLAY_CTRL              0x080000
+#define PANEL_PAN_CTRL                  0x080004
+#define PANEL_COLOR_KEY                 0x080008
+#define PANEL_FB_ADDRESS                0x08000C
+#define PANEL_FB_WIDTH                  0x080010
+#define PANEL_WINDOW_WIDTH              0x080014
+#define PANEL_WINDOW_HEIGHT             0x080018
+#define PANEL_PLANE_TL                  0x08001C
+#define PANEL_PLANE_BR                  0x080020
+#define PANEL_HORIZONTAL_TOTAL          0x080024
+#define PANEL_HORIZONTAL_SYNC           0x080028
+#define PANEL_VERTICAL_TOTAL            0x08002C
+#define PANEL_VERTICAL_SYNC             0x080030
+#define PANEL_CURRENT_LINE              0x080034
+#define VIDEO_DISPLAY_CTRL		0x080040
+#define VIDEO_DISPLAY_FB0		0x080044
+#define VIDEO_DISPLAY_FBWIDTH		0x080048
+#define VIDEO_DISPLAY_FB0LAST		0x08004C
+#define VIDEO_DISPLAY_TL		0x080050
+#define VIDEO_DISPLAY_BR		0x080054
+#define VIDEO_SCALE			0x080058
+#define VIDEO_INITIAL_SCALE		0x08005C
+#define VIDEO_YUV_CONSTANTS		0x080060
+#define VIDEO_DISPLAY_FB1		0x080064
+#define VIDEO_DISPLAY_FB1LAST		0x080068
+#define VIDEO_ALPHA_CTRL		0x080080
+#define PANEL_HWC_ADDRESS		0x0800F0
+#define CRT_DISPLAY_CTRL		0x080200
+#define CRT_FB_ADDRESS			0x080204
+#define CRT_FB_WIDTH			0x080208
+#define CRT_HORIZONTAL_TOTAL		0x08020c
+#define CRT_HORIZONTAL_SYNC		0x080210
+#define CRT_VERTICAL_TOTAL		0x080214
+#define CRT_VERTICAL_SYNC		0x080218
+#define CRT_HWC_ADDRESS			0x080230
+#define CRT_HWC_LOCATION		0x080234
+
+#define ZV_CAPTURE_CTRL			0x090000
+#define ZV_CAPTURE_CLIP			0x090004
+#define ZV_CAPTURE_SIZE			0x090008
+#define ZV_CAPTURE_BUF0			0x09000c
+#define ZV_CAPTURE_BUF1			0x090010
+#define ZV_CAPTURE_OFFSET		0x090014
+#define ZV_FIFO_CTRL			0x090018
+
+#define waitforvsync() udelay(100); udelay(100); udelay(100); udelay(100);
+
+/*
+ * Minimum X and Y resolutions
+ */
+#define MIN_XRES	640
+#define MIN_YRES	480
+
+/*
+* Private structure
+*/
+struct smifb_par
+{
+	/*
+	 * Hardware
+	 */
+	u16		chipID;
+
+	u_int	width;
+	u_int	height;
+	u_int	hz;
+};
diff -Naur linux-2.6.14/include/asm-mips/abi.h linux-mips-2.6.14.orig/include/asm-mips/abi.h
--- linux-2.6.14/include/asm-mips/abi.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/abi.h	2005-11-17 11:44:26.000000000 -0800
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 by Ralf Baechle
+ * Copyright (C) 2005 MIPS Technologies, Inc.
+ */
+#ifndef _ASM_ABI_H
+#define _ASM_ABI_H
+
+#include <asm/signal.h>
+#include <asm/siginfo.h>
+
+struct mips_abi {
+	int (* const do_signal)(sigset_t *oldset, struct pt_regs *regs);
+	int (* const setup_frame)(struct k_sigaction * ka,
+	                          struct pt_regs *regs, int signr,
+	                          sigset_t *set);
+	int (* const setup_rt_frame)(struct k_sigaction * ka,
+	                       struct pt_regs *regs, int signr,
+	                       sigset_t *set, siginfo_t *info);
+};
+
+#endif /* _ASM_ABI_H */
diff -Naur linux-2.6.14/include/asm-mips/addrspace.h linux-mips-2.6.14.orig/include/asm-mips/addrspace.h
--- linux-2.6.14/include/asm-mips/addrspace.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/addrspace.h	2005-11-17 11:44:26.000000000 -0800
@@ -20,10 +20,12 @@
 #define _ATYPE_
 #define _ATYPE32_
 #define _ATYPE64_
+#define _LLCONST_(x)	x
 #else
 #define _ATYPE_		__PTRDIFF_TYPE__
 #define _ATYPE32_	int
 #define _ATYPE64_	long long
+#define _LLCONST_(x)	x ## LL
 #endif
 
 /*
@@ -45,8 +47,9 @@
 /*
  * Returns the physical address of a CKSEGx / XKPHYS address
  */
-#define CPHYSADDR(a)		((_ACAST32_ (a)) & 0x1fffffff)
-#define XPHYSADDR(a)            ((_ACAST64_ (a)) & 0x000000ffffffffff)
+#define CPHYSADDR(a)		((_ACAST32_(a)) & 0x1fffffff)
+#define XPHYSADDR(a)            ((_ACAST64_(a)) &			\
+				 _LLCONST_(0x000000ffffffffff))
 
 #ifdef CONFIG_64BIT
 
@@ -55,14 +58,14 @@
  * The compatibility segments use the full 64-bit sign extended value.  Note
  * the R8000 doesn't have them so don't reference these in generic MIPS code.
  */
-#define XKUSEG			0x0000000000000000
-#define XKSSEG			0x4000000000000000
-#define XKPHYS			0x8000000000000000
-#define XKSEG			0xc000000000000000
-#define CKSEG0			0xffffffff80000000
-#define CKSEG1			0xffffffffa0000000
-#define CKSSEG			0xffffffffc0000000
-#define CKSEG3			0xffffffffe0000000
+#define XKUSEG			_LLCONST_(0x0000000000000000)
+#define XKSSEG			_LLCONST_(0x4000000000000000)
+#define XKPHYS			_LLCONST_(0x8000000000000000)
+#define XKSEG			_LLCONST_(0xc000000000000000)
+#define CKSEG0			_LLCONST_(0xffffffff80000000)
+#define CKSEG1			_LLCONST_(0xffffffffa0000000)
+#define CKSSEG			_LLCONST_(0xffffffffc0000000)
+#define CKSEG3			_LLCONST_(0xffffffffe0000000)
 
 #define CKSEG0ADDR(a)		(CPHYSADDR(a) | CKSEG0)
 #define CKSEG1ADDR(a)		(CPHYSADDR(a) | CKSEG1)
@@ -120,7 +123,8 @@
 #define PHYS_TO_XKSEG_UNCACHED(p)	PHYS_TO_XKPHYS(K_CALG_UNCACHED,(p))
 #define PHYS_TO_XKSEG_CACHED(p)		PHYS_TO_XKPHYS(K_CALG_COH_SHAREABLE,(p))
 #define XKPHYS_TO_PHYS(p)		((p) & TO_PHYS_MASK)
-#define PHYS_TO_XKPHYS(cm,a)		(0x8000000000000000 | ((cm)<<59) | (a))
+#define PHYS_TO_XKPHYS(cm,a)		(_LLCONST_(0x8000000000000000) | \
+					 ((cm)<<59) | (a))
 
 #if defined (CONFIG_CPU_R4300)						\
     || defined (CONFIG_CPU_R4X00)					\
@@ -128,46 +132,56 @@
     || defined (CONFIG_CPU_NEVADA)					\
     || defined (CONFIG_CPU_TX49XX)					\
     || defined (CONFIG_CPU_MIPS64)
-#define	KUSIZE			0x0000010000000000	/* 2^^40 */
-#define	KUSIZE_64		0x0000010000000000	/* 2^^40 */
-#define	K0SIZE			0x0000001000000000	/* 2^^36 */
-#define	K1SIZE			0x0000001000000000	/* 2^^36 */
-#define	K2SIZE			0x000000ff80000000
-#define	KSEGSIZE		0x000000ff80000000	/* max syssegsz */
-#define TO_PHYS_MASK		0x0000000fffffffff	/* 2^^36 - 1 */
+#define KUSIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define KUSIZE_64	_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K0SIZE		_LLCONST_(0x0000001000000000)	/* 2^^36 */
+#define K1SIZE		_LLCONST_(0x0000001000000000)	/* 2^^36 */
+#define K2SIZE		_LLCONST_(0x000000ff80000000)
+#define KSEGSIZE	_LLCONST_(0x000000ff80000000)	/* max syssegsz */
+#define TO_PHYS_MASK	_LLCONST_(0x0000000fffffffff)	/* 2^^36 - 1 */
 #endif
 
 #if defined (CONFIG_CPU_R8000)
 /* We keep KUSIZE consistent with R4000 for now (2^^40) instead of (2^^48) */
-#define	KUSIZE			0x0000010000000000	/* 2^^40 */
-#define	KUSIZE_64		0x0000010000000000	/* 2^^40 */
-#define	K0SIZE			0x0000010000000000	/* 2^^40 */
-#define	K1SIZE			0x0000010000000000	/* 2^^40 */
-#define	K2SIZE			0x0001000000000000
-#define	KSEGSIZE		0x0000010000000000	/* max syssegsz */
-#define TO_PHYS_MASK		0x000000ffffffffff	/* 2^^40 - 1 */
+#define KUSIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define KUSIZE_64	_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K0SIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K1SIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K2SIZE		_LLCONST_(0x0001000000000000)
+#define KSEGSIZE	_LLCONST_(0x0000010000000000)	/* max syssegsz */
+#define TO_PHYS_MASK	_LLCONST_(0x000000ffffffffff)	/* 2^^40 - 1 */
 #endif
 
 #if defined (CONFIG_CPU_R10000)
-#define	KUSIZE			0x0000010000000000	/* 2^^40 */
-#define	KUSIZE_64		0x0000010000000000	/* 2^^40 */
-#define	K0SIZE			0x0000010000000000	/* 2^^40 */
-#define	K1SIZE			0x0000010000000000	/* 2^^40 */
-#define	K2SIZE			0x00000fff80000000
-#define	KSEGSIZE		0x00000fff80000000	/* max syssegsz */
-#define TO_PHYS_MASK		0x000000ffffffffff	/* 2^^40 - 1 */
+#define KUSIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define KUSIZE_64	_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K0SIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K1SIZE		_LLCONST_(0x0000010000000000)	/* 2^^40 */
+#define K2SIZE		_LLCONST_(0x00000fff80000000)
+#define KSEGSIZE	_LLCONST_(0x00000fff80000000)	/* max syssegsz */
+#define TO_PHYS_MASK	_LLCONST_(0x000000ffffffffff)	/* 2^^40 - 1 */
+#endif
+
+#if defined(CONFIG_CPU_SB1) || defined(CONFIG_CPU_SB1A)
+#define KUSIZE		_LLCONST_(0x0000100000000000)	/* 2^^44 */
+#define KUSIZE_64	_LLCONST_(0x0000100000000000)	/* 2^^44 */
+#define K0SIZE		_LLCONST_(0x0000100000000000)	/* 2^^44 */
+#define K1SIZE		_LLCONST_(0x0000100000000000)	/* 2^^44 */
+#define K2SIZE		_LLCONST_(0x0000ffff80000000)
+#define KSEGSIZE	_LLCONST_(0x0000ffff80000000)	/* max syssegsz */
+#define TO_PHYS_MASK	_LLCONST_(0x00000fffffffffff)	/* 2^^44 - 1 */
 #endif
 
 /*
  * Further names for SGI source compatibility.  These are stolen from
  * IRIX's <sys/mips_addrspace.h>.
  */
-#define KUBASE			0
-#define KUSIZE_32		0x0000000080000000	/* KUSIZE
+#define KUBASE		_LLCONST_(0)
+#define KUSIZE_32	_LLCONST_(0x0000000080000000)	/* KUSIZE
 							   for a 32 bit proc */
-#define K0BASE_EXL_WR		0xa800000000000000	/* exclusive on write */
-#define K0BASE_NONCOH		0x9800000000000000	/* noncoherent */
-#define K0BASE_EXL		0xa000000000000000	/* exclusive */
+#define K0BASE_EXL_WR	_LLCONST_(0xa800000000000000)	/* exclusive on write */
+#define K0BASE_NONCOH	_LLCONST_(0x9800000000000000)	/* noncoherent */
+#define K0BASE_EXL	_LLCONST_(0xa000000000000000)	/* exclusive */
 
 #ifndef CONFIG_CPU_R8000
 
@@ -176,7 +190,7 @@
  * in order to catch bugs in the source code.
  */
 
-#define COMPAT_K1BASE32		0xffffffffa0000000
+#define COMPAT_K1BASE32		_LLCONST_(0xffffffffa0000000)
 #define PHYS_TO_COMPATK1(x)	((x) | COMPAT_K1BASE32) /* 32-bit compat k1 */
 
 #endif
diff -Naur linux-2.6.14/include/asm-mips/asm.h linux-mips-2.6.14.orig/include/asm-mips/asm.h
--- linux-2.6.14/include/asm-mips/asm.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/asm.h	2005-11-17 11:44:26.000000000 -0800
@@ -107,6 +107,7 @@
 /*
  * Print formatted string
  */
+#ifdef CONFIG_PRINTK
 #define PRINT(string)                                   \
 		.set	push;				\
 		.set	reorder;                        \
@@ -114,6 +115,9 @@
 		jal	printk;                         \
 		.set	pop;				\
 		TEXT(string)
+#else
+#define PRINT(string)
+#endif
 
 #define	TEXT(msg)                                       \
 		.pushsection .data;			\
diff -Naur linux-2.6.14/include/asm-mips/atomic.h linux-mips-2.6.14.orig/include/asm-mips/atomic.h
--- linux-2.6.14/include/asm-mips/atomic.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/atomic.h	2005-11-17 11:44:26.000000000 -0800
@@ -62,20 +62,24 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%0, %1		# atomic_add		\n"
 		"	addu	%0, %2					\n"
 		"	sc	%0, %1					\n"
 		"	beqzl	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%0, %1		# atomic_add		\n"
 		"	addu	%0, %2					\n"
 		"	sc	%0, %1					\n"
 		"	beqz	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
@@ -100,20 +104,24 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%0, %1		# atomic_sub		\n"
 		"	subu	%0, %2					\n"
 		"	sc	%0, %1					\n"
 		"	beqzl	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%0, %1		# atomic_sub		\n"
 		"	subu	%0, %2					\n"
 		"	sc	%0, %1					\n"
 		"	beqz	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
@@ -136,12 +144,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -149,12 +159,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -179,12 +191,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -192,12 +206,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -229,6 +245,7 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_sub_if_positive\n"
 		"	subu	%0, %1, %3				\n"
 		"	bltz	%0, 1f					\n"
@@ -236,6 +253,7 @@
 		"	beqzl	%0, 1b					\n"
 		"	sync						\n"
 		"1:							\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -243,6 +261,7 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_sub_if_positive\n"
 		"	subu	%0, %1, %3				\n"
 		"	bltz	%0, 1f					\n"
@@ -250,6 +269,7 @@
 		"	beqz	%0, 1b					\n"
 		"	sync						\n"
 		"1:							\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -367,20 +387,24 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%0, %1		# atomic64_add		\n"
 		"	addu	%0, %2					\n"
 		"	scd	%0, %1					\n"
 		"	beqzl	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%0, %1		# atomic64_add		\n"
 		"	addu	%0, %2					\n"
 		"	scd	%0, %1					\n"
 		"	beqz	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
@@ -405,20 +429,24 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%0, %1		# atomic64_sub		\n"
 		"	subu	%0, %2					\n"
 		"	scd	%0, %1					\n"
 		"	beqzl	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%0, %1		# atomic64_sub		\n"
 		"	subu	%0, %2					\n"
 		"	scd	%0, %1					\n"
 		"	beqz	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
@@ -441,12 +469,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -454,12 +484,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -484,12 +516,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -497,12 +531,14 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
 		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
 		"	sync						\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -534,6 +570,7 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_sub_if_positive\n"
 		"	dsubu	%0, %1, %3				\n"
 		"	bltz	%0, 1f					\n"
@@ -541,6 +578,7 @@
 		"	beqzl	%0, 1b					\n"
 		"	sync						\n"
 		"1:							\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
@@ -548,6 +586,7 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_sub_if_positive\n"
 		"	dsubu	%0, %1, %3				\n"
 		"	bltz	%0, 1f					\n"
@@ -555,6 +594,7 @@
 		"	beqz	%0, 1b					\n"
 		"	sync						\n"
 		"1:							\n"
+		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
diff -Naur linux-2.6.14/include/asm-mips/bitops.h linux-mips-2.6.14.orig/include/asm-mips/bitops.h
--- linux-2.6.14/include/asm-mips/bitops.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/bitops.h	2005-11-17 11:44:26.000000000 -0800
@@ -12,20 +12,21 @@
 #include <linux/config.h>
 #include <linux/compiler.h>
 #include <linux/types.h>
+#include <asm/bug.h>
 #include <asm/byteorder.h>		/* sigh ... */
 #include <asm/cpu-features.h>
 
 #if (_MIPS_SZLONG == 32)
 #define SZLONG_LOG 5
 #define SZLONG_MASK 31UL
-#define __LL	"ll	"
-#define __SC	"sc	"
+#define __LL		"ll	"
+#define __SC		"sc	"
 #define cpu_to_lelongp(x) cpu_to_le32p((__u32 *) (x))
 #elif (_MIPS_SZLONG == 64)
 #define SZLONG_LOG 6
 #define SZLONG_MASK 63UL
-#define __LL	"lld	"
-#define __SC	"scd	"
+#define __LL		"lld	"
+#define __SC		"scd	"
 #define cpu_to_lelongp(x) cpu_to_le64p((__u64 *) (x))
 #endif
 
@@ -72,18 +73,22 @@
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	" __LL "%0, %1			# set_bit	\n"
 		"	or	%0, %2					\n"
-		"	"__SC	"%0, %1					\n"
+		"	" __SC	"%0, %1					\n"
 		"	beqzl	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (1UL << (nr & SZLONG_MASK)), "m" (*m));
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	" __LL "%0, %1			# set_bit	\n"
 		"	or	%0, %2					\n"
-		"	"__SC	"%0, %1					\n"
+		"	" __SC	"%0, %1					\n"
 		"	beqz	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (1UL << (nr & SZLONG_MASK)), "m" (*m));
 	} else {
@@ -132,18 +137,22 @@
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	" __LL "%0, %1			# clear_bit	\n"
 		"	and	%0, %2					\n"
 		"	" __SC "%0, %1					\n"
 		"	beqzl	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (~(1UL << (nr & SZLONG_MASK))), "m" (*m));
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	" __LL "%0, %1			# clear_bit	\n"
 		"	and	%0, %2					\n"
 		"	" __SC "%0, %1					\n"
 		"	beqz	%0, 1b					\n"
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (~(1UL << (nr & SZLONG_MASK))), "m" (*m));
 	} else {
@@ -191,10 +200,12 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3				\n"
 		"1:	" __LL "%0, %1		# change_bit	\n"
 		"	xor	%0, %2				\n"
-		"	"__SC	"%0, %1				\n"
+		"	" __SC	"%0, %1				\n"
 		"	beqzl	%0, 1b				\n"
+		"	.set	mips0				\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (1UL << (nr & SZLONG_MASK)), "m" (*m));
 	} else if (cpu_has_llsc) {
@@ -202,10 +213,12 @@
 		unsigned long temp;
 
 		__asm__ __volatile__(
+		"	.set	mips3				\n"
 		"1:	" __LL "%0, %1		# change_bit	\n"
 		"	xor	%0, %2				\n"
-		"	"__SC	"%0, %1				\n"
+		"	" __SC	"%0, %1				\n"
 		"	beqz	%0, 1b				\n"
+		"	.set	mips0				\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (1UL << (nr & SZLONG_MASK)), "m" (*m));
 	} else {
@@ -253,14 +266,16 @@
 		unsigned long temp, res;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	" __LL "%0, %1		# test_and_set_bit	\n"
 		"	or	%2, %0, %3				\n"
 		"	" __SC	"%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
 		"	and	%2, %0, %3				\n"
 #ifdef CONFIG_SMP
-		"sync							\n"
+		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << (nr & SZLONG_MASK)), "m" (*m)
 		: "memory");
@@ -271,16 +286,18 @@
 		unsigned long temp, res;
 
 		__asm__ __volatile__(
-		"	.set	noreorder	# test_and_set_bit	\n"
-		"1:	" __LL "%0, %1					\n"
+		"	.set	push					\n"
+		"	.set	noreorder				\n"
+		"	.set	mips3					\n"
+		"1:	" __LL "%0, %1		# test_and_set_bit	\n"
 		"	or	%2, %0, %3				\n"
 		"	" __SC	"%2, %1					\n"
 		"	beqz	%2, 1b					\n"
 		"	 and	%2, %0, %3				\n"
 #ifdef CONFIG_SMP
-		"sync							\n"
+		"	sync						\n"
 #endif
-		".set\treorder"
+		"	.set	pop					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << (nr & SZLONG_MASK)), "m" (*m)
 		: "memory");
@@ -343,15 +360,17 @@
 		unsigned long temp, res;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	" __LL	"%0, %1		# test_and_clear_bit	\n"
 		"	or	%2, %0, %3				\n"
 		"	xor	%2, %3					\n"
-			__SC 	"%2, %1					\n"
+		"	" __SC 	"%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
 		"	and	%2, %0, %3				\n"
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << (nr & SZLONG_MASK)), "m" (*m)
 		: "memory");
@@ -362,17 +381,19 @@
 		unsigned long temp, res;
 
 		__asm__ __volatile__(
-		"	.set	noreorder	# test_and_clear_bit	\n"
-		"1:	" __LL	"%0, %1					\n"
+		"	.set	push					\n"
+		"	.set	noreorder				\n"
+		"	.set	mips3					\n"
+		"1:	" __LL	"%0, %1		# test_and_clear_bit	\n"
 		"	or	%2, %0, %3				\n"
 		"	xor	%2, %3					\n"
-			__SC 	"%2, %1					\n"
+		"	" __SC 	"%2, %1					\n"
 		"	beqz	%2, 1b					\n"
 		"	 and	%2, %0, %3				\n"
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
-		"	.set	reorder					\n"
+		"	.set	pop					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << (nr & SZLONG_MASK)), "m" (*m)
 		: "memory");
@@ -435,14 +456,16 @@
 		unsigned long temp, res;
 
 		__asm__ __volatile__(
-		"1:	" __LL	" %0, %1	# test_and_change_bit	\n"
+		"	.set	mips3					\n"
+		"1:	" __LL	"%0, %1		# test_and_change_bit	\n"
 		"	xor	%2, %0, %3				\n"
-		"	"__SC	"%2, %1					\n"
+		"	" __SC	"%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
 		"	and	%2, %0, %3				\n"
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << (nr & SZLONG_MASK)), "m" (*m)
 		: "memory");
@@ -453,16 +476,18 @@
 		unsigned long temp, res;
 
 		__asm__ __volatile__(
-		"	.set	noreorder	# test_and_change_bit	\n"
-		"1:	" __LL	" %0, %1				\n"
+		"	.set	push					\n"
+		"	.set	noreorder				\n"
+		"	.set	mips3					\n"
+		"1:	" __LL	"%0, %1		# test_and_change_bit	\n"
 		"	xor	%2, %0, %3				\n"
-		"	"__SC	"\t%2, %1				\n"
+		"	" __SC	"\t%2, %1				\n"
 		"	beqz	%2, 1b					\n"
 		"	 and	%2, %0, %3				\n"
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
-		"	.set	reorder					\n"
+		"	.set	pop					\n"
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << (nr & SZLONG_MASK)), "m" (*m)
 		: "memory");
@@ -523,22 +548,60 @@
 }
 
 /*
- * ffz - find first zero in word.
+ * Return the bit position (0..63) of the most significant 1 bit in a word
+ * Returns -1 if no 1 bit exists
+ */
+static inline int __ilog2(unsigned long x)
+{
+	int lz;
+
+	if (sizeof(x) == 4) {
+		__asm__ (
+		"	.set	push					\n"
+		"	.set	mips32					\n"
+		"	clz	%0, %1					\n"
+		"	.set	pop					\n"
+		: "=r" (lz)
+		: "r" (x));
+
+		return 31 - lz;
+	}
+
+	BUG_ON(sizeof(x) != 8);
+
+	__asm__ (
+	"	.set	push						\n"
+	"	.set	mips64						\n"
+	"	dclz	%0, %1						\n"
+	"	.set	pop						\n"
+	: "=r" (lz)
+	: "r" (x));
+
+	return 63 - lz;
+}
+
+/*
+ * __ffs - find first bit in word.
  * @word: The word to search
  *
- * Undefined if no zero exists, so code should check against ~0UL first.
+ * Returns 0..SZLONG-1
+ * Undefined if no bit exists, so code should check against 0 first.
  */
-static inline unsigned long ffz(unsigned long word)
+static inline unsigned long __ffs(unsigned long word)
 {
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
+	return __ilog2(word & -word);
+#else
 	int b = 0, s;
 
-	word = ~word;
 #ifdef CONFIG_32BIT
 	s = 16; if (word << 16 != 0) s = 0; b += s; word >>= s;
 	s =  8; if (word << 24 != 0) s = 0; b += s; word >>= s;
 	s =  4; if (word << 28 != 0) s = 0; b += s; word >>= s;
 	s =  2; if (word << 30 != 0) s = 0; b += s; word >>= s;
 	s =  1; if (word << 31 != 0) s = 0; b += s;
+
+	return b;
 #endif
 #ifdef CONFIG_64BIT
 	s = 32; if (word << 32 != 0) s = 0; b += s; word >>= s;
@@ -547,27 +610,92 @@
 	s =  4; if (word << 60 != 0) s = 0; b += s; word >>= s;
 	s =  2; if (word << 62 != 0) s = 0; b += s; word >>= s;
 	s =  1; if (word << 63 != 0) s = 0; b += s;
-#endif
 
 	return b;
+#endif
+#endif
 }
 
 /*
- * __ffs - find first bit in word.
+ * ffs - find first bit set.
  * @word: The word to search
  *
- * Undefined if no bit exists, so code should check against 0 first.
+ * Returns 1..SZLONG
+ * Returns 0 if no bit exists
  */
-static inline unsigned long __ffs(unsigned long word)
+
+static inline unsigned long ffs(unsigned long word)
+{
+	if (!word)
+		return 0;
+
+	return __ffs(word) + 1;
+}
+
+/*
+ * ffz - find first zero in word.
+ * @word: The word to search
+ *
+ * Undefined if no zero exists, so code should check against ~0UL first.
+ */
+static inline unsigned long ffz(unsigned long word)
+{
+	return __ffs (~word);
+}
+
+/*
+ * flz - find last zero in word.
+ * @word: The word to search
+ *
+ * Returns 0..SZLONG-1
+ * Undefined if no zero exists, so code should check against ~0UL first.
+ */
+static inline unsigned long flz(unsigned long word)
 {
-	return ffz(~word);
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
+	return __ilog2(~word);
+#else
+#ifdef CONFIG_32BIT
+	int r = 31, s;
+	word = ~word;
+	s = 16; if ((word & 0xffff0000)) s = 0; r -= s; word <<= s;
+	s = 8;  if ((word & 0xff000000)) s = 0; r -= s; word <<= s;
+	s = 4;  if ((word & 0xf0000000)) s = 0; r -= s; word <<= s;
+	s = 2;  if ((word & 0xc0000000)) s = 0; r -= s; word <<= s;
+	s = 1;  if ((word & 0x80000000)) s = 0; r -= s;
+
+	return r;
+#endif
+#ifdef CONFIG_64BIT
+	int r = 63, s;
+	word = ~word;
+	s = 32; if ((word & 0xffffffff00000000UL)) s = 0; r -= s; word <<= s;
+	s = 16; if ((word & 0xffff000000000000UL)) s = 0; r -= s; word <<= s;
+	s = 8;  if ((word & 0xff00000000000000UL)) s = 0; r -= s; word <<= s;
+	s = 4;  if ((word & 0xf000000000000000UL)) s = 0; r -= s; word <<= s;
+	s = 2;  if ((word & 0xc000000000000000UL)) s = 0; r -= s; word <<= s;
+	s = 1;  if ((word & 0x8000000000000000UL)) s = 0; r -= s;
+
+	return r;
+#endif
+#endif
 }
 
 /*
- * fls: find last bit set.
+ * fls - find last bit set.
+ * @word: The word to search
+ *
+ * Returns 1..SZLONG
+ * Returns 0 if no bit exists
  */
+static inline unsigned long fls(unsigned long word)
+{
+	if (word == 0)
+		return 0;
+
+	return flz(~word) + 1;
+}
 
-#define fls(x) generic_fls(x)
 
 /*
  * find_next_zero_bit - find the first zero bit in a memory region
@@ -704,17 +832,6 @@
 }
 
 /*
- * ffs - find first bit set
- * @x: the word to search
- *
- * This is defined the same way as
- * the libc and compiler builtin ffs routines, therefore
- * differs in spirit from the above ffz (man ffs).
- */
-
-#define ffs(x) generic_ffs(x)
-
-/*
  * hweightN - returns the hamming weight of a N-bit word
  * @x: the word to weigh
  *
diff -Naur linux-2.6.14/include/asm-mips/bootinfo.h linux-mips-2.6.14.orig/include/asm-mips/bootinfo.h
--- linux-2.6.14/include/asm-mips/bootinfo.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/bootinfo.h	2005-11-17 11:44:26.000000000 -0800
@@ -77,6 +77,7 @@
 #define  MACH_SGI_IP27		1	/* Origin 200, Origin 2000, Onyx 2 */
 #define  MACH_SGI_IP28		2	/* Indigo2 Impact		*/
 #define  MACH_SGI_IP32		3	/* O2				*/
+#define  MACH_SGI_IP30		4	/* Octane, Octane2              */
 
 /*
  * Valid machtype for group COBALT
@@ -136,6 +137,7 @@
 #define MACH_GROUP_PHILIPS     14
 #define  MACH_PHILIPS_NINO	0	/* Nino */
 #define  MACH_PHILIPS_VELO	1	/* Velo */
+#define  MACH_PHILIPS_JBS	2	/* JBS */
 
 /*
  * Valid machtype for group Globespan
@@ -159,6 +161,7 @@
 #define  MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
 #define  MACH_TOSHIBA_RBTX4927	4
 #define  MACH_TOSHIBA_RBTX4937	5
+#define  MACH_TOSHIBA_RBTX4938	6
 
 #define GROUP_TOSHIBA_NAMES	{ "Pallas", "TopasCE", "JMR", "JMR TX3927", \
 				  "RBTX4927", "RBTX4937" }
@@ -177,6 +180,8 @@
 #define  MACH_MTX1		7       /* 4G MTX-1 Au1500-based board */
 #define  MACH_PB1550		8       /* Au1550-based eval board */
 #define  MACH_DB1550		9       /* Au1550-based eval board */
+#define  MACH_PB1200		10       /* Au1200-based eval board */
+#define  MACH_DB1200		11       /* Au1200-based eval board */
 
 /*
  * Valid machtype for group NEC_VR41XX
diff -Naur linux-2.6.14/include/asm-mips/break.h linux-mips-2.6.14.orig/include/asm-mips/break.h
--- linux-2.6.14/include/asm-mips/break.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/break.h	2005-11-17 11:44:26.000000000 -0800
@@ -28,6 +28,7 @@
 #define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
 #define _BRK_THREADBP	11	/* For threads, user bp (used by debuggers) */
 #define BRK_BUG		512	/* Used by BUG() */
+#define BRK_KDB		513	/* Used in KDB_ENTER() */
 #define BRK_MULOVF	1023	/* Multiply overflow */
 
 #endif /* __ASM_BREAK_H */
diff -Naur linux-2.6.14/include/asm-mips/bug.h linux-mips-2.6.14.orig/include/asm-mips/bug.h
--- linux-2.6.14/include/asm-mips/bug.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/bug.h	2005-11-17 11:44:26.000000000 -0800
@@ -1,16 +1,21 @@
 #ifndef __ASM_BUG_H
 #define __ASM_BUG_H
 
-#include <asm/break.h>
+#include <linux/config.h>
 
 #ifdef CONFIG_BUG
-#define HAVE_ARCH_BUG
+
+#include <asm/break.h>
+
 #define BUG()								\
 do {									\
 	__asm__ __volatile__("break %0" : : "i" (BRK_BUG));		\
 } while (0)
+
+#define HAVE_ARCH_BUG
+
 #endif
 
 #include <asm-generic/bug.h>
 
-#endif
+#endif /* __ASM_BUG_H */
diff -Naur linux-2.6.14/include/asm-mips/bugs.h linux-mips-2.6.14.orig/include/asm-mips/bugs.h
--- linux-2.6.14/include/asm-mips/bugs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/bugs.h	2005-11-17 11:44:26.000000000 -0800
@@ -8,12 +8,18 @@
 #define _ASM_BUGS_H
 
 #include <linux/config.h>
+#include <linux/delay.h>
+#include <asm/cpu.h>
+#include <asm/cpu-info.h>
 
 extern void check_bugs32(void);
 extern void check_bugs64(void);
 
 static inline void check_bugs(void)
 {
+	unsigned int cpu = smp_processor_id();
+
+	cpu_data[cpu].udelay_val = loops_per_jiffy;
 	check_bugs32();
 #ifdef CONFIG_64BIT
 	check_bugs64();
diff -Naur linux-2.6.14/include/asm-mips/cacheflush.h linux-mips-2.6.14.orig/include/asm-mips/cacheflush.h
--- linux-2.6.14/include/asm-mips/cacheflush.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/cacheflush.h	2005-11-17 11:44:27.000000000 -0800
@@ -49,17 +49,29 @@
 
 extern void (*flush_icache_page)(struct vm_area_struct *vma,
 	struct page *page);
-extern void (*flush_icache_range)(unsigned long start, unsigned long end);
+extern void (*flush_icache_range)(unsigned long __user start,
+	unsigned long __user end);
 #define flush_cache_vmap(start, end)		flush_cache_all()
 #define flush_cache_vunmap(start, end)		flush_cache_all()
 
-#define copy_to_user_page(vma, page, vaddr, dst, src, len)		\
-do {									\
-	memcpy(dst, (void *) src, len);					\
-	flush_icache_page(vma, page);					\
-} while (0)
-#define copy_from_user_page(vma, page, vaddr, dst, src, len)		\
-	memcpy(dst, src, len)
+static inline void copy_to_user_page(struct vm_area_struct *vma,
+	struct page *page, unsigned long vaddr, void *dst, const void *src,
+	unsigned long len)
+{
+	if (cpu_has_dc_aliases)
+		flush_cache_page(vma, vaddr, page_to_pfn(page));
+	memcpy(dst, src, len);
+	flush_icache_page(vma, page);
+}
+
+static inline void copy_from_user_page(struct vm_area_struct *vma,
+	struct page *page, unsigned long vaddr, void *dst, const void *src,
+	unsigned long len)
+{
+	if (cpu_has_dc_aliases)
+		flush_cache_page(vma, vaddr, page_to_pfn(page));
+	memcpy(dst, src, len);
+}
 
 extern void (*flush_cache_sigtramp)(unsigned long addr);
 extern void (*flush_icache_all)(void);
@@ -78,4 +90,7 @@
 #define ClearPageDcacheDirty(page)	\
 	clear_bit(PG_dcache_dirty, &(page)->flags)
 
+/* Run kernel code uncached, useful for cache probing functions. */
+unsigned long __init run_uncached(void *func);
+
 #endif /* _ASM_CACHEFLUSH_H */
diff -Naur linux-2.6.14/include/asm-mips/cache.h linux-mips-2.6.14.orig/include/asm-mips/cache.h
--- linux-2.6.14/include/asm-mips/cache.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/cache.h	2005-11-17 11:44:26.000000000 -0800
@@ -10,6 +10,7 @@
 #define _ASM_CACHE_H
 
 #include <linux/config.h>
+#include <kmalloc.h>
 
 #define L1_CACHE_SHIFT		CONFIG_MIPS_L1_CACHE_SHIFT
 #define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
@@ -18,6 +19,4 @@
 #define SMP_CACHE_SHIFT		L1_CACHE_SHIFT
 #define SMP_CACHE_BYTES		L1_CACHE_BYTES
 
-#define ARCH_KMALLOC_MINALIGN	8
-
 #endif /* _ASM_CACHE_H */
diff -Naur linux-2.6.14/include/asm-mips/checksum.h linux-mips-2.6.14.orig/include/asm-mips/checksum.h
--- linux-2.6.14/include/asm-mips/checksum.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/checksum.h	2005-11-17 11:44:27.000000000 -0800
@@ -34,8 +34,9 @@
  * this is a new version of the above that records errors it finds in *errp,
  * but continues and zeros the rest of the buffer.
  */
-unsigned int csum_partial_copy_from_user(const unsigned char *src, unsigned char *dst, int len,
-                                         unsigned int sum, int *errp);
+unsigned int csum_partial_copy_from_user(const unsigned char __user *src,
+					 unsigned char *dst, int len,
+					 unsigned int sum, int *errp);
 
 /*
  * Copy and checksum to user
@@ -70,14 +71,15 @@
 static inline unsigned short int csum_fold(unsigned int sum)
 {
 	__asm__(
-	".set\tnoat\t\t\t# csum_fold\n\t"
-	"sll\t$1,%0,16\n\t"
-	"addu\t%0,$1\n\t"
-	"sltu\t$1,%0,$1\n\t"
-	"srl\t%0,%0,16\n\t"
-	"addu\t%0,$1\n\t"
-	"xori\t%0,0xffff\n\t"
-	".set\tat"
+	"	.set	push		# csum_fold\n"
+	"	.set	noat		\n"
+	"	sll	$1, %0, 16	\n"
+	"	addu	%0, $1		\n"
+	"	sltu	$1, %0, $1	\n"
+	"	srl	%0, %0, 16	\n"
+	"	addu	%0, $1		\n"
+	"	xori	%0, 0xffff	\n"
+	"	.set	pop"
 	: "=r" (sum)
 	: "0" (sum));
 
@@ -127,29 +129,30 @@
 	unsigned int sum)
 {
 	__asm__(
-	".set\tnoat\t\t\t# csum_tcpudp_nofold\n\t"
+	"	.set	push		# csum_tcpudp_nofold\n"
+	"	.set	noat		\n"
 #ifdef CONFIG_32BIT
-	"addu\t%0, %2\n\t"
-	"sltu\t$1, %0, %2\n\t"
-	"addu\t%0, $1\n\t"
-
-	"addu\t%0, %3\n\t"
-	"sltu\t$1, %0, %3\n\t"
-	"addu\t%0, $1\n\t"
-
-	"addu\t%0, %4\n\t"
-	"sltu\t$1, %0, %4\n\t"
-	"addu\t%0, $1\n\t"
+	"	addu	%0, %2		\n"
+	"	sltu	$1, %0, %2	\n"
+	"	addu	%0, $1		\n"
+
+	"	addu	%0, %3		\n"
+	"	sltu	$1, %0, %3	\n"
+	"	addu	%0, $1		\n"
+
+	"	addu	%0, %4		\n"
+	"	sltu	$1, %0, %4	\n"
+	"	addu	%0, $1		\n"
 #endif
 #ifdef CONFIG_64BIT
-	"daddu\t%0, %2\n\t"
-	"daddu\t%0, %3\n\t"
-	"daddu\t%0, %4\n\t"
-	"dsll32\t$1, %0, 0\n\t"
-	"daddu\t%0, $1\n\t"
-	"dsrl32\t%0, %0, 0\n\t"
+	"	daddu	%0, %2		\n"
+	"	daddu	%0, %3		\n"
+	"	daddu	%0, %4		\n"
+	"	dsll32	$1, %0, 0	\n"
+	"	daddu	%0, $1		\n"
+	"	dsra32	%0, %0, 0	\n"
 #endif
-	".set\tat"
+	"	.set	pop"
 	: "=r" (sum)
 	: "0" (daddr), "r"(saddr),
 #ifdef __MIPSEL__
@@ -192,57 +195,57 @@
 						     unsigned int sum)
 {
 	__asm__(
-	".set\tpush\t\t\t# csum_ipv6_magic\n\t"
-	".set\tnoreorder\n\t"
-	".set\tnoat\n\t"
-	"addu\t%0, %5\t\t\t# proto (long in network byte order)\n\t"
-	"sltu\t$1, %0, %5\n\t"
-	"addu\t%0, $1\n\t"
-
-	"addu\t%0, %6\t\t\t# csum\n\t"
-	"sltu\t$1, %0, %6\n\t"
-	"lw\t%1, 0(%2)\t\t\t# four words source address\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 4(%2)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 8(%2)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 12(%2)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 0(%3)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 4(%3)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 8(%3)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
-
-	"lw\t%1, 12(%3)\n\t"
-	"addu\t%0, $1\n\t"
-	"addu\t%0, %1\n\t"
-	"sltu\t$1, %0, %1\n\t"
+	"	.set	push		# csum_ipv6_magic\n"
+	"	.set	noreorder	\n"
+	"	.set	noat		\n"
+	"	addu	%0, %5		# proto (long in network byte order)\n"
+	"	sltu	$1, %0, %5	\n"
+	"	addu	%0, $1		\n"
+
+	"	addu	%0, %6		# csum\n"
+	"	sltu	$1, %0, %6	\n"
+	"	lw	%1, 0(%2)	# four words source address\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 4(%2)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 8(%2)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 12(%2)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 0(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 4(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 8(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
+
+	"	lw	%1, 12(%3)	\n"
+	"	addu	%0, $1		\n"
+	"	addu	%0, %1		\n"
+	"	sltu	$1, %0, %1	\n"
 
-	"addu\t%0, $1\t\t\t# Add final carry\n\t"
-	".set\tpop"
+	"	addu	%0, $1		# Add final carry\n"
+	"	.set	pop"
 	: "=r" (sum), "=r" (proto)
 	: "r" (saddr), "r" (daddr),
 	  "0" (htonl(len)), "1" (htonl(proto)), "r" (sum));
diff -Naur linux-2.6.14/include/asm-mips/cobalt/cobalt.h linux-mips-2.6.14.orig/include/asm-mips/cobalt/cobalt.h
--- linux-2.6.14/include/asm-mips/cobalt/cobalt.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/cobalt/cobalt.h	2005-11-17 11:44:27.000000000 -0800
@@ -19,18 +19,23 @@
  *     9  - PCI
  *    14  - IDE0
  *    15  - IDE1
- *
+ */
+#define COBALT_QUBE_SLOT_IRQ	9
+
+/*
  * CPU IRQs  are 16 ... 23
  */
-#define COBALT_TIMER_IRQ	18
-#define COBALT_SCC_IRQ          19		/* pre-production has 85C30 */
-#define COBALT_RAQ_SCSI_IRQ	19
-#define COBALT_ETH0_IRQ		19
-#define COBALT_ETH1_IRQ		20
-#define COBALT_SERIAL_IRQ	21
-#define COBALT_SCSI_IRQ         21
-#define COBALT_VIA_IRQ		22		/* Chained to VIA ISA bridge */
-#define COBALT_QUBE_SLOT_IRQ	23
+#define COBALT_CPU_IRQ		16
+
+#define COBALT_GALILEO_IRQ	(COBALT_CPU_IRQ + 2)
+#define COBALT_SCC_IRQ          (COBALT_CPU_IRQ + 3)	/* pre-production has 85C30 */
+#define COBALT_RAQ_SCSI_IRQ	(COBALT_CPU_IRQ + 3)
+#define COBALT_ETH0_IRQ		(COBALT_CPU_IRQ + 3)
+#define COBALT_QUBE1_ETH0_IRQ	(COBALT_CPU_IRQ + 4)
+#define COBALT_ETH1_IRQ		(COBALT_CPU_IRQ + 4)
+#define COBALT_SERIAL_IRQ	(COBALT_CPU_IRQ + 5)
+#define COBALT_SCSI_IRQ         (COBALT_CPU_IRQ + 5)
+#define COBALT_VIA_IRQ		(COBALT_CPU_IRQ + 6)	/* Chained to VIA ISA bridge */
 
 /*
  * PCI configuration space manifest constants.  These are wired into
@@ -69,16 +74,21 @@
  * Most of this really should go into a separate GT64111 header file.
  */
 #define GT64111_IO_BASE		0x10000000UL
+#define GT64111_IO_END		0x11ffffffUL
+#define GT64111_MEM_BASE	0x12000000UL
+#define GT64111_MEM_END		0x13ffffffUL
 #define GT64111_BASE		0x14000000UL
-#define GALILEO_REG(ofs)	(KSEG0 + GT64111_BASE + (unsigned long)(ofs))
+#define GALILEO_REG(ofs)	CKSEG1ADDR(GT64111_BASE + (unsigned long)(ofs))
 
 #define GALILEO_INL(port)	(*(volatile unsigned int *) GALILEO_REG(port))
 #define GALILEO_OUTL(val, port)						\
 do {									\
-	*(volatile unsigned int *) GALILEO_REG(port) = (port);		\
+	*(volatile unsigned int *) GALILEO_REG(port) = (val);		\
 } while (0)
 
-#define GALILEO_T0EXP		0x0100
+#define GALILEO_INTR_T0EXP	(1 << 8)
+#define GALILEO_INTR_RETRY_CTR	(1 << 20)
+
 #define GALILEO_ENTC0		0x01
 #define GALILEO_SELTC0		0x02
 
@@ -86,5 +96,21 @@
 	GALILEO_OUTL((0x80000000 | (PCI_SLOT (devfn) << 11) |		\
 		(PCI_FUNC (devfn) << 8) | (where)), GT_PCI0_CFGADDR_OFS)
 
+#define COBALT_LED_PORT		(*(volatile unsigned char *) CKSEG1ADDR(0x1c000000))
+# define COBALT_LED_BAR_LEFT	(1 << 0)	/* Qube */
+# define COBALT_LED_BAR_RIGHT	(1 << 1)	/* Qube */
+# define COBALT_LED_WEB		(1 << 2)	/* RaQ */
+# define COBALT_LED_POWER_OFF	(1 << 3)	/* RaQ */
+# define COBALT_LED_RESET	0x0f
+
+#define COBALT_KEY_PORT		((~*(volatile unsigned int *) CKSEG1ADDR(0x1d000000) >> 24) & COBALT_KEY_MASK)
+# define COBALT_KEY_CLEAR	(1 << 1)
+# define COBALT_KEY_LEFT	(1 << 2)
+# define COBALT_KEY_UP		(1 << 3)
+# define COBALT_KEY_DOWN	(1 << 4)
+# define COBALT_KEY_RIGHT	(1 << 5)
+# define COBALT_KEY_ENTER	(1 << 6)
+# define COBALT_KEY_SELECT	(1 << 7)
+# define COBALT_KEY_MASK	0xfe
 
 #endif /* __ASM_COBALT_H */
diff -Naur linux-2.6.14/include/asm-mips/cobalt/mach-gt64120.h linux-mips-2.6.14.orig/include/asm-mips/cobalt/mach-gt64120.h
--- linux-2.6.14/include/asm-mips/cobalt/mach-gt64120.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/cobalt/mach-gt64120.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1 @@
+/* there's something here ... in the dark */
diff -Naur linux-2.6.14/include/asm-mips/compat.h linux-mips-2.6.14.orig/include/asm-mips/compat.h
--- linux-2.6.14/include/asm-mips/compat.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/compat.h	2005-11-17 11:44:27.000000000 -0800
@@ -15,10 +15,10 @@
 typedef s32		compat_suseconds_t;
 
 typedef s32		compat_pid_t;
-typedef u32		__compat_uid_t;
-typedef u32		__compat_gid_t;
-typedef u32		__compat_uid32_t;
-typedef u32		__compat_gid32_t;
+typedef s32		__compat_uid_t;
+typedef s32		__compat_gid_t;
+typedef __compat_uid_t	__compat_uid32_t;
+typedef __compat_gid_t	__compat_gid32_t;
 typedef u32		compat_mode_t;
 typedef u32		compat_ino_t;
 typedef u32		compat_dev_t;
@@ -54,8 +54,8 @@
 	compat_ino_t	st_ino;
 	compat_mode_t	st_mode;
 	compat_nlink_t	st_nlink;
-	__compat_uid32_t	st_uid;
-	__compat_gid32_t	st_gid;
+	__compat_uid_t	st_uid;
+	__compat_gid_t	st_gid;
 	compat_dev_t	st_rdev;
 	s32		st_pad2[2];
 	compat_off_t	st_size;
diff -Naur linux-2.6.14/include/asm-mips/cpu-features.h linux-mips-2.6.14.orig/include/asm-mips/cpu-features.h
--- linux-2.6.14/include/asm-mips/cpu-features.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/cpu-features.h	2005-11-17 11:44:27.000000000 -0800
@@ -4,6 +4,7 @@
  * for more details.
  *
  * Copyright (C) 2003, 2004 Ralf Baechle
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef __ASM_CPU_FEATURES_H
 #define __ASM_CPU_FEATURES_H
@@ -24,8 +25,19 @@
 #ifndef cpu_has_4kex
 #define cpu_has_4kex		(cpu_data[0].options & MIPS_CPU_4KEX)
 #endif
-#ifndef cpu_has_4ktlb
-#define cpu_has_4ktlb		(cpu_data[0].options & MIPS_CPU_4KTLB)
+#ifndef cpu_has_3k_cache
+#define cpu_has_3k_cache	(cpu_data[0].options & MIPS_CPU_3K_CACHE)
+#endif
+#define cpu_has_6k_cache	0
+#define cpu_has_8k_cache	0
+#ifndef cpu_has_4k_cache
+#define cpu_has_4k_cache	(cpu_data[0].options & MIPS_CPU_4K_CACHE)
+#endif
+#ifndef cpu_has_tx39_cache
+#define cpu_has_tx39_cache	(cpu_data[0].options & MIPS_CPU_TX39_CACHE)
+#endif
+#ifndef cpu_has_sb1_cache
+#define cpu_has_sb1_cache	(cpu_data[0].options & MIPS_CPU_SB1_CACHE)
 #endif
 #ifndef cpu_has_fpu
 #define cpu_has_fpu		(cpu_data[0].options & MIPS_CPU_FPU)
@@ -39,9 +51,6 @@
 #ifndef cpu_has_watch
 #define cpu_has_watch		(cpu_data[0].options & MIPS_CPU_WATCH)
 #endif
-#ifndef cpu_has_mips16
-#define cpu_has_mips16		(cpu_data[0].options & MIPS_CPU_MIPS16)
-#endif
 #ifndef cpu_has_divec
 #define cpu_has_divec		(cpu_data[0].options & MIPS_CPU_DIVEC)
 #endif
@@ -66,6 +75,18 @@
 #ifndef cpu_has_llsc
 #define cpu_has_llsc		(cpu_data[0].options & MIPS_CPU_LLSC)
 #endif
+#ifndef cpu_has_mips16
+#define cpu_has_mips16		(cpu_data[0].ases & MIPS_ASE_MIPS16)
+#endif
+#ifndef cpu_has_mdmx
+#define cpu_has_mdmx           (cpu_data[0].ases & MIPS_ASE_MDMX)
+#endif
+#ifndef cpu_has_mips3d
+#define cpu_has_mips3d         (cpu_data[0].ases & MIPS_ASE_MIPS3D)
+#endif
+#ifndef cpu_has_smartmips
+#define cpu_has_smartmips      (cpu_data[0].ases & MIPS_ASE_SMARTMIPS)
+#endif
 #ifndef cpu_has_vtag_icache
 #define cpu_has_vtag_icache	(cpu_data[0].icache.flags & MIPS_CACHE_VTAG)
 #endif
@@ -95,15 +116,16 @@
 #endif
 #endif
 
-/*
- * Certain CPUs may throw bizarre exceptions if not the whole cacheline
- * contains valid instructions.  For these we ensure proper alignment of
- * signal trampolines and pad them to the size of a full cache lines with
- * nops.  This is also used in structure definitions so can't be a test macro
- * like the others.
- */
-#ifndef PLAT_TRAMPOLINE_STUFF_LINE
-#define PLAT_TRAMPOLINE_STUFF_LINE	0UL
+#ifndef cpu_has_dsp
+#define cpu_has_dsp		(cpu_data[0].ases & MIPS_ASE_DSP)
+#endif
+
+#ifdef CONFIG_MIPS_MT
+#ifndef cpu_has_mipsmt
+# define cpu_has_mipsmt		(cpu_data[0].ases & MIPS_ASE_MIPSMT)
+#endif
+#else
+# define cpu_has_mipsmt		0
 #endif
 
 #ifdef CONFIG_32BIT
@@ -142,6 +164,22 @@
 # endif
 #endif
 
+#ifdef CONFIG_CPU_MIPSR2
+# if defined(CONFIG_CPU_MIPSR2_IRQ_VI) && !defined(cpu_has_vint)
+#  define cpu_has_vint		(cpu_data[0].options & MIPS_CPU_VINT)
+# else
+#  define cpu_has_vint			0
+# endif
+# if defined(CONFIG_CPU_MIPSR2_IRQ_EI) && !defined(cpu_has_veic)
+#  define cpu_has_veic		(cpu_data[0].options & MIPS_CPU_VEIC)
+# else
+#  define cpu_has_veic			0
+# endif
+#else
+# define cpu_has_vint			0
+# define cpu_has_veic			0
+#endif
+
 #ifndef cpu_has_subset_pcaches
 #define cpu_has_subset_pcaches	(cpu_data[0].options & MIPS_CPU_SUBSET_CACHES)
 #endif
diff -Naur linux-2.6.14/include/asm-mips/cpu.h linux-mips-2.6.14.orig/include/asm-mips/cpu.h
--- linux-2.6.14/include/asm-mips/cpu.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/cpu.h	2005-11-17 11:44:27.000000000 -0800
@@ -3,6 +3,7 @@
  *        various MIPS cpu types.
  *
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef _ASM_CPU_H
 #define _ASM_CPU_H
@@ -22,12 +23,17 @@
    spec.
 */
 
-#define PRID_COMP_LEGACY       0x000000
-#define PRID_COMP_MIPS         0x010000
-#define PRID_COMP_BROADCOM     0x020000
-#define PRID_COMP_ALCHEMY      0x030000
-#define PRID_COMP_SIBYTE       0x040000
-#define PRID_COMP_SANDCRAFT    0x050000
+#define PRID_COMP_LEGACY	0x000000
+#define PRID_COMP_MIPS		0x010000
+#define PRID_COMP_BROADCOM	0x020000
+#define PRID_COMP_ALCHEMY	0x030000
+#define PRID_COMP_SIBYTE	0x040000
+#define PRID_COMP_SANDCRAFT	0x050000
+#define PRID_COMP_PHILIPS	0x060000
+#define PRID_COMP_TOSHIBA	0x070000
+#define PRID_COMP_LSI		0x080000
+#define PRID_COMP_LEXRA		0x0b0000
+
 
 /*
  * Assigned values for the product ID register.  In order to detect a
@@ -46,6 +52,7 @@
 #define PRID_IMP_VR41XX		0x0c00
 #define PRID_IMP_R12000		0x0e00
 #define PRID_IMP_R8000		0x1000
+#define PRID_IMP_PR4450		0x1200
 #define PRID_IMP_R4600		0x2000
 #define PRID_IMP_R4700		0x2100
 #define PRID_IMP_TX39		0x2200
@@ -60,6 +67,13 @@
 #define PRID_IMP_RM9000		0x3400
 #define PRID_IMP_R5432		0x5400
 #define PRID_IMP_R5500		0x5500
+
+#define PRID_IMP_UNKNOWN	0xff00
+
+/*
+ * These are the PRID's for when 23:16 == PRID_COMP_MIPS
+ */
+
 #define PRID_IMP_4KC		0x8000
 #define PRID_IMP_5KC		0x8100
 #define PRID_IMP_20KC		0x8200
@@ -71,14 +85,15 @@
 #define PRID_IMP_4KEMPR2	0x9100
 #define PRID_IMP_4KSD		0x9200
 #define PRID_IMP_24K		0x9300
-
-#define PRID_IMP_UNKNOWN	0xff00
+#define PRID_IMP_34K		0x9500
+#define PRID_IMP_24KE		0x9600
 
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_SIBYTE
  */
 
 #define PRID_IMP_SB1            0x0100
+#define PRID_IMP_SB1A           0x1100
 
 /*
  * These are the PRID's for when 23:16 == PRID_COMP_SANDCRAFT
@@ -177,7 +192,11 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
-#define CPU_LAST		58
+#define CPU_AU1200		59
+#define CPU_34K			60
+#define CPU_PR4450		61
+#define CPU_SB1A		62
+#define CPU_LAST		62
 
 /*
  * ISA Level encodings
@@ -200,23 +219,37 @@
  * CPU Option encodings
  */
 #define MIPS_CPU_TLB		0x00000001 /* CPU has TLB */
-/* Leave a spare bit for variant MMU types... */
-#define MIPS_CPU_4KEX		0x00000004 /* "R4K" exception model */
-#define MIPS_CPU_4KTLB		0x00000008 /* "R4K" TLB handler */
-#define MIPS_CPU_FPU		0x00000010 /* CPU has FPU */
-#define MIPS_CPU_32FPR		0x00000020 /* 32 dbl. prec. FP registers */
-#define MIPS_CPU_COUNTER	0x00000040 /* Cycle count/compare */
-#define MIPS_CPU_WATCH		0x00000080 /* watchpoint registers */
-#define MIPS_CPU_MIPS16		0x00000100 /* code compression */
-#define MIPS_CPU_DIVEC		0x00000200 /* dedicated interrupt vector */
-#define MIPS_CPU_VCE		0x00000400 /* virt. coherence conflict possible */
-#define MIPS_CPU_CACHE_CDEX_P	0x00000800 /* Create_Dirty_Exclusive CACHE op */
-#define MIPS_CPU_CACHE_CDEX_S	0x00001000 /* ... same for seconary cache ... */
-#define MIPS_CPU_MCHECK		0x00002000 /* Machine check exception */
-#define MIPS_CPU_EJTAG		0x00004000 /* EJTAG exception */
-#define MIPS_CPU_NOFPUEX	0x00008000 /* no FPU exception */
-#define MIPS_CPU_LLSC		0x00010000 /* CPU has ll/sc instructions */
-#define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
-#define MIPS_CPU_PREFETCH	0x00040000 /* CPU has usable prefetch */
+#define MIPS_CPU_4KEX		0x00000002 /* "R4K" exception model */
+#define MIPS_CPU_3K_CACHE	0x00000004 /* R3000-style caches */
+#define MIPS_CPU_4K_CACHE	0x00000008 /* R4000-style caches */
+#define MIPS_CPU_TX39_CACHE	0x00000010 /* TX3900-style caches */
+#define MIPS_CPU_SB1_CACHE	0x00000020 /* SB1-style caches */
+#define MIPS_CPU_FPU		0x00000040 /* CPU has FPU */
+#define MIPS_CPU_32FPR		0x00000080 /* 32 dbl. prec. FP registers */
+#define MIPS_CPU_COUNTER	0x00000100 /* Cycle count/compare */
+#define MIPS_CPU_WATCH		0x00000200 /* watchpoint registers */
+#define MIPS_CPU_DIVEC		0x00000400 /* dedicated interrupt vector */
+#define MIPS_CPU_VCE		0x00000800 /* virt. coherence conflict possible */
+#define MIPS_CPU_CACHE_CDEX_P	0x00001000 /* Create_Dirty_Exclusive CACHE op */
+#define MIPS_CPU_CACHE_CDEX_S	0x00002000 /* ... same for seconary cache ... */
+#define MIPS_CPU_MCHECK		0x00004000 /* Machine check exception */
+#define MIPS_CPU_EJTAG		0x00008000 /* EJTAG exception */
+#define MIPS_CPU_NOFPUEX	0x00010000 /* no FPU exception */
+#define MIPS_CPU_LLSC		0x00020000 /* CPU has ll/sc instructions */
+#define MIPS_CPU_SUBSET_CACHES	0x00040000 /* P-cache subset enforced */
+#define MIPS_CPU_PREFETCH	0x00080000 /* CPU has usable prefetch */
+#define MIPS_CPU_VINT		0x00100000 /* CPU supports MIPSR2 vectored interrupts */
+#define MIPS_CPU_VEIC		0x00200000 /* CPU supports MIPSR2 external interrupt controller mode */
+
+/*
+ * CPU ASE encodings
+ */
+#define MIPS_ASE_MIPS16		0x00000001 /* code compression */
+#define MIPS_ASE_MDMX		0x00000002 /* MIPS digital media extension */
+#define MIPS_ASE_MIPS3D		0x00000004 /* MIPS-3D */
+#define MIPS_ASE_SMARTMIPS	0x00000008 /* SmartMIPS */
+#define MIPS_ASE_DSP		0x00000010 /* Signal Processing ASE */
+#define MIPS_ASE_MIPSMT		0x00000020 /* CPU supports MIPS MT */
+
 
 #endif /* _ASM_CPU_H */
diff -Naur linux-2.6.14/include/asm-mips/cpu-info.h linux-mips-2.6.14.orig/include/asm-mips/cpu-info.h
--- linux-2.6.14/include/asm-mips/cpu-info.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/cpu-info.h	2005-11-17 11:44:27.000000000 -0800
@@ -7,6 +7,7 @@
  * Copyright (C) 1995, 1996, 1997, 1998, 1999, 2001, 2002, 2003 Ralf Baechle
  * Copyright (C) 1996 Paul M. Antoine
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef __ASM_CPU_INFO_H
 #define __ASM_CPU_INFO_H
@@ -61,6 +62,7 @@
 	 * Capability and feature descriptor structure for MIPS CPU
 	 */
 	unsigned long		options;
+	unsigned long		ases;
 	unsigned int		processor_id;
 	unsigned int		fpu_id;
 	unsigned int		cputype;
diff -Naur linux-2.6.14/include/asm-mips/dec/ecc.h linux-mips-2.6.14.orig/include/asm-mips/dec/ecc.h
--- linux-2.6.14/include/asm-mips/dec/ecc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/ecc.h	2005-11-17 11:44:27.000000000 -0800
@@ -49,7 +49,8 @@
 
 extern void dec_ecc_be_init(void);
 extern int dec_ecc_be_handler(struct pt_regs *regs, int is_fixup);
-extern irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+extern irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs);
 #endif
 
 #endif /* __ASM_MIPS_DEC_ECC_H */
diff -Naur linux-2.6.14/include/asm-mips/dec/ioasic_addrs.h linux-mips-2.6.14.orig/include/asm-mips/dec/ioasic_addrs.h
--- linux-2.6.14/include/asm-mips/dec/ioasic_addrs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/ioasic_addrs.h	2005-11-17 11:44:27.000000000 -0800
@@ -45,7 +45,8 @@
 
 
 /*
- * Offsets for I/O ASIC registers (relative to (system_base + IOASIC_IOCTL)).
+ * Offsets for I/O ASIC registers
+ * (relative to (dec_kn_slot_base + IOASIC_IOCTL)).
  */
 					/* all systems */
 #define IO_REG_SCSI_DMA_P	0x00	/* SCSI DMA Pointer */
diff -Naur linux-2.6.14/include/asm-mips/dec/kn01.h linux-mips-2.6.14.orig/include/asm-mips/dec/kn01.h
--- linux-2.6.14/include/asm-mips/dec/kn01.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/kn01.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,14 +8,12 @@
  *
  * Copyright (C) 1995,1996 by Paul M. Antoine, some code and definitions
  * are by courtesy of Chris Fraser.
- * Copyright (C) 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2005  Maciej W. Rozycki
  */
 #ifndef __ASM_MIPS_DEC_KN01_H
 #define __ASM_MIPS_DEC_KN01_H
 
-#include <asm/addrspace.h>
-
-#define KN01_SLOT_BASE	KSEG1ADDR(0x10000000)
+#define KN01_SLOT_BASE	0x10000000
 #define KN01_SLOT_SIZE	0x01000000
 
 /*
@@ -41,17 +39,9 @@
 
 
 /*
- * Some port addresses...
- */
-#define KN01_LANCE_BASE (KN01_SLOT_BASE + KN01_LANCE)	/* 0xB8000000 */
-#define KN01_DZ11_BASE	(KN01_SLOT_BASE + KN01_DZ11)	/* 0xBC000000 */
-#define KN01_RTC_BASE	(KN01_SLOT_BASE + KN01_RTC)	/* 0xBD000000 */
-
-
-/*
  * Frame buffer memory address.
  */
-#define KN01_VFB_MEM	KSEG1ADDR(0x0fc00000)
+#define KN01_VFB_MEM	0x0fc00000
 
 /*
  * CPU interrupt bits.
@@ -80,4 +70,22 @@
 #define KN01_CSR_VRGTRB		(1<<0)	/* red DAC voltage over blue (r/o) */
 #define KN01_CSR_LEDS		(0xff<<0) /* ~diagnostic LEDs (w/o) */
 
+
+#ifndef __ASSEMBLY__
+
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+struct pt_regs;
+
+extern u16 cached_kn01_csr;
+extern spinlock_t kn01_lock;
+
+extern void dec_kn01_be_init(void);
+extern int dec_kn01_be_handler(struct pt_regs *regs, int is_fixup);
+extern irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id,
+					 struct pt_regs *regs);
+#endif
+
 #endif /* __ASM_MIPS_DEC_KN01_H */
diff -Naur linux-2.6.14/include/asm-mips/dec/kn02.h linux-mips-2.6.14.orig/include/asm-mips/dec/kn02.h
--- linux-2.6.14/include/asm-mips/dec/kn02.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/kn02.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,21 +8,12 @@
  *
  * Copyright (C) 1995,1996 by Paul M. Antoine, some code and definitions
  * are by courtesy of Chris Fraser.
- * Copyright (C) 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2005  Maciej W. Rozycki
  */
 #ifndef __ASM_MIPS_DEC_KN02_H
 #define __ASM_MIPS_DEC_KN02_H
 
-#ifndef __ASSEMBLY__
-#include <linux/spinlock.h>
-#include <linux/types.h>
-#endif
-
-#include <asm/addrspace.h>
-#include <asm/dec/ecc.h>
-
-
-#define KN02_SLOT_BASE	KSEG1ADDR(0x1fc00000)
+#define KN02_SLOT_BASE	0x1fc00000
 #define KN02_SLOT_SIZE	0x00080000
 
 /*
@@ -39,22 +30,14 @@
 
 
 /*
- * Some port addresses...
- */
-#define KN02_DZ11_BASE	(KN02_SLOT_BASE + KN02_DZ11)	/* DZ11 */
-#define KN02_RTC_BASE	(KN02_SLOT_BASE + KN02_RTC)	/* RTC */
-#define KN02_CSR_BASE	(KN02_SLOT_BASE + KN02_CSR)	/* CSR */
-
-
-/*
  * System Control & Status Register bits.
  */
 #define KN02_CSR_RES_28		(0xf<<28)	/* unused */
 #define KN02_CSR_PSU		(1<<27)		/* power supply unit warning */
 #define KN02_CSR_NVRAM		(1<<26)		/* ~NVRAM clear jumper */
 #define KN02_CSR_REFEVEN	(1<<25)		/* mem refresh bank toggle */
-#define KN03_CSR_NRMOD		(1<<24)		/* ~NRMOD manufact. jumper */
-#define KN03_CSR_IOINTEN	(0xff<<16)	/* IRQ mask bits */
+#define KN02_CSR_NRMOD		(1<<24)		/* ~NRMOD manufact. jumper */
+#define KN02_CSR_IOINTEN	(0xff<<16)	/* IRQ mask bits */
 #define KN02_CSR_DIAGCHK	(1<<15)		/* diagn/norml ECC reads */
 #define KN02_CSR_DIAGGEN	(1<<14)		/* diagn/norml ECC writes */
 #define KN02_CSR_CORRECT	(1<<13)		/* ECC correct/check */
@@ -63,8 +46,8 @@
 #define KN02_CSR_BNK32M		(1<<10)		/* 32M/8M stride */
 #define KN02_CSR_DIAGDN		(1<<9)		/* DIAGDN manufact. jumper */
 #define KN02_CSR_BAUD38		(1<<8)		/* DZ11 38/19kbps ext. rate */
-#define KN03_CSR_IOINT		(0xff<<0)	/* IRQ status bits (r/o) */
-#define KN03_CSR_LEDS		(0xff<<0)	/* ~diagnostic LEDs (w/o) */
+#define KN02_CSR_IOINT		(0xff<<0)	/* IRQ status bits (r/o) */
+#define KN02_CSR_LEDS		(0xff<<0)	/* ~diagnostic LEDs (w/o) */
 
 
 /*
@@ -98,6 +81,10 @@
 
 
 #ifndef __ASSEMBLY__
+
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
 extern u32 cached_kn02_csr;
 extern spinlock_t kn02_lock;
 extern void init_kn02_irqs(int base);
diff -Naur linux-2.6.14/include/asm-mips/dec/kn02xa.h linux-mips-2.6.14.orig/include/asm-mips/dec/kn02xa.h
--- linux-2.6.14/include/asm-mips/dec/kn02xa.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/kn02xa.h	2005-11-17 11:44:27.000000000 -0800
@@ -9,7 +9,7 @@
  *
  * Copyright (C) 1995,1996 by Paul M. Antoine, some code and definitions
  * are by courtesy of Chris Fraser.
- * Copyright (C) 2000, 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2000, 2002, 2003, 2005  Maciej W. Rozycki
  *
  * These are addresses which have to be known early in the boot process.
  * For other addresses refer to tc.h, ioasic_addrs.h and friends.
@@ -17,31 +17,23 @@
 #ifndef __ASM_MIPS_DEC_KN02XA_H
 #define __ASM_MIPS_DEC_KN02XA_H
 
-#include <asm/addrspace.h>
 #include <asm/dec/ioasic_addrs.h>
 
-#define KN02XA_SLOT_BASE	KSEG1ADDR(0x1c000000)
-
-/*
- * Some port addresses...
- */
-#define KN02XA_IOASIC_BASE    (KN02XA_SLOT_BASE + IOASIC_IOCTL)	/* I/O ASIC */
-#define KN02XA_RTC_BASE		(KN02XA_SLOT_BASE + IOASIC_TOY)	/* RTC */
-
+#define KN02XA_SLOT_BASE	0x1c000000
 
 /*
  * Memory control ASIC registers.
  */
-#define KN02XA_MER	KSEG1ADDR(0x0c400000)	/* memory error register */
-#define KN02XA_MSR	KSEG1ADDR(0x0c800000)	/* memory size register */
+#define KN02XA_MER		0x0c400000	/* memory error register */
+#define KN02XA_MSR		0x0c800000	/* memory size register */
 
 /*
  * CPU control ASIC registers.
  */
-#define KN02XA_MEM_CONF	KSEG1ADDR(0x0e000000)	/* write timeout config */
-#define KN02XA_EAR	KSEG1ADDR(0x0e000004)	/* error address register */
-#define KN02XA_BOOT0	KSEG1ADDR(0x0e000008)	/* boot 0 register */
-#define KN02XA_MEM_INTR	KSEG1ADDR(0x0e00000c)	/* write err IRQ stat & ack */
+#define KN02XA_MEM_CONF		0x0e000000	/* write timeout config */
+#define KN02XA_EAR		0x0e000004	/* error address register */
+#define KN02XA_BOOT0		0x0e000008	/* boot 0 register */
+#define KN02XA_MEM_INTR		0x0e00000c	/* write err IRQ stat & ack */
 
 /*
  * Memory Error Register bits, common definitions.
@@ -52,8 +44,13 @@
 #define KN02XA_MER_PAGERR	(1<<16)		/* 2k page boundary error */
 #define KN02XA_MER_TRANSERR	(1<<15)		/* transfer length error */
 #define KN02XA_MER_PARDIS	(1<<14)		/* parity error disable */
-#define KN02XA_MER_RES_12	(0x3<<12)	/* unused */
-#define KN02XA_MER_BYTERR	(0xf<<8)	/* byte lane error bitmask */
+#define KN02XA_MER_SIZE		(1<<13)		/* r/o mirror of MSR_SIZE */
+#define KN02XA_MER_RES_12	(1<<12)		/* unused */
+#define KN02XA_MER_BYTERR	(0xf<<8)	/* byte lane error bitmask: */
+#define KN02XA_MER_BYTERR_3	(0x8<<8)	/* byte lane #3 */
+#define KN02XA_MER_BYTERR_2	(0x4<<8)	/* byte lane #2 */
+#define KN02XA_MER_BYTERR_1	(0x2<<8)	/* byte lane #1 */
+#define KN02XA_MER_BYTERR_0	(0x1<<8)	/* byte lane #0 */
 #define KN02XA_MER_RES_0	(0xff<<0)	/* unused */
 
 /*
@@ -72,4 +69,17 @@
 #define KN02XA_EAR_ADDRESS	(0x7ffffff<<2)	/* address involved */
 #define KN02XA_EAR_RES_0	(0x3<<0)	/* unused */
 
+
+#ifndef __ASSEMBLY__
+
+#include <linux/interrupt.h>
+
+struct pt_regs;
+
+extern void dec_kn02xa_be_init(void);
+extern int dec_kn02xa_be_handler(struct pt_regs *regs, int is_fixup);
+extern irqreturn_t dec_kn02xa_be_interrupt(int irq, void *dev_id,
+					   struct pt_regs *regs);
+#endif
+
 #endif /* __ASM_MIPS_DEC_KN02XA_H */
diff -Naur linux-2.6.14/include/asm-mips/dec/kn03.h linux-mips-2.6.14.orig/include/asm-mips/dec/kn03.h
--- linux-2.6.14/include/asm-mips/dec/kn03.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/kn03.h	2005-11-17 11:44:27.000000000 -0800
@@ -10,24 +10,15 @@
  *
  * Copyright (C) 1995,1996 by Paul M. Antoine, some code and definitions
  * are by courtesy of Chris Fraser.
- * Copyright (C) 2000, 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2000, 2002, 2003, 2005  Maciej W. Rozycki
  */
 #ifndef __ASM_MIPS_DEC_KN03_H
 #define __ASM_MIPS_DEC_KN03_H
 
-#include <asm/addrspace.h>
 #include <asm/dec/ecc.h>
 #include <asm/dec/ioasic_addrs.h>
 
-#define KN03_SLOT_BASE	KSEG1ADDR(0x1f800000)
-
-/*
- * Some port addresses...
- */
-#define KN03_IOASIC_BASE	(KN03_SLOT_BASE + IOASIC_IOCTL)	/* I/O ASIC */
-#define KN03_RTC_BASE		(KN03_SLOT_BASE + IOASIC_TOY)	/* RTC */
-#define KN03_MCR_BASE		(KN03_SLOT_BASE + IOASIC_MCR)	/* MCR */
-
+#define KN03_SLOT_BASE		0x1f800000
 
 /*
  * CPU interrupt bits.
diff -Naur linux-2.6.14/include/asm-mips/dec/kn05.h linux-mips-2.6.14.orig/include/asm-mips/dec/kn05.h
--- linux-2.6.14/include/asm-mips/dec/kn05.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/kn05.h	2005-11-17 11:44:27.000000000 -0800
@@ -1,10 +1,12 @@
 /*
  *	include/asm-mips/dec/kn05.h
  *
- *	DECstation 5000/260 (4max+ or KN05) and DECsystem 5900/260
+ *	DECstation/DECsystem 5000/260 (4max+ or KN05), 5000/150 (4min
+ *	or KN04-BA), Personal DECstation/DECsystem 5000/50 (4maxine or
+ *	KN04-CA) and DECsystem 5900/260 (KN05) R4k CPU card MB ASIC
  *	definitions.
  *
- *	Copyright (C) 2002, 2003  Maciej W. Rozycki
+ *	Copyright (C) 2002, 2003, 2005  Maciej W. Rozycki
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -13,8 +15,8 @@
  *
  *	WARNING!  All this information is pure guesswork based on the
  *	ROM.  It is provided here in hope it will give someone some
- *	food for thought.  No documentation for the KN05 module has
- *	been located so far.
+ *	food for thought.  No documentation for the KN05 nor the KN04
+ *	module has been located so far.
  */
 #ifndef __ASM_MIPS_DEC_KN05_H
 #define __ASM_MIPS_DEC_KN05_H
@@ -24,48 +26,50 @@
 /*
  * The oncard MB (Memory Buffer) ASIC provides an additional address
  * decoder.  Certain address ranges within the "high" 16 slots are
- * passed to the I/O ASIC's decoder like with the KN03.  Others are
- * handled locally.  "Low" slots are always passed.
+ * passed to the I/O ASIC's decoder like with the KN03 or KN02-BA/CA.
+ * Others are handled locally.  "Low" slots are always passed.
  */
-#define KN05_MB_ROM	(16*IOASIC_SLOT_SIZE)	/* KN05 card ROM */
-#define KN05_IOCTL	(17*IOASIC_SLOT_SIZE)	/* I/O ASIC */
-#define KN05_ESAR	(18*IOASIC_SLOT_SIZE)	/* LANCE MAC address chip */
-#define KN05_LANCE	(19*IOASIC_SLOT_SIZE)	/* LANCE Ethernet */
-#define KN05_MB_INT	(20*IOASIC_SLOT_SIZE)	/* MB interrupt register */
-#define KN05_MB_EA	(21*IOASIC_SLOT_SIZE)	/* MB error address? */
-#define KN05_MB_EC	(22*IOASIC_SLOT_SIZE)	/* MB error ??? */
-#define KN05_MB_CSR	(23*IOASIC_SLOT_SIZE)	/* MB control & status */
-#define KN05_RES_24	(24*IOASIC_SLOT_SIZE)	/* unused? */
-#define KN05_RES_25	(25*IOASIC_SLOT_SIZE)	/* unused? */
-#define KN05_RES_26	(26*IOASIC_SLOT_SIZE)	/* unused? */
-#define KN05_RES_27	(27*IOASIC_SLOT_SIZE)	/* unused? */
-#define KN05_SCSI	(28*IOASIC_SLOT_SIZE)	/* ASC SCSI */
-#define KN05_RES_29	(29*IOASIC_SLOT_SIZE)	/* unused? */
-#define KN05_RES_30	(30*IOASIC_SLOT_SIZE)	/* unused? */
-#define KN05_RES_31	(31*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_SLOT_BASE	0x1fc00000
+
+#define KN4K_MB_ROM	(0*IOASIC_SLOT_SIZE)	/* KN05/KN04 card ROM */
+#define KN4K_IOCTL	(1*IOASIC_SLOT_SIZE)	/* I/O ASIC */
+#define KN4K_ESAR	(2*IOASIC_SLOT_SIZE)	/* LANCE MAC address chip */
+#define KN4K_LANCE	(3*IOASIC_SLOT_SIZE)	/* LANCE Ethernet */
+#define KN4K_MB_INT	(4*IOASIC_SLOT_SIZE)	/* MB interrupt register */
+#define KN4K_MB_EA	(5*IOASIC_SLOT_SIZE)	/* MB error address? */
+#define KN4K_MB_EC	(6*IOASIC_SLOT_SIZE)	/* MB error ??? */
+#define KN4K_MB_CSR	(7*IOASIC_SLOT_SIZE)	/* MB control & status */
+#define KN4K_RES_08	(8*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_RES_09	(9*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_RES_10	(10*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_RES_11	(11*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_SCSI	(12*IOASIC_SLOT_SIZE)	/* ASC SCSI */
+#define KN4K_RES_13	(13*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_RES_14	(14*IOASIC_SLOT_SIZE)	/* unused? */
+#define KN4K_RES_15	(15*IOASIC_SLOT_SIZE)	/* unused? */
 
 /*
  * Bits for the MB interrupt register.
  * The register appears read-only.
  */
-#define KN05_MB_INT_TC		(1<<0)		/* TURBOchannel? */
-#define KN05_MB_INT_RTC		(1<<1)		/* RTC? */
-#define KN05_MB_INT_MT		(1<<3)		/* ??? */
+#define KN4K_MB_INT_TC		(1<<0)		/* TURBOchannel? */
+#define KN4K_MB_INT_RTC		(1<<1)		/* RTC? */
+#define KN4K_MB_INT_MT		(1<<3)		/* ??? */
 
 /*
  * Bits for the MB control & status register.
  * Set to 0x00bf8001 on my system by the ROM.
  */
-#define KN05_MB_CSR_PF		(1<<0)		/* PreFetching enable? */
-#define KN05_MB_CSR_F		(1<<1)		/* ??? */
-#define KN05_MB_CSR_ECC		(0xff<<2)	/* ??? */
-#define KN05_MB_CSR_OD		(1<<10)		/* ??? */
-#define KN05_MB_CSR_CP		(1<<11)		/* ??? */
-#define KN05_MB_CSR_UNC		(1<<12)		/* ??? */
-#define KN05_MB_CSR_IM		(1<<13)		/* ??? */
-#define KN05_MB_CSR_NC		(1<<14)		/* ??? */
-#define KN05_MB_CSR_EE		(1<<15)		/* (bus) Exception Enable? */
-#define KN05_MB_CSR_MSK		(0x1f<<16)	/* ??? */
-#define KN05_MB_CSR_FW		(1<<21)		/* ??? */
+#define KN4K_MB_CSR_PF		(1<<0)		/* PreFetching enable? */
+#define KN4K_MB_CSR_F		(1<<1)		/* ??? */
+#define KN4K_MB_CSR_ECC		(0xff<<2)	/* ??? */
+#define KN4K_MB_CSR_OD		(1<<10)		/* ??? */
+#define KN4K_MB_CSR_CP		(1<<11)		/* ??? */
+#define KN4K_MB_CSR_UNC		(1<<12)		/* ??? */
+#define KN4K_MB_CSR_IM		(1<<13)		/* ??? */
+#define KN4K_MB_CSR_NC		(1<<14)		/* ??? */
+#define KN4K_MB_CSR_EE		(1<<15)		/* (bus) Exception Enable? */
+#define KN4K_MB_CSR_MSK		(0x1f<<16)	/* ??? */
+#define KN4K_MB_CSR_FW		(1<<21)		/* ??? */
 
 #endif /* __ASM_MIPS_DEC_KN05_H */
diff -Naur linux-2.6.14/include/asm-mips/dec/prom.h linux-mips-2.6.14.orig/include/asm-mips/dec/prom.h
--- linux-2.6.14/include/asm-mips/dec/prom.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/prom.h	2005-11-17 11:44:27.000000000 -0800
@@ -24,7 +24,7 @@
  * PMAX/3MAX PROM entry points for DS2100/3100's and DS5000/2xx's.
  * Many of these will work for MIPSen as well!
  */
-#define VEC_RESET		(u64 *)KSEG1ADDR(0x1fc00000)
+#define VEC_RESET		(u64 *)CKSEG1ADDR(0x1fc00000)
 							/* Prom base address */
 
 #define PMAX_PROM_ENTRY(x)	(VEC_RESET + (x))	/* Prom jump table */
@@ -111,19 +111,21 @@
  * On MIPS64 we have to call PROM functions via a helper
  * dispatcher to accomodate ABI incompatibilities.
  */
-#define __DEC_PROM_O32 __attribute__((alias("call_o32")))
+#define __DEC_PROM_O32(fun, arg) fun arg __asm__(#fun); \
+				 __asm__(#fun " = call_o32")
 
-int _rex_bootinit(int (*)(void)) __DEC_PROM_O32;
-int _rex_bootread(int (*)(void)) __DEC_PROM_O32;
-int _rex_getbitmap(int (*)(memmap *), memmap *) __DEC_PROM_O32;
-unsigned long *_rex_slot_address(unsigned long *(*)(int), int) __DEC_PROM_O32;
-void *_rex_gettcinfo(void *(*)(void)) __DEC_PROM_O32;
-int _rex_getsysid(int (*)(void)) __DEC_PROM_O32;
-void _rex_clear_cache(void (*)(void)) __DEC_PROM_O32;
-
-int _prom_getchar(int (*)(void)) __DEC_PROM_O32;
-char *_prom_getenv(char *(*)(char *), char *) __DEC_PROM_O32;
-int _prom_printf(int (*)(char *, ...), char *, ...) __DEC_PROM_O32;
+int __DEC_PROM_O32(_rex_bootinit, (int (*)(void)));
+int __DEC_PROM_O32(_rex_bootread, (int (*)(void)));
+int __DEC_PROM_O32(_rex_getbitmap, (int (*)(memmap *), memmap *));
+unsigned long *__DEC_PROM_O32(_rex_slot_address,
+			     (unsigned long *(*)(int), int));
+void *__DEC_PROM_O32(_rex_gettcinfo, (void *(*)(void)));
+int __DEC_PROM_O32(_rex_getsysid, (int (*)(void)));
+void __DEC_PROM_O32(_rex_clear_cache, (void (*)(void)));
+
+int __DEC_PROM_O32(_prom_getchar, (int (*)(void)));
+char *__DEC_PROM_O32(_prom_getenv, (char *(*)(char *), char *));
+int __DEC_PROM_O32(_prom_printf, (int (*)(char *, ...), char *, ...));
 
 
 #define rex_bootinit()		_rex_bootinit(__rex_bootinit)
diff -Naur linux-2.6.14/include/asm-mips/dec/system.h linux-mips-2.6.14.orig/include/asm-mips/dec/system.h
--- linux-2.6.14/include/asm-mips/dec/system.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/system.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,18 @@
+/*
+ *	include/asm-mips/dec/system.h
+ *
+ *	Generic DECstation/DECsystem bits.
+ *
+ *	Copyright (C) 2005  Maciej W. Rozycki
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_DEC_SYSTEM_H
+#define __ASM_DEC_SYSTEM_H
+
+extern unsigned long dec_kn_slot_base, dec_kn_slot_size;
+
+#endif /* __ASM_DEC_SYSTEM_H */
diff -Naur linux-2.6.14/include/asm-mips/dec/tc.h linux-mips-2.6.14.orig/include/asm-mips/dec/tc.h
--- linux-2.6.14/include/asm-mips/dec/tc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dec/tc.h	2005-11-17 11:44:27.000000000 -0800
@@ -7,10 +7,8 @@
  *
  * Copyright (c) 1998 Harald Koerfgen
  */
-#ifndef ASM_TC_H
-#define ASM_TC_H
-
-extern unsigned long system_base;
+#ifndef __ASM_DEC_TC_H
+#define __ASM_DEC_TC_H
 
 /*
  * Search for a TURBOchannel Option Module
@@ -36,8 +34,8 @@
  */
 extern unsigned long get_tc_irq_nr(int);
 /*
- * Return TURBOchannel clock frequency in hz
+ * Return TURBOchannel clock frequency in Hz
  */
 extern unsigned long get_tc_speed(void);
 
-#endif
+#endif /* __ASM_DEC_TC_H */
diff -Naur linux-2.6.14/include/asm-mips/delay.h linux-mips-2.6.14.orig/include/asm-mips/delay.h
--- linux-2.6.14/include/asm-mips/delay.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/delay.h	2005-11-17 11:44:27.000000000 -0800
@@ -12,11 +12,9 @@
 
 #include <linux/config.h>
 #include <linux/param.h>
-
+#include <linux/smp.h>
 #include <asm/compiler.h>
 
-extern unsigned long loops_per_jiffy;
-
 static inline void __delay(unsigned long loops)
 {
 	if (sizeof(long) == 4)
@@ -82,11 +80,7 @@
 	__delay(usecs);
 }
 
-#ifdef CONFIG_SMP
 #define __udelay_val cpu_data[smp_processor_id()].udelay_val
-#else
-#define __udelay_val loops_per_jiffy
-#endif
 
 #define udelay(usecs) __udelay((usecs),__udelay_val)
 
diff -Naur linux-2.6.14/include/asm-mips/dma-mapping.h linux-mips-2.6.14.orig/include/asm-mips/dma-mapping.h
--- linux-2.6.14/include/asm-mips/dma-mapping.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/dma-mapping.h	2005-11-17 11:44:27.000000000 -0800
@@ -5,13 +5,13 @@
 #include <asm/cache.h>
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
-			   dma_addr_t *dma_handle, int flag);
+			   dma_addr_t *dma_handle, unsigned int __nocast flag);
 
 void dma_free_noncoherent(struct device *dev, size_t size,
 			 void *vaddr, dma_addr_t dma_handle);
 
 void *dma_alloc_coherent(struct device *dev, size_t size,
-			   dma_addr_t *dma_handle, int flag);
+			   dma_addr_t *dma_handle, unsigned int __nocast flag);
 
 void dma_free_coherent(struct device *dev, size_t size,
 			 void *vaddr, dma_addr_t dma_handle);
diff -Naur linux-2.6.14/include/asm-mips/dsp.h linux-mips-2.6.14.orig/include/asm-mips/dsp.h
--- linux-2.6.14/include/asm-mips/dsp.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/dsp.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2005 Mips Technologies
+ * Author: Chris Dearman, chris@mips.com derived from fpu.h
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef _ASM_DSP_H
+#define _ASM_DSP_H
+
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/hazards.h>
+#include <asm/mipsregs.h>
+
+#define DSP_DEFAULT	0x00000000
+#define DSP_MASK	0x1f
+
+#define __enable_dsp_hazard()						\
+do {									\
+	asm("_ehb");							\
+} while (0)
+
+static inline void __init_dsp(void)
+{
+	mthi1(0);
+	mtlo1(0);
+	mthi2(0);
+	mtlo2(0);
+	mthi3(0);
+	mtlo3(0);
+	wrdsp(DSP_DEFAULT, DSP_MASK);
+}
+
+static inline void init_dsp(void)
+{
+	if (cpu_has_dsp)
+		__init_dsp();
+}
+
+#define __save_dsp(tsk)							\
+do {									\
+	tsk->thread.dsp.dspr[0] = mfhi1();				\
+	tsk->thread.dsp.dspr[1] = mflo1();				\
+	tsk->thread.dsp.dspr[2] = mfhi2();				\
+	tsk->thread.dsp.dspr[3] = mflo2();				\
+	tsk->thread.dsp.dspr[4] = mfhi3();				\
+	tsk->thread.dsp.dspr[5] = mflo3();				\
+} while (0)
+
+#define save_dsp(tsk)							\
+do {									\
+	if (cpu_has_dsp)						\
+		__save_dsp(tsk);					\
+} while (0)
+
+#define __restore_dsp(tsk)						\
+do {									\
+	mthi1(tsk->thread.dsp.dspr[0]);					\
+	mtlo1(tsk->thread.dsp.dspr[1]);					\
+	mthi2(tsk->thread.dsp.dspr[2]);					\
+	mtlo2(tsk->thread.dsp.dspr[3]);					\
+	mthi3(tsk->thread.dsp.dspr[4]);					\
+	mtlo3(tsk->thread.dsp.dspr[5]);					\
+} while (0)
+
+#define restore_dsp(tsk)						\
+do {									\
+	if (cpu_has_dsp)						\
+		__restore_dsp(tsk);					\
+} while (0)
+
+#define __get_dsp_regs(tsk)						\
+({									\
+	if (tsk == current)						\
+		__save_dsp(current);					\
+									\
+	tsk->thread.dsp.dspr;						\
+})
+
+#endif /* _ASM_DSP_H */
diff -Naur linux-2.6.14/include/asm-mips/elf.h linux-mips-2.6.14.orig/include/asm-mips/elf.h
--- linux-2.6.14/include/asm-mips/elf.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/elf.h	2005-11-17 11:44:27.000000000 -0800
@@ -2,6 +2,8 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
+ *
+ * Much of this is taken from binutils and GNU libc ...
  */
 #ifndef _ASM_ELF_H
 #define _ASM_ELF_H
@@ -17,6 +19,8 @@
 #define EF_MIPS_ARCH_5		0x40000000	/* -mips5 code.  */
 #define EF_MIPS_ARCH_32		0x50000000	/* MIPS32 code.  */
 #define EF_MIPS_ARCH_64		0x60000000	/* MIPS64 code.  */
+#define EF_MIPS_ARCH_32R2	0x70000000	/* MIPS32 R2 code.  */
+#define EF_MIPS_ARCH_64R2	0x80000000	/* MIPS64 R2 code.  */
 
 /* The ABI of a file. */
 #define EF_MIPS_ABI_O32		0x00001000	/* O32 ABI.  */
@@ -105,7 +109,11 @@
 #define R_MIPS_LOVENDOR		100
 #define R_MIPS_HIVENDOR		127
 
-#define SHN_MIPS_ACCOMON	0xff00
+#define SHN_MIPS_ACCOMON	0xff00		/* Allocated common symbols */
+#define SHN_MIPS_TEXT		0xff01		/* Allocated test symbols.  */
+#define SHN_MIPS_DATA		0xff02		/* Allocated data symbols.  */
+#define SHN_MIPS_SCOMMON	0xff03		/* Small common symbols */
+#define SHN_MIPS_SUNDEFINED	0xff04		/* Small undefined symbols */
 
 #define SHT_MIPS_LIST		0x70000000
 #define SHT_MIPS_CONFLICT	0x70000002
@@ -193,50 +201,92 @@
 
 #ifdef __KERNEL__
 
+struct mips_abi;
+
+extern struct mips_abi mips_abi;
+extern struct mips_abi mips_abi_32;
+extern struct mips_abi mips_abi_n32;
+
 #ifdef CONFIG_32BIT
 
-#define SET_PERSONALITY(ex, ibcs2)			\
-do {							\
-	if (ibcs2)					\
-		set_personality(PER_SVR4);		\
-	set_personality(PER_LINUX);			\
+#define SET_PERSONALITY(ex, ibcs2)					\
+do {									\
+	if (ibcs2)							\
+		set_personality(PER_SVR4);				\
+	set_personality(PER_LINUX);					\
+									\
+	current->thread.abi = &mips_abi;				\
 } while (0)
 
 #endif /* CONFIG_32BIT */
 
 #ifdef CONFIG_64BIT
 
-#define SET_PERSONALITY(ex, ibcs2)				\
-do {	current->thread.mflags &= ~MF_ABI_MASK;			\
-	if ((ex).e_ident[EI_CLASS] == ELFCLASS32) {		\
-		if ((((ex).e_flags & EF_MIPS_ABI2) != 0) &&	\
-		     ((ex).e_flags & EF_MIPS_ABI) == 0)		\
-			current->thread.mflags |= MF_N32;	\
-		else						\
-			current->thread.mflags |= MF_O32;	\
-	} else							\
-		current->thread.mflags |= MF_N64;		\
-	if (ibcs2)						\
-		set_personality(PER_SVR4);			\
-	else if (current->personality != PER_LINUX32)		\
-		set_personality(PER_LINUX);			\
+#ifdef CONFIG_MIPS32_N32
+#define __SET_PERSONALITY32_N32()					\
+	do {								\
+		current->thread.mflags |= MF_N32;			\
+		current->thread.abi = &mips_abi_n32;			\
+	} while (0)
+#else
+#define __SET_PERSONALITY32_N32()					\
+	do { } while (0)
+#endif
+
+#ifdef CONFIG_MIPS32_O32
+#define __SET_PERSONALITY32_O32()					\
+	do {								\
+		current->thread.mflags |= MF_O32;			\
+		current->thread.abi = &mips_abi_32;			\
+	} while (0)
+#else
+#define __SET_PERSONALITY32_O32()					\
+	do { } while (0)
+#endif
+
+#ifdef CONFIG_MIPS32_COMPAT
+#define __SET_PERSONALITY32(ex)						\
+do {									\
+	if ((((ex).e_flags & EF_MIPS_ABI2) != 0) &&			\
+	     ((ex).e_flags & EF_MIPS_ABI) == 0)				\
+		__SET_PERSONALITY32_N32();				\
+	else								\
+		__SET_PERSONALITY32_O32();				\
+} while (0)
+#else
+#define __SET_PERSONALITY32(ex)	do { } while (0)
+#endif
+
+#define SET_PERSONALITY(ex, ibcs2)					\
+do {									\
+	current->thread.mflags &= ~MF_ABI_MASK;				\
+	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)			\
+		__SET_PERSONALITY32(ex);				\
+	else {								\
+		current->thread.mflags |= MF_N64;			\
+		current->thread.abi = &mips_abi;			\
+	}								\
+									\
+	if (ibcs2)							\
+		set_personality(PER_SVR4);				\
+	else if (current->personality != PER_LINUX32)			\
+		set_personality(PER_LINUX);				\
 } while (0)
 
 #endif /* CONFIG_64BIT */
 
 extern void dump_regs(elf_greg_t *, struct pt_regs *regs);
+extern int dump_task_regs (struct task_struct *, elf_gregset_t *);
 extern int dump_task_fpu(struct task_struct *, elf_fpregset_t *);
 
 #define ELF_CORE_COPY_REGS(elf_regs, regs)			\
 	dump_regs((elf_greg_t *)&(elf_regs), regs);
+#define ELF_CORE_COPY_TASK_REGS(tsk, elf_regs) dump_task_regs(tsk, elf_regs)
 #define ELF_CORE_COPY_FPREGS(tsk, elf_fpregs)			\
 	dump_task_fpu(tsk, elf_fpregs)
 
 #endif /* __KERNEL__ */
 
-/* This one accepts IRIX binaries.  */
-#define irix_elf_check_arch(hdr)	((hdr)->e_flags & RHF_SGI_ONLY)
-
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	PAGE_SIZE
 
diff -Naur linux-2.6.14/include/asm-mips/fcntl.h linux-mips-2.6.14.orig/include/asm-mips/fcntl.h
--- linux-2.6.14/include/asm-mips/fcntl.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/fcntl.h	2005-11-17 11:44:27.000000000 -0800
@@ -3,11 +3,13 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1995, 96, 97, 98, 99, 2003 Ralf Baechle
+ * Copyright (C) 1995, 96, 97, 98, 99, 2003, 05 Ralf Baechle
  */
 #ifndef _ASM_FCNTL_H
 #define _ASM_FCNTL_H
 
+#include <linux/config.h>
+
 #define O_APPEND	0x0008
 #define O_SYNC		0x0010
 #define O_NONBLOCK	0x0080
@@ -40,13 +42,13 @@
  * contain all the same fields as struct flock.
  */
 
-#ifndef __mips64
+#ifdef CONFIG_32BIT
 
 struct flock {
 	short	l_type;
 	short	l_whence;
-	__kernel_off_t l_start;
-	__kernel_off_t l_len;
+	off_t	l_start;
+	off_t	l_len;
 	long	l_sysid;
 	__kernel_pid_t l_pid;
 	long	pad[4];
@@ -54,13 +56,8 @@
 
 #define HAVE_ARCH_STRUCT_FLOCK
 
-#endif
+#endif /* CONFIG_32BIT */
 
 #include <asm-generic/fcntl.h>
 
-typedef struct flock flock_t;
-#ifndef __mips64
-typedef struct flock64 flock64_t;
-#endif
-
 #endif /* _ASM_FCNTL_H */
diff -Naur linux-2.6.14/include/asm-mips/fixmap.h linux-mips-2.6.14.orig/include/asm-mips/fixmap.h
--- linux-2.6.14/include/asm-mips/fixmap.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/fixmap.h	2005-11-17 11:44:27.000000000 -0800
@@ -107,4 +107,11 @@
 	return __virt_to_fix(vaddr);
 }
 
+/*
+ * Called from pgtable_init()
+ */
+extern void fixrange_init(unsigned long start, unsigned long end,
+        pgd_t *pgd_base);
+
+
 #endif
diff -Naur linux-2.6.14/include/asm-mips/fpu_emulator.h linux-mips-2.6.14.orig/include/asm-mips/fpu_emulator.h
--- linux-2.6.14/include/asm-mips/fpu_emulator.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/fpu_emulator.h	2005-11-17 11:44:27.000000000 -0800
@@ -23,16 +23,15 @@
 #ifndef _ASM_FPU_EMULATOR_H
 #define _ASM_FPU_EMULATOR_H
 
-struct mips_fpu_emulator_private {
-	unsigned int eir;
-	struct {
-		unsigned int emulated;
-		unsigned int loads;
-		unsigned int stores;
-		unsigned int cp1ops;
-		unsigned int cp1xops;
-		unsigned int errors;
-	} stats;
+struct mips_fpu_emulator_stats {
+	unsigned int emulated;
+	unsigned int loads;
+	unsigned int stores;
+	unsigned int cp1ops;
+	unsigned int cp1xops;
+	unsigned int errors;
 };
 
+extern struct mips_fpu_emulator_stats fpuemustats;
+
 #endif /* _ASM_FPU_EMULATOR_H */
diff -Naur linux-2.6.14/include/asm-mips/fpu.h linux-mips-2.6.14.orig/include/asm-mips/fpu.h
--- linux-2.6.14/include/asm-mips/fpu.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/fpu.h	2005-11-17 11:44:27.000000000 -0800
@@ -80,9 +80,14 @@
 
 #define clear_fpu_owner()	clear_thread_flag(TIF_USEDFPU)
 
+static inline int __is_fpu_owner(void)
+{
+	return test_thread_flag(TIF_USEDFPU);
+}
+
 static inline int is_fpu_owner(void)
 {
-	return cpu_has_fpu && test_thread_flag(TIF_USEDFPU);
+	return cpu_has_fpu && __is_fpu_owner();
 }
 
 static inline void own_fpu(void)
@@ -127,7 +132,7 @@
 static inline fpureg_t *get_fpu_regs(struct task_struct *tsk)
 {
 	if (cpu_has_fpu) {
-		if ((tsk == current) && is_fpu_owner())
+		if ((tsk == current) && __is_fpu_owner())
 			_save_fp(current);
 		return tsk->thread.fpu.hard.fpr;
 	}
diff -Naur linux-2.6.14/include/asm-mips/futex.h linux-mips-2.6.14.orig/include/asm-mips/futex.h
--- linux-2.6.14/include/asm-mips/futex.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/futex.h	2005-11-17 11:44:27.000000000 -0800
@@ -3,10 +3,45 @@
 
 #ifdef __KERNEL__
 
+#include <linux/config.h>
 #include <linux/futex.h>
 #include <asm/errno.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_SMP
+#define __FUTEX_SMP_SYNC "	sync					\n"
+#else
+#define __FUTEX_SMP_SYNC
+#endif
+
+#define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)		\
+{									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	.set	mips3					\n"	\
+	"1:	ll	%1, (%3)	# __futex_atomic_op1	\n"	\
+	"	.set	mips0					\n"	\
+	"	" insn	"					\n"	\
+	"	.set	mips3					\n"	\
+	"2:	sc	$1, (%3)				\n"	\
+	"	beqzl	$1, 1b					\n"	\
+	__FUTEX_SMP_SYNC						\
+	"3:							\n"	\
+	"	.set	pop					\n"	\
+	"	.set	mips0					\n"	\
+	"	.section .fixup,\"ax\"				\n"	\
+	"4:	li	%0, %5					\n"	\
+	"	j	2b					\n"	\
+	"	.previous					\n"	\
+	"	.section __ex_table,\"a\"			\n"	\
+	"	"__UA_ADDR "\t1b, 4b				\n"	\
+	"	"__UA_ADDR "\t2b, 4b				\n"	\
+	"	.previous					\n"	\
+	: "=r" (ret), "=r" (oldval)					\
+	: "0" (0), "r" (uaddr), "Jr" (oparg), "i" (-EFAULT));		\
+}
+
 static inline int
 futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
 {
@@ -25,10 +60,25 @@
 
 	switch (op) {
 	case FUTEX_OP_SET:
+		__futex_atomic_op("move	$1, %z4", ret, oldval, uaddr, oparg);
+		break;
+
 	case FUTEX_OP_ADD:
+		__futex_atomic_op("addu	$1, %1, %z4",
+		                  ret, oldval, uaddr, oparg);
+		break;
 	case FUTEX_OP_OR:
+		__futex_atomic_op("or	$1, %1, %z4",
+		                  ret, oldval, uaddr, oparg);
+		break;
 	case FUTEX_OP_ANDN:
+		__futex_atomic_op("and	$1, %1, %z4",
+		                  ret, oldval, uaddr, ~oparg);
+		break;
 	case FUTEX_OP_XOR:
+		__futex_atomic_op("xor	$1, %1, %z4",
+		                  ret, oldval, uaddr, oparg);
+		break;
 	default:
 		ret = -ENOSYS;
 	}
diff -Naur linux-2.6.14/include/asm-mips/hazards.h linux-mips-2.6.14.orig/include/asm-mips/hazards.h
--- linux-2.6.14/include/asm-mips/hazards.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/hazards.h	2005-11-17 11:44:27.000000000 -0800
@@ -74,7 +74,8 @@
 #define irq_disable_hazard
 	_ehb
 
-#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
+#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000) || \
+      defined(CONFIG_CPU_SB1)
 
 /*
  * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
@@ -107,6 +108,7 @@
 	"	.endm						\n\t");
 
 #ifdef CONFIG_CPU_RM9000
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
@@ -124,6 +126,9 @@
 		".set\tmips32\n\t"					\
 		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
+
+#define back_to_back_c0_hazard()	do { } while (0)
+
 #else
 
 /*
@@ -144,15 +149,13 @@
 #endif
 
 /*
- * mtc0->mfc0 hazard
- * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
- * It is a MIPS32R2 processor so ehb will clear the hazard.
+ * Interrupt enable/disable hazards
+ * Some processors have hazards when modifying
+ * the status register to change the interrupt state
  */
 
 #ifdef CONFIG_CPU_MIPSR2
-/*
- * Use a macro for ehb unless explicit support for MIPSR2 is enabled
- */
+
 __asm__(
 	"	.macro\tirq_enable_hazard			\n\t"
 	"	_ehb						\n\t"
@@ -160,17 +163,26 @@
 	"							\n\t"
 	"	.macro\tirq_disable_hazard			\n\t"
 	"	_ehb						\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tback_to_back_c0_hazard			\n\t"
+	"	_ehb						\n\t"
 	"	.endm");
 
 #define irq_enable_hazard()						\
 	__asm__ __volatile__(						\
-	"_ehb\t\t\t\t# irq_enable_hazard")
+	"irq_enable_hazard")
 
 #define irq_disable_hazard()						\
 	__asm__ __volatile__(						\
-	"_ehb\t\t\t\t# irq_disable_hazard")
+	"irq_disable_hazard")
 
-#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
+#define back_to_back_c0_hazard()					\
+	__asm__ __volatile__(						\
+	"back_to_back_c0_hazard")
+
+#elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000) || \
+      defined(CONFIG_CPU_SB1)
 
 /*
  * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
@@ -186,6 +198,8 @@
 #define irq_enable_hazard()	do { } while (0)
 #define irq_disable_hazard()	do { } while (0)
 
+#define back_to_back_c0_hazard()	do { } while (0)
+
 #else
 
 /*
@@ -208,8 +222,30 @@
 #define irq_enable_hazard()	do { } while (0)
 #define irq_disable_hazard()						\
 	__asm__ __volatile__(						\
-	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
+	"irq_disable_hazard")
 
+#define back_to_back_c0_hazard()					\
+	__asm__ __volatile__(						\
+	"	.set noreorder				\n"		\
+	"	nop; nop; nop				\n"		\
+	"	.set reorder				\n")
+
+#endif
+
+#ifdef CONFIG_CPU_MIPSR2
+#define instruction_hazard()						\
+do {									\
+__label__ __next;							\
+	__asm__ __volatile__(						\
+	"	jr.hb	%0					\n"	\
+	:								\
+	: "r" (&&__next));						\
+__next:									\
+	;								\
+} while (0)
+
+#else
+#define instruction_hazard() do { } while (0)
 #endif
 
 #endif /* __ASSEMBLY__ */
diff -Naur linux-2.6.14/include/asm-mips/highmem.h linux-mips-2.6.14.orig/include/asm-mips/highmem.h
--- linux-2.6.14/include/asm-mips/highmem.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/highmem.h	2005-11-17 11:44:27.000000000 -0800
@@ -75,6 +75,7 @@
 }
 
 static inline void kunmap_atomic(void *kvaddr, enum km_type type) { }
+#define kmap_atomic_pfn(pfn, idx)	page_address(pfn_to_page(pfn))
 
 #define kmap_atomic_to_page(ptr) virt_to_page(ptr)
 
@@ -86,6 +87,7 @@
 extern void __kunmap(struct page *page);
 extern void *__kmap_atomic(struct page *page, enum km_type type);
 extern void __kunmap_atomic(void *kvaddr, enum km_type type);
+extern void *kmap_atomic_pfn(unsigned long pfn, enum km_type type);
 extern struct page *__kmap_atomic_to_page(void *ptr);
 
 #define kmap			__kmap
diff -Naur linux-2.6.14/include/asm-mips/inst.h linux-mips-2.6.14.orig/include/asm-mips/inst.h
--- linux-2.6.14/include/asm-mips/inst.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/inst.h	2005-11-17 11:44:27.000000000 -0800
@@ -28,7 +28,7 @@
 	sdl_op, sdr_op, swr_op, cache_op,
 	ll_op, lwc1_op, lwc2_op, pref_op,
 	lld_op, ldc1_op, ldc2_op, ld_op,
-	sc_op, swc1_op, swc2_op, major_3b_op, /* Opcode 0x3b is unused */
+	sc_op, swc1_op, swc2_op, rdhwr_op,
 	scd_op, sdc1_op, sdc2_op, sd_op
 };
 
@@ -62,10 +62,10 @@
 	spimi_op, unused_rt_op_0x05, unused_rt_op_0x06, unused_rt_op_0x07,
 	tgei_op, tgeiu_op, tlti_op, tltiu_op,
 	teqi_op, unused_0x0d_rt_op, tnei_op, unused_0x0f_rt_op,
-	bltzal_op, bgezal_op, bltzall_op, bgezall_op
-	/*
-	 * The others (0x14 - 0x1f) are unused.
- 	 */
+	bltzal_op, bgezal_op, bltzall_op, bgezall_op,
+	rt_op_0x14, rt_op_0x15, rt_op_0x16, rt_op_0x17,
+	rt_op_0x18, rt_op_0x19, rt_op_0x1a, rt_op_0x1b,
+	bposge32_op, rt_op_0x1d, rt_op_0x1e, rt_op_0x1f
 };
 
 /*
diff -Naur linux-2.6.14/include/asm-mips/interrupt.h linux-mips-2.6.14.orig/include/asm-mips/interrupt.h
--- linux-2.6.14/include/asm-mips/interrupt.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/interrupt.h	2005-11-17 11:44:27.000000000 -0800
@@ -11,20 +11,25 @@
 #ifndef _ASM_INTERRUPT_H
 #define _ASM_INTERRUPT_H
 
+#include <linux/config.h>
 #include <asm/hazards.h>
 
 __asm__ (
-	".macro\tlocal_irq_enable\n\t"
-	".set\tpush\n\t"
-	".set\treorder\n\t"
-	".set\tnoat\n\t"
-	"mfc0\t$1,$12\n\t"
-	"ori\t$1,0x1f\n\t"
-	"xori\t$1,0x1e\n\t"
-	"mtc0\t$1,$12\n\t"
-	"irq_enable_hazard\n\t"
-	".set\tpop\n\t"
-	".endm");
+	"	.macro	local_irq_enable				\n"
+	"	.set	push						\n"
+	"	.set	reorder						\n"
+	"	.set	noat						\n"
+#ifdef CONFIG_CPU_MIPSR2
+	"	ei							\n"
+#else
+	"	mfc0	$1,$12						\n"
+	"	ori	$1,0x1f						\n"
+	"	xori	$1,0x1e						\n"
+	"	mtc0	$1,$12						\n"
+#endif
+	"	irq_enable_hazard					\n"
+	"	.set	pop						\n"
+	"	.endm");
 
 static inline void local_irq_enable(void)
 {
@@ -43,17 +48,21 @@
  * no nops at all.
  */
 __asm__ (
-	".macro\tlocal_irq_disable\n\t"
-	".set\tpush\n\t"
-	".set\tnoat\n\t"
-	"mfc0\t$1,$12\n\t"
-	"ori\t$1,1\n\t"
-	"xori\t$1,1\n\t"
-	".set\tnoreorder\n\t"
-	"mtc0\t$1,$12\n\t"
-	"irq_disable_hazard\n\t"
-	".set\tpop\n\t"
-	".endm");
+	"	.macro	local_irq_disable\n"
+	"	.set	push						\n"
+	"	.set	noat						\n"
+#ifdef CONFIG_CPU_MIPSR2
+	"	di							\n"
+#else
+	"	mfc0	$1,$12						\n"
+	"	ori	$1,1						\n"
+	"	xori	$1,1						\n"
+	"	.set	noreorder					\n"
+	"	mtc0	$1,$12						\n"
+#endif
+	"	irq_disable_hazard					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
 
 static inline void local_irq_disable(void)
 {
@@ -65,12 +74,12 @@
 }
 
 __asm__ (
-	".macro\tlocal_save_flags flags\n\t"
-	".set\tpush\n\t"
-	".set\treorder\n\t"
-	"mfc0\t\\flags, $12\n\t"
-	".set\tpop\n\t"
-	".endm");
+	"	.macro	local_save_flags flags				\n"
+	"	.set	push						\n"
+	"	.set	reorder						\n"
+	"	mfc0	\\flags, $12					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
 
 #define local_save_flags(x)						\
 __asm__ __volatile__(							\
@@ -78,18 +87,22 @@
 	: "=r" (x))
 
 __asm__ (
-	".macro\tlocal_irq_save result\n\t"
-	".set\tpush\n\t"
-	".set\treorder\n\t"
-	".set\tnoat\n\t"
-	"mfc0\t\\result, $12\n\t"
-	"ori\t$1, \\result, 1\n\t"
-	"xori\t$1, 1\n\t"
-	".set\tnoreorder\n\t"
-	"mtc0\t$1, $12\n\t"
-	"irq_disable_hazard\n\t"
-	".set\tpop\n\t"
-	".endm");
+	"	.macro	local_irq_save result				\n"
+	"	.set	push						\n"
+	"	.set	reorder						\n"
+	"	.set	noat						\n"
+#ifdef CONFIG_CPU_MIPSR2
+	"	di	\\result					\n"
+#else
+	"	mfc0	\\result, $12					\n"
+	"	ori	$1, \\result, 1					\n"
+	"	xori	$1, 1						\n"
+	"	.set	noreorder					\n"
+	"	mtc0	$1, $12						\n"
+#endif
+	"	irq_disable_hazard					\n"
+	"	.set	pop						\n"
+	"	.endm							\n");
 
 #define local_irq_save(x)						\
 __asm__ __volatile__(							\
@@ -99,19 +112,37 @@
 	: "memory")
 
 __asm__ (
-	".macro\tlocal_irq_restore flags\n\t"
-	".set\tnoreorder\n\t"
-	".set\tnoat\n\t"
-	"mfc0\t$1, $12\n\t"
-	"andi\t\\flags, 1\n\t"
-	"ori\t$1, 1\n\t"
-	"xori\t$1, 1\n\t"
-	"or\t\\flags, $1\n\t"
-	"mtc0\t\\flags, $12\n\t"
-	"irq_disable_hazard\n\t"
-	".set\tat\n\t"
-	".set\treorder\n\t"
-	".endm");
+	"	.macro	local_irq_restore flags				\n"
+	"	.set	noreorder					\n"
+	"	.set	noat						\n"
+#if defined(CONFIG_CPU_MIPSR2) && defined(CONFIG_IRQ_CPU)
+	/*
+	 * Slow, but doesn't suffer from a relativly unlikely race
+	 * condition we're having since days 1.
+	 */
+	"	beqz	\\flags, 1f					\n"
+	"	 di							\n"
+	"	ei							\n"
+	"1:								\n"
+#elif defined(CONFIG_CPU_MIPSR2)
+	/*
+	 * Fast, dangerous.  Life is fun, life is good.
+	 */
+	"	mfc0	$1, $12						\n"
+	"	ins	$1, \\flags, 0, 1				\n"
+	"	mtc0	$1, $12						\n"
+#else
+	"	mfc0	$1, $12						\n"
+	"	andi	\\flags, 1					\n"
+	"	ori	$1, 1						\n"
+	"	xori	$1, 1						\n"
+	"	or	\\flags, $1					\n"
+	"	mtc0	\\flags, $12					\n"
+#endif
+	"	irq_disable_hazard					\n"
+	"	.set	at						\n"
+	"	.set	reorder						\n"
+	"	.endm							\n");
 
 #define local_irq_restore(flags)					\
 do {									\
diff -Naur linux-2.6.14/include/asm-mips/inventory.h linux-mips-2.6.14.orig/include/asm-mips/inventory.h
--- linux-2.6.14/include/asm-mips/inventory.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/inventory.h	2005-11-17 11:44:27.000000000 -0800
@@ -4,6 +4,8 @@
 #ifndef __ASM_INVENTORY_H
 #define __ASM_INVENTORY_H
 
+#include <linux/compiler.h>
+
 typedef struct inventory_s {
 	struct inventory_s *inv_next;
 	int    inv_class;
@@ -14,7 +16,9 @@
 } inventory_t;
 
 extern int inventory_items;
-void add_to_inventory (int class, int type, int controller, int unit, int state);
-int dump_inventory_to_user (void *userbuf, int size);
+
+extern void add_to_inventory (int class, int type, int controller, int unit, int state);
+extern int dump_inventory_to_user (void __user *userbuf, int size);
+extern int __init init_inventory(void);
 
 #endif /* __ASM_INVENTORY_H */
diff -Naur linux-2.6.14/include/asm-mips/io.h linux-mips-2.6.14.orig/include/asm-mips/io.h
--- linux-2.6.14/include/asm-mips/io.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/io.h	2005-11-17 11:44:27.000000000 -0800
@@ -25,7 +25,9 @@
 #include <asm/page.h>
 #include <asm/pgtable-bits.h>
 #include <asm/processor.h>
+#include <asm/string.h>
 
+#include <ioremap.h>
 #include <mangle-port.h>
 
 /*
@@ -34,7 +36,7 @@
 #undef CONF_SLOWDOWN_IO
 
 /*
- * Raw operations are never swapped in software.  Otoh values that raw
+ * Raw operations are never swapped in software.  OTOH values that raw
  * operations are working on may or may not have been swapped by the bus
  * hardware.  An example use would be for flash memory that's used for
  * execute in place.
@@ -43,45 +45,53 @@
 # define __raw_ioswabw(x)	(x)
 # define __raw_ioswabl(x)	(x)
 # define __raw_ioswabq(x)	(x)
+# define ____raw_ioswabq(x)	(x)
 
 /*
  * Sane hardware offers swapping of PCI/ISA I/O space accesses in hardware;
  * less sane hardware forces software to fiddle with this...
+ *
+ * Regardless, if the host bus endianness mismatches that of PCI/ISA, then
+ * you can't have the numerical value of data and byte addresses within
+ * multibyte quantities both preserved at the same time.  Hence two
+ * variations of functions: non-prefixed ones that preserve the value
+ * and prefixed ones that preserve byte addresses.  The latters are
+ * typically used for moving raw data between a peripheral and memory (cf.
+ * string I/O functions), hence the "mem_" prefix.
  */
 #if defined(CONFIG_SWAP_IO_SPACE)
 
 # define ioswabb(x)		(x)
+# define mem_ioswabb(x)		(x)
 # ifdef CONFIG_SGI_IP22
 /*
  * IP22 seems braindead enough to swap 16bits values in hardware, but
  * not 32bits.  Go figure... Can't tell without documentation.
  */
 #  define ioswabw(x)		(x)
+#  define mem_ioswabw(x)	le16_to_cpu(x)
 # else
 #  define ioswabw(x)		le16_to_cpu(x)
+#  define mem_ioswabw(x)	(x)
 # endif
 # define ioswabl(x)		le32_to_cpu(x)
+# define mem_ioswabl(x)		(x)
 # define ioswabq(x)		le64_to_cpu(x)
+# define mem_ioswabq(x)		(x)
 
 #else
 
 # define ioswabb(x)		(x)
+# define mem_ioswabb(x)		(x)
 # define ioswabw(x)		(x)
+# define mem_ioswabw(x)		cpu_to_le16(x)
 # define ioswabl(x)		(x)
+# define mem_ioswabl(x)		cpu_to_le32(x)
 # define ioswabq(x)		(x)
+# define mem_ioswabq(x)		cpu_to_le32(x)
 
 #endif
 
-/*
- * Native bus accesses never swapped.
- */
-#define bus_ioswabb(x)		(x)
-#define bus_ioswabw(x)		(x)
-#define bus_ioswabl(x)		(x)
-#define bus_ioswabq(x)		(x)
-
-#define __bus_ioswabq		bus_ioswabq
-
 #define IO_SPACE_LIMIT 0xffff
 
 /*
@@ -194,12 +204,14 @@
  */
 #define page_to_phys(page)	((dma_addr_t)page_to_pfn(page) << PAGE_SHIFT)
 
-extern void * __ioremap(phys_t offset, phys_t size, unsigned long flags);
+extern void __iomem * __ioremap(phys_t offset, phys_t size, unsigned long flags);
 extern void __iounmap(volatile void __iomem *addr);
 
-static inline void * __ioremap_mode(phys_t offset, unsigned long size,
+static inline void __iomem * __ioremap_mode(phys_t offset, unsigned long size,
 	unsigned long flags)
 {
+#define __IS_LOW512(addr) (!((phys_t)(addr) & (phys_t) ~0x1fffffffULL))
+
 	if (cpu_has_64bit_addresses) {
 		u64 base = UNCAC_BASE;
 
@@ -209,10 +221,30 @@
 		 */
 		if (flags == _CACHE_UNCACHED)
 			base = (u64) IO_BASE;
-		return (void *) (unsigned long) (base + offset);
+		return (void __iomem *) (unsigned long) (base + offset);
+	} else if (__builtin_constant_p(offset) &&
+		   __builtin_constant_p(size) && __builtin_constant_p(flags)) {
+		phys_t phys_addr, last_addr;
+
+		phys_addr = fixup_bigphys_addr(offset, size);
+
+		/* Don't allow wraparound or zero size. */
+		last_addr = phys_addr + size - 1;
+		if (!size || last_addr < phys_addr)
+			return NULL;
+
+		/*
+		 * Map uncached objects in the low 512MB of address
+		 * space using KSEG1.
+		 */
+		if (__IS_LOW512(phys_addr) && __IS_LOW512(last_addr) &&
+		    flags == _CACHE_UNCACHED)
+			return (void __iomem *)CKSEG1ADDR(phys_addr);
 	}
 
 	return __ioremap(offset, size, flags);
+
+#undef __IS_LOW512
 }
 
 /*
@@ -264,12 +296,16 @@
 
 static inline void iounmap(volatile void __iomem *addr)
 {
-	if (cpu_has_64bit_addresses)
+#define __IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == CKSEG1)
+
+	if (cpu_has_64bit_addresses ||
+	    (__builtin_constant_p(addr) && __IS_KSEG1(addr)))
 		return;
 
 	__iounmap(addr);
-}
 
+#undef __IS_KSEG1
+}
 
 #define __BUILD_MEMORY_SINGLE(pfx, bwlq, type, irq)			\
 									\
@@ -319,7 +355,8 @@
 	else if (cpu_has_64bits) {					\
 		unsigned long __flags;					\
 									\
-		local_irq_save(__flags);				\
+		if (irq)						\
+			local_irq_save(__flags);			\
 		__asm__ __volatile__(					\
 			".set	mips3"		"\t\t# __readq"	"\n\t"	\
 			"ld	%L0, %1"			"\n\t"	\
@@ -328,7 +365,8 @@
 			".set	mips0"				"\n"	\
 			: "=r" (__val)					\
 			: "m" (*__mem));				\
-		local_irq_restore(__flags);				\
+		if (irq)						\
+			local_irq_restore(__flags);			\
 	} else {							\
 		__val = 0;						\
 		BUG();							\
@@ -349,11 +387,11 @@
 									\
 	__val = pfx##ioswab##bwlq(val);					\
 									\
-	if (sizeof(type) != sizeof(u64)) {				\
-		*__addr = __val;					\
-		slow;							\
-	} else								\
-		BUILD_BUG();						\
+	/* Really, we want this to be atomic */				\
+	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
+									\
+	*__addr = __val;						\
+	slow;								\
 }									\
 									\
 static inline type pfx##in##bwlq##p(unsigned long port)			\
@@ -364,13 +402,10 @@
 	port = __swizzle_addr_##bwlq(port);				\
 	__addr = (void *)(mips_io_port_base + port);			\
 									\
-	if (sizeof(type) != sizeof(u64)) {				\
-		__val = *__addr;					\
-		slow;							\
-	} else {							\
-		__val = 0;						\
-		BUILD_BUG();						\
-	}								\
+	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
+									\
+	__val = *__addr;						\
+	slow;								\
 									\
 	return pfx##ioswab##bwlq(__val);				\
 }
@@ -379,27 +414,35 @@
 									\
 __BUILD_MEMORY_SINGLE(bus, bwlq, type, 1)
 
-#define __BUILD_IOPORT_PFX(bus, bwlq, type)				\
-									\
-__BUILD_IOPORT_SINGLE(bus, bwlq, type, ,)				\
-__BUILD_IOPORT_SINGLE(bus, bwlq, type, _p, SLOW_DOWN_IO)
-
-#define BUILDIO(bwlq, type)						\
+#define BUILDIO_MEM(bwlq, type)						\
 									\
-__BUILD_MEMORY_PFX(, bwlq, type)					\
 __BUILD_MEMORY_PFX(__raw_, bwlq, type)					\
-__BUILD_MEMORY_PFX(bus_, bwlq, type)					\
-__BUILD_IOPORT_PFX(, bwlq, type)					\
-__BUILD_IOPORT_PFX(__raw_, bwlq, type)
+__BUILD_MEMORY_PFX(, bwlq, type)					\
+__BUILD_MEMORY_PFX(mem_, bwlq, type)					\
+
+BUILDIO_MEM(b, u8)
+BUILDIO_MEM(w, u16)
+BUILDIO_MEM(l, u32)
+BUILDIO_MEM(q, u64)
+
+#define __BUILD_IOPORT_PFX(bus, bwlq, type)				\
+	__BUILD_IOPORT_SINGLE(bus, bwlq, type, ,)			\
+	__BUILD_IOPORT_SINGLE(bus, bwlq, type, _p, SLOW_DOWN_IO)
+
+#define BUILDIO_IOPORT(bwlq, type)					\
+	__BUILD_IOPORT_PFX(, bwlq, type)				\
+	__BUILD_IOPORT_PFX(mem_, bwlq, type)
+
+BUILDIO_IOPORT(b, u8)
+BUILDIO_IOPORT(w, u16)
+BUILDIO_IOPORT(l, u32)
+#ifdef CONFIG_64BIT
+BUILDIO_IOPORT(q, u64)
+#endif
 
 #define __BUILDIO(bwlq, type)						\
 									\
-__BUILD_MEMORY_SINGLE(__bus_, bwlq, type, 0)
-
-BUILDIO(b, u8)
-BUILDIO(w, u16)
-BUILDIO(l, u32)
-BUILDIO(q, u64)
+__BUILD_MEMORY_SINGLE(____raw_, bwlq, type, 0)
 
 __BUILDIO(q, u64)
 
@@ -422,7 +465,7 @@
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		__raw_write##bwlq(*__addr, mem);			\
+		mem_write##bwlq(*__addr, mem);				\
 		__addr++;						\
 	}								\
 }									\
@@ -433,20 +476,20 @@
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		*__addr = __raw_read##bwlq(mem);			\
+		*__addr = mem_read##bwlq(mem);				\
 		__addr++;						\
 	}								\
 }
 
 #define __BUILD_IOPORT_STRING(bwlq, type)				\
 									\
-static inline void outs##bwlq(unsigned long port, void *addr,		\
+static inline void outs##bwlq(unsigned long port, const void *addr,	\
 			      unsigned int count)			\
 {									\
-	volatile type *__addr = addr;					\
+	const volatile type *__addr = addr;				\
 									\
 	while (count--) {						\
-		__raw_out##bwlq(*__addr, port);				\
+		mem_out##bwlq(*__addr, port);				\
 		__addr++;						\
 	}								\
 }									\
@@ -457,7 +500,7 @@
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		*__addr = __raw_in##bwlq(port);				\
+		*__addr = mem_in##bwlq(port);				\
 		__addr++;						\
 	}								\
 }
@@ -470,43 +513,26 @@
 BUILDSTRING(b, u8)
 BUILDSTRING(w, u16)
 BUILDSTRING(l, u32)
+#ifdef CONFIG_64BIT
 BUILDSTRING(q, u64)
+#endif
 
 
 /* Depends on MIPS II instruction set */
 #define mmiowb() asm volatile ("sync" ::: "memory")
 
-#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
-#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
-#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
-
-/*
- * Memory Mapped I/O
- */
-#define ioread8(addr)		readb(addr)
-#define ioread16(addr)		readw(addr)
-#define ioread32(addr)		readl(addr)
-
-#define iowrite8(b,addr)	writeb(b,addr)
-#define iowrite16(w,addr)	writew(w,addr)
-#define iowrite32(l,addr)	writel(l,addr)
-
-#define ioread8_rep(a,b,c)	readsb(a,b,c)
-#define ioread16_rep(a,b,c)	readsw(a,b,c)
-#define ioread32_rep(a,b,c)	readsl(a,b,c)
-
-#define iowrite8_rep(a,b,c)	writesb(a,b,c)
-#define iowrite16_rep(a,b,c)	writesw(a,b,c)
-#define iowrite32_rep(a,b,c)	writesl(a,b,c)
-
-/* Create a virtual mapping cookie for an IO port range */
-extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
-extern void ioport_unmap(void __iomem *);
-
-/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
-struct pci_dev;
-extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
-extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+static inline void memset_io(volatile void __iomem *addr, unsigned char val, int count)
+{
+	memset((void __force *) addr, val, count);
+}
+static inline void memcpy_fromio(void *dst, const volatile void __iomem *src, int count)
+{
+	memcpy(dst, (void __force *) src, count);
+}
+static inline void memcpy_toio(volatile void __iomem *dst, const void *src, int count)
+{
+	memcpy((void __force *) dst, src, count);
+}
 
 /*
  * ISA space is 'always mapped' on currently supported MIPS systems, no need
diff -Naur linux-2.6.14/include/asm-mips/ip32/mace.h linux-mips-2.6.14.orig/include/asm-mips/ip32/mace.h
--- linux-2.6.14/include/asm-mips/ip32/mace.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/ip32/mace.h	2005-11-17 11:44:27.000000000 -0800
@@ -277,7 +277,25 @@
  */
 
 /* Parallel port */
-struct mace_parallel {	/* later... */
+struct mace_parallel {
+/* 0 - do nothing, 1 - pulse terminal count to the device after buffer is drained */ 
+#define MACEPAR_CONTEXT_LASTFLAG BIT(63)
+/* Should not cross 4K page boundary */
+#define MACEPAR_CONTEXT_DATALEN_MASK 0xfff00000000
+/* Can be arbitrarily aligned on any byte boundary on output, 64 byte aligned on input */
+#define MACEPAR_CONTEXT_BASEADDR_MASK 0xffffffff
+	volatile u64 context_a;
+	volatile u64 context_b;
+#define MACEPAR_CTLSTAT_DIRECTION BIT(0) /* 0 - mem->device, 1 - device->mem */
+#define MACEPAR_CTLSTAT_ENABLE BIT(1) /* 0 - channel frozen, 1 - channel enabled */
+#define MACEPAR_CTLSTAT_RESET BIT(2) /* 0 - channel active, 1 - complete channel reset */
+#define MACEPAR_CTLSTAT_CTXB_VALID BIT(3)
+#define MACEPAR_CTLSTAT_CTXA_VALID BIT(4)
+	volatile u64 cntlstat; /* Control/Status register */
+#define MACEPAR_DIAG_CTXINUSE BIT(1)
+#define MACEPAR_DIAG_DMACTIVE BIT(2) /* 1 - Dma engine is enabled and processing something */
+#define MACEPAR_DIAG_CTRMASK 0x3ffc /* Counter of bytes left */
+	volatile u64 diagnostic; /* RO: diagnostic register */
 };
 
 struct mace_ecp1284 {	/* later... */
diff -Naur linux-2.6.14/include/asm-mips/irq.h linux-mips-2.6.14.orig/include/asm-mips/irq.h
--- linux-2.6.14/include/asm-mips/irq.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/irq.h	2005-11-17 11:44:27.000000000 -0800
@@ -24,11 +24,9 @@
 
 struct pt_regs;
 
-#ifdef CONFIG_PREEMPT
-
 extern asmlinkage unsigned int do_IRQ(unsigned int irq, struct pt_regs *regs);
 
-#else
+#ifdef CONFIG_PREEMPT
 
 /*
  * do_IRQ handles all normal device IRQ's (the special
diff -Naur linux-2.6.14/include/asm-mips/jmr3927/jmr3927.h linux-mips-2.6.14.orig/include/asm-mips/jmr3927/jmr3927.h
--- linux-2.6.14/include/asm-mips/jmr3927/jmr3927.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/jmr3927/jmr3927.h	2005-11-17 11:44:27.000000000 -0800
@@ -202,20 +202,6 @@
 #endif /* !__ASSEMBLY__ */
 
 /*
- * UART defines for serial.h
- */
-
-/* use Pre-scaler T0 (1/2) */
-#define JMR3927_BASE_BAUD (JMR3927_IMCLK / 2 / 16)
-
-#define UART0_ADDR   0xfffef300
-#define UART1_ADDR   0xfffef400
-#define UART0_INT    JMR3927_IRQ_IRC_SIO0
-#define UART1_INT    JMR3927_IRQ_IRC_SIO1
-#define UART0_FLAGS  ASYNC_BOOT_AUTOCONF
-#define UART1_FLAGS  0
-
-/*
  * IRQ mappings
  */
 
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/au1000.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1000.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/au1000.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1000.h	2005-11-17 11:44:27.000000000 -0800
@@ -60,59 +60,36 @@
 	mdelay(ms);
 }
 
-void static inline au_writeb(u8 val, int reg)
+void static inline au_writeb(u8 val, unsigned long reg)
 {
 	*(volatile u8 *)(reg) = val;
 }
 
-void static inline au_writew(u16 val, int reg)
+void static inline au_writew(u16 val, unsigned long reg)
 {
 	*(volatile u16 *)(reg) = val;
 }
 
-void static inline au_writel(u32 val, int reg)
+void static inline au_writel(u32 val, unsigned long reg)
 {
 	*(volatile u32 *)(reg) = val;
 }
 
-static inline u8 au_readb(unsigned long port)
+static inline u8 au_readb(unsigned long reg)
 {
-	return (*(volatile u8 *)port);
+	return (*(volatile u8 *)reg);
 }
 
-static inline u16 au_readw(unsigned long port)
+static inline u16 au_readw(unsigned long reg)
 {
-	return (*(volatile u16 *)port);
+	return (*(volatile u16 *)reg);
 }
 
-static inline u32 au_readl(unsigned long port)
+static inline u32 au_readl(unsigned long reg)
 {
-	return (*(volatile u32 *)port);
+	return (*(volatile u32 *)reg);
 }
 
-/* These next three functions should be a generic part of the MIPS
- * kernel (with the 'au_' removed from the name) and selected for
- * processors that support the instructions.
- * Taken from PPC tree.  -- Dan
- */
-/* Return the bit position of the most significant 1 bit in a word */
-static __inline__ int __ilog2(unsigned int x)
-{
-	int lz;
-
-	asm volatile (
-		".set\tnoreorder\n\t"
-		".set\tnoat\n\t"
-		".set\tmips32\n\t"
-		"clz\t%0,%1\n\t"
-		".set\tmips0\n\t"
-		".set\tat\n\t"
-		".set\treorder"
-		: "=r" (lz)
-		: "r" (x));
-
-	return 31 - lz;
-}
 
 static __inline__ int au_ffz(unsigned int x)
 {
@@ -162,28 +139,293 @@
 #define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
 #endif
 
-/* SDRAM Controller */
+/*
+ * SDRAM Register Offsets
+ */
 #if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
-#define MEM_SDMODE0                0xB4000000
-#define MEM_SDMODE1                0xB4000004
-#define MEM_SDMODE2                0xB4000008
-
-#define MEM_SDADDR0                0xB400000C
-#define MEM_SDADDR1                0xB4000010
-#define MEM_SDADDR2                0xB4000014
-
-#define MEM_SDREFCFG               0xB4000018
-#define MEM_SDPRECMD               0xB400001C
-#define MEM_SDAUTOREF              0xB4000020
-
-#define MEM_SDWRMD0                0xB4000024
-#define MEM_SDWRMD1                0xB4000028
-#define MEM_SDWRMD2                0xB400002C
+#define MEM_SDMODE0		(0x0000)
+#define MEM_SDMODE1		(0x0004)
+#define MEM_SDMODE2		(0x0008)
+#define MEM_SDADDR0		(0x000C)
+#define MEM_SDADDR1		(0x0010)
+#define MEM_SDADDR2		(0x0014)
+#define MEM_SDREFCFG	(0x0018)
+#define MEM_SDPRECMD	(0x001C)
+#define MEM_SDAUTOREF	(0x0020)
+#define MEM_SDWRMD0		(0x0024)
+#define MEM_SDWRMD1		(0x0028)
+#define MEM_SDWRMD2		(0x002C)
+#define MEM_SDSLEEP		(0x0030)
+#define MEM_SDSMCKE		(0x0034)
+
+/*
+ * MEM_SDMODE register content definitions
+ */
+#define MEM_SDMODE_F		(1<<22)
+#define MEM_SDMODE_SR		(1<<21)
+#define MEM_SDMODE_BS		(1<<20)
+#define MEM_SDMODE_RS		(3<<18)
+#define MEM_SDMODE_CS		(7<<15)
+#define MEM_SDMODE_TRAS		(15<<11)
+#define MEM_SDMODE_TMRD		(3<<9)
+#define MEM_SDMODE_TWR		(3<<7)
+#define MEM_SDMODE_TRP		(3<<5)
+#define MEM_SDMODE_TRCD		(3<<3)
+#define MEM_SDMODE_TCL		(7<<0)
+
+#define MEM_SDMODE_BS_2Bank	(0<<20)
+#define MEM_SDMODE_BS_4Bank	(1<<20)
+#define MEM_SDMODE_RS_11Row	(0<<18)
+#define MEM_SDMODE_RS_12Row	(1<<18)
+#define MEM_SDMODE_RS_13Row	(2<<18)
+#define MEM_SDMODE_RS_N(N)	((N)<<18)
+#define MEM_SDMODE_CS_7Col	(0<<15)
+#define MEM_SDMODE_CS_8Col	(1<<15)
+#define MEM_SDMODE_CS_9Col	(2<<15)
+#define MEM_SDMODE_CS_10Col	(3<<15)
+#define MEM_SDMODE_CS_11Col	(4<<15)
+#define MEM_SDMODE_CS_N(N)		((N)<<15)
+#define MEM_SDMODE_TRAS_N(N)	((N)<<11)
+#define MEM_SDMODE_TMRD_N(N)	((N)<<9)
+#define MEM_SDMODE_TWR_N(N)		((N)<<7)
+#define MEM_SDMODE_TRP_N(N)		((N)<<5)
+#define MEM_SDMODE_TRCD_N(N)	((N)<<3)
+#define MEM_SDMODE_TCL_N(N)		((N)<<0)
+
+/*
+ * MEM_SDADDR register contents definitions
+ */
+#define MEM_SDADDR_E			(1<<20)
+#define MEM_SDADDR_CSBA			(0x03FF<<10)
+#define MEM_SDADDR_CSMASK		(0x03FF<<0)
+#define MEM_SDADDR_CSBA_N(N)	((N)&(0x03FF<<22)>>12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF<<22)>>22)
 
-#define MEM_SDSLEEP                0xB4000030
-#define MEM_SDSMCKE                0xB4000034
+/*
+ * MEM_SDREFCFG register content definitions
+ */
+#define MEM_SDREFCFG_TRC		(15<<28)
+#define MEM_SDREFCFG_TRPM		(3<<26)
+#define MEM_SDREFCFG_E			(1<<25)
+#define MEM_SDREFCFG_RE			(0x1ffffff<<0)
+#define MEM_SDREFCFG_TRC_N(N)	((N)<<MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N)<<MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
 #endif
 
+/***********************************************************************/
+
+/*
+ * Au1550 SDRAM Register Offsets
+ */
+
+/***********************************************************************/
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_SDMODE0		(0x0800)
+#define MEM_SDMODE1		(0x0808)
+#define MEM_SDMODE2		(0x0810)
+#define MEM_SDADDR0		(0x0820)
+#define MEM_SDADDR1		(0x0828)
+#define MEM_SDADDR2		(0x0830)
+#define MEM_SDCONFIGA	(0x0840)
+#define MEM_SDCONFIGB	(0x0848)
+#define MEM_SDSTAT		(0x0850)
+#define MEM_SDERRADDR	(0x0858)
+#define MEM_SDSTRIDE0	(0x0860)
+#define MEM_SDSTRIDE1	(0x0868)
+#define MEM_SDSTRIDE2	(0x0870)
+#define MEM_SDWRMD0		(0x0880)
+#define MEM_SDWRMD1		(0x0888)
+#define MEM_SDWRMD2		(0x0890)
+#define MEM_SDPRECMD	(0x08C0)
+#define MEM_SDAUTOREF	(0x08C8)
+#define MEM_SDSREF		(0x08D0)
+#define MEM_SDSLEEP		MEM_SDSREF
+
+#endif
+
+/*
+ * Physical base addresses for integrated peripherals
+ */
+
+#ifdef CONFIG_SOC_AU1000
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART2_PHYS_ADDR		0x11300000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#endif
+
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1500
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x11500000
+#define	MAC1_PHYS_ADDR		0x11510000
+#define	MACEN_PHYS_ADDR		0x11520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCI_MEM_PHYS_ADDR     0x400000000ULL
+#define PCI_IO_PHYS_ADDR      0x500000000ULL
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000ULL
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000ULL
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#endif
+
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1100
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define LCD_PHYS_ADDR		0x15000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1550
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	USBH_PHYS_ADDR		0x14020000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PE_PHYS_ADDR		0x14008000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PSC2_PHYS_ADDR	 	0x10A00000
+#define PSC3_PHYS_ADDR	 	0x10B00000
+#define PCI_MEM_PHYS_ADDR     0x400000000ULL
+#define PCI_IO_PHYS_ADDR      0x500000000ULL
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000ULL
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000ULL
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1200
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define AES_PHYS_ADDR		0x10300000
+#define CIM_PHYS_ADDR		0x14004000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define USBM_PHYS_ADDR		0x14020000
+#define	USBH_PHYS_ADDR		0x14020100
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define LCD_PHYS_ADDR		0x15000000
+#define SWCNT_PHYS_ADDR		0x1110010C
+#define MAEFE_PHYS_ADDR		0x14012000
+#define MAEBE_PHYS_ADDR		0x14010000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#endif
+
+
 /* Static Bus Controller */
 #define MEM_STCFG0                 0xB4001000
 #define MEM_STTIME0                0xB4001004
@@ -369,7 +611,7 @@
 #define AU1000_MAC0_ENABLE       0xB0520000
 #define AU1000_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1000
+#endif /* CONFIG_SOC_AU1000 */
 
 /* Au1500 */
 #ifdef CONFIG_SOC_AU1500
@@ -429,6 +671,12 @@
 #define AU1500_GPIO_207           62
 #define AU1500_GPIO_208_215       63
 
+/* shortcuts */
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+
 #define UART0_ADDR                0xB1100000
 #define UART3_ADDR                0xB1400000
 
@@ -440,7 +688,7 @@
 #define AU1500_MAC0_ENABLE       0xB1520000
 #define AU1500_MAC1_ENABLE       0xB1520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1500
+#endif /* CONFIG_SOC_AU1500 */
 
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
@@ -485,6 +733,22 @@
 #define AU1000_GPIO_13            45
 #define AU1000_GPIO_14            46
 #define AU1000_GPIO_15            47
+#define AU1000_GPIO_16            48
+#define AU1000_GPIO_17            49
+#define AU1000_GPIO_18            50
+#define AU1000_GPIO_19            51
+#define AU1000_GPIO_20            52
+#define AU1000_GPIO_21            53
+#define AU1000_GPIO_22            54
+#define AU1000_GPIO_23            55
+#define AU1000_GPIO_24            56
+#define AU1000_GPIO_25            57
+#define AU1000_GPIO_26            58
+#define AU1000_GPIO_27            59
+#define AU1000_GPIO_28            60
+#define AU1000_GPIO_29            61
+#define AU1000_GPIO_30            62
+#define AU1000_GPIO_31            63
 
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
@@ -496,7 +760,7 @@
 #define AU1100_ETH0_BASE	  0xB0500000
 #define AU1100_MAC0_ENABLE       0xB0520000
 #define NUM_ETH_INTERFACES 1
-#endif // CONFIG_SOC_AU1100
+#endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
 #define AU1550_UART0_INT          0
@@ -513,14 +777,14 @@
 #define AU1550_PSC1_INT           11
 #define AU1550_PSC2_INT           12
 #define AU1550_PSC3_INT           13
-#define AU1550_TOY_INT			  14
-#define AU1550_TOY_MATCH0_INT     15
-#define AU1550_TOY_MATCH1_INT     16
-#define AU1550_TOY_MATCH2_INT     17
-#define AU1550_RTC_INT            18
-#define AU1550_RTC_MATCH0_INT     19
-#define AU1550_RTC_MATCH1_INT     20
-#define AU1550_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1550_NAND_INT           23
 #define AU1550_USB_DEV_REQ_INT    24
 #define AU1550_USB_DEV_SUS_INT    25
@@ -563,6 +827,12 @@
 #define AU1500_GPIO_207           62
 #define AU1500_GPIO_208_218       63	// Logical or of GPIO208:218
 
+/* shortcuts */
+#define INTA AU1550_PCI_INTA
+#define INTB AU1550_PCI_INTB
+#define INTC AU1550_PCI_INTC
+#define INTD AU1550_PCI_INTD
+
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 #define UART3_ADDR                0xB1400000
@@ -575,7 +845,7 @@
 #define AU1550_MAC0_ENABLE       0xB0520000
 #define AU1550_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1550
+#endif /* CONFIG_SOC_AU1550 */
 
 #ifdef CONFIG_SOC_AU1200
 #define AU1200_UART0_INT          0
@@ -592,14 +862,14 @@
 #define AU1200_PSC1_INT           11
 #define AU1200_AES_INT            12
 #define AU1200_CAMERA_INT         13
-#define AU1200_TOY_INT			  14
-#define AU1200_TOY_MATCH0_INT     15
-#define AU1200_TOY_MATCH1_INT     16
-#define AU1200_TOY_MATCH2_INT     17
-#define AU1200_RTC_INT            18
-#define AU1200_RTC_MATCH0_INT     19
-#define AU1200_RTC_MATCH1_INT     20
-#define AU1200_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1200_NAND_INT           23
 #define AU1200_GPIO_204           24
 #define AU1200_GPIO_205           25
@@ -607,6 +877,7 @@
 #define AU1200_GPIO_207           27
 #define AU1200_GPIO_208_215       28 // Logical OR of 208:215
 #define AU1200_USB_INT            29
+#define AU1000_USB_HOST_INT		  AU1200_USB_INT
 #define AU1200_LCD_INT            30
 #define AU1200_MAE_BOTH_INT       31
 #define AU1000_GPIO_0             32
@@ -645,20 +916,36 @@
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 
-#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB4027ffc
+#define USB_UOC_BASE              0x14020020
+#define USB_UOC_LEN               0x20
+#define USB_OHCI_BASE             0x14020100
+#define USB_OHCI_LEN              0x100
+#define USB_EHCI_BASE             0x14020200
+#define USB_EHCI_LEN              0x100
+#define USB_UDC_BASE              0x14022000
+#define USB_UDC_LEN               0x2000
+#define USB_MSR_BASE			  0xB4020000
+#define USB_MSR_MCFG              4
+#define USBMSRMCFG_OMEMEN         0
+#define USBMSRMCFG_OBMEN          1
+#define USBMSRMCFG_EMEMEN         2
+#define USBMSRMCFG_EBMEN          3
+#define USBMSRMCFG_DMEMEN         4
+#define USBMSRMCFG_DBMEN          5
+#define USBMSRMCFG_GMEMEN         6
+#define USBMSRMCFG_OHCCLKEN       16
+#define USBMSRMCFG_EHCCLKEN       17
+#define USBMSRMCFG_UDCCLKEN       18
+#define USBMSRMCFG_PHYPLLEN       19
+#define USBMSRMCFG_RDCOMB         30
+#define USBMSRMCFG_PFEN           31
 
-// these are here for prototyping on au1550 (do not exist on au1200)
-#define AU1200_ETH0_BASE      0xB0500000
-#define AU1200_ETH1_BASE      0xB0510000
-#define AU1200_MAC0_ENABLE       0xB0520000
-#define AU1200_MAC1_ENABLE       0xB0520004
-#define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1200
+#endif /* CONFIG_SOC_AU1200 */
 
 #define AU1000_LAST_INTC0_INT     31
+#define AU1000_LAST_INTC1_INT     63
 #define AU1000_MAX_INTR           63
-
+#define INTX    		0xFF /* not valid */
 
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE                   0xB1900000
@@ -730,6 +1017,8 @@
   #define I2S_CONTROL_D         (1<<1)
   #define I2S_CONTROL_CE        (1<<0)
 
+#ifndef CONFIG_SOC_AU1200
+
 /* USB Host Controller */
 #define USB_OHCI_LEN              0x00100000
 
@@ -775,6 +1064,8 @@
   #define USBDEV_ENABLE (1<<1)
   #define USBDEV_CE     (1<<0)
 
+#endif /* !CONFIG_SOC_AU1200 */
+
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
@@ -1173,6 +1464,37 @@
   #define SYS_PF_PSC1_S1		(1 << 1)
   #define SYS_PF_MUST_BE_SET		((1 << 5) | (1 << 2))
 
+/* Au1200 Only */
+#ifdef CONFIG_SOC_AU1200
+#define SYS_PINFUNC_DMA		(1<<31)
+#define SYS_PINFUNC_S0A		(1<<30)
+#define SYS_PINFUNC_S1A		(1<<29)
+#define SYS_PINFUNC_LP0		(1<<28)
+#define SYS_PINFUNC_LP1		(1<<27)
+#define SYS_PINFUNC_LD16	(1<<26)
+#define SYS_PINFUNC_LD8		(1<<25)
+#define SYS_PINFUNC_LD1		(1<<24)
+#define SYS_PINFUNC_LD0		(1<<23)
+#define SYS_PINFUNC_P1A		(3<<21)
+#define SYS_PINFUNC_P1B		(1<<20)
+#define SYS_PINFUNC_FS3		(1<<19)
+#define SYS_PINFUNC_P0A		(3<<17)
+#define SYS_PINFUNC_CS		(1<<16)
+#define SYS_PINFUNC_CIM		(1<<15)
+#define SYS_PINFUNC_P1C		(1<<14)
+#define SYS_PINFUNC_U1T		(1<<12)
+#define SYS_PINFUNC_U1R		(1<<11)
+#define SYS_PINFUNC_EX1		(1<<10)
+#define SYS_PINFUNC_EX0		(1<<9)
+#define SYS_PINFUNC_U0R		(1<<8)
+#define SYS_PINFUNC_MC		(1<<7)
+#define SYS_PINFUNC_S0B		(1<<6)
+#define SYS_PINFUNC_S0C		(1<<5)
+#define SYS_PINFUNC_P0B		(1<<4)
+#define SYS_PINFUNC_U0T		(1<<3)
+#define SYS_PINFUNC_S1B		(1<<2)
+#endif
+
 #define SYS_TRIOUTRD              0xB1900100
 #define SYS_TRIOUTCLR             0xB1900100
 #define SYS_OUTPUTRD              0xB1900108
@@ -1239,6 +1561,12 @@
   #define SYS_CS_MI2_MASK           (0x7<<SYS_CS_MI2_BIT)
   #define SYS_CS_DI2                (1<<16)
   #define SYS_CS_CI2                (1<<15)
+#ifdef CONFIG_SOC_AU1100
+  #define SYS_CS_ML_BIT             7
+  #define SYS_CS_ML_MASK            (0x7<<SYS_CS_ML_BIT)
+  #define SYS_CS_DL                 (1<<6)
+  #define SYS_CS_CL                 (1<<5)
+#else
   #define SYS_CS_MUH_BIT            12
   #define SYS_CS_MUH_MASK           (0x7<<SYS_CS_MUH_BIT)
   #define SYS_CS_DUH                (1<<11)
@@ -1247,6 +1575,7 @@
   #define SYS_CS_MUD_MASK           (0x7<<SYS_CS_MUD_BIT)
   #define SYS_CS_DUD                (1<<6)
   #define SYS_CS_CUD                (1<<5)
+#endif
   #define SYS_CS_MIR_BIT            2
   #define SYS_CS_MIR_MASK           (0x7<<SYS_CS_MIR_BIT)
   #define SYS_CS_DIR                (1<<1)
@@ -1300,7 +1629,6 @@
 #define SD1_XMIT_FIFO	0xB0680000
 #define SD1_RECV_FIFO	0xB0680004
 
-
 #if defined (CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
 #define Au1500_CFG_BASE           0xB4005000 // virtual, kseg0 addr
@@ -1363,36 +1691,77 @@
 		      _ctl_; })
 
 
-#else /* Au1000 and Au1100 */
+#else /* Au1000 and Au1100 and Au1200 */
 
 /* don't allow any legacy ports probing */
-#define IOPORT_RESOURCE_START 0x10000000;
+#define IOPORT_RESOURCE_START 0x10000000
 #define IOPORT_RESOURCE_END   0xffffffff
 #define IOMEM_RESOURCE_START  0x10000000
 #define IOMEM_RESOURCE_END    0xffffffff
 
-#ifdef CONFIG_MIPS_PB1000
-#define PCI_IO_START      0x10000000
-#define PCI_IO_END        0x1000ffff
-#define PCI_MEM_START     0x18000000
-#define PCI_MEM_END       0x18ffffff
-#define PCI_FIRST_DEVFN   0
-#define PCI_LAST_DEVFN    1
-#else
-/* no PCI bus controller */
 #define PCI_IO_START    0
 #define PCI_IO_END      0
 #define PCI_MEM_START   0
 #define PCI_MEM_END     0
 #define PCI_FIRST_DEVFN 0
 #define PCI_LAST_DEVFN  0
-#endif
 
 #endif
 
+#ifndef _LANGUAGE_ASSEMBLY
+typedef volatile struct
+{
+	/* 0x0000 */ u32 toytrim;
+	/* 0x0004 */ u32 toywrite;
+	/* 0x0008 */ u32 toymatch0;
+	/* 0x000C */ u32 toymatch1;
+	/* 0x0010 */ u32 toymatch2;
+	/* 0x0014 */ u32 cntrctrl;
+	/* 0x0018 */ u32 scratch0;
+	/* 0x001C */ u32 scratch1;
+	/* 0x0020 */ u32 freqctrl0;
+	/* 0x0024 */ u32 freqctrl1;
+	/* 0x0028 */ u32 clksrc;
+	/* 0x002C */ u32 pinfunc;
+	/* 0x0030 */ u32 reserved0;
+	/* 0x0034 */ u32 wakemsk;
+	/* 0x0038 */ u32 endian;
+	/* 0x003C */ u32 powerctrl;
+	/* 0x0040 */ u32 toyread;
+	/* 0x0044 */ u32 rtctrim;
+	/* 0x0048 */ u32 rtcwrite;
+	/* 0x004C */ u32 rtcmatch0;
+	/* 0x0050 */ u32 rtcmatch1;
+	/* 0x0054 */ u32 rtcmatch2;
+	/* 0x0058 */ u32 rtcread;
+	/* 0x005C */ u32 wakesrc;
+	/* 0x0060 */ u32 cpupll;
+	/* 0x0064 */ u32 auxpll;
+	/* 0x0068 */ u32 reserved1;
+	/* 0x006C */ u32 reserved2;
+	/* 0x0070 */ u32 reserved3;
+	/* 0x0074 */ u32 reserved4;
+	/* 0x0078 */ u32 slppwr;
+	/* 0x007C */ u32 sleep;
+	/* 0x0080 */ u32 reserved5[32];
+	/* 0x0100 */ u32 trioutrd;
+#define trioutclr trioutrd
+	/* 0x0104 */ u32 reserved6;
+	/* 0x0108 */ u32 outputrd;
+#define outputset outputrd
+	/* 0x010C */ u32 outputclr;
+	/* 0x0110 */ u32 pinstaterd;
+#define pininputen pinstaterd
+
+} AU1X00_SYS;
+
+static AU1X00_SYS* const sys  = (AU1X00_SYS *)SYS_BASE;
+
+#endif
 /* Processor information base on prid.
  * Copied from PowerPC.
  */
+#ifndef _LANGUAGE_ASSEMBLY
 struct cpu_spec {
 	/* CPU is matched via (PRID & prid_mask) == prid_value */
 	unsigned int	prid_mask;
@@ -1406,3 +1775,6 @@
 extern struct cpu_spec		cpu_specs[];
 extern struct cpu_spec		*cur_cpu_spec[];
 #endif
+
+#endif
+
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_dbdma.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_dbdma.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_dbdma.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_dbdma.h	2005-11-17 11:44:27.000000000 -0800
@@ -45,7 +45,7 @@
 #define DDMA_GLOBAL_BASE	0xb4003000
 #define DDMA_CHANNEL_BASE	0xb4002000
 
-typedef struct dbdma_global {
+typedef volatile struct dbdma_global {
 	u32	ddma_config;
 	u32	ddma_intstat;
 	u32	ddma_throttle;
@@ -62,7 +62,7 @@
 
 /* The structure of a DMA Channel.
 */
-typedef struct au1xxx_dma_channel {
+typedef volatile struct au1xxx_dma_channel {
 	u32	ddma_cfg;	/* See below */
 	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
 	u32	ddma_statptr;	/* word aligned pointer to status word */
@@ -98,7 +98,7 @@
 /* "Standard" DDMA Descriptor.
  * Must be 32-byte aligned.
  */
-typedef struct au1xxx_ddma_desc {
+typedef volatile struct au1xxx_ddma_desc {
 	u32	dscr_cmd0;		/* See below */
 	u32	dscr_cmd1;		/* See below */
 	u32	dscr_source0;		/* source phys address */
@@ -107,6 +107,12 @@
 	u32	dscr_dest1;		/* See below */
 	u32	dscr_stat;		/* completion status */
 	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
+	/* First 32bytes are HW specific!!!
+	   Lets have some SW data following.. make sure its 32bytes
+	 */
+	u32	sw_status;
+	u32 	sw_context;
+	u32	sw_reserved[6];
 } au1x_ddma_desc_t;
 
 #define DSCR_CMD0_V		(1 << 31)	/* Descriptor valid */
@@ -125,8 +131,11 @@
 #define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
 #define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
 
+#define SW_STATUS_INUSE		(1<<0)
+
 /* Command 0 device IDs.
 */
+#ifdef CONFIG_SOC_AU1550
 #define DSCR_CMD0_UART0_TX	0
 #define DSCR_CMD0_UART0_RX	1
 #define DSCR_CMD0_UART3_TX	2
@@ -155,9 +164,45 @@
 #define DSCR_CMD0_MAC0_TX	25
 #define DSCR_CMD0_MAC1_RX	26
 #define DSCR_CMD0_MAC1_TX	27
+#endif /* CONFIG_SOC_AU1550 */
+
+#ifdef CONFIG_SOC_AU1200
+#define DSCR_CMD0_UART0_TX	0
+#define DSCR_CMD0_UART0_RX	1
+#define DSCR_CMD0_UART1_TX	2
+#define DSCR_CMD0_UART1_RX	3
+#define DSCR_CMD0_DMA_REQ0	4
+#define DSCR_CMD0_DMA_REQ1	5
+#define DSCR_CMD0_MAE_BE	6
+#define DSCR_CMD0_MAE_FE	7
+#define DSCR_CMD0_SDMS_TX0	8
+#define DSCR_CMD0_SDMS_RX0	9
+#define DSCR_CMD0_SDMS_TX1	10
+#define DSCR_CMD0_SDMS_RX1	11
+#define DSCR_CMD0_AES_TX	13
+#define DSCR_CMD0_AES_RX	12
+#define DSCR_CMD0_PSC0_TX	14
+#define DSCR_CMD0_PSC0_RX	15
+#define DSCR_CMD0_PSC1_TX	16
+#define DSCR_CMD0_PSC1_RX	17
+#define DSCR_CMD0_CIM_RXA	18
+#define DSCR_CMD0_CIM_RXB	19
+#define DSCR_CMD0_CIM_RXC	20
+#define DSCR_CMD0_MAE_BOTH	21
+#define DSCR_CMD0_LCD		22
+#define DSCR_CMD0_NAND_FLASH	23
+#define DSCR_CMD0_PSC0_SYNC	24
+#define DSCR_CMD0_PSC1_SYNC	25
+#define DSCR_CMD0_CIM_SYNC	26
+#endif /* CONFIG_SOC_AU1200 */
+
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31
 #define DSCR_NDEV_IDS		32
+/* THis macro is used to find/create custom device types */
+#define DSCR_DEV2CUSTOM_ID(x,d)	(((((x)&0xFFFF)<<8)|0x32000000)|((d)&0xFF))
+#define DSCR_CUSTOM2DEV_ID(x)	((x)&0xFF)
+
 
 #define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
 #define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
@@ -246,6 +291,43 @@
 */
 #define NUM_DBDMA_CHANS	16
 
+/*
+ * Ddma API definitions
+ * FIXME: may not fit to this header file
+ */
+typedef struct dbdma_device_table {
+	u32		dev_id;
+	u32		dev_flags;
+	u32		dev_tsize;
+	u32		dev_devwidth;
+	u32		dev_physaddr;		/* If FIFO */
+	u32		dev_intlevel;
+	u32		dev_intpolarity;
+} dbdev_tab_t;
+
+
+typedef struct dbdma_chan_config {
+	spinlock_t      lock;
+
+	u32			chan_flags;
+	u32			chan_index;
+	dbdev_tab_t		*chan_src;
+	dbdev_tab_t		*chan_dest;
+	au1x_dma_chan_t		*chan_ptr;
+	au1x_ddma_desc_t	*chan_desc_base;
+	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
+	void			*chan_callparam;
+	void (*chan_callback)(int, void *, struct pt_regs *);
+} chan_tab_t;
+
+#define DEV_FLAGS_INUSE		(1 << 0)
+#define DEV_FLAGS_ANYUSE	(1 << 1)
+#define DEV_FLAGS_OUT		(1 << 2)
+#define DEV_FLAGS_IN		(1 << 3)
+#define DEV_FLAGS_BURSTABLE (1 << 4)
+#define DEV_FLAGS_SYNC		(1 << 5)
+/* end Ddma API definitions */
+
 /* External functions for drivers to use.
 */
 /* Use this to allocate a dbdma channel.  The device ids are one of the
@@ -258,18 +340,6 @@
 
 #define DBDMA_MEM_CHAN	DSCR_CMD0_ALWAYS
 
-/* ACK!  These should be in a board specific description file.
-*/
-#ifdef CONFIG_MIPS_PB1550
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#endif
-
-
 /* Set the device width of a in/out fifo.
 */
 u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
@@ -280,8 +350,8 @@
 
 /* Put buffers on source/destination descriptors.
 */
-u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes);
-u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes);
+u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
 
 /* Get a buffer from the destination descriptor.
 */
@@ -295,5 +365,29 @@
 void au1xxx_dbdma_chan_free(u32 chanid);
 void au1xxx_dbdma_dump(u32 chanid);
 
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr );
+
+u32 au1xxx_ddma_add_device( dbdev_tab_t *dev );
+void * au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp);
+
+/*
+ 	Some compatibilty macros --
+		Needed to make changes to API without breaking existing drivers
+*/
+#define	au1xxx_dbdma_put_source(chanid,buf,nbytes)_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_source_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
+#define	put_source_flags(chanid,buf,nbytes,flags) au1xxx_dbdma_put_source_flags(chanid,buf,nbytes,flags)
+
+
+#define au1xxx_dbdma_put_dest(chanid,buf,nbytes) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_dest_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
+#define	put_dest_flags(chanid,buf,nbytes,flags) au1xxx_dbdma_put_dest_flags(chanid,buf,nbytes,flags)
+
+/*
+ *	Flags for the put_source/put_dest functions.
+ */
+#define DDMA_FLAGS_IE	(1<<0)
+#define DDMA_FLAGS_NOIE (1<<1)
+
 #endif /* _LANGUAGE_ASSEMBLY */
 #endif /* _AU1000_DBDMA_H_ */
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_gpio.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_gpio.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_gpio.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_gpio.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,20 @@
+#ifndef __AU1XXX_GPIO_H
+#define __AU1XXX_GPIO_H
+
+void au1xxx_gpio1_set_inputs(void);
+void au1xxx_gpio_tristate(int signal);
+void au1xxx_gpio_write(int signal, int value);
+int  au1xxx_gpio_read(int signal);
+
+typedef volatile struct
+{
+	u32 dir;
+	u32 reserved;
+	u32 output;
+	u32 pinstate;
+	u32 inten;
+	u32 enable;
+
+} AU1X00_GPIO2;
+
+#endif //__AU1XXX_GPIO_H
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,44 @@
+/*
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AU1XXX_H_
+#define _AU1XXX_H_
+
+#include <linux/config.h>
+
+#include <asm/mach-au1x00/au1000.h>
+
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550)
+#include <asm/mach-db1x00/db1x00.h>
+
+#elif defined(CONFIG_MIPS_PB1550)
+#include <asm/mach-pb1x00/pb1550.h>
+
+#elif defined(CONFIG_MIPS_PB1200)
+#include <asm/mach-pb1x00/pb1200.h>
+
+#elif defined(CONFIG_MIPS_DB1200)
+#include <asm/mach-db1x00/db1200.h>
+
+#endif
+
+#endif /* _AU1XXX_H_ */
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_ide.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_ide.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_ide.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_ide.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,301 @@
+/*
+ * include/asm-mips/mach-au1x00/au1xxx_ide.h  version 01.30.00   Aug. 02 2005
+ *
+ * BRIEF MODULE DESCRIPTION
+ * AMD Alchemy Au1xxx IDE interface routines over the Static Bus
+ *
+ * Copyright (c) 2003-2005 AMD, Personal Connectivity Solutions
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 2 of the License, or (at your option) any later
+ * version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Note: for more information, please refer "AMD Alchemy Au1200/Au1550 IDE
+ *       Interface and Linux Device Driver" Application Note.
+ */
+#include <linux/config.h>
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        #define DMA_WAIT_TIMEOUT        100
+        #define NUM_DESCRIPTORS         PRD_ENTRIES
+#else /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
+        #define NUM_DESCRIPTORS         2
+#endif
+
+#ifndef AU1XXX_ATA_RQSIZE
+        #define AU1XXX_ATA_RQSIZE       128
+#endif
+
+/* Disable Burstable-Support for DBDMA */
+#ifndef CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
+        #define CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON  0
+#endif
+
+#ifdef CONFIG_PM
+/*
+* This will enable the device to be powered up when write() or read()
+* is called. If this is not defined, the driver will return -EBUSY.
+*/
+#define WAKE_ON_ACCESS 1
+
+typedef struct
+{
+        spinlock_t         lock;       /* Used to block on state transitions */
+        au1xxx_power_dev_t *dev;       /* Power Managers device structure */
+        unsigned	   stopped;    /* USed to signaling device is stopped */
+} pm_state;
+#endif
+
+
+typedef struct
+{
+        u32                     tx_dev_id, rx_dev_id, target_dev_id;
+        u32                     tx_chan, rx_chan;
+        void                    *tx_desc_head, *rx_desc_head;
+        ide_hwif_t              *hwif;
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+        ide_drive_t             *drive;
+        u8                      white_list, black_list;
+        struct dbdma_cmd        *dma_table_cpu;
+        dma_addr_t              dma_table_dma;
+        struct scatterlist      *sg_table;
+        int                     sg_nents;
+        int                     sg_dma_direction;
+#endif
+        struct device           *dev;
+	int			irq;
+	u32			regbase;
+#ifdef CONFIG_PM
+        pm_state                pm;
+#endif
+} _auide_hwif;
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+struct drive_list_entry {
+        const char * id_model;
+        const char * id_firmware;
+};
+
+/* HD white list */
+static const struct drive_list_entry dma_white_list [] = {
+/*
+ * Hitachi
+ */
+        { "HITACHI_DK14FA-20"    ,       "ALL"           },
+        { "HTS726060M9AT00"      ,       "ALL"           },
+/*
+ * Maxtor
+ */
+        { "Maxtor 6E040L0"      ,       "ALL"           },
+        { "Maxtor 6Y080P0"      ,       "ALL"           },
+        { "Maxtor 6Y160P0"      ,       "ALL"           },
+/*
+ * Seagate
+ */
+        { "ST3120026A"          ,       "ALL"           },
+        { "ST320014A"           ,       "ALL"           },
+        { "ST94011A"            ,       "ALL"           },
+        { "ST340016A"           ,       "ALL"           },
+/*
+ * Western Digital
+ */
+        { "WDC WD400UE-00HCT0"  ,       "ALL"           },
+        { "WDC WD400JB-00JJC0"  ,       "ALL"           },
+        { NULL                  ,       NULL            }
+};
+
+/* HD black list */
+static const struct drive_list_entry dma_black_list [] = {
+/*
+ * Western Digital
+ */
+        { "WDC WD100EB-00CGH0"  ,       "ALL"           },
+        { "WDC WD200BB-00AUA1"  ,       "ALL"           },
+        { "WDC AC24300L"        ,       "ALL"           },
+        { NULL                  ,       NULL            }
+};
+#endif
+
+/* function prototyping */
+u8 auide_inb(unsigned long port);
+u16 auide_inw(unsigned long port);
+u32 auide_inl(unsigned long port);
+void auide_insw(unsigned long port, void *addr, u32 count);
+void auide_insl(unsigned long port, void *addr, u32 count);
+void auide_outb(u8 addr, unsigned long port);
+void auide_outbsync(ide_drive_t *drive, u8 addr, unsigned long port);
+void auide_outw(u16 addr, unsigned long port);
+void auide_outl(u32 addr, unsigned long port);
+void auide_outsw(unsigned long port, void *addr, u32 count);
+void auide_outsl(unsigned long port, void *addr, u32 count);
+static void auide_tune_drive(ide_drive_t *drive, byte pio);
+static int auide_tune_chipset (ide_drive_t *drive, u8 speed);
+static int auide_ddma_init( _auide_hwif *auide );
+static void auide_setup_ports(hw_regs_t *hw, _auide_hwif *ahwif);
+int __init auide_probe(void);
+
+#ifdef CONFIG_PM
+        int au1200ide_pm_callback( au1xxx_power_dev_t *dev,
+                                   au1xxx_request_t request, void *data);
+        static int au1xxxide_pm_standby( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_sleep( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_resume( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_getstatus( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_access( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_idle( au1xxx_power_dev_t *dev );
+        static int au1xxxide_pm_cleanup( au1xxx_power_dev_t *dev );
+#endif
+
+
+/*
+ * Multi-Word DMA + DbDMA functions
+ */
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+
+        static int in_drive_list(struct hd_driveid *id,
+                                 const struct drive_list_entry *drive_table);
+        static int auide_build_sglist(ide_drive_t *drive,  struct request *rq);
+        static int auide_build_dmatable(ide_drive_t *drive);
+        static int auide_dma_end(ide_drive_t *drive);
+        static void auide_dma_start(ide_drive_t *drive );
+        ide_startstop_t auide_dma_intr (ide_drive_t *drive);
+        static void auide_dma_exec_cmd(ide_drive_t *drive, u8 command);
+        static int auide_dma_setup(ide_drive_t *drive);
+        static int auide_dma_check(ide_drive_t *drive);
+        static int auide_dma_test_irq(ide_drive_t *drive);
+        static int auide_dma_host_off(ide_drive_t *drive);
+        static int auide_dma_host_on(ide_drive_t *drive);
+        static int auide_dma_lostirq(ide_drive_t *drive);
+        static int auide_dma_on(ide_drive_t *drive);
+        static void auide_ddma_tx_callback(int irq, void *param,
+                                           struct pt_regs *regs);
+        static void auide_ddma_rx_callback(int irq, void *param,
+                                           struct pt_regs *regs);
+        static int auide_dma_off_quietly(ide_drive_t *drive);
+        static int auide_dma_timeout(ide_drive_t *drive);
+
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA */
+
+/*******************************************************************************
+* PIO Mode timing calculation :                                                *
+*                                                                              *
+* Static Bus Spec   ATA Spec                                                   *
+*      Tcsoe      =   t1                                                       *
+*      Toecs      =   t9                                                       *
+*      Twcs       =   t9                                                       *
+*      Tcsh       =   t2i | t2                                                 *
+*      Tcsoff     =   t2i | t2                                                 *
+*      Twp        =   t2                                                       *
+*      Tcsw       =   t1                                                       *
+*      Tpm        =   0                                                        *
+*      Ta         =   t1+t2                                                    *
+*******************************************************************************/
+
+#define TCSOE_MASK            (0x07<<29)
+#define TOECS_MASK            (0x07<<26)
+#define TWCS_MASK             (0x07<<28)
+#define TCSH_MASK             (0x0F<<24)
+#define TCSOFF_MASK           (0x07<<20)
+#define TWP_MASK              (0x3F<<14)
+#define TCSW_MASK             (0x0F<<10)
+#define TPM_MASK              (0x0F<<6)
+#define TA_MASK               (0x3F<<0)
+#define TS_MASK               (1<<8)
+
+/* Timing parameters PIO mode 0 */
+#define SBC_IDE_PIO0_TCSOE    (0x04<<29)
+#define SBC_IDE_PIO0_TOECS    (0x01<<26)
+#define SBC_IDE_PIO0_TWCS     (0x02<<28)
+#define SBC_IDE_PIO0_TCSH     (0x08<<24)
+#define SBC_IDE_PIO0_TCSOFF   (0x07<<20)
+#define SBC_IDE_PIO0_TWP      (0x10<<14)
+#define SBC_IDE_PIO0_TCSW     (0x04<<10)
+#define SBC_IDE_PIO0_TPM      (0x0<<6)
+#define SBC_IDE_PIO0_TA       (0x15<<0)
+/* Timing parameters PIO mode 1 */
+#define SBC_IDE_PIO1_TCSOE    (0x03<<29)
+#define SBC_IDE_PIO1_TOECS    (0x01<<26)
+#define SBC_IDE_PIO1_TWCS     (0x01<<28)
+#define SBC_IDE_PIO1_TCSH     (0x06<<24)
+#define SBC_IDE_PIO1_TCSOFF   (0x06<<20)
+#define SBC_IDE_PIO1_TWP      (0x08<<14)
+#define SBC_IDE_PIO1_TCSW     (0x03<<10)
+#define SBC_IDE_PIO1_TPM      (0x00<<6)
+#define SBC_IDE_PIO1_TA       (0x0B<<0)
+/* Timing parameters PIO mode 2 */
+#define SBC_IDE_PIO2_TCSOE    (0x05<<29)
+#define SBC_IDE_PIO2_TOECS    (0x01<<26)
+#define SBC_IDE_PIO2_TWCS     (0x01<<28)
+#define SBC_IDE_PIO2_TCSH     (0x07<<24)
+#define SBC_IDE_PIO2_TCSOFF   (0x07<<20)
+#define SBC_IDE_PIO2_TWP      (0x1F<<14)
+#define SBC_IDE_PIO2_TCSW     (0x05<<10)
+#define SBC_IDE_PIO2_TPM      (0x00<<6)
+#define SBC_IDE_PIO2_TA       (0x22<<0)
+/* Timing parameters PIO mode 3 */
+#define SBC_IDE_PIO3_TCSOE    (0x05<<29)
+#define SBC_IDE_PIO3_TOECS    (0x01<<26)
+#define SBC_IDE_PIO3_TWCS     (0x01<<28)
+#define SBC_IDE_PIO3_TCSH     (0x0D<<24)
+#define SBC_IDE_PIO3_TCSOFF   (0x0D<<20)
+#define SBC_IDE_PIO3_TWP      (0x15<<14)
+#define SBC_IDE_PIO3_TCSW     (0x05<<10)
+#define SBC_IDE_PIO3_TPM      (0x00<<6)
+#define SBC_IDE_PIO3_TA       (0x1A<<0)
+/* Timing parameters PIO mode 4 */
+#define SBC_IDE_PIO4_TCSOE    (0x04<<29)
+#define SBC_IDE_PIO4_TOECS    (0x01<<26)
+#define SBC_IDE_PIO4_TWCS     (0x01<<28)
+#define SBC_IDE_PIO4_TCSH     (0x04<<24)
+#define SBC_IDE_PIO4_TCSOFF   (0x04<<20)
+#define SBC_IDE_PIO4_TWP      (0x0D<<14)
+#define SBC_IDE_PIO4_TCSW     (0x03<<10)
+#define SBC_IDE_PIO4_TPM      (0x00<<6)
+#define SBC_IDE_PIO4_TA       (0x12<<0)
+/* Timing parameters MDMA mode 0 */
+#define SBC_IDE_MDMA0_TCSOE   (0x03<<29)
+#define SBC_IDE_MDMA0_TOECS   (0x01<<26)
+#define SBC_IDE_MDMA0_TWCS    (0x01<<28)
+#define SBC_IDE_MDMA0_TCSH    (0x07<<24)
+#define SBC_IDE_MDMA0_TCSOFF  (0x07<<20)
+#define SBC_IDE_MDMA0_TWP     (0x0C<<14)
+#define SBC_IDE_MDMA0_TCSW    (0x03<<10)
+#define SBC_IDE_MDMA0_TPM     (0x00<<6)
+#define SBC_IDE_MDMA0_TA      (0x0F<<0)
+/* Timing parameters MDMA mode 1 */
+#define SBC_IDE_MDMA1_TCSOE   (0x05<<29)
+#define SBC_IDE_MDMA1_TOECS   (0x01<<26)
+#define SBC_IDE_MDMA1_TWCS    (0x01<<28)
+#define SBC_IDE_MDMA1_TCSH    (0x05<<24)
+#define SBC_IDE_MDMA1_TCSOFF  (0x05<<20)
+#define SBC_IDE_MDMA1_TWP     (0x0F<<14)
+#define SBC_IDE_MDMA1_TCSW    (0x05<<10)
+#define SBC_IDE_MDMA1_TPM     (0x00<<6)
+#define SBC_IDE_MDMA1_TA      (0x15<<0)
+/* Timing parameters MDMA mode 2 */
+#define SBC_IDE_MDMA2_TCSOE   (0x04<<29)
+#define SBC_IDE_MDMA2_TOECS   (0x01<<26)
+#define SBC_IDE_MDMA2_TWCS    (0x01<<28)
+#define SBC_IDE_MDMA2_TCSH    (0x04<<24)
+#define SBC_IDE_MDMA2_TCSOFF  (0x04<<20)
+#define SBC_IDE_MDMA2_TWP     (0x0D<<14)
+#define SBC_IDE_MDMA2_TCSW    (0x04<<10)
+#define SBC_IDE_MDMA2_TPM     (0x00<<6)
+#define SBC_IDE_MDMA2_TA      (0x12<<0)
+
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_psc.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_psc.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/au1xxx_psc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/au1xxx_psc.h	2005-11-17 11:44:27.000000000 -0800
@@ -33,6 +33,8 @@
 #ifndef _AU1000_PSC_H_
 #define _AU1000_PSC_H_
 
+#include <linux/config.h>
+
 /* The PSC base addresses.  */
 #ifdef CONFIG_SOC_AU1550
 #define PSC0_BASE_ADDR		0xb1a00000
diff -Naur linux-2.6.14/include/asm-mips/mach-au1x00/ioremap.h linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/ioremap.h
--- linux-2.6.14/include/asm-mips/mach-au1x00/ioremap.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-au1x00/ioremap.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ *	include/asm-mips/mach-au1x00/ioremap.h
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MACH_AU1X00_IOREMAP_H
+#define __ASM_MACH_AU1X00_IOREMAP_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_64BIT_PHYS_ADDR
+extern phys_t __fixup_bigphys_addr(phys_t, phys_t);
+#else
+static inline phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return phys_addr;
+}
+#endif
+
+/*
+ * Allow physical addresses to be fixed up to help 36-bit peripherals.
+ */
+static inline phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return __fixup_bigphys_addr(phys_addr, size);
+}
+
+#endif /* __ASM_MACH_AU1X00_IOREMAP_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-db1x00/db1200.h linux-mips-2.6.14.orig/include/asm-mips/mach-db1x00/db1200.h
--- linux-2.6.14/include/asm-mips/mach-db1x00/db1200.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-db1x00/db1200.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,227 @@
+/*
+ * AMD Alchemy DB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_DB1200_H
+#define __ASM_DB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xB9800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+#define BCSR_RESETS_TV		0x0010
+/* not resets but in the same register */
+#define BCSR_RESETS_PWMR1mUX 0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+
+#define BCSR_LEDS_DECIMALS	0x0003
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x19000300)
+#define AU1XXX_SMC91111_IRQ			DB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x18800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			DB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x20000000
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the DB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define DB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define DB1200_IDE_INT			(DB1200_INT_BEGIN + 0)
+#define DB1200_ETH_INT			(DB1200_INT_BEGIN + 1)
+#define DB1200_PC0_INT			(DB1200_INT_BEGIN + 2)
+#define DB1200_PC0_STSCHG_INT	(DB1200_INT_BEGIN + 3)
+#define DB1200_PC1_INT			(DB1200_INT_BEGIN + 4)
+#define DB1200_PC1_STSCHG_INT	(DB1200_INT_BEGIN + 5)
+#define DB1200_DC_INT			(DB1200_INT_BEGIN + 6)
+#define DB1200_FLASHBUSY_INT	(DB1200_INT_BEGIN + 7)
+#define DB1200_PC0_INSERT_INT	(DB1200_INT_BEGIN + 8)
+#define DB1200_PC0_EJECT_INT	(DB1200_INT_BEGIN + 9)
+#define DB1200_PC1_INSERT_INT	(DB1200_INT_BEGIN + 10)
+#define DB1200_PC1_EJECT_INT	(DB1200_INT_BEGIN + 11)
+#define DB1200_SD0_INSERT_INT	(DB1200_INT_BEGIN + 12)
+#define DB1200_SD0_EJECT_INT	(DB1200_INT_BEGIN + 13)
+
+#define DB1200_INT_END			(DB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+
+/* PCMCIA Db1x00 specific defines */
+
+#define PCMCIA_MAX_SOCK 1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+#define BOARD_PC0_INT DB1200_PC0_INT
+#define BOARD_PC1_INT DB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+/* Nand chip select */
+#define NAND_CS 1
+
+#endif /* __ASM_DB1200_H */
+
diff -Naur linux-2.6.14/include/asm-mips/mach-db1x00/db1x00.h linux-mips-2.6.14.orig/include/asm-mips/mach-db1x00/db1x00.h
--- linux-2.6.14/include/asm-mips/mach-db1x00/db1x00.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-db1x00/db1x00.h	2005-11-17 11:44:27.000000000 -0800
@@ -200,6 +200,12 @@
 			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
 			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
 			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+#define NAND_CS 1
+
+/* should be done by yamon */
+#define NAND_STCFG  0x00400005 /* 8-bit NAND */
+#define NAND_STTIME 0x00007774 /* valid for 396MHz SD=2 only */
+#define NAND_STADDR 0x12000FFF /* physical address 0x20000000 */
 
 #endif /* __ASM_DB1X00_H */
 
diff -Naur linux-2.6.14/include/asm-mips/mach-dec/mc146818rtc.h linux-mips-2.6.14.orig/include/asm-mips/mach-dec/mc146818rtc.h
--- linux-2.6.14/include/asm-mips/mach-dec/mc146818rtc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-dec/mc146818rtc.h	2005-11-17 11:44:27.000000000 -0800
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1998, 2001 by Ralf Baechle
  * Copyright (C) 1998 by Harald Koerfgen
- * Copyright (C) 2002  Maciej W. Rozycki
+ * Copyright (C) 2002, 2005  Maciej W. Rozycki
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -14,23 +14,18 @@
 #define __ASM_MIPS_DEC_RTC_DEC_H
 
 #include <linux/types.h>
-
 #include <asm/addrspace.h>
+#include <asm/dec/system.h>
 
 extern volatile u8 *dec_rtc_base;
-extern unsigned long dec_kn_slot_size;
 
-#define RTC_PORT(x)	CPHYSADDR(dec_rtc_base)
+#define RTC_PORT(x)	CPHYSADDR((long)dec_rtc_base)
 #define RTC_IO_EXTENT	dec_kn_slot_size
 #define RTC_IOMAPPED	0
 #undef RTC_IRQ
 
 #define RTC_DEC_YEAR	0x3f	/* Where we store the real year on DECs.  */
 
-#include <linux/mc146818rtc.h>
-#include <linux/module.h>
-#include <linux/types.h>
-
 static inline unsigned char CMOS_READ(unsigned long addr)
 {
 	return dec_rtc_base[addr * 4];
diff -Naur linux-2.6.14/include/asm-mips/mach-generic/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-generic/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-generic/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-generic/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,6 +8,6 @@
 #ifndef __ASM_MACH_GENERIC_CPU_FEATURE_OVERRIDES_H
 #define __ASM_MACH_GENERIC_CPU_FEATURE_OVERRIDES_H
 
-/* Intensionally empty file ...  */
+/* Intentionally empty file ...  */
 
 #endif /* __ASM_MACH_GENERIC_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-generic/ide.h linux-mips-2.6.14.orig/include/asm-mips/mach-generic/ide.h
--- linux-2.6.14/include/asm-mips/mach-generic/ide.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-generic/ide.h	2005-11-17 11:44:27.000000000 -0800
@@ -18,6 +18,7 @@
 #include <linux/config.h>
 #include <linux/pci.h>
 #include <linux/stddef.h>
+#include <asm/processor.h>
 
 #ifndef MAX_HWIFS
 # ifdef CONFIG_BLK_DEV_IDEPCI
@@ -104,15 +105,71 @@
 
 /* MIPS port and memory-mapped I/O string operations.  */
 
-#define __ide_insw	insw
-#define __ide_insl	insl
-#define __ide_outsw	outsw
-#define __ide_outsl	outsl
-
-#define __ide_mm_insw	readsw
-#define __ide_mm_insl	readsl
-#define __ide_mm_outsw	writesw
-#define __ide_mm_outsl	writesl
+static inline void __ide_flush_dcache_range(unsigned long addr, unsigned long size)
+{
+	if (cpu_has_dc_aliases) {
+		unsigned long end = addr + size;
+		for (; addr < end; addr += PAGE_SIZE)
+			flush_dcache_page(virt_to_page(addr));
+	}
+}
+
+static inline void __ide_insw(unsigned long port, void *addr,
+	unsigned int count)
+{
+	insw(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 2);
+}
+
+static inline void __ide_insl(unsigned long port, void *addr, unsigned int count)
+{
+	insl(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 4);
+}
+
+static inline void __ide_outsw(unsigned long port, const void *addr,
+	unsigned long count)
+{
+	outsw(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 2);
+}
+
+static inline void __ide_outsl(unsigned long port, const void *addr,
+	unsigned long count)
+{
+	outsl(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 4);
+}
+
+static inline void __ide_mm_insw(void __iomem *port, void *addr, u32 count)
+{
+	readsw(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 2);
+}
+
+static inline void __ide_mm_insl(void __iomem *port, void *addr, u32 count)
+{
+	readsl(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 4);
+}
+
+static inline void __ide_mm_outsw(void __iomem *port, void *addr, u32 count)
+{
+	writesw(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 2);
+}
+
+static inline void __ide_mm_outsl(void __iomem * port, void *addr, u32 count)
+{
+	writesl(port, addr, count);
+	__ide_flush_dcache_range((unsigned long)addr, count * 4);
+}
+
+/* ide_insw calls insw, not __ide_insw.  Why? */
+#undef insw
+#undef insl
+#define insw(port, addr, count) __ide_insw(port, addr, count)
+#define insl(port, addr, count) __ide_insl(port, addr, count)
 
 #endif /* __KERNEL__ */
 
diff -Naur linux-2.6.14/include/asm-mips/mach-generic/ioremap.h linux-mips-2.6.14.orig/include/asm-mips/mach-generic/ioremap.h
--- linux-2.6.14/include/asm-mips/mach-generic/ioremap.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-generic/ioremap.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,23 @@
+/*
+ *	include/asm-mips/mach-generic/ioremap.h
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MACH_GENERIC_IOREMAP_H
+#define __ASM_MACH_GENERIC_IOREMAP_H
+
+#include <linux/types.h>
+
+/*
+ * Allow physical addresses to be fixed up to help peripherals located
+ * outside the low 32-bit range -- generic pass-through version.
+ */
+static inline phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return phys_addr;
+}
+
+#endif /* __ASM_MACH_GENERIC_IOREMAP_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-generic/kernel-entry-init.h linux-mips-2.6.14.orig/include/asm-mips/mach-generic/kernel-entry-init.h
--- linux-2.6.14/include/asm-mips/mach-generic/kernel-entry-init.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-generic/kernel-entry-init.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Embedded Alley Solutions, Inc
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ */
+#ifndef __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+#define __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+
+/* Intentionally empty macro, used in head.S. Override in
+ * arch/mips/mach-xxx/kernel-entry-init.h when necessary.
+ */
+.macro	kernel_entry_setup
+.endm
+
+/*
+ * Do SMP slave processor setup necessary before we can savely execute C code.
+ */
+	.macro	smp_slave_setup
+	.endm
+
+
+#endif /* __ASM_MACH_GENERIC_KERNEL_ENTRY_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-generic/kmalloc.h linux-mips-2.6.14.orig/include/asm-mips/mach-generic/kmalloc.h
--- linux-2.6.14/include/asm-mips/mach-generic/kmalloc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-generic/kmalloc.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,13 @@
+#ifndef __ASM_MACH_GENERIC_KMALLOC_H
+#define __ASM_MACH_GENERIC_KMALLOC_H
+
+#include <linux/config.h>
+
+#ifndef CONFIG_DMA_COHERENT
+/*
+ * Total overkill for most systems but need as a safe default.
+ */
+#define ARCH_KMALLOC_MINALIGN	128
+#endif
+
+#endif /* __ASM_MACH_GENERIC_KMALLOC_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-generic/spaces.h linux-mips-2.6.14.orig/include/asm-mips/mach-generic/spaces.h
--- linux-2.6.14/include/asm-mips/mach-generic/spaces.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-generic/spaces.h	2005-11-17 11:44:27.000000000 -0800
@@ -55,13 +55,13 @@
 #endif
 
 #ifdef CONFIG_DMA_NONCOHERENT
-#define CAC_BASE		0x9800000000000000
+#define CAC_BASE		0x9800000000000000UL
 #else
-#define CAC_BASE		0xa800000000000000
+#define CAC_BASE		0xa800000000000000UL
 #endif
-#define IO_BASE			0x9000000000000000
-#define UNCAC_BASE		0x9000000000000000
-#define MAP_BASE		0xc000000000000000
+#define IO_BASE			0x9000000000000000UL
+#define UNCAC_BASE		0x9000000000000000UL
+#define MAP_BASE		0xc000000000000000UL
 
 #define TO_PHYS(x)		(             ((x) & TO_PHYS_MASK))
 #define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
diff -Naur linux-2.6.14/include/asm-mips/mach-ip22/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip22/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-ip22/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip22/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -11,6 +11,12 @@
 /*
  * IP22 with a variety of processors so we can't use defaults for everything.
  */
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4kcache		1
+#define cpu_has_fpu		1
+#define cpu_has_32fpr		1
+#define cpu_has_counter		1
 #define cpu_has_mips16		0
 #define cpu_has_divec		0
 #define cpu_has_cache_cdex_p	1
@@ -23,6 +29,8 @@
 #define cpu_has_dc_aliases	(PAGE_SIZE < 0x4000)
 #define cpu_has_ic_fills_f_dc	0
 
+#define cpu_has_dsp		0
+
 #define cpu_has_nofpuex		0
 #define cpu_has_64bits		1
 
diff -Naur linux-2.6.14/include/asm-mips/mach-ip22/spaces.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip22/spaces.h
--- linux-2.6.14/include/asm-mips/mach-ip22/spaces.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip22/spaces.h	2005-11-17 11:44:27.000000000 -0800
@@ -44,7 +44,7 @@
 #define CAC_BASE		0xffffffff80000000
 #define IO_BASE			0xffffffffa0000000
 #define UNCAC_BASE		0xffffffffa0000000
-#define MAP_BASE		0xffffffffc0000000
+#define MAP_BASE		0xc000000000000000
 
 #define TO_PHYS(x)		(             ((x) & TO_PHYS_MASK))
 #define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
diff -Naur linux-2.6.14/include/asm-mips/mach-ip27/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-ip27/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 #define cpu_icache_snoops_remote_store	1
 
 #define cpu_has_nofpuex		0
diff -Naur linux-2.6.14/include/asm-mips/mach-ip27/kernel-entry-init.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/kernel-entry-init.h
--- linux-2.6.14/include/asm-mips/mach-ip27/kernel-entry-init.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/kernel-entry-init.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,52 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2005 Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MACH_IP27_KERNEL_ENTRY_H
+#define __ASM_MACH_IP27_KERNEL_ENTRY_H
+
+#include <asm/sn/addrs.h>
+#include <asm/sn/sn0/hubni.h>
+#include <asm/sn/klkernvars.h>
+
+/*
+ * Returns the local nasid into res.
+ */
+	.macro GET_NASID_ASM res
+	dli	\res, LOCAL_HUB_ADDR(NI_STATUS_REV_ID)
+	ld	\res, (\res)
+	and	\res, NSRI_NODEID_MASK
+	dsrl	\res, NSRI_NODEID_SHFT
+	.endm
+
+/*
+ * Intentionally empty macro, used in head.S. Override in
+ * arch/mips/mach-xxx/kernel-entry-init.h when necessary.
+ */
+	.macro	kernel_entry_setup
+	GET_NASID_ASM	t1
+	move		t2, t1			# text and data are here
+	MAPPED_KERNEL_SETUP_TLB
+	.endm
+
+/*
+ * Do SMP slave processor setup necessary before we can savely execute C code.
+ */
+	.macro	smp_slave_setup
+	GET_NASID_ASM	t1
+	dli	t0, KLDIR_OFFSET + (KLI_KERN_VARS * KLDIR_ENT_SIZE) + \
+		    KLDIR_OFF_POINTER + CAC_BASE
+	dsll	t1, NASID_SHFT
+	or	t0, t0, t1
+	ld	t0, 0(t0)			# t0 points to kern_vars struct
+	lh	t1, KV_RO_NASID_OFFSET(t0)
+	lh	t2, KV_RW_NASID_OFFSET(t0)
+	MAPPED_KERNEL_SETUP_TLB
+	ARC64_TWIDDLE_PC
+	.endm
+
+#endif /* __ASM_MACH_IP27_KERNEL_ENTRY_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-ip27/kmalloc.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/kmalloc.h
--- linux-2.6.14/include/asm-mips/mach-ip27/kmalloc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/kmalloc.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,8 @@
+#ifndef __ASM_MACH_IP27_KMALLOC_H
+#define __ASM_MACH_IP27_KMALLOC_H
+
+/*
+ * All happy, no need to define ARCH_KMALLOC_MINALIGN
+ */
+
+#endif /* __ASM_MACH_IP27_KMALLOC_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-ip27/mmzone.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/mmzone.h
--- linux-2.6.14/include/asm-mips/mach-ip27/mmzone.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/mmzone.h	2005-11-17 11:44:27.000000000 -0800
@@ -10,7 +10,6 @@
 #define LEVELS_PER_SLICE        128
 
 struct slice_data {
-	unsigned long irq_alloc_mask[2];
 	unsigned long irq_enable_mask[2];
 	int level_to_irq[LEVELS_PER_SLICE];
 };
@@ -20,6 +19,7 @@
 	DECLARE_BITMAP(h_bigwin_used, HUB_NUM_BIG_WINDOW);
 	cpumask_t	h_cpus;
 	unsigned long slice_map;
+	unsigned long irq_alloc_mask[2];
 	struct slice_data slice[2];
 };
 
diff -Naur linux-2.6.14/include/asm-mips/mach-ip27/spaces.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/spaces.h
--- linux-2.6.14/include/asm-mips/mach-ip27/spaces.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/spaces.h	2005-11-17 11:44:27.000000000 -0800
@@ -14,12 +14,13 @@
  * IP27 uses the R10000's uncached attribute feature.  Attribute 3 selects
  * uncached memory addressing.
  */
-#define CAC_BASE		0xa800000000000000
+#define CAC_BASE		0xa800000000000000UL
 
-#define HSPEC_BASE		0x9000000000000000
-#define IO_BASE			0x9200000000000000
-#define MSPEC_BASE		0x9400000000000000
-#define UNCAC_BASE		0x9600000000000000
+#define HSPEC_BASE		0x9000000000000000UL
+#define IO_BASE			0x9200000000000000UL
+#define MSPEC_BASE		0x9400000000000000UL
+#define UNCAC_BASE		0x9600000000000000UL
+#define MAP_BASE		0xc000000000000000UL
 
 #define TO_PHYS(x)		(             ((x) & TO_PHYS_MASK))
 #define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
diff -Naur linux-2.6.14/include/asm-mips/mach-ip27/topology.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/topology.h
--- linux-2.6.14/include/asm-mips/mach-ip27/topology.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip27/topology.h	2005-11-17 11:44:27.000000000 -0800
@@ -9,6 +9,9 @@
 #define parent_node(node)	(node)
 #define node_to_cpumask(node)	(hub_data(node)->h_cpus)
 #define node_to_first_cpu(node)	(first_cpu(node_to_cpumask(node)))
+struct pci_bus;
+extern int pcibus_to_node(struct pci_bus *);
+
 #define pcibus_to_cpumask(bus)	(cpu_online_map)
 
 extern unsigned char __node_distances[MAX_COMPACT_NODES][MAX_COMPACT_NODES];
diff -Naur linux-2.6.14/include/asm-mips/mach-ip32/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip32/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-ip32/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip32/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -37,5 +37,6 @@
 #define cpu_has_ejtag		0
 #define cpu_has_vtag_icache	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 
 #endif /* __ASM_MACH_IP32_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-ip32/kmalloc.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip32/kmalloc.h
--- linux-2.6.14/include/asm-mips/mach-ip32/kmalloc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip32/kmalloc.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,12 @@
+#ifndef __ASM_MACH_IP32_KMALLOC_H
+#define __ASM_MACH_IP32_KMALLOC_H
+
+#include <linux/config.h>
+
+#if defined(CONFIG_CPU_R5000) || defined (CONFIG_CPU_RM7000)
+#define ARCH_KMALLOC_MINALIGN	32
+#else
+#define ARCH_KMALLOC_MINALIGN	128
+#endif
+
+#endif /* __ASM_MACH_IP32_KMALLOC_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-ip32/spaces.h linux-mips-2.6.14.orig/include/asm-mips/mach-ip32/spaces.h
--- linux-2.6.14/include/asm-mips/mach-ip32/spaces.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ip32/spaces.h	2005-11-17 11:44:27.000000000 -0800
@@ -19,10 +19,10 @@
 #define HIGHMEM_START		(1UL << 59UL)
 #endif
 
-#define CAC_BASE		0x9800000000000000
-#define IO_BASE			0x9000000000000000
-#define UNCAC_BASE		0x9000000000000000
-#define MAP_BASE		0xc000000000000000
+#define CAC_BASE		0x9800000000000000UL
+#define IO_BASE			0x9000000000000000UL
+#define UNCAC_BASE		0x9000000000000000UL
+#define MAP_BASE		0xc000000000000000UL
 
 #define TO_PHYS(x)		(             ((x) & TO_PHYS_MASK))
 #define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
diff -Naur linux-2.6.14/include/asm-mips/mach-ja/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-ja/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-ja/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ja/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 #define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex		0
@@ -36,10 +37,4 @@
 #define cpu_icache_line_size()	32
 #define cpu_scache_line_size()	32
 
-/*
- * On the RM9000 we need to ensure that I-cache lines being fetches only
- * contain valid instructions are funny things will happen.
- */
-#define PLAT_TRAMPOLINE_STUFF_LINE	32UL
-
 #endif /* __ASM_MACH_JA_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-mips/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-mips/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-mips/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-mips/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -17,7 +17,7 @@
 #ifdef CONFIG_CPU_MIPS32
 #define cpu_has_tlb		1
 #define cpu_has_4kex		1
-#define cpu_has_4ktlb		1
+#define cpu_has_4kcache		1
 /* #define cpu_has_fpu		? */
 /* #define cpu_has_32fpr	? */
 #define cpu_has_counter		1
@@ -37,12 +37,13 @@
 /* #define cpu_has_64bits	? */
 /* #define cpu_has_64bit_zero_reg ? */
 /* #define cpu_has_subset_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
 #endif
 
 #ifdef CONFIG_CPU_MIPS64
 #define cpu_has_tlb		1
 #define cpu_has_4kex		1
-#define cpu_has_4ktlb		1
+#define cpu_has_4kcache		1
 /* #define cpu_has_fpu		? */
 /* #define cpu_has_32fpr	? */
 #define cpu_has_counter		1
@@ -62,6 +63,7 @@
 /* #define cpu_has_64bits	? */
 /* #define cpu_has_64bit_zero_reg ? */
 /* #define cpu_has_subset_pcaches ? */
+#define cpu_icache_snoops_remote_store 1
 #endif
 
 #endif /* __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-mips/irq.h linux-mips-2.6.14.orig/include/asm-mips/mach-mips/irq.h
--- linux-2.6.14/include/asm-mips/mach-mips/irq.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-mips/irq.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,14 @@
+#ifndef __ASM_MACH_MIPS_IRQ_H
+#define __ASM_MACH_MIPS_IRQ_H
+
+#include <linux/config.h>
+
+#define NR_IRQS	256
+
+#ifdef CONFIG_SMP
+
+#define ARCH_HAS_IRQ_PER_CPU
+
+#endif
+
+#endif /* __ASM_MACH_MIPS_IRQ_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-ocelot3/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -28,6 +28,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 #define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex 	0
@@ -39,10 +40,4 @@
 #define cpu_icache_line_size()	32
 #define cpu_scache_line_size()	32
 
-/*
- * On the RM9000 we need to ensure that I-cache lines being fetches only
- * contain valid instructions are funny things will happen.
- */
-#define PLAT_TRAMPOLINE_STUFF_LINE	32UL
-
 #endif /* __ASM_MACH_JA_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-pb1x00/pb1200.h linux-mips-2.6.14.orig/include/asm-mips/mach-pb1x00/pb1200.h
--- linux-2.6.14/include/asm-mips/mach-pb1x00/pb1200.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pb1x00/pb1200.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,255 @@
+/*
+ * AMD Alchemy PB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_PB1200_H
+#define __ASM_PB1200_H
+
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xAD800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_SD1WP		0x0800
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+/* not resets but in the same register */
+#define BCSR_RESETS_WSCFSM  0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+#define BCSR_RESETS_SD1MUX  0x8000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+#define BCSR_BOARD_SD1PWR	0x0080
+
+#define BCSR_LEDS_DECIMALS	0x00FF
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_VDDI	0x001F
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+#define BCSR_INT_SD1INSERT	0x4000
+#define BCSR_INT_SD1EJECT	0x8000
+
+/* PCMCIA Db1x00 specific defines */
+#define PCMCIA_MAX_SOCK 1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0D000300)
+#define AU1XXX_SMC91111_IRQ			PB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			PB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x1C000000
+
+/* Timing values as described in databook, * ns value stripped of
+ * lower 2 bits.
+ * These defines are here rather than an SOC1200 generic file because
+ * the parts chosen on another board may be different and may require
+ * different timings.
+ */
+#define NAND_T_H			(18 >> 2)
+#define NAND_T_PUL			(30 >> 2)
+#define NAND_T_SU			(30 >> 2)
+#define NAND_T_WH			(30 >> 2)
+
+/* Bitfield shift amounts */
+#define NAND_T_H_SHIFT		0
+#define NAND_T_PUL_SHIFT	4
+#define NAND_T_SU_SHIFT		8
+#define NAND_T_WH_SHIFT		12
+
+#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the PB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define PB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define PB1200_IDE_INT			(PB1200_INT_BEGIN + 0)
+#define PB1200_ETH_INT			(PB1200_INT_BEGIN + 1)
+#define PB1200_PC0_INT			(PB1200_INT_BEGIN + 2)
+#define PB1200_PC0_STSCHG_INT	(PB1200_INT_BEGIN + 3)
+#define PB1200_PC1_INT			(PB1200_INT_BEGIN + 4)
+#define PB1200_PC1_STSCHG_INT	(PB1200_INT_BEGIN + 5)
+#define PB1200_DC_INT			(PB1200_INT_BEGIN + 6)
+#define PB1200_FLASHBUSY_INT	(PB1200_INT_BEGIN + 7)
+#define PB1200_PC0_INSERT_INT	(PB1200_INT_BEGIN + 8)
+#define PB1200_PC0_EJECT_INT	(PB1200_INT_BEGIN + 9)
+#define PB1200_PC1_INSERT_INT	(PB1200_INT_BEGIN + 10)
+#define PB1200_PC1_EJECT_INT	(PB1200_INT_BEGIN + 11)
+#define PB1200_SD0_INSERT_INT	(PB1200_INT_BEGIN + 12)
+#define PB1200_SD0_EJECT_INT	(PB1200_INT_BEGIN + 13)
+#define PB1200_SD1_INSERT_INT	(PB1200_INT_BEGIN + 14)
+#define PB1200_SD1_EJECT_INT	(PB1200_INT_BEGIN + 15)
+
+#define PB1200_INT_END			(PB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT PB1200_PC0_INT
+#define BOARD_PC1_INT PB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+/* Nand chip select */
+#define NAND_CS 1
+
+#endif /* __ASM_PB1200_H */
+
diff -Naur linux-2.6.14/include/asm-mips/mach-pb1x00/pb1550.h linux-mips-2.6.14.orig/include/asm-mips/mach-pb1x00/pb1550.h
--- linux-2.6.14/include/asm-mips/mach-pb1x00/pb1550.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pb1x00/pb1550.h	2005-11-17 11:44:27.000000000 -0800
@@ -166,4 +166,11 @@
 			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
 			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
 
+#define NAND_CS 1
+
+/* should be done by yamon */
+#define NAND_STCFG  0x00400005 /* 8-bit NAND */
+#define NAND_STTIME 0x00007774 /* valid for 396MHz SD=2 only */
+#define NAND_STADDR 0x12000FFF /* physical address 0x20000000 */
+
 #endif /* __ASM_PB1550_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/cm.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/cm.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/cm.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/cm.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,43 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   Clock module specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_CM_H
+#define __PNX8550_CM_H
+
+#define PNX8550_CM_BASE	0xBBE47000
+
+#define PNX8550_CM_PLL0_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x000)
+#define PNX8550_CM_PLL1_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x004)
+#define PNX8550_CM_PLL2_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x008)
+#define PNX8550_CM_PLL3_CTL    *(volatile unsigned long *)(PNX8550_CM_BASE + 0x00C)
+
+// Table not complete.....
+
+#define PNX8550_CM_PLL_BLOCKED_MASK     0x80000000
+#define PNX8550_CM_PLL_LOCK_MASK        0x40000000
+#define PNX8550_CM_PLL_CURRENT_ADJ_MASK 0x3c000000
+#define PNX8550_CM_PLL_N_MASK           0x01ff0000
+#define PNX8550_CM_PLL_M_MASK           0x00003f00
+#define PNX8550_CM_PLL_P_MASK           0x0000000c
+#define PNX8550_CM_PLL_PD_MASK          0x00000002
+
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/glb.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/glb.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/glb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/glb.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,86 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   PNX8550 global definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_GLB_H
+#define __PNX8550_GLB_H
+
+#define PNX8550_GLB1_BASE	0xBBE63000
+#define PNX8550_GLB2_BASE	0xBBE4d000
+#define PNX8550_RESET_BASE      0xBBE60000
+
+/* PCI Inta Output Enable Registers */
+#define PNX8550_GLB2_ENAB_INTA_O	*(volatile unsigned long *)(PNX8550_GLB2_BASE + 0x050)
+
+/* Bit 1:Enable DAC Powerdown
+     0:DACs are enabled and are working normally
+     1:DACs are powerdown
+*/
+#define PNX8550_GLB_DAC_PD      0x2
+/*   Bit 0:Enable of PCI inta output
+     0 = Disable PCI inta output
+     1 = Enable PCI inta output
+*/
+#define PNX8550_GLB_ENABLE_INTA_O 0x1
+
+/* PCI Direct Mappings */
+#define PNX8550_PCIMEM	        0x12000000
+#define PNX8550_PCIMEM_SIZE	0x08000000
+#define PNX8550_PCIIO	        0x1c000000
+#define PNX8550_PCIIO_SIZE	0x02000000	/* 32M */
+
+#define PNX8550_PORT_BASE	KSEG1
+
+// GPIO def
+#define PNX8550_GPIO_BASE	0x1Be00000
+
+#define PNX8550_GPIO_DIRQ0	 (PNX8550_GPIO_BASE + 0x104500)
+#define PNX8550_GPIO_MC1         (PNX8550_GPIO_BASE + 0x104004)
+#define PNX8550_GPIO_MC_31_BIT   30
+#define PNX8550_GPIO_MC_30_BIT   28
+#define PNX8550_GPIO_MC_29_BIT   26
+#define PNX8550_GPIO_MC_28_BIT   24
+#define PNX8550_GPIO_MC_27_BIT   22
+#define PNX8550_GPIO_MC_26_BIT   20
+#define PNX8550_GPIO_MC_25_BIT   18
+#define PNX8550_GPIO_MC_24_BIT   16
+#define PNX8550_GPIO_MC_23_BIT   14
+#define PNX8550_GPIO_MC_22_BIT   12
+#define PNX8550_GPIO_MC_21_BIT   10
+#define PNX8550_GPIO_MC_20_BIT   8
+#define PNX8550_GPIO_MC_19_BIT   6
+#define PNX8550_GPIO_MC_18_BIT   4
+#define PNX8550_GPIO_MC_17_BIT   2
+#define PNX8550_GPIO_MC_16_BIT   0
+
+#define PNX8550_GPIO_MODE_PRIMOP    0x1
+#define PNX8550_GPIO_MODE_NO_OPENDR 0x2
+#define PNX8550_GPIO_MODE_OPENDR    0x3
+
+// RESET module
+#define PNX8550_RST_CTL             *(volatile unsigned long *)(PNX8550_RESET_BASE + 0x0)
+#define PNX8550_RST_CAUSE           *(volatile unsigned long *)(PNX8550_RESET_BASE + 0x4)
+#define PNX8550_RST_EN_WATCHDOG     *(volatile unsigned long *)(PNX8550_RESET_BASE + 0x8)
+
+#define PNX8550_RST_REL_MIPS_RST_N     0x8
+#define PNX8550_RST_DO_SW_RST          0x4
+#define PNX8550_RST_REL_SYS_RST_OUT    0x2
+#define PNX8550_RST_ASSERT_SYS_RST_OUT 0x1
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/int.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/int.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/int.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/int.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,140 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *   Interrupt specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_INT_H
+#define __PNX8550_INT_H
+
+#define PNX8550_GIC_BASE	0xBBE3E000
+
+#define PNX8550_GIC_PRIMASK_0	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x000)
+#define PNX8550_GIC_PRIMASK_1	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x004)
+#define PNX8550_GIC_VECTOR_0	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x100)
+#define PNX8550_GIC_VECTOR_1	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x104)
+#define PNX8550_GIC_PEND_1_31	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x200)
+#define PNX8550_GIC_PEND_32_63	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x204)
+#define PNX8550_GIC_PEND_64_70	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x208)
+#define PNX8550_GIC_FEATURES	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x300)
+#define PNX8550_GIC_REQ(x)	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0x400 + (x)*4)
+#define PNX8550_GIC_MOD_ID	*(volatile unsigned long *)(PNX8550_GIC_BASE + 0xFFC)
+
+// cp0 is two software + six hw exceptions
+#define PNX8550_INT_CP0_TOTINT	8
+#define PNX8550_INT_CP0_MIN	0
+#define PNX8550_INT_CP0_MAX	(PNX8550_INT_CP0_MIN + PNX8550_INT_CP0_TOTINT - 1)
+
+#define MIPS_CPU_GIC_IRQ        2
+#define MIPS_CPU_TIMER_IRQ      7
+
+// GIC are 71 exceptions connected to cp0's first hardware exception
+#define PNX8550_INT_GIC_TOTINT	71
+#define PNX8550_INT_GIC_MIN	(PNX8550_INT_CP0_MAX+1)
+#define PNX8550_INT_GIC_MAX	(PNX8550_INT_GIC_MIN + PNX8550_INT_GIC_TOTINT - 1)
+
+#define PNX8550_INT_UNDEF              (PNX8550_INT_GIC_MIN+0)
+#define PNX8550_INT_IPC_TARGET0_MIPS   (PNX8550_INT_GIC_MIN+1)
+#define PNX8550_INT_IPC_TARGET1_TM32_1 (PNX8550_INT_GIC_MIN+2)
+#define PNX8550_INT_IPC_TARGET1_TM32_2 (PNX8550_INT_GIC_MIN+3)
+#define PNX8550_INT_RESERVED_4         (PNX8550_INT_GIC_MIN+4)
+#define PNX8550_INT_USB                (PNX8550_INT_GIC_MIN+5)
+#define PNX8550_INT_GPIO_EQ1           (PNX8550_INT_GIC_MIN+6)
+#define PNX8550_INT_GPIO_EQ2           (PNX8550_INT_GIC_MIN+7)
+#define PNX8550_INT_GPIO_EQ3           (PNX8550_INT_GIC_MIN+8)
+#define PNX8550_INT_GPIO_EQ4           (PNX8550_INT_GIC_MIN+9)
+
+#define PNX8550_INT_GPIO_EQ5           (PNX8550_INT_GIC_MIN+10)
+#define PNX8550_INT_GPIO_EQ6           (PNX8550_INT_GIC_MIN+11)
+#define PNX8550_INT_RESERVED_12        (PNX8550_INT_GIC_MIN+12)
+#define PNX8550_INT_QVCP1              (PNX8550_INT_GIC_MIN+13)
+#define PNX8550_INT_QVCP2              (PNX8550_INT_GIC_MIN+14)
+#define PNX8550_INT_I2C1               (PNX8550_INT_GIC_MIN+15)
+#define PNX8550_INT_I2C2               (PNX8550_INT_GIC_MIN+16)
+#define PNX8550_INT_ISO_UART1          (PNX8550_INT_GIC_MIN+17)
+#define PNX8550_INT_ISO_UART2          (PNX8550_INT_GIC_MIN+18)
+#define PNX8550_INT_UART1              (PNX8550_INT_GIC_MIN+19)
+
+#define PNX8550_INT_UART2              (PNX8550_INT_GIC_MIN+20)
+#define PNX8550_INT_QNTR               (PNX8550_INT_GIC_MIN+21)
+#define PNX8550_INT_RESERVED22         (PNX8550_INT_GIC_MIN+22)
+#define PNX8550_INT_T_DSC              (PNX8550_INT_GIC_MIN+23)
+#define PNX8550_INT_M_DSC              (PNX8550_INT_GIC_MIN+24)
+#define PNX8550_INT_RESERVED25         (PNX8550_INT_GIC_MIN+25)
+#define PNX8550_INT_2D_DRAW_ENG        (PNX8550_INT_GIC_MIN+26)
+#define PNX8550_INT_MEM_BASED_SCALAR1  (PNX8550_INT_GIC_MIN+27)
+#define PNX8550_INT_VIDEO_MPEG         (PNX8550_INT_GIC_MIN+28)
+#define PNX8550_INT_VIDEO_INPUT_P1     (PNX8550_INT_GIC_MIN+29)
+
+#define PNX8550_INT_VIDEO_INPUT_P2     (PNX8550_INT_GIC_MIN+30)
+#define PNX8550_INT_SPDI1              (PNX8550_INT_GIC_MIN+31)
+#define PNX8550_INT_SPDO               (PNX8550_INT_GIC_MIN+32)
+#define PNX8550_INT_AUDIO_INPUT1       (PNX8550_INT_GIC_MIN+33)
+#define PNX8550_INT_AUDIO_OUTPUT1      (PNX8550_INT_GIC_MIN+34)
+#define PNX8550_INT_AUDIO_INPUT2       (PNX8550_INT_GIC_MIN+35)
+#define PNX8550_INT_AUDIO_OUTPUT2      (PNX8550_INT_GIC_MIN+36)
+#define PNX8550_INT_MEMBASED_SCALAR2   (PNX8550_INT_GIC_MIN+37)
+#define PNX8550_INT_VPK                (PNX8550_INT_GIC_MIN+38)
+#define PNX8550_INT_MPEG1_MIPS         (PNX8550_INT_GIC_MIN+39)
+
+#define PNX8550_INT_MPEG1_TM           (PNX8550_INT_GIC_MIN+40)
+#define PNX8550_INT_MPEG2_MIPS         (PNX8550_INT_GIC_MIN+41)
+#define PNX8550_INT_MPEG2_TM           (PNX8550_INT_GIC_MIN+42)
+#define PNX8550_INT_TS_DMA             (PNX8550_INT_GIC_MIN+43)
+#define PNX8550_INT_EDMA               (PNX8550_INT_GIC_MIN+44)
+#define PNX8550_INT_TM_DEBUG1          (PNX8550_INT_GIC_MIN+45)
+#define PNX8550_INT_TM_DEBUG2          (PNX8550_INT_GIC_MIN+46)
+#define PNX8550_INT_PCI_INTA           (PNX8550_INT_GIC_MIN+47)
+#define PNX8550_INT_CLOCK_MODULE       (PNX8550_INT_GIC_MIN+48)
+#define PNX8550_INT_PCI_XIO_INTA_PCI   (PNX8550_INT_GIC_MIN+49)
+
+#define PNX8550_INT_PCI_XIO_INTB_DMA   (PNX8550_INT_GIC_MIN+50)
+#define PNX8550_INT_PCI_XIO_INTC_GPPM  (PNX8550_INT_GIC_MIN+51)
+#define PNX8550_INT_PCI_XIO_INTD_GPXIO (PNX8550_INT_GIC_MIN+52)
+#define PNX8550_INT_DVD_CSS            (PNX8550_INT_GIC_MIN+53)
+#define PNX8550_INT_VLD                (PNX8550_INT_GIC_MIN+54)
+#define PNX8550_INT_GPIO_TSU_7_0       (PNX8550_INT_GIC_MIN+55)
+#define PNX8550_INT_GPIO_TSU_15_8      (PNX8550_INT_GIC_MIN+56)
+#define PNX8550_INT_GPIO_CTU_IR        (PNX8550_INT_GIC_MIN+57)
+#define PNX8550_INT_GPIO0              (PNX8550_INT_GIC_MIN+58)
+#define PNX8550_INT_GPIO1              (PNX8550_INT_GIC_MIN+59)
+
+#define PNX8550_INT_GPIO2              (PNX8550_INT_GIC_MIN+60)
+#define PNX8550_INT_GPIO3              (PNX8550_INT_GIC_MIN+61)
+#define PNX8550_INT_GPIO4              (PNX8550_INT_GIC_MIN+62)
+#define PNX8550_INT_GPIO5              (PNX8550_INT_GIC_MIN+63)
+#define PNX8550_INT_GPIO6              (PNX8550_INT_GIC_MIN+64)
+#define PNX8550_INT_GPIO7              (PNX8550_INT_GIC_MIN+65)
+#define PNX8550_INT_PMAN_SECURITY      (PNX8550_INT_GIC_MIN+66)
+#define PNX8550_INT_I2C3               (PNX8550_INT_GIC_MIN+67)
+#define PNX8550_INT_RESERVED_68        (PNX8550_INT_GIC_MIN+68)
+#define PNX8550_INT_SPDI2              (PNX8550_INT_GIC_MIN+69)
+
+#define PNX8550_INT_I2C4               (PNX8550_INT_GIC_MIN+70)
+
+// Timer are 3 exceptions connected to cp0's 7th hardware exception
+#define PNX8550_INT_TIMER_TOTINT       3
+#define PNX8550_INT_TIMER_MIN	       (PNX8550_INT_GIC_MAX+1)
+#define PNX8550_INT_TIMER_MAX          (PNX8550_INT_TIMER_MIN + PNX8550_INT_TIMER_TOTINT - 1)
+
+#define PNX8550_INT_TIMER1             (PNX8550_INT_TIMER_MIN+0)
+#define PNX8550_INT_TIMER2             (PNX8550_INT_TIMER_MIN+1)
+#define PNX8550_INT_TIMER3             (PNX8550_INT_TIMER_MIN+2)
+#define PNX8550_INT_WATCHDOG           PNX8550_INT_TIMER3
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/kernel-entry-init.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/kernel-entry-init.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/kernel-entry-init.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/kernel-entry-init.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,262 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005 Embedded Alley Solutions, Inc
+ */
+#ifndef __ASM_MACH_KERNEL_ENTRY_INIT_H
+#define __ASM_MACH_KERNEL_ENTRY_INIT_H
+
+#include <asm/cacheops.h>
+#include <asm/addrspace.h>
+
+#define CO_CONFIGPR_VALID  0x3F1F41FF    /* valid bits to write to ConfigPR */
+#define HAZARD_CP0 nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;
+#define CACHE_OPC      0xBC000000  /* MIPS cache instruction opcode */
+#define ICACHE_LINE_SIZE        32      /* Instruction cache line size bytes */
+#define DCACHE_LINE_SIZE        32      /* Data cache line size in bytes */
+
+#define ICACHE_SET_COUNT        256     /* Instruction cache set count */
+#define DCACHE_SET_COUNT        128     /* Data cache set count */
+
+#define ICACHE_SET_SIZE         (ICACHE_SET_COUNT * ICACHE_LINE_SIZE)
+#define DCACHE_SET_SIZE         (DCACHE_SET_COUNT * DCACHE_LINE_SIZE)
+
+	.macro	kernel_entry_setup
+	.set	push
+	.set	noreorder
+	/*
+	 * PNX8550 entry point, when running a non compressed
+	 * kernel. When loading a zImage, the head.S code in
+	 * arch/mips/zboot/pnx8550 will init the caches and,
+	 * decompress the kernel, and branch to kernel_entry.
+		 */
+cache_begin:	li	t0, (1<<28)
+	mtc0	t0, CP0_STATUS /* cp0 usable */
+	HAZARD_CP0
+
+	mtc0 	zero, CP0_CAUSE
+	HAZARD_CP0
+
+
+	/* Set static virtual to phys address translation and TLB disabled */
+	mfc0 	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+
+	and t0,~((1<<19) | (1<<20))     /* TLB/MAP cleared */
+	mtc0	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+
+	/* CPU boots with kseg0 cache algo set to 0x2 -- uncached */
+
+	init_icache
+	nop
+	init_dcache
+	nop
+
+	cachePr4450ICReset
+	nop
+
+	cachePr4450DCReset
+	nop
+
+	/* read ConfigPR into t0 */
+	mfc0	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+
+	/*  enable the TLB */
+	or      t0, (1<<19)
+
+	/* disable the ICACHE: at least 10x slower */
+	/* or      t0, (1<<26) */
+
+	/* disable the DCACHE; CONFIG_CPU_HAS_LLSC should not be set  */
+	/* or      t0, (1<<27) */
+
+	and	t0, CO_CONFIGPR_VALID
+
+	/* enable TLB. */
+	mtc0	t0, CP0_CONFIG, 7
+	HAZARD_CP0
+cache_end:
+	/* Setup CMEM_0 to MMIO address space, 2MB */
+	lui    t0, 0x1BE0
+	addi   t0, t0, 0x3
+	mtc0   $8, $22, 4
+	nop
+
+	/* Setup CMEM_1, 128MB */
+	lui    t0, 0x1000
+	addi   t0, t0, 0xf
+	mtc0   $8, $22, 5
+	nop
+
+
+	/* Setup CMEM_2, 32MB */
+	lui    t0, 0x1C00
+	addi   t0, t0, 0xb
+	mtc0   $8, $22, 6
+	nop
+
+	/* Setup CMEM_3, 0MB */
+	lui    t0, 0x0
+	addi   t0, t0, 0x0
+	mtc0   $8, $22, 7
+	nop
+
+	/* Enable cache */
+	mfc0	t0, CP0_CONFIG
+	HAZARD_CP0
+	and	t0, t0, 0xFFFFFFF8
+	or	t0, t0, 3
+	mtc0	t0, CP0_CONFIG
+	HAZARD_CP0
+	.set	pop
+	.endm
+
+	.macro	init_icache
+	.set	push
+	.set	noreorder
+
+	/* Get Cache Configuration */
+	mfc0	t3, CP0_CONFIG, 1
+	HAZARD_CP0
+
+	/* get cache Line size */
+
+	srl   t1, t3, 19   /* C0_CONFIGPR_IL_SHIFT */
+	andi  t1, t1, 0x7  /* C0_CONFIGPR_IL_MASK */
+	beq   t1, zero, pr4450_instr_cache_invalidated /* if zero instruction cache is absent */
+	nop
+	addiu t0, t1, 1
+	ori   t1, zero, 1
+	sllv  t1, t1, t0
+
+	/* get max cache Index */
+	srl   t2, t3, 22  /* C0_CONFIGPR_IS_SHIFT */
+	andi  t2, t2, 0x7 /* C0_CONFIGPR_IS_MASK */
+	addiu t0, t2, 6
+	ori   t2, zero, 1
+	sllv  t2, t2, t0
+
+	/* get max cache way */
+	srl   t3, t3, 16  /* C0_CONFIGPR_IA_SHIFT */
+	andi  t3, t3, 0x7 /* C0_CONFIGPR_IA_MASK */
+	addiu t3, t3, 1
+
+	/* total no of cache lines */
+	multu t2, t3             /* max index * max way */
+	mflo  t2
+	addiu t2, t2, -1
+
+	move  t0, zero
+pr4450_next_instruction_cache_set:
+	cache  Index_Invalidate_I, 0(t0)
+	addu  t0, t0, t1         /* add bytes in a line */
+	bne   t2, zero, pr4450_next_instruction_cache_set
+	addiu t2, t2, -1   /* reduce no of lines to invalidate by one */
+pr4450_instr_cache_invalidated:
+	.set	pop
+	.endm
+
+	.macro	init_dcache
+	.set	push
+	.set	noreorder
+	move t1, zero
+
+	/* Store Tag Information */
+	mtc0	zero, CP0_TAGLO, 0
+	HAZARD_CP0
+
+	mtc0	zero, CP0_TAGHI, 0
+	HAZARD_CP0
+
+	/* Cache size is 16384 = 512 lines x 32 bytes per line */
+	or       t2, zero, (128*4)-1  /* 512 lines  */
+	/* Invalidate all lines */
+2:
+	cache Index_Store_Tag_D, 0(t1)
+	addiu    t2, t2, -1
+	bne      t2, zero, 2b
+	addiu    t1, t1, 32        /* 32 bytes in a line */
+	.set pop
+	.endm
+
+	.macro	cachePr4450ICReset
+	.set	push
+	.set	noreorder
+
+	/* Save CP0 status reg on entry; */
+	/* disable interrupts during cache reset */
+	mfc0    t0, CP0_STATUS      /* T0 = interrupt status on entry */
+	HAZARD_CP0
+
+	mtc0    zero, CP0_STATUS   /* disable CPU interrupts */
+	HAZARD_CP0
+
+	or      t1, zero, zero              /* T1 = starting cache index (0) */
+	ori     t2, zero, (256 - 1) /* T2 = inst cache set cnt - 1 */
+
+	icache_invd_loop:
+	/* 9 == register t1 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Invalidate_I << 16) | \
+		(0 * ICACHE_SET_SIZE))  /* invalidate inst cache WAY0 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Invalidate_I << 16) | \
+		(1 * ICACHE_SET_SIZE))  /* invalidate inst cache WAY1 */
+
+	addiu   t1, t1, ICACHE_LINE_SIZE    /* T1 = next cache line index */
+	bne     t2, zero, icache_invd_loop /* T2 = 0 if all sets invalidated */
+	addiu   t2, t2, -1        /* decrement T2 set cnt (delay slot) */
+
+	/* Initialize the latches in the instruction cache tag */
+	/* that drive the way selection tri-state bus drivers, by doing a */
+	/* dummy load while the instruction cache is still disabled. */
+	/* TODO: Is this needed ? */
+	la      t1, KSEG0            /* T1 = cached memory base address */
+	lw      zero, 0x0000(t1)      /* (dummy read of first memory word) */
+
+	mtc0    t0, CP0_STATUS        /* restore interrupt status on entry */
+	HAZARD_CP0
+	.set	pop
+	.endm
+
+	.macro	cachePr4450DCReset
+	.set	push
+	.set	noreorder
+	mfc0    t0, CP0_STATUS           /* T0 = interrupt status on entry */
+	HAZARD_CP0
+	mtc0    zero, CP0_STATUS         /* disable CPU interrupts */
+	HAZARD_CP0
+
+	/* Writeback/invalidate entire data cache sets/ways/lines */
+	or      t1, zero, zero              /* T1 = starting cache index (0) */
+	ori     t2, zero, (DCACHE_SET_COUNT - 1) /* T2 = data cache set cnt - 1 */
+
+	dcache_wbinvd_loop:
+	/* 9 == register t1 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(0 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY0 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(1 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY1 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(2 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY2 */
+	.word   (CACHE_OPC | (9 << 21) | (Index_Writeback_Inv_D << 16) | \
+		(3 * DCACHE_SET_SIZE))  /* writeback/invalidate WAY3 */
+
+	addiu   t1, t1, DCACHE_LINE_SIZE  /* T1 = next data cache line index */
+	bne     t2, zero, dcache_wbinvd_loop /* T2 = 0 when wbinvd entire cache */
+	addiu   t2, t2, -1          /* decrement T2 set cnt (delay slot) */
+
+	/* Initialize the latches in the data cache tag that drive the way
+	selection tri-state bus drivers, by doing a dummy load while the
+	data cache is still in the disabled mode.  TODO: Is this needed ? */
+	la      t1, KSEG0            /* T1 = cached memory base address */
+	lw      zero, 0x0000(t1)      /* (dummy read of first memory word) */
+
+	mtc0    t0, CP0_STATUS       /* restore interrupt status on entry */
+	HAZARD_CP0
+	.set	pop
+	.endm
+
+#endif /* __ASM_MACH_KERNEL_ENTRY_INIT_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/nand.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/nand.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/nand.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/nand.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,121 @@
+#ifndef __PNX8550_NAND_H
+#define __PNX8550_NAND_H
+
+#define PNX8550_NAND_BASE_ADDR   0x10000000
+#define PNX8550_PCIXIO_BASE	 0xBBE40000
+
+#define PNX8550_DMA_EXT_ADDR     *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x800)
+#define PNX8550_DMA_INT_ADDR     *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x804)
+#define PNX8550_DMA_TRANS_SIZE   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x808)
+#define PNX8550_DMA_CTRL         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x80c)
+#define PNX8550_XIO_SEL0         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x814)
+#define PNX8550_GPXIO_ADDR       *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x820)
+#define PNX8550_GPXIO_WR         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x824)
+#define PNX8550_GPXIO_RD         *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x828)
+#define PNX8550_GPXIO_CTRL       *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x82C)
+#define PNX8550_XIO_FLASH_CTRL   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0x830)
+#define PNX8550_GPXIO_INT_STATUS *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfb0)
+#define PNX8550_GPXIO_INT_ENABLE *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfb4)
+#define PNX8550_GPXIO_INT_CLEAR  *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfb8)
+#define PNX8550_DMA_INT_STATUS   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfd0)
+#define PNX8550_DMA_INT_ENABLE   *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfd4)
+#define PNX8550_DMA_INT_CLEAR    *(volatile unsigned long *)(PNX8550_PCIXIO_BASE + 0xfd8)
+
+#define PNX8550_XIO_SEL0_EN_16BIT    0x00800000
+#define PNX8550_XIO_SEL0_USE_ACK     0x00400000
+#define PNX8550_XIO_SEL0_REN_HIGH    0x00100000
+#define PNX8550_XIO_SEL0_REN_LOW     0x00040000
+#define PNX8550_XIO_SEL0_WEN_HIGH    0x00010000
+#define PNX8550_XIO_SEL0_WEN_LOW     0x00004000
+#define PNX8550_XIO_SEL0_WAIT        0x00000200
+#define PNX8550_XIO_SEL0_OFFSET      0x00000020
+#define PNX8550_XIO_SEL0_TYPE_68360  0x00000000
+#define PNX8550_XIO_SEL0_TYPE_NOR    0x00000008
+#define PNX8550_XIO_SEL0_TYPE_NAND   0x00000010
+#define PNX8550_XIO_SEL0_TYPE_IDE    0x00000018
+#define PNX8550_XIO_SEL0_SIZE_8MB    0x00000000
+#define PNX8550_XIO_SEL0_SIZE_16MB   0x00000002
+#define PNX8550_XIO_SEL0_SIZE_32MB   0x00000004
+#define PNX8550_XIO_SEL0_SIZE_64MB   0x00000006
+#define PNX8550_XIO_SEL0_ENAB        0x00000001
+
+#define PNX8550_SEL0_DEFAULT ((PNX8550_XIO_SEL0_EN_16BIT)  | \
+                              (PNX8550_XIO_SEL0_REN_HIGH*0)| \
+	                      (PNX8550_XIO_SEL0_REN_LOW*2) | \
+	                      (PNX8550_XIO_SEL0_WEN_HIGH*0)| \
+                              (PNX8550_XIO_SEL0_WEN_LOW*2) | \
+	                      (PNX8550_XIO_SEL0_WAIT*4)    | \
+			      (PNX8550_XIO_SEL0_OFFSET*0)  | \
+			      (PNX8550_XIO_SEL0_TYPE_NAND) | \
+			      (PNX8550_XIO_SEL0_SIZE_32MB) | \
+			      (PNX8550_XIO_SEL0_ENAB))
+
+#define PNX8550_GPXIO_PENDING        0x00000200
+#define PNX8550_GPXIO_DONE           0x00000100
+#define PNX8550_GPXIO_CLR_DONE       0x00000080
+#define PNX8550_GPXIO_INIT           0x00000040
+#define PNX8550_GPXIO_READ_CMD       0x00000010
+#define PNX8550_GPXIO_BEN            0x0000000F
+
+#define PNX8550_XIO_FLASH_64MB       0x00200000
+#define PNX8550_XIO_FLASH_INC_DATA   0x00100000
+#define PNX8550_XIO_FLASH_CMD_PH     0x000C0000
+#define PNX8550_XIO_FLASH_CMD_PH2    0x00080000
+#define PNX8550_XIO_FLASH_CMD_PH1    0x00040000
+#define PNX8550_XIO_FLASH_CMD_PH0    0x00000000
+#define PNX8550_XIO_FLASH_ADR_PH     0x00030000
+#define PNX8550_XIO_FLASH_ADR_PH3    0x00030000
+#define PNX8550_XIO_FLASH_ADR_PH2    0x00020000
+#define PNX8550_XIO_FLASH_ADR_PH1    0x00010000
+#define PNX8550_XIO_FLASH_ADR_PH0    0x00000000
+#define PNX8550_XIO_FLASH_CMD_B(x)   ((x<<8) & 0x0000FF00)
+#define PNX8550_XIO_FLASH_CMD_A(x)   (x & 0x000000FF)
+
+#define PNX8550_XIO_INT_ACK          0x00004000
+#define PNX8550_XIO_INT_COMPL        0x00002000
+#define PNX8550_XIO_INT_NONSUP       0x00000200
+#define PNX8550_XIO_INT_ABORT        0x00000004
+
+#define PNX8550_DMA_CTRL_SINGLE_DATA 0x00000400
+#define PNX8550_DMA_CTRL_SND2XIO     0x00000200
+#define PNX8550_DMA_CTRL_FIX_ADDR    0x00000100
+#define PNX8550_DMA_CTRL_BURST_8     0x00000000
+#define PNX8550_DMA_CTRL_BURST_16    0x00000020
+#define PNX8550_DMA_CTRL_BURST_32    0x00000040
+#define PNX8550_DMA_CTRL_BURST_64    0x00000060
+#define PNX8550_DMA_CTRL_BURST_128   0x00000080
+#define PNX8550_DMA_CTRL_BURST_256   0x000000A0
+#define PNX8550_DMA_CTRL_BURST_512   0x000000C0
+#define PNX8550_DMA_CTRL_BURST_NORES 0x000000E0
+#define PNX8550_DMA_CTRL_INIT_DMA    0x00000010
+#define PNX8550_DMA_CTRL_CMD_TYPE    0x0000000F
+
+/* see PCI system arch, page 100 for the full list: */
+#define PNX8550_DMA_CTRL_PCI_CMD_READ    0x00000006
+#define PNX8550_DMA_CTRL_PCI_CMD_WRITE   0x00000007
+
+#define PNX8550_DMA_INT_STAT_ACK_DONE	(1<<14)
+#define PNX8550_DMA_INT_STAT_DMA_DONE	(1<<12)
+#define PNX8550_DMA_INT_STAT_DMA_ERR	(1<<9)
+#define PNX8550_DMA_INT_STAT_PERR5	(1<<5)
+#define PNX8550_DMA_INT_STAT_PERR4	(1<<4)
+#define PNX8550_DMA_INT_STAT_M_ABORT	(1<<2)
+#define PNX8550_DMA_INT_STAT_T_ABORT	(1<<1)
+
+#define PNX8550_DMA_INT_EN_ACK_DONE	(1<<14)
+#define PNX8550_DMA_INT_EN_DMA_DONE	(1<<12)
+#define PNX8550_DMA_INT_EN_DMA_ERR	(1<<9)
+#define PNX8550_DMA_INT_EN_PERR5	(1<<5)
+#define PNX8550_DMA_INT_EN_PERR4	(1<<4)
+#define PNX8550_DMA_INT_EN_M_ABORT	(1<<2)
+#define PNX8550_DMA_INT_EN_T_ABORT	(1<<1)
+
+#define PNX8550_DMA_INT_CLR_ACK_DONE	(1<<14)
+#define PNX8550_DMA_INT_CLR_DMA_DONE	(1<<12)
+#define PNX8550_DMA_INT_CLR_DMA_ERR	(1<<9)
+#define PNX8550_DMA_INT_CLR_PERR5	(1<<5)
+#define PNX8550_DMA_INT_CLR_PERR4	(1<<4)
+#define PNX8550_DMA_INT_CLR_M_ABORT	(1<<2)
+#define PNX8550_DMA_INT_CLR_T_ABORT	(1<<1)
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/pci.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/pci.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/pci.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/pci.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,185 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ * PCI specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_PCI_H
+#define __PNX8550_PCI_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+#define PCI_CMD_IOR                     0x20
+#define PCI_CMD_IOW                     0x30
+#define PCI_CMD_CONFIG_READ             0xa0
+#define PCI_CMD_CONFIG_WRITE            0xb0
+
+#define PCI_IO_TIMEOUT                  1000
+#define PCI_IO_RETRY			5
+/* Timeout for IO and CFG accesses.
+   This is in 1/1024 th of a jiffie(=10ms)
+   i.e. approx 10us */
+#define PCI_IO_JIFFIES_TIMEOUT          40
+#define PCI_IO_JIFFIES_SHIFT            10
+
+#define PCI_BYTE_ENABLE_MASK		0x0000000f
+#define PCI_CFG_BUS_SHIFT               16
+#define PCI_CFG_FUNC_SHIFT              8
+#define PCI_CFG_REG_SHIFT               2
+
+#define PCI_BASE                  0x1be00000
+#define PCI_SETUP                 0x00040010
+#define PCI_DIS_REQGNT           (1<<30)
+#define PCI_DIS_REQGNTA          (1<<29)
+#define PCI_DIS_REQGNTB          (1<<28)
+#define PCI_D2_SUPPORT           (1<<27)
+#define PCI_D1_SUPPORT           (1<<26)
+#define PCI_EN_TA                (1<<24)
+#define PCI_EN_PCI2MMI           (1<<23)
+#define PCI_EN_XIO               (1<<22)
+#define PCI_BASE18_PREF          (1<<21)
+#define SIZE_16M                 0x3
+#define SIZE_32M                 0x4
+#define SIZE_64M                 0x5
+#define SIZE_128M                0x6
+#define PCI_SETUP_BASE18_SIZE(X) (X<<18)
+#define PCI_SETUP_BASE18_EN      (1<<17)
+#define PCI_SETUP_BASE14_PREF    (1<<16)
+#define PCI_SETUP_BASE14_SIZE(X) (X<<12)
+#define PCI_SETUP_BASE14_EN      (1<<11)
+#define PCI_SETUP_BASE10_PREF    (1<<10)
+#define PCI_SETUP_BASE10_SIZE(X) (X<<7)
+#define PCI_SETUP_CFGMANAGE_EN   (1<<1)
+#define PCI_SETUP_PCIARB_EN      (1<<0)
+
+#define PCI_CTRL                  0x040014
+#define PCI_SWPB_DCS_PCI         (1<<16)
+#define PCI_SWPB_PCI_PCI         (1<<15)
+#define PCI_SWPB_PCI_DCS         (1<<14)
+#define PCI_REG_WR_POST          (1<<13)
+#define PCI_XIO_WR_POST          (1<<12)
+#define PCI_PCI2_WR_POST         (1<<13)
+#define PCI_PCI1_WR_POST         (1<<12)
+#define PCI_SERR_SEEN            (1<<11)
+#define PCI_B10_SPEC_RD          (1<<6)
+#define PCI_B14_SPEC_RD          (1<<5)
+#define PCI_B18_SPEC_RD          (1<<4)
+#define PCI_B10_NOSUBWORD        (1<<3)
+#define PCI_B14_NOSUBWORD        (1<<2)
+#define PCI_B18_NOSUBWORD        (1<<1)
+#define PCI_RETRY_TMREN          (1<<0)
+
+#define PCI_BASE1_LO              0x040018
+#define PCI_BASE1_HI              0x04001C
+#define PCI_BASE2_LO              0x040020
+#define PCI_BASE2_HI              0x040024
+#define PCI_RDLIFETIM             0x040028
+#define PCI_GPPM_ADDR             0x04002C
+#define PCI_GPPM_WDAT             0x040030
+#define PCI_GPPM_RDAT             0x040034
+#define PCI_GPPM_CTRL             0x040038
+#define GPPM_DONE                (1<<10)
+#define INIT_PCI_CYCLE           (1<<9)
+#define GPPM_CMD(X)              (((X)&0xf)<<4)
+#define GPPM_BYTEEN(X)           ((X)&0xf)
+#define PCI_UNLOCKREG             0x04003C
+#define UNLOCK_SSID(X)           (((X)&0xff)<<8)
+#define UNLOCK_SETUP(X)          (((X)&0xff)<<0)
+#define UNLOCK_MAGIC             0xCA
+#define PCI_DEV_VEND_ID           0x040040
+#define DEVICE_ID(X)             (((X)>>16)&0xffff)
+#define VENDOR_ID(X)             (((X)&0xffff))
+#define PCI_CFG_CMDSTAT           0x040044
+#define PCI_CFG_STATUS(X)            (((X)>>16)&0xffff)
+#define PCI_CFG_COMMAND(X)           ((X)&0xffff)
+#define PCI_CLASS_REV             0x040048
+#define PCI_CLASSCODE(X)         (((X)>>8)&0xffffff)
+#define PCI_REVID(X)             ((X)&0xff)
+#define PCI_LAT_TMR     0x04004c
+#define PCI_BASE10      0x040050
+#define PCI_BASE14      0x040054
+#define PCI_BASE18      0x040058
+#define PCI_SUBSYS_ID   0x04006c
+#define PCI_CAP_PTR     0x040074
+#define PCI_CFG_MISC    0x04007c
+#define PCI_PMC         0x040080
+#define PCI_PWR_STATE   0x040084
+#define PCI_IO          0x040088
+#define PCI_SLVTUNING   0x04008C
+#define PCI_DMATUNING   0x040090
+#define PCI_DMAEADDR    0x040800
+#define PCI_DMAIADDR    0x040804
+#define PCI_DMALEN      0x040808
+#define PCI_DMACTRL     0x04080C
+#define PCI_XIOCTRL     0x040810
+#define PCI_SEL0PROF    0x040814
+#define PCI_SEL1PROF    0x040818
+#define PCI_SEL2PROF    0x04081C
+#define PCI_GPXIOADDR   0x040820
+#define PCI_NANDCTRLS   0x400830
+#define PCI_SEL3PROF    0x040834
+#define PCI_SEL4PROF    0x040838
+#define PCI_GPXIO_STAT  0x040FB0
+#define PCI_GPXIO_IMASK 0x040FB4
+#define PCI_GPXIO_ICLR  0x040FB8
+#define PCI_GPXIO_ISET  0x040FBC
+#define PCI_GPPM_STATUS 0x040FC0
+#define GPPM_DONE      (1<<10)
+#define GPPM_ERR       (1<<9)
+#define GPPM_MPAR_ERR  (1<<8)
+#define GPPM_PAR_ERR   (1<<7)
+#define GPPM_R_MABORT  (1<<2)
+#define GPPM_R_TABORT  (1<<1)
+#define PCI_GPPM_IMASK  0x040FC4
+#define PCI_GPPM_ICLR   0x040FC8
+#define PCI_GPPM_ISET   0x040FCC
+#define PCI_DMA_STATUS  0x040FD0
+#define PCI_DMA_IMASK   0x040FD4
+#define PCI_DMA_ICLR    0x040FD8
+#define PCI_DMA_ISET    0x040FDC
+#define PCI_ISTATUS     0x040FE0
+#define PCI_IMASK       0x040FE4
+#define PCI_ICLR        0x040FE8
+#define PCI_ISET        0x040FEC
+#define PCI_MOD_ID      0x040FFC
+
+/*
+ *  PCI configuration cycle AD bus definition
+ */
+/* Type 0 */
+#define PCI_CFG_TYPE0_REG_SHF           0
+#define PCI_CFG_TYPE0_FUNC_SHF          8
+
+/* Type 1 */
+#define PCI_CFG_TYPE1_REG_SHF           0
+#define PCI_CFG_TYPE1_FUNC_SHF          8
+#define PCI_CFG_TYPE1_DEV_SHF           11
+#define PCI_CFG_TYPE1_BUS_SHF           16
+
+/*
+ *  Ethernet device DP83816 definition
+ */
+#define DP83816_IRQ_ETHER               66
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/uart.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/uart.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/uart.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/uart.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,16 @@
+#ifndef __IP3106_UART_H
+#define __IP3106_UART_H
+
+#include <int.h>
+
+/* early macros for kgdb use. fixme: clean this up */
+
+#define UART_BASE		0xbbe4a000	/* PNX8550 */
+
+#define PNX8550_UART_PORT0	(UART_BASE)
+#define PNX8550_UART_PORT1	(UART_BASE + 0x1000)
+
+#define PNX8550_UART_INT(x)		(PNX8550_INT_GIC_MIN+19+x)
+#define IRQ_TO_UART(x)			(x-PNX8550_INT_GIC_MIN-19)
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-pnx8550/usb.h linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/usb.h
--- linux-2.6.14/include/asm-mips/mach-pnx8550/usb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-pnx8550/usb.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  USB specific definitions
+ *
+ * Author: source@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#ifndef __PNX8550_USB_H
+#define __PNX8550_USB_H
+
+/*
+ * USB Host controller
+ */
+
+#define PNX8550_USB_OHCI_OP_BASE	0x1be48000
+#define PNX8550_USB_OHCI_OP_LEN	        0x1000
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mach-rm200/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-rm200/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-rm200/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-rm200/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -14,7 +14,7 @@
 
 #define cpu_has_tlb		1
 #define cpu_has_4kex		1
-#define cpu_has_4ktlb		1
+#define cpu_has_4kcache		1
 #define cpu_has_fpu		1
 #define cpu_has_32fpr		1
 #define cpu_has_counter		1
@@ -31,6 +31,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	(PAGE_SIZE < 0x4000)
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 #define cpu_has_nofpuex		0
 #define cpu_has_64bits		1
 
diff -Naur linux-2.6.14/include/asm-mips/mach-sibyte/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-sibyte/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-sibyte/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-sibyte/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	1
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 #define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex		0
diff -Naur linux-2.6.14/include/asm-mips/mach-sim/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-sim/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-sim/cpu-feature-overrides.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-sim/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,66 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Chris Dearman
+ */
+#ifndef __ASM_MACH_SIM_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_SIM_CPU_FEATURE_OVERRIDES_H
+
+#include <linux/config.h>
+
+/*
+ * CPU feature overrides for MIPS boards
+ */
+#ifdef CONFIG_CPU_MIPS32
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4kcache		1
+#define cpu_has_fpu		0
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_subset_pcaches ? */
+#endif
+
+#ifdef CONFIG_CPU_MIPS64
+#define cpu_has_tlb		1
+#define cpu_has_4kex		1
+#define cpu_has_4kcache		1
+/* #define cpu_has_fpu		? */
+/* #define cpu_has_32fpr	? */
+#define cpu_has_counter		1
+/* #define cpu_has_watch	? */
+#define cpu_has_divec		1
+#define cpu_has_vce		0
+/* #define cpu_has_cache_cdex_p	? */
+/* #define cpu_has_cache_cdex_s	? */
+/* #define cpu_has_prefetch	? */
+#define cpu_has_mcheck		1
+/* #define cpu_has_ejtag	? */
+#define cpu_has_llsc		1
+/* #define cpu_has_vtag_icache	? */
+/* #define cpu_has_dc_aliases	? */
+/* #define cpu_has_ic_fills_f_dc ? */
+#define cpu_has_nofpuex		0
+/* #define cpu_has_64bits	? */
+/* #define cpu_has_64bit_zero_reg ? */
+/* #define cpu_has_subset_pcaches ? */
+#endif
+
+#endif /* __ASM_MACH_MIPS_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-vr41xx/timex.h linux-mips-2.6.14.orig/include/asm-mips/mach-vr41xx/timex.h
--- linux-2.6.14/include/asm-mips/mach-vr41xx/timex.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-vr41xx/timex.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,18 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003 by Ralf Baechle
+ */
+/*
+ * Changes:
+ *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  - CLOCK_TICK_RATE is changed into 32768 from 6144000.
+ */
+#ifndef __ASM_MACH_VR41XX_TIMEX_H
+#define __ASM_MACH_VR41XX_TIMEX_H
+
+#define CLOCK_TICK_RATE		32768
+
+#endif /* __ASM_MACH_VR41XX_TIMEX_H */
diff -Naur linux-2.6.14/include/asm-mips/mach-yosemite/cpu-feature-overrides.h linux-mips-2.6.14.orig/include/asm-mips/mach-yosemite/cpu-feature-overrides.h
--- linux-2.6.14/include/asm-mips/mach-yosemite/cpu-feature-overrides.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mach-yosemite/cpu-feature-overrides.h	2005-11-17 11:44:27.000000000 -0800
@@ -25,6 +25,7 @@
 #define cpu_has_vtag_icache	0
 #define cpu_has_dc_aliases	0
 #define cpu_has_ic_fills_f_dc	0
+#define cpu_has_dsp		0
 #define cpu_icache_snoops_remote_store	0
 
 #define cpu_has_nofpuex		0
@@ -36,10 +37,4 @@
 #define cpu_icache_line_size()	32
 #define cpu_scache_line_size()	32
 
-/*
- * On the RM9000 we need to ensure that I-cache lines being fetches only
- * contain valid instructions are funny things will happen.
- */
-#define PLAT_TRAMPOLINE_STUFF_LINE	32UL
-
 #endif /* __ASM_MACH_YOSEMITE_CPU_FEATURE_OVERRIDES_H */
diff -Naur linux-2.6.14/include/asm-mips/mips-boards/generic.h linux-mips-2.6.14.orig/include/asm-mips/mips-boards/generic.h
--- linux-2.6.14/include/asm-mips/mips-boards/generic.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mips-boards/generic.h	2005-11-17 11:44:27.000000000 -0800
@@ -66,6 +66,7 @@
 #define MIPS_REVISION_CORID_CORE_EMUL      6
 #define MIPS_REVISION_CORID_CORE_FPGA2     7
 #define MIPS_REVISION_CORID_CORE_FPGAR2    8
+#define MIPS_REVISION_CORID_CORE_FPGA3     9
 
 /**** Artificial corid defines ****/
 /*
@@ -79,4 +80,10 @@
 
 extern unsigned int mips_revision_corid;
 
+#ifdef CONFIG_PCI
+extern void mips_pcibios_init(void);
+#else
+#define mips_pcibios_init() do { } while (0)
+#endif
+
 #endif  /* __ASM_MIPS_BOARDS_GENERIC_H */
diff -Naur linux-2.6.14/include/asm-mips/mips-boards/maltaint.h linux-mips-2.6.14.orig/include/asm-mips/mips-boards/maltaint.h
--- linux-2.6.14/include/asm-mips/mips-boards/maltaint.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mips-boards/maltaint.h	2005-11-17 11:44:27.000000000 -0800
@@ -25,9 +25,63 @@
 #ifndef _MIPS_MALTAINT_H
 #define _MIPS_MALTAINT_H
 
-/* Number of IRQ supported on hw interrupt 0. */
-#define MALTAINT_END      16
+/*
+ * Interrupts 0..15 are used for Malta ISA compatible interrupts
+ */
+#define MALTA_INT_BASE		0
 
+/*
+ * Interrupts 16..23 are used for Malta CPU interrupts (nonEIC mode)
+ */
+#define MIPSCPU_INT_BASE	16
+
+/* CPU interrupt offsets */
+#define MIPSCPU_INT_SW0		0
+#define MIPSCPU_INT_SW1		1
+#define MIPSCPU_INT_MB0		2
+#define MIPSCPU_INT_I8259A	MIPSCPU_INT_MB0
+#define MIPSCPU_INT_MB1		3
+#define MIPSCPU_INT_SMI		MIPSCPU_INT_MB1
+#define MIPSCPU_INT_MB2		4
+#define MIPSCPU_INT_MB3		5
+#define MIPSCPU_INT_COREHI	MIPSCPU_INT_MB3
+#define MIPSCPU_INT_MB4		6
+#define MIPSCPU_INT_CORELO	MIPSCPU_INT_MB4
+#define MIPSCPU_INT_CPUCTR	7
+
+/*
+ * Interrupts 64..127 are used for Soc-it Classic interrupts
+ */
+#define MSC01C_INT_BASE		64
+
+/* SOC-it Classic interrupt offsets */
+#define MSC01C_INT_TMR		0
+#define MSC01C_INT_PCI		1
+
+/*
+ * Interrupts 64..127 are used for Soc-it EIC interrupts
+ */
+#define MSC01E_INT_BASE		64
+
+/* SOC-it EIC interrupt offsets */
+#define MSC01E_INT_SW0		1
+#define MSC01E_INT_SW1		2
+#define MSC01E_INT_MB0		3
+#define MSC01E_INT_I8259A	MSC01E_INT_MB0
+#define MSC01E_INT_MB1		4
+#define MSC01E_INT_SMI		MSC01E_INT_MB1
+#define MSC01E_INT_MB2		5
+#define MSC01E_INT_MB3		6
+#define MSC01E_INT_COREHI	MSC01E_INT_MB3
+#define MSC01E_INT_MB4		7
+#define MSC01E_INT_CORELO	MSC01E_INT_MB4
+#define MSC01E_INT_TMR		8
+#define MSC01E_INT_PCI		9
+#define MSC01E_INT_PERFCTR	10
+#define MSC01E_INT_CPUCTR	11
+
+#ifndef __ASSEMBLY__
 extern void maltaint_init(void);
+#endif
 
 #endif /* !(_MIPS_MALTAINT_H) */
diff -Naur linux-2.6.14/include/asm-mips/mips-boards/msc01_pci.h linux-mips-2.6.14.orig/include/asm-mips/mips-boards/msc01_pci.h
--- linux-2.6.14/include/asm-mips/mips-boards/msc01_pci.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mips-boards/msc01_pci.h	2005-11-17 11:44:27.000000000 -0800
@@ -1,8 +1,9 @@
 /*
  * PCI Register definitions for the MIPS System Controller.
  *
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2002, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -29,22 +30,22 @@
 #define MSC01_PCI_CFGADDR_OFS		0x0610
 #define MSC01_PCI_CFGDATA_OFS		0x0618
 #define MSC01_PCI_IACK_OFS		0x0620
-#define MSC01_PCI_HEAD0_OFS		0x2000  /* DevID, VendorID */
-#define MSC01_PCI_HEAD1_OFS		0x2008  /* Status, Command */
-#define MSC01_PCI_HEAD2_OFS		0x2010  /* Class code, RevID */
-#define MSC01_PCI_HEAD3_OFS		0x2018  /* bist, header, latency */
-#define MSC01_PCI_HEAD4_OFS		0x2020  /* BAR 0 */
-#define MSC01_PCI_HEAD5_OFS		0x2028  /* BAR 1 */
-#define MSC01_PCI_HEAD6_OFS		0x2030  /* BAR 2 */
-#define MSC01_PCI_HEAD7_OFS		0x2038  /* BAR 3 */
-#define MSC01_PCI_HEAD8_OFS		0x2040  /* BAR 4 */
-#define MSC01_PCI_HEAD9_OFS		0x2048  /* BAR 5 */
-#define MSC01_PCI_HEAD10_OFS		0x2050  /* CardBus CIS Ptr */
-#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
-#define MSC01_PCI_HEAD12_OFS		0x2060  /* ROM BAR */
-#define MSC01_PCI_HEAD13_OFS		0x2068  /* Capabilities ptr */
-#define MSC01_PCI_HEAD14_OFS		0x2070  /* reserved */
-#define MSC01_PCI_HEAD15_OFS		0x2078  /* Maxl, ming, intpin, int */
+#define MSC01_PCI_HEAD0_OFS		0x2000	/* DevID, VendorID */
+#define MSC01_PCI_HEAD1_OFS		0x2008	/* Status, Command */
+#define MSC01_PCI_HEAD2_OFS		0x2010	/* Class code, RevID */
+#define MSC01_PCI_HEAD3_OFS		0x2018	/* bist, header, latency */
+#define MSC01_PCI_HEAD4_OFS		0x2020	/* BAR 0 */
+#define MSC01_PCI_HEAD5_OFS		0x2028	/* BAR 1 */
+#define MSC01_PCI_HEAD6_OFS		0x2030	/* BAR 2 */
+#define MSC01_PCI_HEAD7_OFS		0x2038	/* BAR 3 */
+#define MSC01_PCI_HEAD8_OFS		0x2040	/* BAR 4 */
+#define MSC01_PCI_HEAD9_OFS		0x2048	/* BAR 5 */
+#define MSC01_PCI_HEAD10_OFS		0x2050	/* CardBus CIS Ptr */
+#define MSC01_PCI_HEAD11_OFS		0x2058	/* SubSystem ID, -VendorID */
+#define MSC01_PCI_HEAD12_OFS		0x2060	/* ROM BAR */
+#define MSC01_PCI_HEAD13_OFS		0x2068	/* Capabilities ptr */
+#define MSC01_PCI_HEAD14_OFS		0x2070	/* reserved */
+#define MSC01_PCI_HEAD15_OFS		0x2078	/* Maxl, ming, intpin, int */
 #define MSC01_PCI_BAR0_OFS		0x2220
 #define MSC01_PCI_CFG_OFS		0x2380
 #define MSC01_PCI_SWAP_OFS		0x2388
@@ -86,73 +87,73 @@
 #define MSC01_PCI_P2SCMAPL_MAP_SHF	24
 #define MSC01_PCI_P2SCMAPL_MAP_MSK	0xff000000
 
-#define MSC01_PCI_INTCFG_RST_SHF        10
-#define MSC01_PCI_INTCFG_RST_MSK        0x00000400
-#define MSC01_PCI_INTCFG_RST_BIT        0x00000400
-#define MSC01_PCI_INTCFG_MWE_SHF        9
-#define MSC01_PCI_INTCFG_MWE_MSK        0x00000200
-#define MSC01_PCI_INTCFG_MWE_BIT        0x00000200
-#define MSC01_PCI_INTCFG_DTO_SHF        8
-#define MSC01_PCI_INTCFG_DTO_MSK        0x00000100
-#define MSC01_PCI_INTCFG_DTO_BIT        0x00000100
-#define MSC01_PCI_INTCFG_MA_SHF         7
-#define MSC01_PCI_INTCFG_MA_MSK         0x00000080
-#define MSC01_PCI_INTCFG_MA_BIT         0x00000080
-#define MSC01_PCI_INTCFG_TA_SHF         6
-#define MSC01_PCI_INTCFG_TA_MSK         0x00000040
-#define MSC01_PCI_INTCFG_TA_BIT         0x00000040
-#define MSC01_PCI_INTCFG_RTY_SHF        5
-#define MSC01_PCI_INTCFG_RTY_MSK        0x00000020
-#define MSC01_PCI_INTCFG_RTY_BIT        0x00000020
-#define MSC01_PCI_INTCFG_MWP_SHF        4
-#define MSC01_PCI_INTCFG_MWP_MSK        0x00000010
-#define MSC01_PCI_INTCFG_MWP_BIT        0x00000010
-#define MSC01_PCI_INTCFG_MRP_SHF        3
-#define MSC01_PCI_INTCFG_MRP_MSK        0x00000008
-#define MSC01_PCI_INTCFG_MRP_BIT        0x00000008
-#define MSC01_PCI_INTCFG_SWP_SHF        2
-#define MSC01_PCI_INTCFG_SWP_MSK        0x00000004
-#define MSC01_PCI_INTCFG_SWP_BIT        0x00000004
-#define MSC01_PCI_INTCFG_SRP_SHF        1
-#define MSC01_PCI_INTCFG_SRP_MSK        0x00000002
-#define MSC01_PCI_INTCFG_SRP_BIT        0x00000002
-#define MSC01_PCI_INTCFG_SE_SHF         0
-#define MSC01_PCI_INTCFG_SE_MSK         0x00000001
-#define MSC01_PCI_INTCFG_SE_BIT         0x00000001
-
-#define MSC01_PCI_INTSTAT_RST_SHF       10
-#define MSC01_PCI_INTSTAT_RST_MSK       0x00000400
-#define MSC01_PCI_INTSTAT_RST_BIT       0x00000400
-#define MSC01_PCI_INTSTAT_MWE_SHF       9
-#define MSC01_PCI_INTSTAT_MWE_MSK       0x00000200
-#define MSC01_PCI_INTSTAT_MWE_BIT       0x00000200
-#define MSC01_PCI_INTSTAT_DTO_SHF       8
-#define MSC01_PCI_INTSTAT_DTO_MSK       0x00000100
-#define MSC01_PCI_INTSTAT_DTO_BIT       0x00000100
-#define MSC01_PCI_INTSTAT_MA_SHF        7
-#define MSC01_PCI_INTSTAT_MA_MSK        0x00000080
-#define MSC01_PCI_INTSTAT_MA_BIT        0x00000080
-#define MSC01_PCI_INTSTAT_TA_SHF        6
-#define MSC01_PCI_INTSTAT_TA_MSK        0x00000040
-#define MSC01_PCI_INTSTAT_TA_BIT        0x00000040
-#define MSC01_PCI_INTSTAT_RTY_SHF       5
-#define MSC01_PCI_INTSTAT_RTY_MSK       0x00000020
-#define MSC01_PCI_INTSTAT_RTY_BIT       0x00000020
-#define MSC01_PCI_INTSTAT_MWP_SHF       4
-#define MSC01_PCI_INTSTAT_MWP_MSK       0x00000010
-#define MSC01_PCI_INTSTAT_MWP_BIT       0x00000010
-#define MSC01_PCI_INTSTAT_MRP_SHF       3
-#define MSC01_PCI_INTSTAT_MRP_MSK       0x00000008
-#define MSC01_PCI_INTSTAT_MRP_BIT       0x00000008
-#define MSC01_PCI_INTSTAT_SWP_SHF       2
-#define MSC01_PCI_INTSTAT_SWP_MSK       0x00000004
-#define MSC01_PCI_INTSTAT_SWP_BIT       0x00000004
-#define MSC01_PCI_INTSTAT_SRP_SHF       1
-#define MSC01_PCI_INTSTAT_SRP_MSK       0x00000002
-#define MSC01_PCI_INTSTAT_SRP_BIT       0x00000002
-#define MSC01_PCI_INTSTAT_SE_SHF        0
-#define MSC01_PCI_INTSTAT_SE_MSK        0x00000001
-#define MSC01_PCI_INTSTAT_SE_BIT        0x00000001
+#define MSC01_PCI_INTCFG_RST_SHF	10
+#define MSC01_PCI_INTCFG_RST_MSK	0x00000400
+#define MSC01_PCI_INTCFG_RST_BIT	0x00000400
+#define MSC01_PCI_INTCFG_MWE_SHF	9
+#define MSC01_PCI_INTCFG_MWE_MSK	0x00000200
+#define MSC01_PCI_INTCFG_MWE_BIT	0x00000200
+#define MSC01_PCI_INTCFG_DTO_SHF	8
+#define MSC01_PCI_INTCFG_DTO_MSK	0x00000100
+#define MSC01_PCI_INTCFG_DTO_BIT	0x00000100
+#define MSC01_PCI_INTCFG_MA_SHF		7
+#define MSC01_PCI_INTCFG_MA_MSK		0x00000080
+#define MSC01_PCI_INTCFG_MA_BIT		0x00000080
+#define MSC01_PCI_INTCFG_TA_SHF		6
+#define MSC01_PCI_INTCFG_TA_MSK		0x00000040
+#define MSC01_PCI_INTCFG_TA_BIT		0x00000040
+#define MSC01_PCI_INTCFG_RTY_SHF	5
+#define MSC01_PCI_INTCFG_RTY_MSK	0x00000020
+#define MSC01_PCI_INTCFG_RTY_BIT	0x00000020
+#define MSC01_PCI_INTCFG_MWP_SHF	4
+#define MSC01_PCI_INTCFG_MWP_MSK	0x00000010
+#define MSC01_PCI_INTCFG_MWP_BIT	0x00000010
+#define MSC01_PCI_INTCFG_MRP_SHF	3
+#define MSC01_PCI_INTCFG_MRP_MSK	0x00000008
+#define MSC01_PCI_INTCFG_MRP_BIT	0x00000008
+#define MSC01_PCI_INTCFG_SWP_SHF	2
+#define MSC01_PCI_INTCFG_SWP_MSK	0x00000004
+#define MSC01_PCI_INTCFG_SWP_BIT	0x00000004
+#define MSC01_PCI_INTCFG_SRP_SHF	1
+#define MSC01_PCI_INTCFG_SRP_MSK	0x00000002
+#define MSC01_PCI_INTCFG_SRP_BIT	0x00000002
+#define MSC01_PCI_INTCFG_SE_SHF		0
+#define MSC01_PCI_INTCFG_SE_MSK		0x00000001
+#define MSC01_PCI_INTCFG_SE_BIT		0x00000001
+
+#define MSC01_PCI_INTSTAT_RST_SHF	10
+#define MSC01_PCI_INTSTAT_RST_MSK	0x00000400
+#define MSC01_PCI_INTSTAT_RST_BIT	0x00000400
+#define MSC01_PCI_INTSTAT_MWE_SHF	9
+#define MSC01_PCI_INTSTAT_MWE_MSK	0x00000200
+#define MSC01_PCI_INTSTAT_MWE_BIT	0x00000200
+#define MSC01_PCI_INTSTAT_DTO_SHF	8
+#define MSC01_PCI_INTSTAT_DTO_MSK	0x00000100
+#define MSC01_PCI_INTSTAT_DTO_BIT	0x00000100
+#define MSC01_PCI_INTSTAT_MA_SHF	7
+#define MSC01_PCI_INTSTAT_MA_MSK	0x00000080
+#define MSC01_PCI_INTSTAT_MA_BIT	0x00000080
+#define MSC01_PCI_INTSTAT_TA_SHF	6
+#define MSC01_PCI_INTSTAT_TA_MSK	0x00000040
+#define MSC01_PCI_INTSTAT_TA_BIT	0x00000040
+#define MSC01_PCI_INTSTAT_RTY_SHF	5
+#define MSC01_PCI_INTSTAT_RTY_MSK	0x00000020
+#define MSC01_PCI_INTSTAT_RTY_BIT	0x00000020
+#define MSC01_PCI_INTSTAT_MWP_SHF	4
+#define MSC01_PCI_INTSTAT_MWP_MSK	0x00000010
+#define MSC01_PCI_INTSTAT_MWP_BIT	0x00000010
+#define MSC01_PCI_INTSTAT_MRP_SHF	3
+#define MSC01_PCI_INTSTAT_MRP_MSK	0x00000008
+#define MSC01_PCI_INTSTAT_MRP_BIT	0x00000008
+#define MSC01_PCI_INTSTAT_SWP_SHF	2
+#define MSC01_PCI_INTSTAT_SWP_MSK	0x00000004
+#define MSC01_PCI_INTSTAT_SWP_BIT	0x00000004
+#define MSC01_PCI_INTSTAT_SRP_SHF	1
+#define MSC01_PCI_INTSTAT_SRP_MSK	0x00000002
+#define MSC01_PCI_INTSTAT_SRP_BIT	0x00000002
+#define MSC01_PCI_INTSTAT_SE_SHF	0
+#define MSC01_PCI_INTSTAT_SE_MSK	0x00000001
+#define MSC01_PCI_INTSTAT_SE_BIT	0x00000001
 
 #define MSC01_PCI_CFGADDR_BNUM_SHF	16
 #define MSC01_PCI_CFGADDR_BNUM_MSK	0x00ff0000
@@ -167,29 +168,29 @@
 #define MSC01_PCI_CFGDATA_DATA_MSK	0xffffffff
 
 /* The defines below are ONLY valid for a MEM bar! */
-#define MSC01_PCI_BAR0_SIZE_SHF	        4
-#define MSC01_PCI_BAR0_SIZE_MSK	        0xfffffff0
-#define MSC01_PCI_BAR0_P_SHF	        3
-#define MSC01_PCI_BAR0_P_MSK	        0x00000008
-#define MSC01_PCI_BAR0_P_BIT	        MSC01_PCI_BAR0_P_MSK
-#define MSC01_PCI_BAR0_D_SHF	        1
-#define MSC01_PCI_BAR0_D_MSK	        0x00000006
-#define MSC01_PCI_BAR0_T_SHF	        0
-#define MSC01_PCI_BAR0_T_MSK	        0x00000001
-#define MSC01_PCI_BAR0_T_BIT	        MSC01_PCI_BAR0_T_MSK
-
-
-#define MSC01_PCI_CFG_RA_SHF	        17
-#define MSC01_PCI_CFG_RA_MSK	        0x00020000
-#define MSC01_PCI_CFG_RA_BIT	        MSC01_PCI_CFG_RA_MSK
-#define MSC01_PCI_CFG_G_SHF	        16
-#define MSC01_PCI_CFG_G_MSK	        0x00010000
-#define MSC01_PCI_CFG_G_BIT	        MSC01_PCI_CFG_G_MSK
-#define MSC01_PCI_CFG_EN_SHF	        15
-#define MSC01_PCI_CFG_EN_MSK	        0x00008000
-#define MSC01_PCI_CFG_EN_BIT	        MSC01_PCI_CFG_EN_MSK
-#define MSC01_PCI_CFG_MAXRTRY_SHF       0
-#define MSC01_PCI_CFG_MAXRTRY_MSK       0x000000ff
+#define MSC01_PCI_BAR0_SIZE_SHF		4
+#define MSC01_PCI_BAR0_SIZE_MSK		0xfffffff0
+#define MSC01_PCI_BAR0_P_SHF		3
+#define MSC01_PCI_BAR0_P_MSK		0x00000008
+#define MSC01_PCI_BAR0_P_BIT		MSC01_PCI_BAR0_P_MSK
+#define MSC01_PCI_BAR0_D_SHF		1
+#define MSC01_PCI_BAR0_D_MSK		0x00000006
+#define MSC01_PCI_BAR0_T_SHF		0
+#define MSC01_PCI_BAR0_T_MSK		0x00000001
+#define MSC01_PCI_BAR0_T_BIT		MSC01_PCI_BAR0_T_MSK
+
+
+#define MSC01_PCI_CFG_RA_SHF		17
+#define MSC01_PCI_CFG_RA_MSK		0x00020000
+#define MSC01_PCI_CFG_RA_BIT		MSC01_PCI_CFG_RA_MSK
+#define MSC01_PCI_CFG_G_SHF		16
+#define MSC01_PCI_CFG_G_MSK		0x00010000
+#define MSC01_PCI_CFG_G_BIT		MSC01_PCI_CFG_G_MSK
+#define MSC01_PCI_CFG_EN_SHF		15
+#define MSC01_PCI_CFG_EN_MSK		0x00008000
+#define MSC01_PCI_CFG_EN_BIT		MSC01_PCI_CFG_EN_MSK
+#define MSC01_PCI_CFG_MAXRTRY_SHF	0
+#define MSC01_PCI_CFG_MAXRTRY_MSK	0x00000fff
 
 #define MSC01_PCI_SWAP_IO_SHF		18
 #define MSC01_PCI_SWAP_IO_MSK		0x000c0000
@@ -206,7 +207,7 @@
  * FIXME - are these macros specific to Malta and co or to the MSC?  If the
  * latter, they should be moved elsewhere.
  */
-#define MIPS_MSC01_PCI_REG_BASE	0x1bd00000
+#define MIPS_MSC01_PCI_REG_BASE		0x1bd00000
 
 extern unsigned long _pcictrl_msc;
 
@@ -219,19 +220,19 @@
  * Registers absolute addresses
  */
 
-#define MSC01_PCI_ID            (MSC01_PCI_REG_BASE + MSC01_PCI_ID_OFS)
-#define MSC01_PCI_SC2PMBASL     (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMBASL_OFS)
-#define MSC01_PCI_SC2PMMSKL     (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMSKL_OFS)
-#define MSC01_PCI_SC2PMMAPL     (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMAPL_OFS)
-#define MSC01_PCI_SC2PIOBASL    (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOBASL_OFS)
-#define MSC01_PCI_SC2PIOMSKL    (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMSKL_OFS)
-#define MSC01_PCI_SC2PIOMAPL    (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMAPL_OFS)
-#define MSC01_PCI_P2SCMSKL      (MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMSKL_OFS)
-#define MSC01_PCI_P2SCMAPL      (MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMAPL_OFS)
-#define MSC01_PCI_INTCFG        (MSC01_PCI_REG_BASE + MSC01_PCI_INTCFG_OFS)
-#define MSC01_PCI_INTSTAT       (MSC01_PCI_REG_BASE + MSC01_PCI_INTSTAT_OFS)
-#define MSC01_PCI_CFGADDR       (MSC01_PCI_REG_BASE + MSC01_PCI_CFGADDR_OFS)
-#define MSC01_PCI_CFGDATA       (MSC01_PCI_REG_BASE + MSC01_PCI_CFGDATA_OFS)
+#define MSC01_PCI_ID		(MSC01_PCI_REG_BASE + MSC01_PCI_ID_OFS)
+#define MSC01_PCI_SC2PMBASL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMBASL_OFS)
+#define MSC01_PCI_SC2PMMSKL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMSKL_OFS)
+#define MSC01_PCI_SC2PMMAPL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMAPL_OFS)
+#define MSC01_PCI_SC2PIOBASL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOBASL_OFS)
+#define MSC01_PCI_SC2PIOMSKL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMSKL_OFS)
+#define MSC01_PCI_SC2PIOMAPL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMAPL_OFS)
+#define MSC01_PCI_P2SCMSKL	(MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMSKL_OFS)
+#define MSC01_PCI_P2SCMAPL	(MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMAPL_OFS)
+#define MSC01_PCI_INTCFG	(MSC01_PCI_REG_BASE + MSC01_PCI_INTCFG_OFS)
+#define MSC01_PCI_INTSTAT	(MSC01_PCI_REG_BASE + MSC01_PCI_INTSTAT_OFS)
+#define MSC01_PCI_CFGADDR	(MSC01_PCI_REG_BASE + MSC01_PCI_CFGADDR_OFS)
+#define MSC01_PCI_CFGDATA	(MSC01_PCI_REG_BASE + MSC01_PCI_CFGDATA_OFS)
 #define MSC01_PCI_IACK		(MSC01_PCI_REG_BASE + MSC01_PCI_IACK_OFS)
 #define MSC01_PCI_HEAD0		(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD0_OFS)
 #define MSC01_PCI_HEAD1		(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD1_OFS)
@@ -248,7 +249,7 @@
 #define MSC01_PCI_HEAD12	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
 #define MSC01_PCI_HEAD13	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
 #define MSC01_PCI_HEAD14	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
-#define MSC01_PCI_HEAD15        (MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
+#define MSC01_PCI_HEAD15	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
 #define MSC01_PCI_BAR0		(MSC01_PCI_REG_BASE + MSC01_PCI_BAR0_OFS)
 #define MSC01_PCI_CFG		(MSC01_PCI_REG_BASE + MSC01_PCI_CFG_OFS)
 #define MSC01_PCI_SWAP		(MSC01_PCI_REG_BASE + MSC01_PCI_SWAP_OFS)
diff -Naur linux-2.6.14/include/asm-mips/mips-boards/sim.h linux-mips-2.6.14.orig/include/asm-mips/mips-boards/sim.h
--- linux-2.6.14/include/asm-mips/mips-boards/sim.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mips-boards/sim.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _ASM_MIPS_BOARDS_SIM_H
+#define _ASM_MIPS_BOARDS_SIM_H
+
+#define STATS_ON        1
+#define STATS_OFF       2
+#define STATS_CLEAR     3
+#define STATS_DUMP      4
+#define TRACE_ON		5
+#define TRACE_OFF       6
+
+
+#define simcfg(code)						\
+({					   \
+	__asm__  __volatile__( \
+        "sltiu $0,$0, %0" \
+		::"i"(code)					\
+		); \
+})
+
+
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mips-boards/simint.h linux-mips-2.6.14.orig/include/asm-mips/mips-boards/simint.h
--- linux-2.6.14/include/asm-mips/mips-boards/simint.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mips-boards/simint.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#ifndef _MIPS_SIMINT_H
+#define _MIPS_SIMINT_H
+
+
+#define SIM_INT_BASE		0
+#define MIPSCPU_INT_MB0		2
+#define MIPSCPU_INT_BASE	16
+#define MIPS_CPU_TIMER_IRQ	7
+
+
+#define MIPSCPU_INT_CPUCTR	7
+
+#define MSC01E_INT_BASE		64
+
+#define MIPSCPU_INT_CPUCTR	7
+#define MSC01E_INT_CPUCTR	11
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mipsmtregs.h linux-mips-2.6.14.orig/include/asm-mips/mipsmtregs.h
--- linux-2.6.14/include/asm-mips/mipsmtregs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/mipsmtregs.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,391 @@
+/*
+ * MT regs definitions, follows on from mipsregs.h
+ * Copyright (C) 2004 - 2005 MIPS Technologies, Inc.  All rights reserved.
+ * Elizabeth Clarke et. al.
+ *
+ */
+#ifndef _ASM_MIPSMTREGS_H
+#define _ASM_MIPSMTREGS_H
+
+#include <asm/mipsregs.h>
+#include <asm/war.h>
+
+#ifndef __ASSEMBLY__
+
+/*
+ * C macros
+ */
+
+#define read_c0_mvpcontrol()		__read_32bit_c0_register($0, 1)
+#define write_c0_mvpcontrol(val)	__write_32bit_c0_register($0, 1, val)
+
+#define read_c0_mvpconf0()		__read_32bit_c0_register($0, 2)
+#define read_c0_mvpconf1()		__read_32bit_c0_register($0, 3)
+
+#define read_c0_vpecontrol()		__read_32bit_c0_register($1, 1)
+#define write_c0_vpecontrol(val)	__write_32bit_c0_register($1, 1, val)
+
+#define read_c0_vpeconf0()		__read_32bit_c0_register($1, 2)
+#define write_c0_vpeconf0(val)		__write_32bit_c0_register($1, 2, val)
+
+#define read_c0_tcstatus()		__read_32bit_c0_register($2, 1)
+#define write_c0_tcstatus(val)		__write_32bit_c0_register($2, 1, val)
+
+#define read_c0_tcbind()		__read_32bit_c0_register($2, 2)
+
+#define read_c0_tccontext()		__read_32bit_c0_register($2, 5)
+#define write_c0_tccontext(val)		__write_32bit_c0_register($2, 5, val)
+
+#else /* Assembly */
+/*
+ * Macros for use in assembly language code
+ */
+
+#define CP0_MVPCONTROL		$0,1
+#define CP0_MVPCONF0		$0,2
+#define CP0_MVPCONF1		$0,3
+#define CP0_VPECONTROL		$1,1
+#define CP0_VPECONF0		$1,2
+#define CP0_VPECONF1		$1,3
+#define CP0_YQMASK		$1,4
+#define CP0_VPESCHEDULE	$1,5
+#define CP0_VPESCHEFBK		$1,6
+#define CP0_TCSTATUS		$2,1
+#define CP0_TCBIND		$2,2
+#define CP0_TCRESTART		$2,3
+#define CP0_TCHALT		$2,4
+#define CP0_TCCONTEXT		$2,5
+#define CP0_TCSCHEDULE		$2,6
+#define CP0_TCSCHEFBK		$2,7
+#define CP0_SRSCONF0		$6,1
+#define CP0_SRSCONF1		$6,2
+#define CP0_SRSCONF2		$6,3
+#define CP0_SRSCONF3		$6,4
+#define CP0_SRSCONF4		$6,5
+
+#endif
+
+/* MVPControl fields */
+#define MVPCONTROL_EVP		(_ULCAST_(1))
+
+#define MVPCONTROL_VPC_SHIFT	1
+#define MVPCONTROL_VPC		(_ULCAST_(1) << MVPCONTROL_VPC_SHIFT)
+
+#define MVPCONTROL_STLB_SHIFT	2
+#define MVPCONTROL_STLB		(_ULCAST_(1) << MVPCONTROL_STLB_SHIFT)
+
+
+/* MVPConf0 fields */
+#define MVPCONF0_PTC_SHIFT	0
+#define MVPCONF0_PTC		( _ULCAST_(0xff))
+#define MVPCONF0_PVPE_SHIFT	10
+#define MVPCONF0_PVPE		( _ULCAST_(0xf) << MVPCONF0_PVPE_SHIFT)
+#define MVPCONF0_TCA_SHIFT	15
+#define MVPCONF0_TCA		( _ULCAST_(1) << MVPCONF0_TCA_SHIFT)
+#define MVPCONF0_PTLBE_SHIFT	16
+#define MVPCONF0_PTLBE		(_ULCAST_(0x3ff) << MVPCONF0_PTLBE_SHIFT)
+#define MVPCONF0_TLBS_SHIFT	29
+#define MVPCONF0_TLBS		(_ULCAST_(1) << MVPCONF0_TLBS_SHIFT)
+#define MVPCONF0_M_SHIFT	31
+#define MVPCONF0_M		(_ULCAST_(0x1) << MVPCONF0_M_SHIFT)
+
+
+/* config3 fields */
+#define CONFIG3_MT_SHIFT	2
+#define CONFIG3_MT		(_ULCAST_(1) << CONFIG3_MT_SHIFT)
+
+
+/* VPEControl fields (per VPE) */
+#define VPECONTROL_TARGTC	(_ULCAST_(0xff))
+
+#define VPECONTROL_TE_SHIFT	15
+#define VPECONTROL_TE		(_ULCAST_(1) << VPECONTROL_TE_SHIFT)
+#define VPECONTROL_EXCPT_SHIFT	16
+#define VPECONTROL_EXCPT	(_ULCAST_(0x7) << VPECONTROL_EXCPT_SHIFT)
+
+/* Thread Exception Codes for EXCPT field */
+#define THREX_TU		0
+#define THREX_TO		1
+#define THREX_IYQ		2
+#define THREX_GSX		3
+#define THREX_YSCH		4
+#define THREX_GSSCH		5
+
+#define VPECONTROL_GSI_SHIFT	20
+#define VPECONTROL_GSI		(_ULCAST_(1) << VPECONTROL_GSI_SHIFT)
+#define VPECONTROL_YSI_SHIFT	21
+#define VPECONTROL_YSI		(_ULCAST_(1) << VPECONTROL_YSI_SHIFT)
+
+/* VPEConf0 fields (per VPE) */
+#define VPECONF0_VPA_SHIFT	0
+#define VPECONF0_VPA		(_ULCAST_(1) << VPECONF0_VPA_SHIFT)
+#define VPECONF0_MVP_SHIFT	1
+#define VPECONF0_MVP		(_ULCAST_(1) << VPECONF0_MVP_SHIFT)
+#define VPECONF0_XTC_SHIFT	21
+#define VPECONF0_XTC		(_ULCAST_(0xff) << VPECONF0_XTC_SHIFT)
+
+/* TCStatus fields (per TC) */
+#define TCSTATUS_TASID		(_ULCAST_(0xff))
+#define TCSTATUS_IXMT_SHIFT	10
+#define TCSTATUS_IXMT		(_ULCAST_(1) << TCSTATUS_IXMT_SHIFT)
+#define TCSTATUS_TKSU_SHIFT	11
+#define TCSTATUS_TKSU		(_ULCAST_(3) << TCSTATUS_TKSU_SHIFT)
+#define TCSTATUS_A_SHIFT	13
+#define TCSTATUS_A		(_ULCAST_(1) << TCSTATUS_A_SHIFT)
+#define TCSTATUS_DA_SHIFT	15
+#define TCSTATUS_DA		(_ULCAST_(1) << TCSTATUS_DA_SHIFT)
+#define TCSTATUS_DT_SHIFT	20
+#define TCSTATUS_DT		(_ULCAST_(1) << TCSTATUS_DT_SHIFT)
+#define TCSTATUS_TDS_SHIFT	21
+#define TCSTATUS_TDS		(_ULCAST_(1) << TCSTATUS_TDS_SHIFT)
+#define TCSTATUS_TSST_SHIFT	22
+#define TCSTATUS_TSST		(_ULCAST_(1) << TCSTATUS_TSST_SHIFT)
+#define TCSTATUS_RNST_SHIFT	23
+#define TCSTATUS_RNST		(_ULCAST_(3) << TCSTATUS_RNST_SHIFT)
+/* Codes for RNST */
+#define TC_RUNNING		0
+#define TC_WAITING		1
+#define TC_YIELDING		2
+#define TC_GATED		3
+
+#define TCSTATUS_TMX_SHIFT	27
+#define TCSTATUS_TMX		(_ULCAST_(1) << TCSTATUS_TMX_SHIFT)
+/* TCStatus TCU bits can use same definitions/offsets as CU bits in Status */
+
+/* TCBind */
+#define TCBIND_CURVPE_SHIFT	0
+#define TCBIND_CURVPE		(_ULCAST_(0xf))
+
+#define TCBIND_CURTC_SHIFT	21
+
+#define TCBIND_CURTC		(_ULCAST_(0xff) << TCBIND_CURTC_SHIFT)
+
+/* TCHalt */
+#define TCHALT_H		(_ULCAST_(1))
+
+#ifndef __ASSEMBLY__
+
+extern void mips_mt_regdump(void);
+
+static inline unsigned int dvpe(void)
+{
+	int res = 0;
+
+	__asm__ __volatile__(
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	.set	noat						\n"
+	"	.set	mips32r2					\n"
+	"	.word	0x41610001		# dvpe $1		\n"
+	"	move	%0, $1						\n"
+	"	ehb							\n"
+	"	.set	pop						\n"
+	: "=r" (res));
+
+	instruction_hazard();
+
+	return res;
+}
+
+static inline void __raw_evpe(void)
+{
+	__asm__ __volatile__(
+	"	.set	push						\n"
+	"	.set	noreorder					\n"
+	"	.set	noat						\n"
+	"	.set	mips32r2					\n"
+	"	.word	0x41600021		# evpe			\n"
+	"	ehb							\n"
+	"	.set	pop						\n");
+}
+
+/* Enable multiMT if previous suggested it should be.
+   EMT_ENABLE to force */
+
+#define EVPE_ENABLE MVPCONTROL_EVP
+
+static inline void evpe(int previous)
+{
+	if ((previous & MVPCONTROL_EVP))
+		__raw_evpe();
+}
+
+static inline unsigned int dmt(void)
+{
+	int res;
+
+	__asm__ __volatile__(
+	"	.set	push						\n"
+	"	.set	mips32r2					\n"
+	"	.set	noat						\n"
+	"	.word	0x41610BC1			# dmt $1	\n"
+	"	ehb							\n"
+	"	move	%0, $1						\n"
+	"	.set	pop						\n"
+	: "=r" (res));
+
+	instruction_hazard();
+
+	return res;
+}
+
+static inline void __raw_emt(void)
+{
+	__asm__ __volatile__(
+	"	.set	noreorder					\n"
+	"	.set	mips32r2					\n"
+	"	emt							\n"
+	"	ehb							\n"
+	"	.set	mips0						\n"
+	"	.set	reorder");
+}
+
+/* enable multiVPE if previous suggested it should be.
+   EVPE_ENABLE to force */
+
+#define EMT_ENABLE VPECONTROL_TE
+
+static inline void emt(int previous)
+{
+	if ((previous & EMT_ENABLE))
+		__raw_emt();
+}
+
+static inline void ehb(void)
+{
+	__asm__ __volatile__(
+	"	.set	mips32r2				\n"
+	"	ehb						\n"
+	"	.set	mips0					\n");
+}
+
+#define mftc0(rt,sel)							\
+({									\
+	 unsigned long  __res;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	.set	noat					\n"	\
+	"	# mftc0	$1, $" #rt ", " #sel "			\n"	\
+	"	.word	0x41000800 | (" #rt " << 16) | " #sel "	\n"	\
+	"	move	%0, $1					\n"	\
+	"	.set	pop					\n"	\
+	: "=r" (__res));						\
+									\
+	__res;								\
+})
+
+#define mftgpr(rt)							\
+({									\
+	unsigned long __res;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	mftgpr	%0," #rt "				\n"	\
+	"	.set	pop					\n"	\
+	: "=r" (__res));						\
+									\
+	__res;								\
+})
+
+#define mftr(rt,u,sel)							\
+({									\
+	unsigned long __res;						\
+									\
+	__asm__ __volatile__(						\
+	".set noat\n\t"							\
+	"mftr\t%0, " #rt ", " #u ", " #sel "\n\t"			\
+	".set at\n\t"							\
+	: "=r" (__res));						\
+									\
+	__res;								\
+})
+
+#define mttgpr(rd,v)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mttgpr $1, " #rd "				\n"	\
+	"	.word	0x41810020 | (" #rd " << 11)		\n"	\
+	"	.set	pop					\n"	\
+	: : "r" (v));							\
+} while (0)
+
+#define mttc0(rd,sel,v)							\
+({									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	mips32r2				\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mttc0 %0," #rd ", " #sel "			\n"	\
+	"	.word	0x41810000 | (" #rd " << 11) | " #sel "	\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (v));							\
+})
+
+
+#define mttr(rd,u,sel,v)						\
+({									\
+	__asm__ __volatile__(						\
+	"mttr	%0," #rd ", " #u ", " #sel				\
+	: : "r" (v));							\
+})
+
+
+#define settc(tc)							\
+do {									\
+	write_c0_vpecontrol((read_c0_vpecontrol()&~VPECONTROL_TARGTC) | (tc)); \
+	ehb();								\
+} while (0)
+
+
+/* you *must* set the target tc (settc) before trying to use these */
+#define read_vpe_c0_vpecontrol()	mftc0(1, 1)
+#define write_vpe_c0_vpecontrol(val)	mttc0(1, 1, val)
+#define read_vpe_c0_vpeconf0()		mftc0(1, 2)
+#define write_vpe_c0_vpeconf0(val)	mttc0(1, 2, val)
+#define read_vpe_c0_status()		mftc0(12, 0)
+#define write_vpe_c0_status(val)	mttc0(12, 0, val)
+#define read_vpe_c0_cause()		mftc0(13, 0)
+#define write_vpe_c0_cause(val)		mttc0(13, 0, val)
+#define read_vpe_c0_config()		mftc0(16, 0)
+#define write_vpe_c0_config(val)	mttc0(16, 0, val)
+#define read_vpe_c0_config1()		mftc0(16, 1)
+#define write_vpe_c0_config1(val)	mttc0(16, 1, val)
+#define read_vpe_c0_config7()		mftc0(16, 7)
+#define write_vpe_c0_config7(val)	mttc0(16, 7, val)
+#define read_vpe_c0_ebase()		mftc0(15,1)
+#define write_vpe_c0_ebase(val)		mttc0(15, 1, val)
+#define write_vpe_c0_compare(val)	mttc0(11, 0, val)
+
+
+/* TC */
+#define read_tc_c0_tcstatus()		mftc0(2, 1)
+#define write_tc_c0_tcstatus(val)	mttc0(2,1,val)
+#define read_tc_c0_tcbind()		mftc0(2, 2)
+#define write_tc_c0_tcbind(val)		mttc0(2,2,val)
+#define read_tc_c0_tcrestart()		mftc0(2, 3)
+#define write_tc_c0_tcrestart(val)	mttc0(2,3,val)
+#define read_tc_c0_tchalt()		mftc0(2, 4)
+#define write_tc_c0_tchalt(val)		mttc0(2,4,val)
+#define read_tc_c0_tccontext()		mftc0(2, 5)
+#define write_tc_c0_tccontext(val)	mttc0(2,5,val)
+
+/* GPR */
+#define read_tc_gpr_sp()		mftgpr(29)
+#define write_tc_gpr_sp(val)		mttgpr(29, val)
+#define read_tc_gpr_gp()		mftgpr(28)
+#define write_tc_gpr_gp(val)		mttgpr(28, val)
+
+__BUILD_SET_C0(mvpcontrol)
+
+#endif /* Not __ASSEMBLY__ */
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/mipsregs.h linux-mips-2.6.14.orig/include/asm-mips/mipsregs.h
--- linux-2.6.14/include/asm-mips/mipsregs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mipsregs.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,7 +8,7 @@
  * Modified for further R[236]000 support by Paul M. Antoine, 1996.
  * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- * Copyright (C) 2003  Maciej W. Rozycki
+ * Copyright (C) 2003, 2004  Maciej W. Rozycki
  */
 #ifndef _ASM_MIPSREGS_H
 #define _ASM_MIPSREGS_H
@@ -96,6 +96,16 @@
 #define CP0_S1_INTCONTROL $20
 
 /*
+ * Coprocessor 0 Set 2 register names
+ */
+#define CP0_S2_SRSCTL	  $12	/* MIPSR2 */
+
+/*
+ * Coprocessor 0 Set 3 register names
+ */
+#define CP0_S3_SRSMAP	  $12	/* MIPSR2 */
+
+/*
  *  TX39 Series
  */
 #define CP0_TX39_CACHE	$7
@@ -281,6 +291,11 @@
 #define ST0_DL			(_ULCAST_(1) << 24)
 
 /*
+ * Enable the MIPS DSP ASE
+ */
+#define ST0_MX			0x01000000
+
+/*
  * Bitfields in the TX39 family CP0 Configuration Register 3
  */
 #define TX39_CONF_ICS_SHIFT	19
@@ -433,6 +448,14 @@
 #define R5K_CONF_SE		(_ULCAST_(1) << 12)
 #define R5K_CONF_SS		(_ULCAST_(3) << 20)
 
+/* Bits specific to the RM7000.  */
+#define RM7K_CONF_SE		(_ULCAST_(1) <<  3)
+#define RM7K_CONF_TE		(_ULCAST_(1) << 12)
+#define RM7K_CONF_CLK		(_ULCAST_(1) << 16)
+#define RM7K_CONF_TC		(_ULCAST_(1) << 17)
+#define RM7K_CONF_SI		(_ULCAST_(3) << 20)
+#define RM7K_CONF_SC		(_ULCAST_(1) << 31)
+
 /* Bits specific to the R10000.  */
 #define R10K_CONF_DN		(_ULCAST_(3) <<  3)
 #define R10K_CONF_CT		(_ULCAST_(1) <<  5)
@@ -475,6 +498,53 @@
 #define MIPS_CONF_M		(_ULCAST_(1) << 31)
 
 /*
+ * Bits in the MIPS32/64 PRA coprocessor 0 config registers 1 and above.
+ */
+#define MIPS_CONF1_FP		(_ULCAST_(1) <<  0)
+#define MIPS_CONF1_EP		(_ULCAST_(1) <<  1)
+#define MIPS_CONF1_CA		(_ULCAST_(1) <<  2)
+#define MIPS_CONF1_WR		(_ULCAST_(1) <<  3)
+#define MIPS_CONF1_PC		(_ULCAST_(1) <<  4)
+#define MIPS_CONF1_MD		(_ULCAST_(1) <<  5)
+#define MIPS_CONF1_C2		(_ULCAST_(1) <<  6)
+#define MIPS_CONF1_DA		(_ULCAST_(7) <<  7)
+#define MIPS_CONF1_DL		(_ULCAST_(7) << 10)
+#define MIPS_CONF1_DS		(_ULCAST_(7) << 13)
+#define MIPS_CONF1_IA		(_ULCAST_(7) << 16)
+#define MIPS_CONF1_IL		(_ULCAST_(7) << 19)
+#define MIPS_CONF1_IS		(_ULCAST_(7) << 22)
+#define MIPS_CONF1_TLBS		(_ULCAST_(63)<< 25)
+
+#define MIPS_CONF2_SA		(_ULCAST_(15)<<  0)
+#define MIPS_CONF2_SL		(_ULCAST_(15)<<  4)
+#define MIPS_CONF2_SS		(_ULCAST_(15)<<  8)
+#define MIPS_CONF2_SU		(_ULCAST_(15)<< 12)
+#define MIPS_CONF2_TA		(_ULCAST_(15)<< 16)
+#define MIPS_CONF2_TL		(_ULCAST_(15)<< 20)
+#define MIPS_CONF2_TS		(_ULCAST_(15)<< 24)
+#define MIPS_CONF2_TU		(_ULCAST_(7) << 28)
+
+#define MIPS_CONF3_TL		(_ULCAST_(1) <<  0)
+#define MIPS_CONF3_SM		(_ULCAST_(1) <<  1)
+#define MIPS_CONF3_MT		(_ULCAST_(1) <<  2)
+#define MIPS_CONF3_SP		(_ULCAST_(1) <<  4)
+#define MIPS_CONF3_VINT		(_ULCAST_(1) <<  5)
+#define MIPS_CONF3_VEIC		(_ULCAST_(1) <<  6)
+#define MIPS_CONF3_LPA		(_ULCAST_(1) <<  7)
+#define MIPS_CONF3_DSP		(_ULCAST_(1) << 10)
+
+/*
+ * Bits in the MIPS32/64 coprocessor 1 (FPU) revision register.
+ */
+#define MIPS_FPIR_S		(_ULCAST_(1) << 16)
+#define MIPS_FPIR_D		(_ULCAST_(1) << 17)
+#define MIPS_FPIR_PS		(_ULCAST_(1) << 18)
+#define MIPS_FPIR_3D		(_ULCAST_(1) << 19)
+#define MIPS_FPIR_W		(_ULCAST_(1) << 20)
+#define MIPS_FPIR_L		(_ULCAST_(1) << 21)
+#define MIPS_FPIR_F64		(_ULCAST_(1) << 22)
+
+/*
  * R10000 performance counter definitions.
  *
  * FIXME: The R10000 performance counter opens a nice way to implement CPU
@@ -621,13 +691,13 @@
 	if (sel == 0)							\
 		__asm__ __volatile__(					\
 			"mtc0\t%z0, " #register "\n\t"			\
-			: : "Jr" ((unsigned int)value));		\
+			: : "Jr" ((unsigned int)(value)));		\
 	else								\
 		__asm__ __volatile__(					\
 			".set\tmips32\n\t"				\
 			"mtc0\t%z0, " #register ", " #sel "\n\t"	\
 			".set\tmips0"					\
-			: : "Jr" ((unsigned int)value));		\
+			: : "Jr" ((unsigned int)(value)));		\
 } while (0)
 
 #define __write_64bit_c0_register(register, sel, value)			\
@@ -676,7 +746,7 @@
 do {									\
 	__asm__ __volatile__(						\
 		"ctc0\t%z0, " #register "\n\t"				\
-		: : "Jr" ((unsigned int)value));			\
+		: : "Jr" ((unsigned int)(value)));			\
 } while (0)
 
 /*
@@ -769,12 +839,24 @@
 #define read_c0_count()		__read_32bit_c0_register($9, 0)
 #define write_c0_count(val)	__write_32bit_c0_register($9, 0, val)
 
+#define read_c0_count2()	__read_32bit_c0_register($9, 6) /* pnx8550 */
+#define write_c0_count2(val)	__write_32bit_c0_register($9, 6, val)
+
+#define read_c0_count3()	__read_32bit_c0_register($9, 7) /* pnx8550 */
+#define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
+
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
 
+#define read_c0_compare2()	__read_32bit_c0_register($11, 6) /* pnx8550 */
+#define write_c0_compare2(val)	__write_32bit_c0_register($11, 6, val)
+
+#define read_c0_compare3()	__read_32bit_c0_register($11, 7) /* pnx8550 */
+#define write_c0_compare3(val)	__write_32bit_c0_register($11, 7, val)
+
 #define read_c0_status()	__read_32bit_c0_register($12, 0)
 #define write_c0_status(val)	__write_32bit_c0_register($12, 0, val)
 
@@ -790,10 +872,18 @@
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config4()	__read_32bit_c0_register($16, 4)
+#define read_c0_config5()	__read_32bit_c0_register($16, 5)
+#define read_c0_config6()	__read_32bit_c0_register($16, 6)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)
+#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)
+#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
@@ -917,6 +1007,22 @@
 #define read_c0_errorepc()	__read_ulong_c0_register($30, 0)
 #define write_c0_errorepc(val)	__write_ulong_c0_register($30, 0, val)
 
+/* MIPSR2 */
+#define read_c0_hwrena()	__read_32bit_c0_register($7,0)
+#define write_c0_hwrena(val)	__write_32bit_c0_register($7, 0, val)
+
+#define read_c0_intctl()	__read_32bit_c0_register($12, 1)
+#define write_c0_intctl(val)	__write_32bit_c0_register($12, 1, val)
+
+#define read_c0_srsctl()	__read_32bit_c0_register($12, 2)
+#define write_c0_srsctl(val)	__write_32bit_c0_register($12, 2, val)
+
+#define read_c0_srsmap()	__read_32bit_c0_register($12, 3)
+#define write_c0_srsmap(val)	__write_32bit_c0_register($12, 3, val)
+
+#define read_c0_ebase()		__read_32bit_c0_register($15,1)
+#define write_c0_ebase(val)	__write_32bit_c0_register($15, 1, val)
+
 /*
  * Macros to access the floating point coprocessor control registers
  */
@@ -930,6 +1036,284 @@
         : "=r" (__res));                                        \
         __res;})
 
+#define rddsp(mask)							\
+({									\
+	unsigned int __res;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push				\n"		\
+	"	.set	noat				\n"		\
+	"	# rddsp $1, %x1				\n"		\
+	"	.word	0x7c000cb8 | (%x1 << 16)	\n"		\
+	"	move	%0, $1				\n"		\
+	"	.set	pop				\n"		\
+	: "=r" (__res)							\
+	: "i" (mask));							\
+	__res;								\
+})
+
+#define wrdsp(val, mask)						\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# wrdsp $1, %x1					\n"	\
+	"	.word	0x7c2004f8 | (%x1 << 15)		\n"	\
+	"	.set	pop					\n"	\
+        :								\
+	: "r" (val), "i" (mask));					\
+} while (0)
+
+#if 0	/* Need DSP ASE capable assembler ... */
+#define mflo0() ({ long mflo0; __asm__("mflo %0, $ac0" : "=r" (mflo0)); mflo0;})
+#define mflo1() ({ long mflo1; __asm__("mflo %0, $ac1" : "=r" (mflo1)); mflo1;})
+#define mflo2() ({ long mflo2; __asm__("mflo %0, $ac2" : "=r" (mflo2)); mflo2;})
+#define mflo3() ({ long mflo3; __asm__("mflo %0, $ac3" : "=r" (mflo3)); mflo3;})
+
+#define mfhi0() ({ long mfhi0; __asm__("mfhi %0, $ac0" : "=r" (mfhi0)); mfhi0;})
+#define mfhi1() ({ long mfhi1; __asm__("mfhi %0, $ac1" : "=r" (mfhi1)); mfhi1;})
+#define mfhi2() ({ long mfhi2; __asm__("mfhi %0, $ac2" : "=r" (mfhi2)); mfhi2;})
+#define mfhi3() ({ long mfhi3; __asm__("mfhi %0, $ac3" : "=r" (mfhi3)); mfhi3;})
+
+#define mtlo0(x) __asm__("mtlo %0, $ac0" ::"r" (x))
+#define mtlo1(x) __asm__("mtlo %0, $ac1" ::"r" (x))
+#define mtlo2(x) __asm__("mtlo %0, $ac2" ::"r" (x))
+#define mtlo3(x) __asm__("mtlo %0, $ac3" ::"r" (x))
+
+#define mthi0(x) __asm__("mthi %0, $ac0" ::"r" (x))
+#define mthi1(x) __asm__("mthi %0, $ac1" ::"r" (x))
+#define mthi2(x) __asm__("mthi %0, $ac2" ::"r" (x))
+#define mthi3(x) __asm__("mthi %0, $ac3" ::"r" (x))
+
+#else
+
+#define mfhi0()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mfhi	%0, $ac0		\n"			\
+	"	.word	0x00000810		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mfhi1()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mfhi	%0, $ac1		\n"			\
+	"	.word	0x00200810		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mfhi2()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mfhi	%0, $ac2		\n"			\
+	"	.word	0x00400810		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mfhi3()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mfhi	%0, $ac3		\n"			\
+	"	.word	0x00600810		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mflo0()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mflo	%0, $ac0		\n"			\
+	"	.word	0x00000812		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mflo1()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mflo	%0, $ac1		\n"			\
+	"	.word	0x00200812		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mflo2()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mflo	%0, $ac2		\n"			\
+	"	.word	0x00400812		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mflo3()								\
+({									\
+	unsigned long __treg;						\
+									\
+	__asm__ __volatile__(						\
+	"	.set	push			\n"			\
+	"	.set	noat			\n"			\
+	"	# mflo	%0, $ac3		\n"			\
+	"	.word	0x00600812		\n"			\
+	"	move	%0, $1			\n"			\
+	"	.set	pop			\n"			\
+	: "=r" (__treg));						\
+	__treg;								\
+})
+
+#define mthi0(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mthi	$1, $ac0				\n"	\
+	"	.word	0x00200011				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mthi1(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mthi	$1, $ac1				\n"	\
+	"	.word	0x00200811				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mthi2(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mthi	$1, $ac2				\n"	\
+	"	.word	0x00201011				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mthi3(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mthi	$1, $ac3				\n"	\
+	"	.word	0x00201811				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mtlo0(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mtlo	$1, $ac0				\n"	\
+	"	.word	0x00200013				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mtlo1(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mtlo	$1, $ac1				\n"	\
+	"	.word	0x00200813				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mtlo2(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mtlo	$1, $ac2				\n"	\
+	"	.word	0x00201013				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#define mtlo3(x)							\
+do {									\
+	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
+	"	.set	noat					\n"	\
+	"	move	$1, %0					\n"	\
+	"	# mtlo	$1, $ac3				\n"	\
+	"	.word	0x00201813				\n"	\
+	"	.set	pop					\n"	\
+	:								\
+	: "r" (x));							\
+} while (0)
+
+#endif
+
 /*
  * TLB operations.
  *
@@ -1012,6 +1396,8 @@
 __BUILD_SET_C0(cause)
 __BUILD_SET_C0(config)
 __BUILD_SET_C0(intcontrol)
+__BUILD_SET_C0(intctl)
+__BUILD_SET_C0(srsmap)
 
 #endif /* !__ASSEMBLY__ */
 
diff -Naur linux-2.6.14/include/asm-mips/mmu_context.h linux-mips-2.6.14.orig/include/asm-mips/mmu_context.h
--- linux-2.6.14/include/asm-mips/mmu_context.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mmu_context.h	2005-11-17 11:44:27.000000000 -0800
@@ -30,7 +30,7 @@
 
 #ifdef CONFIG_32BIT
 #define TLBMISS_HANDLER_SETUP()						\
-	write_c0_context((unsigned long) smp_processor_id() << 23);	\
+	write_c0_context((unsigned long) smp_processor_id() << 25);	\
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
 #if defined(CONFIG_64BIT) && !defined(CONFIG_BUILD_ELF64)
@@ -40,7 +40,7 @@
 #endif
 #if defined(CONFIG_64BIT) && defined(CONFIG_BUILD_ELF64)
 #define TLBMISS_HANDLER_SETUP()						\
-	write_c0_context((unsigned long) smp_processor_id() << 23);	\
+	write_c0_context((unsigned long) smp_processor_id() << 26);	\
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
 
diff -Naur linux-2.6.14/include/asm-mips/mmzone.h linux-mips-2.6.14.orig/include/asm-mips/mmzone.h
--- linux-2.6.14/include/asm-mips/mmzone.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/mmzone.h	2005-11-17 11:44:27.000000000 -0800
@@ -5,6 +5,7 @@
 #ifndef _ASM_MMZONE_H_
 #define _ASM_MMZONE_H_
 
+#include <linux/config.h>
 #include <asm/page.h>
 #include <mmzone.h>
 
diff -Naur linux-2.6.14/include/asm-mips/module.h linux-mips-2.6.14.orig/include/asm-mips/module.h
--- linux-2.6.14/include/asm-mips/module.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/module.h	2005-11-17 11:44:27.000000000 -0800
@@ -14,15 +14,23 @@
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
 
-typedef struct
-{
-  Elf64_Addr r_offset;			/* Address of relocation.  */
-  Elf64_Word r_sym;			/* Symbol index.  */
-  Elf64_Byte r_ssym;			/* Special symbol.  */
-  Elf64_Byte r_type3;			/* Third relocation.  */
-  Elf64_Byte r_type2;			/* Second relocation.  */
-  Elf64_Byte r_type;			/* First relocation.  */
-  Elf64_Sxword r_addend;		/* Addend.  */
+typedef struct {
+	Elf64_Addr r_offset;			/* Address of relocation.  */
+	Elf64_Word r_sym;			/* Symbol index.  */
+	Elf64_Byte r_ssym;			/* Special symbol.  */
+	Elf64_Byte r_type3;			/* Third relocation.  */
+	Elf64_Byte r_type2;			/* Second relocation.  */
+	Elf64_Byte r_type;			/* First relocation.  */
+} Elf64_Mips_Rel;
+
+typedef struct {
+	Elf64_Addr r_offset;			/* Address of relocation.  */
+	Elf64_Word r_sym;			/* Symbol index.  */
+	Elf64_Byte r_ssym;			/* Special symbol.  */
+	Elf64_Byte r_type3;			/* Third relocation.  */
+	Elf64_Byte r_type2;			/* Second relocation.  */
+	Elf64_Byte r_type;			/* First relocation.  */
+	Elf64_Sxword r_addend;			/* Addend.  */
 } Elf64_Mips_Rela;
 
 #ifdef CONFIG_32BIT
@@ -30,6 +38,13 @@
 #define Elf_Shdr	Elf32_Shdr
 #define Elf_Sym		Elf32_Sym
 #define Elf_Ehdr	Elf32_Ehdr
+#define Elf_Addr	Elf32_Addr
+
+#define Elf_Mips_Rel	Elf32_Rel
+#define Elf_Mips_Rela	Elf32_Rela
+
+#define ELF_MIPS_R_SYM(rel) ELF32_R_SYM(rel.r_info)
+#define ELF_MIPS_R_TYPE(rel) ELF32_R_TYPE(rel.r_info)
 
 #endif
 
@@ -38,6 +53,13 @@
 #define Elf_Shdr	Elf64_Shdr
 #define Elf_Sym		Elf64_Sym
 #define Elf_Ehdr	Elf64_Ehdr
+#define Elf_Addr	Elf64_Addr
+
+#define Elf_Mips_Rel	Elf64_Mips_Rel
+#define Elf_Mips_Rela	Elf64_Mips_Rela
+
+#define ELF_MIPS_R_SYM(rel) (rel.r_sym)
+#define ELF_MIPS_R_TYPE(rel) (rel.r_type)
 
 #endif
 
@@ -53,4 +75,54 @@
 }
 #endif
 
+#ifdef CONFIG_CPU_MIPS32_R1
+#define MODULE_PROC_FAMILY "MIPS32_R1"
+#elif defined CONFIG_CPU_MIPS32_R2
+#define MODULE_PROC_FAMILY "MIPS32_R2"
+#elif defined CONFIG_CPU_MIPS64_R1
+#define MODULE_PROC_FAMILY "MIPS64_R1"
+#elif defined CONFIG_CPU_MIPS64_R2
+#define MODULE_PROC_FAMILY "MIPS64_R2"
+#elif defined CONFIG_CPU_R3000
+#define MODULE_PROC_FAMILY "R3000"
+#elif defined CONFIG_CPU_TX39XX
+#define MODULE_PROC_FAMILY "TX39XX"
+#elif defined CONFIG_CPU_VR41XX
+#define MODULE_PROC_FAMILY "VR41XX"
+#elif defined CONFIG_CPU_R4300
+#define MODULE_PROC_FAMILY "R4300"
+#elif defined CONFIG_CPU_R4X00
+#define MODULE_PROC_FAMILY "R4X00"
+#elif defined CONFIG_CPU_TX49XX
+#define MODULE_PROC_FAMILY "TX49XX"
+#elif defined CONFIG_CPU_R5000
+#define MODULE_PROC_FAMILY "R5000"
+#elif defined CONFIG_CPU_R5432
+#define MODULE_PROC_FAMILY "R5432"
+#elif defined CONFIG_CPU_R6000
+#define MODULE_PROC_FAMILY "R6000"
+#elif defined CONFIG_CPU_NEVADA
+#define MODULE_PROC_FAMILY "NEVADA"
+#elif defined CONFIG_CPU_R8000
+#define MODULE_PROC_FAMILY "R8000"
+#elif defined CONFIG_CPU_R10000
+#define MODULE_PROC_FAMILY "R10000"
+#elif defined CONFIG_CPU_RM7000
+#define MODULE_PROC_FAMILY "RM7000"
+#elif defined CONFIG_CPU_RM9000
+#define MODULE_PROC_FAMILY "RM9000"
+#elif defined CONFIG_CPU_SB1
+#define MODULE_PROC_FAMILY "SB1"
+#else
+#error MODULE_PROC_FAMILY undefined for your processor configuration
+#endif
+
+#ifdef CONFIG_32BIT
+#define MODULE_KERNEL_TYPE "32BIT "
+#elif defined CONFIG_64BIT
+#define MODULE_KERNEL_TYPE "64BIT "
+#endif
+
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_KERNEL_TYPE
+
 #endif /* _ASM_MODULE_H */
diff -Naur linux-2.6.14/include/asm-mips/paccess.h linux-mips-2.6.14.orig/include/asm-mips/paccess.h
--- linux-2.6.14/include/asm-mips/paccess.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/paccess.h	2005-11-17 11:44:27.000000000 -0800
@@ -52,7 +52,7 @@
 })
 
 #define __get_dbe_asm(insn)						\
-({									\
+{									\
 	__asm__ __volatile__(						\
 	"1:\t" insn "\t%1,%2\n\t"					\
 	"move\t%0,$0\n"							\
@@ -67,7 +67,7 @@
 	".previous"							\
 	:"=r" (__gu_err), "=r" (__gu_val)				\
 	:"o" (__mp(__gu_addr)), "i" (-EFAULT));				\
-})
+}
 
 extern void __get_dbe_unknown(void);
 
@@ -90,7 +90,7 @@
 })
 
 #define __put_dbe_asm(insn)						\
-({									\
+{									\
 	__asm__ __volatile__(						\
 	"1:\t" insn "\t%1,%2\n\t"					\
 	"move\t%0,$0\n"							\
@@ -104,7 +104,7 @@
 	".previous"							\
 	: "=r" (__pu_err)						\
 	: "r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT));	\
-})
+}
 
 extern void __put_dbe_unknown(void);
 
diff -Naur linux-2.6.14/include/asm-mips/page.h linux-mips-2.6.14.orig/include/asm-mips/page.h
--- linux-2.6.14/include/asm-mips/page.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/page.h	2005-11-17 11:44:27.000000000 -0800
@@ -87,22 +87,48 @@
 typedef struct { unsigned long pte; } pte_t;
 #define pte_val(x)	((x).pte)
 #endif
+#define __pte(x)	((pte_t) { (x) } )
 
-typedef struct { unsigned long pmd; } pmd_t;
-typedef struct { unsigned long pgd; } pgd_t;
-typedef struct { unsigned long pgprot; } pgprot_t;
+/*
+ * For 3-level pagetables we defines these ourselves, for 2-level the
+ * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
+ */
+#ifdef CONFIG_64BIT
 
+typedef struct { unsigned long pmd; } pmd_t;
 #define pmd_val(x)	((x).pmd)
-#define pgd_val(x)	((x).pgd)
-#define pgprot_val(x)	((x).pgprot)
+#define __pmd(x)	((pmd_t) { (x) } )
 
-#define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
+#endif
 
-#define __pte(x)	((pte_t) { (x) } )
-#define __pmd(x)	((pmd_t) { (x) } )
+/*
+ * Right now we don't support 4-level pagetables, so all pud-related
+ * definitions come from <asm-generic/pgtable-nopud.h>.
+ */
+
+/*
+ * Finall the top of the hierarchy, the pgd
+ */
+typedef struct { unsigned long pgd; } pgd_t;
+#define pgd_val(x)	((x).pgd)
 #define __pgd(x)	((pgd_t) { (x) } )
+
+/*
+ * Manipulate page protection bits
+ */
+typedef struct { unsigned long pgprot; } pgprot_t;
+#define pgprot_val(x)	((x).pgprot)
 #define __pgprot(x)	((pgprot_t) { (x) } )
 
+/*
+ * On R4000-style MMUs where a TLB entry is mapping a adjacent even / odd
+ * pair of pages we only have a single global bit per pair of pages.  When
+ * writing to the TLB make sure we always have the bit set for both pages
+ * or none.  This macro is used to access the `buddy' of the pte we're just
+ * working on.
+ */
+#define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
+
 #endif /* !__ASSEMBLY__ */
 
 /* to align the pointer to the (next) page boundary */
diff -Naur linux-2.6.14/include/asm-mips/pci.h linux-mips-2.6.14.orig/include/asm-mips/pci.h
--- linux-2.6.14/include/asm-mips/pci.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/pci.h	2005-11-17 11:44:27.000000000 -0800
@@ -40,6 +40,11 @@
 	unsigned int need_domain_info;
 
 	int iommu;
+
+	/* Optional access methods for reading/writing the bus number
+	   of the PCI controller */
+	int (*get_busno)(void);
+	void (*set_busno)(int busno);
 };
 
 /*
@@ -142,8 +147,22 @@
 
 extern void pcibios_resource_to_bus(struct pci_dev *dev,
 	struct pci_bus_region *region, struct resource *res);
-extern void pcibios_bus_to_resource(struct pci_dev *dev,
-	struct resource *res, struct pci_bus_region *region);
+
+extern void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+				    struct pci_bus_region *region);
+
+static inline struct resource *
+pcibios_select_root(struct pci_dev *pdev, struct resource *res)
+{
+	struct resource *root = NULL;
+
+	if (res->flags & IORESOURCE_IO)
+		root = &ioport_resource;
+	if (res->flags & IORESOURCE_MEM)
+		root = &iomem_resource;
+
+	return root;
+}
 
 #ifdef CONFIG_PCI_DOMAINS
 
@@ -169,17 +188,4 @@
 /* Do platform specific device initialization at pci_enable_device() time */
 extern int pcibios_plat_dev_init(struct pci_dev *dev);
 
-static inline struct resource *
-pcibios_select_root(struct pci_dev *pdev, struct resource *res)
-{
-	struct resource *root = NULL;
-
-	if (res->flags & IORESOURCE_IO)
-		root = &ioport_resource;
-	if (res->flags & IORESOURCE_MEM)
-		root = &iomem_resource;
-
-	return root;
-}
-
 #endif /* _ASM_PCI_H */
diff -Naur linux-2.6.14/include/asm-mips/pgalloc.h linux-mips-2.6.14.orig/include/asm-mips/pgalloc.h
--- linux-2.6.14/include/asm-mips/pgalloc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/pgalloc.h	2005-11-17 11:44:27.000000000 -0800
@@ -26,10 +26,22 @@
 }
 
 /*
+ * Initialize a new pmd table with invalid pointers.
+ */
+extern void pmd_init(unsigned long page, unsigned long pagetable);
+
+#ifdef CONFIG_64BIT
+
+static inline void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
+{
+	set_pud(pud, __pud((unsigned long)pmd));
+}
+#endif
+
+/*
  * Initialize a new pgd / pmd table with invalid pointers.
  */
 extern void pgd_init(unsigned long page);
-extern void pmd_init(unsigned long page, unsigned long pagetable);
 
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
@@ -86,21 +98,18 @@
 #define __pte_free_tlb(tlb,pte)		tlb_remove_page((tlb),(pte))
 
 #ifdef CONFIG_32BIT
-#define pgd_populate(mm, pmd, pte)	BUG()
 
 /*
  * allocating and freeing a pmd is trivial: the 1-entry pmd is
  * inside the pgd, so has no extra memory associated with it.
  */
-#define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
 #define pmd_free(x)			do { } while (0)
 #define __pmd_free_tlb(tlb,x)		do { } while (0)
+
 #endif
 
 #ifdef CONFIG_64BIT
 
-#define pgd_populate(mm, pgd, pmd)	set_pgd(pgd, __pgd(pmd))
-
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
 	pmd_t *pmd;
diff -Naur linux-2.6.14/include/asm-mips/pgtable-32.h linux-mips-2.6.14.orig/include/asm-mips/pgtable-32.h
--- linux-2.6.14/include/asm-mips/pgtable-32.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/pgtable-32.h	2005-11-17 11:44:27.000000000 -0800
@@ -17,6 +17,8 @@
 #include <asm/cachectl.h>
 #include <asm/fixmap.h>
 
+#include <asm-generic/pgtable-nopmd.h>
+
 /*
  * - add_wired_entry() add a fixed TLB entry, and move wired register
  */
@@ -41,42 +43,38 @@
  * works even with the cache aliasing problem the R4k and above have.
  */
 
-/* PMD_SHIFT determines the size of the area a second-level page table can map */
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
 #ifdef CONFIG_64BIT_PHYS_ADDR
-#define PMD_SHIFT	21
+#define PGDIR_SHIFT	21
 #else
-#define PMD_SHIFT	22
+#define PGDIR_SHIFT	22
 #endif
-#define PMD_SIZE	(1UL << PMD_SHIFT)
-#define PMD_MASK	(~(PMD_SIZE-1))
-
-/* PGDIR_SHIFT determines what a third-level page table entry can map */
-#define PGDIR_SHIFT	PMD_SHIFT
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
 /*
  * Entries per page directory level: we use two-level, so
- * we don't really have any PMD directory physically.
+ * we don't really have any PUD/PMD directory physically.
  */
 #ifdef CONFIG_64BIT_PHYS_ADDR
 #define PGD_ORDER	1
-#define PMD_ORDER	0
+#define PUD_ORDER	aieeee_attempt_to_allocate_pud
+#define PMD_ORDER	1
 #define PTE_ORDER	0
 #else
 #define PGD_ORDER	0
-#define PMD_ORDER	0
+#define PUD_ORDER	aieeee_attempt_to_allocate_pud
+#define PMD_ORDER	1
 #define PTE_ORDER	0
 #endif
 
 #define PTRS_PER_PGD	((PAGE_SIZE << PGD_ORDER) / sizeof(pgd_t))
-#define PTRS_PER_PMD	1
 #define PTRS_PER_PTE	((PAGE_SIZE << PTE_ORDER) / sizeof(pte_t))
 
 #define USER_PTRS_PER_PGD	(0x80000000UL/PGDIR_SIZE)
 #define FIRST_USER_ADDRESS	0
 
-#define VMALLOC_START     KSEG2
+#define VMALLOC_START     MAP_BASE
 
 #ifdef CONFIG_HIGHMEM
 # define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
@@ -91,8 +89,6 @@
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
 #endif
-#define pmd_ERROR(e) \
-	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
 
@@ -120,17 +116,7 @@
 	pmd_val(*pmdp) = ((unsigned long) invalid_pte_table);
 }
 
-/*
- * The "pgd_xxx()" functions here are trivial for a folded two-level
- * setup: the pgd is never bad, and a pmd always exists (as it's folded
- * into the pgd entry)
- */
-static inline int pgd_none(pgd_t pgd)		{ return 0; }
-static inline int pgd_bad(pgd_t pgd)		{ return 0; }
-static inline int pgd_present(pgd_t pgd)	{ return 1; }
-static inline void pgd_clear(pgd_t *pgdp)	{ }
-
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
 #define pte_pfn(x)		((unsigned long)((x).pte_high >> 6))
 static inline pte_t
@@ -151,27 +137,22 @@
 #define pfn_pte(pfn, prot)	__pte(((pfn) << (PAGE_SHIFT + 2)) | pgprot_val(prot))
 #else
 #define pte_pfn(x)		((unsigned long)((x).pte >> PAGE_SHIFT))
-#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+#define pfn_pte(pfn, prot)	__pte(((unsigned long long)(pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #endif
-#endif /* defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32) */
+#endif /* defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1) */
 
 #define __pgd_offset(address)	pgd_index(address)
+#define __pud_offset(address)	(((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
 #define __pmd_offset(address)	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
 
 /* to find an entry in a kernel page-table-directory */
 #define pgd_offset_k(address) pgd_offset(&init_mm, address)
 
-#define pgd_index(address)	((address) >> PGDIR_SHIFT)
+#define pgd_index(address)	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
 
 /* to find an entry in a page-table-directory */
 #define pgd_offset(mm,addr)	((mm)->pgd + pgd_index(addr))
 
-/* Find an entry in the second-level page table.. */
-static inline pmd_t *pmd_offset(pgd_t *dir, unsigned long address)
-{
-	return (pmd_t *) dir;
-}
-
 /* Find an entry in the third-level page table.. */
 #define __pte_offset(address)						\
 	(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
@@ -221,7 +202,7 @@
  */
 #define PTE_FILE_MAX_BITS	27
 
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
 	/* fixme */
 #define pte_to_pgoff(_pte) (((_pte).pte_high >> 6) + ((_pte).pte_high & 0x3f))
 #define pgoff_to_pte(off) \
diff -Naur linux-2.6.14/include/asm-mips/pgtable-64.h linux-mips-2.6.14.orig/include/asm-mips/pgtable-64.h
--- linux-2.6.14/include/asm-mips/pgtable-64.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/pgtable-64.h	2005-11-17 11:44:27.000000000 -0800
@@ -16,13 +16,15 @@
 #include <asm/page.h>
 #include <asm/cachectl.h>
 
+#include <asm-generic/pgtable-nopud.h>
+
 /*
  * Each address space has 2 4K pages as its page directory, giving 1024
  * (== PTRS_PER_PGD) 8 byte pointers to pmd tables. Each pmd table is a
- * pair of 4K pages, giving 1024 (== PTRS_PER_PMD) 8 byte pointers to
- * page tables. Each page table is a single 4K page, giving 512 (==
- * PTRS_PER_PTE) 8 byte ptes. Each pgde is initialized to point to
- * invalid_pmd_table, each pmde is initialized to point to
+ * single 4K page, giving 512 (== PTRS_PER_PMD) 8 byte pointers to page
+ * tables. Each page table is also a single 4K page, giving 512 (==
+ * PTRS_PER_PTE) 8 byte ptes. Each pud entry is initialized to point to
+ * invalid_pmd_table, each pmd entry is initialized to point to
  * invalid_pte_table, each pte is initialized to 0. When memory is low,
  * and a pmd table or a page table allocation fails, empty_bad_pmd_table
  * and empty_bad_page_table is returned back to higher layer code, so
@@ -36,17 +38,17 @@
  */
 
 /* PMD_SHIFT determines the size of the area a second-level page table can map */
-#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT - 3))
+#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT + PTE_ORDER - 3))
 #define PMD_SIZE	(1UL << PMD_SHIFT)
 #define PMD_MASK	(~(PMD_SIZE-1))
 
 /* PGDIR_SHIFT determines what a third-level page table entry can map */
-#define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + 1 - 3))
+#define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + PMD_ORDER - 3))
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
 /*
- * For 4kB page size we use a 3 level page tree and a 8kB pmd and pgds which
+ * For 4kB page size we use a 3 level page tree and an 8kB pud, which
  * permits us mapping 40 bits of virtual address space.
  *
  * We used to implement 41 bits by having an order 1 pmd level but that seemed
@@ -57,7 +59,7 @@
  * two levels would be easy to implement.
  *
  * For 16kB page size we use a 2 level page tree which permits a total of
- * 36 bits of virtual address space.  We could add a third leve. but it seems
+ * 36 bits of virtual address space.  We could add a third level but it seems
  * like at the moment there's no need for this.
  *
  * For 64kB page size we use a 2 level page table tree for a total of 42 bits
@@ -65,21 +67,25 @@
  */
 #ifdef CONFIG_PAGE_SIZE_4KB
 #define PGD_ORDER		1
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 #ifdef CONFIG_PAGE_SIZE_8KB
 #define PGD_ORDER		0
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 #ifdef CONFIG_PAGE_SIZE_16KB
 #define PGD_ORDER		0
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 #ifdef CONFIG_PAGE_SIZE_64KB
 #define PGD_ORDER		0
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
@@ -91,7 +97,7 @@
 #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 #define FIRST_USER_ADDRESS	0
 
-#define VMALLOC_START		XKSEG
+#define VMALLOC_START		MAP_BASE
 #define VMALLOC_END	\
 	(VMALLOC_START + PTRS_PER_PGD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE)
 
@@ -102,13 +108,13 @@
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %016lx.\n", __FILE__, __LINE__, pgd_val(e))
 
-extern pte_t invalid_pte_table[PAGE_SIZE/sizeof(pte_t)];
-extern pte_t empty_bad_page_table[PAGE_SIZE/sizeof(pte_t)];
-extern pmd_t invalid_pmd_table[2*PAGE_SIZE/sizeof(pmd_t)];
-extern pmd_t empty_bad_pmd_table[2*PAGE_SIZE/sizeof(pmd_t)];
+extern pte_t invalid_pte_table[PTRS_PER_PTE];
+extern pte_t empty_bad_page_table[PTRS_PER_PTE];
+extern pmd_t invalid_pmd_table[PTRS_PER_PMD];
+extern pmd_t empty_bad_pmd_table[PTRS_PER_PMD];
 
 /*
- * Empty pmd entries point to the invalid_pte_table.
+ * Empty pgd/pmd entries point to the invalid_pte_table.
  */
 static inline int pmd_none(pmd_t pmd)
 {
@@ -128,26 +134,30 @@
 }
 
 /*
- * Empty pgd entries point to the invalid_pmd_table.
+ * Empty pud entries point to the invalid_pmd_table.
  */
-static inline int pgd_none(pgd_t pgd)
+static inline int pud_none(pud_t pud)
 {
-	return pgd_val(pgd) == (unsigned long) invalid_pmd_table;
+	return pud_val(pud) == (unsigned long) invalid_pmd_table;
 }
 
-#define pgd_bad(pgd)		(pgd_val(pgd) &~ PAGE_MASK)
+static inline int pud_bad(pud_t pud)
+{
+	return pud_val(pud) & ~PAGE_MASK;
+}
 
-static inline int pgd_present(pgd_t pgd)
+static inline int pud_present(pud_t pud)
 {
-	return pgd_val(pgd) != (unsigned long) invalid_pmd_table;
+	return pud_val(pud) != (unsigned long) invalid_pmd_table;
 }
 
-static inline void pgd_clear(pgd_t *pgdp)
+static inline void pud_clear(pud_t *pudp)
 {
-	pgd_val(*pgdp) = ((unsigned long) invalid_pmd_table);
+	pud_val(*pudp) = ((unsigned long) invalid_pmd_table);
 }
 
-#define pte_page(x)		pfn_to_page((unsigned long)((pte_val(x) >> PAGE_SHIFT)))
+#define pte_page(x)		pfn_to_page(pte_pfn(x))
+
 #ifdef CONFIG_CPU_VR41XX
 #define pte_pfn(x)		((unsigned long)((x).pte >> (PAGE_SHIFT + 2)))
 #define pfn_pte(pfn, prot)	__pte(((pfn) << (PAGE_SHIFT + 2)) | pgprot_val(prot))
@@ -157,26 +167,28 @@
 #endif
 
 #define __pgd_offset(address)	pgd_index(address)
+#define __pud_offset(address)	(((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
+#define __pmd_offset(address)	pmd_index(address)
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
 /* to find an entry in a kernel page-table-directory */
 #define pgd_offset_k(address) pgd_offset(&init_mm, 0)
 
-#define pgd_index(address)		((address) >> PGDIR_SHIFT)
+#define pgd_index(address)	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pmd_index(address)	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
 
 /* to find an entry in a page-table-directory */
 #define pgd_offset(mm,addr)	((mm)->pgd + pgd_index(addr))
 
-static inline unsigned long pgd_page(pgd_t pgd)
+static inline unsigned long pud_page(pud_t pud)
 {
-	return pgd_val(pgd);
+	return pud_val(pud);
 }
 
 /* Find an entry in the second-level page table.. */
-static inline pmd_t *pmd_offset(pgd_t * dir, unsigned long address)
+static inline pmd_t *pmd_offset(pud_t * pud, unsigned long address)
 {
-	return (pmd_t *) pgd_page(*dir) +
-	       ((address >> PMD_SHIFT) & (PTRS_PER_PMD - 1));
+	return (pmd_t *) pud_page(*pud) + pmd_index(address);
 }
 
 /* Find an entry in the third-level page table.. */
diff -Naur linux-2.6.14/include/asm-mips/pgtable-bits.h linux-mips-2.6.14.orig/include/asm-mips/pgtable-bits.h
--- linux-2.6.14/include/asm-mips/pgtable-bits.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/pgtable-bits.h	2005-11-17 11:44:27.000000000 -0800
@@ -33,7 +33,7 @@
  * unpredictable things.  The code (when it is written) to deal with
  * this problem will be in the update_mmu_cache() code for the r4k.
  */
-#if defined(CONFIG_CPU_MIPS32) && defined(CONFIG_64BIT_PHYS_ADDR)
+#if defined(CONFIG_CPU_MIPS32_R1) && defined(CONFIG_64BIT_PHYS_ADDR)
 
 #define _PAGE_PRESENT               (1<<6)  /* implemented in software */
 #define _PAGE_READ                  (1<<7)  /* implemented in software */
@@ -123,7 +123,7 @@
 
 #endif
 #endif
-#endif /* defined(CONFIG_CPU_MIPS32) && defined(CONFIG_64BIT_PHYS_ADDR) */
+#endif /* defined(CONFIG_CPU_MIPS32_R1) && defined(CONFIG_64BIT_PHYS_ADDR) */
 
 #define __READABLE	(_PAGE_READ | _PAGE_SILENT_READ | _PAGE_ACCESSED)
 #define __WRITEABLE	(_PAGE_WRITE | _PAGE_SILENT_WRITE | _PAGE_MODIFIED)
@@ -140,7 +140,7 @@
 #define PAGE_CACHABLE_DEFAULT	_CACHE_CACHABLE_COW
 #endif
 
-#if defined(CONFIG_CPU_MIPS32) && defined(CONFIG_64BIT_PHYS_ADDR)
+#if defined(CONFIG_CPU_MIPS32_R1) && defined(CONFIG_64BIT_PHYS_ADDR)
 #define CONF_CM_DEFAULT		(PAGE_CACHABLE_DEFAULT >> 3)
 #else
 #define CONF_CM_DEFAULT		(PAGE_CACHABLE_DEFAULT >> 9)
diff -Naur linux-2.6.14/include/asm-mips/pgtable.h linux-mips-2.6.14.orig/include/asm-mips/pgtable.h
--- linux-2.6.14/include/asm-mips/pgtable.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/pgtable.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
 #ifndef _ASM_PGTABLE_H
 #define _ASM_PGTABLE_H
 
-#include <asm-generic/4level-fixup.h>
-
 #include <linux/config.h>
 #ifdef CONFIG_32BIT
 #include <asm/pgtable-32.h>
@@ -18,6 +16,7 @@
 #include <asm/pgtable-64.h>
 #endif
 
+#include <asm/io.h>
 #include <asm/pgtable-bits.h>
 
 #define PAGE_NONE	__pgprot(_PAGE_PRESENT | _CACHE_CACHABLE_NONCOHERENT)
@@ -84,7 +83,7 @@
 #define pte_none(pte)		(!(pte_val(pte) & ~_PAGE_GLOBAL))
 #define pte_present(pte)	(pte_val(pte) & _PAGE_PRESENT)
 
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
 static inline void set_pte(pte_t *ptep, pte_t pte)
 {
 	ptep->pte_high = pte.pte_high;
@@ -148,11 +147,18 @@
 #endif
 
 /*
- * (pmds are folded into pgds so this doesn't get actually called,
+ * (pmds are folded into puds so this doesn't get actually called,
  * but the define is needed for a generic inline function.)
  */
 #define set_pmd(pmdptr, pmdval) do { *(pmdptr) = (pmdval); } while(0)
-#define set_pgd(pgdptr, pgdval) do { *(pgdptr) = (pgdval); } while(0)
+
+#ifdef CONFIG_64BIT
+/*
+ * (puds are folded into pgds so this doesn't get actually called,
+ * but the define is needed for a generic inline function.)
+ */
+#define set_pud(pudptr, pudval) do { *(pudptr) = (pudval); } while(0)
+#endif
 
 #define PGD_T_LOG2	ffz(~sizeof(pgd_t))
 #define PMD_T_LOG2	ffz(~sizeof(pmd_t))
@@ -165,7 +171,7 @@
  * Undefined behaviour if not..
  */
 static inline int pte_user(pte_t pte)	{ BUG(); return 0; }
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
 static inline int pte_read(pte_t pte)	{ return (pte).pte_low & _PAGE_READ; }
 static inline int pte_write(pte_t pte)	{ return (pte).pte_low & _PAGE_WRITE; }
 static inline int pte_dirty(pte_t pte)	{ return (pte).pte_low & _PAGE_MODIFIED; }
@@ -324,7 +330,7 @@
  */
 #define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
 
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32_R1)
 static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
 {
 	pte.pte_low &= _PAGE_CHG_MASK;
@@ -357,7 +363,6 @@
 #endif
 
 #ifdef CONFIG_64BIT_PHYS_ADDR
-extern phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size);
 extern int remap_pfn_range(struct vm_area_struct *vma, unsigned long from, unsigned long pfn, unsigned long size, pgprot_t prot);
 
 static inline int io_remap_pfn_range(struct vm_area_struct *vma,
@@ -367,7 +372,7 @@
 		pgprot_t prot)
 {
 	phys_t phys_addr_high = fixup_bigphys_addr(pfn << PAGE_SHIFT, size);
-	return remap_pfn_range(vma, vaddr, pfn, size, prot);
+	return remap_pfn_range(vma, vaddr, phys_addr_high >> PAGE_SHIFT, size, prot);
 }
 #else
 #define io_remap_pfn_range(vma, vaddr, pfn, size, prot)		\
diff -Naur linux-2.6.14/include/asm-mips/processor.h linux-mips-2.6.14.orig/include/asm-mips/processor.h
--- linux-2.6.14/include/asm-mips/processor.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/processor.h	2005-11-17 11:44:27.000000000 -0800
@@ -96,12 +96,26 @@
 	{{0,},} \
 }
 
+#define NUM_DSP_REGS   6
+
+typedef __u32 dspreg_t;
+
+struct mips_dsp_state {
+	dspreg_t        dspr[NUM_DSP_REGS];
+	unsigned int    dspcontrol;
+	unsigned short	used_dsp;
+};
+
+#define INIT_DSP {{0,},}
+
 typedef struct {
 	unsigned long seg;
 } mm_segment_t;
 
 #define ARCH_MIN_TASKALIGN	8
 
+struct mips_abi;
+
 /*
  * If you change thread_struct remember to change the #defines below too!
  */
@@ -117,6 +131,9 @@
 	/* Saved fpu/fpu emulator stuff. */
 	union mips_fpu_union fpu;
 
+	/* Saved state of the DSP ASE, if available. */
+	struct mips_dsp_state dsp;
+
 	/* Other stuff associated with the thread. */
 	unsigned long cp0_badvaddr;	/* Last user fault */
 	unsigned long cp0_baduaddr;	/* Last kernel fault accessing USEG */
@@ -129,6 +146,7 @@
 	unsigned long mflags;
 	unsigned long irix_trampoline;  /* Wheee... */
 	unsigned long irix_oldctx;
+	struct mips_abi *abi;
 };
 
 #define MF_ABI_MASK	(MF_32BIT_REGS | MF_32BIT_ADDR)
@@ -151,6 +169,10 @@
 	 */ \
 	INIT_FPU, \
 	/* \
+	 * saved dsp/dsp emulator stuff \
+	 */ \
+	INIT_DSP, \
+	/* \
 	 * Other stuff associated with the process \
 	 */ \
 	0, 0, 0, 0, \
diff -Naur linux-2.6.14/include/asm-mips/ptrace.h linux-mips-2.6.14.orig/include/asm-mips/ptrace.h
--- linux-2.6.14/include/asm-mips/ptrace.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/ptrace.h	2005-11-17 11:44:27.000000000 -0800
@@ -22,6 +22,8 @@
 #define MMLO		68
 #define FPC_CSR		69
 #define FPC_EIR		70
+#define DSP_BASE	71		/* 3 more hi / lo register pairs */
+#define DSP_CONTROL	77
 
 /*
  * This struct defines the way the registers are stored on the stack during a
@@ -38,18 +40,18 @@
 
 	/* Saved special registers. */
 	unsigned long cp0_status;
-	unsigned long lo;
 	unsigned long hi;
+	unsigned long lo;
 	unsigned long cp0_badvaddr;
 	unsigned long cp0_cause;
 	unsigned long cp0_epc;
 };
 
 /* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
-/* #define PTRACE_GETREGS		12 */
-/* #define PTRACE_SETREGS		13 */
-/* #define PTRACE_GETFPREGS		14 */
-/* #define PTRACE_SETFPREGS		15 */
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+#define PTRACE_GETFPREGS		14
+#define PTRACE_SETFPREGS		15
 /* #define PTRACE_GETFPXREGS		18 */
 /* #define PTRACE_SETFPXREGS		19 */
 
@@ -58,6 +60,13 @@
 #define PTRACE_GET_THREAD_AREA	25
 #define PTRACE_SET_THREAD_AREA	26
 
+/* Calls to trace a 64bit program from a 32bit program.  */
+#define PTRACE_PEEKTEXT_3264	0xc0
+#define PTRACE_PEEKDATA_3264	0xc1
+#define PTRACE_POKETEXT_3264	0xc2
+#define PTRACE_POKEDATA_3264	0xc3
+#define PTRACE_GET_THREAD_AREA_3264	0xc4
+
 #ifdef __KERNEL__
 
 #include <linux/linkage.h>
diff -Naur linux-2.6.14/include/asm-mips/r4kcache.h linux-mips-2.6.14.orig/include/asm-mips/r4kcache.h
--- linux-2.6.14/include/asm-mips/r4kcache.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/r4kcache.h	2005-11-17 11:44:27.000000000 -0800
@@ -21,7 +21,7 @@
  *
  *  - The MIPS32 and MIPS64 specs permit an implementation to directly derive
  *    the index bits from the virtual address.  This breaks with tradition
- *    set by the R4000.  To keep unpleassant surprises from happening we pick
+ *    set by the R4000.  To keep unpleasant surprises from happening we pick
  *    an address in KSEG0 / CKSEG0.
  *  - We need a properly sign extended address for 64-bit code.  To get away
  *    without ifdefs we let the compiler do it by a type cast.
@@ -30,11 +30,11 @@
 
 #define cache_op(op,addr)						\
 	__asm__ __volatile__(						\
+	"	.set	push					\n"	\
 	"	.set	noreorder				\n"	\
 	"	.set	mips3\n\t				\n"	\
 	"	cache	%0, %1					\n"	\
-	"	.set	mips0					\n"	\
-	"	.set	reorder"					\
+	"	.set	pop					\n"	\
 	:								\
 	: "i" (op), "m" (*(unsigned char *)(addr)))
 
@@ -84,14 +84,14 @@
 static inline void protected_flush_icache_line(unsigned long addr)
 {
 	__asm__ __volatile__(
-		".set noreorder\n\t"
-		".set mips3\n"
-		"1:\tcache %0,(%1)\n"
-		"2:\t.set mips0\n\t"
-		".set reorder\n\t"
-		".section\t__ex_table,\"a\"\n\t"
-		STR(PTR)"\t1b,2b\n\t"
-		".previous"
+		"	.set	push			\n"
+		"	.set	noreorder		\n"
+		"	.set	mips3			\n"
+		"1:	cache	%0, (%1)		\n"
+		"2:	.set	pop			\n"
+		"	.section __ex_table,\"a\"	\n"
+		"	"STR(PTR)" 1b, 2b		\n"
+		"	.previous"
 		:
 		: "i" (Hit_Invalidate_I), "r" (addr));
 }
@@ -100,19 +100,19 @@
  * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
  * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
  * caches.  We're talking about one cacheline unnecessarily getting invalidated
- * here so the penaltiy isn't overly hard.
+ * here so the penalty isn't overly hard.
  */
 static inline void protected_writeback_dcache_line(unsigned long addr)
 {
 	__asm__ __volatile__(
-		".set noreorder\n\t"
-		".set mips3\n"
-		"1:\tcache %0,(%1)\n"
-		"2:\t.set mips0\n\t"
-		".set reorder\n\t"
-		".section\t__ex_table,\"a\"\n\t"
-		STR(PTR)"\t1b,2b\n\t"
-		".previous"
+		"	.set	push			\n"
+		"	.set	noreorder		\n"
+		"	.set	mips3			\n"
+		"1:	cache	%0, (%1)		\n"
+		"2:	.set	pop			\n"
+		"	.section __ex_table,\"a\"	\n"
+		"	"STR(PTR)" 1b, 2b		\n"
+		"	.previous"
 		:
 		: "i" (Hit_Writeback_Inv_D), "r" (addr));
 }
@@ -120,14 +120,14 @@
 static inline void protected_writeback_scache_line(unsigned long addr)
 {
 	__asm__ __volatile__(
-		".set noreorder\n\t"
-		".set mips3\n"
-		"1:\tcache %0,(%1)\n"
-		"2:\t.set mips0\n\t"
-		".set reorder\n\t"
-		".section\t__ex_table,\"a\"\n\t"
-		STR(PTR)"\t1b,2b\n\t"
-		".previous"
+		"	.set	push			\n"
+		"	.set	noreorder		\n"
+		"	.set	mips3			\n"
+		"1:	cache	%0, (%1)		\n"
+		"2:	.set	pop			\n"
+		"	.section __ex_table,\"a\"	\n"
+		"	"STR(PTR)" 1b, 2b		\n"
+		"	.previous"
 		:
 		: "i" (Hit_Writeback_Inv_SD), "r" (addr));
 }
@@ -142,6 +142,7 @@
 
 #define cache16_unroll32(base,op)					\
 	__asm__ __volatile__(						\
+	"	.set push					\n"	\
 	"	.set noreorder					\n"	\
 	"	.set mips3					\n"	\
 	"	cache %1, 0x000(%0); cache %1, 0x010(%0)	\n"	\
@@ -160,8 +161,7 @@
 	"	cache %1, 0x1a0(%0); cache %1, 0x1b0(%0)	\n"	\
 	"	cache %1, 0x1c0(%0); cache %1, 0x1d0(%0)	\n"	\
 	"	cache %1, 0x1e0(%0); cache %1, 0x1f0(%0)	\n"	\
-	"	.set mips0					\n"	\
-	"	.set reorder					\n"	\
+	"	.set pop					\n"	\
 		:							\
 		: "r" (base),						\
 		  "i" (op));
@@ -285,6 +285,7 @@
 
 #define cache32_unroll32(base,op)					\
 	__asm__ __volatile__(						\
+	"	.set push					\n"	\
 	"	.set noreorder					\n"	\
 	"	.set mips3					\n"	\
 	"	cache %1, 0x000(%0); cache %1, 0x020(%0)	\n"	\
@@ -303,8 +304,7 @@
 	"	cache %1, 0x340(%0); cache %1, 0x360(%0)	\n"	\
 	"	cache %1, 0x380(%0); cache %1, 0x3a0(%0)	\n"	\
 	"	cache %1, 0x3c0(%0); cache %1, 0x3e0(%0)	\n"	\
-	"	.set mips0					\n"	\
-	"	.set reorder					\n"	\
+	"	.set pop					\n"	\
 		:							\
 		: "r" (base),						\
 		  "i" (op));
@@ -428,6 +428,7 @@
 
 #define cache64_unroll32(base,op)					\
 	__asm__ __volatile__(						\
+	"	.set push					\n"	\
 	"	.set noreorder					\n"	\
 	"	.set mips3					\n"	\
 	"	cache %1, 0x000(%0); cache %1, 0x040(%0)	\n"	\
@@ -446,8 +447,7 @@
 	"	cache %1, 0x680(%0); cache %1, 0x6c0(%0)	\n"	\
 	"	cache %1, 0x700(%0); cache %1, 0x740(%0)	\n"	\
 	"	cache %1, 0x780(%0); cache %1, 0x7c0(%0)	\n"	\
-	"	.set mips0					\n"	\
-	"	.set reorder					\n"	\
+	"	.set pop					\n"	\
 		:							\
 		: "r" (base),						\
 		  "i" (op));
@@ -532,6 +532,7 @@
 
 #define cache128_unroll32(base,op)					\
 	__asm__ __volatile__(						\
+	"	.set push					\n"	\
 	"	.set noreorder					\n"	\
 	"	.set mips3					\n"	\
 	"	cache %1, 0x000(%0); cache %1, 0x080(%0)	\n"	\
@@ -550,8 +551,7 @@
 	"	cache %1, 0xd00(%0); cache %1, 0xd80(%0)	\n"	\
 	"	cache %1, 0xe00(%0); cache %1, 0xe80(%0)	\n"	\
 	"	cache %1, 0xf00(%0); cache %1, 0xf80(%0)	\n"	\
-	"	.set mips0					\n"	\
-	"	.set reorder					\n"	\
+	"	.set pop					\n"	\
 		:							\
 		: "r" (base),						\
 		  "i" (op));
diff -Naur linux-2.6.14/include/asm-mips/rtc.h linux-mips-2.6.14.orig/include/asm-mips/rtc.h
--- linux-2.6.14/include/asm-mips/rtc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/rtc.h	2005-11-17 11:44:27.000000000 -0800
@@ -14,7 +14,9 @@
 
 #ifdef __KERNEL__
 
+#include <linux/spinlock.h>
 #include <linux/rtc.h>
+#include <asm/time.h>
 
 #define RTC_PIE 0x40            /* periodic interrupt enable */
 #define RTC_AIE 0x20            /* alarm interrupt enable */
@@ -27,11 +29,52 @@
 #define RTC_24H 0x02            /* 24 hour mode - else hours bit 7 means pm */
 #define RTC_DST_EN 0x01         /* auto switch DST - works f. USA only */
 
-unsigned int get_rtc_time(struct rtc_time *time);
-int set_rtc_time(struct rtc_time *time);
-unsigned int get_rtc_ss(void);
-int get_rtc_pll(struct rtc_pll_info *pll);
-int set_rtc_pll(struct rtc_pll_info *pll);
+static DEFINE_SPINLOCK(mips_rtc_lock);
 
+static inline unsigned int get_rtc_time(struct rtc_time *time)
+{
+	unsigned long nowtime;
+
+	spin_lock(&mips_rtc_lock);
+	nowtime = rtc_get_time();
+	to_tm(nowtime, time);
+	time->tm_year -= 1900;
+	spin_unlock(&mips_rtc_lock);
+
+	return RTC_24H;
+}
+
+static inline int set_rtc_time(struct rtc_time *time)
+{
+	unsigned long nowtime;
+	int ret;
+
+	spin_lock(&mips_rtc_lock);
+	nowtime = mktime(time->tm_year+1900, time->tm_mon+1,
+			time->tm_mday, time->tm_hour, time->tm_min,
+			time->tm_sec);
+	ret = rtc_set_time(nowtime);
+	spin_unlock(&mips_rtc_lock);
+
+	return ret;
+}
+
+static inline unsigned int get_rtc_ss(void)
+{
+	struct rtc_time h;
+
+	get_rtc_time(&h);
+	return h.tm_sec;
+}
+
+static inline int get_rtc_pll(struct rtc_pll_info *pll)
+{
+	return -EINVAL;
+}
+
+static inline int set_rtc_pll(struct rtc_pll_info *pll)
+{
+	return -EINVAL;
+}
 #endif
 #endif
diff -Naur linux-2.6.14/include/asm-mips/rtlx.h linux-mips-2.6.14.orig/include/asm-mips/rtlx.h
--- linux-2.6.14/include/asm-mips/rtlx.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/rtlx.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2004, 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ */
+
+#ifndef _RTLX_H
+#define _RTLX_H_
+
+#define LX_NODE_BASE 10
+
+#define MIPSCPU_INT_BASE       16
+#define MIPS_CPU_RTLX_IRQ 0
+
+#define RTLX_VERSION 1
+#define RTLX_xID 0x12345600
+#define RTLX_ID (RTLX_xID | RTLX_VERSION)
+#define RTLX_CHANNELS 8
+
+enum rtlx_state {
+	RTLX_STATE_UNUSED = 0,
+	RTLX_STATE_INITIALISED,
+	RTLX_STATE_REMOTE_READY,
+	RTLX_STATE_OPENED
+};
+
+#define RTLX_BUFFER_SIZE 1024
+/* each channel supports read and write.
+   linux (vpe0) reads lx_buffer  and writes rt_buffer
+   SP (vpe1) reads rt_buffer and writes lx_buffer
+*/
+typedef struct rtlx_channel {
+	enum rtlx_state rt_state;
+	enum rtlx_state lx_state;
+
+	int buffer_size;
+
+	/* read and write indexes per buffer */
+	int rt_write, rt_read;
+	char *rt_buffer;
+
+	int lx_write, lx_read;
+	char *lx_buffer;
+
+	void *queues;
+
+} rtlx_channel_t;
+
+typedef struct rtlx_info {
+	unsigned long id;
+	enum rtlx_state state;
+
+	struct rtlx_channel channel[RTLX_CHANNELS];
+
+} rtlx_info_t;
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/serial.h linux-mips-2.6.14.orig/include/asm-mips/serial.h
--- linux-2.6.14/include/asm-mips/serial.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/serial.h	2005-11-17 11:44:27.000000000 -0800
@@ -52,16 +52,6 @@
 #define JAZZ_SERIAL_PORT_DEFNS
 #endif
 
-#ifdef CONFIG_MIPS_COBALT
-#include <asm/cobalt/cobalt.h>
-#define COBALT_BASE_BAUD  (18432000 / 16)
-#define COBALT_SERIAL_PORT_DEFNS		\
-	/* UART CLK   PORT  IRQ  FLAGS    */ 		\
-	{ 0, COBALT_BASE_BAUD, 0xc800000, COBALT_SERIAL_IRQ, STD_COM_FLAGS },   /* ttyS0 */
-#else
-#define COBALT_SERIAL_PORT_DEFNS
-#endif
-
 /*
  * Both Galileo boards have the same UART mappings.
  */
@@ -113,17 +103,6 @@
 #define IVR_SERIAL_PORT_DEFNS
 #endif
 
-#ifdef CONFIG_TOSHIBA_JMR3927
-#include <asm/jmr3927/jmr3927.h>
-#define TXX927_SERIAL_PORT_DEFNS                              \
-    { .baud_base = JMR3927_BASE_BAUD, .port = UART0_ADDR, .irq = UART0_INT,  \
-      .flags = UART0_FLAGS, .type = 1 },                        \
-    { .baud_base = JMR3927_BASE_BAUD, .port = UART1_ADDR, .irq = UART1_INT,  \
-      .flags = UART1_FLAGS, .type = 1 },
-#else
-#define TXX927_SERIAL_PORT_DEFNS
-#endif
-
 #ifdef CONFIG_SERIAL_AU1X00
 #include <asm/mach-au1x00/au1000.h>
 #ifdef CONFIG_SOC_AU1000
@@ -227,9 +206,9 @@
 #define JAGUAR_ATX_SERIAL1_BASE	0xfd000023L
 
 #define _JAGUAR_ATX_SERIAL_INIT(int, base)				\
-	{ baud_base: JAGUAR_ATX_BASE_BAUD, irq: int,			\
-	  flags: (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),		\
-	  iomem_base: (u8 *) base, iomem_reg_shift: 2,			\
+	{ .baud_base = JAGUAR_ATX_BASE_BAUD, irq: int,			\
+	  .flags = (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),		\
+	  .iomem_base = (u8 *) base, iomem_reg_shift: 2,			\
 	  io_type: SERIAL_IO_MEM }
 #define MOMENCO_JAGUAR_ATX_SERIAL_PORT_DEFNS				\
 	_JAGUAR_ATX_SERIAL_INIT(JAGUAR_ATX_SERIAL1_IRQ, JAGUAR_ATX_SERIAL1_BASE)
@@ -243,9 +222,9 @@
 #define OCELOT_3_SERIAL_BASE	(signed)0xfd000020
 
 #define _OCELOT_3_SERIAL_INIT(int, base)				\
-	{ baud_base: OCELOT_3_BASE_BAUD, irq: int, 			\
-	  flags: STD_COM_FLAGS,						\
-	  iomem_base: (u8 *) base, iomem_reg_shift: 2,			\
+	{ .baud_base = OCELOT_3_BASE_BAUD, irq: int, 			\
+	  .flags = STD_COM_FLAGS,						\
+	  .iomem_base = (u8 *) base, iomem_reg_shift: 2,			\
 	  io_type: SERIAL_IO_MEM }
 
 #define MOMENCO_OCELOT_3_SERIAL_PORT_DEFNS				\
@@ -342,7 +321,6 @@
 #endif /* CONFIG_SGI_IP32 */
 
 #define SERIAL_PORT_DFNS				\
-	COBALT_SERIAL_PORT_DEFNS			\
 	DDB5477_SERIAL_PORT_DEFNS			\
 	EV96100_SERIAL_PORT_DEFNS			\
 	IP32_SERIAL_PORT_DEFNS                          \
@@ -354,7 +332,6 @@
 	MOMENCO_OCELOT_C_SERIAL_PORT_DEFNS		\
 	MOMENCO_OCELOT_SERIAL_PORT_DEFNS		\
 	MOMENCO_OCELOT_3_SERIAL_PORT_DEFNS		\
-	TXX927_SERIAL_PORT_DEFNS                        \
 	AU1000_SERIAL_PORT_DEFNS
 
 #endif /* _ASM_SERIAL_H */
diff -Naur linux-2.6.14/include/asm-mips/sgi/hpc3.h linux-mips-2.6.14.orig/include/asm-mips/sgi/hpc3.h
--- linux-2.6.14/include/asm-mips/sgi/hpc3.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sgi/hpc3.h	2005-11-17 11:44:27.000000000 -0800
@@ -128,26 +128,26 @@
 	volatile u32 rx_gfptr;	/* current GIO fifo ptr */
 	volatile u32 rx_dfptr;	/* current device fifo ptr */
 	u32 _unused1;		/* padding */
-	volatile u32 rx_reset;	/* reset register */
-#define HPC3_ERXRST_CRESET 0x1	/* Reset dma channel and external controller */
-#define HPC3_ERXRST_CLRIRQ 0x2	/* Clear channel interrupt */
-#define HPC3_ERXRST_LBACK  0x4	/* Enable diagnostic loopback mode of Seeq8003 */
-
-	volatile u32 rx_dconfig;	/* DMA configuration register */
-#define HPC3_ERXDCFG_D1    0x0000f /* Cycles to spend in D1 state for PIO */
-#define HPC3_ERXDCFG_D2    0x000f0 /* Cycles to spend in D2 state for PIO */
-#define HPC3_ERXDCFG_D3    0x00f00 /* Cycles to spend in D3 state for PIO */
-#define HPC3_ERXDCFG_WCTRL 0x01000 /* Enable writes of desc into ex ctrl port */
-#define HPC3_ERXDCFG_FRXDC 0x02000 /* Clear eop stat bits upon rxdc, hw seeq fix */
-#define HPC3_ERXDCFG_FEOP  0x04000 /* Bad packet marker timeout enable */
-#define HPC3_ERXDCFG_FIRQ  0x08000 /* Another bad packet timeout enable */
-#define HPC3_ERXDCFG_PTO   0x30000 /* Programmed timeout value for above two */
-
-	volatile u32 rx_pconfig;	/* PIO configuration register */
-#define HPC3_ERXPCFG_P1    0x000f /* Cycles to spend in P1 state for PIO */
-#define HPC3_ERXPCFG_P2    0x00f0 /* Cycles to spend in P2 state for PIO */
-#define HPC3_ERXPCFG_P3    0x0f00 /* Cycles to spend in P3 state for PIO */
-#define HPC3_ERXPCFG_TST   0x1000 /* Diagnistic ram test feature bit */
+	volatile u32 reset;	/* reset register */
+#define HPC3_ERST_CRESET 0x1	/* Reset dma channel and external controller */
+#define HPC3_ERST_CLRIRQ 0x2	/* Clear channel interrupt */
+#define HPC3_ERST_LBACK  0x4	/* Enable diagnostic loopback mode of Seeq8003 */
+
+	volatile u32 dconfig;    /* DMA configuration register */
+#define HPC3_EDCFG_D1    0x0000f /* Cycles to spend in D1 state for PIO */
+#define HPC3_EDCFG_D2    0x000f0 /* Cycles to spend in D2 state for PIO */
+#define HPC3_EDCFG_D3    0x00f00 /* Cycles to spend in D3 state for PIO */
+#define HPC3_EDCFG_WCTRL 0x01000 /* Enable writes of desc into ex ctrl port */
+#define HPC3_EDCFG_FRXDC 0x02000 /* Clear eop stat bits upon rxdc, hw seeq fix */
+#define HPC3_EDCFG_FEOP  0x04000 /* Bad packet marker timeout enable */
+#define HPC3_EDCFG_FIRQ  0x08000 /* Another bad packet timeout enable */
+#define HPC3_EDCFG_PTO   0x30000 /* Programmed timeout value for above two */
+
+	volatile u32 pconfig;   /* PIO configuration register */
+#define HPC3_EPCFG_P1    0x000f /* Cycles to spend in P1 state for PIO */
+#define HPC3_EPCFG_P2    0x00f0 /* Cycles to spend in P2 state for PIO */
+#define HPC3_EPCFG_P3    0x0f00 /* Cycles to spend in P3 state for PIO */
+#define HPC3_EPCFG_TST   0x1000 /* Diagnistic ram test feature bit */
 
 	u32 _unused2[0x1000/4 - 8];	/* padding */
 
diff -Naur linux-2.6.14/include/asm-mips/sibyte/bcm1480_int.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_int.h
--- linux-2.6.14/include/asm-mips/sibyte/bcm1480_int.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_int.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,310 @@
+/*  *********************************************************************
+    *  BCM1280/BCM1480 Board Support Package
+    *
+    *  Interrupt Mapper definitions		File: bcm1480_int.h
+    *
+    *  This module contains constants for manipulating the
+    *  BCM1255/BCM1280/BCM1455/BCM1480's interrupt mapper and
+    *  definitions for the interrupt sources.
+    *
+    *  BCM1480 specification level: 1X55_1X80-UM100-D4 (11/24/03)
+    *
+    *********************************************************************
+    *
+    *  Copyright 2000,2001,2002,2003
+    *  Broadcom Corporation. All rights reserved.
+    *
+    *  This program is free software; you can redistribute it and/or
+    *  modify it under the terms of the GNU General Public License as
+    *  published by the Free Software Foundation; either version 2 of
+    *  the License, or (at your option) any later version.
+    *
+    *  This program is distributed in the hope that it will be useful,
+    *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+    *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    *  GNU General Public License for more details.
+    *
+    *  You should have received a copy of the GNU General Public License
+    *  along with this program; if not, write to the Free Software
+    *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+    *  MA 02111-1307 USA
+    ********************************************************************* */
+
+
+#ifndef _BCM1480_INT_H
+#define _BCM1480_INT_H
+
+#include "sb1250_defs.h"
+
+/*  *********************************************************************
+    *  Interrupt Mapper Constants
+    ********************************************************************* */
+
+/*
+ * The interrupt mapper deals with 128-bit logical registers that are
+ * implemented as pairs of 64-bit registers, with the "low" 64 bits in
+ * a register that has an address 0x1000 higher(!) than the
+ * corresponding "high" register.
+ *
+ * For appropriate registers, bit 0 of the "high" register is a
+ * cascade bit that summarizes (as a bit-OR) the 64 bits of the "low"
+ * register.
+ */
+
+/*
+ * This entire file uses _BCM1480_ in all the symbols because it is
+ * entirely BCM1480 specific.
+ */
+
+/*
+ * Interrupt sources (Table 22)
+ */
+
+#define K_BCM1480_INT_SOURCES               128
+
+#define _BCM1480_INT_HIGH(k)   (k)
+#define _BCM1480_INT_LOW(k)    ((k)+64)
+
+#define K_BCM1480_INT_ADDR_TRAP             _BCM1480_INT_HIGH(1)
+#define K_BCM1480_INT_GPIO_0                _BCM1480_INT_HIGH(4)
+#define K_BCM1480_INT_GPIO_1                _BCM1480_INT_HIGH(5)
+#define K_BCM1480_INT_GPIO_2                _BCM1480_INT_HIGH(6)
+#define K_BCM1480_INT_GPIO_3                _BCM1480_INT_HIGH(7)
+#define K_BCM1480_INT_PCI_INTA              _BCM1480_INT_HIGH(8)
+#define K_BCM1480_INT_PCI_INTB              _BCM1480_INT_HIGH(9)
+#define K_BCM1480_INT_PCI_INTC              _BCM1480_INT_HIGH(10)
+#define K_BCM1480_INT_PCI_INTD              _BCM1480_INT_HIGH(11)
+#define K_BCM1480_INT_CYCLE_CP0             _BCM1480_INT_HIGH(12)
+#define K_BCM1480_INT_CYCLE_CP1             _BCM1480_INT_HIGH(13)
+#define K_BCM1480_INT_CYCLE_CP2             _BCM1480_INT_HIGH(14)
+#define K_BCM1480_INT_CYCLE_CP3             _BCM1480_INT_HIGH(15)
+#define K_BCM1480_INT_TIMER_0               _BCM1480_INT_HIGH(20)
+#define K_BCM1480_INT_TIMER_1               _BCM1480_INT_HIGH(21)
+#define K_BCM1480_INT_TIMER_2               _BCM1480_INT_HIGH(22)
+#define K_BCM1480_INT_TIMER_3               _BCM1480_INT_HIGH(23)
+#define K_BCM1480_INT_DM_CH_0               _BCM1480_INT_HIGH(28)
+#define K_BCM1480_INT_DM_CH_1               _BCM1480_INT_HIGH(29)
+#define K_BCM1480_INT_DM_CH_2               _BCM1480_INT_HIGH(30)
+#define K_BCM1480_INT_DM_CH_3               _BCM1480_INT_HIGH(31)
+#define K_BCM1480_INT_MAC_0                 _BCM1480_INT_HIGH(36)
+#define K_BCM1480_INT_MAC_0_CH1             _BCM1480_INT_HIGH(37)
+#define K_BCM1480_INT_MAC_1                 _BCM1480_INT_HIGH(38)
+#define K_BCM1480_INT_MAC_1_CH1             _BCM1480_INT_HIGH(39)
+#define K_BCM1480_INT_MAC_2                 _BCM1480_INT_HIGH(40)
+#define K_BCM1480_INT_MAC_2_CH1             _BCM1480_INT_HIGH(41)
+#define K_BCM1480_INT_MAC_3                 _BCM1480_INT_HIGH(42)
+#define K_BCM1480_INT_MAC_3_CH1             _BCM1480_INT_HIGH(43)
+#define K_BCM1480_INT_PMI_LOW               _BCM1480_INT_HIGH(52)
+#define K_BCM1480_INT_PMI_HIGH              _BCM1480_INT_HIGH(53)
+#define K_BCM1480_INT_PMO_LOW               _BCM1480_INT_HIGH(54)
+#define K_BCM1480_INT_PMO_HIGH              _BCM1480_INT_HIGH(55)
+#define K_BCM1480_INT_MBOX_0_0              _BCM1480_INT_HIGH(56)
+#define K_BCM1480_INT_MBOX_0_1              _BCM1480_INT_HIGH(57)
+#define K_BCM1480_INT_MBOX_0_2              _BCM1480_INT_HIGH(58)
+#define K_BCM1480_INT_MBOX_0_3              _BCM1480_INT_HIGH(59)
+#define K_BCM1480_INT_MBOX_1_0              _BCM1480_INT_HIGH(60)
+#define K_BCM1480_INT_MBOX_1_1              _BCM1480_INT_HIGH(61)
+#define K_BCM1480_INT_MBOX_1_2              _BCM1480_INT_HIGH(62)
+#define K_BCM1480_INT_MBOX_1_3              _BCM1480_INT_HIGH(63)
+
+#define K_BCM1480_INT_BAD_ECC               _BCM1480_INT_LOW(1)
+#define K_BCM1480_INT_COR_ECC               _BCM1480_INT_LOW(2)
+#define K_BCM1480_INT_IO_BUS                _BCM1480_INT_LOW(3)
+#define K_BCM1480_INT_PERF_CNT              _BCM1480_INT_LOW(4)
+#define K_BCM1480_INT_SW_PERF_CNT           _BCM1480_INT_LOW(5)
+#define K_BCM1480_INT_TRACE_FREEZE          _BCM1480_INT_LOW(6)
+#define K_BCM1480_INT_SW_TRACE_FREEZE       _BCM1480_INT_LOW(7)
+#define K_BCM1480_INT_WATCHDOG_TIMER_0      _BCM1480_INT_LOW(8)
+#define K_BCM1480_INT_WATCHDOG_TIMER_1      _BCM1480_INT_LOW(9)
+#define K_BCM1480_INT_WATCHDOG_TIMER_2      _BCM1480_INT_LOW(10)
+#define K_BCM1480_INT_WATCHDOG_TIMER_3      _BCM1480_INT_LOW(11)
+#define K_BCM1480_INT_PCI_ERROR             _BCM1480_INT_LOW(16)
+#define K_BCM1480_INT_PCI_RESET             _BCM1480_INT_LOW(17)
+#define K_BCM1480_INT_NODE_CONTROLLER       _BCM1480_INT_LOW(18)
+#define K_BCM1480_INT_HOST_BRIDGE           _BCM1480_INT_LOW(19)
+#define K_BCM1480_INT_PORT_0_FATAL          _BCM1480_INT_LOW(20)
+#define K_BCM1480_INT_PORT_0_NONFATAL       _BCM1480_INT_LOW(21)
+#define K_BCM1480_INT_PORT_1_FATAL          _BCM1480_INT_LOW(22)
+#define K_BCM1480_INT_PORT_1_NONFATAL       _BCM1480_INT_LOW(23)
+#define K_BCM1480_INT_PORT_2_FATAL          _BCM1480_INT_LOW(24)
+#define K_BCM1480_INT_PORT_2_NONFATAL       _BCM1480_INT_LOW(25)
+#define K_BCM1480_INT_LDT_SMI               _BCM1480_INT_LOW(32)
+#define K_BCM1480_INT_LDT_NMI               _BCM1480_INT_LOW(33)
+#define K_BCM1480_INT_LDT_INIT              _BCM1480_INT_LOW(34)
+#define K_BCM1480_INT_LDT_STARTUP           _BCM1480_INT_LOW(35)
+#define K_BCM1480_INT_LDT_EXT               _BCM1480_INT_LOW(36)
+#define K_BCM1480_INT_SMB_0                 _BCM1480_INT_LOW(40)
+#define K_BCM1480_INT_SMB_1                 _BCM1480_INT_LOW(41)
+#define K_BCM1480_INT_PCMCIA                _BCM1480_INT_LOW(42)
+#define K_BCM1480_INT_UART_0                _BCM1480_INT_LOW(44)
+#define K_BCM1480_INT_UART_1                _BCM1480_INT_LOW(45)
+#define K_BCM1480_INT_UART_2                _BCM1480_INT_LOW(46)
+#define K_BCM1480_INT_UART_3                _BCM1480_INT_LOW(47)
+#define K_BCM1480_INT_GPIO_4                _BCM1480_INT_LOW(52)
+#define K_BCM1480_INT_GPIO_5                _BCM1480_INT_LOW(53)
+#define K_BCM1480_INT_GPIO_6                _BCM1480_INT_LOW(54)
+#define K_BCM1480_INT_GPIO_7                _BCM1480_INT_LOW(55)
+#define K_BCM1480_INT_GPIO_8                _BCM1480_INT_LOW(56)
+#define K_BCM1480_INT_GPIO_9                _BCM1480_INT_LOW(57)
+#define K_BCM1480_INT_GPIO_10               _BCM1480_INT_LOW(58)
+#define K_BCM1480_INT_GPIO_11               _BCM1480_INT_LOW(59)
+#define K_BCM1480_INT_GPIO_12               _BCM1480_INT_LOW(60)
+#define K_BCM1480_INT_GPIO_13               _BCM1480_INT_LOW(61)
+#define K_BCM1480_INT_GPIO_14               _BCM1480_INT_LOW(62)
+#define K_BCM1480_INT_GPIO_15               _BCM1480_INT_LOW(63)
+
+/*
+ * Mask values for each interrupt
+ */
+
+#define _BCM1480_INT_MASK1(n)               _SB_MAKEMASK1(((n) & 0x3F))
+#define _BCM1480_INT_OFFSET(n)              (((n) & 0x40) << 6)
+
+#define M_BCM1480_INT_CASCADE               _BCM1480_INT_MASK1(_BCM1480_INT_HIGH(0))
+
+#define M_BCM1480_INT_ADDR_TRAP             _BCM1480_INT_MASK1(K_BCM1480_INT_ADDR_TRAP)
+#define M_BCM1480_INT_GPIO_0                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_0)
+#define M_BCM1480_INT_GPIO_1                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_1)
+#define M_BCM1480_INT_GPIO_2                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_2)
+#define M_BCM1480_INT_GPIO_3                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_3)
+#define M_BCM1480_INT_PCI_INTA              _BCM1480_INT_MASK1(K_BCM1480_INT_PCI_INTA)
+#define M_BCM1480_INT_PCI_INTB              _BCM1480_INT_MASK1(K_BCM1480_INT_PCI_INTB)
+#define M_BCM1480_INT_PCI_INTC              _BCM1480_INT_MASK1(K_BCM1480_INT_PCI_INTC)
+#define M_BCM1480_INT_PCI_INTD              _BCM1480_INT_MASK1(K_BCM1480_INT_PCI_INTD)
+#define M_BCM1480_INT_CYCLE_CP0             _BCM1480_INT_MASK1(K_BCM1480_INT_CYCLE_CP0)
+#define M_BCM1480_INT_CYCLE_CP1             _BCM1480_INT_MASK1(K_BCM1480_INT_CYCLE_CP1)
+#define M_BCM1480_INT_CYCLE_CP2             _BCM1480_INT_MASK1(K_BCM1480_INT_CYCLE_CP2)
+#define M_BCM1480_INT_CYCLE_CP3             _BCM1480_INT_MASK1(K_BCM1480_INT_CYCLE_CP3)
+#define M_BCM1480_INT_TIMER_0               _BCM1480_INT_MASK1(K_BCM1480_INT_TIMER_0)
+#define M_BCM1480_INT_TIMER_1               _BCM1480_INT_MASK1(K_BCM1480_INT_TIMER_1)
+#define M_BCM1480_INT_TIMER_2               _BCM1480_INT_MASK1(K_BCM1480_INT_TIMER_2)
+#define M_BCM1480_INT_TIMER_3               _BCM1480_INT_MASK1(K_BCM1480_INT_TIMER_3)
+#define M_BCM1480_INT_DM_CH_0               _BCM1480_INT_MASK1(K_BCM1480_INT_DM_CH_0)
+#define M_BCM1480_INT_DM_CH_1               _BCM1480_INT_MASK1(K_BCM1480_INT_DM_CH_1)
+#define M_BCM1480_INT_DM_CH_2               _BCM1480_INT_MASK1(K_BCM1480_INT_DM_CH_2)
+#define M_BCM1480_INT_DM_CH_3               _BCM1480_INT_MASK1(K_BCM1480_INT_DM_CH_3)
+#define M_BCM1480_INT_MAC_0                 _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_0)
+#define M_BCM1480_INT_MAC_0_CH1             _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_0_CH1)
+#define M_BCM1480_INT_MAC_1                 _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_1)
+#define M_BCM1480_INT_MAC_1_CH1             _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_1_CH1)
+#define M_BCM1480_INT_MAC_2                 _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_2)
+#define M_BCM1480_INT_MAC_2_CH1             _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_2_CH1)
+#define M_BCM1480_INT_MAC_3                 _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_3)
+#define M_BCM1480_INT_MAC_3_CH1             _BCM1480_INT_MASK1(K_BCM1480_INT_MAC_3_CH1)
+#define M_BCM1480_INT_PMI_LOW               _BCM1480_INT_MASK1(K_BCM1480_INT_PMI_LOW)
+#define M_BCM1480_INT_PMI_HIGH              _BCM1480_INT_MASK1(K_BCM1480_INT_PMI_HIGH)
+#define M_BCM1480_INT_PMO_LOW               _BCM1480_INT_MASK1(K_BCM1480_INT_PMO_LOW)
+#define M_BCM1480_INT_PMO_HIGH              _BCM1480_INT_MASK1(K_BCM1480_INT_PMO_HIGH)
+#define M_BCM1480_INT_MBOX_0_0              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_0_0)
+#define M_BCM1480_INT_MBOX_0_1              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_0_1)
+#define M_BCM1480_INT_MBOX_0_2              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_0_2)
+#define M_BCM1480_INT_MBOX_0_3              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_0_3)
+#define M_BCM1480_INT_MBOX_1_0              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_1_0)
+#define M_BCM1480_INT_MBOX_1_1              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_1_1)
+#define M_BCM1480_INT_MBOX_1_2              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_1_2)
+#define M_BCM1480_INT_MBOX_1_3              _BCM1480_INT_MASK1(K_BCM1480_INT_MBOX_1_3)
+#define M_BCM1480_INT_BAD_ECC               _BCM1480_INT_MASK1(K_BCM1480_INT_BAD_ECC)
+#define M_BCM1480_INT_COR_ECC               _BCM1480_INT_MASK1(K_BCM1480_INT_COR_ECC)
+#define M_BCM1480_INT_IO_BUS                _BCM1480_INT_MASK1(K_BCM1480_INT_IO_BUS)
+#define M_BCM1480_INT_PERF_CNT              _BCM1480_INT_MASK1(K_BCM1480_INT_PERF_CNT)
+#define M_BCM1480_INT_SW_PERF_CNT           _BCM1480_INT_MASK1(K_BCM1480_INT_SW_PERF_CNT)
+#define M_BCM1480_INT_TRACE_FREEZE          _BCM1480_INT_MASK1(K_BCM1480_INT_TRACE_FREEZE)
+#define M_BCM1480_INT_SW_TRACE_FREEZE       _BCM1480_INT_MASK1(K_BCM1480_INT_SW_TRACE_FREEZE)
+#define M_BCM1480_INT_WATCHDOG_TIMER_0      _BCM1480_INT_MASK1(K_BCM1480_INT_WATCHDOG_TIMER_0)
+#define M_BCM1480_INT_WATCHDOG_TIMER_1      _BCM1480_INT_MASK1(K_BCM1480_INT_WATCHDOG_TIMER_1)
+#define M_BCM1480_INT_WATCHDOG_TIMER_2      _BCM1480_INT_MASK1(K_BCM1480_INT_WATCHDOG_TIMER_2)
+#define M_BCM1480_INT_WATCHDOG_TIMER_3      _BCM1480_INT_MASK1(K_BCM1480_INT_WATCHDOG_TIMER_3)
+#define M_BCM1480_INT_PCI_ERROR             _BCM1480_INT_MASK1(K_BCM1480_INT_PCI_ERROR)
+#define M_BCM1480_INT_PCI_RESET             _BCM1480_INT_MASK1(K_BCM1480_INT_PCI_RESET)
+#define M_BCM1480_INT_NODE_CONTROLLER       _BCM1480_INT_MASK1(K_BCM1480_INT_NODE_CONTROLLER)
+#define M_BCM1480_INT_HOST_BRIDGE           _BCM1480_INT_MASK1(K_BCM1480_INT_HOST_BRIDGE)
+#define M_BCM1480_INT_PORT_0_FATAL          _BCM1480_INT_MASK1(K_BCM1480_INT_PORT_0_FATAL)
+#define M_BCM1480_INT_PORT_0_NONFATAL       _BCM1480_INT_MASK1(K_BCM1480_INT_PORT_0_NONFATAL)
+#define M_BCM1480_INT_PORT_1_FATAL          _BCM1480_INT_MASK1(K_BCM1480_INT_PORT_1_FATAL)
+#define M_BCM1480_INT_PORT_1_NONFATAL       _BCM1480_INT_MASK1(K_BCM1480_INT_PORT_1_NONFATAL)
+#define M_BCM1480_INT_PORT_2_FATAL          _BCM1480_INT_MASK1(K_BCM1480_INT_PORT_2_FATAL)
+#define M_BCM1480_INT_PORT_2_NONFATAL       _BCM1480_INT_MASK1(K_BCM1480_INT_PORT_2_NONFATAL)
+#define M_BCM1480_INT_LDT_SMI               _BCM1480_INT_MASK1(K_BCM1480_INT_LDT_SMI)
+#define M_BCM1480_INT_LDT_NMI               _BCM1480_INT_MASK1(K_BCM1480_INT_LDT_NMI)
+#define M_BCM1480_INT_LDT_INIT              _BCM1480_INT_MASK1(K_BCM1480_INT_LDT_INIT)
+#define M_BCM1480_INT_LDT_STARTUP           _BCM1480_INT_MASK1(K_BCM1480_INT_LDT_STARTUP)
+#define M_BCM1480_INT_LDT_EXT               _BCM1480_INT_MASK1(K_BCM1480_INT_LDT_EXT)
+#define M_BCM1480_INT_SMB_0                 _BCM1480_INT_MASK1(K_BCM1480_INT_SMB_0)
+#define M_BCM1480_INT_SMB_1                 _BCM1480_INT_MASK1(K_BCM1480_INT_SMB_1)
+#define M_BCM1480_INT_PCMCIA                _BCM1480_INT_MASK1(K_BCM1480_INT_PCMCIA)
+#define M_BCM1480_INT_UART_0                _BCM1480_INT_MASK1(K_BCM1480_INT_UART_0)
+#define M_BCM1480_INT_UART_1                _BCM1480_INT_MASK1(K_BCM1480_INT_UART_1)
+#define M_BCM1480_INT_UART_2                _BCM1480_INT_MASK1(K_BCM1480_INT_UART_2)
+#define M_BCM1480_INT_UART_3                _BCM1480_INT_MASK1(K_BCM1480_INT_UART_3)
+#define M_BCM1480_INT_GPIO_4                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_4)
+#define M_BCM1480_INT_GPIO_5                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_5)
+#define M_BCM1480_INT_GPIO_6                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_6)
+#define M_BCM1480_INT_GPIO_7                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_7)
+#define M_BCM1480_INT_GPIO_8                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_8)
+#define M_BCM1480_INT_GPIO_9                _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_9)
+#define M_BCM1480_INT_GPIO_10               _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_10)
+#define M_BCM1480_INT_GPIO_11               _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_11)
+#define M_BCM1480_INT_GPIO_12               _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_12)
+#define M_BCM1480_INT_GPIO_13               _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_13)
+#define M_BCM1480_INT_GPIO_14               _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_14)
+#define M_BCM1480_INT_GPIO_15               _BCM1480_INT_MASK1(K_BCM1480_INT_GPIO_15)
+
+/*
+ * Interrupt mappings (Table 18)
+ */
+
+#define K_BCM1480_INT_MAP_I0    0		/* interrupt pins on processor */
+#define K_BCM1480_INT_MAP_I1    1
+#define K_BCM1480_INT_MAP_I2    2
+#define K_BCM1480_INT_MAP_I3    3
+#define K_BCM1480_INT_MAP_I4    4
+#define K_BCM1480_INT_MAP_I5    5
+#define K_BCM1480_INT_MAP_NMI   6		/* nonmaskable */
+#define K_BCM1480_INT_MAP_DINT  7		/* debug interrupt */
+
+/*
+ * Interrupt LDT Set Register (Table 19)
+ */
+
+#define S_BCM1480_INT_HT_INTMSG             0
+#define M_BCM1480_INT_HT_INTMSG             _SB_MAKEMASK(3,S_BCM1480_INT_HT_INTMSG)
+#define V_BCM1480_INT_HT_INTMSG(x)          _SB_MAKEVALUE(x,S_BCM1480_INT_HT_INTMSG)
+#define G_BCM1480_INT_HT_INTMSG(x)          _SB_GETVALUE(x,S_BCM1480_INT_HT_INTMSG,M_BCM1480_INT_HT_INTMSG)
+
+#define K_BCM1480_INT_HT_INTMSG_FIXED       0
+#define K_BCM1480_INT_HT_INTMSG_ARBITRATED  1
+#define K_BCM1480_INT_HT_INTMSG_SMI         2
+#define K_BCM1480_INT_HT_INTMSG_NMI         3
+#define K_BCM1480_INT_HT_INTMSG_INIT        4
+#define K_BCM1480_INT_HT_INTMSG_STARTUP     5
+#define K_BCM1480_INT_HT_INTMSG_EXTINT      6
+#define K_BCM1480_INT_HT_INTMSG_RESERVED    7
+
+#define M_BCM1480_INT_HT_TRIGGERMODE        _SB_MAKEMASK1(3)
+#define V_BCM1480_INT_HT_EDGETRIGGER        0
+#define V_BCM1480_INT_HT_LEVELTRIGGER       M_BCM1480_INT_HT_TRIGGERMODE
+
+#define M_BCM1480_INT_HT_DESTMODE           _SB_MAKEMASK1(4)
+#define V_BCM1480_INT_HT_PHYSICALDEST       0
+#define V_BCM1480_INT_HT_LOGICALDEST        M_BCM1480_INT_HT_DESTMODE
+
+#define S_BCM1480_INT_HT_INTDEST            5
+#define M_BCM1480_INT_HT_INTDEST            _SB_MAKEMASK(8,S_BCM1480_INT_HT_INTDEST)
+#define V_BCM1480_INT_HT_INTDEST(x)         _SB_MAKEVALUE(x,S_BCM1480_INT_HT_INTDEST)
+#define G_BCM1480_INT_HT_INTDEST(x)         _SB_GETVALUE(x,S_BCM1480_INT_HT_INTDEST,M_BCM1480_INT_HT_INTDEST)
+
+#define S_BCM1480_INT_HT_VECTOR             13
+#define M_BCM1480_INT_HT_VECTOR             _SB_MAKEMASK(8,S_BCM1480_INT_HT_VECTOR)
+#define V_BCM1480_INT_HT_VECTOR(x)          _SB_MAKEVALUE(x,S_BCM1480_INT_HT_VECTOR)
+#define G_BCM1480_INT_HT_VECTOR(x)          _SB_GETVALUE(x,S_BCM1480_INT_HT_VECTOR,M_BCM1480_INT_HT_VECTOR)
+
+/*
+ * Vector prefix (Table 4-7)
+ */
+
+#define M_BCM1480_HTVECT_RAISE_INTLDT_HIGH  0x00
+#define M_BCM1480_HTVECT_RAISE_MBOX_0       0x40
+#define M_BCM1480_HTVECT_RAISE_INTLDT_LO    0x80
+#define M_BCM1480_HTVECT_RAISE_MBOX_1       0xC0
+
+#endif /* _BCM1480_INT_H */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/bcm1480_l2c.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_l2c.h
--- linux-2.6.14/include/asm-mips/sibyte/bcm1480_l2c.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_l2c.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,176 @@
+/*  *********************************************************************
+    *  BCM1280/BCM1480 Board Support Package
+    *
+    *  L2 Cache constants and macros		File: bcm1480_l2c.h
+    *
+    *  This module contains constants useful for manipulating the
+    *  level 2 cache.
+    *
+    *  BCM1400 specification level:  1280-UM100-D2 (11/14/03)
+    *
+    *********************************************************************
+    *
+    *  Copyright 2000,2001,2002,2003
+    *  Broadcom Corporation. All rights reserved.
+    *
+    *  This program is free software; you can redistribute it and/or
+    *  modify it under the terms of the GNU General Public License as
+    *  published by the Free Software Foundation; either version 2 of
+    *  the License, or (at your option) any later version.
+    *
+    *  This program is distributed in the hope that it will be useful,
+    *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+    *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    *  GNU General Public License for more details.
+    *
+    *  You should have received a copy of the GNU General Public License
+    *  along with this program; if not, write to the Free Software
+    *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+    *  MA 02111-1307 USA
+    ********************************************************************* */
+
+
+#ifndef _BCM1480_L2C_H
+#define _BCM1480_L2C_H
+
+#include "sb1250_defs.h"
+
+/*
+ * Format of level 2 cache management address (Table 55)
+ */
+
+#define S_BCM1480_L2C_MGMT_INDEX            5
+#define M_BCM1480_L2C_MGMT_INDEX            _SB_MAKEMASK(12,S_BCM1480_L2C_MGMT_INDEX)
+#define V_BCM1480_L2C_MGMT_INDEX(x)         _SB_MAKEVALUE(x,S_BCM1480_L2C_MGMT_INDEX)
+#define G_BCM1480_L2C_MGMT_INDEX(x)         _SB_GETVALUE(x,S_BCM1480_L2C_MGMT_INDEX,M_BCM1480_L2C_MGMT_INDEX)
+
+#define S_BCM1480_L2C_MGMT_WAY              17
+#define M_BCM1480_L2C_MGMT_WAY              _SB_MAKEMASK(3,S_BCM1480_L2C_MGMT_WAY)
+#define V_BCM1480_L2C_MGMT_WAY(x)           _SB_MAKEVALUE(x,S_BCM1480_L2C_MGMT_WAY)
+#define G_BCM1480_L2C_MGMT_WAY(x)           _SB_GETVALUE(x,S_BCM1480_L2C_MGMT_WAY,M_BCM1480_L2C_MGMT_WAY)
+
+#define M_BCM1480_L2C_MGMT_DIRTY            _SB_MAKEMASK1(20)
+#define M_BCM1480_L2C_MGMT_VALID            _SB_MAKEMASK1(21)
+
+#define S_BCM1480_L2C_MGMT_ECC_DIAG         22
+#define M_BCM1480_L2C_MGMT_ECC_DIAG         _SB_MAKEMASK(2,S_BCM1480_L2C_MGMT_ECC_DIAG)
+#define V_BCM1480_L2C_MGMT_ECC_DIAG(x)      _SB_MAKEVALUE(x,S_BCM1480_L2C_MGMT_ECC_DIAG)
+#define G_BCM1480_L2C_MGMT_ECC_DIAG(x)      _SB_GETVALUE(x,S_BCM1480_L2C_MGMT_ECC_DIAG,M_BCM1480_L2C_MGMT_ECC_DIAG)
+
+#define A_BCM1480_L2C_MGMT_TAG_BASE         0x00D0000000
+
+#define BCM1480_L2C_ENTRIES_PER_WAY         4096
+#define BCM1480_L2C_NUM_WAYS                8
+
+
+/*
+ * Level 2 Cache Tag register (Table 59)
+ */
+
+#define S_BCM1480_L2C_TAG_MBZ               0
+#define M_BCM1480_L2C_TAG_MBZ               _SB_MAKEMASK(5,S_BCM1480_L2C_TAG_MBZ)
+
+#define S_BCM1480_L2C_TAG_INDEX             5
+#define M_BCM1480_L2C_TAG_INDEX             _SB_MAKEMASK(12,S_BCM1480_L2C_TAG_INDEX)
+#define V_BCM1480_L2C_TAG_INDEX(x)          _SB_MAKEVALUE(x,S_BCM1480_L2C_TAG_INDEX)
+#define G_BCM1480_L2C_TAG_INDEX(x)          _SB_GETVALUE(x,S_BCM1480_L2C_TAG_INDEX,M_BCM1480_L2C_TAG_INDEX)
+
+/* Note that index bit 16 is also tag bit 40 */
+#define S_BCM1480_L2C_TAG_TAG               17
+#define M_BCM1480_L2C_TAG_TAG               _SB_MAKEMASK(23,S_BCM1480_L2C_TAG_TAG)
+#define V_BCM1480_L2C_TAG_TAG(x)            _SB_MAKEVALUE(x,S_BCM1480_L2C_TAG_TAG)
+#define G_BCM1480_L2C_TAG_TAG(x)            _SB_GETVALUE(x,S_BCM1480_L2C_TAG_TAG,M_BCM1480_L2C_TAG_TAG)
+
+#define S_BCM1480_L2C_TAG_ECC               40
+#define M_BCM1480_L2C_TAG_ECC               _SB_MAKEMASK(6,S_BCM1480_L2C_TAG_ECC)
+#define V_BCM1480_L2C_TAG_ECC(x)            _SB_MAKEVALUE(x,S_BCM1480_L2C_TAG_ECC)
+#define G_BCM1480_L2C_TAG_ECC(x)            _SB_GETVALUE(x,S_BCM1480_L2C_TAG_ECC,M_BCM1480_L2C_TAG_ECC)
+
+#define S_BCM1480_L2C_TAG_WAY               46
+#define M_BCM1480_L2C_TAG_WAY               _SB_MAKEMASK(3,S_BCM1480_L2C_TAG_WAY)
+#define V_BCM1480_L2C_TAG_WAY(x)            _SB_MAKEVALUE(x,S_BCM1480_L2C_TAG_WAY)
+#define G_BCM1480_L2C_TAG_WAY(x)            _SB_GETVALUE(x,S_BCM1480_L2C_TAG_WAY,M_BCM1480_L2C_TAG_WAY)
+
+#define M_BCM1480_L2C_TAG_DIRTY             _SB_MAKEMASK1(49)
+#define M_BCM1480_L2C_TAG_VALID             _SB_MAKEMASK1(50)
+
+#define S_BCM1480_L2C_DATA_ECC              51
+#define M_BCM1480_L2C_DATA_ECC              _SB_MAKEMASK(10,S_BCM1480_L2C_DATA_ECC)
+#define V_BCM1480_L2C_DATA_ECC(x)           _SB_MAKEVALUE(x,S_BCM1480_L2C_DATA_ECC)
+#define G_BCM1480_L2C_DATA_ECC(x)           _SB_GETVALUE(x,S_BCM1480_L2C_DATA_ECC,M_BCM1480_L2C_DATA_ECC)
+
+
+/*
+ * L2 Misc0 Value Register (Table 60)
+ */
+
+#define S_BCM1480_L2C_MISC0_WAY_REMOTE      0
+#define M_BCM1480_L2C_MISC0_WAY_REMOTE      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC0_WAY_REMOTE)
+#define G_BCM1480_L2C_MISC0_WAY_REMOTE(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC0_WAY_REMOTE,M_BCM1480_L2C_MISC0_WAY_REMOTE)
+
+#define S_BCM1480_L2C_MISC0_WAY_LOCAL       8
+#define M_BCM1480_L2C_MISC0_WAY_LOCAL       _SB_MAKEMASK(8,S_BCM1480_L2C_MISC0_WAY_LOCAL)
+#define G_BCM1480_L2C_MISC0_WAY_LOCAL(x)    _SB_GETVALUE(x,S_BCM1480_L2C_MISC0_WAY_LOCAL,M_BCM1480_L2C_MISC0_WAY_LOCAL)
+
+#define S_BCM1480_L2C_MISC0_WAY_ENABLE      16
+#define M_BCM1480_L2C_MISC0_WAY_ENABLE      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC0_WAY_ENABLE)
+#define G_BCM1480_L2C_MISC0_WAY_ENABLE(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC0_WAY_ENABLE,M_BCM1480_L2C_MISC0_WAY_ENABLE)
+
+#define S_BCM1480_L2C_MISC0_CACHE_DISABLE   24
+#define M_BCM1480_L2C_MISC0_CACHE_DISABLE   _SB_MAKEMASK(2,S_BCM1480_L2C_MISC0_CACHE_DISABLE)
+#define G_BCM1480_L2C_MISC0_CACHE_DISABLE(x) _SB_GETVALUE(x,S_BCM1480_L2C_MISC0_CACHE_DISABLE,M_BCM1480_L2C_MISC0_CACHE_DISABLE)
+
+#define S_BCM1480_L2C_MISC0_CACHE_QUAD      26
+#define M_BCM1480_L2C_MISC0_CACHE_QUAD      _SB_MAKEMASK(2,S_BCM1480_L2C_MISC0_CACHE_QUAD)
+#define G_BCM1480_L2C_MISC0_CACHE_QUAD(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC0_CACHE_QUAD,M_BCM1480_L2C_MISC0_CACHE_QUAD)
+
+#define S_BCM1480_L2C_MISC0_MC_PRIORITY      30
+#define M_BCM1480_L2C_MISC0_MC_PRIORITY      _SB_MAKEMASK1(S_BCM1480_L2C_MISC0_MC_PRIORITY)
+
+#define S_BCM1480_L2C_MISC0_ECC_CLEANUP      31
+#define M_BCM1480_L2C_MISC0_ECC_CLEANUP      _SB_MAKEMASK1(S_BCM1480_L2C_MISC0_ECC_CLEANUP)
+
+
+/*
+ * L2 Misc1 Value Register (Table 60)
+ */
+
+#define S_BCM1480_L2C_MISC1_WAY_AGENT_0      0
+#define M_BCM1480_L2C_MISC1_WAY_AGENT_0      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC1_WAY_AGENT_0)
+#define G_BCM1480_L2C_MISC1_WAY_AGENT_0(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC1_WAY_AGENT_0,M_BCM1480_L2C_MISC1_WAY_AGENT_0)
+
+#define S_BCM1480_L2C_MISC1_WAY_AGENT_1      8
+#define M_BCM1480_L2C_MISC1_WAY_AGENT_1      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC1_WAY_AGENT_1)
+#define G_BCM1480_L2C_MISC1_WAY_AGENT_1(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC1_WAY_AGENT_1,M_BCM1480_L2C_MISC1_WAY_AGENT_1)
+
+#define S_BCM1480_L2C_MISC1_WAY_AGENT_2      16
+#define M_BCM1480_L2C_MISC1_WAY_AGENT_2      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC1_WAY_AGENT_2)
+#define G_BCM1480_L2C_MISC1_WAY_AGENT_2(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC1_WAY_AGENT_2,M_BCM1480_L2C_MISC1_WAY_AGENT_2)
+
+#define S_BCM1480_L2C_MISC1_WAY_AGENT_3      24
+#define M_BCM1480_L2C_MISC1_WAY_AGENT_3      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC1_WAY_AGENT_3)
+#define G_BCM1480_L2C_MISC1_WAY_AGENT_3(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC1_WAY_AGENT_3,M_BCM1480_L2C_MISC1_WAY_AGENT_3)
+
+#define S_BCM1480_L2C_MISC1_WAY_AGENT_4      32
+#define M_BCM1480_L2C_MISC1_WAY_AGENT_4      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC1_WAY_AGENT_4)
+#define G_BCM1480_L2C_MISC1_WAY_AGENT_4(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC1_WAY_AGENT_4,M_BCM1480_L2C_MISC1_WAY_AGENT_4)
+
+
+/*
+ * L2 Misc2 Value Register (Table 60)
+ */
+
+#define S_BCM1480_L2C_MISC2_WAY_AGENT_8      0
+#define M_BCM1480_L2C_MISC2_WAY_AGENT_8      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC2_WAY_AGENT_8)
+#define G_BCM1480_L2C_MISC2_WAY_AGENT_8(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC2_WAY_AGENT_8,M_BCM1480_L2C_MISC2_WAY_AGENT_8)
+
+#define S_BCM1480_L2C_MISC2_WAY_AGENT_9      8
+#define M_BCM1480_L2C_MISC2_WAY_AGENT_9      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC2_WAY_AGENT_9)
+#define G_BCM1480_L2C_MISC2_WAY_AGENT_9(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC2_WAY_AGENT_9,M_BCM1480_L2C_MISC2_WAY_AGENT_9)
+
+#define S_BCM1480_L2C_MISC2_WAY_AGENT_A      16
+#define M_BCM1480_L2C_MISC2_WAY_AGENT_A      _SB_MAKEMASK(8,S_BCM1480_L2C_MISC2_WAY_AGENT_A)
+#define G_BCM1480_L2C_MISC2_WAY_AGENT_A(x)   _SB_GETVALUE(x,S_BCM1480_L2C_MISC2_WAY_AGENT_A,M_BCM1480_L2C_MISC2_WAY_AGENT_A)
+
+
+#endif /* _BCM1480_L2C_H */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/bcm1480_mc.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_mc.h
--- linux-2.6.14/include/asm-mips/sibyte/bcm1480_mc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_mc.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,962 @@
+/*  *********************************************************************
+    *  BCM1280/BCM1480 Board Support Package
+    *
+    *  Memory Controller constants              File: bcm1480_mc.h
+    *
+    *  This module contains constants and macros useful for
+    *  programming the memory controller.
+    *
+    *  BCM1400 specification level:  1280-UM100-D1 (11/14/03 Review Copy)
+    *
+    *********************************************************************
+    *
+    *  Copyright 2000,2001,2002,2003
+    *  Broadcom Corporation. All rights reserved.
+    *
+    *  This program is free software; you can redistribute it and/or
+    *  modify it under the terms of the GNU General Public License as
+    *  published by the Free Software Foundation; either version 2 of
+    *  the License, or (at your option) any later version.
+    *
+    *  This program is distributed in the hope that it will be useful,
+    *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+    *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    *  GNU General Public License for more details.
+    *
+    *  You should have received a copy of the GNU General Public License
+    *  along with this program; if not, write to the Free Software
+    *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+    *  MA 02111-1307 USA
+    ********************************************************************* */
+
+
+#ifndef _BCM1480_MC_H
+#define _BCM1480_MC_H
+
+#include "sb1250_defs.h"
+
+/*
+ * Memory Channel Configuration Register (Table 81)
+ */
+
+#define S_BCM1480_MC_INTLV0                 0
+#define M_BCM1480_MC_INTLV0                 _SB_MAKEMASK(6,S_BCM1480_MC_INTLV0)
+#define V_BCM1480_MC_INTLV0(x)              _SB_MAKEVALUE(x,S_BCM1480_MC_INTLV0)
+#define G_BCM1480_MC_INTLV0(x)              _SB_GETVALUE(x,S_BCM1480_MC_INTLV0,M_BCM1480_MC_INTLV0)
+#define V_BCM1480_MC_INTLV0_DEFAULT         V_BCM1480_MC_INTLV0(0)
+
+#define S_BCM1480_MC_INTLV1                 8
+#define M_BCM1480_MC_INTLV1                 _SB_MAKEMASK(6,S_BCM1480_MC_INTLV1)
+#define V_BCM1480_MC_INTLV1(x)              _SB_MAKEVALUE(x,S_BCM1480_MC_INTLV1)
+#define G_BCM1480_MC_INTLV1(x)              _SB_GETVALUE(x,S_BCM1480_MC_INTLV1,M_BCM1480_MC_INTLV1)
+#define V_BCM1480_MC_INTLV1_DEFAULT         V_BCM1480_MC_INTLV1(0)
+
+#define S_BCM1480_MC_INTLV2                 16
+#define M_BCM1480_MC_INTLV2                 _SB_MAKEMASK(6,S_BCM1480_MC_INTLV2)
+#define V_BCM1480_MC_INTLV2(x)              _SB_MAKEVALUE(x,S_BCM1480_MC_INTLV2)
+#define G_BCM1480_MC_INTLV2(x)              _SB_GETVALUE(x,S_BCM1480_MC_INTLV2,M_BCM1480_MC_INTLV2)
+#define V_BCM1480_MC_INTLV2_DEFAULT         V_BCM1480_MC_INTLV2(0)
+
+#define S_BCM1480_MC_CS_MODE                32
+#define M_BCM1480_MC_CS_MODE                _SB_MAKEMASK(8,S_BCM1480_MC_CS_MODE)
+#define V_BCM1480_MC_CS_MODE(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_CS_MODE)
+#define G_BCM1480_MC_CS_MODE(x)             _SB_GETVALUE(x,S_BCM1480_MC_CS_MODE,M_BCM1480_MC_CS_MODE)
+#define V_BCM1480_MC_CS_MODE_DEFAULT        V_BCM1480_MC_CS_MODE(0)
+
+#define V_BCM1480_MC_CONFIG_DEFAULT         (V_BCM1480_MC_INTLV0_DEFAULT  | \
+                                     V_BCM1480_MC_INTLV1_DEFAULT  | \
+                                     V_BCM1480_MC_INTLV2_DEFAULT  | \
+				     V_BCM1480_MC_CS_MODE_DEFAULT)
+
+#define K_BCM1480_MC_CS01_MODE		    0x03
+#define K_BCM1480_MC_CS02_MODE		    0x05
+#define K_BCM1480_MC_CS0123_MODE	    0x0F
+#define K_BCM1480_MC_CS0246_MODE	    0x55
+#define K_BCM1480_MC_CS0145_MODE	    0x33
+#define K_BCM1480_MC_CS0167_MODE	    0xC3
+#define K_BCM1480_MC_CSFULL_MODE	    0xFF
+
+/*
+ * Chip Select Start Address Register (Table 82)
+ */
+
+#define S_BCM1480_MC_CS0_START              0
+#define M_BCM1480_MC_CS0_START              _SB_MAKEMASK(12,S_BCM1480_MC_CS0_START)
+#define V_BCM1480_MC_CS0_START(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_CS0_START)
+#define G_BCM1480_MC_CS0_START(x)           _SB_GETVALUE(x,S_BCM1480_MC_CS0_START,M_BCM1480_MC_CS0_START)
+
+#define S_BCM1480_MC_CS1_START              16
+#define M_BCM1480_MC_CS1_START              _SB_MAKEMASK(12,S_BCM1480_MC_CS1_START)
+#define V_BCM1480_MC_CS1_START(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_CS1_START)
+#define G_BCM1480_MC_CS1_START(x)           _SB_GETVALUE(x,S_BCM1480_MC_CS1_START,M_BCM1480_MC_CS1_START)
+
+#define S_BCM1480_MC_CS2_START              32
+#define M_BCM1480_MC_CS2_START              _SB_MAKEMASK(12,S_BCM1480_MC_CS2_START)
+#define V_BCM1480_MC_CS2_START(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_CS2_START)
+#define G_BCM1480_MC_CS2_START(x)           _SB_GETVALUE(x,S_BCM1480_MC_CS2_START,M_BCM1480_MC_CS2_START)
+
+#define S_BCM1480_MC_CS3_START              48
+#define M_BCM1480_MC_CS3_START              _SB_MAKEMASK(12,S_BCM1480_MC_CS3_START)
+#define V_BCM1480_MC_CS3_START(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_CS3_START)
+#define G_BCM1480_MC_CS3_START(x)           _SB_GETVALUE(x,S_BCM1480_MC_CS3_START,M_BCM1480_MC_CS3_START)
+
+/*
+ * Chip Select End Address Register (Table 83)
+ */
+
+#define S_BCM1480_MC_CS0_END                0
+#define M_BCM1480_MC_CS0_END                _SB_MAKEMASK(12,S_BCM1480_MC_CS0_END)
+#define V_BCM1480_MC_CS0_END(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_CS0_END)
+#define G_BCM1480_MC_CS0_END(x)             _SB_GETVALUE(x,S_BCM1480_MC_CS0_END,M_BCM1480_MC_CS0_END)
+
+#define S_BCM1480_MC_CS1_END                16
+#define M_BCM1480_MC_CS1_END                _SB_MAKEMASK(12,S_BCM1480_MC_CS1_END)
+#define V_BCM1480_MC_CS1_END(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_CS1_END)
+#define G_BCM1480_MC_CS1_END(x)             _SB_GETVALUE(x,S_BCM1480_MC_CS1_END,M_BCM1480_MC_CS1_END)
+
+#define S_BCM1480_MC_CS2_END                32
+#define M_BCM1480_MC_CS2_END                _SB_MAKEMASK(12,S_BCM1480_MC_CS2_END)
+#define V_BCM1480_MC_CS2_END(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_CS2_END)
+#define G_BCM1480_MC_CS2_END(x)             _SB_GETVALUE(x,S_BCM1480_MC_CS2_END,M_BCM1480_MC_CS2_END)
+
+#define S_BCM1480_MC_CS3_END                48
+#define M_BCM1480_MC_CS3_END                _SB_MAKEMASK(12,S_BCM1480_MC_CS3_END)
+#define V_BCM1480_MC_CS3_END(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_CS3_END)
+#define G_BCM1480_MC_CS3_END(x)             _SB_GETVALUE(x,S_BCM1480_MC_CS3_END,M_BCM1480_MC_CS3_END)
+
+/*
+ * Row Address Bit Select Register 0 (Table 84)
+ */
+
+#define S_BCM1480_MC_ROW00                  0
+#define M_BCM1480_MC_ROW00                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW00)
+#define V_BCM1480_MC_ROW00(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW00)
+#define G_BCM1480_MC_ROW00(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW00,M_BCM1480_MC_ROW00)
+
+#define S_BCM1480_MC_ROW01                  8
+#define M_BCM1480_MC_ROW01                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW01)
+#define V_BCM1480_MC_ROW01(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW01)
+#define G_BCM1480_MC_ROW01(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW01,M_BCM1480_MC_ROW01)
+
+#define S_BCM1480_MC_ROW02                  16
+#define M_BCM1480_MC_ROW02                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW02)
+#define V_BCM1480_MC_ROW02(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW02)
+#define G_BCM1480_MC_ROW02(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW02,M_BCM1480_MC_ROW02)
+
+#define S_BCM1480_MC_ROW03                  24
+#define M_BCM1480_MC_ROW03                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW03)
+#define V_BCM1480_MC_ROW03(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW03)
+#define G_BCM1480_MC_ROW03(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW03,M_BCM1480_MC_ROW03)
+
+#define S_BCM1480_MC_ROW04                  32
+#define M_BCM1480_MC_ROW04                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW04)
+#define V_BCM1480_MC_ROW04(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW04)
+#define G_BCM1480_MC_ROW04(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW04,M_BCM1480_MC_ROW04)
+
+#define S_BCM1480_MC_ROW05                  40
+#define M_BCM1480_MC_ROW05                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW05)
+#define V_BCM1480_MC_ROW05(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW05)
+#define G_BCM1480_MC_ROW05(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW05,M_BCM1480_MC_ROW05)
+
+#define S_BCM1480_MC_ROW06                  48
+#define M_BCM1480_MC_ROW06                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW06)
+#define V_BCM1480_MC_ROW06(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW06)
+#define G_BCM1480_MC_ROW06(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW06,M_BCM1480_MC_ROW06)
+
+#define S_BCM1480_MC_ROW07                  56
+#define M_BCM1480_MC_ROW07                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW07)
+#define V_BCM1480_MC_ROW07(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW07)
+#define G_BCM1480_MC_ROW07(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW07,M_BCM1480_MC_ROW07)
+
+/*
+ * Row Address Bit Select Register 1 (Table 85)
+ */
+
+#define S_BCM1480_MC_ROW08                  0
+#define M_BCM1480_MC_ROW08                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW08)
+#define V_BCM1480_MC_ROW08(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW08)
+#define G_BCM1480_MC_ROW08(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW08,M_BCM1480_MC_ROW08)
+
+#define S_BCM1480_MC_ROW09                  8
+#define M_BCM1480_MC_ROW09                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW09)
+#define V_BCM1480_MC_ROW09(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW09)
+#define G_BCM1480_MC_ROW09(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW09,M_BCM1480_MC_ROW09)
+
+#define S_BCM1480_MC_ROW10                  16
+#define M_BCM1480_MC_ROW10                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW10)
+#define V_BCM1480_MC_ROW10(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW10)
+#define G_BCM1480_MC_ROW10(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW10,M_BCM1480_MC_ROW10)
+
+#define S_BCM1480_MC_ROW11                  24
+#define M_BCM1480_MC_ROW11                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW11)
+#define V_BCM1480_MC_ROW11(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW11)
+#define G_BCM1480_MC_ROW11(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW11,M_BCM1480_MC_ROW11)
+
+#define S_BCM1480_MC_ROW12                  32
+#define M_BCM1480_MC_ROW12                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW12)
+#define V_BCM1480_MC_ROW12(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW12)
+#define G_BCM1480_MC_ROW12(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW12,M_BCM1480_MC_ROW12)
+
+#define S_BCM1480_MC_ROW13                  40
+#define M_BCM1480_MC_ROW13                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW13)
+#define V_BCM1480_MC_ROW13(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW13)
+#define G_BCM1480_MC_ROW13(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW13,M_BCM1480_MC_ROW13)
+
+#define S_BCM1480_MC_ROW14                  48
+#define M_BCM1480_MC_ROW14                  _SB_MAKEMASK(6,S_BCM1480_MC_ROW14)
+#define V_BCM1480_MC_ROW14(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_ROW14)
+#define G_BCM1480_MC_ROW14(x)               _SB_GETVALUE(x,S_BCM1480_MC_ROW14,M_BCM1480_MC_ROW14)
+
+#define K_BCM1480_MC_ROWX_BIT_SPACING  	    8
+
+/*
+ * Column Address Bit Select Register 0 (Table 86)
+ */
+
+#define S_BCM1480_MC_COL00                  0
+#define M_BCM1480_MC_COL00                  _SB_MAKEMASK(6,S_BCM1480_MC_COL00)
+#define V_BCM1480_MC_COL00(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL00)
+#define G_BCM1480_MC_COL00(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL00,M_BCM1480_MC_COL00)
+
+#define S_BCM1480_MC_COL01                  8
+#define M_BCM1480_MC_COL01                  _SB_MAKEMASK(6,S_BCM1480_MC_COL01)
+#define V_BCM1480_MC_COL01(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL01)
+#define G_BCM1480_MC_COL01(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL01,M_BCM1480_MC_COL01)
+
+#define S_BCM1480_MC_COL02                  16
+#define M_BCM1480_MC_COL02                  _SB_MAKEMASK(6,S_BCM1480_MC_COL02)
+#define V_BCM1480_MC_COL02(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL02)
+#define G_BCM1480_MC_COL02(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL02,M_BCM1480_MC_COL02)
+
+#define S_BCM1480_MC_COL03                  24
+#define M_BCM1480_MC_COL03                  _SB_MAKEMASK(6,S_BCM1480_MC_COL03)
+#define V_BCM1480_MC_COL03(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL03)
+#define G_BCM1480_MC_COL03(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL03,M_BCM1480_MC_COL03)
+
+#define S_BCM1480_MC_COL04                  32
+#define M_BCM1480_MC_COL04                  _SB_MAKEMASK(6,S_BCM1480_MC_COL04)
+#define V_BCM1480_MC_COL04(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL04)
+#define G_BCM1480_MC_COL04(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL04,M_BCM1480_MC_COL04)
+
+#define S_BCM1480_MC_COL05                  40
+#define M_BCM1480_MC_COL05                  _SB_MAKEMASK(6,S_BCM1480_MC_COL05)
+#define V_BCM1480_MC_COL05(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL05)
+#define G_BCM1480_MC_COL05(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL05,M_BCM1480_MC_COL05)
+
+#define S_BCM1480_MC_COL06                  48
+#define M_BCM1480_MC_COL06                  _SB_MAKEMASK(6,S_BCM1480_MC_COL06)
+#define V_BCM1480_MC_COL06(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL06)
+#define G_BCM1480_MC_COL06(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL06,M_BCM1480_MC_COL06)
+
+#define S_BCM1480_MC_COL07                  56
+#define M_BCM1480_MC_COL07                  _SB_MAKEMASK(6,S_BCM1480_MC_COL07)
+#define V_BCM1480_MC_COL07(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL07)
+#define G_BCM1480_MC_COL07(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL07,M_BCM1480_MC_COL07)
+
+/*
+ * Column Address Bit Select Register 1 (Table 87)
+ */
+
+#define S_BCM1480_MC_COL08                  0
+#define M_BCM1480_MC_COL08                  _SB_MAKEMASK(6,S_BCM1480_MC_COL08)
+#define V_BCM1480_MC_COL08(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL08)
+#define G_BCM1480_MC_COL08(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL08,M_BCM1480_MC_COL08)
+
+#define S_BCM1480_MC_COL09                  8
+#define M_BCM1480_MC_COL09                  _SB_MAKEMASK(6,S_BCM1480_MC_COL09)
+#define V_BCM1480_MC_COL09(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL09)
+#define G_BCM1480_MC_COL09(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL09,M_BCM1480_MC_COL09)
+
+#define S_BCM1480_MC_COL10                  16   /* not a valid position, must be prog as 0 */
+
+#define S_BCM1480_MC_COL11                  24
+#define M_BCM1480_MC_COL11                  _SB_MAKEMASK(6,S_BCM1480_MC_COL11)
+#define V_BCM1480_MC_COL11(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL11)
+#define G_BCM1480_MC_COL11(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL11,M_BCM1480_MC_COL11)
+
+#define S_BCM1480_MC_COL12                  32
+#define M_BCM1480_MC_COL12                  _SB_MAKEMASK(6,S_BCM1480_MC_COL12)
+#define V_BCM1480_MC_COL12(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL12)
+#define G_BCM1480_MC_COL12(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL12,M_BCM1480_MC_COL12)
+
+#define S_BCM1480_MC_COL13                  40
+#define M_BCM1480_MC_COL13                  _SB_MAKEMASK(6,S_BCM1480_MC_COL13)
+#define V_BCM1480_MC_COL13(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL13)
+#define G_BCM1480_MC_COL13(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL13,M_BCM1480_MC_COL13)
+
+#define S_BCM1480_MC_COL14                  48
+#define M_BCM1480_MC_COL14                  _SB_MAKEMASK(6,S_BCM1480_MC_COL14)
+#define V_BCM1480_MC_COL14(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_COL14)
+#define G_BCM1480_MC_COL14(x)               _SB_GETVALUE(x,S_BCM1480_MC_COL14,M_BCM1480_MC_COL14)
+
+#define K_BCM1480_MC_COLX_BIT_SPACING  	    8
+
+/*
+ * CS0 and CS1 Bank Address Bit Select Register (Table 88)
+ */
+
+#define S_BCM1480_MC_CS01_BANK0             0
+#define M_BCM1480_MC_CS01_BANK0             _SB_MAKEMASK(6,S_BCM1480_MC_CS01_BANK0)
+#define V_BCM1480_MC_CS01_BANK0(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_CS01_BANK0)
+#define G_BCM1480_MC_CS01_BANK0(x)          _SB_GETVALUE(x,S_BCM1480_MC_CS01_BANK0,M_BCM1480_MC_CS01_BANK0)
+
+#define S_BCM1480_MC_CS01_BANK1             8
+#define M_BCM1480_MC_CS01_BANK1             _SB_MAKEMASK(6,S_BCM1480_MC_CS01_BANK1)
+#define V_BCM1480_MC_CS01_BANK1(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_CS01_BANK1)
+#define G_BCM1480_MC_CS01_BANK1(x)          _SB_GETVALUE(x,S_BCM1480_MC_CS01_BANK1,M_BCM1480_MC_CS01_BANK1)
+
+#define S_BCM1480_MC_CS01_BANK2             16
+#define M_BCM1480_MC_CS01_BANK2             _SB_MAKEMASK(6,S_BCM1480_MC_CS01_BANK2)
+#define V_BCM1480_MC_CS01_BANK2(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_CS01_BANK2)
+#define G_BCM1480_MC_CS01_BANK2(x)          _SB_GETVALUE(x,S_BCM1480_MC_CS01_BANK2,M_BCM1480_MC_CS01_BANK2)
+
+/*
+ * CS2 and CS3 Bank Address Bit Select Register (Table 89)
+ */
+
+#define S_BCM1480_MC_CS23_BANK0             0
+#define M_BCM1480_MC_CS23_BANK0             _SB_MAKEMASK(6,S_BCM1480_MC_CS23_BANK0)
+#define V_BCM1480_MC_CS23_BANK0(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_CS23_BANK0)
+#define G_BCM1480_MC_CS23_BANK0(x)          _SB_GETVALUE(x,S_BCM1480_MC_CS23_BANK0,M_BCM1480_MC_CS23_BANK0)
+
+#define S_BCM1480_MC_CS23_BANK1             8
+#define M_BCM1480_MC_CS23_BANK1             _SB_MAKEMASK(6,S_BCM1480_MC_CS23_BANK1)
+#define V_BCM1480_MC_CS23_BANK1(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_CS23_BANK1)
+#define G_BCM1480_MC_CS23_BANK1(x)          _SB_GETVALUE(x,S_BCM1480_MC_CS23_BANK1,M_BCM1480_MC_CS23_BANK1)
+
+#define S_BCM1480_MC_CS23_BANK2             16
+#define M_BCM1480_MC_CS23_BANK2             _SB_MAKEMASK(6,S_BCM1480_MC_CS23_BANK2)
+#define V_BCM1480_MC_CS23_BANK2(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_CS23_BANK2)
+#define G_BCM1480_MC_CS23_BANK2(x)          _SB_GETVALUE(x,S_BCM1480_MC_CS23_BANK2,M_BCM1480_MC_CS23_BANK2)
+
+#define K_BCM1480_MC_CSXX_BANKX_BIT_SPACING  8
+
+/*
+ * DRAM Command Register (Table 90)
+ */
+
+#define S_BCM1480_MC_COMMAND                0
+#define M_BCM1480_MC_COMMAND                _SB_MAKEMASK(4,S_BCM1480_MC_COMMAND)
+#define V_BCM1480_MC_COMMAND(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_COMMAND)
+#define G_BCM1480_MC_COMMAND(x)             _SB_GETVALUE(x,S_BCM1480_MC_COMMAND,M_BCM1480_MC_COMMAND)
+
+#define K_BCM1480_MC_COMMAND_EMRS           0
+#define K_BCM1480_MC_COMMAND_MRS            1
+#define K_BCM1480_MC_COMMAND_PRE            2
+#define K_BCM1480_MC_COMMAND_AR             3
+#define K_BCM1480_MC_COMMAND_SETRFSH        4
+#define K_BCM1480_MC_COMMAND_CLRRFSH        5
+#define K_BCM1480_MC_COMMAND_SETPWRDN       6
+#define K_BCM1480_MC_COMMAND_CLRPWRDN       7
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define K_BCM1480_MC_COMMAND_EMRS2	    8
+#define K_BCM1480_MC_COMMAND_EMRS3	    9
+#define K_BCM1480_MC_COMMAND_ENABLE_MCLK    10
+#define K_BCM1480_MC_COMMAND_DISABLE_MCLK   11
+#endif
+
+#define V_BCM1480_MC_COMMAND_EMRS           V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_EMRS)
+#define V_BCM1480_MC_COMMAND_MRS            V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_MRS)
+#define V_BCM1480_MC_COMMAND_PRE            V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_PRE)
+#define V_BCM1480_MC_COMMAND_AR             V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_AR)
+#define V_BCM1480_MC_COMMAND_SETRFSH        V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_SETRFSH)
+#define V_BCM1480_MC_COMMAND_CLRRFSH        V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_CLRRFSH)
+#define V_BCM1480_MC_COMMAND_SETPWRDN       V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_SETPWRDN)
+#define V_BCM1480_MC_COMMAND_CLRPWRDN       V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_CLRPWRDN)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define V_BCM1480_MC_COMMAND_EMRS2          V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_EMRS2)
+#define V_BCM1480_MC_COMMAND_EMRS3          V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_EMRS3)
+#define V_BCM1480_MC_COMMAND_ENABLE_MCLK    V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_ENABLE_MCLK)
+#define V_BCM1480_MC_COMMAND_DISABLE_MCLK   V_BCM1480_MC_COMMAND(K_BCM1480_MC_COMMAND_DISABLE_MCLK)
+#endif
+
+#define S_BCM1480_MC_CS0		    4
+#define M_BCM1480_MC_CS0                    _SB_MAKEMASK1(4)
+#define M_BCM1480_MC_CS1                    _SB_MAKEMASK1(5)
+#define M_BCM1480_MC_CS2                    _SB_MAKEMASK1(6)
+#define M_BCM1480_MC_CS3                    _SB_MAKEMASK1(7)
+#define M_BCM1480_MC_CS4                    _SB_MAKEMASK1(8)
+#define M_BCM1480_MC_CS5                    _SB_MAKEMASK1(9)
+#define M_BCM1480_MC_CS6                    _SB_MAKEMASK1(10)
+#define M_BCM1480_MC_CS7                    _SB_MAKEMASK1(11)
+
+#define M_BCM1480_MC_CMD_ACTIVE             _SB_MAKEMASK1(16)
+
+/*
+ * DRAM Mode Register (Table 91)
+ */
+
+#define S_BCM1480_MC_EMODE                  0
+#define M_BCM1480_MC_EMODE                  _SB_MAKEMASK(15,S_BCM1480_MC_EMODE)
+#define V_BCM1480_MC_EMODE(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_EMODE)
+#define G_BCM1480_MC_EMODE(x)               _SB_GETVALUE(x,S_BCM1480_MC_EMODE,M_BCM1480_MC_EMODE)
+#define V_BCM1480_MC_EMODE_DEFAULT          V_BCM1480_MC_EMODE(0)
+
+#define S_BCM1480_MC_MODE                   16
+#define M_BCM1480_MC_MODE                   _SB_MAKEMASK(15,S_BCM1480_MC_MODE)
+#define V_BCM1480_MC_MODE(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_MODE)
+#define G_BCM1480_MC_MODE(x)                _SB_GETVALUE(x,S_BCM1480_MC_MODE,M_BCM1480_MC_MODE)
+#define V_BCM1480_MC_MODE_DEFAULT           V_BCM1480_MC_MODE(0)
+
+#define S_BCM1480_MC_DRAM_TYPE              32
+#define M_BCM1480_MC_DRAM_TYPE              _SB_MAKEMASK(4,S_BCM1480_MC_DRAM_TYPE)
+#define V_BCM1480_MC_DRAM_TYPE(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_DRAM_TYPE)
+#define G_BCM1480_MC_DRAM_TYPE(x)           _SB_GETVALUE(x,S_BCM1480_MC_DRAM_TYPE,M_BCM1480_MC_DRAM_TYPE)
+
+#define K_BCM1480_MC_DRAM_TYPE_JEDEC        0
+#define K_BCM1480_MC_DRAM_TYPE_FCRAM        1
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define K_BCM1480_MC_DRAM_TYPE_DDR2	    2
+#endif
+
+#define V_BCM1480_MC_DRAM_TYPE_JEDEC        V_BCM1480_MC_DRAM_TYPE(K_BCM1480_MC_DRAM_TYPE_JEDEC)
+#define V_BCM1480_MC_DRAM_TYPE_FCRAM        V_BCM1480_MC_DRAM_TYPE(K_BCM1480_MC_DRAM_TYPE_FCRAM)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define V_BCM1480_MC_DRAM_TYPE_DDR2	    V_BCM1480_MC_DRAM_TYPE(K_BCM1480_MC_DRAM_TYPE_DDR2)
+#endif
+
+#define M_BCM1480_MC_GANGED                 _SB_MAKEMASK1(36)
+#define M_BCM1480_MC_BY9_INTF               _SB_MAKEMASK1(37)
+#define M_BCM1480_MC_FORCE_ECC64            _SB_MAKEMASK1(38)
+#define M_BCM1480_MC_ECC_DISABLE            _SB_MAKEMASK1(39)
+
+#define S_BCM1480_MC_PG_POLICY              40
+#define M_BCM1480_MC_PG_POLICY              _SB_MAKEMASK(2,S_BCM1480_MC_PG_POLICY)
+#define V_BCM1480_MC_PG_POLICY(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_PG_POLICY)
+#define G_BCM1480_MC_PG_POLICY(x)           _SB_GETVALUE(x,S_BCM1480_MC_PG_POLICY,M_BCM1480_MC_PG_POLICY)
+
+#define K_BCM1480_MC_PG_POLICY_CLOSED       0
+#define K_BCM1480_MC_PG_POLICY_CAS_TIME_CHK 1
+
+#define V_BCM1480_MC_PG_POLICY_CLOSED       V_BCM1480_MC_PG_POLICY(K_BCM1480_MC_PG_POLICY_CLOSED)
+#define V_BCM1480_MC_PG_POLICY_CAS_TIME_CHK V_BCM1480_MC_PG_POLICY(K_BCM1480_MC_PG_POLICY_CAS_TIME_CHK)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define M_BCM1480_MC_2T_CMD		    _SB_MAKEMASK1(42)
+#define M_BCM1480_MC_ECC_COR_DIS	    _SB_MAKEMASK1(43)
+#endif
+
+#define V_BCM1480_MC_DRAMMODE_DEFAULT	V_BCM1480_MC_EMODE_DEFAULT | V_BCM1480_MC_MODE_DEFAULT | V_BCM1480_MC_DRAM_TYPE_JEDEC | \
+                                V_BCM1480_MC_PG_POLICY(K_BCM1480_MC_PG_POLICY_CAS_TIME_CHK)
+
+/*
+ * Memory Clock Configuration Register (Table 92)
+ */
+
+#define S_BCM1480_MC_CLK_RATIO              0
+#define M_BCM1480_MC_CLK_RATIO              _SB_MAKEMASK(6,S_BCM1480_MC_CLK_RATIO)
+#define V_BCM1480_MC_CLK_RATIO(x)           _SB_MAKEVALUE(x,S_BCM1480_MC_CLK_RATIO)
+#define G_BCM1480_MC_CLK_RATIO(x)           _SB_GETVALUE(x,S_BCM1480_MC_CLK_RATIO,M_BCM1480_MC_CLK_RATIO)
+
+#define V_BCM1480_MC_CLK_RATIO_DEFAULT      V_BCM1480_MC_CLK_RATIO(10)
+
+#define S_BCM1480_MC_REF_RATE               8
+#define M_BCM1480_MC_REF_RATE               _SB_MAKEMASK(8,S_BCM1480_MC_REF_RATE)
+#define V_BCM1480_MC_REF_RATE(x)            _SB_MAKEVALUE(x,S_BCM1480_MC_REF_RATE)
+#define G_BCM1480_MC_REF_RATE(x)            _SB_GETVALUE(x,S_BCM1480_MC_REF_RATE,M_BCM1480_MC_REF_RATE)
+
+#define K_BCM1480_MC_REF_RATE_100MHz        0x31
+#define K_BCM1480_MC_REF_RATE_200MHz        0x62
+#define K_BCM1480_MC_REF_RATE_400MHz        0xC4
+
+#define V_BCM1480_MC_REF_RATE_100MHz        V_BCM1480_MC_REF_RATE(K_BCM1480_MC_REF_RATE_100MHz)
+#define V_BCM1480_MC_REF_RATE_200MHz        V_BCM1480_MC_REF_RATE(K_BCM1480_MC_REF_RATE_200MHz)
+#define V_BCM1480_MC_REF_RATE_400MHz        V_BCM1480_MC_REF_RATE(K_BCM1480_MC_REF_RATE_400MHz)
+#define V_BCM1480_MC_REF_RATE_DEFAULT       V_BCM1480_MC_REF_RATE_400MHz
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define M_BCM1480_MC_AUTO_REF_DIS	    _SB_MAKEMASK1(16)
+#endif
+
+/*
+ * ODT Register (Table 99)
+ */
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define M_BCM1480_MC_RD_ODT0_CS0	    _SB_MAKEMASK1(0)
+#define M_BCM1480_MC_RD_ODT0_CS2	    _SB_MAKEMASK1(1)
+#define M_BCM1480_MC_RD_ODT0_CS4	    _SB_MAKEMASK1(2)
+#define M_BCM1480_MC_RD_ODT0_CS6	    _SB_MAKEMASK1(3)
+#define M_BCM1480_MC_WR_ODT0_CS0	    _SB_MAKEMASK1(4)
+#define M_BCM1480_MC_WR_ODT0_CS2	    _SB_MAKEMASK1(5)
+#define M_BCM1480_MC_WR_ODT0_CS4	    _SB_MAKEMASK1(6)
+#define M_BCM1480_MC_WR_ODT0_CS6	    _SB_MAKEMASK1(7)
+#define M_BCM1480_MC_RD_ODT2_CS0	    _SB_MAKEMASK1(8)
+#define M_BCM1480_MC_RD_ODT2_CS2	    _SB_MAKEMASK1(9)
+#define M_BCM1480_MC_RD_ODT2_CS4	    _SB_MAKEMASK1(10)
+#define M_BCM1480_MC_RD_ODT2_CS6	    _SB_MAKEMASK1(11)
+#define M_BCM1480_MC_WR_ODT2_CS0	    _SB_MAKEMASK1(12)
+#define M_BCM1480_MC_WR_ODT2_CS2	    _SB_MAKEMASK1(13)
+#define M_BCM1480_MC_WR_ODT2_CS4	    _SB_MAKEMASK1(14)
+#define M_BCM1480_MC_WR_ODT2_CS6	    _SB_MAKEMASK1(15)
+#define M_BCM1480_MC_RD_ODT4_CS0	    _SB_MAKEMASK1(16)
+#define M_BCM1480_MC_RD_ODT4_CS2	    _SB_MAKEMASK1(17)
+#define M_BCM1480_MC_RD_ODT4_CS4	    _SB_MAKEMASK1(18)
+#define M_BCM1480_MC_RD_ODT4_CS6	    _SB_MAKEMASK1(19)
+#define M_BCM1480_MC_WR_ODT4_CS0	    _SB_MAKEMASK1(20)
+#define M_BCM1480_MC_WR_ODT4_CS2	    _SB_MAKEMASK1(21)
+#define M_BCM1480_MC_WR_ODT4_CS4	    _SB_MAKEMASK1(22)
+#define M_BCM1480_MC_WR_ODT4_CS6	    _SB_MAKEMASK1(23)
+#define M_BCM1480_MC_RD_ODT6_CS0	    _SB_MAKEMASK1(24)
+#define M_BCM1480_MC_RD_ODT6_CS2	    _SB_MAKEMASK1(25)
+#define M_BCM1480_MC_RD_ODT6_CS4	    _SB_MAKEMASK1(26)
+#define M_BCM1480_MC_RD_ODT6_CS6	    _SB_MAKEMASK1(27)
+#define M_BCM1480_MC_WR_ODT6_CS0	    _SB_MAKEMASK1(28)
+#define M_BCM1480_MC_WR_ODT6_CS2	    _SB_MAKEMASK1(29)
+#define M_BCM1480_MC_WR_ODT6_CS4	    _SB_MAKEMASK1(30)
+#define M_BCM1480_MC_WR_ODT6_CS6	    _SB_MAKEMASK1(31)
+
+#define M_BCM1480_MC_CS_ODD_ODT_EN	    _SB_MAKEMASK1(32)
+#endif
+
+/*
+ * Memory DLL Configuration Register (Table 93)
+ */
+
+#define S_BCM1480_MC_ADDR_COARSE_ADJ         0
+#define M_BCM1480_MC_ADDR_COARSE_ADJ         _SB_MAKEMASK(6,S_BCM1480_MC_ADDR_COARSE_ADJ)
+#define V_BCM1480_MC_ADDR_COARSE_ADJ(x)      _SB_MAKEVALUE(x,S_BCM1480_MC_ADDR_COARSE_ADJ)
+#define G_BCM1480_MC_ADDR_COARSE_ADJ(x)      _SB_GETVALUE(x,S_BCM1480_MC_ADDR_COARSE_ADJ,M_BCM1480_MC_ADDR_COARSE_ADJ)
+#define V_BCM1480_MC_ADDR_COARSE_ADJ_DEFAULT V_BCM1480_MC_ADDR_COARSE_ADJ(0x0)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_ADDR_FREQ_RANGE	    	8
+#define M_BCM1480_MC_ADDR_FREQ_RANGE	    	_SB_MAKEMASK(4,S_BCM1480_MC_ADDR_FREQ_RANGE)
+#define V_BCM1480_MC_ADDR_FREQ_RANGE(x)     	_SB_MAKEVALUE(x,S_BCM1480_MC_ADDR_FREQ_RANGE)
+#define G_BCM1480_MC_ADDR_FREQ_RANGE(x)     	_SB_GETVALUE(x,S_BCM1480_MC_ADDR_FREQ_RANGE,M_BCM1480_MC_ADDR_FREQ_RANGE)
+#define V_BCM1480_MC_ADDR_FREQ_RANGE_DEFAULT 	V_BCM1480_MC_ADDR_FREQ_RANGE(0x4)
+#endif
+
+#define S_BCM1480_MC_ADDR_FINE_ADJ          8
+#define M_BCM1480_MC_ADDR_FINE_ADJ          _SB_MAKEMASK(4,S_BCM1480_MC_ADDR_FINE_ADJ)
+#define V_BCM1480_MC_ADDR_FINE_ADJ(x)       _SB_MAKEVALUE(x,S_BCM1480_MC_ADDR_FINE_ADJ)
+#define G_BCM1480_MC_ADDR_FINE_ADJ(x)       _SB_GETVALUE(x,S_BCM1480_MC_ADDR_FINE_ADJ,M_BCM1480_MC_ADDR_FINE_ADJ)
+#define V_BCM1480_MC_ADDR_FINE_ADJ_DEFAULT  V_BCM1480_MC_ADDR_FINE_ADJ(0x8)
+
+#define S_BCM1480_MC_DQI_COARSE_ADJ         16
+#define M_BCM1480_MC_DQI_COARSE_ADJ         _SB_MAKEMASK(6,S_BCM1480_MC_DQI_COARSE_ADJ)
+#define V_BCM1480_MC_DQI_COARSE_ADJ(x)      _SB_MAKEVALUE(x,S_BCM1480_MC_DQI_COARSE_ADJ)
+#define G_BCM1480_MC_DQI_COARSE_ADJ(x)      _SB_GETVALUE(x,S_BCM1480_MC_DQI_COARSE_ADJ,M_BCM1480_MC_DQI_COARSE_ADJ)
+#define V_BCM1480_MC_DQI_COARSE_ADJ_DEFAULT V_BCM1480_MC_DQI_COARSE_ADJ(0x0)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_DQI_FREQ_RANGE	    	24
+#define M_BCM1480_MC_DQI_FREQ_RANGE	    	_SB_MAKEMASK(4,S_BCM1480_MC_DQI_FREQ_RANGE)
+#define V_BCM1480_MC_DQI_FREQ_RANGE(x)     	_SB_MAKEVALUE(x,S_BCM1480_MC_DQI_FREQ_RANGE)
+#define G_BCM1480_MC_DQI_FREQ_RANGE(x)     	_SB_GETVALUE(x,S_BCM1480_MC_DQI_FREQ_RANGE,M_BCM1480_MC_DQI_FREQ_RANGE)
+#define V_BCM1480_MC_DQI_FREQ_RANGE_DEFAULT 	V_BCM1480_MC_DQI_FREQ_RANGE(0x4)
+#endif
+
+#define S_BCM1480_MC_DQI_FINE_ADJ           24
+#define M_BCM1480_MC_DQI_FINE_ADJ           _SB_MAKEMASK(4,S_BCM1480_MC_DQI_FINE_ADJ)
+#define V_BCM1480_MC_DQI_FINE_ADJ(x)        _SB_MAKEVALUE(x,S_BCM1480_MC_DQI_FINE_ADJ)
+#define G_BCM1480_MC_DQI_FINE_ADJ(x)        _SB_GETVALUE(x,S_BCM1480_MC_DQI_FINE_ADJ,M_BCM1480_MC_DQI_FINE_ADJ)
+#define V_BCM1480_MC_DQI_FINE_ADJ_DEFAULT   V_BCM1480_MC_DQI_FINE_ADJ(0x8)
+
+#define S_BCM1480_MC_DQO_COARSE_ADJ         32
+#define M_BCM1480_MC_DQO_COARSE_ADJ         _SB_MAKEMASK(6,S_BCM1480_MC_DQO_COARSE_ADJ)
+#define V_BCM1480_MC_DQO_COARSE_ADJ(x)      _SB_MAKEVALUE(x,S_BCM1480_MC_DQO_COARSE_ADJ)
+#define G_BCM1480_MC_DQO_COARSE_ADJ(x)      _SB_GETVALUE(x,S_BCM1480_MC_DQO_COARSE_ADJ,M_BCM1480_MC_DQO_COARSE_ADJ)
+#define V_BCM1480_MC_DQO_COARSE_ADJ_DEFAULT V_BCM1480_MC_DQO_COARSE_ADJ(0x0)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_DQO_FREQ_RANGE	    	40
+#define M_BCM1480_MC_DQO_FREQ_RANGE	    	_SB_MAKEMASK(4,S_BCM1480_MC_DQO_FREQ_RANGE)
+#define V_BCM1480_MC_DQO_FREQ_RANGE(x)     	_SB_MAKEVALUE(x,S_BCM1480_MC_DQO_FREQ_RANGE)
+#define G_BCM1480_MC_DQO_FREQ_RANGE(x)     	_SB_GETVALUE(x,S_BCM1480_MC_DQO_FREQ_RANGE,M_BCM1480_MC_DQO_FREQ_RANGE)
+#define V_BCM1480_MC_DQO_FREQ_RANGE_DEFAULT 	V_BCM1480_MC_DQO_FREQ_RANGE(0x4)
+#endif
+
+#define S_BCM1480_MC_DQO_FINE_ADJ           40
+#define M_BCM1480_MC_DQO_FINE_ADJ           _SB_MAKEMASK(4,S_BCM1480_MC_DQO_FINE_ADJ)
+#define V_BCM1480_MC_DQO_FINE_ADJ(x)        _SB_MAKEVALUE(x,S_BCM1480_MC_DQO_FINE_ADJ)
+#define G_BCM1480_MC_DQO_FINE_ADJ(x)        _SB_GETVALUE(x,S_BCM1480_MC_DQO_FINE_ADJ,M_BCM1480_MC_DQO_FINE_ADJ)
+#define V_BCM1480_MC_DQO_FINE_ADJ_DEFAULT   V_BCM1480_MC_DQO_FINE_ADJ(0x8)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_DLL_PDSEL            44
+#define M_BCM1480_MC_DLL_PDSEL            _SB_MAKEMASK(2,S_BCM1480_MC_DLL_PDSEL)
+#define V_BCM1480_MC_DLL_PDSEL(x)         _SB_MAKEVALUE(x,S_BCM1480_MC_DLL_PDSEL)
+#define G_BCM1480_MC_DLL_PDSEL(x)         _SB_GETVALUE(x,S_BCM1480_MC_DLL_PDSEL,M_BCM1480_MC_DLL_PDSEL)
+#define V_BCM1480_MC_DLL_DEFAULT_PDSEL    V_BCM1480_MC_DLL_PDSEL(0x0)
+
+#define	M_BCM1480_MC_DLL_REGBYPASS        _SB_MAKEMASK1(46)
+#define	M_BCM1480_MC_DQO_SHIFT            _SB_MAKEMASK1(47)
+#endif
+
+#define S_BCM1480_MC_DLL_DEFAULT            48
+#define M_BCM1480_MC_DLL_DEFAULT            _SB_MAKEMASK(6,S_BCM1480_MC_DLL_DEFAULT)
+#define V_BCM1480_MC_DLL_DEFAULT(x)         _SB_MAKEVALUE(x,S_BCM1480_MC_DLL_DEFAULT)
+#define G_BCM1480_MC_DLL_DEFAULT(x)         _SB_GETVALUE(x,S_BCM1480_MC_DLL_DEFAULT,M_BCM1480_MC_DLL_DEFAULT)
+#define V_BCM1480_MC_DLL_DEFAULT_DEFAULT    V_BCM1480_MC_DLL_DEFAULT(0x10)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_DLL_REGCTRL	  54
+#define M_BCM1480_MC_DLL_REGCTRL       	  _SB_MAKEMASK(2,S_BCM1480_MC_DLL_REGCTRL)
+#define V_BCM1480_MC_DLL_REGCTRL(x)       _SB_MAKEVALUE(x,S_BCM1480_MC_DLL_REGCTRL)
+#define G_BCM1480_MC_DLL_REGCTRL(x)       _SB_GETVALUE(x,S_BCM1480_MC_DLL_REGCTRL,M_BCM1480_MC_DLL_REGCTRL)
+#define V_BCM1480_MC_DLL_DEFAULT_REGCTRL  V_BCM1480_MC_DLL_REGCTRL(0x0)
+#endif
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_DLL_FREQ_RANGE	    	56
+#define M_BCM1480_MC_DLL_FREQ_RANGE	    	_SB_MAKEMASK(4,S_BCM1480_MC_DLL_FREQ_RANGE)
+#define V_BCM1480_MC_DLL_FREQ_RANGE(x)     	_SB_MAKEVALUE(x,S_BCM1480_MC_DLL_FREQ_RANGE)
+#define G_BCM1480_MC_DLL_FREQ_RANGE(x)     	_SB_GETVALUE(x,S_BCM1480_MC_DLL_FREQ_RANGE,M_BCM1480_MC_DLL_FREQ_RANGE)
+#define V_BCM1480_MC_DLL_FREQ_RANGE_DEFAULT 	V_BCM1480_MC_DLL_FREQ_RANGE(0x4)
+#endif
+
+#define S_BCM1480_MC_DLL_STEP_SIZE          56
+#define M_BCM1480_MC_DLL_STEP_SIZE          _SB_MAKEMASK(4,S_BCM1480_MC_DLL_STEP_SIZE)
+#define V_BCM1480_MC_DLL_STEP_SIZE(x)       _SB_MAKEVALUE(x,S_BCM1480_MC_DLL_STEP_SIZE)
+#define G_BCM1480_MC_DLL_STEP_SIZE(x)       _SB_GETVALUE(x,S_BCM1480_MC_DLL_STEP_SIZE,M_BCM1480_MC_DLL_STEP_SIZE)
+#define V_BCM1480_MC_DLL_STEP_SIZE_DEFAULT  V_BCM1480_MC_DLL_STEP_SIZE(0x8)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_DLL_BGCTRL	  60
+#define M_BCM1480_MC_DLL_BGCTRL       	  _SB_MAKEMASK(2,S_BCM1480_MC_DLL_BGCTRL)
+#define V_BCM1480_MC_DLL_BGCTRL(x)       _SB_MAKEVALUE(x,S_BCM1480_MC_DLL_BGCTRL)
+#define G_BCM1480_MC_DLL_BGCTRL(x)       _SB_GETVALUE(x,S_BCM1480_MC_DLL_BGCTRL,M_BCM1480_MC_DLL_BGCTRL)
+#define V_BCM1480_MC_DLL_DEFAULT_BGCTRL  V_BCM1480_MC_DLL_BGCTRL(0x0)
+#endif
+
+#define	M_BCM1480_MC_DLL_BYPASS		    _SB_MAKEMASK1(63)
+
+/*
+ * Memory Drive Configuration Register (Table 94)
+ */
+
+#define S_BCM1480_MC_RTT_BYP_PULLDOWN       0
+#define M_BCM1480_MC_RTT_BYP_PULLDOWN       _SB_MAKEMASK(3,S_BCM1480_MC_RTT_BYP_PULLDOWN)
+#define V_BCM1480_MC_RTT_BYP_PULLDOWN(x)    _SB_MAKEVALUE(x,S_BCM1480_MC_RTT_BYP_PULLDOWN)
+#define G_BCM1480_MC_RTT_BYP_PULLDOWN(x)    _SB_GETVALUE(x,S_BCM1480_MC_RTT_BYP_PULLDOWN,M_BCM1480_MC_RTT_BYP_PULLDOWN)
+
+#define S_BCM1480_MC_RTT_BYP_PULLUP         6
+#define M_BCM1480_MC_RTT_BYP_PULLUP         _SB_MAKEMASK(3,S_BCM1480_MC_RTT_BYP_PULLUP)
+#define V_BCM1480_MC_RTT_BYP_PULLUP(x)      _SB_MAKEVALUE(x,S_BCM1480_MC_RTT_BYP_PULLUP)
+#define G_BCM1480_MC_RTT_BYP_PULLUP(x)      _SB_GETVALUE(x,S_BCM1480_MC_RTT_BYP_PULLUP,M_BCM1480_MC_RTT_BYP_PULLUP)
+
+#define M_BCM1480_MC_RTT_BYPASS             _SB_MAKEMASK1(8)
+#define M_BCM1480_MC_RTT_COMP_MOV_AVG       _SB_MAKEMASK1(9)
+
+#define S_BCM1480_MC_PVT_BYP_C1_PULLDOWN    10
+#define M_BCM1480_MC_PVT_BYP_C1_PULLDOWN    _SB_MAKEMASK(4,S_BCM1480_MC_PVT_BYP_C1_PULLDOWN)
+#define V_BCM1480_MC_PVT_BYP_C1_PULLDOWN(x) _SB_MAKEVALUE(x,S_BCM1480_MC_PVT_BYP_C1_PULLDOWN)
+#define G_BCM1480_MC_PVT_BYP_C1_PULLDOWN(x) _SB_GETVALUE(x,S_BCM1480_MC_PVT_BYP_C1_PULLDOWN,M_BCM1480_MC_PVT_BYP_C1_PULLDOWN)
+
+#define S_BCM1480_MC_PVT_BYP_C1_PULLUP      15
+#define M_BCM1480_MC_PVT_BYP_C1_PULLUP      _SB_MAKEMASK(4,S_BCM1480_MC_PVT_BYP_C1_PULLUP)
+#define V_BCM1480_MC_PVT_BYP_C1_PULLUP(x)   _SB_MAKEVALUE(x,S_BCM1480_MC_PVT_BYP_C1_PULLUP)
+#define G_BCM1480_MC_PVT_BYP_C1_PULLUP(x)   _SB_GETVALUE(x,S_BCM1480_MC_PVT_BYP_C1_PULLUP,M_BCM1480_MC_PVT_BYP_C1_PULLUP)
+
+#define S_BCM1480_MC_PVT_BYP_C2_PULLDOWN    20
+#define M_BCM1480_MC_PVT_BYP_C2_PULLDOWN    _SB_MAKEMASK(4,S_BCM1480_MC_PVT_BYP_C2_PULLDOWN)
+#define V_BCM1480_MC_PVT_BYP_C2_PULLDOWN(x) _SB_MAKEVALUE(x,S_BCM1480_MC_PVT_BYP_C2_PULLDOWN)
+#define G_BCM1480_MC_PVT_BYP_C2_PULLDOWN(x) _SB_GETVALUE(x,S_BCM1480_MC_PVT_BYP_C2_PULLDOWN,M_BCM1480_MC_PVT_BYP_C2_PULLDOWN)
+
+#define S_BCM1480_MC_PVT_BYP_C2_PULLUP      25
+#define M_BCM1480_MC_PVT_BYP_C2_PULLUP      _SB_MAKEMASK(4,S_BCM1480_MC_PVT_BYP_C2_PULLUP)
+#define V_BCM1480_MC_PVT_BYP_C2_PULLUP(x)   _SB_MAKEVALUE(x,S_BCM1480_MC_PVT_BYP_C2_PULLUP)
+#define G_BCM1480_MC_PVT_BYP_C2_PULLUP(x)   _SB_GETVALUE(x,S_BCM1480_MC_PVT_BYP_C2_PULLUP,M_BCM1480_MC_PVT_BYP_C2_PULLUP)
+
+#define M_BCM1480_MC_PVT_BYPASS             _SB_MAKEMASK1(30)
+#define M_BCM1480_MC_PVT_COMP_MOV_AVG       _SB_MAKEMASK1(31)
+
+#define M_BCM1480_MC_CLK_CLASS              _SB_MAKEMASK1(34)
+#define M_BCM1480_MC_DATA_CLASS             _SB_MAKEMASK1(35)
+#define M_BCM1480_MC_ADDR_CLASS             _SB_MAKEMASK1(36)
+
+#define M_BCM1480_MC_DQ_ODT_75              _SB_MAKEMASK1(37)
+#define M_BCM1480_MC_DQ_ODT_150             _SB_MAKEMASK1(38)
+#define M_BCM1480_MC_DQS_ODT_75             _SB_MAKEMASK1(39)
+#define M_BCM1480_MC_DQS_ODT_150            _SB_MAKEMASK1(40)
+#define M_BCM1480_MC_DQS_DIFF               _SB_MAKEMASK1(41)
+
+/*
+ * ECC Test Data Register (Table 95)
+ */
+
+#define S_BCM1480_MC_DATA_INVERT            0
+#define M_DATA_ECC_INVERT           _SB_MAKEMASK(64,S_BCM1480_MC_ECC_INVERT)
+
+/*
+ * ECC Test ECC Register (Table 96)
+ */
+
+#define S_BCM1480_MC_ECC_INVERT             0
+#define M_BCM1480_MC_ECC_INVERT             _SB_MAKEMASK(8,S_BCM1480_MC_ECC_INVERT)
+
+/*
+ * SDRAM Timing Register  (Table 97)
+ */
+
+#define S_BCM1480_MC_tRCD                   0
+#define M_BCM1480_MC_tRCD                   _SB_MAKEMASK(4,S_BCM1480_MC_tRCD)
+#define V_BCM1480_MC_tRCD(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRCD)
+#define G_BCM1480_MC_tRCD(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRCD,M_BCM1480_MC_tRCD)
+#define K_BCM1480_MC_tRCD_DEFAULT           3
+#define V_BCM1480_MC_tRCD_DEFAULT           V_BCM1480_MC_tRCD(K_BCM1480_MC_tRCD_DEFAULT)
+
+#define S_BCM1480_MC_tCL                    4
+#define M_BCM1480_MC_tCL                    _SB_MAKEMASK(4,S_BCM1480_MC_tCL)
+#define V_BCM1480_MC_tCL(x)                 _SB_MAKEVALUE(x,S_BCM1480_MC_tCL)
+#define G_BCM1480_MC_tCL(x)                 _SB_GETVALUE(x,S_BCM1480_MC_tCL,M_BCM1480_MC_tCL)
+#define K_BCM1480_MC_tCL_DEFAULT            2
+#define V_BCM1480_MC_tCL_DEFAULT            V_BCM1480_MC_tCL(K_BCM1480_MC_tCL_DEFAULT)
+
+#define M_BCM1480_MC_tCrDh                  _SB_MAKEMASK1(8)
+
+#define S_BCM1480_MC_tWR                    9
+#define M_BCM1480_MC_tWR                    _SB_MAKEMASK(3,S_BCM1480_MC_tWR)
+#define V_BCM1480_MC_tWR(x)                 _SB_MAKEVALUE(x,S_BCM1480_MC_tWR)
+#define G_BCM1480_MC_tWR(x)                 _SB_GETVALUE(x,S_BCM1480_MC_tWR,M_BCM1480_MC_tWR)
+#define K_BCM1480_MC_tWR_DEFAULT            2
+#define V_BCM1480_MC_tWR_DEFAULT            V_BCM1480_MC_tWR(K_BCM1480_MC_tWR_DEFAULT)
+
+#define S_BCM1480_MC_tCwD                   12
+#define M_BCM1480_MC_tCwD                   _SB_MAKEMASK(4,S_BCM1480_MC_tCwD)
+#define V_BCM1480_MC_tCwD(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tCwD)
+#define G_BCM1480_MC_tCwD(x)                _SB_GETVALUE(x,S_BCM1480_MC_tCwD,M_BCM1480_MC_tCwD)
+#define K_BCM1480_MC_tCwD_DEFAULT           1
+#define V_BCM1480_MC_tCwD_DEFAULT           V_BCM1480_MC_tCwD(K_BCM1480_MC_tCwD_DEFAULT)
+
+#define S_BCM1480_MC_tRP                    16
+#define M_BCM1480_MC_tRP                    _SB_MAKEMASK(4,S_BCM1480_MC_tRP)
+#define V_BCM1480_MC_tRP(x)                 _SB_MAKEVALUE(x,S_BCM1480_MC_tRP)
+#define G_BCM1480_MC_tRP(x)                 _SB_GETVALUE(x,S_BCM1480_MC_tRP,M_BCM1480_MC_tRP)
+#define K_BCM1480_MC_tRP_DEFAULT            4
+#define V_BCM1480_MC_tRP_DEFAULT            V_BCM1480_MC_tRP(K_BCM1480_MC_tRP_DEFAULT)
+
+#define S_BCM1480_MC_tRRD                   20
+#define M_BCM1480_MC_tRRD                   _SB_MAKEMASK(4,S_BCM1480_MC_tRRD)
+#define V_BCM1480_MC_tRRD(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRRD)
+#define G_BCM1480_MC_tRRD(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRRD,M_BCM1480_MC_tRRD)
+#define K_BCM1480_MC_tRRD_DEFAULT           2
+#define V_BCM1480_MC_tRRD_DEFAULT           V_BCM1480_MC_tRRD(K_BCM1480_MC_tRRD_DEFAULT)
+
+#define S_BCM1480_MC_tRCw                   24
+#define M_BCM1480_MC_tRCw                   _SB_MAKEMASK(5,S_BCM1480_MC_tRCw)
+#define V_BCM1480_MC_tRCw(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRCw)
+#define G_BCM1480_MC_tRCw(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRCw,M_BCM1480_MC_tRCw)
+#define K_BCM1480_MC_tRCw_DEFAULT           10
+#define V_BCM1480_MC_tRCw_DEFAULT           V_BCM1480_MC_tRCw(K_BCM1480_MC_tRCw_DEFAULT)
+
+#define S_BCM1480_MC_tRCr                   32
+#define M_BCM1480_MC_tRCr                   _SB_MAKEMASK(5,S_BCM1480_MC_tRCr)
+#define V_BCM1480_MC_tRCr(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRCr)
+#define G_BCM1480_MC_tRCr(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRCr,M_BCM1480_MC_tRCr)
+#define K_BCM1480_MC_tRCr_DEFAULT           9
+#define V_BCM1480_MC_tRCr_DEFAULT           V_BCM1480_MC_tRCr(K_BCM1480_MC_tRCr_DEFAULT)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define S_BCM1480_MC_tFAW                   40
+#define M_BCM1480_MC_tFAW                   _SB_MAKEMASK(6,S_BCM1480_MC_tFAW)
+#define V_BCM1480_MC_tFAW(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tFAW)
+#define G_BCM1480_MC_tFAW(x)                _SB_GETVALUE(x,S_BCM1480_MC_tFAW,M_BCM1480_MC_tFAW)
+#define K_BCM1480_MC_tFAW_DEFAULT           0
+#define V_BCM1480_MC_tFAW_DEFAULT           V_BCM1480_MC_tFAW(K_BCM1480_MC_tFAW_DEFAULT)
+#endif
+
+#define S_BCM1480_MC_tRFC                   48
+#define M_BCM1480_MC_tRFC                   _SB_MAKEMASK(7,S_BCM1480_MC_tRFC)
+#define V_BCM1480_MC_tRFC(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRFC)
+#define G_BCM1480_MC_tRFC(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRFC,M_BCM1480_MC_tRFC)
+#define K_BCM1480_MC_tRFC_DEFAULT           12
+#define V_BCM1480_MC_tRFC_DEFAULT           V_BCM1480_MC_tRFC(K_BCM1480_MC_tRFC_DEFAULT)
+
+#define S_BCM1480_MC_tFIFO                  56
+#define M_BCM1480_MC_tFIFO                  _SB_MAKEMASK(2,S_BCM1480_MC_tFIFO)
+#define V_BCM1480_MC_tFIFO(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_tFIFO)
+#define G_BCM1480_MC_tFIFO(x)               _SB_GETVALUE(x,S_BCM1480_MC_tFIFO,M_BCM1480_MC_tFIFO)
+#define K_BCM1480_MC_tFIFO_DEFAULT          0
+#define V_BCM1480_MC_tFIFO_DEFAULT          V_BCM1480_MC_tFIFO(K_BCM1480_MC_tFIFO_DEFAULT)
+
+#define S_BCM1480_MC_tW2R                  58
+#define M_BCM1480_MC_tW2R                  _SB_MAKEMASK(2,S_BCM1480_MC_tW2R)
+#define V_BCM1480_MC_tW2R(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_tW2R)
+#define G_BCM1480_MC_tW2R(x)               _SB_GETVALUE(x,S_BCM1480_MC_tW2R,M_BCM1480_MC_tW2R)
+#define K_BCM1480_MC_tW2R_DEFAULT          1
+#define V_BCM1480_MC_tW2R_DEFAULT          V_BCM1480_MC_tW2R(K_BCM1480_MC_tW2R_DEFAULT)
+
+#define S_BCM1480_MC_tR2W                  60
+#define M_BCM1480_MC_tR2W                  _SB_MAKEMASK(2,S_BCM1480_MC_tR2W)
+#define V_BCM1480_MC_tR2W(x)               _SB_MAKEVALUE(x,S_BCM1480_MC_tR2W)
+#define G_BCM1480_MC_tR2W(x)               _SB_GETVALUE(x,S_BCM1480_MC_tR2W,M_BCM1480_MC_tR2W)
+#define K_BCM1480_MC_tR2W_DEFAULT          0
+#define V_BCM1480_MC_tR2W_DEFAULT          V_BCM1480_MC_tR2W(K_BCM1480_MC_tR2W_DEFAULT)
+
+#define M_BCM1480_MC_tR2R		    _SB_MAKEMASK1(62)
+
+#define V_BCM1480_MC_TIMING_DEFAULT         (M_BCM1480_MC_tR2R | \
+                                     V_BCM1480_MC_tFIFO_DEFAULT | \
+                                     V_BCM1480_MC_tR2W_DEFAULT | \
+                                     V_BCM1480_MC_tW2R_DEFAULT | \
+                                     V_BCM1480_MC_tRFC_DEFAULT | \
+                                     V_BCM1480_MC_tRCr_DEFAULT | \
+                                     V_BCM1480_MC_tRCw_DEFAULT | \
+                                     V_BCM1480_MC_tRRD_DEFAULT | \
+                                     V_BCM1480_MC_tRP_DEFAULT | \
+                                     V_BCM1480_MC_tCwD_DEFAULT | \
+                                     V_BCM1480_MC_tWR_DEFAULT | \
+                                     M_BCM1480_MC_tCrDh | \
+                                     V_BCM1480_MC_tCL_DEFAULT | \
+                                     V_BCM1480_MC_tRCD_DEFAULT)
+
+/*
+ * SDRAM Timing Register 2
+ */
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+
+#define S_BCM1480_MC_tAL                   0
+#define M_BCM1480_MC_tAL                   _SB_MAKEMASK(4,S_BCM1480_MC_tAL)
+#define V_BCM1480_MC_tAL(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tAL)
+#define G_BCM1480_MC_tAL(x)                _SB_GETVALUE(x,S_BCM1480_MC_tAL,M_BCM1480_MC_tAL)
+#define K_BCM1480_MC_tAL_DEFAULT           0
+#define V_BCM1480_MC_tAL_DEFAULT           V_BCM1480_MC_tAL(K_BCM1480_MC_tAL_DEFAULT)
+
+#define S_BCM1480_MC_tRTP                   4
+#define M_BCM1480_MC_tRTP                   _SB_MAKEMASK(3,S_BCM1480_MC_tRTP)
+#define V_BCM1480_MC_tRTP(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRTP)
+#define G_BCM1480_MC_tRTP(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRTP,M_BCM1480_MC_tRTP)
+#define K_BCM1480_MC_tRTP_DEFAULT           2
+#define V_BCM1480_MC_tRTP_DEFAULT           V_BCM1480_MC_tRTP(K_BCM1480_MC_tRTP_DEFAULT)
+
+#define S_BCM1480_MC_tW2W                   8
+#define M_BCM1480_MC_tW2W                   _SB_MAKEMASK(2,S_BCM1480_MC_tW2W)
+#define V_BCM1480_MC_tW2W(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tW2W)
+#define G_BCM1480_MC_tW2W(x)                _SB_GETVALUE(x,S_BCM1480_MC_tW2W,M_BCM1480_MC_tW2W)
+#define K_BCM1480_MC_tW2W_DEFAULT           0
+#define V_BCM1480_MC_tW2W_DEFAULT           V_BCM1480_MC_tW2W(K_BCM1480_MC_tW2W_DEFAULT)
+
+#define S_BCM1480_MC_tRAP                   12
+#define M_BCM1480_MC_tRAP                  _SB_MAKEMASK(4,S_BCM1480_MC_tRAP)
+#define V_BCM1480_MC_tRAP(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_tRAP)
+#define G_BCM1480_MC_tRAP(x)                _SB_GETVALUE(x,S_BCM1480_MC_tRAP,M_BCM1480_MC_tRAP)
+#define K_BCM1480_MC_tRAP_DEFAULT           0
+#define V_BCM1480_MC_tRAP_DEFAULT           V_BCM1480_MC_tRAP(K_BCM1480_MC_tRAP_DEFAULT)
+
+#endif
+
+
+
+/*
+ * Global Registers: single instances per BCM1480
+ */
+
+/*
+ * Global Configuration Register (Table 99)
+ */
+
+#define S_BCM1480_MC_BLK_SET_MARK           8
+#define M_BCM1480_MC_BLK_SET_MARK           _SB_MAKEMASK(4,S_BCM1480_MC_BLK_SET_MARK)
+#define V_BCM1480_MC_BLK_SET_MARK(x)        _SB_MAKEVALUE(x,S_BCM1480_MC_BLK_SET_MARK)
+#define G_BCM1480_MC_BLK_SET_MARK(x)        _SB_GETVALUE(x,S_BCM1480_MC_BLK_SET_MARK,M_BCM1480_MC_BLK_SET_MARK)
+
+#define S_BCM1480_MC_BLK_CLR_MARK           12
+#define M_BCM1480_MC_BLK_CLR_MARK           _SB_MAKEMASK(4,S_BCM1480_MC_BLK_CLR_MARK)
+#define V_BCM1480_MC_BLK_CLR_MARK(x)        _SB_MAKEVALUE(x,S_BCM1480_MC_BLK_CLR_MARK)
+#define G_BCM1480_MC_BLK_CLR_MARK(x)        _SB_GETVALUE(x,S_BCM1480_MC_BLK_CLR_MARK,M_BCM1480_MC_BLK_CLR_MARK)
+
+#define M_BCM1480_MC_PKT_PRIORITY           _SB_MAKEMASK1(16)
+
+#define S_BCM1480_MC_MAX_AGE                20
+#define M_BCM1480_MC_MAX_AGE                _SB_MAKEMASK(4,S_BCM1480_MC_MAX_AGE)
+#define V_BCM1480_MC_MAX_AGE(x)             _SB_MAKEVALUE(x,S_BCM1480_MC_MAX_AGE)
+#define G_BCM1480_MC_MAX_AGE(x)             _SB_GETVALUE(x,S_BCM1480_MC_MAX_AGE,M_BCM1480_MC_MAX_AGE)
+
+#define M_BCM1480_MC_BERR_DISABLE           _SB_MAKEMASK1(29)
+#define M_BCM1480_MC_FORCE_SEQ              _SB_MAKEMASK1(30)
+#define M_BCM1480_MC_VGEN                   _SB_MAKEMASK1(32)
+
+#define S_BCM1480_MC_SLEW                   33
+#define M_BCM1480_MC_SLEW                   _SB_MAKEMASK(2,S_BCM1480_MC_SLEW)
+#define V_BCM1480_MC_SLEW(x)                _SB_MAKEVALUE(x,S_BCM1480_MC_SLEW)
+#define G_BCM1480_MC_SLEW(x)                _SB_GETVALUE(x,S_BCM1480_MC_SLEW,M_BCM1480_MC_SLEW)
+
+#define M_BCM1480_MC_SSTL_VOLTAGE           _SB_MAKEMASK1(35)
+
+/*
+ * Global Channel Interleave Register (Table 100)
+ */
+
+#define S_BCM1480_MC_INTLV0                 0
+#define M_BCM1480_MC_INTLV0                 _SB_MAKEMASK(6,S_BCM1480_MC_INTLV0)
+#define V_BCM1480_MC_INTLV0(x)              _SB_MAKEVALUE(x,S_BCM1480_MC_INTLV0)
+#define G_BCM1480_MC_INTLV0(x)              _SB_GETVALUE(x,S_BCM1480_MC_INTLV0,M_BCM1480_MC_INTLV0)
+
+#define S_BCM1480_MC_INTLV1                 8
+#define M_BCM1480_MC_INTLV1                 _SB_MAKEMASK(6,S_BCM1480_MC_INTLV1)
+#define V_BCM1480_MC_INTLV1(x)              _SB_MAKEVALUE(x,S_BCM1480_MC_INTLV1)
+#define G_BCM1480_MC_INTLV1(x)              _SB_GETVALUE(x,S_BCM1480_MC_INTLV1,M_BCM1480_MC_INTLV1)
+
+#define S_BCM1480_MC_INTLV_MODE             16
+#define M_BCM1480_MC_INTLV_MODE             _SB_MAKEMASK(3,S_BCM1480_MC_INTLV_MODE)
+#define V_BCM1480_MC_INTLV_MODE(x)          _SB_MAKEVALUE(x,S_BCM1480_MC_INTLV_MODE)
+#define G_BCM1480_MC_INTLV_MODE(x)          _SB_GETVALUE(x,S_BCM1480_MC_INTLV_MODE,M_BCM1480_MC_INTLV_MODE)
+
+#define K_BCM1480_MC_INTLV_MODE_NONE        0x0
+#define K_BCM1480_MC_INTLV_MODE_01          0x1
+#define K_BCM1480_MC_INTLV_MODE_23          0x2
+#define K_BCM1480_MC_INTLV_MODE_01_23       0x3
+#define K_BCM1480_MC_INTLV_MODE_0123        0x4
+
+#define V_BCM1480_MC_INTLV_MODE_NONE        V_BCM1480_MC_INTLV_MODE(K_BCM1480_MC_INTLV_MODE_NONE)
+#define V_BCM1480_MC_INTLV_MODE_01          V_BCM1480_MC_INTLV_MODE(K_BCM1480_MC_INTLV_MODE_01)
+#define V_BCM1480_MC_INTLV_MODE_23          V_BCM1480_MC_INTLV_MODE(K_BCM1480_MC_INTLV_MODE_23)
+#define V_BCM1480_MC_INTLV_MODE_01_23       V_BCM1480_MC_INTLV_MODE(K_BCM1480_MC_INTLV_MODE_01_23)
+#define V_BCM1480_MC_INTLV_MODE_0123        V_BCM1480_MC_INTLV_MODE(K_BCM1480_MC_INTLV_MODE_0123)
+
+/*
+ * ECC Status Register
+ */
+
+#define S_BCM1480_MC_ECC_ERR_ADDR           0
+#define M_BCM1480_MC_ECC_ERR_ADDR           _SB_MAKEMASK(37,S_BCM1480_MC_ECC_ERR_ADDR)
+#define V_BCM1480_MC_ECC_ERR_ADDR(x)        _SB_MAKEVALUE(x,S_BCM1480_MC_ECC_ERR_ADDR)
+#define G_BCM1480_MC_ECC_ERR_ADDR(x)        _SB_GETVALUE(x,S_BCM1480_MC_ECC_ERR_ADDR,M_BCM1480_MC_ECC_ERR_ADDR)
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define M_BCM1480_MC_ECC_ERR_RMW            _SB_MAKEMASK1(60)
+#endif
+
+#define M_BCM1480_MC_ECC_MULT_ERR_DET       _SB_MAKEMASK1(61)
+#define M_BCM1480_MC_ECC_UERR_DET           _SB_MAKEMASK1(62)
+#define M_BCM1480_MC_ECC_CERR_DET           _SB_MAKEMASK1(63)
+
+/*
+ * Global ECC Address Register (Table 102)
+ */
+
+#define S_BCM1480_MC_ECC_CORR_ADDR          0
+#define M_BCM1480_MC_ECC_CORR_ADDR          _SB_MAKEMASK(37,S_BCM1480_MC_ECC_CORR_ADDR)
+#define V_BCM1480_MC_ECC_CORR_ADDR(x)       _SB_MAKEVALUE(x,S_BCM1480_MC_ECC_CORR_ADDR)
+#define G_BCM1480_MC_ECC_CORR_ADDR(x)       _SB_GETVALUE(x,S_BCM1480_MC_ECC_CORR_ADDR,M_BCM1480_MC_ECC_CORR_ADDR)
+
+/*
+ * Global ECC Correction Register (Table 103)
+ */
+
+#define S_BCM1480_MC_ECC_CORRECT            0
+#define M_BCM1480_MC_ECC_CORRECT            _SB_MAKEMASK(64,S_BCM1480_MC_ECC_CORRECT)
+#define V_BCM1480_MC_ECC_CORRECT(x)         _SB_MAKEVALUE(x,S_BCM1480_MC_ECC_CORRECT)
+#define G_BCM1480_MC_ECC_CORRECT(x)         _SB_GETVALUE(x,S_BCM1480_MC_ECC_CORRECT,M_BCM1480_MC_ECC_CORRECT)
+
+/*
+ * Global ECC Performance Counters Control Register (Table 104)
+ */
+
+#define S_BCM1480_MC_CHANNEL_SELECT         0
+#define M_BCM1480_MC_CHANNEL_SELECT         _SB_MAKEMASK(4,S_BCM1480_MC_CHANNEL_SELECT)
+#define V_BCM1480_MC_CHANNEL_SELECT(x)      _SB_MAKEVALUE(x,S_BCM1480_MC_CHANNEL_SELECT)
+#define G_BCM1480_MC_CHANNEL_SELECT(x)      _SB_GETVALUE(x,S_BCM1480_MC_CHANNEL_SELECT,M_BCM1480_MC_CHANNEL_SELECT)
+#define K_BCM1480_MC_CHANNEL_SELECT_0       0x1
+#define K_BCM1480_MC_CHANNEL_SELECT_1       0x2
+#define K_BCM1480_MC_CHANNEL_SELECT_2       0x4
+#define K_BCM1480_MC_CHANNEL_SELECT_3       0x8
+
+#endif /* _BCM1480_MC_H */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/bcm1480_regs.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_regs.h
--- linux-2.6.14/include/asm-mips/sibyte/bcm1480_regs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_regs.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,869 @@
+/*  *********************************************************************
+    *  BCM1255/BCM1280/BCM1455/BCM1480 Board Support Package
+    *
+    *  Register Definitions                     File: bcm1480_regs.h
+    *
+    *  This module contains the addresses of the on-chip peripherals
+    *  on the BCM1280 and BCM1480.
+    *
+    *  BCM1480 specification level:  1X55_1X80-UM100-D4 (11/24/03)
+    *
+    *********************************************************************
+    *
+    *  Copyright 2000,2001,2002,2003
+    *  Broadcom Corporation. All rights reserved.
+    *
+    *  This program is free software; you can redistribute it and/or
+    *  modify it under the terms of the GNU General Public License as
+    *  published by the Free Software Foundation; either version 2 of
+    *  the License, or (at your option) any later version.
+    *
+    *  This program is distributed in the hope that it will be useful,
+    *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+    *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    *  GNU General Public License for more details.
+    *
+    *  You should have received a copy of the GNU General Public License
+    *  along with this program; if not, write to the Free Software
+    *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+    *  MA 02111-1307 USA
+    ********************************************************************* */
+
+#ifndef _BCM1480_REGS_H
+#define _BCM1480_REGS_H
+
+#include "sb1250_defs.h"
+
+/*  *********************************************************************
+    *  Pull in the BCM1250's registers since a great deal of the 1480's
+    *  functions are the same as the BCM1250.
+    ********************************************************************* */
+
+#include "sb1250_regs.h"
+
+
+/*  *********************************************************************
+    *  Some general notes:
+    *
+    *  Register addresses are grouped by function and follow the order
+    *  of the User Manual.
+    *
+    *  For the most part, when there is more than one peripheral
+    *  of the same type on the SOC, the constants below will be
+    *  offsets from the base of each peripheral.  For example,
+    *  the MAC registers are described as offsets from the first
+    *  MAC register, and there will be a MAC_REGISTER() macro
+    *  to calculate the base address of a given MAC.
+    *
+    *  The information in this file is based on the BCM1X55/BCM1X80
+    *  User Manual, Document 1X55_1X80-UM100-R, 22/12/03.
+    *
+    *  This file is basically a "what's new" header file.  Since the
+    *  BCM1250 and the new BCM1480 (and derivatives) share many common
+    *  features, this file contains only what's new or changed from
+    *  the 1250.  (above, you can see that we include the 1250 symbols
+    *  to get the base functionality).
+    *
+    *  In software, be sure to use the correct symbols, particularly
+    *  for blocks that are different between the two chip families.
+    *  All BCM1480-specific symbols have _BCM1480_ in their names,
+    *  and all BCM1250-specific and "base" functions that are common in
+    *  both chips have no special names (this is for compatibility with
+    *  older include files).  Therefore, if you're working with the
+    *  SCD, which is very different on each chip, A_SCD_xxx implies
+    *  the BCM1250 version and A_BCM1480_SCD_xxx implies the BCM1480
+    *  version.
+    ********************************************************************* */
+
+
+/*  *********************************************************************
+    * Memory Controller Registers (Section 6)
+    ********************************************************************* */
+
+#define A_BCM1480_MC_BASE_0                 0x0010050000
+#define A_BCM1480_MC_BASE_1                 0x0010051000
+#define A_BCM1480_MC_BASE_2                 0x0010052000
+#define A_BCM1480_MC_BASE_3                 0x0010053000
+#define BCM1480_MC_REGISTER_SPACING         0x1000
+
+#define A_BCM1480_MC_BASE(ctlid)            (A_BCM1480_MC_BASE_0+(ctlid)*BCM1480_MC_REGISTER_SPACING)
+#define A_BCM1480_MC_REGISTER(ctlid,reg)    (A_BCM1480_MC_BASE(ctlid)+(reg))
+
+#define R_BCM1480_MC_CONFIG                 0x0000000100
+#define R_BCM1480_MC_CS_START               0x0000000120
+#define R_BCM1480_MC_CS_END                 0x0000000140
+#define S_BCM1480_MC_CS_STARTEND            24
+
+#define R_BCM1480_MC_CS01_ROW0              0x0000000180
+#define R_BCM1480_MC_CS01_ROW1              0x00000001A0
+#define R_BCM1480_MC_CS23_ROW0              0x0000000200
+#define R_BCM1480_MC_CS23_ROW1              0x0000000220
+#define R_BCM1480_MC_CS01_COL0              0x0000000280
+#define R_BCM1480_MC_CS01_COL1              0x00000002A0
+#define R_BCM1480_MC_CS23_COL0              0x0000000300
+#define R_BCM1480_MC_CS23_COL1              0x0000000320
+
+#define R_BCM1480_MC_CSX_BASE               0x0000000180
+#define R_BCM1480_MC_CSX_ROW0               0x0000000000   /* relative to CSX_BASE */
+#define R_BCM1480_MC_CSX_ROW1               0x0000000020   /* relative to CSX_BASE */
+#define R_BCM1480_MC_CSX_COL0               0x0000000100   /* relative to CSX_BASE */
+#define R_BCM1480_MC_CSX_COL1               0x0000000120   /* relative to CSX_BASE */
+#define BCM1480_MC_CSX_SPACING              0x0000000080   /* CS23 relative to CS01 */
+
+#define R_BCM1480_MC_CS01_BA                0x0000000380
+#define R_BCM1480_MC_CS23_BA                0x00000003A0
+#define R_BCM1480_MC_DRAMCMD                0x0000000400
+#define R_BCM1480_MC_DRAMMODE               0x0000000420
+#define R_BCM1480_MC_CLOCK_CFG              0x0000000440
+#define R_BCM1480_MC_MCLK_CFG               R_BCM1480_MC_CLOCK_CFG
+#define R_BCM1480_MC_TEST_DATA              0x0000000480
+#define R_BCM1480_MC_TEST_ECC               0x00000004A0
+#define R_BCM1480_MC_TIMING1                0x00000004C0
+#define R_BCM1480_MC_TIMING2                0x00000004E0
+#define R_BCM1480_MC_DLL_CFG                0x0000000500
+#define R_BCM1480_MC_DRIVE_CFG              0x0000000520
+
+#if SIBYTE_HDR_FEATURE(1480, PASS2)
+#define R_BCM1480_MC_ODT		    0x0000000460
+#define R_BCM1480_MC_ECC_STATUS		    0x0000000540
+#endif
+
+/* Global registers (single instance) */
+#define A_BCM1480_MC_GLB_CONFIG             0x0010054100
+#define A_BCM1480_MC_GLB_INTLV              0x0010054120
+#define A_BCM1480_MC_GLB_ECC_STATUS         0x0010054140
+#define A_BCM1480_MC_GLB_ECC_ADDR           0x0010054160
+#define A_BCM1480_MC_GLB_ECC_CORRECT        0x0010054180
+#define A_BCM1480_MC_GLB_PERF_CNT_CONTROL   0x00100541A0
+
+/*  *********************************************************************
+    * L2 Cache Control Registers (Section 5)
+    ********************************************************************* */
+
+#define A_BCM1480_L2_BASE                   0x0010040000
+
+#define A_BCM1480_L2_READ_TAG               0x0010040018
+#define A_BCM1480_L2_ECC_TAG                0x0010040038
+#define A_BCM1480_L2_MISC0_VALUE            0x0010040058
+#define A_BCM1480_L2_MISC1_VALUE            0x0010040078
+#define A_BCM1480_L2_MISC2_VALUE            0x0010040098
+#define A_BCM1480_L2_MISC_CONFIG            0x0010040040	/* x040 */
+#define A_BCM1480_L2_CACHE_DISABLE          0x0010040060	/* x060 */
+#define A_BCM1480_L2_MAKECACHEDISABLE(x)    (A_BCM1480_L2_CACHE_DISABLE | (((x)&0xF) << 12))
+#define A_BCM1480_L2_WAY_ENABLE_3_0         0x0010040080	/* x080 */
+#define A_BCM1480_L2_WAY_ENABLE_7_4         0x00100400A0	/* x0A0 */
+#define A_BCM1480_L2_MAKE_WAY_ENABLE_LO(x)  (A_BCM1480_L2_WAY_ENABLE_3_0 | (((x)&0xF) << 12))
+#define A_BCM1480_L2_MAKE_WAY_ENABLE_HI(x)  (A_BCM1480_L2_WAY_ENABLE_7_4 | (((x)&0xF) << 12))
+#define A_BCM1480_L2_MAKE_WAY_DISABLE_LO(x)  (A_BCM1480_L2_WAY_ENABLE_3_0 | (((~x)&0xF) << 12))
+#define A_BCM1480_L2_MAKE_WAY_DISABLE_HI(x)  (A_BCM1480_L2_WAY_ENABLE_7_4 | (((~x)&0xF) << 12))
+#define A_BCM1480_L2_WAY_LOCAL_3_0          0x0010040100	/* x100 */
+#define A_BCM1480_L2_WAY_LOCAL_7_4          0x0010040120	/* x120 */
+#define A_BCM1480_L2_WAY_REMOTE_3_0         0x0010040140	/* x140 */
+#define A_BCM1480_L2_WAY_REMOTE_7_4         0x0010040160	/* x160 */
+#define A_BCM1480_L2_WAY_AGENT_3_0          0x00100400C0	/* xxC0 */
+#define A_BCM1480_L2_WAY_AGENT_7_4          0x00100400E0	/* xxE0 */
+#define A_BCM1480_L2_WAY_ENABLE(A, banks)   (A | (((~(banks))&0x0F) << 8))
+#define A_BCM1480_L2_BANK_BASE              0x00D0300000
+#define A_BCM1480_L2_BANK_ADDRESS(b)        (A_BCM1480_L2_BANK_BASE | (((b)&0x7)<<17))
+#define A_BCM1480_L2_MGMT_TAG_BASE          0x00D0000000
+
+
+/*  *********************************************************************
+    * PCI-X Interface Registers (Section 7)
+    ********************************************************************* */
+
+#define A_BCM1480_PCI_BASE                  0x0010061400
+
+#define A_BCM1480_PCI_RESET                 0x0010061400
+#define A_BCM1480_PCI_DLL                   0x0010061500
+
+#define A_BCM1480_PCI_TYPE00_HEADER         0x002E000000
+
+/*  *********************************************************************
+    * Ethernet MAC Registers (Section 11) and DMA Registers (Section 10.6)
+    ********************************************************************* */
+
+/* No register changes with Rev.C BCM1250, but one additional MAC */
+
+#define A_BCM1480_MAC_BASE_2        0x0010066000
+
+#ifndef A_MAC_BASE_2
+#define A_MAC_BASE_2                A_BCM1480_MAC_BASE_2
+#endif
+
+#define A_BCM1480_MAC_BASE_3        0x0010067000
+#define A_MAC_BASE_3                A_BCM1480_MAC_BASE_3
+
+#define R_BCM1480_MAC_DMA_OODPKTLOST        0x00000038
+
+#ifndef R_MAC_DMA_OODPKTLOST
+#define R_MAC_DMA_OODPKTLOST        R_BCM1480_MAC_DMA_OODPKTLOST
+#endif
+
+
+/*  *********************************************************************
+    * DUART Registers (Section 14)
+    ********************************************************************* */
+
+/* No significant differences from BCM1250, two DUARTs */
+
+/*  Conventions, per user manual:
+ *     DUART    generic, channels A,B,C,D
+ *     DUART0   implementing channels A,B
+ *     DUART1   inplementing channels C,D
+ */
+
+#define BCM1480_DUART_NUM_PORTS           4
+
+#define A_BCM1480_DUART0                    0x0010060000
+#define A_BCM1480_DUART1                    0x0010060400
+#define A_BCM1480_DUART(chan)               ((((chan)&2) == 0)? A_BCM1480_DUART0 : A_BCM1480_DUART1)
+
+#define BCM1480_DUART_CHANREG_SPACING       0x100
+#define A_BCM1480_DUART_CHANREG(chan,reg)   (A_BCM1480_DUART(chan) \
+                                     + BCM1480_DUART_CHANREG_SPACING*((chan)&1) \
+                                     + (reg))
+#define R_BCM1480_DUART_CHANREG(chan,reg)   (BCM1480_DUART_CHANREG_SPACING*((chan)&1) + (reg))
+
+#define R_BCM1480_DUART_IMRREG(chan)	    (R_DUART_IMR_A + ((chan)&1)*DUART_IMRISR_SPACING)
+#define R_BCM1480_DUART_ISRREG(chan)	    (R_DUART_ISR_A + ((chan)&1)*DUART_IMRISR_SPACING)
+
+#define A_BCM1480_DUART_IMRREG(chan)	    (A_BCM1480_DUART(chan) + R_BCM1480_DUART_IMRREG(chan))
+#define A_BCM1480_DUART_ISRREG(chan)	    (A_BCM1480_DUART(chan) + R_BCM1480_DUART_ISRREG(chan))
+
+/*
+ * These constants are the absolute addresses.
+ */
+
+#define A_BCM1480_DUART_MODE_REG_1_C        0x0010060400
+#define A_BCM1480_DUART_MODE_REG_2_C        0x0010060410
+#define A_BCM1480_DUART_STATUS_C            0x0010060420
+#define A_BCM1480_DUART_CLK_SEL_C           0x0010060430
+#define A_BCM1480_DUART_FULL_CTL_C          0x0010060440
+#define A_BCM1480_DUART_CMD_C               0x0010060450
+#define A_BCM1480_DUART_RX_HOLD_C           0x0010060460
+#define A_BCM1480_DUART_TX_HOLD_C           0x0010060470
+#define A_BCM1480_DUART_OPCR_C              0x0010060480
+#define A_BCM1480_DUART_AUX_CTRL_C          0x0010060490
+
+#define A_BCM1480_DUART_MODE_REG_1_D        0x0010060500
+#define A_BCM1480_DUART_MODE_REG_2_D        0x0010060510
+#define A_BCM1480_DUART_STATUS_D            0x0010060520
+#define A_BCM1480_DUART_CLK_SEL_D           0x0010060530
+#define A_BCM1480_DUART_FULL_CTL_D          0x0010060540
+#define A_BCM1480_DUART_CMD_D               0x0010060550
+#define A_BCM1480_DUART_RX_HOLD_D           0x0010060560
+#define A_BCM1480_DUART_TX_HOLD_D           0x0010060570
+#define A_BCM1480_DUART_OPCR_D              0x0010060580
+#define A_BCM1480_DUART_AUX_CTRL_D          0x0010060590
+
+#define A_BCM1480_DUART_INPORT_CHNG_CD      0x0010060600
+#define A_BCM1480_DUART_AUX_CTRL_CD         0x0010060610
+#define A_BCM1480_DUART_ISR_C               0x0010060620
+#define A_BCM1480_DUART_IMR_C               0x0010060630
+#define A_BCM1480_DUART_ISR_D               0x0010060640
+#define A_BCM1480_DUART_IMR_D               0x0010060650
+#define A_BCM1480_DUART_OUT_PORT_CD         0x0010060660
+#define A_BCM1480_DUART_OPCR_CD             0x0010060670
+#define A_BCM1480_DUART_IN_PORT_CD          0x0010060680
+#define A_BCM1480_DUART_ISR_CD              0x0010060690
+#define A_BCM1480_DUART_IMR_CD              0x00100606A0
+#define A_BCM1480_DUART_SET_OPR_CD          0x00100606B0
+#define A_BCM1480_DUART_CLEAR_OPR_CD        0x00100606C0
+#define A_BCM1480_DUART_INPORT_CHNG_C       0x00100606D0
+#define A_BCM1480_DUART_INPORT_CHNG_D       0x00100606E0
+
+
+/*  *********************************************************************
+    * Generic Bus Registers (Section 15) and PCMCIA Registers (Section 16)
+    ********************************************************************* */
+
+#define A_BCM1480_IO_PCMCIA_CFG_B	0x0010061A58
+#define A_BCM1480_IO_PCMCIA_STATUS_B	0x0010061A68
+
+/*  *********************************************************************
+    * GPIO Registers (Section 17)
+    ********************************************************************* */
+
+/* One additional GPIO register, placed _before_ the BCM1250's GPIO block base */
+
+#define A_BCM1480_GPIO_INT_ADD_TYPE         0x0010061A78
+#define R_BCM1480_GPIO_INT_ADD_TYPE         (-8)
+
+#define A_GPIO_INT_ADD_TYPE	A_BCM1480_GPIO_INT_ADD_TYPE
+#define R_GPIO_INT_ADD_TYPE	R_BCM1480_GPIO_INT_ADD_TYPE
+
+/*  *********************************************************************
+    * SMBus Registers (Section 18)
+    ********************************************************************* */
+
+/* No changes from BCM1250 */
+
+/*  *********************************************************************
+    * Timer Registers (Sections 4.6)
+    ********************************************************************* */
+
+/* BCM1480 has two additional watchdogs */
+
+/* Watchdog timers */
+
+#define A_BCM1480_SCD_WDOG_2                0x0010022050
+#define A_BCM1480_SCD_WDOG_3                0x0010022150
+
+#define BCM1480_SCD_NUM_WDOGS               4
+
+#define A_BCM1480_SCD_WDOG_BASE(w)       (A_BCM1480_SCD_WDOG_0+((w)&2)*0x1000 + ((w)&1)*0x100)
+#define A_BCM1480_SCD_WDOG_REGISTER(w,r) (A_BCM1480_SCD_WDOG_BASE(w) + (r))
+
+#define A_BCM1480_SCD_WDOG_INIT_2       0x0010022050
+#define A_BCM1480_SCD_WDOG_CNT_2        0x0010022058
+#define A_BCM1480_SCD_WDOG_CFG_2        0x0010022060
+
+#define A_BCM1480_SCD_WDOG_INIT_3       0x0010022150
+#define A_BCM1480_SCD_WDOG_CNT_3        0x0010022158
+#define A_BCM1480_SCD_WDOG_CFG_3        0x0010022160
+
+/* BCM1480 has two additional compare registers */
+
+#define A_BCM1480_SCD_ZBBUS_CYCLE_COUNT		A_SCD_ZBBUS_CYCLE_COUNT
+#define A_BCM1480_SCD_ZBBUS_CYCLE_CP_BASE       0x0010020C00
+#define A_BCM1480_SCD_ZBBUS_CYCLE_CP0           A_SCD_ZBBUS_CYCLE_CP0
+#define A_BCM1480_SCD_ZBBUS_CYCLE_CP1           A_SCD_ZBBUS_CYCLE_CP1
+#define A_BCM1480_SCD_ZBBUS_CYCLE_CP2           0x0010020C10
+#define A_BCM1480_SCD_ZBBUS_CYCLE_CP3           0x0010020C18
+
+/*  *********************************************************************
+    * System Control Registers (Section 4.2)
+    ********************************************************************* */
+
+/* Scratch register in different place */
+
+#define A_BCM1480_SCD_SCRATCH	 	0x100200A0
+
+/*  *********************************************************************
+    * System Address Trap Registers (Section 4.9)
+    ********************************************************************* */
+
+/* No changes from BCM1250 */
+
+/*  *********************************************************************
+    * System Interrupt Mapper Registers (Sections 4.3-4.5)
+    ********************************************************************* */
+
+#define A_BCM1480_IMR_CPU0_BASE             0x0010020000
+#define A_BCM1480_IMR_CPU1_BASE             0x0010022000
+#define A_BCM1480_IMR_CPU2_BASE             0x0010024000
+#define A_BCM1480_IMR_CPU3_BASE             0x0010026000
+#define BCM1480_IMR_REGISTER_SPACING        0x2000
+#define BCM1480_IMR_REGISTER_SPACING_SHIFT  13
+
+#define A_BCM1480_IMR_MAPPER(cpu)       (A_BCM1480_IMR_CPU0_BASE+(cpu)*BCM1480_IMR_REGISTER_SPACING)
+#define A_BCM1480_IMR_REGISTER(cpu,reg) (A_BCM1480_IMR_MAPPER(cpu)+(reg))
+
+/* Most IMR registers are 128 bits, implemented as non-contiguous
+   64-bit registers high (_H) and low (_L) */
+#define BCM1480_IMR_HL_SPACING                  0x1000
+
+#define R_BCM1480_IMR_INTERRUPT_DIAG_H          0x0010
+#define R_BCM1480_IMR_LDT_INTERRUPT_H           0x0018
+#define R_BCM1480_IMR_LDT_INTERRUPT_CLR_H       0x0020
+#define R_BCM1480_IMR_INTERRUPT_MASK_H          0x0028
+#define R_BCM1480_IMR_INTERRUPT_TRACE_H         0x0038
+#define R_BCM1480_IMR_INTERRUPT_SOURCE_STATUS_H 0x0040
+#define R_BCM1480_IMR_LDT_INTERRUPT_SET         0x0048
+#define R_BCM1480_IMR_MAILBOX_0_CPU             0x00C0
+#define R_BCM1480_IMR_MAILBOX_0_SET_CPU         0x00C8
+#define R_BCM1480_IMR_MAILBOX_0_CLR_CPU         0x00D0
+#define R_BCM1480_IMR_MAILBOX_1_CPU             0x00E0
+#define R_BCM1480_IMR_MAILBOX_1_SET_CPU         0x00E8
+#define R_BCM1480_IMR_MAILBOX_1_CLR_CPU         0x00F0
+#define R_BCM1480_IMR_INTERRUPT_STATUS_BASE_H   0x0100
+#define BCM1480_IMR_INTERRUPT_STATUS_COUNT      8
+#define R_BCM1480_IMR_INTERRUPT_MAP_BASE_H      0x0200
+#define BCM1480_IMR_INTERRUPT_MAP_COUNT         64
+
+#define R_BCM1480_IMR_INTERRUPT_DIAG_L          0x1010
+#define R_BCM1480_IMR_LDT_INTERRUPT_L           0x1018
+#define R_BCM1480_IMR_LDT_INTERRUPT_CLR_L       0x1020
+#define R_BCM1480_IMR_INTERRUPT_MASK_L          0x1028
+#define R_BCM1480_IMR_INTERRUPT_TRACE_L         0x1038
+#define R_BCM1480_IMR_INTERRUPT_SOURCE_STATUS_L 0x1040
+#define R_BCM1480_IMR_INTERRUPT_STATUS_BASE_L   0x1100
+#define R_BCM1480_IMR_INTERRUPT_MAP_BASE_L      0x1200
+
+#define A_BCM1480_IMR_ALIAS_MAILBOX_CPU0_BASE   0x0010028000
+#define A_BCM1480_IMR_ALIAS_MAILBOX_CPU1_BASE   0x0010028100
+#define A_BCM1480_IMR_ALIAS_MAILBOX_CPU2_BASE   0x0010028200
+#define A_BCM1480_IMR_ALIAS_MAILBOX_CPU3_BASE   0x0010028300
+#define BCM1480_IMR_ALIAS_MAILBOX_SPACING       0100
+
+#define A_BCM1480_IMR_ALIAS_MAILBOX(cpu)     (A_BCM1480_IMR_ALIAS_MAILBOX_CPU0_BASE + \
+                                        (cpu)*BCM1480_IMR_ALIAS_MAILBOX_SPACING)
+#define A_BCM1480_IMR_ALIAS_MAILBOX_REGISTER(cpu,reg) (A_BCM1480_IMR_ALIAS_MAILBOX(cpu)+(reg))
+
+#define R_BCM1480_IMR_ALIAS_MAILBOX_0           0x0000		/* 0x0x0 */
+#define R_BCM1480_IMR_ALIAS_MAILBOX_0_SET       0x0008		/* 0x0x8 */
+
+/*  *********************************************************************
+    * System Performance Counter Registers (Section 4.7)
+    ********************************************************************* */
+
+/* BCM1480 has four more performance counter registers, and two control
+   registers. */
+
+#define A_BCM1480_SCD_PERF_CNT_BASE         0x00100204C0
+
+#define A_BCM1480_SCD_PERF_CNT_CFG0         0x00100204C0
+#define A_BCM1480_SCD_PERF_CNT_CFG_0        A_BCM1480_SCD_PERF_CNT_CFG0
+#define A_BCM1480_SCD_PERF_CNT_CFG1         0x00100204C8
+#define A_BCM1480_SCD_PERF_CNT_CFG_1        A_BCM1480_SCD_PERF_CNT_CFG1
+
+#define A_BCM1480_SCD_PERF_CNT_0            A_SCD_PERF_CNT_0
+#define A_BCM1480_SCD_PERF_CNT_1            A_SCD_PERF_CNT_1
+#define A_BCM1480_SCD_PERF_CNT_2            A_SCD_PERF_CNT_2
+#define A_BCM1480_SCD_PERF_CNT_3            A_SCD_PERF_CNT_3
+
+#define A_BCM1480_SCD_PERF_CNT_4            0x00100204F0
+#define A_BCM1480_SCD_PERF_CNT_5            0x00100204F8
+#define A_BCM1480_SCD_PERF_CNT_6            0x0010020500
+#define A_BCM1480_SCD_PERF_CNT_7            0x0010020508
+
+/*  *********************************************************************
+    * System Bus Watcher Registers (Section 4.8)
+    ********************************************************************* */
+
+
+/* Same as 1250 except BUS_ERR_STATUS_DEBUG is in a different place. */
+
+#define A_BCM1480_BUS_ERR_STATUS_DEBUG      0x00100208D8
+
+/*  *********************************************************************
+    * System Debug Controller Registers (Section 19)
+    ********************************************************************* */
+
+/* Same as 1250 */
+
+/*  *********************************************************************
+    * System Trace Unit Registers (Sections 4.10)
+    ********************************************************************* */
+
+/* Same as 1250 */
+
+/*  *********************************************************************
+    * Data Mover DMA Registers (Section 10.7)
+    ********************************************************************* */
+
+/* Same as 1250 */
+
+
+/*  *********************************************************************
+    * HyperTransport Interface Registers (Section 8)
+    ********************************************************************* */
+
+#define BCM1480_HT_NUM_PORTS		   3
+#define BCM1480_HT_PORT_SPACING		   0x800
+#define A_BCM1480_HT_PORT_HEADER(x)	   (A_BCM1480_HT_PORT0_HEADER + ((x)*BCM1480_HT_PORT_SPACING))
+
+#define A_BCM1480_HT_PORT0_HEADER          0x00FE000000
+#define A_BCM1480_HT_PORT1_HEADER          0x00FE000800
+#define A_BCM1480_HT_PORT2_HEADER          0x00FE001000
+#define A_BCM1480_HT_TYPE00_HEADER         0x00FE002000
+
+
+/*  *********************************************************************
+    * Node Controller Registers (Section 9)
+    ********************************************************************* */
+
+#define A_BCM1480_NC_BASE                   0x00DFBD0000
+
+#define A_BCM1480_NC_RLD_FIELD              0x00DFBD0000
+#define A_BCM1480_NC_RLD_TRIGGER            0x00DFBD0020
+#define A_BCM1480_NC_RLD_BAD_ERROR          0x00DFBD0040
+#define A_BCM1480_NC_RLD_COR_ERROR          0x00DFBD0060
+#define A_BCM1480_NC_RLD_ECC_STATUS         0x00DFBD0080
+#define A_BCM1480_NC_RLD_WAY_ENABLE         0x00DFBD00A0
+#define A_BCM1480_NC_RLD_RANDOM_LFSR        0x00DFBD00C0
+
+#define A_BCM1480_NC_INTERRUPT_STATUS       0x00DFBD00E0
+#define A_BCM1480_NC_INTERRUPT_ENABLE       0x00DFBD0100
+#define A_BCM1480_NC_TIMEOUT_COUNTER        0x00DFBD0120
+#define A_BCM1480_NC_TIMEOUT_COUNTER_SEL    0x00DFBD0140
+
+#define A_BCM1480_NC_CREDIT_STATUS_REG0     0x00DFBD0200
+#define A_BCM1480_NC_CREDIT_STATUS_REG1     0x00DFBD0220
+#define A_BCM1480_NC_CREDIT_STATUS_REG2     0x00DFBD0240
+#define A_BCM1480_NC_CREDIT_STATUS_REG3     0x00DFBD0260
+#define A_BCM1480_NC_CREDIT_STATUS_REG4     0x00DFBD0280
+#define A_BCM1480_NC_CREDIT_STATUS_REG5     0x00DFBD02A0
+#define A_BCM1480_NC_CREDIT_STATUS_REG6     0x00DFBD02C0
+#define A_BCM1480_NC_CREDIT_STATUS_REG7     0x00DFBD02E0
+#define A_BCM1480_NC_CREDIT_STATUS_REG8     0x00DFBD0300
+#define A_BCM1480_NC_CREDIT_STATUS_REG9     0x00DFBD0320
+#define A_BCM1480_NC_CREDIT_STATUS_REG10    0x00DFBE0000
+#define A_BCM1480_NC_CREDIT_STATUS_REG11    0x00DFBE0020
+#define A_BCM1480_NC_CREDIT_STATUS_REG12    0x00DFBE0040
+
+#define A_BCM1480_NC_SR_TIMEOUT_COUNTER     0x00DFBE0060
+#define A_BCM1480_NC_SR_TIMEOUT_COUNTER_SEL 0x00DFBE0080
+
+
+/*  *********************************************************************
+    * H&R Block Configuration Registers (Section 12.4)
+    ********************************************************************* */
+
+#define A_BCM1480_HR_BASE_0                 0x00DF820000
+#define A_BCM1480_HR_BASE_1                 0x00DF8A0000
+#define A_BCM1480_HR_BASE_2                 0x00DF920000
+#define BCM1480_HR_REGISTER_SPACING         0x80000
+
+#define A_BCM1480_HR_BASE(idx)              (A_BCM1480_HR_BASE_0 + ((idx)*BCM1480_HR_REGISTER_SPACING))
+#define A_BCM1480_HR_REGISTER(idx,reg)      (A_BCM1480_HR_BASE(idx) + (reg))
+
+#define R_BCM1480_HR_CFG                    0x0000000000
+
+#define R_BCM1480_HR_MAPPING		    0x0000010010
+
+#define BCM1480_HR_RULE_SPACING             0x0000000010
+#define BCM1480_HR_NUM_RULES                16
+#define BCM1480_HR_OP_OFFSET                0x0000000100
+#define BCM1480_HR_TYPE_OFFSET              0x0000000108
+#define R_BCM1480_HR_RULE_OP(idx)           (BCM1480_HR_OP_OFFSET + ((idx)*BCM1480_HR_RULE_SPACING))
+#define R_BCM1480_HR_RULE_TYPE(idx)         (BCM1480_HR_TYPE_OFFSET + ((idx)*BCM1480_HR_RULE_SPACING))
+
+#define BCM1480_HR_LEAF_SPACING             0x0000000010
+#define BCM1480_HR_NUM_LEAVES               10
+#define BCM1480_HR_LEAF_OFFSET              0x0000000300
+#define R_BCM1480_HR_HA_LEAF0(idx)          (BCM1480_HR_LEAF_OFFSET + ((idx)*BCM1480_HR_LEAF_SPACING))
+
+#define R_BCM1480_HR_EX_LEAF0               0x00000003A0
+
+#define BCM1480_HR_PATH_SPACING             0x0000000010
+#define BCM1480_HR_NUM_PATHS                16
+#define BCM1480_HR_PATH_OFFSET              0x0000000600
+#define R_BCM1480_HR_PATH(idx)              (BCM1480_HR_PATH_OFFSET + ((idx)*BCM1480_HR_PATH_SPACING))
+
+#define R_BCM1480_HR_PATH_DEFAULT           0x0000000700
+
+#define BCM1480_HR_ROUTE_SPACING            8
+#define BCM1480_HR_NUM_ROUTES               512
+#define BCM1480_HR_ROUTE_OFFSET             0x0000001000
+#define R_BCM1480_HR_RT_WORD(idx)           (BCM1480_HR_ROUTE_OFFSET + ((idx)*BCM1480_HR_ROUTE_SPACING))
+
+
+/* checked to here - ehs */
+/*  *********************************************************************
+    * Packet Manager DMA Registers (Section 12.5)
+    ********************************************************************* */
+
+#define A_BCM1480_PM_BASE                   0x0010056000
+
+#define A_BCM1480_PMI_LCL_0                 0x0010058000
+#define A_BCM1480_PMO_LCL_0                 0x001005C000
+#define A_BCM1480_PMI_OFFSET_0              (A_BCM1480_PMI_LCL_0 - A_BCM1480_PM_BASE)
+#define A_BCM1480_PMO_OFFSET_0              (A_BCM1480_PMO_LCL_0 - A_BCM1480_PM_BASE)
+
+#define BCM1480_PM_LCL_REGISTER_SPACING     0x100
+#define BCM1480_PM_NUM_CHANNELS             32
+
+#define A_BCM1480_PMI_LCL_BASE(idx)             (A_BCM1480_PMI_LCL_0 + ((idx)*BCM1480_PM_LCL_REGISTER_SPACING))
+#define A_BCM1480_PMI_LCL_REGISTER(idx,reg)     (A_BCM1480_PMI_LCL_BASE(idx) + (reg))
+#define A_BCM1480_PMO_LCL_BASE(idx)             (A_BCM1480_PMO_LCL_0 + ((idx)*BCM1480_PM_LCL_REGISTER_SPACING))
+#define A_BCM1480_PMO_LCL_REGISTER(idx,reg)     (A_BCM1480_PMO_LCL_BASE(idx) + (reg))
+
+#define BCM1480_PM_INT_PACKING              8
+#define BCM1480_PM_INT_FUNCTION_SPACING     0x40
+#define BCM1480_PM_INT_NUM_FUNCTIONS        3
+
+/*
+ * DMA channel registers relative to A_BCM1480_PMI_LCL_BASE(n) and A_BCM1480_PMO_LCL_BASE(n)
+ */
+
+#define R_BCM1480_PM_BASE_SIZE              0x0000000000
+#define R_BCM1480_PM_CNT                    0x0000000008
+#define R_BCM1480_PM_PFCNT                  0x0000000010
+#define R_BCM1480_PM_LAST                   0x0000000018
+#define R_BCM1480_PM_PFINDX                 0x0000000020
+#define R_BCM1480_PM_INT_WMK                0x0000000028
+#define R_BCM1480_PM_CONFIG0                0x0000000030
+#define R_BCM1480_PM_LOCALDEBUG             0x0000000078
+#define R_BCM1480_PM_CACHEABILITY           0x0000000080   /* PMI only */
+#define R_BCM1480_PM_INT_CNFG               0x0000000088
+#define R_BCM1480_PM_DESC_MERGE_TIMER       0x0000000090
+#define R_BCM1480_PM_LOCALDEBUG_PIB         0x00000000F8   /* PMI only */
+#define R_BCM1480_PM_LOCALDEBUG_POB         0x00000000F8   /* PMO only */
+
+/*
+ * Global Registers (Not Channelized)
+ */
+
+#define A_BCM1480_PMI_GLB_0                 0x0010056000
+#define A_BCM1480_PMO_GLB_0                 0x0010057000
+
+/*
+ * PM to TX Mapping Register relative to A_BCM1480_PMI_GLB_0 and A_BCM1480_PMO_GLB_0
+ */
+
+#define R_BCM1480_PM_PMO_MAPPING            0x00000008C8   /* PMO only */
+
+#define A_BCM1480_PM_PMO_MAPPING	(A_BCM1480_PMO_GLB_0 + R_BCM1480_PM_PMO_MAPPING)
+
+/*
+ * Interrupt mapping registers
+ */
+
+
+#define A_BCM1480_PMI_INT_0                 0x0010056800
+#define A_BCM1480_PMI_INT(q)                (A_BCM1480_PMI_INT_0 + ((q>>8)<<8))
+#define A_BCM1480_PMI_INT_OFFSET_0          (A_BCM1480_PMI_INT_0 - A_BCM1480_PM_BASE)
+#define A_BCM1480_PMO_INT_0                 0x0010057800
+#define A_BCM1480_PMO_INT(q)                (A_BCM1480_PMO_INT_0 + ((q>>8)<<8))
+#define A_BCM1480_PMO_INT_OFFSET_0          (A_BCM1480_PMO_INT_0 - A_BCM1480_PM_BASE)
+
+/*
+ * Interrupt registers relative to A_BCM1480_PMI_INT_0 and A_BCM1480_PMO_INT_0
+ */
+
+#define R_BCM1480_PM_INT_ST                 0x0000000000
+#define R_BCM1480_PM_INT_MSK                0x0000000040
+#define R_BCM1480_PM_INT_CLR                0x0000000080
+#define R_BCM1480_PM_MRGD_INT               0x00000000C0
+
+/*
+ * Debug registers (global)
+ */
+
+#define A_BCM1480_PM_GLOBALDEBUGMODE_PMI    0x0010056000
+#define A_BCM1480_PM_GLOBALDEBUG_PID        0x00100567F8
+#define A_BCM1480_PM_GLOBALDEBUG_PIB        0x0010056FF8
+#define A_BCM1480_PM_GLOBALDEBUGMODE_PMO    0x0010057000
+#define A_BCM1480_PM_GLOBALDEBUG_POD        0x00100577F8
+#define A_BCM1480_PM_GLOBALDEBUG_POB        0x0010057FF8
+
+/*  *********************************************************************
+    *  Switch performance counters
+    ********************************************************************* */
+
+#define A_BCM1480_SWPERF_CFG	0xdfb91800
+#define A_BCM1480_SWPERF_CNT0	0xdfb91880
+#define A_BCM1480_SWPERF_CNT1	0xdfb91888
+#define A_BCM1480_SWPERF_CNT2	0xdfb91890
+#define A_BCM1480_SWPERF_CNT3	0xdfb91898
+
+
+/*  *********************************************************************
+    *  Switch Trace Unit
+    ********************************************************************* */
+
+#define A_BCM1480_SWTRC_MATCH_CONTROL_0		0xDFB91000
+#define A_BCM1480_SWTRC_MATCH_DATA_VALUE_0	0xDFB91100
+#define A_BCM1480_SWTRC_MATCH_DATA_MASK_0	0xDFB91108
+#define A_BCM1480_SWTRC_MATCH_TAG_VALUE_0	0xDFB91200
+#define A_BCM1480_SWTRC_MATCH_TAG_MAKS_0	0xDFB91208
+#define A_BCM1480_SWTRC_EVENT_0			0xDFB91300
+#define A_BCM1480_SWTRC_SEQUENCE_0		0xDFB91400
+
+#define A_BCM1480_SWTRC_CFG			0xDFB91500
+#define A_BCM1480_SWTRC_READ			0xDFB91508
+
+#define A_BCM1480_SWDEBUG_SCHEDSTOP		0xDFB92000
+
+#define A_BCM1480_SWTRC_MATCH_CONTROL(x) (A_BCM1480_SWTRC_MATCH_CONTROL_0 + ((x)*8))
+#define A_BCM1480_SWTRC_EVENT(x) (A_BCM1480_SWTRC_EVENT_0 + ((x)*8))
+#define A_BCM1480_SWTRC_SEQUENCE(x) (A_BCM1480_SWTRC_SEQUENCE_0 + ((x)*8))
+
+#define A_BCM1480_SWTRC_MATCH_DATA_VALUE(x) (A_BCM1480_SWTRC_MATCH_DATA_VALUE_0 + ((x)*16))
+#define A_BCM1480_SWTRC_MATCH_DATA_MASK(x) (A_BCM1480_SWTRC_MATCH_DATA_MASK_0 + ((x)*16))
+#define A_BCM1480_SWTRC_MATCH_TAG_VALUE(x) (A_BCM1480_SWTRC_MATCH_TAG_VALUE_0 + ((x)*16))
+#define A_BCM1480_SWTRC_MATCH_TAG_MASK(x) (A_BCM1480_SWTRC_MATCH_TAG_MASK_0 + ((x)*16))
+
+
+
+/*  *********************************************************************
+    *  High-Speed Port Registers (Section 13)
+    ********************************************************************* */
+
+#define A_BCM1480_HSP_BASE_0                0x00DF810000
+#define A_BCM1480_HSP_BASE_1                0x00DF890000
+#define A_BCM1480_HSP_BASE_2                0x00DF910000
+#define BCM1480_HSP_REGISTER_SPACING        0x80000
+
+#define A_BCM1480_HSP_BASE(idx)             (A_BCM1480_HSP_BASE_0 + ((idx)*BCM1480_HSP_REGISTER_SPACING))
+#define A_BCM1480_HSP_REGISTER(idx,reg)     (A_BCM1480_HSP_BASE(idx) + (reg))
+
+#define R_BCM1480_HSP_RX_SPI4_CFG_0           0x0000000000
+#define R_BCM1480_HSP_RX_SPI4_CFG_1           0x0000000008
+#define R_BCM1480_HSP_RX_SPI4_DESKEW_OVERRIDE 0x0000000010
+#define R_BCM1480_HSP_RX_SPI4_DESKEW_DATAPATH 0x0000000018
+#define R_BCM1480_HSP_RX_SPI4_PORT_INT_EN     0x0000000020
+#define R_BCM1480_HSP_RX_SPI4_PORT_INT_STATUS 0x0000000028
+
+#define R_BCM1480_HSP_RX_SPI4_CALENDAR_0      0x0000000200
+#define R_BCM1480_HSP_RX_SPI4_CALENDAR_1      0x0000000208
+
+#define R_BCM1480_HSP_RX_PLL_CNFG             0x0000000800
+#define R_BCM1480_HSP_RX_CALIBRATION          0x0000000808
+#define R_BCM1480_HSP_RX_TEST                 0x0000000810
+#define R_BCM1480_HSP_RX_DIAG_DETAILS         0x0000000818
+#define R_BCM1480_HSP_RX_DIAG_CRC_0           0x0000000820
+#define R_BCM1480_HSP_RX_DIAG_CRC_1           0x0000000828
+#define R_BCM1480_HSP_RX_DIAG_HTCMD           0x0000000830
+#define R_BCM1480_HSP_RX_DIAG_PKTCTL          0x0000000838
+
+#define R_BCM1480_HSP_RX_VIS_FLCTRL_COUNTER   0x0000000870
+
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_0       0x0000020020
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_1       0x0000020028
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_2       0x0000020030
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_3       0x0000020038
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_4       0x0000020040
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_5       0x0000020048
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_6       0x0000020050
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC_7       0x0000020058
+#define R_BCM1480_HSP_RX_PKT_RAMALLOC(idx)    (R_BCM1480_HSP_RX_PKT_RAMALLOC_0 + 8*(idx))
+
+/* XXX Following registers were shuffled.  Renamed/renumbered per errata. */
+#define R_BCM1480_HSP_RX_HT_RAMALLOC_0      0x0000020078
+#define R_BCM1480_HSP_RX_HT_RAMALLOC_1      0x0000020080
+#define R_BCM1480_HSP_RX_HT_RAMALLOC_2      0x0000020088
+#define R_BCM1480_HSP_RX_HT_RAMALLOC_3      0x0000020090
+#define R_BCM1480_HSP_RX_HT_RAMALLOC_4      0x0000020098
+#define R_BCM1480_HSP_RX_HT_RAMALLOC_5      0x00000200A0
+
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_0      0x00000200B0
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_1      0x00000200B8
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_2      0x00000200C0
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_3      0x00000200C8
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_4      0x00000200D0
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_5      0x00000200D8
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_6      0x00000200E0
+#define R_BCM1480_HSP_RX_SPI_WATERMARK_7      0x00000200E8
+#define R_BCM1480_HSP_RX_SPI_WATERMARK(idx)   (R_BCM1480_HSP_RX_SPI_WATERMARK_0 + 8*(idx))
+
+#define R_BCM1480_HSP_RX_VIS_CMDQ_0           0x00000200F0
+#define R_BCM1480_HSP_RX_VIS_CMDQ_1           0x00000200F8
+#define R_BCM1480_HSP_RX_VIS_CMDQ_2           0x0000020100
+#define R_BCM1480_HSP_RX_RAM_READCTL          0x0000020108
+#define R_BCM1480_HSP_RX_RAM_READWINDOW       0x0000020110
+#define R_BCM1480_HSP_RX_RF_READCTL           0x0000020118
+#define R_BCM1480_HSP_RX_RF_READWINDOW        0x0000020120
+
+#define R_BCM1480_HSP_TX_SPI4_CFG_0           0x0000040000
+#define R_BCM1480_HSP_TX_SPI4_CFG_1           0x0000040008
+#define R_BCM1480_HSP_TX_SPI4_TRAINING_FMT    0x0000040010
+
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_0       0x0000040020
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_1       0x0000040028
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_2       0x0000040030
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_3       0x0000040038
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_4       0x0000040040
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_5       0x0000040048
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_6       0x0000040050
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC_7       0x0000040058
+#define R_BCM1480_HSP_TX_PKT_RAMALLOC(idx)    (R_BCM1480_HSP_TX_PKT_RAMALLOC_0 + 8*(idx))
+#define R_BCM1480_HSP_TX_NPC_RAMALLOC         0x0000040078
+#define R_BCM1480_HSP_TX_RSP_RAMALLOC         0x0000040080
+#define R_BCM1480_HSP_TX_PC_RAMALLOC          0x0000040088
+#define R_BCM1480_HSP_TX_HTCC_RAMALLOC_0      0x0000040090
+#define R_BCM1480_HSP_TX_HTCC_RAMALLOC_1      0x0000040098
+#define R_BCM1480_HSP_TX_HTCC_RAMALLOC_2      0x00000400A0
+
+#define R_BCM1480_HSP_TX_PKT_RXPHITCNT_0      0x00000400B0
+#define R_BCM1480_HSP_TX_PKT_RXPHITCNT_1      0x00000400B8
+#define R_BCM1480_HSP_TX_PKT_RXPHITCNT_2      0x00000400C0
+#define R_BCM1480_HSP_TX_PKT_RXPHITCNT_3      0x00000400C8
+#define R_BCM1480_HSP_TX_PKT_RXPHITCNT(idx)   (R_BCM1480_HSP_TX_PKT_RXPHITCNT_0 + 8*(idx))
+#define R_BCM1480_HSP_TX_HTIO_RXPHITCNT       0x00000400D0
+#define R_BCM1480_HSP_TX_HTCC_RXPHITCNT       0x00000400D8
+
+#define R_BCM1480_HSP_TX_PKT_TXPHITCNT_0      0x00000400E0
+#define R_BCM1480_HSP_TX_PKT_TXPHITCNT_1      0x00000400E8
+#define R_BCM1480_HSP_TX_PKT_TXPHITCNT_2      0x00000400F0
+#define R_BCM1480_HSP_TX_PKT_TXPHITCNT_3      0x00000400F8
+#define R_BCM1480_HSP_TX_PKT_TXPHITCNT(idx)   (R_BCM1480_HSP_TX_PKT_TXPHITCNT_0 + 8*(idx))
+#define R_BCM1480_HSP_TX_HTIO_TXPHITCNT       0x0000040100
+#define R_BCM1480_HSP_TX_HTCC_TXPHITCNT       0x0000040108
+
+#define R_BCM1480_HSP_TX_SPI4_CALENDAR_0      0x0000040200
+#define R_BCM1480_HSP_TX_SPI4_CALENDAR_1      0x0000040208
+
+#define R_BCM1480_HSP_TX_PLL_CNFG             0x0000040800
+#define R_BCM1480_HSP_TX_CALIBRATION          0x0000040808
+#define R_BCM1480_HSP_TX_TEST                 0x0000040810
+
+#define R_BCM1480_HSP_TX_VIS_CMDQ_0           0x0000040840
+#define R_BCM1480_HSP_TX_VIS_CMDQ_1           0x0000040848
+#define R_BCM1480_HSP_TX_VIS_CMDQ_2           0x0000040850
+#define R_BCM1480_HSP_TX_RAM_READCTL          0x0000040860
+#define R_BCM1480_HSP_TX_RAM_READWINDOW       0x0000040868
+#define R_BCM1480_HSP_TX_RF_READCTL           0x0000040870
+#define R_BCM1480_HSP_TX_RF_READWINDOW        0x0000040878
+
+#define R_BCM1480_HSP_TX_SPI4_PORT_INT_STATUS 0x0000040880
+#define R_BCM1480_HSP_TX_SPI4_PORT_INT_EN     0x0000040888
+
+#define R_BCM1480_HSP_TX_NEXT_ADDR_BASE 0x000040400
+#define R_BCM1480_HSP_TX_NEXT_ADDR_REGISTER(x)  (R_BCM1480_HSP_TX_NEXT_ADDR_BASE+ 8*(x))
+
+
+
+/*  *********************************************************************
+    *  Physical Address Map (Table 10 and Figure 7)
+    ********************************************************************* */
+
+#define A_BCM1480_PHYS_MEMORY_0                 _SB_MAKE64(0x0000000000)
+#define A_BCM1480_PHYS_MEMORY_SIZE              _SB_MAKE64((256*1024*1024))
+#define A_BCM1480_PHYS_SYSTEM_CTL               _SB_MAKE64(0x0010000000)
+#define A_BCM1480_PHYS_IO_SYSTEM                _SB_MAKE64(0x0010060000)
+#define A_BCM1480_PHYS_GENBUS                   _SB_MAKE64(0x0010090000)
+#define A_BCM1480_PHYS_GENBUS_END               _SB_MAKE64(0x0028000000)
+#define A_BCM1480_PHYS_PCI_MISC_MATCH_BYTES     _SB_MAKE64(0x0028000000)
+#define A_BCM1480_PHYS_PCI_IACK_MATCH_BYTES     _SB_MAKE64(0x0029000000)
+#define A_BCM1480_PHYS_PCI_IO_MATCH_BYTES       _SB_MAKE64(0x002C000000)
+#define A_BCM1480_PHYS_PCI_CFG_MATCH_BYTES      _SB_MAKE64(0x002E000000)
+#define A_BCM1480_PHYS_PCI_OMAP_MATCH_BYTES     _SB_MAKE64(0x002F000000)
+#define A_BCM1480_PHYS_PCI_MEM_MATCH_BYTES      _SB_MAKE64(0x0030000000)
+#define A_BCM1480_PHYS_HT_MEM_MATCH_BYTES       _SB_MAKE64(0x0040000000)
+#define A_BCM1480_PHYS_HT_MEM_MATCH_BITS        _SB_MAKE64(0x0060000000)
+#define A_BCM1480_PHYS_MEMORY_1                 _SB_MAKE64(0x0080000000)
+#define A_BCM1480_PHYS_MEMORY_2                 _SB_MAKE64(0x0090000000)
+#define A_BCM1480_PHYS_PCI_MISC_MATCH_BITS      _SB_MAKE64(0x00A8000000)
+#define A_BCM1480_PHYS_PCI_IACK_MATCH_BITS      _SB_MAKE64(0x00A9000000)
+#define A_BCM1480_PHYS_PCI_IO_MATCH_BITS        _SB_MAKE64(0x00AC000000)
+#define A_BCM1480_PHYS_PCI_CFG_MATCH_BITS       _SB_MAKE64(0x00AE000000)
+#define A_BCM1480_PHYS_PCI_OMAP_MATCH_BITS      _SB_MAKE64(0x00AF000000)
+#define A_BCM1480_PHYS_PCI_MEM_MATCH_BITS       _SB_MAKE64(0x00B0000000)
+#define A_BCM1480_PHYS_MEMORY_3                 _SB_MAKE64(0x00C0000000)
+#define A_BCM1480_PHYS_L2_CACHE_TEST            _SB_MAKE64(0x00D0000000)
+#define A_BCM1480_PHYS_HT_SPECIAL_MATCH_BYTES   _SB_MAKE64(0x00D8000000)
+#define A_BCM1480_PHYS_HT_IO_MATCH_BYTES        _SB_MAKE64(0x00DC000000)
+#define A_BCM1480_PHYS_HT_CFG_MATCH_BYTES       _SB_MAKE64(0x00DE000000)
+#define A_BCM1480_PHYS_HS_SUBSYS                _SB_MAKE64(0x00DF000000)
+#define A_BCM1480_PHYS_HT_SPECIAL_MATCH_BITS    _SB_MAKE64(0x00F8000000)
+#define A_BCM1480_PHYS_HT_IO_MATCH_BITS         _SB_MAKE64(0x00FC000000)
+#define A_BCM1480_PHYS_HT_CFG_MATCH_BITS        _SB_MAKE64(0x00FE000000)
+#define A_BCM1480_PHYS_MEMORY_EXP               _SB_MAKE64(0x0100000000)
+#define A_BCM1480_PHYS_MEMORY_EXP_SIZE          _SB_MAKE64((508*1024*1024*1024))
+#define A_BCM1480_PHYS_PCI_UPPER                _SB_MAKE64(0x1000000000)
+#define A_BCM1480_PHYS_HT_UPPER_MATCH_BYTES     _SB_MAKE64(0x2000000000)
+#define A_BCM1480_PHYS_HT_UPPER_MATCH_BITS      _SB_MAKE64(0x3000000000)
+#define A_BCM1480_PHYS_HT_NODE_ALIAS            _SB_MAKE64(0x4000000000)
+#define A_BCM1480_PHYS_HT_FULLACCESS            _SB_MAKE64(0xF000000000)
+
+
+/*  *********************************************************************
+    *  L2 Cache as RAM (Table 54)
+    ********************************************************************* */
+
+#define A_BCM1480_PHYS_L2CACHE_WAY_SIZE         _SB_MAKE64(0x0000020000)
+#define BCM1480_PHYS_L2CACHE_NUM_WAYS           8
+#define A_BCM1480_PHYS_L2CACHE_TOTAL_SIZE       _SB_MAKE64(0x0000100000)
+#define A_BCM1480_PHYS_L2CACHE_WAY0             _SB_MAKE64(0x00D0300000)
+#define A_BCM1480_PHYS_L2CACHE_WAY1             _SB_MAKE64(0x00D0320000)
+#define A_BCM1480_PHYS_L2CACHE_WAY2             _SB_MAKE64(0x00D0340000)
+#define A_BCM1480_PHYS_L2CACHE_WAY3             _SB_MAKE64(0x00D0360000)
+#define A_BCM1480_PHYS_L2CACHE_WAY4             _SB_MAKE64(0x00D0380000)
+#define A_BCM1480_PHYS_L2CACHE_WAY5             _SB_MAKE64(0x00D03A0000)
+#define A_BCM1480_PHYS_L2CACHE_WAY6             _SB_MAKE64(0x00D03C0000)
+#define A_BCM1480_PHYS_L2CACHE_WAY7             _SB_MAKE64(0x00D03E0000)
+
+#endif /* _BCM1480_REGS_H */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/bcm1480_scd.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_scd.h
--- linux-2.6.14/include/asm-mips/sibyte/bcm1480_scd.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/bcm1480_scd.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,436 @@
+/*  *********************************************************************
+    *  BCM1280/BCM1400 Board Support Package
+    *
+    *  SCD Constants and Macros                     File: bcm1480_scd.h
+    *
+    *  This module contains constants and macros useful for
+    *  manipulating the System Control and Debug module.
+    *
+    *  BCM1400 specification level: 1X55_1X80-UM100-R (12/18/03)
+    *
+    *********************************************************************
+    *
+    *  Copyright 2000,2001,2002,2003
+    *  Broadcom Corporation. All rights reserved.
+    *
+    *  This program is free software; you can redistribute it and/or
+    *  modify it under the terms of the GNU General Public License as
+    *  published by the Free Software Foundation; either version 2 of
+    *  the License, or (at your option) any later version.
+    *
+    *  This program is distributed in the hope that it will be useful,
+    *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+    *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    *  GNU General Public License for more details.
+    *
+    *  You should have received a copy of the GNU General Public License
+    *  along with this program; if not, write to the Free Software
+    *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+    *  MA 02111-1307 USA
+    ********************************************************************* */
+
+#ifndef _BCM1480_SCD_H
+#define _BCM1480_SCD_H
+
+#include "sb1250_defs.h"
+
+/*  *********************************************************************
+    *  Pull in the BCM1250's SCD since lots of stuff is the same.
+    ********************************************************************* */
+
+#include "sb1250_scd.h"
+
+/*  *********************************************************************
+    *  Some general notes:
+    *
+    *  This file is basically a "what's new" header file.  Since the
+    *  BCM1250 and the new BCM1480 (and derivatives) share many common
+    *  features, this file contains only what's new or changed from
+    *  the 1250.  (above, you can see that we include the 1250 symbols
+    *  to get the base functionality).
+    *
+    *  In software, be sure to use the correct symbols, particularly
+    *  for blocks that are different between the two chip families.
+    *  All BCM1480-specific symbols have _BCM1480_ in their names,
+    *  and all BCM1250-specific and "base" functions that are common in
+    *  both chips have no special names (this is for compatibility with
+    *  older include files).  Therefore, if you're working with the
+    *  SCD, which is very different on each chip, A_SCD_xxx implies
+    *  the BCM1250 version and A_BCM1480_SCD_xxx implies the BCM1480
+    *  version.
+    ********************************************************************* */
+
+/*  *********************************************************************
+    *  System control/debug registers
+    ********************************************************************* */
+
+/*
+ * System Identification and Revision Register (Table 12)
+ * Register: SCD_SYSTEM_REVISION
+ * This register is field compatible with the 1250.
+ */
+
+/*
+ * New part definitions
+ */
+
+#define K_SYS_PART_BCM1480          0x1406
+#define K_SYS_PART_BCM1280          0x1206
+#define K_SYS_PART_BCM1455          0x1407
+#define K_SYS_PART_BCM1255          0x1257
+
+/*
+ * Manufacturing Information Register (Table 14)
+ * Register: SCD_SYSTEM_MANUF
+ */
+
+/*
+ * System Configuration Register (Table 15)
+ * Register: SCD_SYSTEM_CFG
+ * Entire register is different from 1250, all new constants below
+ */
+
+#define M_BCM1480_SYS_RESERVED0             _SB_MAKEMASK1(0)
+#define M_BCM1480_SYS_HT_MINRSTCNT          _SB_MAKEMASK1(1)
+#define M_BCM1480_SYS_RESERVED2             _SB_MAKEMASK1(2)
+#define M_BCM1480_SYS_RESERVED3             _SB_MAKEMASK1(3)
+#define M_BCM1480_SYS_RESERVED4             _SB_MAKEMASK1(4)
+#define M_BCM1480_SYS_IOB_DIV               _SB_MAKEMASK1(5)
+
+#define S_BCM1480_SYS_PLL_DIV               _SB_MAKE64(6)
+#define M_BCM1480_SYS_PLL_DIV               _SB_MAKEMASK(5,S_BCM1480_SYS_PLL_DIV)
+#define V_BCM1480_SYS_PLL_DIV(x)            _SB_MAKEVALUE(x,S_BCM1480_SYS_PLL_DIV)
+#define G_BCM1480_SYS_PLL_DIV(x)            _SB_GETVALUE(x,S_BCM1480_SYS_PLL_DIV,M_BCM1480_SYS_PLL_DIV)
+
+#define S_BCM1480_SYS_SW_DIV                _SB_MAKE64(11)
+#define M_BCM1480_SYS_SW_DIV                _SB_MAKEMASK(5,S_BCM1480_SYS_SW_DIV)
+#define V_BCM1480_SYS_SW_DIV(x)             _SB_MAKEVALUE(x,S_BCM1480_SYS_SW_DIV)
+#define G_BCM1480_SYS_SW_DIV(x)             _SB_GETVALUE(x,S_BCM1480_SYS_SW_DIV,M_BCM1480_SYS_SW_DIV)
+
+#define M_BCM1480_SYS_PCMCIA_ENABLE         _SB_MAKEMASK1(16)
+#define M_BCM1480_SYS_DUART1_ENABLE         _SB_MAKEMASK1(17)
+
+#define S_BCM1480_SYS_BOOT_MODE             _SB_MAKE64(18)
+#define M_BCM1480_SYS_BOOT_MODE             _SB_MAKEMASK(2,S_BCM1480_SYS_BOOT_MODE)
+#define V_BCM1480_SYS_BOOT_MODE(x)          _SB_MAKEVALUE(x,S_BCM1480_SYS_BOOT_MODE)
+#define G_BCM1480_SYS_BOOT_MODE(x)          _SB_GETVALUE(x,S_BCM1480_SYS_BOOT_MODE,M_BCM1480_SYS_BOOT_MODE)
+#define K_BCM1480_SYS_BOOT_MODE_ROM32       0
+#define K_BCM1480_SYS_BOOT_MODE_ROM8        1
+#define K_BCM1480_SYS_BOOT_MODE_SMBUS_SMALL 2
+#define K_BCM1480_SYS_BOOT_MODE_SMBUS_BIG   3
+#define M_BCM1480_SYS_BOOT_MODE_SMBUS       _SB_MAKEMASK1(19)
+
+#define M_BCM1480_SYS_PCI_HOST              _SB_MAKEMASK1(20)
+#define M_BCM1480_SYS_PCI_ARBITER           _SB_MAKEMASK1(21)
+#define M_BCM1480_SYS_BIG_ENDIAN            _SB_MAKEMASK1(22)
+#define M_BCM1480_SYS_GENCLK_EN             _SB_MAKEMASK1(23)
+#define M_BCM1480_SYS_GEN_PARITY_EN         _SB_MAKEMASK1(24)
+#define M_BCM1480_SYS_RESERVED25            _SB_MAKEMASK1(25)
+
+#define S_BCM1480_SYS_CONFIG                26
+#define M_BCM1480_SYS_CONFIG                _SB_MAKEMASK(6,S_BCM1480_SYS_CONFIG)
+#define V_BCM1480_SYS_CONFIG(x)             _SB_MAKEVALUE(x,S_BCM1480_SYS_CONFIG)
+#define G_BCM1480_SYS_CONFIG(x)             _SB_GETVALUE(x,S_BCM1480_SYS_CONFIG,M_BCM1480_SYS_CONFIG)
+
+#define M_BCM1480_SYS_RESERVED32            _SB_MAKEMASK(32,15)
+
+#define S_BCM1480_SYS_NODEID                47
+#define M_BCM1480_SYS_NODEID                _SB_MAKEMASK(4,S_BCM1480_SYS_NODEID)
+#define V_BCM1480_SYS_NODEID(x)             _SB_MAKEVALUE(x,S_BCM1480_SYS_NODEID)
+#define G_BCM1480_SYS_NODEID(x)             _SB_GETVALUE(x,S_BCM1480_SYS_NODEID,M_BCM1480_SYS_NODEID)
+
+#define M_BCM1480_SYS_CCNUMA_EN             _SB_MAKEMASK1(51)
+#define M_BCM1480_SYS_CPU_RESET_0           _SB_MAKEMASK1(52)
+#define M_BCM1480_SYS_CPU_RESET_1           _SB_MAKEMASK1(53)
+#define M_BCM1480_SYS_CPU_RESET_2           _SB_MAKEMASK1(54)
+#define M_BCM1480_SYS_CPU_RESET_3           _SB_MAKEMASK1(55)
+#define S_BCM1480_SYS_DISABLECPU0           56
+#define M_BCM1480_SYS_DISABLECPU0           _SB_MAKEMASK1(S_BCM1480_SYS_DISABLECPU0)
+#define S_BCM1480_SYS_DISABLECPU1           57
+#define M_BCM1480_SYS_DISABLECPU1           _SB_MAKEMASK1(S_BCM1480_SYS_DISABLECPU1)
+#define S_BCM1480_SYS_DISABLECPU2           58
+#define M_BCM1480_SYS_DISABLECPU2           _SB_MAKEMASK1(S_BCM1480_SYS_DISABLECPU2)
+#define S_BCM1480_SYS_DISABLECPU3           59
+#define M_BCM1480_SYS_DISABLECPU3           _SB_MAKEMASK1(S_BCM1480_SYS_DISABLECPU3)
+
+#define M_BCM1480_SYS_SB_SOFTRES            _SB_MAKEMASK1(60)
+#define M_BCM1480_SYS_EXT_RESET             _SB_MAKEMASK1(61)
+#define M_BCM1480_SYS_SYSTEM_RESET          _SB_MAKEMASK1(62)
+#define M_BCM1480_SYS_SW_FLAG               _SB_MAKEMASK1(63)
+
+/*
+ * Scratch Register (Table 16)
+ * Register: SCD_SYSTEM_SCRATCH
+ * Same as BCM1250
+ */
+
+
+/*
+ * Mailbox Registers (Table 17)
+ * Registers: SCD_MBOX_{0,1}_CPU_x
+ * Same as BCM1250
+ */
+
+
+/*
+ * See bcm1480_int.h for interrupt mapper registers.
+ */
+
+
+/*
+ * Watchdog Timer Initial Count Registers (Table 23)
+ * Registers: SCD_WDOG_INIT_CNT_x
+ *
+ * The watchdogs are almost the same as the 1250, except
+ * the configuration register has more bits to control the
+ * other CPUs.
+ */
+
+
+/*
+ * Watchdog Timer Configuration Registers (Table 25)
+ * Registers: SCD_WDOG_CFG_x
+ */
+
+#define M_BCM1480_SCD_WDOG_ENABLE           _SB_MAKEMASK1(0)
+
+#define S_BCM1480_SCD_WDOG_RESET_TYPE       2
+#define M_BCM1480_SCD_WDOG_RESET_TYPE       _SB_MAKEMASK(5,S_BCM1480_SCD_WDOG_RESET_TYPE)
+#define V_BCM1480_SCD_WDOG_RESET_TYPE(x)    _SB_MAKEVALUE(x,S_BCM1480_SCD_WDOG_RESET_TYPE)
+#define G_BCM1480_SCD_WDOG_RESET_TYPE(x)    _SB_GETVALUE(x,S_BCM1480_SCD_WDOG_RESET_TYPE,M_BCM1480_SCD_WDOG_RESET_TYPE)
+
+#define K_BCM1480_SCD_WDOG_RESET_FULL       0	/* actually, (x & 1) == 0  */
+#define K_BCM1480_SCD_WDOG_RESET_SOFT       1
+#define K_BCM1480_SCD_WDOG_RESET_CPU0       3
+#define K_BCM1480_SCD_WDOG_RESET_CPU1       5
+#define K_BCM1480_SCD_WDOG_RESET_CPU2       9
+#define K_BCM1480_SCD_WDOG_RESET_CPU3       17
+#define K_BCM1480_SCD_WDOG_RESET_ALL_CPUS   31
+
+
+#define M_BCM1480_SCD_WDOG_HAS_RESET        _SB_MAKEMASK1(8)
+
+/*
+ * General Timer Initial Count Registers (Table 26)
+ * Registers: SCD_TIMER_INIT_x
+ *
+ * The timer registers are the same as the BCM1250
+ */
+
+
+/*
+ * ZBbus Count Register (Table 29)
+ * Register: ZBBUS_CYCLE_COUNT
+ *
+ * Same as BCM1250
+ */
+
+/*
+ * ZBbus Compare Registers (Table 30)
+ * Registers: ZBBUS_CYCLE_CPx
+ *
+ * Same as BCM1250
+ */
+
+
+/*
+ * System Performance Counter Configuration Register (Table 31)
+ * Register: PERF_CNT_CFG_0
+ *
+ * Since the clear/enable bits are moved compared to the
+ * 1250 and there are more fields, this register will be BCM1480 specific.
+ */
+
+#define S_BCM1480_SPC_CFG_SRC0              0
+#define M_BCM1480_SPC_CFG_SRC0              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC0)
+#define V_BCM1480_SPC_CFG_SRC0(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC0)
+#define G_BCM1480_SPC_CFG_SRC0(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC0,M_BCM1480_SPC_CFG_SRC0)
+
+#define S_BCM1480_SPC_CFG_SRC1              8
+#define M_BCM1480_SPC_CFG_SRC1              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC1)
+#define V_BCM1480_SPC_CFG_SRC1(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC1)
+#define G_BCM1480_SPC_CFG_SRC1(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC1,M_BCM1480_SPC_CFG_SRC1)
+
+#define S_BCM1480_SPC_CFG_SRC2              16
+#define M_BCM1480_SPC_CFG_SRC2              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC2)
+#define V_BCM1480_SPC_CFG_SRC2(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC2)
+#define G_BCM1480_SPC_CFG_SRC2(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC2,M_BCM1480_SPC_CFG_SRC2)
+
+#define S_BCM1480_SPC_CFG_SRC3              24
+#define M_BCM1480_SPC_CFG_SRC3              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC3)
+#define V_BCM1480_SPC_CFG_SRC3(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC3)
+#define G_BCM1480_SPC_CFG_SRC3(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC3,M_BCM1480_SPC_CFG_SRC3)
+
+#define S_BCM1480_SPC_CFG_SRC4              32
+#define M_BCM1480_SPC_CFG_SRC4              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC4)
+#define V_BCM1480_SPC_CFG_SRC4(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC4)
+#define G_BCM1480_SPC_CFG_SRC4(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC4,M_BCM1480_SPC_CFG_SRC4)
+
+#define S_BCM1480_SPC_CFG_SRC5              40
+#define M_BCM1480_SPC_CFG_SRC5              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC5)
+#define V_BCM1480_SPC_CFG_SRC5(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC5)
+#define G_BCM1480_SPC_CFG_SRC5(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC5,M_BCM1480_SPC_CFG_SRC5)
+
+#define S_BCM1480_SPC_CFG_SRC6              48
+#define M_BCM1480_SPC_CFG_SRC6              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC6)
+#define V_BCM1480_SPC_CFG_SRC6(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC6)
+#define G_BCM1480_SPC_CFG_SRC6(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC6,M_BCM1480_SPC_CFG_SRC6)
+
+#define S_BCM1480_SPC_CFG_SRC7              56
+#define M_BCM1480_SPC_CFG_SRC7              _SB_MAKEMASK(8,S_BCM1480_SPC_CFG_SRC7)
+#define V_BCM1480_SPC_CFG_SRC7(x)           _SB_MAKEVALUE(x,S_BCM1480_SPC_CFG_SRC7)
+#define G_BCM1480_SPC_CFG_SRC7(x)           _SB_GETVALUE(x,S_BCM1480_SPC_CFG_SRC7,M_BCM1480_SPC_CFG_SRC7)
+
+/*
+ * System Performance Counter Control Register (Table 32)
+ * Register: PERF_CNT_CFG_1
+ * BCM1480 specific
+ */
+
+#define M_BCM1480_SPC_CFG_CLEAR             _SB_MAKEMASK1(0)
+#define M_BCM1480_SPC_CFG_ENABLE            _SB_MAKEMASK1(1)
+
+/*
+ * System Performance Counters (Table 33)
+ * Registers: PERF_CNT_x
+ */
+
+#define S_BCM1480_SPC_CNT_COUNT             0
+#define M_BCM1480_SPC_CNT_COUNT             _SB_MAKEMASK(40,S_BCM1480_SPC_CNT_COUNT)
+#define V_BCM1480_SPC_CNT_COUNT(x)          _SB_MAKEVALUE(x,S_BCM1480_SPC_CNT_COUNT)
+#define G_BCM1480_SPC_CNT_COUNT(x)          _SB_GETVALUE(x,S_BCM1480_SPC_CNT_COUNT,M_BCM1480_SPC_CNT_COUNT)
+
+#define M_BCM1480_SPC_CNT_OFLOW             _SB_MAKEMASK1(40)
+
+
+/*
+ * Bus Watcher Error Status Register (Tables 36, 37)
+ * Registers: BUS_ERR_STATUS, BUS_ERR_STATUS_DEBUG
+ * Same as BCM1250.
+ */
+
+/*
+ * Bus Watcher Error Data Registers (Table 38)
+ * Registers: BUS_ERR_DATA_x
+ * Same as BCM1250.
+ */
+
+/*
+ * Bus Watcher L2 ECC Counter Register (Table 39)
+ * Register: BUS_L2_ERRORS
+ * Same as BCM1250.
+ */
+
+
+/*
+ * Bus Watcher Memory and I/O Error Counter Register (Table 40)
+ * Register: BUS_MEM_IO_ERRORS
+ * Same as BCM1250.
+ */
+
+
+/*
+ * Address Trap Registers
+ *
+ * Register layout same as BCM1250, almost.  The bus agents
+ * are different, and the address trap configuration bits are
+ * slightly different.
+ */
+
+#define M_BCM1480_ATRAP_INDEX		  _SB_MAKEMASK(4,0)
+#define M_BCM1480_ATRAP_ADDRESS		  _SB_MAKEMASK(40,0)
+
+#define S_BCM1480_ATRAP_CFG_CNT            0
+#define M_BCM1480_ATRAP_CFG_CNT            _SB_MAKEMASK(3,S_BCM1480_ATRAP_CFG_CNT)
+#define V_BCM1480_ATRAP_CFG_CNT(x)         _SB_MAKEVALUE(x,S_BCM1480_ATRAP_CFG_CNT)
+#define G_BCM1480_ATRAP_CFG_CNT(x)         _SB_GETVALUE(x,S_BCM1480_ATRAP_CFG_CNT,M_BCM1480_ATRAP_CFG_CNT)
+
+#define M_BCM1480_ATRAP_CFG_WRITE	   _SB_MAKEMASK1(3)
+#define M_BCM1480_ATRAP_CFG_ALL	  	   _SB_MAKEMASK1(4)
+#define M_BCM1480_ATRAP_CFG_INV	   	   _SB_MAKEMASK1(5)
+#define M_BCM1480_ATRAP_CFG_USESRC	   _SB_MAKEMASK1(6)
+#define M_BCM1480_ATRAP_CFG_SRCINV	   _SB_MAKEMASK1(7)
+
+#define S_BCM1480_ATRAP_CFG_AGENTID     8
+#define M_BCM1480_ATRAP_CFG_AGENTID     _SB_MAKEMASK(4,S_BCM1480_ATRAP_CFG_AGENTID)
+#define V_BCM1480_ATRAP_CFG_AGENTID(x)  _SB_MAKEVALUE(x,S_BCM1480_ATRAP_CFG_AGENTID)
+#define G_BCM1480_ATRAP_CFG_AGENTID(x)  _SB_GETVALUE(x,S_BCM1480_ATRAP_CFG_AGENTID,M_BCM1480_ATRAP_CFG_AGENTID)
+
+
+#define K_BCM1480_BUS_AGENT_CPU0            0
+#define K_BCM1480_BUS_AGENT_CPU1            1
+#define K_BCM1480_BUS_AGENT_NC              2
+#define K_BCM1480_BUS_AGENT_IOB             3
+#define K_BCM1480_BUS_AGENT_SCD             4
+#define K_BCM1480_BUS_AGENT_L2C             6
+#define K_BCM1480_BUS_AGENT_MC              7
+#define K_BCM1480_BUS_AGENT_CPU2            8
+#define K_BCM1480_BUS_AGENT_CPU3            9
+#define K_BCM1480_BUS_AGENT_PM              10
+
+#define S_BCM1480_ATRAP_CFG_CATTR           12
+#define M_BCM1480_ATRAP_CFG_CATTR           _SB_MAKEMASK(2,S_BCM1480_ATRAP_CFG_CATTR)
+#define V_BCM1480_ATRAP_CFG_CATTR(x)        _SB_MAKEVALUE(x,S_BCM1480_ATRAP_CFG_CATTR)
+#define G_BCM1480_ATRAP_CFG_CATTR(x)        _SB_GETVALUE(x,S_BCM1480_ATRAP_CFG_CATTR,M_BCM1480_ATRAP_CFG_CATTR)
+
+#define K_BCM1480_ATRAP_CFG_CATTR_IGNORE    0
+#define K_BCM1480_ATRAP_CFG_CATTR_UNC       1
+#define K_BCM1480_ATRAP_CFG_CATTR_NONCOH    2
+#define K_BCM1480_ATRAP_CFG_CATTR_COHERENT  3
+
+#define M_BCM1480_ATRAP_CFG_CATTRINV        _SB_MAKEMASK1(14)
+
+
+/*
+ * Trace Event Registers (Table 47)
+ * Same as BCM1250.
+ */
+
+/*
+ * Trace Sequence Control Registers (Table 48)
+ * Registers: TRACE_SEQUENCE_x
+ *
+ * Same as BCM1250 except for two new fields.
+ */
+
+
+#define M_BCM1480_SCD_TRSEQ_TID_MATCH_EN    _SB_MAKEMASK1(25)
+
+#define S_BCM1480_SCD_TRSEQ_SWFUNC          26
+#define M_BCM1480_SCD_TRSEQ_SWFUNC          _SB_MAKEMASK(2,S_BCM1480_SCD_TRSEQ_SWFUNC)
+#define V_BCM1480_SCD_TRSEQ_SWFUNC(x)       _SB_MAKEVALUE(x,S_BCM1480_SCD_TRSEQ_SWFUNC)
+#define G_BCM1480_SCD_TRSEQ_SWFUNC(x)       _SB_GETVALUE(x,S_BCM1480_SCD_TRSEQ_SWFUNC,M_BCM1480_SCD_TRSEQ_SWFUNC)
+
+/*
+ * Trace Control Register (Table 49)
+ * Register: TRACE_CFG
+ *
+ * Bits 0..8 are the same as the BCM1250, rest are different.
+ * Entire register is redefined below.
+ */
+
+#define M_BCM1480_SCD_TRACE_CFG_RESET       _SB_MAKEMASK1(0)
+#define M_BCM1480_SCD_TRACE_CFG_START_READ  _SB_MAKEMASK1(1)
+#define M_BCM1480_SCD_TRACE_CFG_START       _SB_MAKEMASK1(2)
+#define M_BCM1480_SCD_TRACE_CFG_STOP        _SB_MAKEMASK1(3)
+#define M_BCM1480_SCD_TRACE_CFG_FREEZE      _SB_MAKEMASK1(4)
+#define M_BCM1480_SCD_TRACE_CFG_FREEZE_FULL _SB_MAKEMASK1(5)
+#define M_BCM1480_SCD_TRACE_CFG_DEBUG_FULL  _SB_MAKEMASK1(6)
+#define M_BCM1480_SCD_TRACE_CFG_FULL        _SB_MAKEMASK1(7)
+#define M_BCM1480_SCD_TRACE_CFG_FORCE_CNT   _SB_MAKEMASK1(8)
+
+#define S_BCM1480_SCD_TRACE_CFG_MODE        16
+#define M_BCM1480_SCD_TRACE_CFG_MODE        _SB_MAKEMASK(2,S_BCM1480_SCD_TRACE_CFG_MODE)
+#define V_BCM1480_SCD_TRACE_CFG_MODE(x)     _SB_MAKEVALUE(x,S_BCM1480_SCD_TRACE_CFG_MODE)
+#define G_BCM1480_SCD_TRACE_CFG_MODE(x)     _SB_GETVALUE(x,S_BCM1480_SCD_TRACE_CFG_MODE,M_BCM1480_SCD_TRACE_CFG_MODE)
+
+#define K_BCM1480_SCD_TRACE_CFG_MODE_BLOCKERS	0
+#define K_BCM1480_SCD_TRACE_CFG_MODE_BYTEEN_INT	1
+#define K_BCM1480_SCD_TRACE_CFG_MODE_FLOW_ID	2
+
+#define S_BCM1480_SCD_TRACE_CFG_CUR_ADDR    24
+#define M_BCM1480_SCD_TRACE_CFG_CUR_ADDR    _SB_MAKEMASK(8,S_BCM1480_SCD_TRACE_CFG_CUR_ADDR)
+#define V_BCM1480_SCD_TRACE_CFG_CUR_ADDR(x) _SB_MAKEVALUE(x,S_BCM1480_SCD_TRACE_CFG_CUR_ADDR)
+#define G_BCM1480_SCD_TRACE_CFG_CUR_ADDR(x) _SB_GETVALUE(x,S_BCM1480_SCD_TRACE_CFG_CUR_ADDR,M_BCM1480_SCD_TRACE_CFG_CUR_ADDR)
+
+#endif /* _BCM1480_SCD_H */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/bigsur.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/bigsur.h
--- linux-2.6.14/include/asm-mips/sibyte/bigsur.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/bigsur.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2000,2001,2002,2003,2004 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#ifndef __ASM_SIBYTE_BIGSUR_H
+#define __ASM_SIBYTE_BIGSUR_H
+
+#include <asm/sibyte/sb1250.h>
+#include <asm/sibyte/bcm1480_int.h>
+
+#ifdef CONFIG_SIBYTE_BIGSUR
+#define SIBYTE_BOARD_NAME "BCM91x80A/B (BigSur)"
+#define SIBYTE_HAVE_PCMCIA 1
+#define SIBYTE_HAVE_IDE    1
+#endif
+
+/* Generic bus chip selects */
+#define LEDS_CS         3
+#define LEDS_PHYS       0x100a0000
+
+#ifdef SIBYTE_HAVE_IDE
+#define IDE_CS          4
+#define IDE_PHYS        0x100b0000
+#define K_GPIO_GB_IDE   4
+#define K_INT_GB_IDE    (K_INT_GPIO_0 + K_GPIO_GB_IDE)
+#endif
+
+#ifdef SIBYTE_HAVE_PCMCIA
+#define PCMCIA_CS       6
+#define PCMCIA_PHYS     0x11000000
+#define K_GPIO_PC_READY 9
+#define K_INT_PC_READY  (K_INT_GPIO_0 + K_GPIO_PC_READY)
+#endif
+
+#endif /* __ASM_SIBYTE_BIGSUR_H */
+
diff -Naur linux-2.6.14/include/asm-mips/sibyte/board.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/board.h
--- linux-2.6.14/include/asm-mips/sibyte/board.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/board.h	2005-11-17 11:44:27.000000000 -0800
@@ -21,8 +21,6 @@
 
 #include <linux/config.h>
 
-#ifdef CONFIG_SIBYTE_BOARD
-
 #if defined(CONFIG_SIBYTE_SWARM) || defined(CONFIG_SIBYTE_PTSWARM) || \
     defined(CONFIG_SIBYTE_CRHONE) || defined(CONFIG_SIBYTE_CRHINE) || \
     defined(CONFIG_SIBYTE_LITTLESUR)
@@ -37,6 +35,10 @@
 #include <asm/sibyte/carmel.h>
 #endif
 
+#ifdef CONFIG_SIBYTE_BIGSUR
+#include <asm/sibyte/bigsur.h>
+#endif
+
 #ifdef __ASSEMBLY__
 
 #ifdef LEDS_PHYS
@@ -54,16 +56,6 @@
 #define setleds(t0,t1,c0,c1,c2,c3)
 #endif /* LEDS_PHYS */
 
-#else
-
-#ifdef LEDS_PHYS
-extern void setleds(char *str);
-#else
-#define setleds(s) do { } while (0)
-#endif /* LEDS_PHYS */
-
 #endif /* __ASSEMBLY__ */
 
-#endif /* CONFIG_SIBYTE_BOARD */
-
 #endif /* _SIBYTE_BOARD_H */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_defs.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_defs.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_defs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_defs.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -97,13 +95,17 @@
     *  ordering, so be careful when adding support for new minor revs.
     ********************************************************************* */
 
-#define	SIBYTE_HDR_FMASK_1250_ALL		0x00000ff
-#define	SIBYTE_HDR_FMASK_1250_PASS1		0x0000001
-#define	SIBYTE_HDR_FMASK_1250_PASS2		0x0000002
-#define	SIBYTE_HDR_FMASK_1250_PASS3		0x0000004
-
-#define	SIBYTE_HDR_FMASK_112x_ALL		0x0000f00
-#define	SIBYTE_HDR_FMASK_112x_PASS1		0x0000100
+#define	SIBYTE_HDR_FMASK_1250_ALL		0x000000ff
+#define	SIBYTE_HDR_FMASK_1250_PASS1		0x00000001
+#define	SIBYTE_HDR_FMASK_1250_PASS2		0x00000002
+#define	SIBYTE_HDR_FMASK_1250_PASS3		0x00000004
+
+#define	SIBYTE_HDR_FMASK_112x_ALL		0x00000f00
+#define	SIBYTE_HDR_FMASK_112x_PASS1		0x00000100
+
+#define SIBYTE_HDR_FMASK_1480_ALL		0x0000f000
+#define SIBYTE_HDR_FMASK_1480_PASS1		0x00001000
+#define SIBYTE_HDR_FMASK_1480_PASS2		0x00002000
 
 /* Bit mask for chip/revision.  (use _ALL for all revisions of a chip).  */
 #define	SIBYTE_HDR_FMASK(chip, pass)					\
@@ -111,8 +113,17 @@
 #define	SIBYTE_HDR_FMASK_ALLREVS(chip)					\
     (SIBYTE_HDR_FMASK_ ## chip ## _ALL)
 
+/* Default constant value for all chips, all revisions */
 #define	SIBYTE_HDR_FMASK_ALL						\
+    (SIBYTE_HDR_FMASK_1250_ALL | SIBYTE_HDR_FMASK_112x_ALL		\
+     | SIBYTE_HDR_FMASK_1480_ALL)
+
+/* This one is used for the "original" BCM1250/BCM112x chips.  We use this
+   to weed out constants and macros that do not exist on later chips like
+   the BCM1480  */
+#define SIBYTE_HDR_FMASK_1250_112x_ALL					\
     (SIBYTE_HDR_FMASK_1250_ALL | SIBYTE_HDR_FMASK_112x_ALL)
+#define SIBYTE_HDR_FMASK_1250_112x SIBYTE_HDR_FMASK_1250_112x_ALL
 
 #ifndef SIBYTE_HDR_FEATURES
 #define	SIBYTE_HDR_FEATURES			SIBYTE_HDR_FMASK_ALL
@@ -133,6 +144,12 @@
 #define SIBYTE_HDR_FEATURE_CHIP(chip)					\
     (!! (SIBYTE_HDR_FMASK_ALLREVS(chip) & SIBYTE_HDR_FEATURES))
 
+/* True for all versions of the BCM1250 and BCM1125, but not true for
+   anything else */
+#define SIBYTE_HDR_FEATURE_1250_112x \
+      (SIBYTE_HDR_FEATURE_CHIP(1250) || SIBYTE_HDR_FEATURE_CHIP(112x))
+/*    (!!  (SIBYTE_HDR_FEATURES & SIBYHTE_HDR_FMASK_1250_112x)) */
+
 /* True if header features enabled for that rev or later, inclusive.  */
 #define SIBYTE_HDR_FEATURE(chip, pass)					\
     (!! ((SIBYTE_HDR_FMASK(chip, pass)					\
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_dma.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_dma.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_dma.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_dma.h	2005-11-17 11:44:27.000000000 -0800
@@ -7,9 +7,8 @@
     *  programming the SB1250's DMA controllers, both the data mover
     *  and the Ethernet DMA.
     *
-    *  SB1250 specification level:  User's manual 1/02/02
-    *
-    *  Author:  Mitch Lichtenberg
+    *  SB1250 specification level:  User's manual 10/21/02
+    *  BCM1280 specification level: User's manual 11/24/03
     *
     *********************************************************************
     *
@@ -58,17 +57,17 @@
 #define M_DMA_RESERVED1             _SB_MAKEMASK1(2)
 
 #define S_DMA_DESC_TYPE		    _SB_MAKE64(1)
-#define M_DMA_DESC_TYPE		    _SB_MAKE64(2,S_DMA_DESC_TYPE)
+#define M_DMA_DESC_TYPE		    _SB_MAKEMASK(2,S_DMA_DESC_TYPE)
 #define V_DMA_DESC_TYPE(x)          _SB_MAKEVALUE(x,S_DMA_DESC_TYPE)
 #define G_DMA_DESC_TYPE(x)          _SB_GETVALUE(x,S_DMA_DESC_TYPE,M_DMA_DESC_TYPE)
 
 #define K_DMA_DESC_TYPE_RING_AL		0
 #define K_DMA_DESC_TYPE_CHAIN_AL	1
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define K_DMA_DESC_TYPE_RING_UAL_WI	2
 #define K_DMA_DESC_TYPE_RING_UAL_RMW	3
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define M_DMA_EOP_INT_EN            _SB_MAKEMASK1(3)
 #define M_DMA_HWM_INT_EN            _SB_MAKEMASK1(4)
@@ -111,11 +110,11 @@
 #define M_DMA_NO_DSCR_UPDT          _SB_MAKEMASK1(4)
 #define M_DMA_L2CA		    _SB_MAKEMASK1(5)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_DMA_RX_XTRA_STATUS	    _SB_MAKEMASK1(6)
 #define M_DMA_TX_CPU_PAUSE	    _SB_MAKEMASK1(6)
 #define M_DMA_TX_FC_PAUSE_EN	    _SB_MAKEMASK1(7)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define M_DMA_MBZ1                  _SB_MAKEMASK(6,15)
 
@@ -165,14 +164,14 @@
 #define S_DMA_CURDSCR_COUNT         _SB_MAKE64(40)
 #define M_DMA_CURDSCR_COUNT         _SB_MAKEMASK(16,S_DMA_CURDSCR_COUNT)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_DMA_TX_CH_PAUSE_ON	    _SB_MAKEMASK1(56)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 /*
  * Receive Packet Drop Registers
  */
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_DMA_OODLOST_RX           _SB_MAKE64(0)
 #define M_DMA_OODLOST_RX           _SB_MAKEMASK(16,S_DMA_OODLOST_RX)
 #define G_DMA_OODLOST_RX(x)        _SB_GETVALUE(x,S_DMA_OODLOST_RX,M_DMA_OODLOST_RX)
@@ -180,7 +179,7 @@
 #define S_DMA_EOP_COUNT_RX         _SB_MAKE64(16)
 #define M_DMA_EOP_COUNT_RX         _SB_MAKEMASK(8,S_DMA_EOP_COUNT_RX)
 #define G_DMA_EOP_COUNT_RX(x)      _SB_GETVALUE(x,S_DMA_EOP_COUNT_RX,M_DMA_EOP_COUNT_RX)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 /*  *********************************************************************
     *  DMA Descriptors
@@ -201,21 +200,21 @@
 
 #define M_DMA_DSCRA_A_ADDR_OFFSET   (M_DMA_DSCRA_OFFSET | M_DMA_DSCRA_A_ADDR)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_DMA_DSCRA_A_ADDR_UA        _SB_MAKE64(0)
 #define M_DMA_DSCRA_A_ADDR_UA        _SB_MAKEMASK(40,S_DMA_DSCRA_A_ADDR_UA)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define S_DMA_DSCRA_A_SIZE          _SB_MAKE64(40)
 #define M_DMA_DSCRA_A_SIZE          _SB_MAKEMASK(9,S_DMA_DSCRA_A_SIZE)
 #define V_DMA_DSCRA_A_SIZE(x)       _SB_MAKEVALUE(x,S_DMA_DSCRA_A_SIZE)
 #define G_DMA_DSCRA_A_SIZE(x)       _SB_GETVALUE(x,S_DMA_DSCRA_A_SIZE,M_DMA_DSCRA_A_SIZE)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_DMA_DSCRA_DSCR_CNT	    _SB_MAKE64(40)
 #define M_DMA_DSCRA_DSCR_CNT	    _SB_MAKEMASK(8,S_DMA_DSCRA_DSCR_CNT)
 #define G_DMA_DSCRA_DSCR_CNT(x)	    _SB_GETVALUE(x,S_DMA_DSCRA_DSCR_CNT,M_DMA_DSCRA_DSCR_CNT)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define M_DMA_DSCRA_INTERRUPT       _SB_MAKEMASK1(49)
 #define M_DMA_DSCRA_OFFSETB	    _SB_MAKEMASK1(50)
@@ -235,12 +234,12 @@
 #define V_DMA_DSCRB_OPTIONS(x)      _SB_MAKEVALUE(x,S_DMA_DSCRB_OPTIONS)
 #define G_DMA_DSCRB_OPTIONS(x)      _SB_GETVALUE(x,S_DMA_DSCRB_OPTIONS,M_DMA_DSCRB_OPTIONS)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_DMA_DSCRB_A_SIZE        _SB_MAKE64(8)
 #define M_DMA_DSCRB_A_SIZE        _SB_MAKEMASK(14,S_DMA_DSCRB_A_SIZE)
 #define V_DMA_DSCRB_A_SIZE(x)     _SB_MAKEVALUE(x,S_DMA_DSCRB_A_SIZE)
 #define G_DMA_DSCRB_A_SIZE(x)     _SB_GETVALUE(x,S_DMA_DSCRB_A_SIZE,M_DMA_DSCRB_A_SIZE)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define R_DMA_DSCRB_ADDR            _SB_MAKE64(0x10)
 
@@ -255,12 +254,12 @@
 
 #define M_DMA_DSCRB_B_VALID         _SB_MAKEMASK1(49)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_DMA_DSCRB_PKT_SIZE_MSB    _SB_MAKE64(48)
 #define M_DMA_DSCRB_PKT_SIZE_MSB    _SB_MAKEMASK(2,S_DMA_DSCRB_PKT_SIZE_MSB)
 #define V_DMA_DSCRB_PKT_SIZE_MSB(x) _SB_MAKEVALUE(x,S_DMA_DSCRB_PKT_SIZE_MSB)
 #define G_DMA_DSCRB_PKT_SIZE_MSB(x) _SB_GETVALUE(x,S_DMA_DSCRB_PKT_SIZE_MSB,M_DMA_DSCRB_PKT_SIZE_MSB)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define S_DMA_DSCRB_PKT_SIZE        _SB_MAKE64(50)
 #define M_DMA_DSCRB_PKT_SIZE        _SB_MAKEMASK(14,S_DMA_DSCRB_PKT_SIZE)
@@ -282,15 +281,16 @@
 #define M_DMA_ETHRX_BADIP4CS        _SB_MAKEMASK1(51)
 #define M_DMA_ETHRX_DSCRERR	    _SB_MAKEMASK1(52)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
-/* Note: BADTCPCS is actually in DSCR_B options field */
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
+/* Note: This bit is in the DSCR_B options field */
 #define M_DMA_ETHRX_BADTCPCS	_SB_MAKEMASK1(0)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
+/* Note: These bits are in the DSCR_B options field */
 #define M_DMA_ETH_VLAN_FLAG	_SB_MAKEMASK1(1)
 #define M_DMA_ETH_CRC_FLAG	_SB_MAKEMASK1(2)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define S_DMA_ETHRX_RXCH            53
 #define M_DMA_ETHRX_RXCH            _SB_MAKEMASK(2,S_DMA_ETHRX_RXCH)
@@ -438,7 +438,7 @@
                                      M_DM_CUR_DSCR_DSCR_COUNT)
 
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 /*
  * Data Mover Channel Partial Result Registers
  * Register: DM_PARTIAL_0
@@ -459,10 +459,10 @@
                                        M_DM_PARTIAL_TCPCS_PARTIAL)
 
 #define M_DM_PARTIAL_ODD_BYTE         _SB_MAKEMASK1(48)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 /*
  * Data Mover CRC Definition Registers
  * Register: CRC_DEF_0
@@ -479,10 +479,10 @@
 #define V_CRC_DEF_CRC_POLY(r)         _SB_MAKEVALUE(r,S_CRC_DEF_CRC_POLY)
 #define G_CRC_DEF_CRC_POLY(r)         _SB_GETVALUE(r,S_CRC_DEF_CRC_POLY,\
                                        M_CRC_DEF_CRC_POLY)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 /*
  * Data Mover CRC/Checksum Definition Registers
  * Register: CTCP_DEF_0
@@ -511,7 +511,7 @@
 #define K_CTCP_DEF_CRC_WIDTH_1        2
 
 #define M_CTCP_DEF_CRC_BIT_ORDER      _SB_MAKEMASK1(50)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 
 /*
@@ -560,12 +560,12 @@
 #define M_DM_DSCRA_L2C_DEST         _SB_MAKEMASK1(50)
 #define M_DM_DSCRA_L2C_SRC          _SB_MAKEMASK1(51)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_DM_DSCRA_RD_BKOFF	    _SB_MAKEMASK1(52)
 #define M_DM_DSCRA_WR_BKOFF	    _SB_MAKEMASK1(53)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_DM_DSCRA_TCPCS_EN         _SB_MAKEMASK1(54)
 #define M_DM_DSCRA_TCPCS_RES        _SB_MAKEMASK1(55)
 #define M_DM_DSCRA_TCPCS_AP         _SB_MAKEMASK1(56)
@@ -574,7 +574,7 @@
 #define M_DM_DSCRA_CRC_AP           _SB_MAKEMASK1(59)
 #define M_DM_DSCRA_CRC_DFN          _SB_MAKEMASK1(60)
 #define M_DM_DSCRA_CRC_XBIT         _SB_MAKEMASK1(61)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define M_DM_DSCRA_RESERVED2        _SB_MAKEMASK(3,61)
 
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_genbus.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_genbus.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_genbus.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_genbus.h	2005-11-17 11:44:27.000000000 -0800
@@ -6,9 +6,8 @@
     *  This module contains constants and macros useful for
     *  manipulating the SB1250's Generic Bus interface
     *
-    *  SB1250 specification level:  User's manual 1/02/02
-    *
-    *  Author:  Mitch Lichtenberg
+    *  SB1250 specification level:  User's manual 10/21/02
+    *  BCM1280 specification level: User's Manual 11/14/03
     *
     *********************************************************************
     *
@@ -51,19 +50,21 @@
 #define M_IO_WIDTH_SEL		_SB_MAKEMASK(2,S_IO_WIDTH_SEL)
 #define K_IO_WIDTH_SEL_1	0
 #define K_IO_WIDTH_SEL_2	1
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) \
+    || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define K_IO_WIDTH_SEL_1L       2
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 #define K_IO_WIDTH_SEL_4	3
 #define V_IO_WIDTH_SEL(x)	_SB_MAKEVALUE(x,S_IO_WIDTH_SEL)
 #define G_IO_WIDTH_SEL(x)	_SB_GETVALUE(x,S_IO_WIDTH_SEL,M_IO_WIDTH_SEL)
 
 #define S_IO_PARITY_ENA		4
 #define M_IO_PARITY_ENA		_SB_MAKEMASK1(S_IO_PARITY_ENA)
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) \
+    || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_IO_BURST_EN		5
 #define M_IO_BURST_EN		_SB_MAKEMASK1(S_IO_BURST_EN)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 #define S_IO_PARITY_ODD		6
 #define M_IO_PARITY_ODD		_SB_MAKEMASK1(S_IO_PARITY_ODD)
 #define S_IO_NONMUX		7
@@ -96,8 +97,11 @@
 
 #define S_IO_ADDRBASE		16	 /* # bits to shift addr for this reg */
 
+#define M_IO_BLK_CACHE		_SB_MAKEMASK1(15)
+
+
 /*
- * Generic Bus Region 0 Timing Registers (Table 11-7)
+ * Generic Bus Timing 0 Registers (Table 11-7)
  */
 
 #define S_IO_ALE_WIDTH		0
@@ -105,21 +109,23 @@
 #define V_IO_ALE_WIDTH(x)	_SB_MAKEVALUE(x,S_IO_ALE_WIDTH)
 #define G_IO_ALE_WIDTH(x)	_SB_GETVALUE(x,S_IO_ALE_WIDTH,M_IO_ALE_WIDTH)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) \
+    || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_IO_EARLY_CS	        _SB_MAKEMASK1(3)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
 #define S_IO_ALE_TO_CS		4
 #define M_IO_ALE_TO_CS		_SB_MAKEMASK(2,S_IO_ALE_TO_CS)
 #define V_IO_ALE_TO_CS(x)	_SB_MAKEVALUE(x,S_IO_ALE_TO_CS)
 #define G_IO_ALE_TO_CS(x)	_SB_GETVALUE(x,S_IO_ALE_TO_CS,M_IO_ALE_TO_CS)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) \
+    || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_IO_BURST_WIDTH           _SB_MAKE64(6)
 #define M_IO_BURST_WIDTH           _SB_MAKEMASK(2,S_IO_BURST_WIDTH)
 #define V_IO_BURST_WIDTH(x)        _SB_MAKEVALUE(x,S_IO_BURST_WIDTH)
 #define G_IO_BURST_WIDTH(x)        _SB_GETVALUE(x,S_IO_BURST_WIDTH,M_IO_BURST_WIDTH)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
 #define S_IO_CS_WIDTH		8
 #define M_IO_CS_WIDTH		_SB_MAKEMASK(5,S_IO_CS_WIDTH)
@@ -141,9 +147,10 @@
 #define V_IO_ALE_TO_WRITE(x)	_SB_MAKEVALUE(x,S_IO_ALE_TO_WRITE)
 #define G_IO_ALE_TO_WRITE(x)	_SB_GETVALUE(x,S_IO_ALE_TO_WRITE,M_IO_ALE_TO_WRITE)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) \
+    || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_IO_RDY_SYNC	        _SB_MAKEMASK1(3)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
 #define S_IO_WRITE_WIDTH	4
 #define M_IO_WRITE_WIDTH	_SB_MAKEMASK(4,S_IO_WRITE_WIDTH)
@@ -183,9 +190,127 @@
 #define M_IO_TIMEOUT_INT	_SB_MAKEMASK1(10)
 #define M_IO_ILL_ADDR_INT	_SB_MAKEMASK1(11)
 #define M_IO_MULT_CS_INT	_SB_MAKEMASK1(12)
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_IO_COH_ERR	        _SB_MAKEMASK1(14)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
+
+
+/*
+ * Generic Bus Output Drive Control Register 0 (Table 14-18)
+ */
+
+#define S_IO_SLEW0		0
+#define M_IO_SLEW0		_SB_MAKEMASK(2,S_IO_SLEW0)
+#define V_IO_SLEW0(x)		_SB_MAKEVALUE(x,S_IO_SLEW0)
+#define G_IO_SLEW0(x)		_SB_GETVALUE(x,S_IO_SLEW0,M_IO_SLEW0)
+
+#define S_IO_DRV_A		2
+#define M_IO_DRV_A		_SB_MAKEMASK(2,S_IO_DRV_A)
+#define V_IO_DRV_A(x)		_SB_MAKEVALUE(x,S_IO_DRV_A)
+#define G_IO_DRV_A(x)		_SB_GETVALUE(x,S_IO_DRV_A,M_IO_DRV_A)
+
+#define S_IO_DRV_B		6
+#define M_IO_DRV_B		_SB_MAKEMASK(2,S_IO_DRV_B)
+#define V_IO_DRV_B(x)		_SB_MAKEVALUE(x,S_IO_DRV_B)
+#define G_IO_DRV_B(x)		_SB_GETVALUE(x,S_IO_DRV_B,M_IO_DRV_B)
+
+#define S_IO_DRV_C		10
+#define M_IO_DRV_C		_SB_MAKEMASK(2,S_IO_DRV_C)
+#define V_IO_DRV_C(x)		_SB_MAKEVALUE(x,S_IO_DRV_C)
+#define G_IO_DRV_C(x)		_SB_GETVALUE(x,S_IO_DRV_C,M_IO_DRV_C)
+
+#define S_IO_DRV_D		14
+#define M_IO_DRV_D		_SB_MAKEMASK(2,S_IO_DRV_D)
+#define V_IO_DRV_D(x)		_SB_MAKEVALUE(x,S_IO_DRV_D)
+#define G_IO_DRV_D(x)		_SB_GETVALUE(x,S_IO_DRV_D,M_IO_DRV_D)
+
+/*
+ * Generic Bus Output Drive Control Register 1 (Table 14-19)
+ */
+
+#define S_IO_DRV_E		2
+#define M_IO_DRV_E		_SB_MAKEMASK(2,S_IO_DRV_E)
+#define V_IO_DRV_E(x)		_SB_MAKEVALUE(x,S_IO_DRV_E)
+#define G_IO_DRV_E(x)		_SB_GETVALUE(x,S_IO_DRV_E,M_IO_DRV_E)
+
+#define S_IO_DRV_F		6
+#define M_IO_DRV_F		_SB_MAKEMASK(2,S_IO_DRV_F)
+#define V_IO_DRV_F(x)		_SB_MAKEVALUE(x,S_IO_DRV_F)
+#define G_IO_DRV_F(x)		_SB_GETVALUE(x,S_IO_DRV_F,M_IO_DRV_F)
+
+#define S_IO_SLEW1		8
+#define M_IO_SLEW1		_SB_MAKEMASK(2,S_IO_SLEW1)
+#define V_IO_SLEW1(x)		_SB_MAKEVALUE(x,S_IO_SLEW1)
+#define G_IO_SLEW1(x)		_SB_GETVALUE(x,S_IO_SLEW1,M_IO_SLEW1)
+
+#define S_IO_DRV_G		10
+#define M_IO_DRV_G		_SB_MAKEMASK(2,S_IO_DRV_G)
+#define V_IO_DRV_G(x)		_SB_MAKEVALUE(x,S_IO_DRV_G)
+#define G_IO_DRV_G(x)		_SB_GETVALUE(x,S_IO_DRV_G,M_IO_DRV_G)
+
+#define S_IO_SLEW2		12
+#define M_IO_SLEW2		_SB_MAKEMASK(2,S_IO_SLEW2)
+#define V_IO_SLEW2(x)		_SB_MAKEVALUE(x,S_IO_SLEW2)
+#define G_IO_SLEW2(x)		_SB_GETVALUE(x,S_IO_SLEW2,M_IO_SLEW2)
+
+#define S_IO_DRV_H		14
+#define M_IO_DRV_H		_SB_MAKEMASK(2,S_IO_DRV_H)
+#define V_IO_DRV_H(x)		_SB_MAKEVALUE(x,S_IO_DRV_H)
+#define G_IO_DRV_H(x)		_SB_GETVALUE(x,S_IO_DRV_H,M_IO_DRV_H)
+
+/*
+ * Generic Bus Output Drive Control Register 2 (Table 14-20)
+ */
+
+#define S_IO_DRV_J		2
+#define M_IO_DRV_J		_SB_MAKEMASK(2,S_IO_DRV_J)
+#define V_IO_DRV_J(x)		_SB_MAKEVALUE(x,S_IO_DRV_J)
+#define G_IO_DRV_J(x)		_SB_GETVALUE(x,S_IO_DRV_J,M_IO_DRV_J)
+
+#define S_IO_DRV_K		6
+#define M_IO_DRV_K		_SB_MAKEMASK(2,S_IO_DRV_K)
+#define V_IO_DRV_K(x)		_SB_MAKEVALUE(x,S_IO_DRV_K)
+#define G_IO_DRV_K(x)		_SB_GETVALUE(x,S_IO_DRV_K,M_IO_DRV_K)
+
+#define S_IO_DRV_L		10
+#define M_IO_DRV_L		_SB_MAKEMASK(2,S_IO_DRV_L)
+#define V_IO_DRV_L(x)		_SB_MAKEVALUE(x,S_IO_DRV_L)
+#define G_IO_DRV_L(x)		_SB_GETVALUE(x,S_IO_DRV_L,M_IO_DRV_L)
+
+#define S_IO_DRV_M		14
+#define M_IO_DRV_M		_SB_MAKEMASK(2,S_IO_DRV_M)
+#define V_IO_DRV_M(x)		_SB_MAKEVALUE(x,S_IO_DRV_M)
+#define G_IO_DRV_M(x)		_SB_GETVALUE(x,S_IO_DRV_M,M_IO_DRV_M)
+
+/*
+ * Generic Bus Output Drive Control Register 3 (Table 14-21)
+ */
+
+#define S_IO_SLEW3		0
+#define M_IO_SLEW3		_SB_MAKEMASK(2,S_IO_SLEW3)
+#define V_IO_SLEW3(x)		_SB_MAKEVALUE(x,S_IO_SLEW3)
+#define G_IO_SLEW3(x)		_SB_GETVALUE(x,S_IO_SLEW3,M_IO_SLEW3)
+
+#define S_IO_DRV_N		2
+#define M_IO_DRV_N		_SB_MAKEMASK(2,S_IO_DRV_N)
+#define V_IO_DRV_N(x)		_SB_MAKEVALUE(x,S_IO_DRV_N)
+#define G_IO_DRV_N(x)		_SB_GETVALUE(x,S_IO_DRV_N,M_IO_DRV_N)
+
+#define S_IO_DRV_P		6
+#define M_IO_DRV_P		_SB_MAKEMASK(2,S_IO_DRV_P)
+#define V_IO_DRV_P(x)		_SB_MAKEVALUE(x,S_IO_DRV_P)
+#define G_IO_DRV_P(x)		_SB_GETVALUE(x,S_IO_DRV_P,M_IO_DRV_P)
+
+#define S_IO_DRV_Q		10
+#define M_IO_DRV_Q		_SB_MAKEMASK(2,S_IO_DRV_Q)
+#define V_IO_DRV_Q(x)		_SB_MAKEVALUE(x,S_IO_DRV_Q)
+#define G_IO_DRV_Q(x)		_SB_GETVALUE(x,S_IO_DRV_Q,M_IO_DRV_Q)
+
+#define S_IO_DRV_R		14
+#define M_IO_DRV_R		_SB_MAKEMASK(2,S_IO_DRV_R)
+#define V_IO_DRV_R(x)		_SB_MAKEVALUE(x,S_IO_DRV_R)
+#define G_IO_DRV_R(x)		_SB_GETVALUE(x,S_IO_DRV_R,M_IO_DRV_R)
+
 
 /*
  * PCMCIA configuration register (Table 12-6)
@@ -202,6 +327,22 @@
 #define M_PCMCIA_CFG_RDYMASK	_SB_MAKEMASK1(8)
 #define M_PCMCIA_CFG_PWRCTL	_SB_MAKEMASK1(9)
 
+#if SIBYTE_HDR_FEATURE_CHIP(1480)
+#define S_PCMCIA_MODE		16
+#define M_PCMCIA_MODE		_SB_MAKEMASK(3,S_PCMCIA_MODE)
+#define V_PCMCIA_MODE(x)	_SB_MAKEVALUE(x,S_PCMCIA_MODE)
+#define G_PCMCIA_MODE(x)	_SB_GETVALUE(x,S_PCMCIA_MODE,M_PCMCIA_MODE)
+
+#define K_PCMCIA_MODE_PCMA_NOB	0	/* standard PCMCIA "A", no "B" */
+#define K_PCMCIA_MODE_IDEA_NOB	1	/* IDE "A", no "B" */
+#define K_PCMCIA_MODE_PCMIOA_NOB 2	/* PCMCIA with I/O "A", no "B" */
+#define K_PCMCIA_MODE_PCMA_PCMB 4	/* standard PCMCIA "A", standard PCMCIA "B" */
+#define K_PCMCIA_MODE_IDEA_PCMB 5	/* IDE "A", standard PCMCIA "B" */
+#define K_PCMCIA_MODE_PCMA_IDEB 6	/* standard PCMCIA "A", IDE "B" */
+#define K_PCMCIA_MODE_IDEA_IDEB 7	/* IDE "A", IDE "B" */
+#endif
+
+
 /*
  * PCMCIA status register (Table 12-7)
  */
@@ -272,5 +413,62 @@
 #define V_GPIO_INTR_TYPE14(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_TYPE14)
 #define G_GPIO_INTR_TYPE14(x)	_SB_GETVALUE(x,S_GPIO_INTR_TYPE14,M_GPIO_INTR_TYPE14)
 
+#if SIBYTE_HDR_FEATURE_CHIP(1480)
+
+/*
+ * GPIO Interrupt Additional Type Register
+ */
+
+#define K_GPIO_INTR_BOTHEDGE	0
+#define K_GPIO_INTR_RISEEDGE	1
+#define K_GPIO_INTR_UNPRED1	2
+#define K_GPIO_INTR_UNPRED2	3
+
+#define S_GPIO_INTR_ATYPEX(n)	(((n)/2)*2)
+#define M_GPIO_INTR_ATYPEX(n)	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPEX(n))
+#define V_GPIO_INTR_ATYPEX(n,x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPEX(n))
+#define G_GPIO_INTR_ATYPEX(n,x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPEX(n),M_GPIO_INTR_ATYPEX(n))
+
+#define S_GPIO_INTR_ATYPE0	0
+#define M_GPIO_INTR_ATYPE0	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE0)
+#define V_GPIO_INTR_ATYPE0(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE0)
+#define G_GPIO_INTR_ATYPE0(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE0,M_GPIO_INTR_ATYPE0)
+
+#define S_GPIO_INTR_ATYPE2	2
+#define M_GPIO_INTR_ATYPE2	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE2)
+#define V_GPIO_INTR_ATYPE2(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE2)
+#define G_GPIO_INTR_ATYPE2(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE2,M_GPIO_INTR_ATYPE2)
+
+#define S_GPIO_INTR_ATYPE4	4
+#define M_GPIO_INTR_ATYPE4	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE4)
+#define V_GPIO_INTR_ATYPE4(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE4)
+#define G_GPIO_INTR_ATYPE4(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE4,M_GPIO_INTR_ATYPE4)
+
+#define S_GPIO_INTR_ATYPE6	6
+#define M_GPIO_INTR_ATYPE6	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE6)
+#define V_GPIO_INTR_ATYPE6(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE6)
+#define G_GPIO_INTR_ATYPE6(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE6,M_GPIO_INTR_ATYPE6)
+
+#define S_GPIO_INTR_ATYPE8	8
+#define M_GPIO_INTR_ATYPE8	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE8)
+#define V_GPIO_INTR_ATYPE8(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE8)
+#define G_GPIO_INTR_ATYPE8(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE8,M_GPIO_INTR_ATYPE8)
+
+#define S_GPIO_INTR_ATYPE10	10
+#define M_GPIO_INTR_ATYPE10	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE10)
+#define V_GPIO_INTR_ATYPE10(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE10)
+#define G_GPIO_INTR_ATYPE10(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE10,M_GPIO_INTR_ATYPE10)
+
+#define S_GPIO_INTR_ATYPE12	12
+#define M_GPIO_INTR_ATYPE12	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE12)
+#define V_GPIO_INTR_ATYPE12(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE12)
+#define G_GPIO_INTR_ATYPE12(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE12,M_GPIO_INTR_ATYPE12)
+
+#define S_GPIO_INTR_ATYPE14	14
+#define M_GPIO_INTR_ATYPE14	_SB_MAKEMASK(2,S_GPIO_INTR_ATYPE14)
+#define V_GPIO_INTR_ATYPE14(x)	_SB_MAKEVALUE(x,S_GPIO_INTR_ATYPE14)
+#define G_GPIO_INTR_ATYPE14(x)	_SB_GETVALUE(x,S_GPIO_INTR_ATYPE14,M_GPIO_INTR_ATYPE14)
+#endif
+
 
 #endif
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250.h	2005-11-17 11:44:27.000000000 -0800
@@ -27,6 +27,9 @@
 
 #define SB1250_NR_IRQS 64
 
+#define BCM1480_NR_IRQS                 128
+#define BCM1480_NR_IRQS_HALF            64
+
 #define SB1250_DUART_MINOR_BASE		64
 
 #ifndef __ASSEMBLY__
@@ -35,6 +38,7 @@
 
 /* For revision/pass information */
 #include <asm/sibyte/sb1250_scd.h>
+#include <asm/sibyte/bcm1480_scd.h>
 extern unsigned int sb1_pass;
 extern unsigned int soc_pass;
 extern unsigned int soc_type;
@@ -46,6 +50,13 @@
 extern void sb1250_mask_irq(int cpu, int irq);
 extern void sb1250_unmask_irq(int cpu, int irq);
 extern void sb1250_smp_finish(void);
+
+extern void bcm1480_time_init(void);
+extern unsigned long bcm1480_gettimeoffset(void);
+extern void bcm1480_mask_irq(int cpu, int irq);
+extern void bcm1480_unmask_irq(int cpu, int irq);
+extern void bcm1480_smp_finish(void);
+
 extern void prom_printf(char *fmt, ...);
 
 #define AT_spin \
@@ -58,6 +69,6 @@
 
 #endif
 
-#define IOADDR(a) (IO_BASE + (a))
+#define IOADDR(a) ((volatile void __iomem *)(IO_BASE + (a)))
 
 #endif
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_int.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_int.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_int.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_int.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -47,6 +45,10 @@
  * First, the interrupt numbers.
  */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
+
+#define K_INT_SOURCES               64
+
 #define K_INT_WATCHDOG_TIMER_0      0
 #define K_INT_WATCHDOG_TIMER_1      1
 #define K_INT_TIMER_0               2
@@ -244,4 +246,6 @@
 #define M_LDTVECT_RAISEMBOX             0x40
 
 
+#endif	/* 1250/112x */
+
 #endif
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_l2c.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_l2c.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_l2c.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_l2c.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -89,8 +87,13 @@
 #define V_L2C_MGMT_WAY(x)           _SB_MAKEVALUE(x,S_L2C_MGMT_WAY)
 #define G_L2C_MGMT_WAY(x)           _SB_GETVALUE(x,S_L2C_MGMT_WAY,M_L2C_MGMT_WAY)
 
-#define S_L2C_MGMT_TAG              21
-#define M_L2C_MGMT_TAG              _SB_MAKEMASK(6,S_L2C_MGMT_TAG)
+#define S_L2C_MGMT_ECC_DIAG         21
+#define M_L2C_MGMT_ECC_DIAG         _SB_MAKEMASK(2,S_L2C_MGMT_ECC_DIAG)
+#define V_L2C_MGMT_ECC_DIAG(x)      _SB_MAKEVALUE(x,S_L2C_MGMT_ECC_DIAG)
+#define G_L2C_MGMT_ECC_DIAG(x)      _SB_GETVALUE(x,S_L2C_MGMT_ECC_DIAG,M_L2C_MGMT_ECC_DIAG)
+
+#define S_L2C_MGMT_TAG              23
+#define M_L2C_MGMT_TAG              _SB_MAKEMASK(4,S_L2C_MGMT_TAG)
 #define V_L2C_MGMT_TAG(x)           _SB_MAKEVALUE(x,S_L2C_MGMT_TAG)
 #define G_L2C_MGMT_TAG(x)           _SB_GETVALUE(x,S_L2C_MGMT_TAG,M_L2C_MGMT_TAG)
 
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_ldt.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_ldt.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_ldt.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_ldt.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_mac.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_mac.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_mac.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_mac.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -81,7 +79,10 @@
 #define M_MAC_RESERVED1             _SB_MAKEMASK(8,9)
 
 #define M_MAC_AP_STAT_EN            _SB_MAKEMASK1(17)
-#define M_MAC_RESERVED2		    _SB_MAKEMASK1(18)
+
+#if SIBYTE_HDR_FEATURE_CHIP(1480)
+#define M_MAC_TIMESTAMP		    _SB_MAKEMASK1(18)
+#endif
 #define M_MAC_DRP_ERRPKT_EN         _SB_MAKEMASK1(19)
 #define M_MAC_DRP_FCSERRPKT_EN      _SB_MAKEMASK1(20)
 #define M_MAC_DRP_CODEERRPKT_EN     _SB_MAKEMASK1(21)
@@ -132,9 +133,9 @@
 #define M_MAC_RX_CH_SEL_MSB	    _SB_MAKEMASK1(44)
 #endif /* 1250 PASS2 || 112x PASS1 */
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_MAC_SPLIT_CH_SEL	    _SB_MAKEMASK1(45)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define S_MAC_BYPASS_IFG            _SB_MAKE64(46)
 #define M_MAC_BYPASS_IFG            _SB_MAKEMASK(8,S_MAC_BYPASS_IFG)
@@ -176,10 +177,22 @@
 
 #define M_MAC_PORT_RESET            _SB_MAKEMASK1(8)
 
+#if (SIBYTE_HDR_FEATURE_CHIP(1250) || SIBYTE_HDR_FEATURE_CHIP(112x))
 #define M_MAC_RX_ENABLE             _SB_MAKEMASK1(10)
 #define M_MAC_TX_ENABLE             _SB_MAKEMASK1(11)
 #define M_MAC_BYP_RX_ENABLE         _SB_MAKEMASK1(12)
 #define M_MAC_BYP_TX_ENABLE         _SB_MAKEMASK1(13)
+#endif
+
+/*
+ * MAC reset information register (1280/1255)
+ */
+#if SIBYTE_HDR_FEATURE_CHIP(1480)
+#define M_MAC_RX_CH0_PAUSE_ON	_SB_MAKEMASK1(8)
+#define M_MAC_RX_CH1_PAUSE_ON	_SB_MAKEMASK1(16)
+#define M_MAC_TX_CH0_PAUSE_ON	_SB_MAKEMASK1(24)
+#define M_MAC_TX_CH1_PAUSE_ON	_SB_MAKEMASK1(32)
+#endif
 
 /*
  * MAC DMA Control Register
@@ -267,12 +280,12 @@
 #define V_MAC_IFG_RX(x)             _SB_MAKEVALUE(x,S_MAC_IFG_RX)
 #define G_MAC_IFG_RX(x)             _SB_GETVALUE(x,S_MAC_IFG_RX,M_MAC_IFG_RX)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_MAC_PRE_LEN               _SB_MAKE64(0)
 #define M_MAC_PRE_LEN               _SB_MAKEMASK(6,S_MAC_PRE_LEN)
 #define V_MAC_PRE_LEN(x)            _SB_MAKEVALUE(x,S_MAC_PRE_LEN)
 #define G_MAC_PRE_LEN(x)            _SB_GETVALUE(x,S_MAC_PRE_LEN,M_MAC_PRE_LEN)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 #define S_MAC_IFG_TX                _SB_MAKE64(6)
 #define M_MAC_IFG_TX                _SB_MAKEMASK(6,S_MAC_IFG_TX)
@@ -458,9 +471,9 @@
 #define V_MAC_COUNTER_ADDR(x)       _SB_MAKEVALUE(x,S_MAC_COUNTER_ADDR)
 #define G_MAC_COUNTER_ADDR(x)       _SB_GETVALUE(x,S_MAC_COUNTER_ADDR,M_MAC_COUNTER_ADDR)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define M_MAC_TX_PAUSE_ON	    _SB_MAKEMASK1(52)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 /*
  * MAC Fifo Pointer Registers (Table 9-19)    [Debug register]
@@ -594,7 +607,7 @@
 #define V_MAC_IPHDR_OFFSET(x)	_SB_MAKEVALUE(x,S_MAC_IPHDR_OFFSET)
 #define G_MAC_IPHDR_OFFSET(x)	_SB_GETVALUE(x,S_MAC_IPHDR_OFFSET,M_MAC_IPHDR_OFFSET)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define S_MAC_RX_CRC_OFFSET     _SB_MAKE64(16)
 #define M_MAC_RX_CRC_OFFSET     _SB_MAKEMASK(8,S_MAC_RX_CRC_OFFSET)
 #define V_MAC_RX_CRC_OFFSET(x)	_SB_MAKEVALUE(x,S_MAC_RX_CRC_OFFSET)
@@ -612,7 +625,7 @@
 #define M_MAC_RX_CH_MSN_SEL     _SB_MAKEMASK(8,S_MAC_RX_CH_MSN_SEL)
 #define V_MAC_RX_CH_MSN_SEL(x)	_SB_MAKEVALUE(x,S_MAC_RX_CH_MSN_SEL)
 #define G_MAC_RX_CH_MSN_SEL(x)	_SB_GETVALUE(x,S_MAC_RX_CH_MSN_SEL,M_MAC_RX_CH_MSN_SEL)
-#endif /* 1250 PASS3 || 112x PASS1 */
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
 
 /*
  * MAC Receive Channel Select Registers (Table 9-25)
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_mc.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_mc.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_mc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_mc.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -324,6 +322,10 @@
 #define K_MC_tRFC_DEFAULT         12
 #define V_MC_tRFC_DEFAULT         V_MC_tRFC(K_MC_tRFC_DEFAULT)
 
+#if SIBYTE_HDR_FEATURE(1250, PASS3)
+#define M_MC_tRFC_PLUS16          _SB_MAKEMASK1(51)	/* 1250C3 and later.  */
+#endif
+
 #define S_MC_tCwCr                40
 #define M_MC_tCwCr                _SB_MAKEMASK(4,S_MC_tCwCr)
 #define V_MC_tCwCr(x)             _SB_MAKEVALUE(x,S_MC_tCwCr)
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_regs.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_regs.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_regs.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_regs.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  01/02/2002
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -61,6 +59,8 @@
  * XXX: can't remove MC base 0 if 112x, since it's used by other macros,
  * since there is one reg there (but it could get its addr/offset constant).
  */
+
+#if SIBYTE_HDR_FEATURE_1250_112x		/* This MC only on 1250 & 112x */
 #define A_MC_BASE_0                 0x0010051000
 #define A_MC_BASE_1                 0x0010052000
 #define MC_REGISTER_SPACING         0x1000
@@ -101,10 +101,14 @@
 #define R_MC_TEST_ECC               0x0000000420
 #define R_MC_MCLK_CFG               0x0000000500
 
+#endif	/* 1250 & 112x */
+
 /*  *********************************************************************
     * L2 Cache Control Registers
     ********************************************************************* */
 
+#if SIBYTE_HDR_FEATURE_1250_112x	/* This L2C only on 1250/112x */
+
 #define A_L2_READ_TAG               0x0010040018
 #define A_L2_ECC_TAG                0x0010040038
 #if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1)
@@ -125,13 +129,16 @@
 #define A_L2_READ_ADDRESS           A_L2_READ_TAG
 #define A_L2_EEC_ADDRESS            A_L2_ECC_TAG
 
+#endif
 
 /*  *********************************************************************
     * PCI Interface Registers
     ********************************************************************* */
 
+#if SIBYTE_HDR_FEATURE_1250_112x	/* This PCI/HT only on 1250/112x */
 #define A_PCI_TYPE00_HEADER         0x00DE000000
 #define A_PCI_TYPE01_HEADER         0x00DE000800
+#endif
 
 
 /*  *********************************************************************
@@ -264,15 +271,15 @@
     ********************************************************************* */
 
 
+#if SIBYTE_HDR_FEATURE_1250_112x		/* This MC only on 1250 & 112x */
 #define R_DUART_NUM_PORTS           2
 
 #define A_DUART                     0x0010060000
 
-#define A_DUART_REG(r)
-
 #define DUART_CHANREG_SPACING       0x100
 #define A_DUART_CHANREG(chan,reg)   (A_DUART + DUART_CHANREG_SPACING*(chan) + (reg))
 #define R_DUART_CHANREG(chan,reg)   (DUART_CHANREG_SPACING*(chan) + (reg))
+#endif	/* 1250 & 112x */
 
 #define R_DUART_MODE_REG_1	    0x100
 #define R_DUART_MODE_REG_2	    0x110
@@ -307,11 +314,13 @@
 
 #define DUART_IMRISR_SPACING        0x20
 
+#if SIBYTE_HDR_FEATURE_1250_112x		/* This MC only on 1250 & 112x */
 #define R_DUART_IMRREG(chan)	    (R_DUART_IMR_A + (chan)*DUART_IMRISR_SPACING)
 #define R_DUART_ISRREG(chan)	    (R_DUART_ISR_A + (chan)*DUART_IMRISR_SPACING)
 
 #define A_DUART_IMRREG(chan)	    (A_DUART + R_DUART_IMRREG(chan))
 #define A_DUART_ISRREG(chan)	    (A_DUART + R_DUART_ISRREG(chan))
+#endif	/* 1250 & 112x */
 
 
 
@@ -368,6 +377,8 @@
     ********************************************************************* */
 
 
+#if SIBYTE_HDR_FEATURE_1250_112x	/* sync serial only on 1250/112x */
+
 #define A_SER_BASE_0                0x0010060400
 #define A_SER_BASE_1                0x0010060800
 #define SER_SPACING                 0x400
@@ -457,6 +468,8 @@
 #define R_SER_RMON_RX_ERRORS        0x000001F0
 #define R_SER_RMON_RX_BADADDR       0x000001F8
 
+#endif	/* 1250/112x */
+
 /*  *********************************************************************
     * Generic Bus Registers
     ********************************************************************* */
@@ -634,12 +647,13 @@
 
 #if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
 #define A_SCD_SCRATCH		   0x0010020C10
+#endif /* 1250 PASS2 || 112x PASS1 */
 
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define A_SCD_ZBBUS_CYCLE_COUNT	   0x0010030000
 #define A_SCD_ZBBUS_CYCLE_CP0	   0x0010020C00
 #define A_SCD_ZBBUS_CYCLE_CP1	   0x0010020C08
-#endif /* 1250 PASS2 || 112x PASS1 */
-
+#endif
 
 /*  *********************************************************************
     * System Control Registers
@@ -667,15 +681,16 @@
 #define A_ADDR_TRAP_CFG_1           0x0010020448
 #define A_ADDR_TRAP_CFG_2           0x0010020450
 #define A_ADDR_TRAP_CFG_3           0x0010020458
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 #define A_ADDR_TRAP_REG_DEBUG	    0x0010020460
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
 
 /*  *********************************************************************
     * System Interrupt Mapper Registers
     ********************************************************************* */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
 #define A_IMR_CPU0_BASE                 0x0010020000
 #define A_IMR_CPU1_BASE                 0x0010022000
 #define IMR_REGISTER_SPACING            0x2000
@@ -700,6 +715,7 @@
 #define R_IMR_INTERRUPT_STATUS_COUNT    7
 #define R_IMR_INTERRUPT_MAP_BASE        0x0200
 #define R_IMR_INTERRUPT_MAP_COUNT       64
+#endif	/* 1250/112x */
 
 /*  *********************************************************************
     * System Performance Counter Registers
@@ -718,6 +734,7 @@
 #define A_SCD_BUS_ERR_STATUS        0x0010020880
 #if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
 #define A_SCD_BUS_ERR_STATUS_DEBUG  0x00100208D0
+#define A_BUS_ERR_STATUS_DEBUG  0x00100208D0
 #endif /* 1250 PASS2 || 112x PASS1 */
 #define A_BUS_ERR_DATA_0            0x00100208A0
 #define A_BUS_ERR_DATA_1            0x00100208A8
@@ -798,6 +815,7 @@
     *  Physical Address Map
     ********************************************************************* */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
 #define A_PHYS_MEMORY_0                 _SB_MAKE64(0x0000000000)
 #define A_PHYS_MEMORY_SIZE              _SB_MAKE64((256*1024*1024))
 #define A_PHYS_SYSTEM_CTL               _SB_MAKE64(0x0010000000)
@@ -831,6 +849,7 @@
 #define A_PHYS_L2CACHE_WAY1             _SB_MAKE64(0x00D01A0000)
 #define A_PHYS_L2CACHE_WAY2             _SB_MAKE64(0x00D01C0000)
 #define A_PHYS_L2CACHE_WAY3             _SB_MAKE64(0x00D01E0000)
+#endif
 
 
 #endif
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_scd.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_scd.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_scd.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_scd.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -51,26 +49,70 @@
 #define V_SYS_REVISION(x)           _SB_MAKEVALUE(x,S_SYS_REVISION)
 #define G_SYS_REVISION(x)           _SB_GETVALUE(x,S_SYS_REVISION,M_SYS_REVISION)
 
-#if SIBYTE_HDR_FEATURE_CHIP(1250)
-#define K_SYS_REVISION_BCM1250_PASS1	1
-#define K_SYS_REVISION_BCM1250_PASS2	3
-#define K_SYS_REVISION_BCM1250_A10	11
-#define K_SYS_REVISION_BCM1250_PASS2_2	16
-#define K_SYS_REVISION_BCM1250_B2	17
-#define K_SYS_REVISION_BCM1250_PASS3	32
-#define K_SYS_REVISION_BCM1250_C1	33
+#define K_SYS_REVISION_BCM1250_PASS1	0x01
 
+#define K_SYS_REVISION_BCM1250_PASS2	0x03
+#define K_SYS_REVISION_BCM1250_A1	0x03	/* Pass 2.0 WB */
+#define K_SYS_REVISION_BCM1250_A2	0x04	/* Pass 2.0 FC */
+#define K_SYS_REVISION_BCM1250_A3	0x05	/* Pass 2.1 FC */
+#define K_SYS_REVISION_BCM1250_A4	0x06	/* Pass 2.1 WB */
+#define K_SYS_REVISION_BCM1250_A6	0x07	/* OR 0x04 (A2) w/WID != 0 */
+#define K_SYS_REVISION_BCM1250_A8	0x0b	/* A8/A10 */
+#define K_SYS_REVISION_BCM1250_A9	0x08
+#define K_SYS_REVISION_BCM1250_A10	K_SYS_REVISION_BCM1250_A8
+
+#define K_SYS_REVISION_BCM1250_PASS2_2	0x10
+#define K_SYS_REVISION_BCM1250_B0	K_SYS_REVISION_BCM1250_B1
+#define K_SYS_REVISION_BCM1250_B1	0x10
+#define K_SYS_REVISION_BCM1250_B2	0x11
+
+#define K_SYS_REVISION_BCM1250_C0	0x20
+#define K_SYS_REVISION_BCM1250_C1	0x21
+#define K_SYS_REVISION_BCM1250_C2	0x22
+#define K_SYS_REVISION_BCM1250_C3	0x23
+
+#if SIBYTE_HDR_FEATURE_CHIP(1250)
 /* XXX: discourage people from using these constants.  */
 #define K_SYS_REVISION_PASS1	    K_SYS_REVISION_BCM1250_PASS1
 #define K_SYS_REVISION_PASS2	    K_SYS_REVISION_BCM1250_PASS2
 #define K_SYS_REVISION_PASS2_2	    K_SYS_REVISION_BCM1250_PASS2_2
 #define K_SYS_REVISION_PASS3	    K_SYS_REVISION_BCM1250_PASS3
+#define K_SYS_REVISION_BCM1250_PASS3	K_SYS_REVISION_BCM1250_C0
 #endif /* 1250 */
 
-#if SIBYTE_HDR_FEATURE_CHIP(112x)
-#define K_SYS_REVISION_BCM112x_A1	32
-#define K_SYS_REVISION_BCM112x_A2	33
-#endif /* 112x */
+#define K_SYS_REVISION_BCM112x_A1	0x20
+#define K_SYS_REVISION_BCM112x_A2	0x21
+#define K_SYS_REVISION_BCM112x_A3	0x22
+#define K_SYS_REVISION_BCM112x_A4	0x23
+
+#define K_SYS_REVISION_BCM1480_S0	0x01
+#define K_SYS_REVISION_BCM1480_A1	0x02
+#define K_SYS_REVISION_BCM1480_A2	0x03
+#define K_SYS_REVISION_BCM1480_A3	0x04
+#define K_SYS_REVISION_BCM1480_B0	0x11
+
+/*Cache size - 23:20  of revision register*/
+#define S_SYS_L2C_SIZE            _SB_MAKE64(20)
+#define M_SYS_L2C_SIZE            _SB_MAKEMASK(4,S_SYS_L2C_SIZE)
+#define V_SYS_L2C_SIZE(x)         _SB_MAKEVALUE(x,S_SYS_L2C_SIZE)
+#define G_SYS_L2C_SIZE(x)         _SB_GETVALUE(x,S_SYS_L2C_SIZE,M_SYS_L2C_SIZE)
+
+#define K_SYS_L2C_SIZE_1MB	0
+#define K_SYS_L2C_SIZE_512KB	5
+#define K_SYS_L2C_SIZE_256KB	2
+#define K_SYS_L2C_SIZE_128KB	1
+
+#define K_SYS_L2C_SIZE_BCM1250	K_SYS_L2C_SIZE_512KB
+#define K_SYS_L2C_SIZE_BCM1125	K_SYS_L2C_SIZE_256KB
+#define K_SYS_L2C_SIZE_BCM1122	K_SYS_L2C_SIZE_128KB
+
+
+/* Number of CPU cores, bits 27:24  of revision register*/
+#define S_SYS_NUM_CPUS            _SB_MAKE64(24)
+#define M_SYS_NUM_CPUS            _SB_MAKEMASK(4,S_SYS_NUM_CPUS)
+#define V_SYS_NUM_CPUS(x)         _SB_MAKEVALUE(x,S_SYS_NUM_CPUS)
+#define G_SYS_NUM_CPUS(x)         _SB_GETVALUE(x,S_SYS_NUM_CPUS,M_SYS_NUM_CPUS)
+
 
 /* XXX: discourage people from using these constants.  */
 #define S_SYS_PART                  _SB_MAKE64(16)
@@ -83,6 +125,8 @@
 #define K_SYS_PART_BCM1120          0x1121
 #define K_SYS_PART_BCM1125          0x1123
 #define K_SYS_PART_BCM1125H         0x1124
+#define K_SYS_PART_BCM1122          0x1113
+
 
 /* The "peripheral set" (SOC type) is the low 4 bits of the "part" field.  */
 #define S_SYS_SOC_TYPE              _SB_MAKE64(16)
@@ -96,6 +140,8 @@
 #define K_SYS_SOC_TYPE_BCM1125      0x3
 #define K_SYS_SOC_TYPE_BCM1125H     0x4
 #define K_SYS_SOC_TYPE_BCM1250_ALT2 0x5		/* 1250pass2 w/ 1/2 L2.  */
+#define K_SYS_SOC_TYPE_BCM1x80      0x6
+#define K_SYS_SOC_TYPE_BCM1x55      0x7
 
 /*
  * Calculate correct SOC type given a copy of system revision register.
@@ -127,10 +173,12 @@
 #define V_SYS_WID(x)                _SB_MAKEVALUE(x,S_SYS_WID)
 #define G_SYS_WID(x)                _SB_GETVALUE(x,S_SYS_WID,M_SYS_WID)
 
-/* System Manufacturing Register
-* Register: SCD_SYSTEM_MANUF
-*/
+/*
+ * System Manufacturing Register
+ * Register: SCD_SYSTEM_MANUF
+ */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
 /* Wafer ID: bits 31:0 */
 #define S_SYS_WAFERID1_200        _SB_MAKE64(0)
 #define M_SYS_WAFERID1_200        _SB_MAKEMASK(32,S_SYS_WAFERID1_200)
@@ -139,8 +187,8 @@
 
 #define S_SYS_BIN                 _SB_MAKE64(32)
 #define M_SYS_BIN                 _SB_MAKEMASK(4,S_SYS_BIN)
-#define V_SYS_BIN                 _SB_MAKEVALUE(x,S_SYS_BIN)
-#define G_SYS_BIN                 _SB_GETVALUE(x,S_SYS_BIN,M_SYS_BIN)
+#define V_SYS_BIN(x)              _SB_MAKEVALUE(x,S_SYS_BIN)
+#define G_SYS_BIN(x)              _SB_GETVALUE(x,S_SYS_BIN,M_SYS_BIN)
 
 /* Wafer ID: bits 39:36 */
 #define S_SYS_WAFERID2_200        _SB_MAKE64(36)
@@ -163,12 +211,14 @@
 #define M_SYS_YPOS                _SB_MAKEMASK(6,S_SYS_YPOS)
 #define V_SYS_YPOS(x)             _SB_MAKEVALUE(x,S_SYS_YPOS)
 #define G_SYS_YPOS(x)             _SB_GETVALUE(x,S_SYS_YPOS,M_SYS_YPOS)
+#endif
 
 /*
  * System Config Register (Table 4-2)
  * Register: SCD_SYSTEM_CFG
  */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
 #define M_SYS_LDT_PLL_BYP           _SB_MAKEMASK1(3)
 #define M_SYS_PCI_SYNC_TEST_MODE    _SB_MAKEMASK1(4)
 #define M_SYS_IOB0_DIV              _SB_MAKEMASK1(5)
@@ -253,6 +303,8 @@
 #define M_SYS_SW_FLAG		    _SB_MAKEMASK1(63)
 #endif /* 1250 PASS2 || 112x PASS1 */
 
+#endif
+
 
 /*
  * Mailbox Registers (Table 4-3)
@@ -326,6 +378,7 @@
  * System Performance Counters
  */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
 #define S_SPC_CFG_SRC0            0
 #define M_SPC_CFG_SRC0            _SB_MAKEMASK(8,S_SPC_CFG_SRC0)
 #define V_SPC_CFG_SRC0(x)         _SB_MAKEVALUE(x,S_SPC_CFG_SRC0)
@@ -348,6 +401,7 @@
 
 #define M_SPC_CFG_CLEAR		_SB_MAKEMASK1(32)
 #define M_SPC_CFG_ENABLE	_SB_MAKEMASK1(33)
+#endif
 
 
 /*
@@ -412,6 +466,7 @@
  * Address Trap Registers
  */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
 #define M_ATRAP_INDEX		  _SB_MAKEMASK(4,0)
 #define M_ATRAP_ADDRESS		  _SB_MAKEMASK(40,0)
 
@@ -436,7 +491,6 @@
 #define K_BUS_AGENT_IOB0	2
 #define K_BUS_AGENT_IOB1	3
 #define K_BUS_AGENT_SCD	4
-#define K_BUS_AGENT_RESERVED	5
 #define K_BUS_AGENT_L2C	6
 #define K_BUS_AGENT_MC	7
 
@@ -454,10 +508,14 @@
 #define K_ATRAP_CFG_CATTR_NOTNONCOH	6
 #define K_ATRAP_CFG_CATTR_NOTCOHERENT   7
 
+#endif	/* 1250/112x */
+
 /*
  * Trace Buffer Config register
  */
 
+#if SIBYTE_HDR_FEATURE_1250_112x
+
 #define M_SCD_TRACE_CFG_RESET           _SB_MAKEMASK1(0)
 #define M_SCD_TRACE_CFG_START_READ      _SB_MAKEMASK1(1)
 #define M_SCD_TRACE_CFG_START           _SB_MAKEMASK1(2)
@@ -475,6 +533,8 @@
 #define V_SCD_TRACE_CFG_CUR_ADDR(x)     _SB_MAKEVALUE(x,S_SCD_TRACE_CFG_CUR_ADDR)
 #define G_SCD_TRACE_CFG_CUR_ADDR(x)     _SB_GETVALUE(x,S_SCD_TRACE_CFG_CUR_ADDR,M_SCD_TRACE_CFG_CUR_ADDR)
 
+#endif	/* 1250/112x */
+
 /*
  * Trace Event registers
  */
@@ -578,5 +638,7 @@
 #define M_SCD_TRSEQ_DEBUGPIN            _SB_MAKEMASK1(20)
 #define M_SCD_TRSEQ_DEBUGCPU            _SB_MAKEMASK1(21)
 #define M_SCD_TRSEQ_CLEARUSE            _SB_MAKEMASK1(22)
+#define M_SCD_TRSEQ_ALLD_A              _SB_MAKEMASK1(23)
+#define M_SCD_TRSEQ_ALL_A               _SB_MAKEMASK1(24)
 
 #endif
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_smbus.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_smbus.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_smbus.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_smbus.h	2005-11-17 11:44:27.000000000 -0800
@@ -6,9 +6,8 @@
     *  This module contains constants and macros useful for
     *  manipulating the SB1250's SMbus devices.
     *
-    *  SB1250 specification level:  01/02/2002
-    *
-    *  Author:  Mitch Lichtenberg
+    *  SB1250 specification level:  10/21/02
+    *  BCM1280 specification level:  11/24/03
     *
     *********************************************************************
     *
@@ -47,6 +46,7 @@
 
 #define K_SMB_FREQ_400KHZ	    0x1F
 #define K_SMB_FREQ_100KHZ	    0x7D
+#define K_SMB_FREQ_10KHZ	    1250
 
 #define S_SMB_CMD                   0
 #define M_SMB_CMD                   _SB_MAKEMASK(8,S_SMB_CMD)
@@ -58,7 +58,11 @@
 
 #define M_SMB_ERR_INTR              _SB_MAKEMASK1(0)
 #define M_SMB_FINISH_INTR           _SB_MAKEMASK1(1)
-#define M_SMB_DATA_OUT              _SB_MAKEMASK1(4)
+
+#define S_SMB_DATA_OUT              4
+#define M_SMB_DATA_OUT              _SB_MAKEMASK1(S_SMB_DATA_OUT)
+#define V_SMB_DATA_OUT(x)           _SB_MAKEVALUE(x,S_SMB_DATA_OUT)
+
 #define M_SMB_DATA_DIR              _SB_MAKEMASK1(5)
 #define M_SMB_DATA_DIR_OUTPUT       M_SMB_DATA_DIR
 #define M_SMB_CLK_OUT               _SB_MAKEMASK1(6)
@@ -71,8 +75,23 @@
 #define M_SMB_BUSY                  _SB_MAKEMASK1(0)
 #define M_SMB_ERROR                 _SB_MAKEMASK1(1)
 #define M_SMB_ERROR_TYPE            _SB_MAKEMASK1(2)
-#define M_SMB_REF                   _SB_MAKEMASK1(6)
-#define M_SMB_DATA_IN               _SB_MAKEMASK1(7)
+
+#if SIBYTE_HDR_FEATURE(1250, PASS3) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
+#define S_SMB_SCL_IN                5
+#define M_SMB_SCL_IN                _SB_MAKEMASK1(S_SMB_SCL_IN)
+#define V_SMB_SCL_IN(x)             _SB_MAKEVALUE(x,S_SMB_SCL_IN)
+#define G_SMB_SCL_IN(x)             _SB_GETVALUE(x,S_SMB_SCL_IN,M_SMB_SCL_IN)
+#endif /* 1250 PASS3 || 112x PASS1 || 1480 */
+
+#define S_SMB_REF                   6
+#define M_SMB_REF                   _SB_MAKEMASK1(S_SMB_REF)
+#define V_SMB_REF(x)                _SB_MAKEVALUE(x,S_SMB_REF)
+#define G_SMB_REF(x)                _SB_GETVALUE(x,S_SMB_REF,M_SMB_REF)
+
+#define S_SMB_DATA_IN               7
+#define M_SMB_DATA_IN               _SB_MAKEMASK1(S_SMB_DATA_IN)
+#define V_SMB_DATA_IN(x)            _SB_MAKEVALUE(x,S_SMB_DATA_IN)
+#define G_SMB_DATA_IN(x)            _SB_GETVALUE(x,S_SMB_DATA_IN,M_SMB_DATA_IN)
 
 /*
  * SMBus Start/Command registers (Table 14-9)
@@ -132,16 +151,14 @@
 #define V_SPEC_MB(x)                _SB_MAKEVALUE(x,S_SPEC_PEC)
 
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 
 #define S_SMB_CMDH                  8
-#define M_SMB_CMDH                  _SB_MAKEMASK(8,S_SMBH_CMD)
-#define V_SMB_CMDH(x)               _SB_MAKEVALUE(x,S_SMBH_CMD)
+#define M_SMB_CMDH                  _SB_MAKEMASK(8,S_SMB_CMDH)
+#define V_SMB_CMDH(x)               _SB_MAKEVALUE(x,S_SMB_CMDH)
 
 #define M_SMB_EXTEND		    _SB_MAKEMASK1(14)
 
-#define M_SMB_DIR		    _SB_MAKEMASK1(13)
-
 #define S_SMB_DFMT                  8
 #define M_SMB_DFMT                  _SB_MAKEMASK(3,S_SMB_DFMT)
 #define V_SMB_DFMT(x)               _SB_MAKEVALUE(x,S_SMB_DFMT)
@@ -165,6 +182,23 @@
 #define V_SMB_DFMT_CMD5BYTE	    V_SMB_DFMT(K_SMB_DFMT_CMD5BYTE)
 #define V_SMB_DFMT_RESERVED	    V_SMB_DFMT(K_SMB_DFMT_RESERVED)
 
-#endif /* 1250 PASS2 || 112x PASS1 */
+#define S_SMB_AFMT                  11
+#define M_SMB_AFMT                  _SB_MAKEMASK(2,S_SMB_AFMT)
+#define V_SMB_AFMT(x)               _SB_MAKEVALUE(x,S_SMB_AFMT)
+#define G_SMB_AFMT(x)               _SB_GETVALUE(x,S_SMB_AFMT,M_SMB_AFMT)
+
+#define K_SMB_AFMT_NONE             0
+#define K_SMB_AFMT_ADDR             1
+#define K_SMB_AFMT_ADDR_CMD1BYTE    2
+#define K_SMB_AFMT_ADDR_CMD2BYTE    3
+
+#define V_SMB_AFMT_NONE		    V_SMB_AFMT(K_SMB_AFMT_NONE)
+#define V_SMB_AFMT_ADDR		    V_SMB_AFMT(K_SMB_AFMT_ADDR)
+#define V_SMB_AFMT_ADDR_CMD1BYTE    V_SMB_AFMT(K_SMB_AFMT_ADDR_CMD1BYTE)
+#define V_SMB_AFMT_ADDR_CMD2BYTE    V_SMB_AFMT(K_SMB_AFMT_ADDR_CMD2BYTE)
+
+#define M_SMB_DIR		    _SB_MAKEMASK1(13)
+
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
 #endif
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_syncser.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_syncser.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_syncser.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_syncser.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
diff -Naur linux-2.6.14/include/asm-mips/sibyte/sb1250_uart.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_uart.h
--- linux-2.6.14/include/asm-mips/sibyte/sb1250_uart.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/sb1250_uart.h	2005-11-17 11:44:27.000000000 -0800
@@ -8,8 +8,6 @@
     *
     *  SB1250 specification level:  User's manual 1/02/02
     *
-    *  Author:  Mitch Lichtenberg
-    *
     *********************************************************************
     *
     *  Copyright 2000,2001,2002,2003
@@ -240,7 +238,12 @@
  */
 
 #define M_DUART_ISR_TX_A            _SB_MAKEMASK1(0)
-#define M_DUART_ISR_RX_A            _SB_MAKEMASK1(1)
+
+#define S_DUART_ISR_RX_A            1
+#define M_DUART_ISR_RX_A            _SB_MAKEMASK1(S_DUART_ISR_RX_A)
+#define V_DUART_ISR_RX_A(x)         _SB_MAKEVALUE(x,S_DUART_ISR_RX_A)
+#define G_DUART_ISR_RX_A(x)         _SB_GETVALUE(x,S_DUART_ISR_RX_A,M_DUART_ISR_RX_A)
+
 #define M_DUART_ISR_BRK_A           _SB_MAKEMASK1(2)
 #define M_DUART_ISR_IN_A            _SB_MAKEMASK1(3)
 #define M_DUART_ISR_TX_B            _SB_MAKEMASK1(4)
@@ -331,7 +334,7 @@
 #define M_DUART_OUT_PIN_CLR(chan) \
     (chan == 0 ? M_DUART_OUT_PIN_CLR0 : M_DUART_OUT_PIN_CLR1)
 
-#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1)
+#if SIBYTE_HDR_FEATURE(1250, PASS2) || SIBYTE_HDR_FEATURE(112x, PASS1) || SIBYTE_HDR_FEATURE_CHIP(1480)
 /*
  * Full Interrupt Control Register
  */
@@ -345,7 +348,7 @@
 #define M_DUART_INT_TIME           _SB_MAKEMASK(4,S_DUART_INT_TIME)
 #define V_DUART_INT_TIME(x)        _SB_MAKEVALUE(x,S_DUART_INT_TIME)
 #define G_DUART_INT_TIME(x)        _SB_GETVALUE(x,S_DUART_INT_TIME,M_DUART_INT_TIME)
-#endif /* 1250 PASS2 || 112x PASS1 */
+#endif /* 1250 PASS2 || 112x PASS1 || 1480 */
 
 
 /* ********************************************************************** */
diff -Naur linux-2.6.14/include/asm-mips/sibyte/swarm.h linux-mips-2.6.14.orig/include/asm-mips/sibyte/swarm.h
--- linux-2.6.14/include/asm-mips/sibyte/swarm.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sibyte/swarm.h	2005-11-17 11:44:27.000000000 -0800
@@ -34,7 +34,7 @@
 #define SIBYTE_DEFAULT_CONSOLE "ttyS0,115200"
 #endif
 #ifdef CONFIG_SIBYTE_LITTLESUR
-#define SIBYTE_BOARD_NAME "BCM1250C2 (LittleSur)"
+#define SIBYTE_BOARD_NAME "BCM91250C2 (LittleSur)"
 #define SIBYTE_HAVE_PCMCIA 0
 #define SIBYTE_HAVE_IDE    1
 #define SIBYTE_DEFAULT_CONSOLE "cfe0"
diff -Naur linux-2.6.14/include/asm-mips/sigcontext.h linux-mips-2.6.14.orig/include/asm-mips/sigcontext.h
--- linux-2.6.14/include/asm-mips/sigcontext.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sigcontext.h	2005-11-17 11:44:27.000000000 -0800
@@ -27,14 +27,15 @@
 	unsigned int		sc_fpc_csr;
 	unsigned int		sc_fpc_eir;	/* Unused */
 	unsigned int		sc_used_math;
-	unsigned int		sc_ssflags;	/* Unused */
+	unsigned int		sc_dsp;		/* dsp status, was sc_ssflags */
 	unsigned long long	sc_mdhi;
 	unsigned long long	sc_mdlo;
-
-	unsigned int		sc_cause;	/* Unused */
-	unsigned int		sc_badvaddr;	/* Unused */
-
-	unsigned long		sc_sigset[4];	/* kernel's sigset_t */
+	unsigned long		sc_hi1;		/* Was sc_cause */
+	unsigned long		sc_lo1;		/* Was sc_badvaddr */
+	unsigned long		sc_hi2;		/* Was sc_sigset[4] */
+	unsigned long		sc_lo2;
+	unsigned long		sc_hi3;
+	unsigned long		sc_lo3;
 };
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
@@ -48,19 +49,19 @@
  * Warning: this structure illdefined with sc_badvaddr being just an unsigned
  * int so it was changed to unsigned long in 2.6.0-test1.  This may break
  * binary compatibility - no prisoners.
+ * DSP ASE in 2.6.12-rc4.  Turn sc_mdhi and sc_mdlo into an array of four
+ * entries, add sc_dsp and sc_reserved for padding.  No prisoners.
  */
 struct sigcontext {
 	unsigned long	sc_regs[32];
 	unsigned long	sc_fpregs[32];
-	unsigned long	sc_mdhi;
-	unsigned long	sc_mdlo;
+	unsigned long	sc_hi[4];
+	unsigned long	sc_lo[4];
 	unsigned long	sc_pc;
-	unsigned long	sc_badvaddr;
-	unsigned int	sc_status;
 	unsigned int	sc_fpc_csr;
-	unsigned int	sc_fpc_eir;
 	unsigned int	sc_used_math;
-	unsigned int	sc_cause;
+	unsigned int	sc_dsp;
+	unsigned int	sc_reserved;
 };
 
 #ifdef __KERNEL__
@@ -68,23 +69,24 @@
 #include <linux/posix_types.h>
 
 struct sigcontext32 {
-	__u32	sc_regmask;		/* Unused */
-	__u32	sc_status;
-	__u64	sc_pc;
-	__u64	sc_regs[32];
-	__u64	sc_fpregs[32];
-	__u32	sc_ownedfp;		/* Unused */
-	__u32	sc_fpc_csr;
-	__u32	sc_fpc_eir;		/* Unused */
-	__u32	sc_used_math;
-	__u32	sc_ssflags;		/* Unused */
-	__u64	sc_mdhi;
-	__u64	sc_mdlo;
-
-	__u32	sc_cause;		/* Unused */
-	__u32	sc_badvaddr;		/* Unused */
-
-	__u32	sc_sigset[4];		/* kernel's sigset_t */
+	__u32		sc_regmask;	/* Unused */
+	__u32		sc_status;
+	__u64		sc_pc;
+	__u64		sc_regs[32];
+	__u64		sc_fpregs[32];
+	__u32		sc_ownedfp;	/* Unused */
+	__u32		sc_fpc_csr;
+	__u32		sc_fpc_eir;	/* Unused */
+	__u32		sc_used_math;
+	__u32		sc_dsp;		/* dsp status, was sc_ssflags */
+	__u64		sc_mdhi;
+	__u64		sc_mdlo;
+	__u32		sc_hi1;		/* Was sc_cause */
+	__u32		sc_lo1;		/* Was sc_badvaddr */
+	__u32		sc_hi2;		/* Was sc_sigset[4] */
+	__u32		sc_lo2;
+	__u32		sc_hi3;
+	__u32		sc_lo3;
 };
 #endif /* __KERNEL__ */
 
diff -Naur linux-2.6.14/include/asm-mips/siginfo.h linux-mips-2.6.14.orig/include/asm-mips/siginfo.h
--- linux-2.6.14/include/asm-mips/siginfo.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/siginfo.h	2005-11-17 11:44:27.000000000 -0800
@@ -11,6 +11,7 @@
 
 #include <linux/config.h>
 
+#define __ARCH_SIGEV_PREAMBLE_SIZE (sizeof(long) + 2*sizeof(int))
 #undef __ARCH_SI_TRAPNO	/* exception code needs to fill this ...  */
 
 #define HAVE_ARCH_SIGINFO_T
diff -Naur linux-2.6.14/include/asm-mips/signal.h linux-mips-2.6.14.orig/include/asm-mips/signal.h
--- linux-2.6.14/include/asm-mips/signal.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/signal.h	2005-11-17 11:44:27.000000000 -0800
@@ -98,12 +98,39 @@
 #define MINSIGSTKSZ    2048
 #define SIGSTKSZ       8192
 
+#ifdef __KERNEL__
+
+/*
+ * These values of sa_flags are used only by the kernel as part of the
+ * irq handling routines.
+ *
+ * SA_INTERRUPT is also used by the irq handling routines.
+ * SA_SHIRQ flag is for shared interrupt support on PCI and EISA.
+ */
+#define SA_SAMPLE_RANDOM	SA_RESTART
+
+#ifdef CONFIG_TRAD_SIGNALS
+#define sig_uses_siginfo(ka)	((ka)->sa.sa_flags & SA_SIGINFO)
+#else
+#define sig_uses_siginfo(ka)	(1)
+#endif
+
+#endif /* __KERNEL__ */
+
 #define SIG_BLOCK	1	/* for blocking signals */
 #define SIG_UNBLOCK	2	/* for unblocking signals */
 #define SIG_SETMASK	3	/* for setting the signal mask */
 #define SIG_SETMASK32	256	/* Goodie from SGI for BSD compatibility:
 				   set only the low 32 bit of the sigset.  */
-#include <asm-generic/signal.h>
+
+/* Type of a signal handler.  */
+typedef void __signalfn_t(int);
+typedef __signalfn_t __user *__sighandler_t;
+
+/* Fake signal functions */
+#define SIG_DFL	((__sighandler_t)0)	/* default signal handling */
+#define SIG_IGN	((__sighandler_t)1)	/* ignore signal */
+#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
 
 struct sigaction {
 	unsigned int	sa_flags;
diff -Naur linux-2.6.14/include/asm-mips/sn/sn0/arch.h linux-mips-2.6.14.orig/include/asm-mips/sn/sn0/arch.h
--- linux-2.6.14/include/asm-mips/sn/sn0/arch.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/sn/sn0/arch.h	2005-11-17 11:44:27.000000000 -0800
@@ -74,13 +74,8 @@
 #define MAX_MEM_SLOTS   32                      /* max slots per node */
 #endif /* defined(N_MODE) */
 
-#if SABLE_RTL
-#define SLOT_SHIFT      	(28)
-#define SLOT_MIN_MEM_SIZE	(16*1024*1024)
-#else
 #define SLOT_SHIFT      	(27)
 #define SLOT_MIN_MEM_SIZE	(32*1024*1024)
-#endif
 
 #define CPUS_PER_NODE		2	/* CPUs on a single hub */
 #define CPUS_PER_NODE_SHFT	1	/* Bits to shift in the node number */
diff -Naur linux-2.6.14/include/asm-mips/socket.h linux-mips-2.6.14.orig/include/asm-mips/socket.h
--- linux-2.6.14/include/asm-mips/socket.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/socket.h	2005-11-17 11:44:27.000000000 -0800
@@ -37,8 +37,6 @@
 #define SO_ERROR	0x1007	/* get error status and clear */
 #define SO_SNDBUF	0x1001	/* Send buffer size. */
 #define SO_RCVBUF	0x1002	/* Receive buffer. */
-#define SO_SNDBUFFORCE	0x100a
-#define SO_RCVBUFFORCE	0x100b
 #define SO_SNDLOWAT	0x1003	/* send low-water mark */
 #define SO_RCVLOWAT	0x1004	/* receive low-water mark */
 #define SO_SNDTIMEO	0x1005	/* send timeout */
@@ -69,6 +67,8 @@
 #define SCM_TIMESTAMP		SO_TIMESTAMP
 
 #define SO_PEERSEC		30
+#define SO_SNDBUFFORCE		31
+#define SO_RCVBUFFORCE		33
 
 #ifdef __KERNEL__
 
@@ -92,6 +92,7 @@
 	SOCK_RAW	= 3,
 	SOCK_RDM	= 4,
 	SOCK_SEQPACKET	= 5,
+	SOCK_DCCP	= 6,
 	SOCK_PACKET	= 10,
 };
 
diff -Naur linux-2.6.14/include/asm-mips/spinlock.h linux-mips-2.6.14.orig/include/asm-mips/spinlock.h
--- linux-2.6.14/include/asm-mips/spinlock.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/spinlock.h	2005-11-17 11:44:27.000000000 -0800
@@ -9,17 +9,16 @@
 #ifndef _ASM_SPINLOCK_H
 #define _ASM_SPINLOCK_H
 
-#include <linux/config.h>
 #include <asm/war.h>
 
 /*
  * Your basic SMP spinlocks, allowing only a single CPU anywhere
  */
 
-#define __raw_spin_is_locked(x)	((x)->lock != 0)
+#define __raw_spin_is_locked(x)       ((x)->lock != 0)
 #define __raw_spin_lock_flags(lock, flags) __raw_spin_lock(lock)
 #define __raw_spin_unlock_wait(x) \
-		do { cpu_relax(); } while ((x)->lock)
+	do { cpu_relax(); } while ((x)->lock)
 
 /*
  * Simple spin lock operations.  There are two variants, one clears IRQ's
@@ -119,6 +118,18 @@
  * read-locks.
  */
 
+/*
+ * read_can_lock - would read_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define __raw_read_can_lock(rw)	((rw)->lock >= 0)
+
+/*
+ * write_can_lock - would write_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define __raw_write_can_lock(rw)	(!(rw)->lock)
+
 static inline void __raw_read_lock(raw_rwlock_t *rw)
 {
 	unsigned int tmp;
@@ -197,8 +208,7 @@
 		"	 lui	%1, 0x8000				\n"
 		"	sc	%1, %0					\n"
 		"	beqzl	%1, 1b					\n"
-		"	 nop						\n"
-		"	sync						\n"
+		"	 sync						\n"
 		"	.set	reorder					\n"
 		: "=m" (rw->lock), "=&r" (tmp)
 		: "m" (rw->lock)
@@ -211,8 +221,7 @@
 		"	 lui	%1, 0x8000				\n"
 		"	sc	%1, %0					\n"
 		"	beqz	%1, 1b					\n"
-		"	 nop						\n"
-		"	sync						\n"
+		"	 sync						\n"
 		"	.set	reorder					\n"
 		: "=m" (rw->lock), "=&r" (tmp)
 		: "m" (rw->lock)
@@ -246,8 +255,7 @@
 		"	 lui	%1, 0x8000				\n"
 		"	sc	%1, %0					\n"
 		"	beqzl	%1, 1b					\n"
-		"	 nop						\n"
-		"	sync						\n"
+		"	 sync						\n"
 		"	li	%2, 1					\n"
 		"	.set	reorder					\n"
 		"2:							\n"
diff -Naur linux-2.6.14/include/asm-mips/stackframe.h linux-mips-2.6.14.orig/include/asm-mips/stackframe.h
--- linux-2.6.14/include/asm-mips/stackframe.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/stackframe.h	2005-11-17 11:44:27.000000000 -0800
@@ -60,7 +60,6 @@
 		mfc0	k0, CP0_CONTEXT
 		lui	k1, %hi(kernelsp)
 		srl	k0, k0, 23
-		sll	k0, k0, 2
 		addu	k1, k0
 		LONG_L	k1, %lo(kernelsp)(k1)
 #endif
@@ -76,9 +75,14 @@
 #endif
 #if defined(CONFIG_64BIT) && defined(CONFIG_BUILD_ELF64)
 		MFC0	k1, CP0_CONTEXT
+		lui	k0, %highest(kernelsp)
 		dsrl	k1, 23
-		dsll	k1, k1, 3
-		LONG_L	k1, kernelsp(k1)
+		daddiu	k0, %higher(kernelsp)
+		dsll	k0, k0, 16
+		daddiu	k0, %hi(kernelsp)
+		dsll	k0, k0, 16
+		daddu	k1, k1, k0
+		LONG_L	k1, %lo(kernelsp)(k1)
 #endif
 		.endm
 
@@ -86,25 +90,28 @@
 #ifdef CONFIG_32BIT
 		mfc0	\temp, CP0_CONTEXT
 		srl	\temp, 23
-		sll	\temp, 2
-		LONG_S	\stackp, kernelsp(\temp)
 #endif
 #if defined(CONFIG_64BIT) && !defined(CONFIG_BUILD_ELF64)
 		lw	\temp, TI_CPU(gp)
 		dsll	\temp, 3
-		lui	\temp2, %hi(kernelsp)
-		daddu	\temp, \temp2
-		LONG_S	\stackp, %lo(kernelsp)(\temp)
 #endif
 #if defined(CONFIG_64BIT) && defined(CONFIG_BUILD_ELF64)
-		lw	\temp, TI_CPU(gp)
-		dsll	\temp, 3
-		LONG_S	\stackp, kernelsp(\temp)
+		MFC0	\temp, CP0_CONTEXT
+		dsrl	\temp, 23
 #endif
+		LONG_S	\stackp, kernelsp(\temp)
 		.endm
 #else
 		.macro	get_saved_sp	/* Uniprocessor variation */
+#if defined(CONFIG_64BIT) && defined(CONFIG_BUILD_ELF64)
+		lui	k1, %highest(kernelsp)
+		daddiu	k1, %higher(kernelsp)
+		dsll	k1, k1, 16
+		daddiu	k1, %hi(kernelsp)
+		dsll	k1, k1, 16
+#else
 		lui	k1, %hi(kernelsp)
+#endif
 		LONG_L	k1, %lo(kernelsp)(k1)
 		.endm
 
diff -Naur linux-2.6.14/include/asm-mips/system.h linux-mips-2.6.14.orig/include/asm-mips/system.h
--- linux-2.6.14/include/asm-mips/system.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/system.h	2005-11-17 11:44:27.000000000 -0800
@@ -17,6 +17,7 @@
 
 #include <asm/addrspace.h>
 #include <asm/cpu-features.h>
+#include <asm/dsp.h>
 #include <asm/ptrace.h>
 #include <asm/war.h>
 #include <asm/interrupt.h>
@@ -70,7 +71,7 @@
  * does not enforce ordering, since there is no data dependency between
  * the read of "a" and the read of "b".  Therefore, on some CPUs, such
  * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
- * in cases like thiswhere there are no data dependencies.
+ * in cases like this where there are no data dependencies.
  */
 
 #define read_barrier_depends()	do { } while(0)
@@ -154,15 +155,15 @@
 
 struct task_struct;
 
-#define switch_to(prev,next,last) \
-do { \
-	(last) = resume(prev, next, next->thread_info); \
+#define switch_to(prev,next,last)					\
+do {									\
+	if (cpu_has_dsp)						\
+		__save_dsp(prev);					\
+	(last) = resume(prev, next, next->thread_info);			\
+	if (cpu_has_dsp)						\
+		__restore_dsp(current);					\
 } while(0)
 
-#define ROT_IN_PIECES							\
-	"	.set	noreorder	\n"				\
-	"	.set	reorder		\n"
-
 static inline unsigned long __xchg_u32(volatile int * m, unsigned int val)
 {
 	__u32 retval;
@@ -171,14 +172,17 @@
 		unsigned long dummy;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%0, %3			# xchg_u32	\n"
+		"	.set	mips0					\n"
 		"	move	%2, %z4					\n"
+		"	.set	mips3					\n"
 		"	sc	%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
-		ROT_IN_PIECES
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
 		: "memory");
@@ -186,13 +190,17 @@
 		unsigned long dummy;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	ll	%0, %3			# xchg_u32	\n"
+		"	.set	mips0					\n"
 		"	move	%2, %z4					\n"
+		"	.set	mips3					\n"
 		"	sc	%2, %1					\n"
 		"	beqz	%2, 1b					\n"
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
 		: "memory");
@@ -217,14 +225,15 @@
 		unsigned long dummy;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%0, %3			# xchg_u64	\n"
 		"	move	%2, %z4					\n"
 		"	scd	%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
-		ROT_IN_PIECES
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
 		: "memory");
@@ -232,6 +241,7 @@
 		unsigned long dummy;
 
 		__asm__ __volatile__(
+		"	.set	mips3					\n"
 		"1:	lld	%0, %3			# xchg_u64	\n"
 		"	move	%2, %z4					\n"
 		"	scd	%2, %1					\n"
@@ -239,6 +249,7 @@
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
+		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
 		: "memory");
@@ -286,34 +297,41 @@
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		__asm__ __volatile__(
+		"	.set	push					\n"
 		"	.set	noat					\n"
+		"	.set	mips3					\n"
 		"1:	ll	%0, %2			# __cmpxchg_u32	\n"
 		"	bne	%0, %z3, 2f				\n"
+		"	.set	mips0					\n"
 		"	move	$1, %z4					\n"
+		"	.set	mips3					\n"
 		"	sc	$1, %1					\n"
 		"	beqzl	$1, 1b					\n"
-		ROT_IN_PIECES
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
 		"2:							\n"
-		"	.set	at					\n"
+		"	.set	pop					\n"
 		: "=&r" (retval), "=m" (*m)
 		: "R" (*m), "Jr" (old), "Jr" (new)
 		: "memory");
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
+		"	.set	push					\n"
 		"	.set	noat					\n"
+		"	.set	mips3					\n"
 		"1:	ll	%0, %2			# __cmpxchg_u32	\n"
 		"	bne	%0, %z3, 2f				\n"
+		"	.set	mips0					\n"
 		"	move	$1, %z4					\n"
+		"	.set	mips3					\n"
 		"	sc	$1, %1					\n"
 		"	beqz	$1, 1b					\n"
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
 		"2:							\n"
-		"	.set	at					\n"
+		"	.set	pop					\n"
 		: "=&r" (retval), "=m" (*m)
 		: "R" (*m), "Jr" (old), "Jr" (new)
 		: "memory");
@@ -338,24 +356,27 @@
 
 	if (cpu_has_llsc) {
 		__asm__ __volatile__(
+		"	.set	push					\n"
 		"	.set	noat					\n"
+		"	.set	mips3					\n"
 		"1:	lld	%0, %2			# __cmpxchg_u64	\n"
 		"	bne	%0, %z3, 2f				\n"
 		"	move	$1, %z4					\n"
 		"	scd	$1, %1					\n"
 		"	beqzl	$1, 1b					\n"
-		ROT_IN_PIECES
 #ifdef CONFIG_SMP
 		"	sync						\n"
 #endif
 		"2:							\n"
-		"	.set	at					\n"
+		"	.set	pop					\n"
 		: "=&r" (retval), "=m" (*m)
 		: "R" (*m), "Jr" (old), "Jr" (new)
 		: "memory");
 	} else if (cpu_has_llsc) {
 		__asm__ __volatile__(
+		"	.set	push					\n"
 		"	.set	noat					\n"
+		"	.set	mips3					\n"
 		"1:	lld	%0, %2			# __cmpxchg_u64	\n"
 		"	bne	%0, %z3, 2f				\n"
 		"	move	$1, %z4					\n"
@@ -365,7 +386,7 @@
 		"	sync						\n"
 #endif
 		"2:							\n"
-		"	.set	at					\n"
+		"	.set	pop					\n"
 		: "=&r" (retval), "=m" (*m)
 		: "R" (*m), "Jr" (old), "Jr" (new)
 		: "memory");
@@ -406,18 +427,20 @@
 
 #define cmpxchg(ptr,old,new) ((__typeof__(*(ptr)))__cmpxchg((ptr), (unsigned long)(old), (unsigned long)(new),sizeof(*(ptr))))
 
+extern void set_handler (unsigned long offset, void *addr, unsigned long len);
+extern void set_uncached_handler (unsigned long offset, void *addr, unsigned long len);
+extern void *set_vi_handler (int n, void *addr);
+extern void *set_vi_srs_handler (int n, void *addr, int regset);
 extern void *set_except_vector(int n, void *addr);
 extern void per_cpu_trap_init(void);
 
-extern NORET_TYPE void __die(const char *, struct pt_regs *, const char *file,
-	const char *func, unsigned long line);
-extern void __die_if_kernel(const char *, struct pt_regs *, const char *file,
-	const char *func, unsigned long line);
-
-#define die(msg, regs)							\
-	__die(msg, regs, __FILE__ ":", __FUNCTION__, __LINE__)
-#define die_if_kernel(msg, regs)					\
-	__die_if_kernel(msg, regs, __FILE__ ":", __FUNCTION__, __LINE__)
+extern NORET_TYPE void die(const char *, struct pt_regs *);
+
+static inline void die_if_kernel(const char *str, struct pt_regs *regs)
+{
+	if (unlikely(!user_mode(regs)))
+		die(str, regs);
+}
 
 extern int stop_a_enabled;
 
diff -Naur linux-2.6.14/include/asm-mips/thread_info.h linux-mips-2.6.14.orig/include/asm-mips/thread_info.h
--- linux-2.6.14/include/asm-mips/thread_info.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/thread_info.h	2005-11-17 11:44:27.000000000 -0800
@@ -26,6 +26,7 @@
 	struct task_struct	*task;		/* main task structure */
 	struct exec_domain	*exec_domain;	/* execution domain */
 	unsigned long		flags;		/* low level flags */
+	unsigned long		tp_value;	/* thread pointer */
 	__u32			cpu;		/* current CPU */
 	int			preempt_count;	/* 0 => preemptable, <0 => BUG */
 
@@ -114,6 +115,7 @@
 #define TIF_SIGPENDING		2	/* signal pending */
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_SYSCALL_AUDIT	4	/* syscall auditing active */
+#define TIF_SECCOMP		5	/* secure computing */
 #define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
 #define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
 #define TIF_MEMDIE		18
@@ -124,13 +126,14 @@
 #define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
 #define _TIF_SYSCALL_AUDIT	(1<<TIF_SYSCALL_AUDIT)
+#define _TIF_SECCOMP		(1<<TIF_SECCOMP)
 #define _TIF_USEDFPU		(1<<TIF_USEDFPU)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
 
-#define _TIF_WORK_MASK		0x0000ffef	/* work to do on
-                                                   interrupt/exception return */
-#define _TIF_ALLWORK_MASK	0x8000ffff	/* work to do on any return to
-                                                   u-space */
+/* work to do on interrupt/exception return */
+#define _TIF_WORK_MASK		(0x0000ffef & ~_TIF_SECCOMP)
+/* work to do on any return to u-space */
+#define _TIF_ALLWORK_MASK	(0x8000ffff & ~_TIF_SECCOMP)
 
 #endif /* __KERNEL__ */
 
diff -Naur linux-2.6.14/include/asm-mips/traps.h linux-mips-2.6.14.orig/include/asm-mips/traps.h
--- linux-2.6.14/include/asm-mips/traps.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/traps.h	2005-11-17 11:44:27.000000000 -0800
@@ -21,4 +21,7 @@
 extern void (*board_be_init)(void);
 extern int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
 
+extern void (*board_nmi_handler_setup)(void);
+extern void (*board_ejtag_handler_setup)(void);
+
 #endif /* _ASM_TRAPS_H */
diff -Naur linux-2.6.14/include/asm-mips/tx4938/rbtx4938.h linux-mips-2.6.14.orig/include/asm-mips/tx4938/rbtx4938.h
--- linux-2.6.14/include/asm-mips/tx4938/rbtx4938.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/tx4938/rbtx4938.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,207 @@
+/*
+ * linux/include/asm-mips/tx4938/rbtx4938.h
+ * Definitions for TX4937/TX4938
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#ifndef __ASM_TX_BOARDS_RBTX4938_H
+#define __ASM_TX_BOARDS_RBTX4938_H
+
+#include <asm/addrspace.h>
+#include <asm/tx4938/tx4938.h>
+
+/* CS */
+#define RBTX4938_CE0	0x1c000000	/* 64M */
+#define RBTX4938_CE2	0x17f00000	/* 1M */
+
+/* Address map */
+#define RBTX4938_FPGA_REG_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000000)
+#define RBTX4938_FPGA_REV_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000002)
+#define RBTX4938_CONFIG1_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000004)
+#define RBTX4938_CONFIG2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000006)
+#define RBTX4938_CONFIG3_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00000008)
+#define RBTX4938_LED_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00001000)
+#define RBTX4938_DIPSW_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00001002)
+#define RBTX4938_BDIPSW_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00001004)
+#define RBTX4938_IMASK_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002000)
+#define RBTX4938_IMASK2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002002)
+#define RBTX4938_INTPOL_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002004)
+#define RBTX4938_ISTAT_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002006)
+#define RBTX4938_ISTAT2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00002008)
+#define RBTX4938_IMSTAT_ADDR	(KSEG1 + RBTX4938_CE2 + 0x0000200a)
+#define RBTX4938_IMSTAT2_ADDR	(KSEG1 + RBTX4938_CE2 + 0x0000200c)
+#define RBTX4938_SOFTINT_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00003000)
+#define RBTX4938_PIOSEL_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00005000)
+#define RBTX4938_SPICS_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00005002)
+#define RBTX4938_SFPWR_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00005008)
+#define RBTX4938_SFVOL_ADDR	(KSEG1 + RBTX4938_CE2 + 0x0000500a)
+#define RBTX4938_SOFTRESET_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00007000)
+#define RBTX4938_SOFTRESETLOCK_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00007002)
+#define RBTX4938_PCIRESET_ADDR	(KSEG1 + RBTX4938_CE2 + 0x00007004)
+#define RBTX4938_ETHER_BASE	(KSEG1 + RBTX4938_CE2 + 0x00020000)
+
+/* Ethernet port address (Jumperless Mode (W12:Open)) */
+#define RBTX4938_ETHER_ADDR	(RBTX4938_ETHER_BASE + 0x280)
+
+/* bits for ISTAT/IMASK/IMSTAT */
+#define RBTX4938_INTB_PCID	0
+#define RBTX4938_INTB_PCIC	1
+#define RBTX4938_INTB_PCIB	2
+#define RBTX4938_INTB_PCIA	3
+#define RBTX4938_INTB_RTC	4
+#define RBTX4938_INTB_ATA	5
+#define RBTX4938_INTB_MODEM	6
+#define RBTX4938_INTB_SWINT	7
+#define RBTX4938_INTF_PCID	(1 << RBTX4938_INTB_PCID)
+#define RBTX4938_INTF_PCIC	(1 << RBTX4938_INTB_PCIC)
+#define RBTX4938_INTF_PCIB	(1 << RBTX4938_INTB_PCIB)
+#define RBTX4938_INTF_PCIA	(1 << RBTX4938_INTB_PCIA)
+#define RBTX4938_INTF_RTC	(1 << RBTX4938_INTB_RTC)
+#define RBTX4938_INTF_ATA	(1 << RBTX4938_INTB_ATA)
+#define RBTX4938_INTF_MODEM	(1 << RBTX4938_INTB_MODEM)
+#define RBTX4938_INTF_SWINT	(1 << RBTX4938_INTB_SWINT)
+
+#define rbtx4938_fpga_rev_ptr	\
+	((volatile unsigned char *)RBTX4938_FPGA_REV_ADDR)
+#define rbtx4938_led_ptr	\
+	((volatile unsigned char *)RBTX4938_LED_ADDR)
+#define rbtx4938_dipsw_ptr	\
+	((volatile unsigned char *)RBTX4938_DIPSW_ADDR)
+#define rbtx4938_bdipsw_ptr	\
+	((volatile unsigned char *)RBTX4938_BDIPSW_ADDR)
+#define rbtx4938_imask_ptr	\
+	((volatile unsigned char *)RBTX4938_IMASK_ADDR)
+#define rbtx4938_imask2_ptr	\
+	((volatile unsigned char *)RBTX4938_IMASK2_ADDR)
+#define rbtx4938_intpol_ptr	\
+	((volatile unsigned char *)RBTX4938_INTPOL_ADDR)
+#define rbtx4938_istat_ptr	\
+	((volatile unsigned char *)RBTX4938_ISTAT_ADDR)
+#define rbtx4938_istat2_ptr	\
+	((volatile unsigned char *)RBTX4938_ISTAT2_ADDR)
+#define rbtx4938_imstat_ptr	\
+	((volatile unsigned char *)RBTX4938_IMSTAT_ADDR)
+#define rbtx4938_imstat2_ptr	\
+	((volatile unsigned char *)RBTX4938_IMSTAT2_ADDR)
+#define rbtx4938_softint_ptr	\
+	((volatile unsigned char *)RBTX4938_SOFTINT_ADDR)
+#define rbtx4938_piosel_ptr	\
+	((volatile unsigned char *)RBTX4938_PIOSEL_ADDR)
+#define rbtx4938_spics_ptr	\
+	((volatile unsigned char *)RBTX4938_SPICS_ADDR)
+#define rbtx4938_sfpwr_ptr	\
+	((volatile unsigned char *)RBTX4938_SFPWR_ADDR)
+#define rbtx4938_sfvol_ptr	\
+	((volatile unsigned char *)RBTX4938_SFVOL_ADDR)
+#define rbtx4938_softreset_ptr	\
+	((volatile unsigned char *)RBTX4938_SOFTRESET_ADDR)
+#define rbtx4938_softresetlock_ptr	\
+	((volatile unsigned char *)RBTX4938_SOFTRESETLOCK_ADDR)
+#define rbtx4938_pcireset_ptr	\
+	((volatile unsigned char *)RBTX4938_PCIRESET_ADDR)
+
+/* SPI */
+#define RBTX4938_SEEPROM1_CHIPID	0
+#define RBTX4938_SEEPROM2_CHIPID	1
+#define RBTX4938_SEEPROM3_CHIPID	2
+#define RBTX4938_SRTC_CHIPID	3
+
+/*
+ * IRQ mappings
+ */
+
+#define RBTX4938_SOFT_INT0	0	/* not used */
+#define RBTX4938_SOFT_INT1	1	/* not used */
+#define RBTX4938_IRC_INT	2
+#define RBTX4938_TIMER_INT	7
+
+/* These are the virtual IRQ numbers, we divide all IRQ's into
+ * 'spaces', the 'space' determines where and how to enable/disable
+ * that particular IRQ on an RBTX4938 machine.  Add new 'spaces' as new
+ * IRQ hardware is supported.
+ */
+#define RBTX4938_NR_IRQ_LOCAL	8
+#define RBTX4938_NR_IRQ_IRC	32	/* On-Chip IRC */
+#define RBTX4938_NR_IRQ_IOC	8
+
+#define MI8259_IRQ_ISA_RAW_BEG   0	/* optional backplane i8259 */
+#define MI8259_IRQ_ISA_RAW_END  15
+#define TX4938_IRQ_CP0_RAW_BEG   0	/* tx4938 cpu built-in cp0 */
+#define TX4938_IRQ_CP0_RAW_END   7
+#define TX4938_IRQ_PIC_RAW_BEG   0	/* tx4938 cpu build-in pic */
+#define TX4938_IRQ_PIC_RAW_END  31
+
+#define MI8259_IRQ_ISA_BEG                          MI8259_IRQ_ISA_RAW_BEG	/*  0 */
+#define MI8259_IRQ_ISA_END                          MI8259_IRQ_ISA_RAW_END	/* 15 */
+
+#define TX4938_IRQ_CP0_BEG  ((MI8259_IRQ_ISA_END+1)+TX4938_IRQ_CP0_RAW_BEG)	/* 16 */
+#define TX4938_IRQ_CP0_END  ((MI8259_IRQ_ISA_END+1)+TX4938_IRQ_CP0_RAW_END)	/* 23 */
+
+#define TX4938_IRQ_PIC_BEG  ((TX4938_IRQ_CP0_END+1)+TX4938_IRQ_PIC_RAW_BEG)	/* 24 */
+#define TX4938_IRQ_PIC_END  ((TX4938_IRQ_CP0_END+1)+TX4938_IRQ_PIC_RAW_END)	/* 55 */
+#define TX4938_IRQ_NEST_EXT_ON_PIC  (TX4938_IRQ_PIC_BEG+2)
+#define TX4938_IRQ_NEST_PIC_ON_CP0  (TX4938_IRQ_CP0_BEG+2)
+#define TX4938_IRQ_USER0            (TX4938_IRQ_CP0_BEG+0)
+#define TX4938_IRQ_USER1            (TX4938_IRQ_CP0_BEG+1)
+#define TX4938_IRQ_CPU_TIMER        (TX4938_IRQ_CP0_BEG+7)
+
+#define TOSHIBA_RBTX4938_IRQ_IOC_RAW_BEG   0
+#define TOSHIBA_RBTX4938_IRQ_IOC_RAW_END   7
+
+#define TOSHIBA_RBTX4938_IRQ_IOC_BEG  ((TX4938_IRQ_PIC_END+1)+TOSHIBA_RBTX4938_IRQ_IOC_RAW_BEG) /* 56 */
+#define TOSHIBA_RBTX4938_IRQ_IOC_END  ((TX4938_IRQ_PIC_END+1)+TOSHIBA_RBTX4938_IRQ_IOC_RAW_END) /* 63 */
+#define RBTX4938_IRQ_LOCAL	TX4938_IRQ_CP0_BEG
+#define RBTX4938_IRQ_IRC	(RBTX4938_IRQ_LOCAL + RBTX4938_NR_IRQ_LOCAL)
+#define RBTX4938_IRQ_IOC	(RBTX4938_IRQ_IRC + RBTX4938_NR_IRQ_IRC)
+#define RBTX4938_IRQ_END	(RBTX4938_IRQ_IOC + RBTX4938_NR_IRQ_IOC)
+
+#define RBTX4938_IRQ_LOCAL_SOFT0	(RBTX4938_IRQ_LOCAL + RBTX4938_SOFT_INT0)
+#define RBTX4938_IRQ_LOCAL_SOFT1	(RBTX4938_IRQ_LOCAL + RBTX4938_SOFT_INT1)
+#define RBTX4938_IRQ_LOCAL_IRC	(RBTX4938_IRQ_LOCAL + RBTX4938_IRC_INT)
+#define RBTX4938_IRQ_LOCAL_TIMER	(RBTX4938_IRQ_LOCAL + RBTX4938_TIMER_INT)
+#define RBTX4938_IRQ_IRC_ECCERR	(RBTX4938_IRQ_IRC + TX4938_IR_ECCERR)
+#define RBTX4938_IRQ_IRC_WTOERR	(RBTX4938_IRQ_IRC + TX4938_IR_WTOERR)
+#define RBTX4938_IRQ_IRC_INT(n)	(RBTX4938_IRQ_IRC + TX4938_IR_INT(n))
+#define RBTX4938_IRQ_IRC_SIO(n)	(RBTX4938_IRQ_IRC + TX4938_IR_SIO(n))
+#define RBTX4938_IRQ_IRC_DMA(ch,n)	(RBTX4938_IRQ_IRC + TX4938_IR_DMA(ch,n))
+#define RBTX4938_IRQ_IRC_PIO	(RBTX4938_IRQ_IRC + TX4938_IR_PIO)
+#define RBTX4938_IRQ_IRC_PDMAC	(RBTX4938_IRQ_IRC + TX4938_IR_PDMAC)
+#define RBTX4938_IRQ_IRC_PCIC	(RBTX4938_IRQ_IRC + TX4938_IR_PCIC)
+#define RBTX4938_IRQ_IRC_TMR(n)	(RBTX4938_IRQ_IRC + TX4938_IR_TMR(n))
+#define RBTX4938_IRQ_IRC_NDFMC	(RBTX4938_IRQ_IRC + TX4938_IR_NDFMC)
+#define RBTX4938_IRQ_IRC_PCIERR	(RBTX4938_IRQ_IRC + TX4938_IR_PCIERR)
+#define RBTX4938_IRQ_IRC_PCIPME	(RBTX4938_IRQ_IRC + TX4938_IR_PCIPME)
+#define RBTX4938_IRQ_IRC_ACLC	(RBTX4938_IRQ_IRC + TX4938_IR_ACLC)
+#define RBTX4938_IRQ_IRC_ACLCPME	(RBTX4938_IRQ_IRC + TX4938_IR_ACLCPME)
+#define RBTX4938_IRQ_IRC_PCIC1	(RBTX4938_IRQ_IRC + TX4938_IR_PCIC1)
+#define RBTX4938_IRQ_IRC_SPI	(RBTX4938_IRQ_IRC + TX4938_IR_SPI)
+#define RBTX4938_IRQ_IOC_PCID	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCID)
+#define RBTX4938_IRQ_IOC_PCIC	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCIC)
+#define RBTX4938_IRQ_IOC_PCIB	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCIB)
+#define RBTX4938_IRQ_IOC_PCIA	(RBTX4938_IRQ_IOC + RBTX4938_INTB_PCIA)
+#define RBTX4938_IRQ_IOC_RTC	(RBTX4938_IRQ_IOC + RBTX4938_INTB_RTC)
+#define RBTX4938_IRQ_IOC_ATA	(RBTX4938_IRQ_IOC + RBTX4938_INTB_ATA)
+#define RBTX4938_IRQ_IOC_MODEM	(RBTX4938_IRQ_IOC + RBTX4938_INTB_MODEM)
+#define RBTX4938_IRQ_IOC_SWINT	(RBTX4938_IRQ_IOC + RBTX4938_INTB_SWINT)
+
+
+/* IOC (PCI, etc) */
+#define RBTX4938_IRQ_IOCINT	(TX4938_IRQ_NEST_EXT_ON_PIC)
+/* Onboard 10M Ether */
+#define RBTX4938_IRQ_ETHER	(TX4938_IRQ_NEST_EXT_ON_PIC + 1)
+
+#define RBTX4938_RTL_8019_BASE (RBTX4938_ETHER_ADDR - mips_io_port_base)
+#define RBTX4938_RTL_8019_IRQ  (RBTX4938_IRQ_ETHER)
+
+/* IRCR : Int. Control */
+#define TX4938_IRCR_LOW  0x00000000
+#define TX4938_IRCR_HIGH 0x00000001
+#define TX4938_IRCR_DOWN 0x00000002
+#define TX4938_IRCR_UP   0x00000003
+
+#endif /* __ASM_TX_BOARDS_RBTX4938_H */
diff -Naur linux-2.6.14/include/asm-mips/tx4938/spi.h linux-mips-2.6.14.orig/include/asm-mips/tx4938/spi.h
--- linux-2.6.14/include/asm-mips/tx4938/spi.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/tx4938/spi.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,74 @@
+/*
+ * linux/include/asm-mips/tx4938/spi.h
+ * Definitions for TX4937/TX4938 SPI
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#ifndef __ASM_TX_BOARDS_TX4938_SPI_H
+#define __ASM_TX_BOARDS_TX4938_SPI_H
+
+/* SPI */
+struct spi_dev_desc {
+	unsigned int baud;
+	unsigned short tcss, tcsh, tcsr; /* CS setup/hold/recovery time */
+	unsigned int byteorder:1;	/* 0:LSB-First, 1:MSB-First */
+	unsigned int polarity:1;	/* 0:High-Active */
+	unsigned int phase:1;		/* 0:Sample-Then-Shift */
+};
+
+extern void txx9_spi_init(unsigned long base, int (*cs_func)(int chipid, int on)) __init;
+extern void txx9_spi_irqinit(int irc_irq) __init;
+extern int txx9_spi_io(int chipid, struct spi_dev_desc *desc,
+		       unsigned char **inbufs, unsigned int *incounts,
+		       unsigned char **outbufs, unsigned int *outcounts,
+		       int cansleep);
+extern int spi_eeprom_write_enable(int chipid, int enable);
+extern int spi_eeprom_read_status(int chipid);
+extern int spi_eeprom_read(int chipid, int address, unsigned char *buf, int len);
+extern int spi_eeprom_write(int chipid, int address, unsigned char *buf, int len);
+extern void spi_eeprom_proc_create(struct proc_dir_entry *dir, int chipid) __init;
+
+#define TXX9_IMCLK     (txx9_gbus_clock / 2)
+
+/*
+* SPI
+*/
+
+/* SPMCR : SPI Master Control */
+#define TXx9_SPMCR_OPMODE	0xc0
+#define TXx9_SPMCR_CONFIG	0x40
+#define TXx9_SPMCR_ACTIVE	0x80
+#define TXx9_SPMCR_SPSTP	0x02
+#define TXx9_SPMCR_BCLR	0x01
+
+/* SPCR0 : SPI Status */
+#define TXx9_SPCR0_TXIFL_MASK	0xc000
+#define TXx9_SPCR0_RXIFL_MASK	0x3000
+#define TXx9_SPCR0_SIDIE	0x0800
+#define TXx9_SPCR0_SOEIE	0x0400
+#define TXx9_SPCR0_RBSIE	0x0200
+#define TXx9_SPCR0_TBSIE	0x0100
+#define TXx9_SPCR0_IFSPSE	0x0010
+#define TXx9_SPCR0_SBOS	0x0004
+#define TXx9_SPCR0_SPHA	0x0002
+#define TXx9_SPCR0_SPOL	0x0001
+
+/* SPSR : SPI Status */
+#define TXx9_SPSR_TBSI	0x8000
+#define TXx9_SPSR_RBSI	0x4000
+#define TXx9_SPSR_TBS_MASK	0x3800
+#define TXx9_SPSR_RBS_MASK	0x0700
+#define TXx9_SPSR_SPOE	0x0080
+#define TXx9_SPSR_IFSD	0x0008
+#define TXx9_SPSR_SIDLE	0x0004
+#define TXx9_SPSR_STRDY	0x0002
+#define TXx9_SPSR_SRRDY	0x0001
+
+#endif /* __ASM_TX_BOARDS_TX4938_SPI_H */
diff -Naur linux-2.6.14/include/asm-mips/tx4938/tx4938.h linux-mips-2.6.14.orig/include/asm-mips/tx4938/tx4938.h
--- linux-2.6.14/include/asm-mips/tx4938/tx4938.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/tx4938/tx4938.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,706 @@
+/*
+ * linux/include/asm-mips/tx4938/tx4938.h
+ * Definitions for TX4937/TX4938
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#ifndef __ASM_TX_BOARDS_TX4938_H
+#define __ASM_TX_BOARDS_TX4938_H
+
+#include <asm/tx4938/tx4938_mips.h>
+
+#define tx4938_read_nfmc(addr) (*(volatile unsigned int *)(addr))
+#define tx4938_write_nfmc(b,addr) (*(volatile unsigned int *)(addr)) = (b)
+
+#define TX4938_NR_IRQ_LOCAL     TX4938_IRQ_PIC_BEG
+
+#define TX4938_IRQ_IRC_PCIC     (TX4938_NR_IRQ_LOCAL + TX4938_IR_PCIC)
+#define TX4938_IRQ_IRC_PCIERR   (TX4938_NR_IRQ_LOCAL + TX4938_IR_PCIERR)
+
+#define TX4938_PCIIO_0 0x10000000
+#define TX4938_PCIIO_1 0x01010000
+#define TX4938_PCIMEM_0 0x08000000
+#define TX4938_PCIMEM_1 0x11000000
+
+#define TX4938_PCIIO_SIZE_0 0x01000000
+#define TX4938_PCIIO_SIZE_1 0x00010000
+#define TX4938_PCIMEM_SIZE_0 0x08000000
+#define TX4938_PCIMEM_SIZE_1 0x00010000
+
+#define TX4938_REG_BASE	0xff1f0000 /* == TX4937_REG_BASE */
+#define TX4938_REG_SIZE	0x00010000 /* == TX4937_REG_SIZE */
+
+/* NDFMC, SRAMC, PCIC1, SPIC: TX4938 only */
+#define TX4938_NDFMC_REG	(TX4938_REG_BASE + 0x5000)
+#define TX4938_SRAMC_REG	(TX4938_REG_BASE + 0x6000)
+#define TX4938_PCIC1_REG	(TX4938_REG_BASE + 0x7000)
+#define TX4938_SDRAMC_REG	(TX4938_REG_BASE + 0x8000)
+#define TX4938_EBUSC_REG	(TX4938_REG_BASE + 0x9000)
+#define TX4938_DMA_REG(ch)	(TX4938_REG_BASE + 0xb000 + (ch) * 0x800)
+#define TX4938_PCIC_REG		(TX4938_REG_BASE + 0xd000)
+#define TX4938_CCFG_REG		(TX4938_REG_BASE + 0xe000)
+#define TX4938_NR_TMR	3
+#define TX4938_TMR_REG(ch)	((TX4938_REG_BASE + 0xf000) + (ch) * 0x100)
+#define TX4938_NR_SIO	2
+#define TX4938_SIO_REG(ch)	((TX4938_REG_BASE + 0xf300) + (ch) * 0x100)
+#define TX4938_PIO_REG		(TX4938_REG_BASE + 0xf500)
+#define TX4938_IRC_REG		(TX4938_REG_BASE + 0xf600)
+#define TX4938_ACLC_REG		(TX4938_REG_BASE + 0xf700)
+#define TX4938_SPI_REG		(TX4938_REG_BASE + 0xf800)
+
+#ifndef _LANGUAGE_ASSEMBLY
+#include <asm/byteorder.h>
+
+#define TX4938_MKA(x) ((u32)( ((u32)(TX4938_REG_BASE)) | ((u32)(x)) ))
+
+#define TX4938_RD08( reg      )   (*(vu08*)(reg))
+#define TX4938_WR08( reg, val )  ((*(vu08*)(reg))=(val))
+
+#define TX4938_RD16( reg      )   (*(vu16*)(reg))
+#define TX4938_WR16( reg, val )  ((*(vu16*)(reg))=(val))
+
+#define TX4938_RD32( reg      )   (*(vu32*)(reg))
+#define TX4938_WR32( reg, val )  ((*(vu32*)(reg))=(val))
+
+#define TX4938_RD64( reg      )   (*(vu64*)(reg))
+#define TX4938_WR64( reg, val )  ((*(vu64*)(reg))=(val))
+
+#define TX4938_RD( reg      ) TX4938_RD32( reg )
+#define TX4938_WR( reg, val ) TX4938_WR32( reg, val )
+
+#endif /* !__ASSEMBLY__ */
+
+#ifdef __ASSEMBLY__
+#define _CONST64(c)	c
+#else
+#define _CONST64(c)	c##ull
+
+#include <asm/byteorder.h>
+
+#ifdef __BIG_ENDIAN
+#define endian_def_l2(e1,e2)	\
+	volatile unsigned long e1,e2
+#define endian_def_s2(e1,e2)	\
+	volatile unsigned short e1,e2
+#define endian_def_sb2(e1,e2,e3)	\
+	volatile unsigned short e1;volatile unsigned char e2,e3
+#define endian_def_b2s(e1,e2,e3)	\
+	volatile unsigned char e1,e2;volatile unsigned short e3
+#define endian_def_b4(e1,e2,e3,e4)	\
+	volatile unsigned char e1,e2,e3,e4
+#else
+#define endian_def_l2(e1,e2)	\
+	volatile unsigned long e2,e1
+#define endian_def_s2(e1,e2)	\
+	volatile unsigned short e2,e1
+#define endian_def_sb2(e1,e2,e3)	\
+	volatile unsigned char e3,e2;volatile unsigned short e1
+#define endian_def_b2s(e1,e2,e3)	\
+	volatile unsigned short e3;volatile unsigned char e2,e1
+#define endian_def_b4(e1,e2,e3,e4)	\
+	volatile unsigned char e4,e3,e2,e1
+#endif
+
+
+struct tx4938_sdramc_reg {
+	volatile unsigned long long cr[4];
+	volatile unsigned long long unused0[4];
+	volatile unsigned long long tr;
+	volatile unsigned long long unused1[2];
+	volatile unsigned long long cmd;
+	volatile unsigned long long sfcmd;
+};
+
+struct tx4938_ebusc_reg {
+	volatile unsigned long long cr[8];
+};
+
+struct tx4938_dma_reg {
+	struct tx4938_dma_ch_reg {
+		volatile unsigned long long cha;
+		volatile unsigned long long sar;
+		volatile unsigned long long dar;
+		endian_def_l2(unused0, cntr);
+		endian_def_l2(unused1, sair);
+		endian_def_l2(unused2, dair);
+		endian_def_l2(unused3, ccr);
+		endian_def_l2(unused4, csr);
+	} ch[4];
+	volatile unsigned long long dbr[8];
+	volatile unsigned long long tdhr;
+	volatile unsigned long long midr;
+	endian_def_l2(unused0, mcr);
+};
+
+struct tx4938_pcic_reg {
+	volatile unsigned long pciid;
+	volatile unsigned long pcistatus;
+	volatile unsigned long pciccrev;
+	volatile unsigned long pcicfg1;
+	volatile unsigned long p2gm0plbase;		/* +10 */
+	volatile unsigned long p2gm0pubase;
+	volatile unsigned long p2gm1plbase;
+	volatile unsigned long p2gm1pubase;
+	volatile unsigned long p2gm2pbase;		/* +20 */
+	volatile unsigned long p2giopbase;
+	volatile unsigned long unused0;
+	volatile unsigned long pcisid;
+	volatile unsigned long unused1;		/* +30 */
+	volatile unsigned long pcicapptr;
+	volatile unsigned long unused2;
+	volatile unsigned long pcicfg2;
+	volatile unsigned long g2ptocnt;		/* +40 */
+	volatile unsigned long unused3[15];
+	volatile unsigned long g2pstatus;		/* +80 */
+	volatile unsigned long g2pmask;
+	volatile unsigned long pcisstatus;
+	volatile unsigned long pcimask;
+	volatile unsigned long p2gcfg;		/* +90 */
+	volatile unsigned long p2gstatus;
+	volatile unsigned long p2gmask;
+	volatile unsigned long p2gccmd;
+	volatile unsigned long unused4[24];		/* +a0 */
+	volatile unsigned long pbareqport;		/* +100 */
+	volatile unsigned long pbacfg;
+	volatile unsigned long pbastatus;
+	volatile unsigned long pbamask;
+	volatile unsigned long pbabm;		/* +110 */
+	volatile unsigned long pbacreq;
+	volatile unsigned long pbacgnt;
+	volatile unsigned long pbacstate;
+	volatile unsigned long long g2pmgbase[3];		/* +120 */
+	volatile unsigned long long g2piogbase;
+	volatile unsigned long g2pmmask[3];		/* +140 */
+	volatile unsigned long g2piomask;
+	volatile unsigned long long g2pmpbase[3];		/* +150 */
+	volatile unsigned long long g2piopbase;
+	volatile unsigned long pciccfg;		/* +170 */
+	volatile unsigned long pcicstatus;
+	volatile unsigned long pcicmask;
+	volatile unsigned long unused5;
+	volatile unsigned long long p2gmgbase[3];		/* +180 */
+	volatile unsigned long long p2giogbase;
+	volatile unsigned long g2pcfgadrs;		/* +1a0 */
+	volatile unsigned long g2pcfgdata;
+	volatile unsigned long unused6[8];
+	volatile unsigned long g2pintack;
+	volatile unsigned long g2pspc;
+	volatile unsigned long unused7[12];		/* +1d0 */
+	volatile unsigned long long pdmca;		/* +200 */
+	volatile unsigned long long pdmga;
+	volatile unsigned long long pdmpa;
+	volatile unsigned long long pdmctr;
+	volatile unsigned long long pdmcfg;		/* +220 */
+	volatile unsigned long long pdmsts;
+};
+
+struct tx4938_aclc_reg {
+	volatile unsigned long acctlen;
+	volatile unsigned long acctldis;
+	volatile unsigned long acregacc;
+	volatile unsigned long unused0;
+	volatile unsigned long acintsts;
+	volatile unsigned long acintmsts;
+	volatile unsigned long acinten;
+	volatile unsigned long acintdis;
+	volatile unsigned long acsemaph;
+	volatile unsigned long unused1[7];
+	volatile unsigned long acgpidat;
+	volatile unsigned long acgpodat;
+	volatile unsigned long acslten;
+	volatile unsigned long acsltdis;
+	volatile unsigned long acfifosts;
+	volatile unsigned long unused2[11];
+	volatile unsigned long acdmasts;
+	volatile unsigned long acdmasel;
+	volatile unsigned long unused3[6];
+	volatile unsigned long acaudodat;
+	volatile unsigned long acsurrdat;
+	volatile unsigned long accentdat;
+	volatile unsigned long aclfedat;
+	volatile unsigned long acaudiat;
+	volatile unsigned long unused4;
+	volatile unsigned long acmodoat;
+	volatile unsigned long acmodidat;
+	volatile unsigned long unused5[15];
+	volatile unsigned long acrevid;
+};
+
+
+struct tx4938_tmr_reg {
+	volatile unsigned long tcr;
+	volatile unsigned long tisr;
+	volatile unsigned long cpra;
+	volatile unsigned long cprb;
+	volatile unsigned long itmr;
+	volatile unsigned long unused0[3];
+	volatile unsigned long ccdr;
+	volatile unsigned long unused1[3];
+	volatile unsigned long pgmr;
+	volatile unsigned long unused2[3];
+	volatile unsigned long wtmr;
+	volatile unsigned long unused3[43];
+	volatile unsigned long trr;
+};
+
+struct tx4938_sio_reg {
+	volatile unsigned long lcr;
+	volatile unsigned long dicr;
+	volatile unsigned long disr;
+	volatile unsigned long cisr;
+	volatile unsigned long fcr;
+	volatile unsigned long flcr;
+	volatile unsigned long bgr;
+	volatile unsigned long tfifo;
+	volatile unsigned long rfifo;
+};
+
+struct tx4938_pio_reg {
+	volatile unsigned long dout;
+	volatile unsigned long din;
+	volatile unsigned long dir;
+	volatile unsigned long od;
+	volatile unsigned long flag[2];
+	volatile unsigned long pol;
+	volatile unsigned long intc;
+	volatile unsigned long maskcpu;
+	volatile unsigned long maskext;
+};
+struct tx4938_irc_reg {
+	volatile unsigned long cer;
+	volatile unsigned long cr[2];
+	volatile unsigned long unused0;
+	volatile unsigned long ilr[8];
+	volatile unsigned long unused1[4];
+	volatile unsigned long imr;
+	volatile unsigned long unused2[7];
+	volatile unsigned long scr;
+	volatile unsigned long unused3[7];
+	volatile unsigned long ssr;
+	volatile unsigned long unused4[7];
+	volatile unsigned long csr;
+};
+
+struct tx4938_ndfmc_reg {
+	endian_def_l2(unused0, dtr);
+	endian_def_l2(unused1, mcr);
+	endian_def_l2(unused2, sr);
+	endian_def_l2(unused3, isr);
+	endian_def_l2(unused4, imr);
+	endian_def_l2(unused5, spr);
+	endian_def_l2(unused6, rstr);
+};
+
+struct tx4938_spi_reg {
+	volatile unsigned long mcr;
+	volatile unsigned long cr0;
+	volatile unsigned long cr1;
+	volatile unsigned long fs;
+	volatile unsigned long unused1;
+	volatile unsigned long sr;
+	volatile unsigned long dr;
+	volatile unsigned long unused2;
+};
+
+struct tx4938_sramc_reg {
+	volatile unsigned long long cr;
+};
+
+struct tx4938_ccfg_reg {
+	volatile unsigned long long ccfg;
+	volatile unsigned long long crir;
+	volatile unsigned long long pcfg;
+	volatile unsigned long long tear;
+	volatile unsigned long long clkctr;
+	volatile unsigned long long unused0;
+	volatile unsigned long long garbc;
+	volatile unsigned long long unused1;
+	volatile unsigned long long unused2;
+	volatile unsigned long long ramp;
+	volatile unsigned long long unused3;
+	volatile unsigned long long jmpadr;
+};
+
+#undef endian_def_l2
+#undef endian_def_s2
+#undef endian_def_sb2
+#undef endian_def_b2s
+#undef endian_def_b4
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * NDFMC
+ */
+
+/* NDFMCR : NDFMC Mode Control */
+#define TX4938_NDFMCR_WE	0x80
+#define TX4938_NDFMCR_ECC_ALL	0x60
+#define TX4938_NDFMCR_ECC_RESET	0x60
+#define TX4938_NDFMCR_ECC_READ	0x40
+#define TX4938_NDFMCR_ECC_ON	0x20
+#define TX4938_NDFMCR_ECC_OFF	0x00
+#define TX4938_NDFMCR_CE	0x10
+#define TX4938_NDFMCR_BSPRT	0x04
+#define TX4938_NDFMCR_ALE	0x02
+#define TX4938_NDFMCR_CLE	0x01
+
+/* NDFMCR : NDFMC Status */
+#define TX4938_NDFSR_BUSY	0x80
+
+/* NDFMCR : NDFMC Reset */
+#define TX4938_NDFRSTR_RST	0x01
+
+/*
+ * IRC
+ */
+
+#define TX4938_IR_ECCERR	0
+#define TX4938_IR_WTOERR	1
+#define TX4938_NUM_IR_INT	6
+#define TX4938_IR_INT(n)	(2 + (n))
+#define TX4938_NUM_IR_SIO	2
+#define TX4938_IR_SIO(n)	(8 + (n))
+#define TX4938_NUM_IR_DMA	4
+#define TX4938_IR_DMA(ch,n)	((ch ? 27 : 10) + (n)) /* 10-13,27-30 */
+#define TX4938_IR_PIO	14
+#define TX4938_IR_PDMAC	15
+#define TX4938_IR_PCIC	16
+#define TX4938_NUM_IR_TMR	3
+#define TX4938_IR_TMR(n)	(17 + (n))
+#define TX4938_IR_NDFMC	21
+#define TX4938_IR_PCIERR	22
+#define TX4938_IR_PCIPME	23
+#define TX4938_IR_ACLC	24
+#define TX4938_IR_ACLCPME	25
+#define TX4938_IR_PCIC1	26
+#define TX4938_IR_SPI	31
+#define TX4938_NUM_IR	32
+/* multiplex */
+#define TX4938_IR_ETH0	TX4938_IR_INT(4)
+#define TX4938_IR_ETH1	TX4938_IR_INT(3)
+
+/*
+ * CCFG
+ */
+/* CCFG : Chip Configuration */
+#define TX4938_CCFG_WDRST	_CONST64(0x0000020000000000)
+#define TX4938_CCFG_WDREXEN	_CONST64(0x0000010000000000)
+#define TX4938_CCFG_BCFG_MASK	_CONST64(0x000000ff00000000)
+#define TX4938_CCFG_TINTDIS	0x01000000
+#define TX4938_CCFG_PCI66	0x00800000
+#define TX4938_CCFG_PCIMODE	0x00400000
+#define TX4938_CCFG_PCI1_66	0x00200000
+#define TX4938_CCFG_DIVMODE_MASK	0x001e0000
+#define TX4938_CCFG_DIVMODE_2	(0x4 << 17)
+#define TX4938_CCFG_DIVMODE_2_5	(0xf << 17)
+#define TX4938_CCFG_DIVMODE_3	(0x5 << 17)
+#define TX4938_CCFG_DIVMODE_4	(0x6 << 17)
+#define TX4938_CCFG_DIVMODE_4_5	(0xd << 17)
+#define TX4938_CCFG_DIVMODE_8	(0x0 << 17)
+#define TX4938_CCFG_DIVMODE_10	(0xb << 17)
+#define TX4938_CCFG_DIVMODE_12	(0x1 << 17)
+#define TX4938_CCFG_DIVMODE_16	(0x2 << 17)
+#define TX4938_CCFG_DIVMODE_18	(0x9 << 17)
+#define TX4938_CCFG_BEOW	0x00010000
+#define TX4938_CCFG_WR	0x00008000
+#define TX4938_CCFG_TOE	0x00004000
+#define TX4938_CCFG_PCIXARB	0x00002000
+#define TX4938_CCFG_PCIDIVMODE_MASK	0x00001c00
+#define TX4938_CCFG_PCIDIVMODE_4	(0x1 << 10)
+#define TX4938_CCFG_PCIDIVMODE_4_5	(0x3 << 10)
+#define TX4938_CCFG_PCIDIVMODE_5	(0x5 << 10)
+#define TX4938_CCFG_PCIDIVMODE_5_5	(0x7 << 10)
+#define TX4938_CCFG_PCIDIVMODE_8	(0x0 << 10)
+#define TX4938_CCFG_PCIDIVMODE_9	(0x2 << 10)
+#define TX4938_CCFG_PCIDIVMODE_10	(0x4 << 10)
+#define TX4938_CCFG_PCIDIVMODE_11	(0x6 << 10)
+#define TX4938_CCFG_PCI1DMD	0x00000100
+#define TX4938_CCFG_SYSSP_MASK	0x000000c0
+#define TX4938_CCFG_ENDIAN	0x00000004
+#define TX4938_CCFG_HALT	0x00000002
+#define TX4938_CCFG_ACEHOLD	0x00000001
+
+/* PCFG : Pin Configuration */
+#define TX4938_PCFG_ETH0_SEL	_CONST64(0x8000000000000000)
+#define TX4938_PCFG_ETH1_SEL	_CONST64(0x4000000000000000)
+#define TX4938_PCFG_ATA_SEL	_CONST64(0x2000000000000000)
+#define TX4938_PCFG_ISA_SEL	_CONST64(0x1000000000000000)
+#define TX4938_PCFG_SPI_SEL	_CONST64(0x0800000000000000)
+#define TX4938_PCFG_NDF_SEL	_CONST64(0x0400000000000000)
+#define TX4938_PCFG_SDCLKDLY_MASK	0x30000000
+#define TX4938_PCFG_SDCLKDLY(d)	((d)<<28)
+#define TX4938_PCFG_SYSCLKEN	0x08000000
+#define TX4938_PCFG_SDCLKEN_ALL	0x07800000
+#define TX4938_PCFG_SDCLKEN(ch)	(0x00800000<<(ch))
+#define TX4938_PCFG_PCICLKEN_ALL	0x003f0000
+#define TX4938_PCFG_PCICLKEN(ch)	(0x00010000<<(ch))
+#define TX4938_PCFG_SEL2	0x00000200
+#define TX4938_PCFG_SEL1	0x00000100
+#define TX4938_PCFG_DMASEL_ALL	0x0000000f
+#define TX4938_PCFG_DMASEL0_DRQ0	0x00000000
+#define TX4938_PCFG_DMASEL0_SIO1	0x00000001
+#define TX4938_PCFG_DMASEL1_DRQ1	0x00000000
+#define TX4938_PCFG_DMASEL1_SIO1	0x00000002
+#define TX4938_PCFG_DMASEL2_DRQ2	0x00000000
+#define TX4938_PCFG_DMASEL2_SIO0	0x00000004
+#define TX4938_PCFG_DMASEL3_DRQ3	0x00000000
+#define TX4938_PCFG_DMASEL3_SIO0	0x00000008
+
+/* CLKCTR : Clock Control */
+#define TX4938_CLKCTR_NDFCKD	_CONST64(0x0001000000000000)
+#define TX4938_CLKCTR_NDFRST	_CONST64(0x0000000100000000)
+#define TX4938_CLKCTR_ETH1CKD	0x80000000
+#define TX4938_CLKCTR_ETH0CKD	0x40000000
+#define TX4938_CLKCTR_SPICKD	0x20000000
+#define TX4938_CLKCTR_SRAMCKD	0x10000000
+#define TX4938_CLKCTR_PCIC1CKD	0x08000000
+#define TX4938_CLKCTR_DMA1CKD	0x04000000
+#define TX4938_CLKCTR_ACLCKD	0x02000000
+#define TX4938_CLKCTR_PIOCKD	0x01000000
+#define TX4938_CLKCTR_DMACKD	0x00800000
+#define TX4938_CLKCTR_PCICKD	0x00400000
+#define TX4938_CLKCTR_TM0CKD	0x00100000
+#define TX4938_CLKCTR_TM1CKD	0x00080000
+#define TX4938_CLKCTR_TM2CKD	0x00040000
+#define TX4938_CLKCTR_SIO0CKD	0x00020000
+#define TX4938_CLKCTR_SIO1CKD	0x00010000
+#define TX4938_CLKCTR_ETH1RST	0x00008000
+#define TX4938_CLKCTR_ETH0RST	0x00004000
+#define TX4938_CLKCTR_SPIRST	0x00002000
+#define TX4938_CLKCTR_SRAMRST	0x00001000
+#define TX4938_CLKCTR_PCIC1RST	0x00000800
+#define TX4938_CLKCTR_DMA1RST	0x00000400
+#define TX4938_CLKCTR_ACLRST	0x00000200
+#define TX4938_CLKCTR_PIORST	0x00000100
+#define TX4938_CLKCTR_DMARST	0x00000080
+#define TX4938_CLKCTR_PCIRST	0x00000040
+#define TX4938_CLKCTR_TM0RST	0x00000010
+#define TX4938_CLKCTR_TM1RST	0x00000008
+#define TX4938_CLKCTR_TM2RST	0x00000004
+#define TX4938_CLKCTR_SIO0RST	0x00000002
+#define TX4938_CLKCTR_SIO1RST	0x00000001
+
+/* bits for G2PSTATUS/G2PMASK */
+#define TX4938_PCIC_G2PSTATUS_ALL	0x00000003
+#define TX4938_PCIC_G2PSTATUS_TTOE	0x00000002
+#define TX4938_PCIC_G2PSTATUS_RTOE	0x00000001
+
+/* bits for PCIMASK (see also PCI_STATUS_XXX in linux/pci.h */
+#define TX4938_PCIC_PCISTATUS_ALL	0x0000f900
+
+/* bits for PBACFG */
+#define TX4938_PCIC_PBACFG_FIXPA	0x00000008
+#define TX4938_PCIC_PBACFG_RPBA	0x00000004
+#define TX4938_PCIC_PBACFG_PBAEN	0x00000002
+#define TX4938_PCIC_PBACFG_BMCEN	0x00000001
+
+/* bits for G2PMnGBASE */
+#define TX4938_PCIC_G2PMnGBASE_BSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_G2PMnGBASE_ECHG	_CONST64(0x0000001000000000)
+
+/* bits for G2PIOGBASE */
+#define TX4938_PCIC_G2PIOGBASE_BSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_G2PIOGBASE_ECHG	_CONST64(0x0000001000000000)
+
+/* bits for PCICSTATUS/PCICMASK */
+#define TX4938_PCIC_PCICSTATUS_ALL	0x000007b8
+#define TX4938_PCIC_PCICSTATUS_PME	0x00000400
+#define TX4938_PCIC_PCICSTATUS_TLB	0x00000200
+#define TX4938_PCIC_PCICSTATUS_NIB	0x00000100
+#define TX4938_PCIC_PCICSTATUS_ZIB	0x00000080
+#define TX4938_PCIC_PCICSTATUS_PERR	0x00000020
+#define TX4938_PCIC_PCICSTATUS_SERR	0x00000010
+#define TX4938_PCIC_PCICSTATUS_GBE	0x00000008
+#define TX4938_PCIC_PCICSTATUS_IWB	0x00000002
+#define TX4938_PCIC_PCICSTATUS_E2PDONE	0x00000001
+
+/* bits for PCICCFG */
+#define TX4938_PCIC_PCICCFG_GBWC_MASK	0x0fff0000
+#define TX4938_PCIC_PCICCFG_HRST	0x00000800
+#define TX4938_PCIC_PCICCFG_SRST	0x00000400
+#define TX4938_PCIC_PCICCFG_IRBER	0x00000200
+#define TX4938_PCIC_PCICCFG_G2PMEN(ch)	(0x00000100>>(ch))
+#define TX4938_PCIC_PCICCFG_G2PM0EN	0x00000100
+#define TX4938_PCIC_PCICCFG_G2PM1EN	0x00000080
+#define TX4938_PCIC_PCICCFG_G2PM2EN	0x00000040
+#define TX4938_PCIC_PCICCFG_G2PIOEN	0x00000020
+#define TX4938_PCIC_PCICCFG_TCAR	0x00000010
+#define TX4938_PCIC_PCICCFG_ICAEN	0x00000008
+
+/* bits for P2GMnGBASE */
+#define TX4938_PCIC_P2GMnGBASE_TMEMEN	_CONST64(0x0000004000000000)
+#define TX4938_PCIC_P2GMnGBASE_TBSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_P2GMnGBASE_TECHG	_CONST64(0x0000001000000000)
+
+/* bits for P2GIOGBASE */
+#define TX4938_PCIC_P2GIOGBASE_TIOEN	_CONST64(0x0000004000000000)
+#define TX4938_PCIC_P2GIOGBASE_TBSDIS	_CONST64(0x0000002000000000)
+#define TX4938_PCIC_P2GIOGBASE_TECHG	_CONST64(0x0000001000000000)
+
+#define TX4938_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
+#define TX4938_PCIC_MAX_DEVNU	TX4938_PCIC_IDSEL_AD_TO_SLOT(32)
+
+/* bits for PDMCFG */
+#define TX4938_PCIC_PDMCFG_RSTFIFO	0x00200000
+#define TX4938_PCIC_PDMCFG_EXFER	0x00100000
+#define TX4938_PCIC_PDMCFG_REQDLY_MASK	0x00003800
+#define TX4938_PCIC_PDMCFG_REQDLY_NONE	(0 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_16	(1 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_32	(2 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_64	(3 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_128	(4 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_256	(5 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_512	(6 << 11)
+#define TX4938_PCIC_PDMCFG_REQDLY_1024	(7 << 11)
+#define TX4938_PCIC_PDMCFG_ERRIE	0x00000400
+#define TX4938_PCIC_PDMCFG_NCCMPIE	0x00000200
+#define TX4938_PCIC_PDMCFG_NTCMPIE	0x00000100
+#define TX4938_PCIC_PDMCFG_CHNEN	0x00000080
+#define TX4938_PCIC_PDMCFG_XFRACT	0x00000040
+#define TX4938_PCIC_PDMCFG_BSWAP	0x00000020
+#define TX4938_PCIC_PDMCFG_XFRSIZE_MASK	0x0000000c
+#define TX4938_PCIC_PDMCFG_XFRSIZE_1DW	0x00000000
+#define TX4938_PCIC_PDMCFG_XFRSIZE_1QW	0x00000004
+#define TX4938_PCIC_PDMCFG_XFRSIZE_4QW	0x00000008
+#define TX4938_PCIC_PDMCFG_XFRDIRC	0x00000002
+#define TX4938_PCIC_PDMCFG_CHRST	0x00000001
+
+/* bits for PDMSTS */
+#define TX4938_PCIC_PDMSTS_REQCNT_MASK	0x3f000000
+#define TX4938_PCIC_PDMSTS_FIFOCNT_MASK	0x00f00000
+#define TX4938_PCIC_PDMSTS_FIFOWP_MASK	0x000c0000
+#define TX4938_PCIC_PDMSTS_FIFORP_MASK	0x00030000
+#define TX4938_PCIC_PDMSTS_ERRINT	0x00000800
+#define TX4938_PCIC_PDMSTS_DONEINT	0x00000400
+#define TX4938_PCIC_PDMSTS_CHNEN	0x00000200
+#define TX4938_PCIC_PDMSTS_XFRACT	0x00000100
+#define TX4938_PCIC_PDMSTS_ACCMP	0x00000080
+#define TX4938_PCIC_PDMSTS_NCCMP	0x00000040
+#define TX4938_PCIC_PDMSTS_NTCMP	0x00000020
+#define TX4938_PCIC_PDMSTS_CFGERR	0x00000008
+#define TX4938_PCIC_PDMSTS_PCIERR	0x00000004
+#define TX4938_PCIC_PDMSTS_CHNERR	0x00000002
+#define TX4938_PCIC_PDMSTS_DATAERR	0x00000001
+#define TX4938_PCIC_PDMSTS_ALL_CMP	0x000000e0
+#define TX4938_PCIC_PDMSTS_ALL_ERR	0x0000000f
+
+/*
+ * DMA
+ */
+/* bits for MCR */
+#define TX4938_DMA_MCR_EIS(ch)	(0x10000000<<(ch))
+#define TX4938_DMA_MCR_DIS(ch)	(0x01000000<<(ch))
+#define TX4938_DMA_MCR_RSFIF	0x00000080
+#define TX4938_DMA_MCR_FIFUM(ch)	(0x00000008<<(ch))
+#define TX4938_DMA_MCR_RPRT	0x00000002
+#define TX4938_DMA_MCR_MSTEN	0x00000001
+
+/* bits for CCRn */
+#define TX4938_DMA_CCR_IMMCHN	0x20000000
+#define TX4938_DMA_CCR_USEXFSZ	0x10000000
+#define TX4938_DMA_CCR_LE	0x08000000
+#define TX4938_DMA_CCR_DBINH	0x04000000
+#define TX4938_DMA_CCR_SBINH	0x02000000
+#define TX4938_DMA_CCR_CHRST	0x01000000
+#define TX4938_DMA_CCR_RVBYTE	0x00800000
+#define TX4938_DMA_CCR_ACKPOL	0x00400000
+#define TX4938_DMA_CCR_REQPL	0x00200000
+#define TX4938_DMA_CCR_EGREQ	0x00100000
+#define TX4938_DMA_CCR_CHDN	0x00080000
+#define TX4938_DMA_CCR_DNCTL	0x00060000
+#define TX4938_DMA_CCR_EXTRQ	0x00010000
+#define TX4938_DMA_CCR_INTRQD	0x0000e000
+#define TX4938_DMA_CCR_INTENE	0x00001000
+#define TX4938_DMA_CCR_INTENC	0x00000800
+#define TX4938_DMA_CCR_INTENT	0x00000400
+#define TX4938_DMA_CCR_CHNEN	0x00000200
+#define TX4938_DMA_CCR_XFACT	0x00000100
+#define TX4938_DMA_CCR_SMPCHN	0x00000020
+#define TX4938_DMA_CCR_XFSZ(order)	(((order) << 2) & 0x0000001c)
+#define TX4938_DMA_CCR_XFSZ_1W	TX4938_DMA_CCR_XFSZ(2)
+#define TX4938_DMA_CCR_XFSZ_2W	TX4938_DMA_CCR_XFSZ(3)
+#define TX4938_DMA_CCR_XFSZ_4W	TX4938_DMA_CCR_XFSZ(4)
+#define TX4938_DMA_CCR_XFSZ_8W	TX4938_DMA_CCR_XFSZ(5)
+#define TX4938_DMA_CCR_XFSZ_16W	TX4938_DMA_CCR_XFSZ(6)
+#define TX4938_DMA_CCR_XFSZ_32W	TX4938_DMA_CCR_XFSZ(7)
+#define TX4938_DMA_CCR_MEMIO	0x00000002
+#define TX4938_DMA_CCR_SNGAD	0x00000001
+
+/* bits for CSRn */
+#define TX4938_DMA_CSR_CHNEN	0x00000400
+#define TX4938_DMA_CSR_STLXFER	0x00000200
+#define TX4938_DMA_CSR_CHNACT	0x00000100
+#define TX4938_DMA_CSR_ABCHC	0x00000080
+#define TX4938_DMA_CSR_NCHNC	0x00000040
+#define TX4938_DMA_CSR_NTRNFC	0x00000020
+#define TX4938_DMA_CSR_EXTDN	0x00000010
+#define TX4938_DMA_CSR_CFERR	0x00000008
+#define TX4938_DMA_CSR_CHERR	0x00000004
+#define TX4938_DMA_CSR_DESERR	0x00000002
+#define TX4938_DMA_CSR_SORERR	0x00000001
+
+/* TX4938 Interrupt Controller (32-bit registers) */
+#define TX4938_IRC_BASE                 0xf510
+#define TX4938_IRC_IRFLAG0              0xf510
+#define TX4938_IRC_IRFLAG1              0xf514
+#define TX4938_IRC_IRPOL                0xf518
+#define TX4938_IRC_IRRCNT               0xf51c
+#define TX4938_IRC_IRMASKINT            0xf520
+#define TX4938_IRC_IRMASKEXT            0xf524
+#define TX4938_IRC_IRDEN                0xf600
+#define TX4938_IRC_IRDM0                0xf604
+#define TX4938_IRC_IRDM1                0xf608
+#define TX4938_IRC_IRLVL0               0xf610
+#define TX4938_IRC_IRLVL1               0xf614
+#define TX4938_IRC_IRLVL2               0xf618
+#define TX4938_IRC_IRLVL3               0xf61c
+#define TX4938_IRC_IRLVL4               0xf620
+#define TX4938_IRC_IRLVL5               0xf624
+#define TX4938_IRC_IRLVL6               0xf628
+#define TX4938_IRC_IRLVL7               0xf62c
+#define TX4938_IRC_IRMSK                0xf640
+#define TX4938_IRC_IREDC                0xf660
+#define TX4938_IRC_IRPND                0xf680
+#define TX4938_IRC_IRCS                 0xf6a0
+#define TX4938_IRC_LIMIT                0xf6ff
+
+
+#ifndef __ASSEMBLY__
+
+#define tx4938_sdramcptr	((struct tx4938_sdramc_reg *)TX4938_SDRAMC_REG)
+#define tx4938_ebuscptr         ((struct tx4938_ebusc_reg *)TX4938_EBUSC_REG)
+#define tx4938_dmaptr(ch)	((struct tx4938_dma_reg *)TX4938_DMA_REG(ch))
+#define tx4938_ndfmcptr		((struct tx4938_ndfmc_reg *)TX4938_NDFMC_REG)
+#define tx4938_ircptr		((struct tx4938_irc_reg *)TX4938_IRC_REG)
+#define tx4938_pcicptr		((struct tx4938_pcic_reg *)TX4938_PCIC_REG)
+#define tx4938_pcic1ptr		((struct tx4938_pcic_reg *)TX4938_PCIC1_REG)
+#define tx4938_ccfgptr		((struct tx4938_ccfg_reg *)TX4938_CCFG_REG)
+#define tx4938_tmrptr(ch)	((struct tx4938_tmr_reg *)TX4938_TMR_REG(ch))
+#define tx4938_sioptr(ch)	((struct tx4938_sio_reg *)TX4938_SIO_REG(ch))
+#define tx4938_pioptr		((struct tx4938_pio_reg *)TX4938_PIO_REG)
+#define tx4938_aclcptr		((struct tx4938_aclc_reg *)TX4938_ACLC_REG)
+#define tx4938_spiptr		((struct tx4938_spi_reg *)TX4938_SPI_REG)
+#define tx4938_sramcptr		((struct tx4938_sramc_reg *)TX4938_SRAMC_REG)
+
+
+#define TX4938_REV_MAJ_MIN()	((unsigned long)tx4938_ccfgptr->crir & 0x00ff)
+#define TX4938_REV_PCODE()	((unsigned long)tx4938_ccfgptr->crir >> 16)
+
+#define TX4938_SDRAMC_BA(ch)	((tx4938_sdramcptr->cr[ch] >> 49) << 21)
+#define TX4938_SDRAMC_SIZE(ch)	(((tx4938_sdramcptr->cr[ch] >> 33) + 1) << 21)
+
+#define TX4938_EBUSC_BA(ch)	((tx4938_ebuscptr->cr[ch] >> 48) << 20)
+#define TX4938_EBUSC_SIZE(ch)	\
+	(0x00100000 << ((unsigned long)(tx4938_ebuscptr->cr[ch] >> 8) & 0xf))
+
+
+#endif /* !__ASSEMBLY__ */
+
+#endif
diff -Naur linux-2.6.14/include/asm-mips/tx4938/tx4938_mips.h linux-mips-2.6.14.orig/include/asm-mips/tx4938/tx4938_mips.h
--- linux-2.6.14/include/asm-mips/tx4938/tx4938_mips.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/asm-mips/tx4938/tx4938_mips.h	2005-11-17 11:44:27.000000000 -0800
@@ -0,0 +1,54 @@
+/*
+ * linux/include/asm-mips/tx4938/tx4938_bitmask.h
+ * Generic bitmask definitions
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+#ifndef TX4938_TX4938_MIPS_H
+#define TX4938_TX4938_MIPS_H
+#ifndef __ASSEMBLY__
+
+#define reg_rd08(r)    ((u8 )(*((vu8 *)(r))))
+#define reg_rd16(r)    ((u16)(*((vu16*)(r))))
+#define reg_rd32(r)    ((u32)(*((vu32*)(r))))
+#define reg_rd64(r)    ((u64)(*((vu64*)(r))))
+
+#define reg_wr08(r,v)  ((*((vu8 *)(r)))=((u8 )(v)))
+#define reg_wr16(r,v)  ((*((vu16*)(r)))=((u16)(v)))
+#define reg_wr32(r,v)  ((*((vu32*)(r)))=((u32)(v)))
+#define reg_wr64(r,v)  ((*((vu64*)(r)))=((u64)(v)))
+
+typedef volatile __signed char vs8;
+typedef volatile unsigned char vu8;
+
+typedef volatile __signed short vs16;
+typedef volatile unsigned short vu16;
+
+typedef volatile __signed int vs32;
+typedef volatile unsigned int vu32;
+
+typedef s8 s08;
+typedef vs8 vs08;
+
+typedef u8 u08;
+typedef vu8 vu08;
+
+#if (_MIPS_SZLONG == 64)
+
+typedef volatile __signed__ long vs64;
+typedef volatile unsigned long vu64;
+
+#else
+
+typedef volatile __signed__ long long vs64;
+typedef volatile unsigned long long vu64;
+
+#endif
+#endif
+#endif
diff -Naur linux-2.6.14/include/asm-mips/uaccess.h linux-mips-2.6.14.orig/include/asm-mips/uaccess.h
--- linux-2.6.14/include/asm-mips/uaccess.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/uaccess.h	2005-11-17 11:44:27.000000000 -0800
@@ -196,63 +196,55 @@
 	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))
 
 struct __large_struct { unsigned long buf[100]; };
-#define __m(x) (*(struct __large_struct *)(x))
+#define __m(x) (*(struct __large_struct __user *)(x))
 
 /*
  * Yuck.  We need two variants, one for 64bit operation and one
  * for 32 bit mode and old iron.
  */
 #ifdef __mips64
-#define __GET_USER_DW(__gu_err) __get_user_asm("ld", __gu_err)
+#define __GET_USER_DW(ptr) __get_user_asm("ld", ptr)
 #else
-#define __GET_USER_DW(__gu_err) __get_user_asm_ll32(__gu_err)
+#define __GET_USER_DW(ptr) __get_user_asm_ll32(ptr)
 #endif
 
 #define __get_user_nocheck(x,ptr,size)					\
 ({									\
-	__typeof(*(ptr)) __gu_val = 0;					\
-	long __gu_addr;							\
+	__typeof(*(ptr)) __gu_val =  (__typeof(*(ptr))) 0;		\
 	long __gu_err = 0;						\
 									\
-	might_sleep();							\
-	__gu_addr = (long) (ptr);					\
 	switch (size) {							\
-	case 1: __get_user_asm("lb", __gu_err); break;			\
-	case 2: __get_user_asm("lh", __gu_err); break;			\
-	case 4: __get_user_asm("lw", __gu_err); break;			\
-	case 8: __GET_USER_DW(__gu_err); break;				\
+	case 1: __get_user_asm("lb", ptr); break;			\
+	case 2: __get_user_asm("lh", ptr); break;			\
+	case 4: __get_user_asm("lw", ptr); break;			\
+	case 8: __GET_USER_DW(ptr); break;				\
 	default: __get_user_unknown(); break;				\
 	}								\
-	x = (__typeof__(*(ptr))) __gu_val;				\
+	(x) = (__typeof__(*(ptr))) __gu_val;				\
 	__gu_err;							\
 })
 
 #define __get_user_check(x,ptr,size)					\
 ({									\
+	const __typeof__(*(ptr)) __user * __gu_addr = (ptr);		\
 	__typeof__(*(ptr)) __gu_val = 0;				\
-	long __gu_addr;							\
-	long __gu_err;							\
-									\
-	might_sleep();							\
-	__gu_addr = (long) (ptr);					\
-	__gu_err = access_ok(VERIFY_READ, (void *) __gu_addr, size)	\
-				? 0 : -EFAULT;				\
+	long __gu_err = -EFAULT;					\
 									\
-	if (likely(!__gu_err)) {					\
+	if (likely(access_ok(VERIFY_READ,  __gu_addr, size))) {		\
 		switch (size) {						\
-		case 1: __get_user_asm("lb", __gu_err); break;		\
-		case 2: __get_user_asm("lh", __gu_err); break;		\
-		case 4: __get_user_asm("lw", __gu_err); break;		\
-		case 8: __GET_USER_DW(__gu_err); break;			\
+		case 1: __get_user_asm("lb", __gu_addr); break;		\
+		case 2: __get_user_asm("lh", __gu_addr); break;		\
+		case 4: __get_user_asm("lw", __gu_addr); break;		\
+		case 8: __GET_USER_DW(__gu_addr); break;		\
 		default: __get_user_unknown(); break;			\
 		}							\
 	}								\
-	x = (__typeof__(*(ptr))) __gu_val;				\
+	(x) = (__typeof__(*(ptr))) __gu_val;				\
 	__gu_err;							\
 })
 
-#define __get_user_asm(insn,__gu_err)					\
-({									\
+#define __get_user_asm(insn, addr)					\
+{									\
 	__asm__ __volatile__(						\
 	"1:	" insn "	%1, %3				\n"	\
 	"2:							\n"	\
@@ -264,20 +256,20 @@
 	"	"__UA_ADDR "\t1b, 3b				\n"	\
 	"	.previous					\n"	\
 	: "=r" (__gu_err), "=r" (__gu_val)				\
-	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
-})
+	: "0" (0), "o" (__m(addr)), "i" (-EFAULT));			\
+}
 
 /*
  * Get a long long 64 using 32 bit registers.
  */
-#define __get_user_asm_ll32(__gu_err)					\
-({									\
+#define __get_user_asm_ll32(addr)					\
+{									\
 	__asm__ __volatile__(						\
-	"1:	lw	%1, %3					\n"	\
-	"2:	lw	%D1, %4					\n"	\
+	"1:	lw	%1, (%3)				\n"	\
+	"2:	lw	%D1, 4(%3)				\n"	\
 	"	move	%0, $0					\n"	\
 	"3:	.section	.fixup,\"ax\"			\n"	\
-	"4:	li	%0, %5					\n"	\
+	"4:	li	%0, %4					\n"	\
 	"	move	%1, $0					\n"	\
 	"	move	%D1, $0					\n"	\
 	"	j	3b					\n"	\
@@ -287,9 +279,8 @@
 	"	" __UA_ADDR "	2b, 4b				\n"	\
 	"	.previous					\n"	\
 	: "=r" (__gu_err), "=&r" (__gu_val)				\
-	: "0" (__gu_err), "o" (__m(__gu_addr)),				\
-	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
-})
+	: "0" (0), "r" (addr), "i" (-EFAULT));				\
+}
 
 extern void __get_user_unknown(void);
 
@@ -298,25 +289,22 @@
  * for 32 bit mode and old iron.
  */
 #ifdef __mips64
-#define __PUT_USER_DW(__pu_val) __put_user_asm("sd", __pu_val)
+#define __PUT_USER_DW(ptr) __put_user_asm("sd", ptr)
 #else
-#define __PUT_USER_DW(__pu_val) __put_user_asm_ll32(__pu_val)
+#define __PUT_USER_DW(ptr) __put_user_asm_ll32(ptr)
 #endif
 
 #define __put_user_nocheck(x,ptr,size)					\
 ({									\
 	__typeof__(*(ptr)) __pu_val;					\
-	long __pu_addr;							\
 	long __pu_err = 0;						\
 									\
-	might_sleep();							\
 	__pu_val = (x);							\
-	__pu_addr = (long) (ptr);					\
 	switch (size) {							\
-	case 1: __put_user_asm("sb", __pu_val); break;			\
-	case 2: __put_user_asm("sh", __pu_val); break;			\
-	case 4: __put_user_asm("sw", __pu_val); break;			\
-	case 8: __PUT_USER_DW(__pu_val); break;				\
+	case 1: __put_user_asm("sb", ptr); break;			\
+	case 2: __put_user_asm("sh", ptr); break;			\
+	case 4: __put_user_asm("sw", ptr); break;			\
+	case 8: __PUT_USER_DW(ptr); break;				\
 	default: __put_user_unknown(); break;				\
 	}								\
 	__pu_err;							\
@@ -324,30 +312,24 @@
 
 #define __put_user_check(x,ptr,size)					\
 ({									\
-	__typeof__(*(ptr)) __pu_val;					\
-	long __pu_addr;							\
-	long __pu_err;							\
+	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\
+	__typeof__(*(ptr)) __pu_val = (x);				\
+	long __pu_err = -EFAULT;					\
 									\
-	might_sleep();							\
-	__pu_val = (x);							\
-	__pu_addr = (long) (ptr);					\
-	__pu_err = access_ok(VERIFY_WRITE, (void *) __pu_addr, size)	\
-				? 0 : -EFAULT;				\
-									\
-	if (likely(!__pu_err)) {					\
+	if (likely(access_ok(VERIFY_WRITE,  __pu_addr, size))) {	\
 		switch (size) {						\
-		case 1: __put_user_asm("sb", __pu_val); break;		\
-		case 2: __put_user_asm("sh", __pu_val); break;		\
-		case 4: __put_user_asm("sw", __pu_val); break;		\
-		case 8: __PUT_USER_DW(__pu_val); break;			\
+		case 1: __put_user_asm("sb", __pu_addr); break;		\
+		case 2: __put_user_asm("sh", __pu_addr); break;		\
+		case 4: __put_user_asm("sw", __pu_addr); break;		\
+		case 8: __PUT_USER_DW(__pu_addr); break;		\
 		default: __put_user_unknown(); break;			\
 		}							\
 	}								\
 	__pu_err;							\
 })
 
-#define __put_user_asm(insn, __pu_val)					\
-({									\
+#define __put_user_asm(insn, ptr)					\
+{									\
 	__asm__ __volatile__(						\
 	"1:	" insn "	%z2, %3		# __put_user_asm\n"	\
 	"2:							\n"	\
@@ -359,18 +341,18 @@
 	"	" __UA_ADDR "	1b, 3b				\n"	\
 	"	.previous					\n"	\
 	: "=r" (__pu_err)						\
-	: "0" (__pu_err), "Jr" (__pu_val), "o" (__m(__pu_addr)),	\
+	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
 	  "i" (-EFAULT));						\
-})
+}
 
-#define __put_user_asm_ll32(__pu_val)					\
-({									\
+#define __put_user_asm_ll32(ptr)					\
+{									\
 	__asm__ __volatile__(						\
-	"1:	sw	%2, %3		# __put_user_asm_ll32	\n"	\
-	"2:	sw	%D2, %4					\n"	\
+	"1:	sw	%2, (%3)	# __put_user_asm_ll32	\n"	\
+	"2:	sw	%D2, 4(%3)				\n"	\
 	"3:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
-	"4:	li	%0, %5					\n"	\
+	"4:	li	%0, %4					\n"	\
 	"	j	3b					\n"	\
 	"	.previous					\n"	\
 	"	.section	__ex_table,\"a\"		\n"	\
@@ -378,9 +360,9 @@
 	"	" __UA_ADDR "	2b, 4b				\n"	\
 	"	.previous"						\
 	: "=r" (__pu_err)						\
-	: "0" (__pu_err), "r" (__pu_val), "o" (__m(__pu_addr)),		\
-	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
-})
+	: "0" (0), "r" (__pu_val), "r" (ptr),				\
+	  "i" (-EFAULT));						\
+}
 
 extern void __put_user_unknown(void);
 
@@ -403,7 +385,7 @@
 
 #define __invoke_copy_to_user(to,from,n)				\
 ({									\
-	register void *__cu_to_r __asm__ ("$4");			\
+	register void __user *__cu_to_r __asm__ ("$4");			\
 	register const void *__cu_from_r __asm__ ("$5");		\
 	register long __cu_len_r __asm__ ("$6");			\
 									\
@@ -435,7 +417,7 @@
  */
 #define __copy_to_user(to,from,n)					\
 ({									\
-	void *__cu_to;							\
+	void __user *__cu_to;						\
 	const void *__cu_from;						\
 	long __cu_len;							\
 									\
@@ -465,7 +447,7 @@
  */
 #define copy_to_user(to,from,n)						\
 ({									\
-	void *__cu_to;							\
+	void __user *__cu_to;						\
 	const void *__cu_from;						\
 	long __cu_len;							\
 									\
@@ -482,7 +464,7 @@
 #define __invoke_copy_from_user(to,from,n)				\
 ({									\
 	register void *__cu_to_r __asm__ ("$4");			\
-	register const void *__cu_from_r __asm__ ("$5");		\
+	register const void __user *__cu_from_r __asm__ ("$5");		\
 	register long __cu_len_r __asm__ ("$6");			\
 									\
 	__cu_to_r = (to);						\
@@ -521,7 +503,7 @@
 #define __copy_from_user(to,from,n)					\
 ({									\
 	void *__cu_to;							\
-	const void *__cu_from;						\
+	const void __user *__cu_from;					\
 	long __cu_len;							\
 									\
 	might_sleep();							\
@@ -552,7 +534,7 @@
 #define copy_from_user(to,from,n)					\
 ({									\
 	void *__cu_to;							\
-	const void *__cu_from;						\
+	const void __user *__cu_from;					\
 	long __cu_len;							\
 									\
 	might_sleep();							\
@@ -569,8 +551,8 @@
 
 #define copy_in_user(to,from,n)						\
 ({									\
-	void *__cu_to;							\
-	const void *__cu_from;						\
+	void __user *__cu_to;						\
+	const void __user *__cu_from;					\
 	long __cu_len;							\
 									\
 	might_sleep();							\
@@ -596,7 +578,7 @@
  * On success, this will be zero.
  */
 static inline __kernel_size_t
-__clear_user(void *addr, __kernel_size_t size)
+__clear_user(void __user *addr, __kernel_size_t size)
 {
 	__kernel_size_t res;
 
@@ -616,7 +598,7 @@
 
 #define clear_user(addr,n)						\
 ({									\
-	void * __cl_addr = (addr);					\
+	void __user * __cl_addr = (addr);				\
 	unsigned long __cl_size = (n);					\
 	if (__cl_size && access_ok(VERIFY_WRITE,			\
 		((unsigned long)(__cl_addr)), __cl_size))		\
@@ -645,7 +627,7 @@
  * and returns @count.
  */
 static inline long
-__strncpy_from_user(char *__to, const char *__from, long __len)
+__strncpy_from_user(char *__to, const char __user *__from, long __len)
 {
 	long res;
 
@@ -682,7 +664,7 @@
  * and returns @count.
  */
 static inline long
-strncpy_from_user(char *__to, const char *__from, long __len)
+strncpy_from_user(char *__to, const char __user *__from, long __len)
 {
 	long res;
 
@@ -701,7 +683,7 @@
 }
 
 /* Returns: 0 if bad, string length+1 (memory size) of string if ok */
-static inline long __strlen_user(const char *s)
+static inline long __strlen_user(const char __user *s)
 {
 	long res;
 
@@ -731,7 +713,7 @@
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
-static inline long strlen_user(const char *s)
+static inline long strlen_user(const char __user *s)
 {
 	long res;
 
@@ -748,7 +730,7 @@
 }
 
 /* Returns: 0 if bad, string length+1 (memory size) of string if ok */
-static inline long __strnlen_user(const char *s, long n)
+static inline long __strnlen_user(const char __user *s, long n)
 {
 	long res;
 
@@ -779,7 +761,7 @@
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
-static inline long strnlen_user(const char *s, long n)
+static inline long strnlen_user(const char __user *s, long n)
 {
 	long res;
 
diff -Naur linux-2.6.14/include/asm-mips/unistd.h linux-mips-2.6.14.orig/include/asm-mips/unistd.h
--- linux-2.6.14/include/asm-mips/unistd.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/unistd.h	2005-11-17 11:44:27.000000000 -0800
@@ -303,16 +303,21 @@
 #define __NR_add_key			(__NR_Linux + 280)
 #define __NR_request_key		(__NR_Linux + 281)
 #define __NR_keyctl			(__NR_Linux + 282)
+#define __NR_set_thread_area		(__NR_Linux + 283)
+#define __NR_inotify_init		(__NR_Linux + 284)
+#define __NR_inotify_add_watch		(__NR_Linux + 285)
+#define __NR_inotify_rm_watch		(__NR_Linux + 286)
+
 
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		282
+#define __NR_Linux_syscalls		286
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
 #define __NR_O32_Linux			4000
-#define __NR_O32_Linux_syscalls		282
+#define __NR_O32_Linux_syscalls		283
 
 #if _MIPS_SIM == _MIPS_SIM_ABI64
 
@@ -562,16 +567,20 @@
 #define __NR_add_key			(__NR_Linux + 239)
 #define __NR_request_key		(__NR_Linux + 240)
 #define __NR_keyctl			(__NR_Linux + 241)
+#define __NR_set_thread_area		(__NR_Linux + 242)
+#define __NR_inotify_init		(__NR_Linux + 243)
+#define __NR_inotify_add_watch		(__NR_Linux + 244)
+#define __NR_inotify_rm_watch		(__NR_Linux + 245)
 
 /*
  * Offset of the last Linux 64-bit flavoured syscall
  */
-#define __NR_Linux_syscalls		241
+#define __NR_Linux_syscalls		245
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #define __NR_64_Linux			5000
-#define __NR_64_Linux_syscalls		241
+#define __NR_64_Linux_syscalls		242
 
 #if _MIPS_SIM == _MIPS_SIM_NABI32
 
@@ -825,16 +834,20 @@
 #define __NR_add_key			(__NR_Linux + 243)
 #define __NR_request_key		(__NR_Linux + 244)
 #define __NR_keyctl			(__NR_Linux + 245)
+#define __NR_set_thread_area		(__NR_Linux + 246)
+#define __NR_inotify_init		(__NR_Linux + 247)
+#define __NR_inotify_add_watch		(__NR_Linux + 248)
+#define __NR_inotify_rm_watch		(__NR_Linux + 249)
 
 /*
  * Offset of the last N32 flavoured syscall
  */
-#define __NR_Linux_syscalls		245
+#define __NR_Linux_syscalls		249
 
 #endif /* _MIPS_SIM == _MIPS_SIM_NABI32 */
 
 #define __NR_N32_Linux			6000
-#define __NR_N32_Linux_syscalls		245
+#define __NR_N32_Linux_syscalls		246
 
 #ifndef __ASSEMBLY__
 
diff -Naur linux-2.6.14/include/asm-mips/vga.h linux-mips-2.6.14.orig/include/asm-mips/vga.h
--- linux-2.6.14/include/asm-mips/vga.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/vga.h	2005-11-17 11:44:27.000000000 -0800
@@ -6,6 +6,8 @@
 #ifndef _ASM_VGA_H
 #define _ASM_VGA_H
 
+#include <asm/byteorder.h>
+
 /*
  *	On the PC, we can just recalculate addresses and then
  *	access the videoram directly without any black magic.
@@ -16,4 +18,27 @@
 #define vga_readb(x)	(*(x))
 #define vga_writeb(x,y)	(*(y) = (x))
 
+#define VT_BUF_HAVE_RW
+/*
+ *  These are only needed for supporting VGA or MDA text mode, which use little
+ *  endian byte ordering.
+ *  In other cases, we can optimize by using native byte ordering and
+ *  <linux/vt_buffer.h> has already done the right job for us.
+ */
+
+static inline void scr_writew(u16 val, volatile u16 *addr)
+{
+	*addr = cpu_to_le16(val);
+}
+
+static inline u16 scr_readw(volatile const u16 *addr)
+{
+	return le16_to_cpu(*addr);
+}
+
+#define scr_memcpyw(d, s, c) memcpy(d, s, c)
+#define scr_memmovew(d, s, c) memmove(d, s, c)
+#define VT_BUF_HAVE_MEMCPYW
+#define VT_BUF_HAVE_MEMMOVEW
+
 #endif /* _ASM_VGA_H */
diff -Naur linux-2.6.14/include/asm-mips/vr41xx/siu.h linux-mips-2.6.14.orig/include/asm-mips/vr41xx/siu.h
--- linux-2.6.14/include/asm-mips/vr41xx/siu.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/vr41xx/siu.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,50 +0,0 @@
-/*
- *  Include file for NEC VR4100 series Serial Interface Unit.
- *
- *  Copyright (C) 2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#ifndef __NEC_VR41XX_SIU_H
-#define __NEC_VR41XX_SIU_H
-
-typedef enum {
-	SIU_INTERFACE_RS232C,
-	SIU_INTERFACE_IRDA,
-} siu_interface_t;
-
-extern void vr41xx_select_siu_interface(siu_interface_t interface);
-
-typedef enum {
-	SIU_USE_IRDA,
-	FIR_USE_IRDA,
-} irda_use_t;
-
-extern void vr41xx_use_irda(irda_use_t use);
-
-typedef enum {
-	SHARP_IRDA,
-	TEMIC_IRDA,
-	HP_IRDA,
-} irda_module_t;
-
-typedef enum {
-	IRDA_TX_1_5MBPS,
-	IRDA_TX_4MBPS,
-} irda_speed_t;
-
-extern void vr41xx_select_irda_module(irda_module_t module, irda_speed_t speed);
-
-#endif /* __NEC_VR41XX_SIU_H */
diff -Naur linux-2.6.14/include/asm-mips/vr41xx/tb0287.h linux-mips-2.6.14.orig/include/asm-mips/vr41xx/tb0287.h
--- linux-2.6.14/include/asm-mips/vr41xx/tb0287.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/vr41xx/tb0287.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,43 +0,0 @@
-/*
- *  tb0287.h, Include file for TANBAC TB0287 mini-ITX board.
- *
- *  Copyright (C) 2005  Media Lab Inc. <ito@mlb.co.jp>
- *
- *  This code is largely based on tb0219.h.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#ifndef __TANBAC_TB0287_H
-#define __TANBAC_TB0287_H
-
-#include <asm/vr41xx/vr41xx.h>
-
-/*
- * General-Purpose I/O Pin Number
- */
-#define TB0287_PCI_SLOT_PIN		2
-#define TB0287_SM501_PIN		3
-#define TB0287_SIL680A_PIN		8
-#define TB0287_RTL8110_PIN		13
-
-/*
- * Interrupt Number
- */
-#define TB0287_PCI_SLOT_IRQ		GIU_IRQ(TB0287_PCI_SLOT_PIN)
-#define TB0287_SM501_IRQ		GIU_IRQ(TB0287_SM501_PIN)
-#define TB0287_SIL680A_IRQ		GIU_IRQ(TB0287_SIL680A_PIN)
-#define TB0287_RTL8110_IRQ		GIU_IRQ(TB0287_RTL8110_PIN)
-
-#endif /* __TANBAC_TB0287_H */
diff -Naur linux-2.6.14/include/asm-mips/vr41xx/vr41xx.h linux-mips-2.6.14.orig/include/asm-mips/vr41xx/vr41xx.h
--- linux-2.6.14/include/asm-mips/vr41xx/vr41xx.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/vr41xx/vr41xx.h	2005-11-17 11:44:27.000000000 -0800
@@ -7,7 +7,7 @@
  * Copyright (C) 2001, 2002 Paul Mundt
  * Copyright (C) 2002 MontaVista Software, Inc.
  * Copyright (C) 2002 TimeSys Corp.
- * Copyright (C) 2003-2005 Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ * Copyright (C) 2003-2004 Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
diff -Naur linux-2.6.14/include/asm-mips/war.h linux-mips-2.6.14.orig/include/asm-mips/war.h
--- linux-2.6.14/include/asm-mips/war.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/asm-mips/war.h	2005-11-17 11:44:27.000000000 -0800
@@ -177,6 +177,17 @@
 #endif
 
 /*
+ * The RM9000 has a bug (though PMC-Sierra opposes it being called that)
+ * where invalid instructions in the same I-cache line worth of instructions
+ * being fetched may case spurious exceptions.
+ */
+#if defined(CONFIG_MOMENCO_JAGUAR_ATX) || defined(CONFIG_MOMENCO_OCELOT_3) || \
+    defined(CONFIG_PMC_YOSEMITE)
+#define ICACHE_REFILLS_WORKAROUND_WAR	1
+#endif
+
+
+/*
  * ON the R10000 upto version 2.6 (not sure about 2.7) there is a bug that
  * may cause ll / sc and lld / scd sequences to execute non-atomically.
  */
@@ -187,6 +198,9 @@
 /*
  * Workarounds default to off
  */
+#ifndef ICACHE_REFILLS_WORKAROUND_WAR
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#endif
 #ifndef R4600_V1_INDEX_ICACHEOP_WAR
 #define R4600_V1_INDEX_ICACHEOP_WAR	0
 #endif
diff -Naur linux-2.6.14/include/linux/ds17287rtc.h linux-mips-2.6.14.orig/include/linux/ds17287rtc.h
--- linux-2.6.14/include/linux/ds17287rtc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/linux/ds17287rtc.h	2005-11-17 11:44:37.000000000 -0800
@@ -0,0 +1,68 @@
+/* 
+ * ds17287rtc.h - register definitions for the ds1728[57] RTC / CMOS RAM
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ * 
+ * (C) 2003 Guido Guenther <agx@sigxcpu.org>
+ *
+ */
+
+#ifndef _DS17287RTC_H
+#define _DS17287RTC_H
+
+#include <asm/io.h>
+#include <linux/rtc.h>			/* get the user-level API */
+#include <linux/spinlock.h>		/* spinlock_t */
+#include <linux/mc146818rtc.h>
+
+/* Register A */
+#define DS_REGA_DV2 0x40		/* countdown chain */
+#define DS_REGA_DV1 0x20		/* oscillator enable */
+#define DS_REGA_DV0 0x10		/* bank select */
+
+/* bank 1 registers */
+#define DS_B1_MODEL	 0x40		/* model number byte */
+#define DS_B1_SN1 	 0x41		/* serial number byte 1 */
+#define DS_B1_SN2 	 0x42		/* serial number byte 2 */
+#define DS_B1_SN3 	 0x43		/* serial number byte 3 */
+#define DS_B1_SN4 	 0x44		/* serial number byte 4 */
+#define DS_B1_SN5 	 0x45		/* serial number byte 5 */
+#define DS_B1_SN6 	 0x46		/* serial number byte 6 */
+#define DS_B1_CRC 	 0x47		/* CRC byte */
+#define DS_B1_CENTURY 	 0x48		/* Century byte */
+#define DS_B1_DALARM 	 0x49		/* date alarm */
+#define DS_B1_XCTRL4A	 0x4a		/* extendec control register 4a */
+#define DS_B1_XCTRL4B	 0x4b		/* extendec control register 4b */
+#define DS_B1_RTCADDR2 	 0x4e		/* rtc address 2 */
+#define DS_B1_RTCADDR3 	 0x4f		/* rtc address 3 */
+#define DS_B1_RAMLSB	 0x50		/* extended ram LSB */
+#define DS_B1_RAMMSB	 0x51		/* extended ram MSB */
+#define DS_B1_RAMDPORT	 0x53		/* extended ram data port */
+
+/* register details */
+/* extended control register 4a */
+#define DS_XCTRL4A_VRT2  0x80 		/* valid ram and time */
+#define DS_XCTRL4A_INCR  0x40		/* increment progress status */
+#define DS_XCTRL4A_BME   0x20		/* burst mode enable */
+#define DS_XCTRL4A_PAB   0x08		/* power active bar ctrl */
+#define DS_XCTRL4A_RF    0x04		/* ram clear flag */
+#define DS_XCTRL4A_WF    0x02		/* wake up alarm flag */
+#define DS_XCTRL4A_KF    0x01		/* kickstart flag */
+/* interrupt causes */
+#define DS_XCTRL4A_IFS	(DS_XCTRL4A_RF|DS_XCTRL4A_WF|DS_XCTRL4A_KF)
+
+/* extended control register 4b */
+#define DS_XCTRL4B_ABE   0x80 		/* auxiliary battery enable */
+#define DS_XCTRL4B_E32K	 0x40		/* enable 32.768 kHz Output */
+#define DS_XCTRL4B_CS    0x20		/* crystal select */
+#define DS_XCTRL4B_RCE   0x10		/* ram clear enable */
+#define DS_XCTRL4B_PRS   0x08		/* PAB resec select */
+#define DS_XCTRL4B_RIE   0x04		/* ram clear interrupt enable */
+#define DS_XCTRL4B_WFE   0x02		/* wake up alarm interrupt enable */
+#define DS_XCTRL4B_KFE   0x01		/* kickstart interrupt enable */
+/* interrupt enable bits */
+#define DS_XCTRL4B_IFES	(DS_XCTRL4B_RIE|DS_XCTRL4B_WFE|DS_XCTRL4B_KFE)
+
+#endif /* _DS17287RTC_H */
diff -Naur linux-2.6.14/include/linux/ds1742rtc.h linux-mips-2.6.14.orig/include/linux/ds1742rtc.h
--- linux-2.6.14/include/linux/ds1742rtc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/linux/ds1742rtc.h	2005-11-17 11:44:37.000000000 -0800
@@ -0,0 +1,53 @@
+/*
+ * ds1742rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * Permission is hereby granted to copy, modify and redistribute this code
+ * in terms of the GNU Library General Public License, Version 2 or later,
+ * at your option.
+ */
+#ifndef __LINUX_DS1742RTC_H
+#define __LINUX_DS1742RTC_H
+
+#include <asm/ds1742.h>
+
+#define RTC_BRAM_SIZE		0x800
+#define RTC_OFFSET		0x7f8
+
+/*
+ * Register summary
+ */
+#define RTC_CONTROL		(RTC_OFFSET + 0)
+#define RTC_CENTURY		(RTC_OFFSET + 0)
+#define RTC_SECONDS		(RTC_OFFSET + 1)
+#define RTC_MINUTES		(RTC_OFFSET + 2)
+#define RTC_HOURS		(RTC_OFFSET + 3)
+#define RTC_DAY			(RTC_OFFSET + 4)
+#define RTC_DATE		(RTC_OFFSET + 5)
+#define RTC_MONTH		(RTC_OFFSET + 6)
+#define RTC_YEAR		(RTC_OFFSET + 7)
+
+#define RTC_CENTURY_MASK	0x3f
+#define RTC_SECONDS_MASK	0x7f
+#define RTC_DAY_MASK		0x07
+
+/*
+ * Bits in the Control/Century register
+ */
+#define RTC_WRITE		0x80
+#define RTC_READ		0x40
+
+/*
+ * Bits in the Seconds register
+ */
+#define RTC_STOP		0x80
+
+/*
+ * Bits in the Day register
+ */
+#define RTC_BATT_FLAG		0x80
+#define RTC_FREQ_TEST		0x40
+
+#endif /* __LINUX_DS1742RTC_H */
diff -Naur linux-2.6.14/include/linux/elf.h linux-mips-2.6.14.orig/include/linux/elf.h
--- linux-2.6.14/include/linux/elf.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/linux/elf.h	2005-11-17 11:44:37.000000000 -0800
@@ -67,7 +67,7 @@
 
 #define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
 
-#define EM_MIPS_RS4_BE 10	/* MIPS R4000 big-endian */
+#define EM_MIPS_RS3_LE 10	/* MIPS R3000 little-endian */
 
 #define EM_PARISC      15	/* HPPA */
 
diff -Naur linux-2.6.14/include/linux/ide.h linux-mips-2.6.14.orig/include/linux/ide.h
--- linux-2.6.14/include/linux/ide.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/linux/ide.h	2005-11-17 11:44:41.000000000 -0800
@@ -218,7 +218,7 @@
 		ide_rz1000,	ide_trm290,
 		ide_cmd646,	ide_cy82c693,	ide_4drives,
 		ide_pmac,	ide_etrax100,	ide_acorn,
-		ide_forced
+		ide_au1xxx, ide_forced
 } hwif_chipset_t;
 
 /*
diff -Naur linux-2.6.14/include/linux/mc146818rtc.h linux-mips-2.6.14.orig/include/linux/mc146818rtc.h
--- linux-2.6.14/include/linux/mc146818rtc.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/linux/mc146818rtc.h	2005-11-17 11:44:42.000000000 -0800
@@ -89,4 +89,12 @@
 # define RTC_VRT 0x80		/* valid RAM and time */
 /**********************************************************************/
 
+#ifndef RTC_IO_EXTENT
+#define RTC_IO_EXTENT	0x8
+#endif
+
+#ifndef RTC_IOMAPPED
+#define RTC_IOMAPPED	1	/* Default to I/O mapping. */
+#endif
+
 #endif /* _MC146818RTC_H */
diff -Naur linux-2.6.14/include/linux/pci_ids.h linux-mips-2.6.14.orig/include/linux/pci_ids.h
--- linux-2.6.14/include/linux/pci_ids.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/linux/pci_ids.h	2005-11-17 11:44:42.000000000 -0800
@@ -1649,8 +1649,8 @@
 #define PCI_VENDOR_ID_TOSHIBA_2		0x102f
 #define PCI_DEVICE_ID_TOSHIBA_TX3927	0x000a
 #define PCI_DEVICE_ID_TOSHIBA_TC35815CF	0x0030
-#define PCI_DEVICE_ID_TOSHIBA_TX4927	0x0180
 #define PCI_DEVICE_ID_TOSHIBA_TC86C001_MISC	0x0108
+#define PCI_DEVICE_ID_TOSHIBA_TX4927	0x0180
 #define PCI_DEVICE_ID_TOSHIBA_SPIDER_NET 0x01b3
 
 #define PCI_VENDOR_ID_RICOH		0x1180
@@ -2210,6 +2210,9 @@
 #define PCI_VENDOR_ID_MIPS		0x153f
 #define PCI_DEVICE_ID_SOC_IT		0x0001
 
+#define PCI_VENDOR_ID_MIPS		0x153f
+#define PCI_DEVICE_ID_SOC_IT		0x0001
+
 #define PCI_VENDOR_ID_SYBA		0x1592
 #define PCI_DEVICE_ID_SYBA_2P_EPP	0x0782
 #define PCI_DEVICE_ID_SYBA_1P_ECP	0x0783
diff -Naur linux-2.6.14/include/linux/serial_core.h linux-mips-2.6.14.orig/include/linux/serial_core.h
--- linux-2.6.14/include/linux/serial_core.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/linux/serial_core.h	2005-11-17 11:44:43.000000000 -0800
@@ -39,7 +39,8 @@
 #define PORT_RSA	13
 #define PORT_NS16550A	14
 #define PORT_XSCALE	15
-#define PORT_MAX_8250	15	/* max port ID */
+#define PORT_IP3106	16
+#define PORT_MAX_8250	16	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
diff -Naur linux-2.6.14/include/linux/serial.h linux-mips-2.6.14.orig/include/linux/serial.h
--- linux-2.6.14/include/linux/serial.h	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/include/linux/serial.h	2005-11-17 11:44:43.000000000 -0800
@@ -75,7 +75,8 @@
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
diff -Naur linux-2.6.14/include/linux/serial_ip3106.h linux-mips-2.6.14.orig/include/linux/serial_ip3106.h
--- linux-2.6.14/include/linux/serial_ip3106.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/include/linux/serial_ip3106.h	2005-11-17 11:44:43.000000000 -0800
@@ -0,0 +1,93 @@
+/*
+ * Embedded Alley Solutions, source@embeddedalley.com.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_SERIAL_IP3106_H
+#define _LINUX_SERIAL_IP3106_H
+
+#include <linux/serial_core.h>
+#include <linux/device.h>
+
+#define IP3106_NR_PORTS		2
+
+struct ip3106_port {
+	struct uart_port	port;
+	struct timer_list	timer;
+	unsigned int		old_status;
+};
+
+/* register offsets */
+#define IP3106_LCR		0
+#define IP3106_MCR		0x004
+#define IP3106_BAUD		0x008
+#define IP3106_CFG		0x00c
+#define IP3106_FIFO		0x028
+#define IP3106_ISTAT		0xfe0
+#define IP3106_IEN		0xfe4
+#define IP3106_ICLR		0xfe8
+#define IP3106_ISET		0xfec
+#define IP3106_PD		0xff4
+#define IP3106_MID		0xffc
+
+#define IP3106_UART_LCR_TXBREAK		(1<<30)
+#define IP3106_UART_LCR_PAREVN		0x10000000
+#define IP3106_UART_LCR_PAREN		0x08000000
+#define IP3106_UART_LCR_2STOPB		0x04000000
+#define IP3106_UART_LCR_8BIT		0x01000000
+#define IP3106_UART_LCR_TX_RST		0x00040000
+#define IP3106_UART_LCR_RX_RST		0x00020000
+#define IP3106_UART_LCR_RX_NEXT		0x00010000
+
+#define IP3106_UART_MCR_SCR		0xFF000000
+#define IP3106_UART_MCR_DCD		0x00800000
+#define IP3106_UART_MCR_CTS		0x00100000
+#define IP3106_UART_MCR_LOOP		0x00000010
+#define IP3106_UART_MCR_RTS		0x00000002
+#define IP3106_UART_MCR_DTR		0x00000001
+
+#define IP3106_UART_INT_TX		0x00000080
+#define IP3106_UART_INT_EMPTY		0x00000040
+#define IP3106_UART_INT_RCVTO		0x00000020
+#define IP3106_UART_INT_RX		0x00000010
+#define IP3106_UART_INT_RXOVRN		0x00000008
+#define IP3106_UART_INT_FRERR		0x00000004
+#define IP3106_UART_INT_BREAK		0x00000002
+#define IP3106_UART_INT_PARITY		0x00000001
+#define IP3106_UART_INT_ALLRX		0x0000003F
+#define IP3106_UART_INT_ALLTX		0x000000C0
+
+#define IP3106_UART_FIFO_TXFIFO		0x001F0000
+#define IP3106_UART_FIFO_TXFIFO_STA	(0x1f<<16)
+#define IP3106_UART_FIFO_RXBRK		0x00008000
+#define IP3106_UART_FIFO_RXFE		0x00004000
+#define IP3106_UART_FIFO_RXPAR		0x00002000
+#define IP3106_UART_FIFO_RXFIFO		0x00001F00
+#define IP3106_UART_FIFO_RBRTHR		0x000000FF
+
+#define ip3106_lcr(base,port)    *(volatile u32 *)(base+(port*0x1000) + 0x000)
+#define ip3106_mcr(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0x004)
+#define ip3106_baud(base, port)  *(volatile u32 *)(base+(port*0x1000) + 0x008)
+#define ip3106_cfg(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0x00C)
+#define ip3106_fifo(base, port)	 *(volatile u32 *)(base+(port*0x1000) + 0x028)
+#define ip3106_istat(base, port) *(volatile u32 *)(base+(port*0x1000) + 0xFE0)
+#define ip3106_ien(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0xFE4)
+#define ip3106_iclr(base, port)  *(volatile u32 *)(base+(port*0x1000) + 0xFE8)
+#define ip3106_iset(base, port)  *(volatile u32 *)(base+(port*0x1000) + 0xFEC)
+#define ip3106_pd(base, port)    *(volatile u32 *)(base+(port*0x1000) + 0xFF4)
+#define ip3106_mid(base, port)   *(volatile u32 *)(base+(port*0x1000) + 0xFFC)
+
+#endif
diff -Naur linux-2.6.14/MAINTAINERS linux-mips-2.6.14.orig/MAINTAINERS
--- linux-2.6.14/MAINTAINERS	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/MAINTAINERS	2005-11-17 11:42:04.000000000 -0800
@@ -1640,7 +1640,7 @@
 MIPS
 P:	Ralf Baechle
 M:	ralf@linux-mips.org
-W:	http://oss.sgi.com/mips/mips-howto.html
+W:	http://www.linux-mips.org/
 L:	linux-mips@linux-mips.org
 S:	Maintained
 
diff -Naur linux-2.6.14/Makefile linux-mips-2.6.14.orig/Makefile
--- linux-2.6.14/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/Makefile	2005-11-17 11:42:04.000000000 -0800
@@ -166,9 +166,7 @@
 # then ARCH is assigned, getting whatever value it gets normally, and 
 # SUBARCH is subsequently ignored.
 
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ )
+SUBARCH := mips
 
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
@@ -534,7 +532,7 @@
 CHECKFLAGS     += $(NOSTDINC_FLAGS)
 
 # warn about C99 declaration after statement
-CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
+#CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
 
 # disable pointer signedness warnings in gcc 4.0
 CFLAGS += $(call cc-option,-Wno-pointer-sign,)
diff -Naur linux-2.6.14/sound/oss/au1550_ac97.c linux-mips-2.6.14.orig/sound/oss/au1550_ac97.c
--- linux-2.6.14/sound/oss/au1550_ac97.c	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/sound/oss/au1550_ac97.c	2005-11-17 11:45:06.000000000 -0800
@@ -35,7 +35,6 @@
 
 #undef DEBUG
 
-#include <linux/version.h>
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/ioport.h>
@@ -59,6 +58,7 @@
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-au1x00/au1xxx_psc.h>
 #include <asm/mach-au1x00/au1xxx_dbdma.h>
+#include <asm/mach-pb1x00/pb1550.h>
 
 #undef OSS_DOCUMENTED_MIXER_SEMANTICS
 
diff -Naur linux-2.6.14/sound/oss/au1550_i2s.c linux-mips-2.6.14.orig/sound/oss/au1550_i2s.c
--- linux-2.6.14/sound/oss/au1550_i2s.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-mips-2.6.14.orig/sound/oss/au1550_i2s.c	2005-11-17 11:45:06.000000000 -0800
@@ -0,0 +1,2029 @@
+/*
+ *      au1550_i2s.c  --  Sound driver for Alchemy Au1550 MIPS
+ *			Internet Edge Processor.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ * Copyright 2005 Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Mostly copied from the au1550_psc.c driver and some from the
+ * PowerMac dbdma driver.
+ * We assume the processor can do memory coherent DMA.
+ *
+ * WM8731 mixer support, codec framework, cleanup, and 2.6 port
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * The SMBus (I2C) is required for the control of the 
+ * appears at I2C address 0x36 (I2C binary 0011011).  The Pb1550
+ * uses the Wolfson WM8731 codec, which is controlled over the I2C.
+ * It's connected to a 12MHz clock, so we can only reliably support
+ * 96KHz, 48KHz, 32KHz, and 8KHz data rates.  Variable rate audio is
+ * unsupported, we currently force it to 48KHz.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/hardirq.h>
+#include <linux/sound.h>
+#include <linux/slab.h>
+#include <linux/soundcard.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_psc.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+#include <asm/mach-pb1x00/pb1550.h>
+
+#undef OSS_DOCUMENTED_MIXER_SEMANTICS
+
+#define AU1550_MODULE_NAME "Au1550 I2S Audio"
+#define PFX AU1550_MODULE_NAME
+
+/* Define this if you want to try running at the 44.1 KHz rate.
+ * It's just a little off, I think it's actually 44117 or something.
+ * I did this for debugging, since many programs, including this
+ * driver, will try to upsample from 44.1 to 48 KHz.
+ * Seems to work well, we'll just leave it this way.
+ */
+#define TRY_441KHz
+
+#ifdef TRY_441KHz
+#define SAMP_RATE	44100
+#else
+#define SAMP_RATE	48000
+#endif
+
+/* The number of DBDMA ring descriptors to allocate.  No sense making
+ * this too large....if you can't keep up with a few you aren't likely
+ * to be able to with lots of them, either.
+ */
+#define NUM_DBDMA_DESCRIPTORS 4
+
+#define pr_error(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+
+static void
+au1550_delay(int msec)
+{
+	unsigned long   tmo;
+	signed long     tmo2;
+
+	if (in_interrupt())
+		return;
+
+	tmo = jiffies + (msec * HZ) / 1000;
+	for (;;) {
+		tmo2 = tmo - jiffies;
+		if (tmo2 <= 0)
+			break;
+		schedule_timeout(tmo2);
+	}
+}
+
+/*
+ * Codec framework. If somebody supports another codec, they
+ * should hopefully be able to define another struct i2s_codec
+ * definition, and #ifdef the support for it and the WM8731 so
+ * they can be selected via a CONFIG option. For now, we just
+ * hardcode WM8731_CODEC.
+ */
+#define i2s_supported_mixer(CODEC,FOO) ((FOO >= 0) && \
+                                    (FOO < SOUND_MIXER_NRDEVICES) && \
+                                    (CODEC)->supported_mixers & (1<<FOO) )
+
+struct i2s_codec {
+	int			modcnt;
+	int			supported_mixers;
+	int			stereo_mixers;
+	int			record_sources;
+	unsigned int		mixer_state[SOUND_MIXER_NRDEVICES];
+	void			*data;
+	int			(*set_mixer) (struct i2s_codec *codec, unsigned int oss_mixer, unsigned int val);
+	void			(*init_codec) (struct i2s_codec *codec);
+};
+
+#define WM8731_CODEC
+#ifdef WM8731_CODEC
+/*
+ * WM8731 codec support
+ */
+#define WM8731_SUPPORTED_MASK (WM8731_STEREO_MASK|WM8731_RECORD_MASK)
+#define WM8731_STEREO_MASK (SOUND_MASK_VOLUME|SOUND_MASK_LINE)
+#define WM8731_RECORD_MASK (SOUND_MASK_MIC|SOUND_MASK_LINE)
+
+static struct codec_data {
+	u16			audio_path;
+} wm8731_data;
+
+static void
+wm8731_wrcodec(u8 ctlreg, u8 val)
+{
+	int	rcnt;
+	extern int pb1550_wm_codec_write(u8 addr, u8 reg, u8 val);
+
+	/* The codec is a write only device, with a 16-bit control/data
+	 * word.  Although it is written as two bytes on the I2C, the
+	 * format is actually 7 bits of register and 9 bits of data.
+	 * The ls bit of the first byte is the ms bit of the data.
+	 */
+	rcnt = 0;
+	while ((pb1550_wm_codec_write((0x36 >> 1), ctlreg, val) != 1) 
+							&& (rcnt < 50)) {
+		rcnt++;
+	}
+}
+
+static int
+wm8731_set_mixer(struct i2s_codec *codec, unsigned int oss_mixer, unsigned int val)
+{
+	unsigned int lvol, rvol;
+	struct codec_data *cdata = (struct codec_data *)codec->data;
+
+	switch (oss_mixer) {
+		case SOUND_MIXER_VOLUME:
+			/* normalize OSS range to fit codec volume control */
+			lvol = ((((val & 0x7f00) >> 8) * 0x60) / 0x64) + 0x1f;
+			rvol = (((val & 0x7f) * 0x60) / 0x64) + 0x1f;
+			lvol |= 0x80;
+			rvol |= 0x80;
+			wm8731_wrcodec(0x04, lvol);
+			au1550_delay(10);
+			wm8731_wrcodec(0x06, rvol);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		case SOUND_MIXER_LINE:
+			/* normalize OSS range to fit codec line control */
+			lvol = ((((val & 0x7f00) >> 8) * 0x1f) / 0x64);
+			rvol = (((val & 0x7f) * 0x1f) / 0x64);
+			if (!(val & 0x1f00))
+				lvol |= 0x80;
+			else
+				lvol &= ~0x80;
+			if (!(val & 0x001f))
+				rvol |= 0x80;
+			else
+				rvol &= ~0x80;
+			wm8731_wrcodec(0x00, lvol);
+			au1550_delay(10);
+			wm8731_wrcodec(0x02, rvol);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		case SOUND_MIXER_MIC:
+			if (!val)
+				cdata->audio_path |= 0x02;
+			else {
+				if (val >= 0x32)
+					cdata->audio_path |= 0x01;
+				else
+					cdata->audio_path &= ~0x01;
+				cdata->audio_path &= ~0x02;
+			}
+			wm8731_wrcodec(0x08, cdata->audio_path);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		case SOUND_MIXER_RECSRC:
+			if (val & SOUND_MASK_LINE)
+				cdata->audio_path &= ~0x04;
+			else
+				cdata->audio_path |= 0x04;
+			wm8731_wrcodec(0x08, cdata->audio_path);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+void
+wm8731_init_codec(struct i2s_codec *codec)
+{
+	struct codec_data *cdata = (struct codec_data *)codec->data;
+
+	wm8731_wrcodec(0x1e, 0x00);	/* Reset */
+	au1550_delay(200);
+	wm8731_wrcodec(0x0c, 0x00);	/* Power up everything */
+	au1550_delay(10);
+	wm8731_wrcodec(0x12, 0x00);	/* Deactivate codec */
+	au1550_delay(10);
+	cdata->audio_path = 0x10;
+	/* Select DAC outputs to line out */
+	wm8731_wrcodec(0x08, cdata->audio_path);
+	au1550_delay(10);
+	wm8731_wrcodec(0x0a, 0x00);	/* Disable output mute */
+	au1550_delay(10);
+	wm8731_wrcodec(0x0e, 0x02);	/* Set slave, 16-bit, I2S modes */
+	au1550_delay(10);
+	wm8731_wrcodec(0x10, 0x01);	/* 12MHz (USB), 250fs */
+	au1550_delay(10);
+	wm8731_wrcodec(0x12, 0x01);	/* Activate codec */
+	au1550_delay(10);
+
+	codec->set_mixer(codec, SOUND_MIXER_VOLUME, 0x5050);
+	codec->set_mixer(codec, SOUND_MIXER_LINE, 0x0000);
+	codec->set_mixer(codec, SOUND_MIXER_MIC, 0x00);
+	codec->mixer_state[SOUND_MIXER_RECSRC] = SOUND_MIXER_LINE;
+}
+
+static struct i2s_codec au1550_i2s_codec = {
+	.supported_mixers	= WM8731_SUPPORTED_MASK,
+	.stereo_mixers		= WM8731_STEREO_MASK,
+	.record_sources		= WM8731_RECORD_MASK,
+	.init_codec		= &wm8731_init_codec,
+	.set_mixer		= &wm8731_set_mixer,
+	.data			= &wm8731_data,
+};
+#endif /* WM8731_CODEC */
+
+static struct au1550_state {
+	/* soundcore stuff */
+	int             dev_audio;
+	int		dev_mixer;
+
+	spinlock_t		lock;
+	struct semaphore	open_sem;
+	struct semaphore	sem;
+	mode_t			open_mode;
+	wait_queue_head_t	open_wait;
+	volatile psc_i2s_t	*psc_addr;
+	struct i2s_codec	*codec;
+
+	struct dmabuf {
+		u32		dmanr;
+		unsigned        sample_rate;
+		unsigned	src_factor;
+		unsigned        sample_size;
+		int             num_channels;
+		int		dma_bytes_per_sample;
+		int		user_bytes_per_sample;
+		int		cnt_factor;
+
+		void		*rawbuf;
+		unsigned        buforder;
+		unsigned	numfrag;
+		unsigned        fragshift;
+		void		*nextIn;
+		void		*nextOut;
+		int		count;
+		unsigned        total_bytes;
+		unsigned        error;
+		wait_queue_head_t wait;
+
+		/* redundant, but makes calculations easier */
+		unsigned	fragsize;
+		unsigned	dma_fragsize;
+		unsigned	dmasize;
+		unsigned	dma_qcount;
+
+		/* OSS stuff */
+		unsigned        mapped:1;
+		unsigned        ready:1;
+		unsigned        stopped:1;
+		unsigned        ossfragshift;
+		int             ossmaxfrags;
+		unsigned        subdivision;
+
+		/* Mixer stuff */
+		int		dev_mixer;
+	} dma_dac, dma_adc;
+} au1550_state;
+
+static unsigned
+ld2(unsigned int x)
+{
+	unsigned        r = 0;
+
+	if (x >= 0x10000) {
+		x >>= 16;
+		r += 16;
+	}
+	if (x >= 0x100) {
+		x >>= 8;
+		r += 8;
+	}
+	if (x >= 0x10) {
+		x >>= 4;
+		r += 4;
+	}
+	if (x >= 4) {
+		x >>= 2;
+		r += 2;
+	}
+	if (x >= 2)
+		r++;
+	return r;
+}
+
+/* stop the ADC before calling */
+static void
+set_adc_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *adc = &s->dma_adc;
+
+	/* calc SRC factor */
+	adc->src_factor = (((SAMP_RATE*2) / rate) + 1) >> 1;
+	adc->sample_rate = SAMP_RATE / adc->src_factor;
+	return;
+
+	adc->src_factor = 1;
+}
+
+/* stop the DAC before calling */
+static void
+set_dac_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *dac = &s->dma_dac;
+
+	/* calc SRC factor */
+	dac->src_factor = (((SAMP_RATE*2) / rate) + 1) >> 1;
+	dac->sample_rate = SAMP_RATE / dac->src_factor;
+	return;
+
+	dac->src_factor = 1;
+}
+
+static void
+stop_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	unsigned long   flags;
+	uint	stat;
+	volatile psc_i2s_t *ip;
+
+	if (db->stopped)
+		return;
+
+	ip = s->psc_addr;
+	spin_lock_irqsave(&s->lock, flags);
+
+	ip->psc_i2spcr = PSC_I2SPCR_TP;
+	au_sync();
+
+	/* Wait for Transmit Busy to show disabled.
+	*/
+	do {
+		stat = ip->psc_i2sstat;
+		au_sync();
+	} while ((stat & PSC_I2SSTAT_TB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+stop_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	unsigned long   flags;
+	uint	stat;
+	volatile psc_i2s_t *ip;
+
+	if (db->stopped)
+		return;
+
+	ip = s->psc_addr;
+	spin_lock_irqsave(&s->lock, flags);
+
+	ip->psc_i2spcr = PSC_I2SPCR_RP;
+	au_sync();
+
+	/* Wait for Receive Busy to show disabled.
+	*/
+	do {
+		stat = ip->psc_i2sstat;
+		au_sync();
+	} while ((stat & PSC_I2SSTAT_RB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+set_xmit_slots(int num_channels)
+{
+	/* This is here just as a place holder.  The WM8731 only
+	 * supports two fixed channels.
+	 */
+}
+
+static void
+set_recv_slots(int num_channels)
+{
+	/* This is here just as a place holder.  The WM8731 only
+	 * supports two fixed channels.
+	 */
+}
+
+static void
+start_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	unsigned long   flags;
+	volatile psc_i2s_t *ip;
+
+	if (!db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	ip = s->psc_addr;
+	set_xmit_slots(db->num_channels);
+	ip->psc_i2spcr = PSC_I2SPCR_TC;
+	au_sync();
+	ip->psc_i2spcr = PSC_I2SPCR_TS;
+	au_sync();
+
+	au1xxx_dbdma_start(db->dmanr);
+
+	db->stopped = 0;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+start_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	int	i;
+	volatile psc_i2s_t *ip;
+
+	if (!db->stopped)
+		return;
+
+	/* Put two buffers on the ring to get things started.
+	*/
+	for (i=0; i<2; i++) {
+		au1xxx_dbdma_put_dest(db->dmanr, db->nextIn, db->dma_fragsize);
+
+		db->nextIn += db->dma_fragsize;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+	}
+
+	ip = s->psc_addr;
+	set_recv_slots(db->num_channels);
+	au1xxx_dbdma_start(db->dmanr);
+	ip->psc_i2spcr = PSC_I2SPCR_RC;
+	au_sync();
+	ip->psc_i2spcr = PSC_I2SPCR_RS;
+	au_sync();
+
+	db->stopped = 0;
+}
+
+static int
+prog_dmabuf(struct au1550_state *s, struct dmabuf *db)
+{
+	unsigned user_bytes_per_sec;
+	unsigned        bufs;
+	unsigned        rate = db->sample_rate;
+
+	if (!db->rawbuf) {
+		db->ready = db->mapped = 0;
+		db->buforder = 5;	/* 32 * PAGE_SIZE */
+		db->rawbuf = kmalloc((PAGE_SIZE << db->buforder), GFP_KERNEL);
+		if (!db->rawbuf)
+			return -ENOMEM;
+	}
+
+	db->cnt_factor = 1;
+	if (db->sample_size == 8)
+		db->cnt_factor *= 2;
+	if (db->num_channels == 1)
+		db->cnt_factor *= 2;
+	db->cnt_factor *= db->src_factor;
+
+	db->count = 0;
+	db->dma_qcount = 0;
+	db->nextIn = db->nextOut = db->rawbuf;
+
+	db->user_bytes_per_sample = (db->sample_size>>3) * db->num_channels;
+	db->dma_bytes_per_sample = 2 * ((db->num_channels == 1) ?
+					2 : db->num_channels);
+
+	user_bytes_per_sec = rate * db->user_bytes_per_sample;
+	bufs = PAGE_SIZE << db->buforder;
+	if (db->ossfragshift) {
+		if ((1000 << db->ossfragshift) < user_bytes_per_sec)
+			db->fragshift = ld2(user_bytes_per_sec/1000);
+		else
+			db->fragshift = db->ossfragshift;
+	} else {
+		db->fragshift = ld2(user_bytes_per_sec / 100 /
+				    (db->subdivision ? db->subdivision : 1));
+		if (db->fragshift < 3)
+			db->fragshift = 3;
+	}
+
+	db->fragsize = 1 << db->fragshift;
+	db->dma_fragsize = db->fragsize * db->cnt_factor;
+	db->numfrag = bufs / db->dma_fragsize;
+
+	while (db->numfrag < 4 && db->fragshift > 3) {
+		db->fragshift--;
+		db->fragsize = 1 << db->fragshift;
+		db->dma_fragsize = db->fragsize * db->cnt_factor;
+		db->numfrag = bufs / db->dma_fragsize;
+	}
+
+	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
+		db->numfrag = db->ossmaxfrags;
+
+	db->dmasize = db->dma_fragsize * db->numfrag;
+	memset(db->rawbuf, 0, bufs);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg("rate=%d, samplesize=%d, channels=%d",
+	    rate, db->sample_size, db->num_channels);
+	dbg("fragsize=%d, cnt_factor=%d, dma_fragsize=%d",
+	    db->fragsize, db->cnt_factor, db->dma_fragsize);
+	dbg("numfrag=%d, dmasize=%d", db->numfrag, db->dmasize);
+#endif
+
+	db->ready = 1;
+	return 0;
+}
+
+static int
+prog_dmabuf_adc(struct au1550_state *s)
+{
+	stop_adc(s);
+	return prog_dmabuf(s, &s->dma_adc);
+
+}
+
+static int
+prog_dmabuf_dac(struct au1550_state *s)
+{
+	stop_dac(s);
+	return prog_dmabuf(s, &s->dma_dac);
+}
+
+
+/* hold spinlock for the following */
+static void
+dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct au1550_state *s = (struct au1550_state *) dev_id;
+	struct dmabuf  *db = &s->dma_dac;
+	u32	i2s_stat;
+	volatile psc_i2s_t *ip;
+
+	ip = s->psc_addr;
+	i2s_stat = ip->psc_i2sstat;
+#ifdef AU1000_VERBOSE_DEBUG
+	if (i2s_stat & (PSC_I2SSTAT_TF | PSC_I2SSTAT_TR | PSC_I2SSTAT_TF))
+		dbg("I2S status = 0x%08x", i2s_stat);
+#endif
+	db->dma_qcount--;
+
+	if (db->count >= db->fragsize) {
+		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+			pr_error("qcount < 2 and no ring room!");
+		}
+		db->nextOut += db->fragsize;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		db->count -= db->fragsize;
+		db->total_bytes += db->dma_fragsize;
+		db->dma_qcount++;
+	}
+
+	/* wake up anybody listening */
+	if (waitqueue_active(&db->wait))
+		wake_up(&db->wait);
+}
+
+
+static void
+adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct	au1550_state *s = (struct au1550_state *)dev_id;
+	struct	dmabuf  *dp = &s->dma_adc;
+	u32	obytes;
+	char	*obuf;
+
+	/* Pull the buffer from the dma queue.
+	*/
+	au1xxx_dbdma_get_dest(dp->dmanr, (void *)(&obuf), &obytes);
+
+	if ((dp->count + obytes) > dp->dmasize) {
+		/* Overrun. Stop ADC and log the error
+		*/
+		stop_adc(s);
+		dp->error++;
+		pr_error("adc overrun");
+		return;
+	}
+
+	/* Put a new empty buffer on the destination DMA.
+	*/
+	au1xxx_dbdma_put_dest(dp->dmanr, dp->nextIn, dp->dma_fragsize);
+
+	dp->nextIn += dp->dma_fragsize;
+	if (dp->nextIn >= dp->rawbuf + dp->dmasize)
+		dp->nextIn -= dp->dmasize;
+
+	dp->count += obytes;
+	dp->total_bytes += obytes;
+
+	/* wake up anybody listening
+	*/
+	if (waitqueue_active(&dp->wait))
+		wake_up(&dp->wait);
+
+}
+
+static loff_t
+au1550_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+static int
+au1550_open_mixdev(struct inode *inode, struct file *file)
+{
+	file->private_data = &au1550_state;
+	return 0;
+}
+
+static int
+au1550_release_mixdev(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+#define I2S_CODEC	"Wolfson WM8731"
+
+static int
+au1550_ioctl_mixdev(struct inode *inode, struct file *file,
+			       unsigned int cmd, unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct i2s_codec *codec = s->codec;
+	int i, val = 0;
+
+	if (cmd == SOUND_MIXER_INFO) {
+		mixer_info info;
+		memset(&info, 0, sizeof(info));
+		strlcpy(info.id, I2S_CODEC, sizeof(info.id));
+		strlcpy(info.name, I2S_CODEC, sizeof(info.name));
+		info.modify_counter = codec->modcnt;
+		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	if (cmd == SOUND_OLD_MIXER_INFO) {
+		_old_mixer_info info;
+		memset(&info, 0, sizeof(info));
+		strlcpy(info.id, I2S_CODEC, sizeof(info.id));
+		strlcpy(info.name, I2S_CODEC, sizeof(info.name));
+		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
+		return -EINVAL;
+
+	if (cmd == OSS_GETVERSION)
+		return put_user(SOUND_VERSION, (int __user *)arg);
+
+	if (_SIOC_DIR(cmd) == _SIOC_READ) {
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* give them the current record source */
+			val = codec->mixer_state[SOUND_MIXER_RECSRC];
+			break;
+
+		case SOUND_MIXER_DEVMASK: /* give them the supported mixers */
+			val = codec->supported_mixers;
+			break;
+
+		case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
+			val = codec->record_sources;
+			break;
+
+		case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
+			val = codec->stereo_mixers;
+			break;
+
+		case SOUND_MIXER_CAPS:
+			val = SOUND_CAP_EXCL_INPUT;
+			break;
+
+		default: /* read a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!i2s_supported_mixer(codec, i)) 
+				return -EINVAL;
+
+			val = codec->mixer_state[i];
+ 			break;
+		}
+		return put_user(val, (int __user *)arg);
+	}
+
+	if (_SIOC_DIR(cmd) == (_SIOC_WRITE|_SIOC_READ)) {
+		codec->modcnt++;
+		if (get_user(val, (int __user *)arg))
+			return -EFAULT;
+
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
+			if (!val) return 0;
+			if (!(val &= codec->record_sources)) return -EINVAL;
+
+			codec->set_mixer(codec, SOUND_MIXER_RECSRC, val);
+
+			return 0;
+		default: /* write a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!i2s_supported_mixer(codec, i)) 
+				return -EINVAL;
+
+			codec->set_mixer(codec, i, val);
+
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static struct file_operations au1550_mixer_fops = {
+	owner:THIS_MODULE,
+	llseek:au1550_llseek,
+	ioctl:au1550_ioctl_mixdev,
+	open:au1550_open_mixdev,
+	release:au1550_release_mixdev,
+};
+
+static int
+drain_dac(struct au1550_state *s, int nonblock)
+{
+	unsigned long   flags;
+	int             count, tmo;
+
+	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
+		return 0;
+
+	for (;;) {
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count <= 0)
+			break;
+		if (signal_pending(current))
+			break;
+		if (nonblock)
+			return -EBUSY;
+		tmo = 1000 * count / SAMP_RATE;
+		tmo /= s->dma_dac.dma_bytes_per_sample;
+		au1550_delay(tmo);
+	}
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+	return 0;
+}
+
+static inline u8 S16_TO_U8(s16 ch)
+{
+	return (u8) (ch >> 8) + 0x80;
+}
+static inline s16 U8_TO_S16(u8 ch)
+{
+	return (s16) (ch - 0x80) << 8;
+}
+
+/*
+ * Translates user samples to dma buffer suitable for audio DAC data:
+ *     If mono, copy left channel to right channel in dma buffer.
+ *     If 8 bit samples, cvt to 16-bit before writing to dma buffer.
+ *     If interpolating (no VRA), duplicate every audio frame src_factor times.
+ */
+static int
+translate_from_user(struct dmabuf *db, char* dmabuf, char* userbuf,
+							       int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+	s16             ch, dmasample[6];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_from_user(dmabuf, userbuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		if (copy_from_user(usersample, userbuf,
+				   db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				ch = U8_TO_S16(usersample[i]);
+			else
+				ch = *((s16 *) (&usersample[i * 2]));
+			dmasample[i] = ch;
+			if (mono)
+				dmasample[i + 1] = ch;	/* right channel */
+		}
+
+		/* duplicate every audio frame src_factor times
+		*/
+		for (i = 0; i < db->src_factor; i++)
+			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Translates audio ADC samples to user buffer:
+ *     If mono, send only left channel to user buffer.
+ *     If 8 bit samples, cvt from 16 to 8 bit before writing to user buffer.
+ *     If decimating (no VRA), skip over src_factor audio frames.
+ */
+static int
+translate_to_user(struct dmabuf *db, char* userbuf, char* dmabuf,
+							     int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_to_user(userbuf, dmabuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				usersample[i] =
+					S16_TO_U8(*((s16 *) (&dmabuf[i * 2])));
+			else
+				*((s16 *) (&usersample[i * 2])) =
+					*((s16 *) (&dmabuf[i * 2]));
+		}
+
+		if (copy_to_user(userbuf, usersample,
+				 db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Copy audio data to/from user buffer from/to dma buffer, taking care
+ * that we wrap when reading/writing the dma buffer. Returns actual byte
+ * count written to or read from the dma buffer.
+ */
+static int
+copy_dmabuf_user(struct dmabuf *db, char* userbuf, int count, int to_user)
+{
+	char           *bufptr = to_user ? db->nextOut : db->nextIn;
+	char           *bufend = db->rawbuf + db->dmasize;
+	int             cnt, ret;
+
+	if (bufptr + count > bufend) {
+		int             partial = (int) (bufend - bufptr);
+		if (to_user) {
+			if ((cnt = translate_to_user(db, userbuf,
+						     bufptr, partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_to_user(db, userbuf + partial,
+						     db->rawbuf,
+						     count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		} else {
+			if ((cnt = translate_from_user(db, bufptr, userbuf,
+						       partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_from_user(db, db->rawbuf,
+						       userbuf + partial,
+						       count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		}
+	} else {
+		if (to_user)
+			ret = translate_to_user(db, userbuf, bufptr, count);
+		else
+			ret = translate_from_user(db, bufptr, userbuf, count);
+	}
+
+	return ret;
+}
+
+static ssize_t
+au1550_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_adc;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+	ret = 0;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for samples in ADC dma buffer
+		*/
+		do {
+			if (db->stopped)
+				start_adc(s);
+			spin_lock_irqsave(&s->lock, flags);
+			avail = db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from nextOut to user
+		*/
+		if ((cnt = copy_dmabuf_user(db, buffer,
+					    count > avail ?
+					    avail : count, 1)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count -= cnt;
+		db->nextOut += cnt;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+static ssize_t
+au1550_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_dac;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret = 0;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg("write: count=%d", count);
+#endif
+
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);	
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for space in playback buffer
+		*/
+		do {
+			spin_lock_irqsave(&s->lock, flags);
+			avail = (int) db->dmasize - db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from user to nextIn
+		*/
+		if ((cnt = copy_dmabuf_user(db, (char *) buffer,
+					    count > avail ?
+					    avail : count, 0)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count += cnt;
+		db->nextIn += cnt;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+
+		/* If the data is available, we want to keep two buffers
+		 * on the dma queue.  If the queue count reaches zero,
+		 * we know the dma has stopped.
+		 */
+		while ((db->dma_qcount < 2) && (db->count >= db->fragsize)) {
+			if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+				pr_error("qcount < 2 and no ring room!");
+			}
+			db->nextOut += db->fragsize;
+			if (db->nextOut >= db->rawbuf + db->dmasize)
+				db->nextOut -= db->dmasize;
+			db->count -= db->fragsize;
+			db->total_bytes += db->dma_fragsize;
+			if (db->dma_qcount == 0)
+				start_dac(s);
+			db->dma_qcount++;
+		}
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+
+/* No kernel lock - we have our own spinlock */
+static unsigned int
+au1550_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	unsigned int    mask = 0;
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!s->dma_dac.ready)
+			return 0;
+		poll_wait(file, &s->dma_dac.wait, wait);
+	}
+	if (file->f_mode & FMODE_READ) {
+		if (!s->dma_adc.ready)
+			return 0;
+		poll_wait(file, &s->dma_adc.wait, wait);
+	}
+
+	spin_lock_irqsave(&s->lock, flags);
+	
+	if (file->f_mode & FMODE_READ) {
+		if (s->dma_adc.count >= (signed)s->dma_adc.dma_fragsize)
+			mask |= POLLIN | POLLRDNORM;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if (s->dma_dac.mapped) {
+			if (s->dma_dac.count >=
+			    (signed)s->dma_dac.dma_fragsize) 
+				mask |= POLLOUT | POLLWRNORM;
+		} else {
+			if ((signed) s->dma_dac.dmasize >=
+			    s->dma_dac.count + (signed)s->dma_dac.dma_fragsize)
+				mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+	spin_unlock_irqrestore(&s->lock, flags);
+	return mask;
+}
+
+static int
+au1550_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db;
+	unsigned long   size;
+	int ret = 0;
+
+	lock_kernel();
+	down(&s->sem);
+	if (vma->vm_flags & VM_WRITE)
+		db = &s->dma_dac;
+	else if (vma->vm_flags & VM_READ)
+		db = &s->dma_adc;
+	else {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (vma->vm_pgoff != 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+	size = vma->vm_end - vma->vm_start;
+	if (size > (PAGE_SIZE << db->buforder)) {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (remap_pfn_range(vma, vma->vm_start,
+			     page_to_pfn(virt_to_page(db->rawbuf)),
+			     size, vma->vm_page_prot)) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	vma->vm_flags &= ~VM_IO;
+	db->mapped = 1;
+out:
+	up(&s->sem);
+	unlock_kernel();
+	return ret;
+}
+
+
+#ifdef AU1000_VERBOSE_DEBUG
+static struct ioctl_str_t {
+	unsigned int    cmd;
+	const char     *str;
+} ioctl_str[] = {
+	{SNDCTL_DSP_RESET, "SNDCTL_DSP_RESET"},
+	{SNDCTL_DSP_SYNC, "SNDCTL_DSP_SYNC"},
+	{SNDCTL_DSP_SPEED, "SNDCTL_DSP_SPEED"},
+	{SNDCTL_DSP_STEREO, "SNDCTL_DSP_STEREO"},
+	{SNDCTL_DSP_GETBLKSIZE, "SNDCTL_DSP_GETBLKSIZE"},
+	{SNDCTL_DSP_SAMPLESIZE, "SNDCTL_DSP_SAMPLESIZE"},
+	{SNDCTL_DSP_CHANNELS, "SNDCTL_DSP_CHANNELS"},
+	{SOUND_PCM_WRITE_CHANNELS, "SOUND_PCM_WRITE_CHANNELS"},
+	{SOUND_PCM_WRITE_FILTER, "SOUND_PCM_WRITE_FILTER"},
+	{SNDCTL_DSP_POST, "SNDCTL_DSP_POST"},
+	{SNDCTL_DSP_SUBDIVIDE, "SNDCTL_DSP_SUBDIVIDE"},
+	{SNDCTL_DSP_SETFRAGMENT, "SNDCTL_DSP_SETFRAGMENT"},
+	{SNDCTL_DSP_GETFMTS, "SNDCTL_DSP_GETFMTS"},
+	{SNDCTL_DSP_SETFMT, "SNDCTL_DSP_SETFMT"},
+	{SNDCTL_DSP_GETOSPACE, "SNDCTL_DSP_GETOSPACE"},
+	{SNDCTL_DSP_GETISPACE, "SNDCTL_DSP_GETISPACE"},
+	{SNDCTL_DSP_NONBLOCK, "SNDCTL_DSP_NONBLOCK"},
+	{SNDCTL_DSP_GETCAPS, "SNDCTL_DSP_GETCAPS"},
+	{SNDCTL_DSP_GETTRIGGER, "SNDCTL_DSP_GETTRIGGER"},
+	{SNDCTL_DSP_SETTRIGGER, "SNDCTL_DSP_SETTRIGGER"},
+	{SNDCTL_DSP_GETIPTR, "SNDCTL_DSP_GETIPTR"},
+	{SNDCTL_DSP_GETOPTR, "SNDCTL_DSP_GETOPTR"},
+	{SNDCTL_DSP_MAPINBUF, "SNDCTL_DSP_MAPINBUF"},
+	{SNDCTL_DSP_MAPOUTBUF, "SNDCTL_DSP_MAPOUTBUF"},
+	{SNDCTL_DSP_SETSYNCRO, "SNDCTL_DSP_SETSYNCRO"},
+	{SNDCTL_DSP_SETDUPLEX, "SNDCTL_DSP_SETDUPLEX"},
+	{SNDCTL_DSP_GETODELAY, "SNDCTL_DSP_GETODELAY"},
+	{SNDCTL_DSP_GETCHANNELMASK, "SNDCTL_DSP_GETCHANNELMASK"},
+	{SNDCTL_DSP_BIND_CHANNEL, "SNDCTL_DSP_BIND_CHANNEL"},
+	{OSS_GETVERSION, "OSS_GETVERSION"},
+	{SOUND_PCM_READ_RATE, "SOUND_PCM_READ_RATE"},
+	{SOUND_PCM_READ_CHANNELS, "SOUND_PCM_READ_CHANNELS"},
+	{SOUND_PCM_READ_BITS, "SOUND_PCM_READ_BITS"},
+	{SOUND_PCM_READ_FILTER, "SOUND_PCM_READ_FILTER"}
+};
+#endif
+
+static int
+dma_count_done(struct dmabuf *db)
+{
+	if (db->stopped)
+		return 0;
+
+	return db->dma_fragsize - au1xxx_get_dma_residue(db->dmanr);
+}
+
+
+static int
+au1550_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	audio_buf_info  abinfo;
+	count_info      cinfo;
+	int             count;
+	int             val, mapped, ret, diff;
+
+	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
+		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
+		if (ioctl_str[count].cmd == cmd)
+			break;
+	}
+	if (count < sizeof(ioctl_str) / sizeof(ioctl_str[0]))
+		dbg("ioctl %s, arg=0x%lx", ioctl_str[count].str, arg);
+	else
+		dbg("ioctl 0x%x unknown, arg=0x%lx", cmd, arg);
+#endif
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *) arg);
+
+	case SNDCTL_DSP_SYNC:
+		if (file->f_mode & FMODE_WRITE)
+			return drain_dac(s, file->f_flags & O_NONBLOCK);
+		return 0;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_GETCAPS:
+		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
+				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			synchronize_irq();
+			s->dma_dac.count = s->dma_dac.total_bytes = 0;
+			s->dma_dac.nextIn = s->dma_dac.nextOut =
+				s->dma_dac.rawbuf;
+		}
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			synchronize_irq();
+			s->dma_adc.count = s->dma_adc.total_bytes = 0;
+			s->dma_adc.nextIn = s->dma_adc.nextOut =
+				s->dma_adc.rawbuf;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val >= 0) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				set_adc_rate(s, val);
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				set_dac_rate(s, val);
+			}
+			if (s->open_mode & FMODE_READ)
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			if (s->open_mode & FMODE_WRITE)
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+		}
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SNDCTL_DSP_STEREO:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.num_channels = val ? 2 : 1;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.num_channels = val ? 2 : 1;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_CHANNELS:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 0) {
+			if (file->f_mode & FMODE_READ) {
+				if (val < 0 || val > 2)
+					return -EINVAL;
+				stop_adc(s);
+				s->dma_adc.num_channels = val;
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				switch (val) {
+				case 1:
+				case 2:
+					break;
+				default:
+					return -EINVAL;
+				}
+
+				stop_dac(s);
+				s->dma_dac.num_channels = val;
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_GETFMTS:	/* Returns a mask */
+		return put_user(AFMT_S16_LE | AFMT_U8, (int *) arg);
+
+	case SNDCTL_DSP_SETFMT:	/* Selects ONE fmt */
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != AFMT_QUERY) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				if (val == AFMT_S16_LE)
+					s->dma_adc.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_adc.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				if (val == AFMT_S16_LE)
+					s->dma_dac.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_dac.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = (s->dma_adc.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+			else
+				val = (s->dma_dac.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		spin_lock_irqsave(&s->lock, flags);
+		if (file->f_mode & FMODE_READ && !s->dma_adc.stopped)
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && !s->dma_dac.stopped)
+			val |= PCM_ENABLE_OUTPUT;
+		spin_unlock_irqrestore(&s->lock, flags);
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT)
+				start_adc(s);
+			else
+				stop_adc(s);
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT)
+				start_dac(s);
+			else
+				stop_dac(s);
+		}
+		return 0;
+
+	case SNDCTL_DSP_GETOSPACE:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_dac.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = (s->dma_dac.dmasize - count) /
+			s->dma_dac.cnt_factor;
+		abinfo.fragstotal = s->dma_dac.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
+#ifdef AU1000_VERBOSE_DEBUG
+		dbg("bytes=%d, fragments=%d", abinfo.bytes, abinfo.fragments);
+#endif
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_GETISPACE:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_adc.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_adc.count;
+		count += dma_count_done(&s->dma_adc);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = count / s->dma_adc.cnt_factor;
+		abinfo.fragstotal = s->dma_adc.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_GETODELAY:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		count /= s->dma_dac.cnt_factor;
+		return put_user(count, (int *) arg);
+
+	case SNDCTL_DSP_GETIPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_adc.total_bytes;
+		count = s->dma_adc.count;
+		if (!s->dma_adc.stopped) {
+			diff = dma_count_done(&s->dma_adc);
+			count += diff;
+			cinfo.bytes += diff;
+			cinfo.ptr =  virt_to_phys(s->dma_adc.nextIn) + diff -
+				virt_to_phys(s->dma_adc.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_adc.nextIn) -
+				virt_to_phys(s->dma_adc.rawbuf);
+		if (s->dma_adc.mapped)
+			s->dma_adc.count &= (s->dma_adc.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETOPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_dac.total_bytes;
+		count = s->dma_dac.count;
+		if (!s->dma_dac.stopped) {
+			diff = dma_count_done(&s->dma_dac);
+			count -= diff;
+			cinfo.bytes += diff;
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) + diff -
+				virt_to_phys(s->dma_dac.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) -
+				virt_to_phys(s->dma_dac.rawbuf);
+		if (s->dma_dac.mapped)
+			s->dma_dac.count &= (s->dma_dac.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_dac.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(s->dma_dac.fragsize, (int *) arg);
+		else
+			return put_user(s->dma_adc.fragsize, (int *) arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.ossfragshift = val & 0xffff;
+			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_adc.ossfragshift < 4)
+				s->dma_adc.ossfragshift = 4;
+			if (s->dma_adc.ossfragshift > 15)
+				s->dma_adc.ossfragshift = 15;
+			if (s->dma_adc.ossmaxfrags < 4)
+				s->dma_adc.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.ossfragshift = val & 0xffff;
+			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_dac.ossfragshift < 4)
+				s->dma_dac.ossfragshift = 4;
+			if (s->dma_dac.ossfragshift > 15)
+				s->dma_dac.ossfragshift = 15;
+			if (s->dma_dac.ossmaxfrags < 4)
+				s->dma_dac.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SUBDIVIDE:
+		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
+		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
+			return -EINVAL;
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 1 && val != 2 && val != 4)
+			return -EINVAL;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.subdivision = val;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.subdivision = val;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SOUND_PCM_READ_RATE:
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SOUND_PCM_READ_CHANNELS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.num_channels, (int *)arg);
+		else
+			return put_user(s->dma_dac.num_channels, (int *)arg);
+
+	case SOUND_PCM_READ_BITS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.sample_size, (int *)arg);
+		else
+			return put_user(s->dma_dac.sample_size, (int *)arg);
+
+	case SOUND_PCM_WRITE_FILTER:
+	case SNDCTL_DSP_SETSYNCRO:
+	case SOUND_PCM_READ_FILTER:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int
+au1550_open(struct inode *inode, struct file *file)
+{
+	int             minor = MINOR(inode->i_rdev);
+	DECLARE_WAITQUEUE(wait, current);
+	struct au1550_state *s = &au1550_state;
+	int             ret;
+
+#ifdef AU1000_VERBOSE_DEBUG
+	if (file->f_flags & O_NONBLOCK)
+		dbg(__FUNCTION__ ": non-blocking");
+	else
+		dbg(__FUNCTION__ ": blocking");
+#endif
+	
+	file->private_data = s;
+	/* wait for device to become free */
+	down(&s->open_sem);
+	while (s->open_mode & file->f_mode) {
+		if (file->f_flags & O_NONBLOCK) {
+			up(&s->open_sem);
+			return -EBUSY;
+		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
+		up(&s->open_sem);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		down(&s->open_sem);
+	}
+
+	stop_dac(s);
+	stop_adc(s);
+
+	if (file->f_mode & FMODE_READ) {
+		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
+			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
+		s->dma_adc.num_channels = 1;
+		s->dma_adc.sample_size = 8;
+		set_adc_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_adc.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
+			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
+		s->dma_dac.num_channels = 1;
+		s->dma_dac.sample_size = 8;
+		set_dac_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_dac.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		if ((ret = prog_dmabuf_adc(s)))
+			return ret;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if ((ret = prog_dmabuf_dac(s)))
+			return ret;
+	}
+
+	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
+	up(&s->open_sem);
+	init_MUTEX(&s->sem);
+	return 0;
+}
+
+static int
+au1550_release(struct inode *inode, struct file *file)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+
+	lock_kernel();
+	
+	if (file->f_mode & FMODE_WRITE) {
+		unlock_kernel();
+		drain_dac(s, file->f_flags & O_NONBLOCK);
+		lock_kernel();
+	}
+
+	down(&s->open_sem);
+	if (file->f_mode & FMODE_WRITE) {
+		stop_dac(s);
+		kfree(s->dma_dac.rawbuf);
+		s->dma_dac.rawbuf = NULL;
+	}
+	if (file->f_mode & FMODE_READ) {
+		stop_adc(s);
+		kfree(s->dma_adc.rawbuf);
+		s->dma_adc.rawbuf = NULL;
+	}
+	s->open_mode &= ((~file->f_mode) & (FMODE_READ|FMODE_WRITE));
+	up(&s->open_sem);
+	wake_up(&s->open_wait);
+	unlock_kernel();
+	return 0;
+}
+
+static struct file_operations au1550_audio_fops = {
+	owner:		THIS_MODULE,
+	llseek:		au1550_llseek,
+	read:		au1550_read,
+	write:		au1550_write,
+	poll:		au1550_poll,
+	ioctl:		au1550_ioctl,
+	mmap:		au1550_mmap,
+	open:		au1550_open,
+	release:	au1550_release,
+};
+
+/* Set up an internal clock for the PSC3.  This will then get
+ * driven out of the Au1550 as the master.
+ */
+static void
+intclk_setup(void)
+{
+	uint clk, rate;
+
+	/* Wire up Freq4 as a clock for the PSC3.
+	 * We know SMBus uses Freq3.
+	 * By making changes to this rate, plus the word strobe
+	 * size, we can make fine adjustments to the actual data rate.
+	 */
+	rate = get_au1x00_speed();
+#ifdef TRY_441KHz
+	rate /= (11 * 1000000);
+#else
+	rate /= (12 * 1000000);
+#endif
+
+	/* The FRDIV in the frequency control is (FRDIV + 1) * 2
+	*/
+	rate /=2;
+	rate--;
+	clk = au_readl(SYS_FREQCTRL1);
+	au_sync();
+	clk &= ~(SYS_FC_FRDIV4_MASK | SYS_FC_FS4);;
+	clk |= (rate << SYS_FC_FRDIV4_BIT);
+	clk |= SYS_FC_FE4;
+	au_writel(clk, SYS_FREQCTRL1);
+	au_sync();
+
+	/* Set up the clock source routing to get Freq4 to PSC3_intclk.
+	*/
+	clk = au_readl(SYS_CLKSRC);
+	au_sync();
+	clk &= ~0x01f00000;
+	clk |= (6 << 22);
+	au_writel(clk, SYS_CLKSRC);
+	au_sync();
+}
+
+static int __devinit
+au1550_probe(void)
+{
+	struct au1550_state *s = &au1550_state;
+	int val;
+	volatile psc_i2s_t *ip;
+#ifdef AU1550_DEBUG
+	char proc_str[80];
+#endif
+
+	memset(s, 0, sizeof(struct au1550_state));
+
+	init_waitqueue_head(&s->dma_adc.wait);
+	init_waitqueue_head(&s->dma_dac.wait);
+	init_waitqueue_head(&s->open_wait);
+	init_MUTEX(&s->open_sem);
+	spin_lock_init(&s->lock);
+
+	s->codec = &au1550_i2s_codec;
+	s->psc_addr = (volatile psc_i2s_t *)I2S_PSC_BASE;
+	ip = s->psc_addr;
+
+	if (!request_region(CPHYSADDR(ip),
+			    0x30, AU1550_MODULE_NAME)) {
+		pr_error("I2S Audio ports in use");
+	}
+
+	/* Allocate the DMA Channels
+	*/
+	if ((s->dma_dac.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_MEM_CHAN,
+	    DBDMA_I2S_TX_CHAN, dac_dma_interrupt, (void *)s)) == 0) {
+		pr_error("Can't get DAC DMA");
+		goto err_dma1;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_dac.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_dac.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		pr_error("Can't get DAC DMA descriptors");
+		goto err_dma1;
+	}
+
+	if ((s->dma_adc.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_I2S_RX_CHAN,
+	    DBDMA_MEM_CHAN, adc_dma_interrupt, (void *)s)) == 0) {
+		pr_error("Can't get ADC DMA");
+		goto err_dma2;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_adc.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_adc.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		pr_error("Can't get ADC DMA descriptors");
+		goto err_dma2;
+	}
+
+	pr_info("DAC: DMA%d, ADC: DMA%d", DBDMA_I2S_TX_CHAN, DBDMA_I2S_RX_CHAN);
+
+	/* register devices */
+
+	if ((s->dev_audio = register_sound_dsp(&au1550_audio_fops, -1)) < 0)
+		goto err_dev1;
+
+	if ((s->dev_mixer = register_sound_mixer(&au1550_mixer_fops, -1)) < 0)
+		goto err_dev2;
+
+#ifdef AU1550_DEBUG
+	/* intialize the debug proc device */
+	s->ps = create_proc_read_entry(AU1000_MODULE_NAME, 0, NULL,
+				       proc_au1550_dump, NULL);
+#endif /* AU1550_DEBUG */
+
+	intclk_setup();
+
+	/* The GPIO for the appropriate PSC was configured by the
+	 * board specific start up.
+	 *
+	 * configure PSC for I2S Audio
+	 */
+	ip->psc_ctrl = PSC_CTRL_DISABLE;	/* Disable PSC */
+	au_sync();
+	ip->psc_sel = (PSC_SEL_CLK_INTCLK | PSC_SEL_PS_I2SMODE);
+	au_sync();
+
+	/* Enable PSC
+	*/
+	ip->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+
+	/* Wait for PSC ready.
+	*/
+	do {
+		val = ip->psc_i2sstat;
+		au_sync();
+	} while ((val & PSC_I2SSTAT_SR) == 0);
+
+	/* Configure I2S controller.
+	 * Deep FIFO, 16-bit sample, DMA, make sure DMA matches fifo size.
+	 * Actual I2S mode (first bit delayed by one clock).
+	 * Master mode (We provide the clock from the PSC).
+	 */
+	val = PSC_I2SCFG_SET_LEN(16);
+#ifdef TRY_441KHz
+	/* This really should be 250, but it appears that all of the
+	 * PLLs, dividers and so on in the chain shift it.  That's the
+	 * problem with sourceing the clock instead of letting the very
+	 * stable codec provide it.  But, the PSC doesn't appear to want
+	 * to work in slave mode, so this is what we get.  It's  not
+	 * studio quality timing, but it's good enough for listening
+	 * to mp3s.
+	 */
+	val |= PSC_I2SCFG_SET_WS(252);
+#else
+	val |= PSC_I2SCFG_SET_WS(250);
+#endif
+	val |= PSC_I2SCFG_RT_FIFO8 | PSC_I2SCFG_TT_FIFO8 | \
+					PSC_I2SCFG_BI | PSC_I2SCFG_XM;
+
+	ip->psc_i2scfg = val;
+	au_sync();
+	val |= PSC_I2SCFG_DE_ENABLE;
+	ip->psc_i2scfg = val;
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		val = ip->psc_i2sstat;
+		au_sync();
+	} while ((val & PSC_I2SSTAT_DR) == 0);
+
+	val = ip->psc_i2scfg;
+	au_sync();
+
+	s->codec->init_codec(s->codec);
+
+	return 0;
+
+ err_dev2:
+	unregister_sound_dsp(s->dev_audio);
+ err_dev1:
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+ err_dma2:
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+ err_dma1:
+	release_region(CPHYSADDR(I2S_PSC_BASE), 0x30);
+
+	return -1;
+}
+
+static void __devinit
+au1550_remove(void)
+{
+	struct au1550_state *s = &au1550_state;
+
+	if (!s)
+		return;
+#ifdef AU1550_DEBUG
+	if (s->ps)
+		remove_proc_entry(AU1000_MODULE_NAME, NULL);
+#endif /* AU1000_DEBUG */
+	synchronize_irq();
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+	release_region(CPHYSADDR(I2S_PSC_BASE), 0x30);
+	unregister_sound_dsp(s->dev_audio);
+	unregister_sound_mixer(s->dev_mixer);
+}
+
+static int __init
+init_au1550(void)
+{
+	return au1550_probe();
+}
+
+static void __exit
+cleanup_au1550(void)
+{
+	au1550_remove();
+}
+
+module_init(init_au1550);
+module_exit(cleanup_au1550);
+
+MODULE_AUTHOR("Advanced Micro Devices (AMD), dan@embeddededge.com");
+MODULE_DESCRIPTION("Au1550 I2S Audio Driver");
diff -Naur linux-2.6.14/sound/oss/Kconfig linux-mips-2.6.14.orig/sound/oss/Kconfig
--- linux-2.6.14/sound/oss/Kconfig	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/sound/oss/Kconfig	2005-11-17 11:45:06.000000000 -0800
@@ -202,7 +202,7 @@
 	depends on SOUND_PRIME && SGI_IP22 && EXPERIMENTAL
 	help
 	  Say Y or M if you have an SGI Indy system and want to be able to
-	  use it's on-board A2 audio system.
+	  use it's on-board A2 audio system
 
 config SOUND_IT8172
 	tristate "IT8172G Sound"
@@ -224,6 +224,10 @@
 	tristate "Au1550 AC97 Sound"
 	depends on SOUND_PRIME && SOC_AU1550
 
+config SOUND_AU1550_I2S
+	tristate "Au1550 I2S Sound"
+	depends on SOUND_PRIME && SOC_AU1550
+
 config SOUND_TRIDENT
 	tristate "Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core"
 	depends on SOUND_PRIME && PCI
diff -Naur linux-2.6.14/sound/oss/Makefile linux-mips-2.6.14.orig/sound/oss/Makefile
--- linux-2.6.14/sound/oss/Makefile	2005-10-27 17:02:08.000000000 -0700
+++ linux-mips-2.6.14.orig/sound/oss/Makefile	2005-11-17 11:45:06.000000000 -0800
@@ -64,8 +64,9 @@
 obj-$(CONFIG_SOUND_ES1370)	+= es1370.o
 obj-$(CONFIG_SOUND_ES1371)	+= es1371.o ac97_codec.o
 obj-$(CONFIG_SOUND_VRC5477)	+= nec_vrc5477.o ac97_codec.o
-obj-$(CONFIG_SOUND_AU1000)	+= au1000.o ac97_codec.o
-obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o
+obj-$(CONFIG_SOUND_AU1000)	+= au1000.o ac97_codec.o  
+obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o  
+obj-$(CONFIG_SOUND_AU1550_I2S)	+= au1550_i2s.o  
 obj-$(CONFIG_SOUND_ESSSOLO1)	+= esssolo1.o
 obj-$(CONFIG_SOUND_FUSION)	+= cs46xx.o ac97_codec.o
 obj-$(CONFIG_SOUND_MAESTRO)	+= maestro.o
