Submitted By:            Pierre Labastie <pierre dot labastie at neuf dot fr>
Date:                    2022-04-06
Initial Package Version: 102.9.0esr
Upstream Status:         Applied
Origin:                  upstream (rediffed for applying to 102.9)
Description:             Update Gecko to use ffmpeg 6.0 APIs

Without this patch, H.264 videos cannot be played. Fix taken from
     https://hg.mozilla.org/mozilla-central/rev/467cc49519ff
     https://hg.mozilla.org/mozilla-central/rev/c174bd2624e2
     https://hg.mozilla.org/mozilla-central/rev/2b8ef32d5cbe
     https://hg.mozilla.org/mozilla-central/rev/86f5be2f7d24
     https://hg.mozilla.org/mozilla-central/rev/c0bdf286aeea
     https://hg.mozilla.org/mozilla-central/rev/1d959fb3ed39
     https://hg.mozilla.org/mozilla-central/rev/72741c64ce30
     https://hg.mozilla.org/mozilla-central/rev/02ab0b6c0713
     https://hg.mozilla.org/mozilla-central/rev/f35fdcd00b92
     https://hg.mozilla.org/mozilla-central/rev/f446b3e633af
     https://hg.mozilla.org/mozilla-central/rev/3ace3ff557d1
     https://hg.mozilla.org/mozilla-central/rev/2453ed57c828
     https://hg.mozilla.org/mozilla-central/rev/f9db1c11b1c0
     https://hg.mozilla.org/mozilla-central/rev/cff1321634cf
and  https://hg.mozilla.org/mozilla-central/rev/4e3d5ec4e2b1
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avcodec.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avcodec.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avcodec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avcodec.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,3230 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_AVCODEC_H
+#define AVCODEC_AVCODEC_H
+
+/**
+ * @file
+ * @ingroup libavc
+ * Libavcodec external API header
+ */
+
+#include "libavutil/samplefmt.h"
+#include "libavutil/attributes.h"
+#include "libavutil/avutil.h"
+#include "libavutil/buffer.h"
+#include "libavutil/dict.h"
+#include "libavutil/frame.h"
+#include "libavutil/log.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/rational.h"
+
+#include "codec.h"
+#include "codec_desc.h"
+#include "codec_par.h"
+#include "codec_id.h"
+#include "defs.h"
+#include "packet.h"
+#include "version_major.h"
+#ifndef HAVE_AV_CONFIG_H
+/* When included as part of the ffmpeg build, only include the major version
+ * to avoid unnecessary rebuilds. When included externally, keep including
+ * the full version information. */
+#  include "version.h"
+#endif
+
+/**
+ * @defgroup libavc libavcodec
+ * Encoding/Decoding Library
+ *
+ * @{
+ *
+ * @defgroup lavc_decoding Decoding
+ * @{
+ * @}
+ *
+ * @defgroup lavc_encoding Encoding
+ * @{
+ * @}
+ *
+ * @defgroup lavc_codec Codecs
+ * @{
+ * @defgroup lavc_codec_native Native Codecs
+ * @{
+ * @}
+ * @defgroup lavc_codec_wrappers External library wrappers
+ * @{
+ * @}
+ * @defgroup lavc_codec_hwaccel Hardware Accelerators bridge
+ * @{
+ * @}
+ * @}
+ * @defgroup lavc_internal Internal
+ * @{
+ * @}
+ * @}
+ */
+
+/**
+ * @ingroup libavc
+ * @defgroup lavc_encdec send/receive encoding and decoding API overview
+ * @{
+ *
+ * The avcodec_send_packet()/avcodec_receive_frame()/avcodec_send_frame()/
+ * avcodec_receive_packet() functions provide an encode/decode API, which
+ * decouples input and output.
+ *
+ * The API is very similar for encoding/decoding and audio/video, and works as
+ * follows:
+ * - Set up and open the AVCodecContext as usual.
+ * - Send valid input:
+ *   - For decoding, call avcodec_send_packet() to give the decoder raw
+ *     compressed data in an AVPacket.
+ *   - For encoding, call avcodec_send_frame() to give the encoder an AVFrame
+ *     containing uncompressed audio or video.
+ *
+ *   In both cases, it is recommended that AVPackets and AVFrames are
+ *   refcounted, or libavcodec might have to copy the input data. (libavformat
+ *   always returns refcounted AVPackets, and av_frame_get_buffer() allocates
+ *   refcounted AVFrames.)
+ * - Receive output in a loop. Periodically call one of the avcodec_receive_*()
+ *   functions and process their output:
+ *   - For decoding, call avcodec_receive_frame(). On success, it will return
+ *     an AVFrame containing uncompressed audio or video data.
+ *   - For encoding, call avcodec_receive_packet(). On success, it will return
+ *     an AVPacket with a compressed frame.
+ *
+ *   Repeat this call until it returns AVERROR(EAGAIN) or an error. The
+ *   AVERROR(EAGAIN) return value means that new input data is required to
+ *   return new output. In this case, continue with sending input. For each
+ *   input frame/packet, the codec will typically return 1 output frame/packet,
+ *   but it can also be 0 or more than 1.
+ *
+ * At the beginning of decoding or encoding, the codec might accept multiple
+ * input frames/packets without returning a frame, until its internal buffers
+ * are filled. This situation is handled transparently if you follow the steps
+ * outlined above.
+ *
+ * In theory, sending input can result in EAGAIN - this should happen only if
+ * not all output was received. You can use this to structure alternative decode
+ * or encode loops other than the one suggested above. For example, you could
+ * try sending new input on each iteration, and try to receive output if that
+ * returns EAGAIN.
+ *
+ * End of stream situations. These require "flushing" (aka draining) the codec,
+ * as the codec might buffer multiple frames or packets internally for
+ * performance or out of necessity (consider B-frames).
+ * This is handled as follows:
+ * - Instead of valid input, send NULL to the avcodec_send_packet() (decoding)
+ *   or avcodec_send_frame() (encoding) functions. This will enter draining
+ *   mode.
+ * - Call avcodec_receive_frame() (decoding) or avcodec_receive_packet()
+ *   (encoding) in a loop until AVERROR_EOF is returned. The functions will
+ *   not return AVERROR(EAGAIN), unless you forgot to enter draining mode.
+ * - Before decoding can be resumed again, the codec has to be reset with
+ *   avcodec_flush_buffers().
+ *
+ * Using the API as outlined above is highly recommended. But it is also
+ * possible to call functions outside of this rigid schema. For example, you can
+ * call avcodec_send_packet() repeatedly without calling
+ * avcodec_receive_frame(). In this case, avcodec_send_packet() will succeed
+ * until the codec's internal buffer has been filled up (which is typically of
+ * size 1 per output frame, after initial input), and then reject input with
+ * AVERROR(EAGAIN). Once it starts rejecting input, you have no choice but to
+ * read at least some output.
+ *
+ * Not all codecs will follow a rigid and predictable dataflow; the only
+ * guarantee is that an AVERROR(EAGAIN) return value on a send/receive call on
+ * one end implies that a receive/send call on the other end will succeed, or
+ * at least will not fail with AVERROR(EAGAIN). In general, no codec will
+ * permit unlimited buffering of input or output.
+ *
+ * A codec is not allowed to return AVERROR(EAGAIN) for both sending and
+ * receiving. This would be an invalid state, which could put the codec user
+ * into an endless loop. The API has no concept of time either: it cannot happen
+ * that trying to do avcodec_send_packet() results in AVERROR(EAGAIN), but a
+ * repeated call 1 second later accepts the packet (with no other receive/flush
+ * API calls involved). The API is a strict state machine, and the passage of
+ * time is not supposed to influence it. Some timing-dependent behavior might
+ * still be deemed acceptable in certain cases. But it must never result in both
+ * send/receive returning EAGAIN at the same time at any point. It must also
+ * absolutely be avoided that the current state is "unstable" and can
+ * "flip-flop" between the send/receive APIs allowing progress. For example,
+ * it's not allowed that the codec randomly decides that it actually wants to
+ * consume a packet now instead of returning a frame, after it just returned
+ * AVERROR(EAGAIN) on an avcodec_send_packet() call.
+ * @}
+ */
+
+/**
+ * @defgroup lavc_core Core functions/structures.
+ * @ingroup libavc
+ *
+ * Basic definitions, functions for querying libavcodec capabilities,
+ * allocating core structures, etc.
+ * @{
+ */
+
+/**
+ * @ingroup lavc_encoding
+ * minimum encoding buffer size
+ * Used to avoid some checks during header writing.
+ */
+#define AV_INPUT_BUFFER_MIN_SIZE 16384
+
+/**
+ * @ingroup lavc_encoding
+ */
+typedef struct RcOverride {
+  int start_frame;
+  int end_frame;
+  int qscale;  // If this is 0 then quality_factor will be used instead.
+  float quality_factor;
+} RcOverride;
+
+/* encoding support
+   These flags can be passed in AVCodecContext.flags before initialization.
+   Note: Not everything is supported yet.
+*/
+
+/**
+ * Allow decoders to produce frames with data planes that are not aligned
+ * to CPU requirements (e.g. due to cropping).
+ */
+#define AV_CODEC_FLAG_UNALIGNED (1 << 0)
+/**
+ * Use fixed qscale.
+ */
+#define AV_CODEC_FLAG_QSCALE (1 << 1)
+/**
+ * 4 MV per MB allowed / advanced prediction for H.263.
+ */
+#define AV_CODEC_FLAG_4MV (1 << 2)
+/**
+ * Output even those frames that might be corrupted.
+ */
+#define AV_CODEC_FLAG_OUTPUT_CORRUPT (1 << 3)
+/**
+ * Use qpel MC.
+ */
+#define AV_CODEC_FLAG_QPEL (1 << 4)
+/**
+ * Don't output frames whose parameters differ from first
+ * decoded frame in stream.
+ */
+#define AV_CODEC_FLAG_DROPCHANGED (1 << 5)
+/**
+ * Request the encoder to output reconstructed frames, i.e.\ frames that would
+ * be produced by decoding the encoded bistream. These frames may be retrieved
+ * by calling avcodec_receive_frame() immediately after a successful call to
+ * avcodec_receive_packet().
+ *
+ * Should only be used with encoders flagged with the
+ * @ref AV_CODEC_CAP_ENCODER_RECON_FRAME capability.
+ */
+#define AV_CODEC_FLAG_RECON_FRAME (1 << 6)
+/**
+ * @par decoding
+ * Request the decoder to propagate each packets AVPacket.opaque and
+ * AVPacket.opaque_ref to its corresponding output AVFrame.
+ *
+ * @par encoding:
+ * Request the encoder to propagate each frame's AVFrame.opaque and
+ * AVFrame.opaque_ref values to its corresponding output AVPacket.
+ *
+ * @par
+ * May only be set on encoders that have the
+ * @ref AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability flag.
+ *
+ * @note
+ * While in typical cases one input frame produces exactly one output packet
+ * (perhaps after a delay), in general the mapping of frames to packets is
+ * M-to-N, so
+ * - Any number of input frames may be associated with any given output packet.
+ *   This includes zero - e.g. some encoders may output packets that carry only
+ *   metadata about the whole stream.
+ * - A given input frame may be associated with any number of output packets.
+ *   Again this includes zero - e.g. some encoders may drop frames under certain
+ *   conditions.
+ * .
+ * This implies that when using this flag, the caller must NOT assume that
+ * - a given input frame's opaques will necessarily appear on some output
+ * packet;
+ * - every output packet will have some non-NULL opaque value.
+ * .
+ * When an output packet contains multiple frames, the opaque values will be
+ * taken from the first of those.
+ *
+ * @note
+ * The converse holds for decoders, with frames and packets switched.
+ */
+#define AV_CODEC_FLAG_COPY_OPAQUE (1 << 7)
+/**
+ * Signal to the encoder that the values of AVFrame.duration are valid and
+ * should be used (typically for transferring them to output packets).
+ *
+ * If this flag is not set, frame durations are ignored.
+ */
+#define AV_CODEC_FLAG_FRAME_DURATION (1 << 8)
+/**
+ * Use internal 2pass ratecontrol in first pass mode.
+ */
+#define AV_CODEC_FLAG_PASS1 (1 << 9)
+/**
+ * Use internal 2pass ratecontrol in second pass mode.
+ */
+#define AV_CODEC_FLAG_PASS2 (1 << 10)
+/**
+ * loop filter.
+ */
+#define AV_CODEC_FLAG_LOOP_FILTER (1 << 11)
+/**
+ * Only decode/encode grayscale.
+ */
+#define AV_CODEC_FLAG_GRAY (1 << 13)
+/**
+ * error[?] variables will be set during encoding.
+ */
+#define AV_CODEC_FLAG_PSNR (1 << 15)
+/**
+ * Use interlaced DCT.
+ */
+#define AV_CODEC_FLAG_INTERLACED_DCT (1 << 18)
+/**
+ * Force low delay.
+ */
+#define AV_CODEC_FLAG_LOW_DELAY (1 << 19)
+/**
+ * Place global headers in extradata instead of every keyframe.
+ */
+#define AV_CODEC_FLAG_GLOBAL_HEADER (1 << 22)
+/**
+ * Use only bitexact stuff (except (I)DCT).
+ */
+#define AV_CODEC_FLAG_BITEXACT (1 << 23)
+/* Fx : Flag for H.263+ extra options */
+/**
+ * H.263 advanced intra coding / MPEG-4 AC prediction
+ */
+#define AV_CODEC_FLAG_AC_PRED (1 << 24)
+/**
+ * interlaced motion estimation
+ */
+#define AV_CODEC_FLAG_INTERLACED_ME (1 << 29)
+#define AV_CODEC_FLAG_CLOSED_GOP (1U << 31)
+
+/**
+ * Allow non spec compliant speedup tricks.
+ */
+#define AV_CODEC_FLAG2_FAST (1 << 0)
+/**
+ * Skip bitstream encoding.
+ */
+#define AV_CODEC_FLAG2_NO_OUTPUT (1 << 2)
+/**
+ * Place global headers at every keyframe instead of in extradata.
+ */
+#define AV_CODEC_FLAG2_LOCAL_HEADER (1 << 3)
+
+/**
+ * Input bitstream might be truncated at a packet boundaries
+ * instead of only at frame boundaries.
+ */
+#define AV_CODEC_FLAG2_CHUNKS (1 << 15)
+/**
+ * Discard cropping information from SPS.
+ */
+#define AV_CODEC_FLAG2_IGNORE_CROP (1 << 16)
+
+/**
+ * Show all frames before the first keyframe
+ */
+#define AV_CODEC_FLAG2_SHOW_ALL (1 << 22)
+/**
+ * Export motion vectors through frame side data
+ */
+#define AV_CODEC_FLAG2_EXPORT_MVS (1 << 28)
+/**
+ * Do not skip samples and export skip information as frame side data
+ */
+#define AV_CODEC_FLAG2_SKIP_MANUAL (1 << 29)
+/**
+ * Do not reset ASS ReadOrder field on flush (subtitles decoding)
+ */
+#define AV_CODEC_FLAG2_RO_FLUSH_NOOP (1 << 30)
+/**
+ * Generate/parse ICC profiles on encode/decode, as appropriate for the type of
+ * file. No effect on codecs which cannot contain embedded ICC profiles, or
+ * when compiled without support for lcms2.
+ */
+#define AV_CODEC_FLAG2_ICC_PROFILES (1U << 31)
+
+/* Exported side data.
+   These flags can be passed in AVCodecContext.export_side_data before
+   initialization.
+*/
+/**
+ * Export motion vectors through frame side data
+ */
+#define AV_CODEC_EXPORT_DATA_MVS (1 << 0)
+/**
+ * Export encoder Producer Reference Time through packet side data
+ */
+#define AV_CODEC_EXPORT_DATA_PRFT (1 << 1)
+/**
+ * Decoding only.
+ * Export the AVVideoEncParams structure through frame side data.
+ */
+#define AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS (1 << 2)
+/**
+ * Decoding only.
+ * Do not apply film grain, export it instead.
+ */
+#define AV_CODEC_EXPORT_DATA_FILM_GRAIN (1 << 3)
+
+/**
+ * The decoder will keep a reference to the frame and may reuse it later.
+ */
+#define AV_GET_BUFFER_FLAG_REF (1 << 0)
+
+/**
+ * The encoder will keep a reference to the packet and may reuse it later.
+ */
+#define AV_GET_ENCODE_BUFFER_FLAG_REF (1 << 0)
+
+struct AVCodecInternal;
+
+/**
+ * main external API structure.
+ * New fields can be added to the end with minor version bumps.
+ * Removal, reordering and changes to existing fields require a major
+ * version bump.
+ * You can use AVOptions (av_opt* / av_set/get*()) to access these fields from
+ * user applications. The name string for AVOptions options matches the
+ * associated command line parameter name and can be found in
+ * libavcodec/options_table.h The AVOption/command line parameter names differ
+ * in some cases from the C structure field names for historic reasons or
+ * brevity. sizeof(AVCodecContext) must not be used outside libav*.
+ */
+typedef struct AVCodecContext {
+  /**
+   * information on struct for av_log
+   * - set by avcodec_alloc_context3
+   */
+  const AVClass* av_class;
+  int log_level_offset;
+
+  enum AVMediaType codec_type; /* see AVMEDIA_TYPE_xxx */
+  const struct AVCodec* codec;
+  enum AVCodecID codec_id; /* see AV_CODEC_ID_xxx */
+
+  /**
+   * fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
+   * This is used to work around some encoder bugs.
+   * A demuxer should set this to what is stored in the field used to identify
+   * the codec. If there are multiple such fields in a container then the
+   * demuxer should choose the one which maximizes the information about the
+   * used codec. If the codec tag field in a container is larger than 32 bits
+   * then the demuxer should remap the longer ID to 32 bits with a table or
+   * other structure. Alternatively a new extra_codec_tag + size could be added
+   * but for this a clear advantage must be demonstrated first.
+   * - encoding: Set by user, if not then the default based on codec_id will be
+   * used.
+   * - decoding: Set by user, will be converted to uppercase by libavcodec
+   * during init.
+   */
+  unsigned int codec_tag;
+
+  void* priv_data;
+
+  /**
+   * Private context used for internal data.
+   *
+   * Unlike priv_data, this is not codec-specific. It is used in general
+   * libavcodec functions.
+   */
+  struct AVCodecInternal* internal;
+
+  /**
+   * Private data of the user, can be used to carry app specific stuff.
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  void* opaque;
+
+  /**
+   * the average bitrate
+   * - encoding: Set by user; unused for constant quantizer encoding.
+   * - decoding: Set by user, may be overwritten by libavcodec
+   *             if this info is available in the stream
+   */
+  int64_t bit_rate;
+
+  /**
+   * number of bits the bitstream is allowed to diverge from the reference.
+   *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
+   * - encoding: Set by user; unused for constant quantizer encoding.
+   * - decoding: unused
+   */
+  int bit_rate_tolerance;
+
+  /**
+   * Global quality for codecs which cannot change it per frame.
+   * This should be proportional to MPEG-1/2/4 qscale.
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int global_quality;
+
+  /**
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int compression_level;
+#define FF_COMPRESSION_DEFAULT -1
+
+  /**
+   * AV_CODEC_FLAG_*.
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  int flags;
+
+  /**
+   * AV_CODEC_FLAG2_*
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  int flags2;
+
+  /**
+   * some codecs need / can use extradata like Huffman tables.
+   * MJPEG: Huffman tables
+   * rv10: additional flags
+   * MPEG-4: global headers (they can be in the bitstream or here)
+   * The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger
+   * than extradata_size to avoid problems if it is read with the bitstream
+   * reader. The bytewise contents of extradata must not depend on the
+   * architecture or CPU endianness. Must be allocated with the av_malloc()
+   * family of functions.
+   * - encoding: Set/allocated/freed by libavcodec.
+   * - decoding: Set/allocated/freed by user.
+   */
+  uint8_t* extradata;
+  int extradata_size;
+
+  /**
+   * This is the fundamental unit of time (in seconds) in terms
+   * of which frame timestamps are represented. For fixed-fps content,
+   * timebase should be 1/framerate and timestamp increments should be
+   * identically 1.
+   * This often, but not always is the inverse of the frame rate or field rate
+   * for video. 1/time_base is not the average frame rate if the frame rate is
+   * not constant.
+   *
+   * Like containers, elementary streams also can store timestamps, 1/time_base
+   * is the unit in which these timestamps are specified.
+   * As example of such codec time base see ISO/IEC 14496-2:2001(E)
+   * vop_time_increment_resolution and fixed_vop_rate
+   * (fixed_vop_rate == 0 implies that it is different from the framerate)
+   *
+   * - encoding: MUST be set by user.
+   * - decoding: unused.
+   */
+  AVRational time_base;
+
+  /**
+   * For some codecs, the time base is closer to the field rate than the frame
+   * rate. Most notably, H.264 and MPEG-2 specify time_base as half of frame
+   * duration if no telecine is used ...
+   *
+   * Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it
+   * to 2.
+   */
+  int ticks_per_frame;
+
+  /**
+   * Codec delay.
+   *
+   * Encoding: Number of frames delay there will be from the encoder input to
+   *           the decoder output. (we assume the decoder matches the spec)
+   * Decoding: Number of frames delay in addition to what a standard decoder
+   *           as specified in the spec would produce.
+   *
+   * Video:
+   *   Number of frames the decoded output will be delayed relative to the
+   *   encoded input.
+   *
+   * Audio:
+   *   For encoding, this field is unused (see initial_padding).
+   *
+   *   For decoding, this is the number of samples the decoder needs to
+   *   output before the decoder's output is valid. When seeking, you should
+   *   start decoding this many samples prior to your desired seek point.
+   *
+   * - encoding: Set by libavcodec.
+   * - decoding: Set by libavcodec.
+   */
+  int delay;
+
+  /* video only */
+  /**
+   * picture width / height.
+   *
+   * @note Those fields may not match the values of the last
+   * AVFrame output by avcodec_receive_frame() due frame
+   * reordering.
+   *
+   * - encoding: MUST be set by user.
+   * - decoding: May be set by the user before opening the decoder if known e.g.
+   *             from the container. Some decoders will require the dimensions
+   *             to be set by the caller. During decoding, the decoder may
+   *             overwrite those values as required while parsing the data.
+   */
+  int width, height;
+
+  /**
+   * Bitstream width / height, may be different from width/height e.g. when
+   * the decoded frame is cropped before being output or lowres is enabled.
+   *
+   * @note Those field may not match the value of the last
+   * AVFrame output by avcodec_receive_frame() due frame
+   * reordering.
+   *
+   * - encoding: unused
+   * - decoding: May be set by the user before opening the decoder if known
+   *             e.g. from the container. During decoding, the decoder may
+   *             overwrite those values as required while parsing the data.
+   */
+  int coded_width, coded_height;
+
+  /**
+   * the number of pictures in a group of pictures, or 0 for intra_only
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int gop_size;
+
+  /**
+   * Pixel format, see AV_PIX_FMT_xxx.
+   * May be set by the demuxer if known from headers.
+   * May be overridden by the decoder if it knows better.
+   *
+   * @note This field may not match the value of the last
+   * AVFrame output by avcodec_receive_frame() due frame
+   * reordering.
+   *
+   * - encoding: Set by user.
+   * - decoding: Set by user if known, overridden by libavcodec while
+   *             parsing the data.
+   */
+  enum AVPixelFormat pix_fmt;
+
+  /**
+   * If non NULL, 'draw_horiz_band' is called by the libavcodec
+   * decoder to draw a horizontal band. It improves cache usage. Not
+   * all codecs can do that. You must check the codec capabilities
+   * beforehand.
+   * When multithreading is used, it may be called from multiple threads
+   * at the same time; threads might draw different parts of the same AVFrame,
+   * or multiple AVFrames, and there is no guarantee that slices will be drawn
+   * in order.
+   * The function is also used by hardware acceleration APIs.
+   * It is called at least once during frame decoding to pass
+   * the data needed for hardware render.
+   * In that mode instead of pixel data, AVFrame points to
+   * a structure specific to the acceleration API. The application
+   * reads the structure and can change some fields to indicate progress
+   * or mark state.
+   * - encoding: unused
+   * - decoding: Set by user.
+   * @param height the height of the slice
+   * @param y the y position of the slice
+   * @param type 1->top field, 2->bottom field, 3->frame
+   * @param offset offset into the AVFrame.data from which the slice should be
+   * read
+   */
+  void (*draw_horiz_band)(struct AVCodecContext* s, const AVFrame* src,
+                          int offset[AV_NUM_DATA_POINTERS], int y, int type,
+                          int height);
+
+  /**
+   * Callback to negotiate the pixel format. Decoding only, may be set by the
+   * caller before avcodec_open2().
+   *
+   * Called by some decoders to select the pixel format that will be used for
+   * the output frames. This is mainly used to set up hardware acceleration,
+   * then the provided format list contains the corresponding hwaccel pixel
+   * formats alongside the "software" one. The software pixel format may also
+   * be retrieved from \ref sw_pix_fmt.
+   *
+   * This callback will be called when the coded frame properties (such as
+   * resolution, pixel format, etc.) change and more than one output format is
+   * supported for those new properties. If a hardware pixel format is chosen
+   * and initialization for it fails, the callback may be called again
+   * immediately.
+   *
+   * This callback may be called from different threads if the decoder is
+   * multi-threaded, but not from more than one thread simultaneously.
+   *
+   * @param fmt list of formats which may be used in the current
+   *            configuration, terminated by AV_PIX_FMT_NONE.
+   * @warning Behavior is undefined if the callback returns a value other
+   *          than one of the formats in fmt or AV_PIX_FMT_NONE.
+   * @return the chosen format or AV_PIX_FMT_NONE
+   */
+  enum AVPixelFormat (*get_format)(struct AVCodecContext* s,
+                                   const enum AVPixelFormat* fmt);
+
+  /**
+   * maximum number of B-frames between non-B-frames
+   * Note: The output will be delayed by max_b_frames+1 relative to the input.
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int max_b_frames;
+
+  /**
+   * qscale factor between IP and B-frames
+   * If > 0 then the last P-frame quantizer will be used (q=
+   * lastp_q*factor+offset). If < 0 then normal ratecontrol will be done (q=
+   * -normal_q*factor+offset).
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float b_quant_factor;
+
+  /**
+   * qscale offset between IP and B-frames
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float b_quant_offset;
+
+  /**
+   * Size of the frame reordering buffer in the decoder.
+   * For MPEG-2 it is 1 IPB or 0 low delay IP.
+   * - encoding: Set by libavcodec.
+   * - decoding: Set by libavcodec.
+   */
+  int has_b_frames;
+
+  /**
+   * qscale factor between P- and I-frames
+   * If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor +
+   * offset). If < 0 then normal ratecontrol will be done (q=
+   * -normal_q*factor+offset).
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float i_quant_factor;
+
+  /**
+   * qscale offset between P and I-frames
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float i_quant_offset;
+
+  /**
+   * luminance masking (0-> disabled)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float lumi_masking;
+
+  /**
+   * temporary complexity masking (0-> disabled)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float temporal_cplx_masking;
+
+  /**
+   * spatial complexity masking (0-> disabled)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float spatial_cplx_masking;
+
+  /**
+   * p block masking (0-> disabled)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float p_masking;
+
+  /**
+   * darkness masking (0-> disabled)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  float dark_masking;
+
+  /**
+   * slice count
+   * - encoding: Set by libavcodec.
+   * - decoding: Set by user (or 0).
+   */
+  int slice_count;
+
+  /**
+   * slice offsets in the frame in bytes
+   * - encoding: Set/allocated by libavcodec.
+   * - decoding: Set/allocated by user (or NULL).
+   */
+  int* slice_offset;
+
+  /**
+   * sample aspect ratio (0 if unknown)
+   * That is the width of a pixel divided by the height of the pixel.
+   * Numerator and denominator must be relatively prime and smaller than 256 for
+   * some video standards.
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  AVRational sample_aspect_ratio;
+
+  /**
+   * motion estimation comparison function
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int me_cmp;
+  /**
+   * subpixel motion estimation comparison function
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int me_sub_cmp;
+  /**
+   * macroblock comparison function (not supported yet)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int mb_cmp;
+  /**
+   * interlaced DCT comparison function
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int ildct_cmp;
+#define FF_CMP_SAD 0
+#define FF_CMP_SSE 1
+#define FF_CMP_SATD 2
+#define FF_CMP_DCT 3
+#define FF_CMP_PSNR 4
+#define FF_CMP_BIT 5
+#define FF_CMP_RD 6
+#define FF_CMP_ZERO 7
+#define FF_CMP_VSAD 8
+#define FF_CMP_VSSE 9
+#define FF_CMP_NSSE 10
+#define FF_CMP_W53 11
+#define FF_CMP_W97 12
+#define FF_CMP_DCTMAX 13
+#define FF_CMP_DCT264 14
+#define FF_CMP_MEDIAN_SAD 15
+#define FF_CMP_CHROMA 256
+
+  /**
+   * ME diamond size & shape
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int dia_size;
+
+  /**
+   * amount of previous MV predictors (2a+1 x 2a+1 square)
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int last_predictor_count;
+
+  /**
+   * motion estimation prepass comparison function
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int me_pre_cmp;
+
+  /**
+   * ME prepass diamond size & shape
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int pre_dia_size;
+
+  /**
+   * subpel ME quality
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int me_subpel_quality;
+
+  /**
+   * maximum motion estimation search range in subpel units
+   * If 0 then no limit.
+   *
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int me_range;
+
+  /**
+   * slice flags
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  int slice_flags;
+#define SLICE_FLAG_CODED_ORDER \
+  0x0001  ///< draw_horiz_band() is called in coded order instead of display
+#define SLICE_FLAG_ALLOW_FIELD \
+  0x0002  ///< allow draw_horiz_band() with field slices (MPEG-2 field pics)
+#define SLICE_FLAG_ALLOW_PLANE \
+  0x0004  ///< allow draw_horiz_band() with 1 component at a time (SVQ1)
+
+  /**
+   * macroblock decision mode
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int mb_decision;
+#define FF_MB_DECISION_SIMPLE 0  ///< uses mb_cmp
+#define FF_MB_DECISION_BITS 1  ///< chooses the one which needs the fewest bits
+#define FF_MB_DECISION_RD 2    ///< rate distortion
+
+  /**
+   * custom intra quantization matrix
+   * Must be allocated with the av_malloc() family of functions, and will be
+   * freed in avcodec_free_context().
+   * - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.
+   * - decoding: Set/allocated/freed by libavcodec.
+   */
+  uint16_t* intra_matrix;
+
+  /**
+   * custom inter quantization matrix
+   * Must be allocated with the av_malloc() family of functions, and will be
+   * freed in avcodec_free_context().
+   * - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.
+   * - decoding: Set/allocated/freed by libavcodec.
+   */
+  uint16_t* inter_matrix;
+
+  /**
+   * precision of the intra DC coefficient - 8
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec
+   */
+  int intra_dc_precision;
+
+  /**
+   * Number of macroblock rows at the top which are skipped.
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  int skip_top;
+
+  /**
+   * Number of macroblock rows at the bottom which are skipped.
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  int skip_bottom;
+
+  /**
+   * minimum MB Lagrange multiplier
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int mb_lmin;
+
+  /**
+   * maximum MB Lagrange multiplier
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int mb_lmax;
+
+  /**
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int bidir_refine;
+
+  /**
+   * minimum GOP size
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int keyint_min;
+
+  /**
+   * number of reference frames
+   * - encoding: Set by user.
+   * - decoding: Set by lavc.
+   */
+  int refs;
+
+  /**
+   * Note: Value depends upon the compare function used for fullpel ME.
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int mv0_threshold;
+
+  /**
+   * Chromaticity coordinates of the source primaries.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVColorPrimaries color_primaries;
+
+  /**
+   * Color Transfer Characteristic.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVColorTransferCharacteristic color_trc;
+
+  /**
+   * YUV colorspace type.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVColorSpace colorspace;
+
+  /**
+   * MPEG vs JPEG YUV range.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVColorRange color_range;
+
+  /**
+   * This defines the location of chroma samples.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVChromaLocation chroma_sample_location;
+
+  /**
+   * Number of slices.
+   * Indicates number of picture subdivisions. Used for parallelized
+   * decoding.
+   * - encoding: Set by user
+   * - decoding: unused
+   */
+  int slices;
+
+  /** Field order
+   * - encoding: set by libavcodec
+   * - decoding: Set by user.
+   */
+  enum AVFieldOrder field_order;
+
+  /* audio only */
+  int sample_rate;  ///< samples per second
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * number of audio channels
+   * @deprecated use ch_layout.nb_channels
+   */
+  attribute_deprecated int channels;
+#endif
+
+  /**
+   * audio sample format
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  enum AVSampleFormat sample_fmt;  ///< sample format
+
+  /* The following data should not be initialized. */
+  /**
+   * Number of samples per channel in an audio frame.
+   *
+   * - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
+   *   except the last must contain exactly frame_size samples per channel.
+   *   May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then
+   * the frame size is not restricted.
+   * - decoding: may be set by some decoders to indicate constant frame size
+   */
+  int frame_size;
+
+#if FF_API_AVCTX_FRAME_NUMBER
+  /**
+   * Frame counter, set by libavcodec.
+   *
+   * - decoding: total number of frames returned from the decoder so far.
+   * - encoding: total number of frames passed to the encoder so far.
+   *
+   *   @note the counter is not incremented if encoding/decoding resulted in
+   *   an error.
+   *   @deprecated use frame_num instead
+   */
+  attribute_deprecated int frame_number;
+#endif
+
+  /**
+   * number of bytes per packet if constant and known or 0
+   * Used by some WAV based audio codecs.
+   */
+  int block_align;
+
+  /**
+   * Audio cutoff bandwidth (0 means "automatic")
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int cutoff;
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * Audio channel layout.
+   * - encoding: set by user.
+   * - decoding: set by user, may be overwritten by libavcodec.
+   * @deprecated use ch_layout
+   */
+  attribute_deprecated uint64_t channel_layout;
+
+  /**
+   * Request decoder to use this channel layout if it can (0 for default)
+   * - encoding: unused
+   * - decoding: Set by user.
+   * @deprecated use "downmix" codec private option
+   */
+  attribute_deprecated uint64_t request_channel_layout;
+#endif
+
+  /**
+   * Type of service that the audio stream conveys.
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  enum AVAudioServiceType audio_service_type;
+
+  /**
+   * desired sample format
+   * - encoding: Not used.
+   * - decoding: Set by user.
+   * Decoder will decode to this format if it can.
+   */
+  enum AVSampleFormat request_sample_fmt;
+
+  /**
+   * This callback is called at the beginning of each frame to get data
+   * buffer(s) for it. There may be one contiguous buffer for all the data or
+   * there may be a buffer per each data plane or anything in between. What
+   * this means is, you may set however many entries in buf[] you feel
+   * necessary. Each buffer must be reference-counted using the AVBuffer API
+   * (see description of buf[] below).
+   *
+   * The following fields will be set in the frame before this callback is
+   * called:
+   * - format
+   * - width, height (video only)
+   * - sample_rate, channel_layout, nb_samples (audio only)
+   * Their values may differ from the corresponding values in
+   * AVCodecContext. This callback must use the frame values, not the codec
+   * context values, to calculate the required buffer size.
+   *
+   * This callback must fill the following fields in the frame:
+   * - data[]
+   * - linesize[]
+   * - extended_data:
+   *   * if the data is planar audio with more than 8 channels, then this
+   *     callback must allocate and fill extended_data to contain all pointers
+   *     to all data planes. data[] must hold as many pointers as it can.
+   *     extended_data must be allocated with av_malloc() and will be freed in
+   *     av_frame_unref().
+   *   * otherwise extended_data must point to data
+   * - buf[] must contain one or more pointers to AVBufferRef structures. Each
+   * of the frame's data and extended_data pointers must be contained in these.
+   * That is, one AVBufferRef for each allocated chunk of memory, not
+   * necessarily one AVBufferRef per data[] entry. See: av_buffer_create(),
+   * av_buffer_alloc(), and av_buffer_ref().
+   * - extended_buf and nb_extended_buf must be allocated with av_malloc() by
+   *   this callback and filled with the extra buffers if there are more
+   *   buffers than buf[] can hold. extended_buf will be freed in
+   *   av_frame_unref().
+   *
+   * If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
+   * avcodec_default_get_buffer2() instead of providing buffers allocated by
+   * some other means.
+   *
+   * Each data plane must be aligned to the maximum required by the target
+   * CPU.
+   *
+   * @see avcodec_default_get_buffer2()
+   *
+   * Video:
+   *
+   * If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
+   * (read and/or written to if it is writable) later by libavcodec.
+   *
+   * avcodec_align_dimensions2() should be used to find the required width and
+   * height, as they normally need to be rounded up to the next multiple of 16.
+   *
+   * Some decoders do not support linesizes changing between frames.
+   *
+   * If frame multithreading is used, this callback may be called from a
+   * different thread, but not from more than one at once. Does not need to be
+   * reentrant.
+   *
+   * @see avcodec_align_dimensions2()
+   *
+   * Audio:
+   *
+   * Decoders request a buffer of a particular size by setting
+   * AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
+   * however, utilize only part of the buffer by setting AVFrame.nb_samples
+   * to a smaller value in the output frame.
+   *
+   * As a convenience, av_samples_get_buffer_size() and
+   * av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
+   * functions to find the required data size and to fill data pointers and
+   * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
+   * since all planes must be the same size.
+   *
+   * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
+   *
+   * - encoding: unused
+   * - decoding: Set by libavcodec, user can override.
+   */
+  int (*get_buffer2)(struct AVCodecContext* s, AVFrame* frame, int flags);
+
+  /* - encoding parameters */
+  float qcompress;  ///< amount of qscale change between easy & hard scenes
+                    ///< (0.0-1.0)
+  float qblur;      ///< amount of qscale smoothing over time (0.0-1.0)
+
+  /**
+   * minimum quantizer
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int qmin;
+
+  /**
+   * maximum quantizer
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int qmax;
+
+  /**
+   * maximum quantizer difference between frames
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int max_qdiff;
+
+  /**
+   * decoder bitstream buffer size
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int rc_buffer_size;
+
+  /**
+   * ratecontrol override, see RcOverride
+   * - encoding: Allocated/set/freed by user.
+   * - decoding: unused
+   */
+  int rc_override_count;
+  RcOverride* rc_override;
+
+  /**
+   * maximum bitrate
+   * - encoding: Set by user.
+   * - decoding: Set by user, may be overwritten by libavcodec.
+   */
+  int64_t rc_max_rate;
+
+  /**
+   * minimum bitrate
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int64_t rc_min_rate;
+
+  /**
+   * Ratecontrol attempt to use, at maximum, <value> of what can be used without
+   * an underflow.
+   * - encoding: Set by user.
+   * - decoding: unused.
+   */
+  float rc_max_available_vbv_use;
+
+  /**
+   * Ratecontrol attempt to use, at least, <value> times the amount needed to
+   * prevent a vbv overflow.
+   * - encoding: Set by user.
+   * - decoding: unused.
+   */
+  float rc_min_vbv_overflow_use;
+
+  /**
+   * Number of bits which should be loaded into the rc buffer before decoding
+   * starts.
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int rc_initial_buffer_occupancy;
+
+  /**
+   * trellis RD quantization
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int trellis;
+
+  /**
+   * pass1 encoding statistics output buffer
+   * - encoding: Set by libavcodec.
+   * - decoding: unused
+   */
+  char* stats_out;
+
+  /**
+   * pass2 encoding statistics input buffer
+   * Concatenated stuff from stats_out of pass1 should be placed here.
+   * - encoding: Allocated/set/freed by user.
+   * - decoding: unused
+   */
+  char* stats_in;
+
+  /**
+   * Work around bugs in encoders which sometimes cannot be detected
+   * automatically.
+   * - encoding: Set by user
+   * - decoding: Set by user
+   */
+  int workaround_bugs;
+#define FF_BUG_AUTODETECT 1  ///< autodetection
+#define FF_BUG_XVID_ILACE 4
+#define FF_BUG_UMP4 8
+#define FF_BUG_NO_PADDING 16
+#define FF_BUG_AMV 32
+#define FF_BUG_QPEL_CHROMA 64
+#define FF_BUG_STD_QPEL 128
+#define FF_BUG_QPEL_CHROMA2 256
+#define FF_BUG_DIRECT_BLOCKSIZE 512
+#define FF_BUG_EDGE 1024
+#define FF_BUG_HPEL_CHROMA 2048
+#define FF_BUG_DC_CLIP 4096
+#define FF_BUG_MS \
+  8192  ///< Work around various bugs in Microsoft's broken decoders.
+#define FF_BUG_TRUNCATED 16384
+#define FF_BUG_IEDGE 32768
+
+  /**
+   * strictly follow the standard (MPEG-4, ...).
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   * Setting this to STRICT or higher means the encoder and decoder will
+   * generally do stupid things, whereas setting it to unofficial or lower
+   * will mean the encoder might produce output that is not supported by all
+   * spec-compliant decoders. Decoders don't differentiate between normal,
+   * unofficial and experimental (that is, they always try to decode things
+   * when they can) unless they are explicitly asked to behave stupidly
+   * (=strictly conform to the specs)
+   * This may only be set to one of the FF_COMPLIANCE_* values in defs.h.
+   */
+  int strict_std_compliance;
+
+  /**
+   * error concealment flags
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  int error_concealment;
+#define FF_EC_GUESS_MVS 1
+#define FF_EC_DEBLOCK 2
+#define FF_EC_FAVOR_INTER 256
+
+  /**
+   * debug
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  int debug;
+#define FF_DEBUG_PICT_INFO 1
+#define FF_DEBUG_RC 2
+#define FF_DEBUG_BITSTREAM 4
+#define FF_DEBUG_MB_TYPE 8
+#define FF_DEBUG_QP 16
+#define FF_DEBUG_DCT_COEFF 0x00000040
+#define FF_DEBUG_SKIP 0x00000080
+#define FF_DEBUG_STARTCODE 0x00000100
+#define FF_DEBUG_ER 0x00000400
+#define FF_DEBUG_MMCO 0x00000800
+#define FF_DEBUG_BUGS 0x00001000
+#define FF_DEBUG_BUFFERS 0x00008000
+#define FF_DEBUG_THREADS 0x00010000
+#define FF_DEBUG_GREEN_MD 0x00800000
+#define FF_DEBUG_NOMC 0x01000000
+
+  /**
+   * Error recognition; may misdetect some more or less valid parts as errors.
+   * This is a bitfield of the AV_EF_* values defined in defs.h.
+   *
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  int err_recognition;
+
+#if FF_API_REORDERED_OPAQUE
+  /**
+   * opaque 64-bit number (generally a PTS) that will be reordered and
+   * output in AVFrame.reordered_opaque
+   * - encoding: Set by libavcodec to the reordered_opaque of the input
+   *             frame corresponding to the last returned packet. Only
+   *             supported by encoders with the
+   *             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.
+   * - decoding: Set by user.
+   *
+   * @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead
+   */
+  attribute_deprecated int64_t reordered_opaque;
+#endif
+
+  /**
+   * Hardware accelerator in use
+   * - encoding: unused.
+   * - decoding: Set by libavcodec
+   */
+  const struct AVHWAccel* hwaccel;
+
+  /**
+   * Legacy hardware accelerator context.
+   *
+   * For some hardware acceleration methods, the caller may use this field to
+   * signal hwaccel-specific data to the codec. The struct pointed to by this
+   * pointer is hwaccel-dependent and defined in the respective header. Please
+   * refer to the FFmpeg HW accelerator documentation to know how to fill
+   * this.
+   *
+   * In most cases this field is optional - the necessary information may also
+   * be provided to libavcodec through @ref hw_frames_ctx or @ref
+   * hw_device_ctx (see avcodec_get_hw_config()). However, in some cases it
+   * may be the only method of signalling some (optional) information.
+   *
+   * The struct and its contents are owned by the caller.
+   *
+   * - encoding: May be set by the caller before avcodec_open2(). Must remain
+   *             valid until avcodec_free_context().
+   * - decoding: May be set by the caller in the get_format() callback.
+   *             Must remain valid until the next get_format() call,
+   *             or avcodec_free_context() (whichever comes first).
+   */
+  void* hwaccel_context;
+
+  /**
+   * error
+   * - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
+   * - decoding: unused
+   */
+  uint64_t error[AV_NUM_DATA_POINTERS];
+
+  /**
+   * DCT algorithm, see FF_DCT_* below
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int dct_algo;
+#define FF_DCT_AUTO 0
+#define FF_DCT_FASTINT 1
+#define FF_DCT_INT 2
+#define FF_DCT_MMX 3
+#define FF_DCT_ALTIVEC 5
+#define FF_DCT_FAAN 6
+
+  /**
+   * IDCT algorithm, see FF_IDCT_* below.
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  int idct_algo;
+#define FF_IDCT_AUTO 0
+#define FF_IDCT_INT 1
+#define FF_IDCT_SIMPLE 2
+#define FF_IDCT_SIMPLEMMX 3
+#define FF_IDCT_ARM 7
+#define FF_IDCT_ALTIVEC 8
+#define FF_IDCT_SIMPLEARM 10
+#define FF_IDCT_XVID 14
+#define FF_IDCT_SIMPLEARMV5TE 16
+#define FF_IDCT_SIMPLEARMV6 17
+#define FF_IDCT_FAAN 20
+#define FF_IDCT_SIMPLENEON 22
+#if FF_API_IDCT_NONE
+// formerly used by xvmc
+#  define FF_IDCT_NONE 24
+#endif
+#define FF_IDCT_SIMPLEAUTO 128
+
+  /**
+   * bits per sample/pixel from the demuxer (needed for huffyuv).
+   * - encoding: Set by libavcodec.
+   * - decoding: Set by user.
+   */
+  int bits_per_coded_sample;
+
+  /**
+   * Bits per sample/pixel of internal libavcodec pixel/sample format.
+   * - encoding: set by user.
+   * - decoding: set by libavcodec.
+   */
+  int bits_per_raw_sample;
+
+  /**
+   * low resolution decoding, 1-> 1/2 size, 2->1/4 size
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  int lowres;
+
+  /**
+   * thread count
+   * is used to decide how many independent tasks should be passed to execute()
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  int thread_count;
+
+  /**
+   * Which multithreading methods to use.
+   * Use of FF_THREAD_FRAME will increase decoding delay by one frame per
+   * thread, so clients which cannot provide future frames should not use it.
+   *
+   * - encoding: Set by user, otherwise the default is used.
+   * - decoding: Set by user, otherwise the default is used.
+   */
+  int thread_type;
+#define FF_THREAD_FRAME 1  ///< Decode more than one frame at once
+#define FF_THREAD_SLICE \
+  2  ///< Decode more than one part of a single frame at once
+
+  /**
+   * Which multithreading methods are in use by the codec.
+   * - encoding: Set by libavcodec.
+   * - decoding: Set by libavcodec.
+   */
+  int active_thread_type;
+
+  /**
+   * The codec may call this to execute several independent things.
+   * It will return only after finishing all tasks.
+   * The user may replace this with some multithreaded implementation,
+   * the default implementation will execute the parts serially.
+   * @param count the number of things to execute
+   * - encoding: Set by libavcodec, user can override.
+   * - decoding: Set by libavcodec, user can override.
+   */
+  int (*execute)(struct AVCodecContext* c,
+                 int (*func)(struct AVCodecContext* c2, void* arg), void* arg2,
+                 int* ret, int count, int size);
+
+  /**
+   * The codec may call this to execute several independent things.
+   * It will return only after finishing all tasks.
+   * The user may replace this with some multithreaded implementation,
+   * the default implementation will execute the parts serially.
+   * @param c context passed also to func
+   * @param count the number of things to execute
+   * @param arg2 argument passed unchanged to func
+   * @param ret return values of executed functions, must have space for "count"
+   * values. May be NULL.
+   * @param func function that will be called count times, with jobnr from 0 to
+   * count-1. threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS
+   * and so that no two instances of func executing at the same time will have
+   * the same threadnr.
+   * @return always 0 currently, but code should handle a future improvement
+   * where when any call to func returns < 0 no further calls to func may be
+   * done and < 0 is returned.
+   * - encoding: Set by libavcodec, user can override.
+   * - decoding: Set by libavcodec, user can override.
+   */
+  int (*execute2)(struct AVCodecContext* c,
+                  int (*func)(struct AVCodecContext* c2, void* arg, int jobnr,
+                              int threadnr),
+                  void* arg2, int* ret, int count);
+
+  /**
+   * noise vs. sse weight for the nsse comparison function
+   * - encoding: Set by user.
+   * - decoding: unused
+   */
+  int nsse_weight;
+
+  /**
+   * profile
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  int profile;
+#define FF_PROFILE_UNKNOWN -99
+#define FF_PROFILE_RESERVED -100
+
+#define FF_PROFILE_AAC_MAIN 0
+#define FF_PROFILE_AAC_LOW 1
+#define FF_PROFILE_AAC_SSR 2
+#define FF_PROFILE_AAC_LTP 3
+#define FF_PROFILE_AAC_HE 4
+#define FF_PROFILE_AAC_HE_V2 28
+#define FF_PROFILE_AAC_LD 22
+#define FF_PROFILE_AAC_ELD 38
+#define FF_PROFILE_MPEG2_AAC_LOW 128
+#define FF_PROFILE_MPEG2_AAC_HE 131
+
+#define FF_PROFILE_DNXHD 0
+#define FF_PROFILE_DNXHR_LB 1
+#define FF_PROFILE_DNXHR_SQ 2
+#define FF_PROFILE_DNXHR_HQ 3
+#define FF_PROFILE_DNXHR_HQX 4
+#define FF_PROFILE_DNXHR_444 5
+
+#define FF_PROFILE_DTS 20
+#define FF_PROFILE_DTS_ES 30
+#define FF_PROFILE_DTS_96_24 40
+#define FF_PROFILE_DTS_HD_HRA 50
+#define FF_PROFILE_DTS_HD_MA 60
+#define FF_PROFILE_DTS_EXPRESS 70
+
+#define FF_PROFILE_MPEG2_422 0
+#define FF_PROFILE_MPEG2_HIGH 1
+#define FF_PROFILE_MPEG2_SS 2
+#define FF_PROFILE_MPEG2_SNR_SCALABLE 3
+#define FF_PROFILE_MPEG2_MAIN 4
+#define FF_PROFILE_MPEG2_SIMPLE 5
+
+#define FF_PROFILE_H264_CONSTRAINED (1 << 9)  // 8+1; constraint_set1_flag
+#define FF_PROFILE_H264_INTRA (1 << 11)       // 8+3; constraint_set3_flag
+
+#define FF_PROFILE_H264_BASELINE 66
+#define FF_PROFILE_H264_CONSTRAINED_BASELINE (66 | FF_PROFILE_H264_CONSTRAINED)
+#define FF_PROFILE_H264_MAIN 77
+#define FF_PROFILE_H264_EXTENDED 88
+#define FF_PROFILE_H264_HIGH 100
+#define FF_PROFILE_H264_HIGH_10 110
+#define FF_PROFILE_H264_HIGH_10_INTRA (110 | FF_PROFILE_H264_INTRA)
+#define FF_PROFILE_H264_MULTIVIEW_HIGH 118
+#define FF_PROFILE_H264_HIGH_422 122
+#define FF_PROFILE_H264_HIGH_422_INTRA (122 | FF_PROFILE_H264_INTRA)
+#define FF_PROFILE_H264_STEREO_HIGH 128
+#define FF_PROFILE_H264_HIGH_444 144
+#define FF_PROFILE_H264_HIGH_444_PREDICTIVE 244
+#define FF_PROFILE_H264_HIGH_444_INTRA (244 | FF_PROFILE_H264_INTRA)
+#define FF_PROFILE_H264_CAVLC_444 44
+
+#define FF_PROFILE_VC1_SIMPLE 0
+#define FF_PROFILE_VC1_MAIN 1
+#define FF_PROFILE_VC1_COMPLEX 2
+#define FF_PROFILE_VC1_ADVANCED 3
+
+#define FF_PROFILE_MPEG4_SIMPLE 0
+#define FF_PROFILE_MPEG4_SIMPLE_SCALABLE 1
+#define FF_PROFILE_MPEG4_CORE 2
+#define FF_PROFILE_MPEG4_MAIN 3
+#define FF_PROFILE_MPEG4_N_BIT 4
+#define FF_PROFILE_MPEG4_SCALABLE_TEXTURE 5
+#define FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION 6
+#define FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE 7
+#define FF_PROFILE_MPEG4_HYBRID 8
+#define FF_PROFILE_MPEG4_ADVANCED_REAL_TIME 9
+#define FF_PROFILE_MPEG4_CORE_SCALABLE 10
+#define FF_PROFILE_MPEG4_ADVANCED_CODING 11
+#define FF_PROFILE_MPEG4_ADVANCED_CORE 12
+#define FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE 13
+#define FF_PROFILE_MPEG4_SIMPLE_STUDIO 14
+#define FF_PROFILE_MPEG4_ADVANCED_SIMPLE 15
+
+#define FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 1
+#define FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 2
+#define FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION 32768
+#define FF_PROFILE_JPEG2000_DCINEMA_2K 3
+#define FF_PROFILE_JPEG2000_DCINEMA_4K 4
+
+#define FF_PROFILE_VP9_0 0
+#define FF_PROFILE_VP9_1 1
+#define FF_PROFILE_VP9_2 2
+#define FF_PROFILE_VP9_3 3
+
+#define FF_PROFILE_HEVC_MAIN 1
+#define FF_PROFILE_HEVC_MAIN_10 2
+#define FF_PROFILE_HEVC_MAIN_STILL_PICTURE 3
+#define FF_PROFILE_HEVC_REXT 4
+#define FF_PROFILE_HEVC_SCC 9
+
+#define FF_PROFILE_VVC_MAIN_10 1
+#define FF_PROFILE_VVC_MAIN_10_444 33
+
+#define FF_PROFILE_AV1_MAIN 0
+#define FF_PROFILE_AV1_HIGH 1
+#define FF_PROFILE_AV1_PROFESSIONAL 2
+
+#define FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT 0xc0
+#define FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT 0xc1
+#define FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT 0xc2
+#define FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS 0xc3
+#define FF_PROFILE_MJPEG_JPEG_LS 0xf7
+
+#define FF_PROFILE_SBC_MSBC 1
+
+#define FF_PROFILE_PRORES_PROXY 0
+#define FF_PROFILE_PRORES_LT 1
+#define FF_PROFILE_PRORES_STANDARD 2
+#define FF_PROFILE_PRORES_HQ 3
+#define FF_PROFILE_PRORES_4444 4
+#define FF_PROFILE_PRORES_XQ 5
+
+#define FF_PROFILE_ARIB_PROFILE_A 0
+#define FF_PROFILE_ARIB_PROFILE_C 1
+
+#define FF_PROFILE_KLVA_SYNC 0
+#define FF_PROFILE_KLVA_ASYNC 1
+
+  /**
+   * level
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  int level;
+#define FF_LEVEL_UNKNOWN -99
+
+  /**
+   * Skip loop filtering for selected frames.
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  enum AVDiscard skip_loop_filter;
+
+  /**
+   * Skip IDCT/dequantization for selected frames.
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  enum AVDiscard skip_idct;
+
+  /**
+   * Skip decoding for selected frames.
+   * - encoding: unused
+   * - decoding: Set by user.
+   */
+  enum AVDiscard skip_frame;
+
+  /**
+   * Header containing style information for text subtitles.
+   * For SUBTITLE_ASS subtitle type, it should contain the whole ASS
+   * [Script Info] and [V4+ Styles] section, plus the [Events] line and
+   * the Format line following. It shouldn't include any Dialogue line.
+   * - encoding: Set/allocated/freed by user (before avcodec_open2())
+   * - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
+   */
+  uint8_t* subtitle_header;
+  int subtitle_header_size;
+
+  /**
+   * Audio only. The number of "priming" samples (padding) inserted by the
+   * encoder at the beginning of the audio. I.e. this number of leading
+   * decoded samples must be discarded by the caller to get the original audio
+   * without leading padding.
+   *
+   * - decoding: unused
+   * - encoding: Set by libavcodec. The timestamps on the output packets are
+   *             adjusted by the encoder so that they always refer to the
+   *             first sample of the data actually contained in the packet,
+   *             including any added padding.  E.g. if the timebase is
+   *             1/samplerate and the timestamp of the first input sample is
+   *             0, the timestamp of the first output packet will be
+   *             -initial_padding.
+   */
+  int initial_padding;
+
+  /**
+   * - decoding: For codecs that store a framerate value in the compressed
+   *             bitstream, the decoder may export it here. { 0, 1} when
+   *             unknown.
+   * - encoding: May be used to signal the framerate of CFR content to an
+   *             encoder.
+   */
+  AVRational framerate;
+
+  /**
+   * Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
+   * - encoding: unused.
+   * - decoding: Set by libavcodec before calling get_format()
+   */
+  enum AVPixelFormat sw_pix_fmt;
+
+  /**
+   * Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
+   * - encoding unused.
+   * - decoding set by user.
+   */
+  AVRational pkt_timebase;
+
+  /**
+   * AVCodecDescriptor
+   * - encoding: unused.
+   * - decoding: set by libavcodec.
+   */
+  const AVCodecDescriptor* codec_descriptor;
+
+  /**
+   * Current statistics for PTS correction.
+   * - decoding: maintained and used by libavcodec, not intended to be used by
+   * user apps
+   * - encoding: unused
+   */
+  int64_t
+      pts_correction_num_faulty_pts;  /// Number of incorrect PTS values so far
+  int64_t
+      pts_correction_num_faulty_dts;  /// Number of incorrect DTS values so far
+  int64_t pts_correction_last_pts;    /// PTS of the last frame
+  int64_t pts_correction_last_dts;    /// DTS of the last frame
+
+  /**
+   * Character encoding of the input subtitles file.
+   * - decoding: set by user
+   * - encoding: unused
+   */
+  char* sub_charenc;
+
+  /**
+   * Subtitles character encoding mode. Formats or codecs might be adjusting
+   * this setting (if they are doing the conversion themselves for instance).
+   * - decoding: set by libavcodec
+   * - encoding: unused
+   */
+  int sub_charenc_mode;
+#define FF_SUB_CHARENC_MODE_DO_NOTHING \
+  -1  ///< do nothing (demuxer outputs a stream supposed to be already in UTF-8,
+      ///< or the codec is bitmap for instance)
+#define FF_SUB_CHARENC_MODE_AUTOMATIC \
+  0  ///< libavcodec will select the mode itself
+#define FF_SUB_CHARENC_MODE_PRE_DECODER \
+  1  ///< the AVPacket data needs to be recoded to UTF-8 before being fed to the
+     ///< decoder, requires iconv
+#define FF_SUB_CHARENC_MODE_IGNORE \
+  2  ///< neither convert the subtitles, nor check them for valid UTF-8
+
+  /**
+   * Skip processing alpha if supported by codec.
+   * Note that if the format uses pre-multiplied alpha (common with VP6,
+   * and recommended due to better video quality/compression)
+   * the image will look as if alpha-blended onto a black background.
+   * However for formats that do not use pre-multiplied alpha
+   * there might be serious artefacts (though e.g. libswscale currently
+   * assumes pre-multiplied alpha anyway).
+   *
+   * - decoding: set by user
+   * - encoding: unused
+   */
+  int skip_alpha;
+
+  /**
+   * Number of samples to skip after a discontinuity
+   * - decoding: unused
+   * - encoding: set by libavcodec
+   */
+  int seek_preroll;
+
+  /**
+   * custom intra quantization matrix
+   * - encoding: Set by user, can be NULL.
+   * - decoding: unused.
+   */
+  uint16_t* chroma_intra_matrix;
+
+  /**
+   * dump format separator.
+   * can be ", " or "\n      " or anything else
+   * - encoding: Set by user.
+   * - decoding: Set by user.
+   */
+  uint8_t* dump_separator;
+
+  /**
+   * ',' separated list of allowed decoders.
+   * If NULL then all are allowed
+   * - encoding: unused
+   * - decoding: set by user
+   */
+  char* codec_whitelist;
+
+  /**
+   * Properties of the stream that gets decoded
+   * - encoding: unused
+   * - decoding: set by libavcodec
+   */
+  unsigned properties;
+#define FF_CODEC_PROPERTY_LOSSLESS 0x00000001
+#define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 0x00000002
+#define FF_CODEC_PROPERTY_FILM_GRAIN 0x00000004
+
+  /**
+   * Additional data associated with the entire coded stream.
+   *
+   * - decoding: unused
+   * - encoding: may be set by libavcodec after avcodec_open2().
+   */
+  AVPacketSideData* coded_side_data;
+  int nb_coded_side_data;
+
+  /**
+   * A reference to the AVHWFramesContext describing the input (for encoding)
+   * or output (decoding) frames. The reference is set by the caller and
+   * afterwards owned (and freed) by libavcodec - it should never be read by
+   * the caller after being set.
+   *
+   * - decoding: This field should be set by the caller from the get_format()
+   *             callback. The previous reference (if any) will always be
+   *             unreffed by libavcodec before the get_format() call.
+   *
+   *             If the default get_buffer2() is used with a hwaccel pixel
+   *             format, then this AVHWFramesContext will be used for
+   *             allocating the frame buffers.
+   *
+   * - encoding: For hardware encoders configured to use a hwaccel pixel
+   *             format, this field should be set by the caller to a reference
+   *             to the AVHWFramesContext describing input frames.
+   *             AVHWFramesContext.format must be equal to
+   *             AVCodecContext.pix_fmt.
+   *
+   *             This field should be set before avcodec_open2() is called.
+   */
+  AVBufferRef* hw_frames_ctx;
+
+  /**
+   * Audio only. The amount of padding (in samples) appended by the encoder to
+   * the end of the audio. I.e. this number of decoded samples must be
+   * discarded by the caller from the end of the stream to get the original
+   * audio without any trailing padding.
+   *
+   * - decoding: unused
+   * - encoding: unused
+   */
+  int trailing_padding;
+
+  /**
+   * The number of pixels per image to maximally accept.
+   *
+   * - decoding: set by user
+   * - encoding: set by user
+   */
+  int64_t max_pixels;
+
+  /**
+   * A reference to the AVHWDeviceContext describing the device which will
+   * be used by a hardware encoder/decoder.  The reference is set by the
+   * caller and afterwards owned (and freed) by libavcodec.
+   *
+   * This should be used if either the codec device does not require
+   * hardware frames or any that are used are to be allocated internally by
+   * libavcodec.  If the user wishes to supply any of the frames used as
+   * encoder input or decoder output then hw_frames_ctx should be used
+   * instead.  When hw_frames_ctx is set in get_format() for a decoder, this
+   * field will be ignored while decoding the associated stream segment, but
+   * may again be used on a following one after another get_format() call.
+   *
+   * For both encoders and decoders this field should be set before
+   * avcodec_open2() is called and must not be written to thereafter.
+   *
+   * Note that some decoders may require this field to be set initially in
+   * order to support hw_frames_ctx at all - in that case, all frames
+   * contexts used must be created on the same device.
+   */
+  AVBufferRef* hw_device_ctx;
+
+  /**
+   * Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
+   * decoding (if active).
+   * - encoding: unused
+   * - decoding: Set by user (either before avcodec_open2(), or in the
+   *             AVCodecContext.get_format callback)
+   */
+  int hwaccel_flags;
+
+  /**
+   * Video decoding only. Certain video codecs support cropping, meaning that
+   * only a sub-rectangle of the decoded frame is intended for display.  This
+   * option controls how cropping is handled by libavcodec.
+   *
+   * When set to 1 (the default), libavcodec will apply cropping internally.
+   * I.e. it will modify the output frame width/height fields and offset the
+   * data pointers (only by as much as possible while preserving alignment, or
+   * by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that
+   * the frames output by the decoder refer only to the cropped area. The
+   * crop_* fields of the output frames will be zero.
+   *
+   * When set to 0, the width/height fields of the output frames will be set
+   * to the coded dimensions and the crop_* fields will describe the cropping
+   * rectangle. Applying the cropping is left to the caller.
+   *
+   * @warning When hardware acceleration with opaque output frames is used,
+   * libavcodec is unable to apply cropping from the top/left border.
+   *
+   * @note when this option is set to zero, the width/height fields of the
+   * AVCodecContext and output AVFrames have different meanings. The codec
+   * context fields store display dimensions (with the coded dimensions in
+   * coded_width/height), while the frame fields store the coded dimensions
+   * (with the display dimensions being determined by the crop_* fields).
+   */
+  int apply_cropping;
+
+  /*
+   * Video decoding only.  Sets the number of extra hardware frames which
+   * the decoder will allocate for use by the caller.  This must be set
+   * before avcodec_open2() is called.
+   *
+   * Some hardware decoders require all frames that they will use for
+   * output to be defined in advance before decoding starts.  For such
+   * decoders, the hardware frame pool must therefore be of a fixed size.
+   * The extra frames set here are on top of any number that the decoder
+   * needs internally in order to operate normally (for example, frames
+   * used as reference pictures).
+   */
+  int extra_hw_frames;
+
+  /**
+   * The percentage of damaged samples to discard a frame.
+   *
+   * - decoding: set by user
+   * - encoding: unused
+   */
+  int discard_damaged_percentage;
+
+  /**
+   * The number of samples per frame to maximally accept.
+   *
+   * - decoding: set by user
+   * - encoding: set by user
+   */
+  int64_t max_samples;
+
+  /**
+   * Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of
+   * metadata exported in frame, packet, or coded stream side data by
+   * decoders and encoders.
+   *
+   * - decoding: set by user
+   * - encoding: set by user
+   */
+  int export_side_data;
+
+  /**
+   * This callback is called at the beginning of each packet to get a data
+   * buffer for it.
+   *
+   * The following field will be set in the packet before this callback is
+   * called:
+   * - size
+   * This callback must use the above value to calculate the required buffer
+   * size, which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes.
+   *
+   * In some specific cases, the encoder may not use the entire buffer allocated
+   * by this callback. This will be reflected in the size value in the packet
+   * once returned by avcodec_receive_packet().
+   *
+   * This callback must fill the following fields in the packet:
+   * - data: alignment requirements for AVPacket apply, if any. Some
+   * architectures and encoders may benefit from having aligned data.
+   * - buf: must contain a pointer to an AVBufferRef structure. The packet's
+   *   data pointer must be contained in it. See: av_buffer_create(),
+   * av_buffer_alloc(), and av_buffer_ref().
+   *
+   * If AV_CODEC_CAP_DR1 is not set then get_encode_buffer() must call
+   * avcodec_default_get_encode_buffer() instead of providing a buffer allocated
+   * by some other means.
+   *
+   * The flags field may contain a combination of AV_GET_ENCODE_BUFFER_FLAG_
+   * flags. They may be used for example to hint what use the buffer may get
+   * after being created. Implementations of this callback may ignore flags they
+   * don't understand. If AV_GET_ENCODE_BUFFER_FLAG_REF is set in flags then the
+   * packet may be reused (read and/or written to if it is writable) later by
+   * libavcodec.
+   *
+   * This callback must be thread-safe, as when frame threading is used, it may
+   * be called from multiple threads simultaneously.
+   *
+   * @see avcodec_default_get_encode_buffer()
+   *
+   * - encoding: Set by libavcodec, user can override.
+   * - decoding: unused
+   */
+  int (*get_encode_buffer)(struct AVCodecContext* s, AVPacket* pkt, int flags);
+
+  /**
+   * Audio channel layout.
+   * - encoding: must be set by the caller, to one of AVCodec.ch_layouts.
+   * - decoding: may be set by the caller if known e.g. from the container.
+   *             The decoder can then override during decoding as needed.
+   */
+  AVChannelLayout ch_layout;
+
+  /**
+   * Frame counter, set by libavcodec.
+   *
+   * - decoding: total number of frames returned from the decoder so far.
+   * - encoding: total number of frames passed to the encoder so far.
+   *
+   *   @note the counter is not incremented if encoding/decoding resulted in
+   *   an error.
+   */
+  int64_t frame_num;
+} AVCodecContext;
+
+/**
+ * @defgroup lavc_hwaccel AVHWAccel
+ *
+ * @note  Nothing in this structure should be accessed by the user.  At some
+ *        point in future it will not be externally visible at all.
+ *
+ * @{
+ */
+typedef struct AVHWAccel {
+  /**
+   * Name of the hardware accelerated codec.
+   * The name is globally unique among encoders and among decoders (but an
+   * encoder and a decoder can share the same name).
+   */
+  const char* name;
+
+  /**
+   * Type of codec implemented by the hardware accelerator.
+   *
+   * See AVMEDIA_TYPE_xxx
+   */
+  enum AVMediaType type;
+
+  /**
+   * Codec implemented by the hardware accelerator.
+   *
+   * See AV_CODEC_ID_xxx
+   */
+  enum AVCodecID id;
+
+  /**
+   * Supported pixel format.
+   *
+   * Only hardware accelerated formats are supported here.
+   */
+  enum AVPixelFormat pix_fmt;
+
+  /**
+   * Hardware accelerated codec capabilities.
+   * see AV_HWACCEL_CODEC_CAP_*
+   */
+  int capabilities;
+
+  /*****************************************************************
+   * No fields below this line are part of the public API. They
+   * may not be used outside of libavcodec and can be changed and
+   * removed at will.
+   * New public fields should be added right above.
+   *****************************************************************
+   */
+
+  /**
+   * Allocate a custom buffer
+   */
+  int (*alloc_frame)(AVCodecContext* avctx, AVFrame* frame);
+
+  /**
+   * Called at the beginning of each frame or field picture.
+   *
+   * Meaningful frame information (codec specific) is guaranteed to
+   * be parsed at this point. This function is mandatory.
+   *
+   * Note that buf can be NULL along with buf_size set to 0.
+   * Otherwise, this means the whole frame is available at this point.
+   *
+   * @param avctx the codec context
+   * @param buf the frame data buffer base
+   * @param buf_size the size of the frame in bytes
+   * @return zero if successful, a negative value otherwise
+   */
+  int (*start_frame)(AVCodecContext* avctx, const uint8_t* buf,
+                     uint32_t buf_size);
+
+  /**
+   * Callback for parameter data (SPS/PPS/VPS etc).
+   *
+   * Useful for hardware decoders which keep persistent state about the
+   * video parameters, and need to receive any changes to update that state.
+   *
+   * @param avctx the codec context
+   * @param type the nal unit type
+   * @param buf the nal unit data buffer
+   * @param buf_size the size of the nal unit in bytes
+   * @return zero if successful, a negative value otherwise
+   */
+  int (*decode_params)(AVCodecContext* avctx, int type, const uint8_t* buf,
+                       uint32_t buf_size);
+
+  /**
+   * Callback for each slice.
+   *
+   * Meaningful slice information (codec specific) is guaranteed to
+   * be parsed at this point. This function is mandatory.
+   *
+   * @param avctx the codec context
+   * @param buf the slice data buffer base
+   * @param buf_size the size of the slice in bytes
+   * @return zero if successful, a negative value otherwise
+   */
+  int (*decode_slice)(AVCodecContext* avctx, const uint8_t* buf,
+                      uint32_t buf_size);
+
+  /**
+   * Called at the end of each frame or field picture.
+   *
+   * The whole picture is parsed at this point and can now be sent
+   * to the hardware accelerator. This function is mandatory.
+   *
+   * @param avctx the codec context
+   * @return zero if successful, a negative value otherwise
+   */
+  int (*end_frame)(AVCodecContext* avctx);
+
+  /**
+   * Size of per-frame hardware accelerator private data.
+   *
+   * Private data is allocated with av_mallocz() before
+   * AVCodecContext.get_buffer() and deallocated after
+   * AVCodecContext.release_buffer().
+   */
+  int frame_priv_data_size;
+
+  /**
+   * Initialize the hwaccel private data.
+   *
+   * This will be called from ff_get_format(), after hwaccel and
+   * hwaccel_context are set and the hwaccel private data in AVCodecInternal
+   * is allocated.
+   */
+  int (*init)(AVCodecContext* avctx);
+
+  /**
+   * Uninitialize the hwaccel private data.
+   *
+   * This will be called from get_format() or avcodec_close(), after hwaccel
+   * and hwaccel_context are already uninitialized.
+   */
+  int (*uninit)(AVCodecContext* avctx);
+
+  /**
+   * Size of the private data to allocate in
+   * AVCodecInternal.hwaccel_priv_data.
+   */
+  int priv_data_size;
+
+  /**
+   * Internal hwaccel capabilities.
+   */
+  int caps_internal;
+
+  /**
+   * Fill the given hw_frames context with current codec parameters. Called
+   * from get_format. Refer to avcodec_get_hw_frames_parameters() for
+   * details.
+   *
+   * This CAN be called before AVHWAccel.init is called, and you must assume
+   * that avctx->hwaccel_priv_data is invalid.
+   */
+  int (*frame_params)(AVCodecContext* avctx, AVBufferRef* hw_frames_ctx);
+} AVHWAccel;
+
+/**
+ * HWAccel is experimental and is thus avoided in favor of non experimental
+ * codecs
+ */
+#define AV_HWACCEL_CODEC_CAP_EXPERIMENTAL 0x0200
+
+/**
+ * Hardware acceleration should be used for decoding even if the codec level
+ * used is unknown or higher than the maximum supported level reported by the
+ * hardware driver.
+ *
+ * It's generally a good idea to pass this flag unless you have a specific
+ * reason not to, as hardware tends to under-report supported levels.
+ */
+#define AV_HWACCEL_FLAG_IGNORE_LEVEL (1 << 0)
+
+/**
+ * Hardware acceleration can output YUV pixel formats with a different chroma
+ * sampling than 4:2:0 and/or other than 8 bits per component.
+ */
+#define AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH (1 << 1)
+
+/**
+ * Hardware acceleration should still be attempted for decoding when the
+ * codec profile does not match the reported capabilities of the hardware.
+ *
+ * For example, this can be used to try to decode baseline profile H.264
+ * streams in hardware - it will often succeed, because many streams marked
+ * as baseline profile actually conform to constrained baseline profile.
+ *
+ * @warning If the stream is actually not supported then the behaviour is
+ *          undefined, and may include returning entirely incorrect output
+ *          while indicating success.
+ */
+#define AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH (1 << 2)
+
+/**
+ * Some hardware decoders (namely nvdec) can either output direct decoder
+ * surfaces, or make an on-device copy and return said copy.
+ * There is a hard limit on how many decoder surfaces there can be, and it
+ * cannot be accurately guessed ahead of time.
+ * For some processing chains, this can be okay, but others will run into the
+ * limit and in turn produce very confusing errors that require fine tuning of
+ * more or less obscure options by the user, or in extreme cases cannot be
+ * resolved at all without inserting an avfilter that forces a copy.
+ *
+ * Thus, the hwaccel will by default make a copy for safety and resilience.
+ * If a users really wants to minimize the amount of copies, they can set this
+ * flag and ensure their processing chain does not exhaust the surface pool.
+ */
+#define AV_HWACCEL_FLAG_UNSAFE_OUTPUT (1 << 3)
+
+/**
+ * @}
+ */
+
+enum AVSubtitleType {
+  SUBTITLE_NONE,
+
+  SUBTITLE_BITMAP,  ///< A bitmap, pict will be set
+
+  /**
+   * Plain text, the text field must be set by the decoder and is
+   * authoritative. ass and pict fields may contain approximations.
+   */
+  SUBTITLE_TEXT,
+
+  /**
+   * Formatted text, the ass field must be set by the decoder and is
+   * authoritative. pict and text fields may contain approximations.
+   */
+  SUBTITLE_ASS,
+};
+
+#define AV_SUBTITLE_FLAG_FORCED 0x00000001
+
+typedef struct AVSubtitleRect {
+  int x;          ///< top left corner  of pict, undefined when pict is not set
+  int y;          ///< top left corner  of pict, undefined when pict is not set
+  int w;          ///< width            of pict, undefined when pict is not set
+  int h;          ///< height           of pict, undefined when pict is not set
+  int nb_colors;  ///< number of colors in pict, undefined when pict is not set
+
+  /**
+   * data+linesize for the bitmap of this subtitle.
+   * Can be set for text/ass as well once they are rendered.
+   */
+  uint8_t* data[4];
+  int linesize[4];
+
+  enum AVSubtitleType type;
+
+  char* text;  ///< 0 terminated plain UTF-8 text
+
+  /**
+   * 0 terminated ASS/SSA compatible event line.
+   * The presentation of this is unaffected by the other values in this
+   * struct.
+   */
+  char* ass;
+
+  int flags;
+} AVSubtitleRect;
+
+typedef struct AVSubtitle {
+  uint16_t format;             /* 0 = graphics */
+  uint32_t start_display_time; /* relative to packet pts, in ms */
+  uint32_t end_display_time;   /* relative to packet pts, in ms */
+  unsigned num_rects;
+  AVSubtitleRect** rects;
+  int64_t pts;  ///< Same as packet pts, in AV_TIME_BASE
+} AVSubtitle;
+
+/**
+ * Return the LIBAVCODEC_VERSION_INT constant.
+ */
+unsigned avcodec_version(void);
+
+/**
+ * Return the libavcodec build-time configuration.
+ */
+const char* avcodec_configuration(void);
+
+/**
+ * Return the libavcodec license.
+ */
+const char* avcodec_license(void);
+
+/**
+ * Allocate an AVCodecContext and set its fields to default values. The
+ * resulting struct should be freed with avcodec_free_context().
+ *
+ * @param codec if non-NULL, allocate private data and initialize defaults
+ *              for the given codec. It is illegal to then call avcodec_open2()
+ *              with a different codec.
+ *              If NULL, then the codec-specific defaults won't be initialized,
+ *              which may result in suboptimal default settings (this is
+ *              important mainly for encoders, e.g. libx264).
+ *
+ * @return An AVCodecContext filled with default values or NULL on failure.
+ */
+AVCodecContext* avcodec_alloc_context3(const AVCodec* codec);
+
+/**
+ * Free the codec context and everything associated with it and write NULL to
+ * the provided pointer.
+ */
+void avcodec_free_context(AVCodecContext** avctx);
+
+/**
+ * Get the AVClass for AVCodecContext. It can be used in combination with
+ * AV_OPT_SEARCH_FAKE_OBJ for examining options.
+ *
+ * @see av_opt_find().
+ */
+const AVClass* avcodec_get_class(void);
+
+/**
+ * Get the AVClass for AVSubtitleRect. It can be used in combination with
+ * AV_OPT_SEARCH_FAKE_OBJ for examining options.
+ *
+ * @see av_opt_find().
+ */
+const AVClass* avcodec_get_subtitle_rect_class(void);
+
+/**
+ * Fill the parameters struct based on the values from the supplied codec
+ * context. Any allocated fields in par are freed and replaced with duplicates
+ * of the corresponding fields in codec.
+ *
+ * @return >= 0 on success, a negative AVERROR code on failure
+ */
+int avcodec_parameters_from_context(AVCodecParameters* par,
+                                    const AVCodecContext* codec);
+
+/**
+ * Fill the codec context based on the values from the supplied codec
+ * parameters. Any allocated fields in codec that have a corresponding field in
+ * par are freed and replaced with duplicates of the corresponding field in par.
+ * Fields in codec that do not have a counterpart in par are not touched.
+ *
+ * @return >= 0 on success, a negative AVERROR code on failure.
+ */
+int avcodec_parameters_to_context(AVCodecContext* codec,
+                                  const AVCodecParameters* par);
+
+/**
+ * Initialize the AVCodecContext to use the given AVCodec. Prior to using this
+ * function the context has to be allocated with avcodec_alloc_context3().
+ *
+ * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
+ * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
+ * retrieving a codec.
+ *
+ * @note Always call this function before using decoding routines (such as
+ * @ref avcodec_receive_frame()).
+ *
+ * @code
+ * av_dict_set(&opts, "b", "2.5M", 0);
+ * codec = avcodec_find_decoder(AV_CODEC_ID_H264);
+ * if (!codec)
+ *     exit(1);
+ *
+ * context = avcodec_alloc_context3(codec);
+ *
+ * if (avcodec_open2(context, codec, opts) < 0)
+ *     exit(1);
+ * @endcode
+ *
+ * @param avctx The context to initialize.
+ * @param codec The codec to open this context for. If a non-NULL codec has been
+ *              previously passed to avcodec_alloc_context3() or
+ *              for this context, then this parameter MUST be either NULL or
+ *              equal to the previously passed codec.
+ * @param options A dictionary filled with AVCodecContext and codec-private
+ * options. On return this object will be filled with options that were not
+ * found.
+ *
+ * @return zero on success, a negative value on error
+ * @see avcodec_alloc_context3(), avcodec_find_decoder(),
+ * avcodec_find_encoder(), av_dict_set(), av_opt_find().
+ */
+int avcodec_open2(AVCodecContext* avctx, const AVCodec* codec,
+                  AVDictionary** options);
+
+/**
+ * Close a given AVCodecContext and free all the data associated with it
+ * (but not the AVCodecContext itself).
+ *
+ * Calling this function on an AVCodecContext that hasn't been opened will free
+ * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
+ * codec. Subsequent calls will do nothing.
+ *
+ * @note Do not use this function. Use avcodec_free_context() to destroy a
+ * codec context (either open or closed). Opening and closing a codec context
+ * multiple times is not supported anymore -- use multiple codec contexts
+ * instead.
+ */
+int avcodec_close(AVCodecContext* avctx);
+
+/**
+ * Free all allocated data in the given subtitle struct.
+ *
+ * @param sub AVSubtitle to free.
+ */
+void avsubtitle_free(AVSubtitle* sub);
+
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup lavc_decoding
+ * @{
+ */
+
+/**
+ * The default callback for AVCodecContext.get_buffer2(). It is made public so
+ * it can be called by custom get_buffer2() implementations for decoders without
+ * AV_CODEC_CAP_DR1 set.
+ */
+int avcodec_default_get_buffer2(AVCodecContext* s, AVFrame* frame, int flags);
+
+/**
+ * The default callback for AVCodecContext.get_encode_buffer(). It is made
+ * public so it can be called by custom get_encode_buffer() implementations for
+ * encoders without AV_CODEC_CAP_DR1 set.
+ */
+int avcodec_default_get_encode_buffer(AVCodecContext* s, AVPacket* pkt,
+                                      int flags);
+
+/**
+ * Modify width and height values so that they will result in a memory
+ * buffer that is acceptable for the codec if you do not use any horizontal
+ * padding.
+ *
+ * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
+ */
+void avcodec_align_dimensions(AVCodecContext* s, int* width, int* height);
+
+/**
+ * Modify width and height values so that they will result in a memory
+ * buffer that is acceptable for the codec if you also ensure that all
+ * line sizes are a multiple of the respective linesize_align[i].
+ *
+ * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
+ */
+void avcodec_align_dimensions2(AVCodecContext* s, int* width, int* height,
+                               int linesize_align[AV_NUM_DATA_POINTERS]);
+
+#ifdef FF_API_AVCODEC_CHROMA_POS
+/**
+ * Converts AVChromaLocation to swscale x/y chroma position.
+ *
+ * The positions represent the chroma (0,0) position in a coordinates system
+ * with luma (0,0) representing the origin and luma(1,1) representing 256,256
+ *
+ * @param xpos  horizontal chroma sample position
+ * @param ypos  vertical   chroma sample position
+ * @deprecated Use av_chroma_location_enum_to_pos() instead.
+ */
+attribute_deprecated int avcodec_enum_to_chroma_pos(int* xpos, int* ypos,
+                                                    enum AVChromaLocation pos);
+
+/**
+ * Converts swscale x/y chroma position to AVChromaLocation.
+ *
+ * The positions represent the chroma (0,0) position in a coordinates system
+ * with luma (0,0) representing the origin and luma(1,1) representing 256,256
+ *
+ * @param xpos  horizontal chroma sample position
+ * @param ypos  vertical   chroma sample position
+ * @deprecated Use av_chroma_location_pos_to_enum() instead.
+ */
+attribute_deprecated enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos,
+                                                                      int ypos);
+#endif
+
+/**
+ * Decode a subtitle message.
+ * Return a negative value on error, otherwise return the number of bytes used.
+ * If no subtitle could be decompressed, got_sub_ptr is zero.
+ * Otherwise, the subtitle is stored in *sub.
+ * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
+ * simplicity, because the performance difference is expected to be negligible
+ * and reusing a get_buffer written for video codecs would probably perform
+ * badly due to a potentially very different allocation pattern.
+ *
+ * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between
+ * input and output. This means that for some packets they will not immediately
+ * produce decoded output and need to be flushed at the end of decoding to get
+ * all the decoded data. Flushing is done by calling this function with packets
+ * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
+ * returning subtitles. It is safe to flush even those decoders that are not
+ * marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
+ *
+ * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
+ * before packets may be fed to the decoder.
+ *
+ * @param avctx the codec context
+ * @param[out] sub The preallocated AVSubtitle in which the decoded subtitle
+ * will be stored, must be freed with avsubtitle_free if *got_sub_ptr is set.
+ * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed,
+ * otherwise, it is nonzero.
+ * @param[in] avpkt The input AVPacket containing the input buffer.
+ */
+int avcodec_decode_subtitle2(AVCodecContext* avctx, AVSubtitle* sub,
+                             int* got_sub_ptr, const AVPacket* avpkt);
+
+/**
+ * Supply raw packet data as input to a decoder.
+ *
+ * Internally, this call will copy relevant AVCodecContext fields, which can
+ * influence decoding per-packet, and apply them when the packet is actually
+ * decoded. (For example AVCodecContext.skip_frame, which might direct the
+ * decoder to drop the frame contained by the packet sent with this function.)
+ *
+ * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
+ *          larger than the actual read bytes because some optimized bitstream
+ *          readers read 32 or 64 bits at once and could read over the end.
+ *
+ * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
+ *       before packets may be fed to the decoder.
+ *
+ * @param avctx codec context
+ * @param[in] avpkt The input AVPacket. Usually, this will be a single video
+ *                  frame, or several complete audio frames.
+ *                  Ownership of the packet remains with the caller, and the
+ *                  decoder will not write to the packet. The decoder may create
+ *                  a reference to the packet data (or copy it if the packet is
+ *                  not reference-counted).
+ *                  Unlike with older APIs, the packet is always fully consumed,
+ *                  and if it contains multiple frames (e.g. some audio codecs),
+ *                  will require you to call avcodec_receive_frame() multiple
+ *                  times afterwards before you can send a new packet.
+ *                  It can be NULL (or an AVPacket with data set to NULL and
+ *                  size set to 0); in this case, it is considered a flush
+ *                  packet, which signals the end of the stream. Sending the
+ *                  first flush packet will return success. Subsequent ones are
+ *                  unnecessary and will return AVERROR_EOF. If the decoder
+ *                  still has frames buffered, it will return them after sending
+ *                  a flush packet.
+ *
+ * @retval 0                 success
+ * @retval AVERROR(EAGAIN)   input is not accepted in the current state - user
+ *                           must read output with avcodec_receive_frame() (once
+ *                           all output is read, the packet should be resent,
+ *                           and the call will not fail with EAGAIN).
+ * @retval AVERROR_EOF       the decoder has been flushed, and no new packets
+ * can be sent to it (also returned if more than 1 flush packet is sent)
+ * @retval AVERROR(EINVAL)   codec not opened, it is an encoder, or requires
+ * flush
+ * @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
+ * @retval "another negative error code" legitimate decoding errors
+ */
+int avcodec_send_packet(AVCodecContext* avctx, const AVPacket* avpkt);
+
+/**
+ * Return decoded output data from a decoder or encoder (when the
+ * AV_CODEC_FLAG_RECON_FRAME flag is used).
+ *
+ * @param avctx codec context
+ * @param frame This will be set to a reference-counted video or audio
+ *              frame (depending on the decoder type) allocated by the
+ *              codec. Note that the function will always call
+ *              av_frame_unref(frame) before doing anything else.
+ *
+ * @retval 0                success, a frame was returned
+ * @retval AVERROR(EAGAIN)  output is not available in this state - user must
+ *                          try to send new input
+ * @retval AVERROR_EOF      the codec has been fully flushed, and there will be
+ *                          no more output frames
+ * @retval AVERROR(EINVAL)  codec not opened, or it is an encoder without the
+ *                          AV_CODEC_FLAG_RECON_FRAME flag enabled
+ * @retval AVERROR_INPUT_CHANGED current decoded frame has changed parameters
+ * with respect to first decoded frame. Applicable when flag
+ *                          AV_CODEC_FLAG_DROPCHANGED is set.
+ * @retval "other negative error code" legitimate decoding errors
+ */
+int avcodec_receive_frame(AVCodecContext* avctx, AVFrame* frame);
+
+/**
+ * Supply a raw video or audio frame to the encoder. Use
+ * avcodec_receive_packet() to retrieve buffered output packets.
+ *
+ * @param avctx     codec context
+ * @param[in] frame AVFrame containing the raw audio or video frame to be
+ * encoded. Ownership of the frame remains with the caller, and the encoder will
+ * not write to the frame. The encoder may create a reference to the frame data
+ * (or copy it if the frame is not reference-counted). It can be NULL, in which
+ * case it is considered a flush packet.  This signals the end of the stream. If
+ * the encoder still has packets buffered, it will return them after this call.
+ * Once flushing mode has been entered, additional flush packets are ignored,
+ * and sending frames will return AVERROR_EOF.
+ *
+ *                  For audio:
+ *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
+ *                  can have any number of samples.
+ *                  If it is not set, frame->nb_samples must be equal to
+ *                  avctx->frame_size for all frames except the last.
+ *                  The final frame may be smaller than avctx->frame_size.
+ * @retval 0                 success
+ * @retval AVERROR(EAGAIN)   input is not accepted in the current state - user
+ * must read output with avcodec_receive_packet() (once all output is read, the
+ * packet should be resent, and the call will not fail with EAGAIN).
+ * @retval AVERROR_EOF       the encoder has been flushed, and no new frames can
+ *                           be sent to it
+ * @retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires
+ * flush
+ * @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
+ * @retval "another negative error code" legitimate encoding errors
+ */
+int avcodec_send_frame(AVCodecContext* avctx, const AVFrame* frame);
+
+/**
+ * Read encoded data from the encoder.
+ *
+ * @param avctx codec context
+ * @param avpkt This will be set to a reference-counted packet allocated by the
+ *              encoder. Note that the function will always call
+ *              av_packet_unref(avpkt) before doing anything else.
+ * @retval 0               success
+ * @retval AVERROR(EAGAIN) output is not available in the current state - user
+ * must try to send input
+ * @retval AVERROR_EOF     the encoder has been fully flushed, and there will be
+ * no more output packets
+ * @retval AVERROR(EINVAL) codec not opened, or it is a decoder
+ * @retval "another negative error code" legitimate encoding errors
+ */
+int avcodec_receive_packet(AVCodecContext* avctx, AVPacket* avpkt);
+
+/**
+ * Create and return a AVHWFramesContext with values adequate for hardware
+ * decoding. This is meant to get called from the get_format callback, and is
+ * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
+ * This API is for decoding with certain hardware acceleration modes/APIs only.
+ *
+ * The returned AVHWFramesContext is not initialized. The caller must do this
+ * with av_hwframe_ctx_init().
+ *
+ * Calling this function is not a requirement, but makes it simpler to avoid
+ * codec or hardware API specific details when manually allocating frames.
+ *
+ * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
+ * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
+ * it unnecessary to call this function or having to care about
+ * AVHWFramesContext initialization at all.
+ *
+ * There are a number of requirements for calling this function:
+ *
+ * - It must be called from get_format with the same avctx parameter that was
+ *   passed to get_format. Calling it outside of get_format is not allowed, and
+ *   can trigger undefined behavior.
+ * - The function is not always supported (see description of return values).
+ *   Even if this function returns successfully, hwaccel initialization could
+ *   fail later. (The degree to which implementations check whether the stream
+ *   is actually supported varies. Some do this check only after the user's
+ *   get_format callback returns.)
+ * - The hw_pix_fmt must be one of the choices suggested by get_format. If the
+ *   user decides to use a AVHWFramesContext prepared with this API function,
+ *   the user must return the same hw_pix_fmt from get_format.
+ * - The device_ref passed to this function must support the given hw_pix_fmt.
+ * - After calling this API function, it is the user's responsibility to
+ *   initialize the AVHWFramesContext (returned by the out_frames_ref
+ * parameter), and to set AVCodecContext.hw_frames_ctx to it. If done, this must
+ * be done before returning from get_format (this is implied by the normal
+ *   AVCodecContext.hw_frames_ctx API rules).
+ * - The AVHWFramesContext parameters may change every time time get_format is
+ *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
+ *   you are inherently required to go through this process again on every
+ *   get_format call.
+ * - It is perfectly possible to call this function without actually using
+ *   the resulting AVHWFramesContext. One use-case might be trying to reuse a
+ *   previously initialized AVHWFramesContext, and calling this API function
+ *   only to test whether the required frame parameters have changed.
+ * - Fields that use dynamically allocated values of any kind must not be set
+ *   by the user unless setting them is explicitly allowed by the documentation.
+ *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
+ *   the new free callback must call the potentially set previous free callback.
+ *   This API call may set any dynamically allocated fields, including the free
+ *   callback.
+ *
+ * The function will set at least the following fields on AVHWFramesContext
+ * (potentially more, depending on hwaccel API):
+ *
+ * - All fields set by av_hwframe_ctx_alloc().
+ * - Set the format field to hw_pix_fmt.
+ * - Set the sw_format field to the most suited and most versatile format. (An
+ *   implication is that this will prefer generic formats over opaque formats
+ *   with arbitrary restrictions, if possible.)
+ * - Set the width/height fields to the coded frame size, rounded up to the
+ *   API-specific minimum alignment.
+ * - Only _if_ the hwaccel requires a pre-allocated pool: set the
+ * initial_pool_size field to the number of maximum reference surfaces possible
+ * with the codec, plus 1 surface for the user to work (meaning the user can
+ * safely reference at most 1 decoded surface at a time), plus additional
+ * buffering introduced by frame threading. If the hwaccel does not require
+ * pre-allocation, the field is left to 0, and the decoder will allocate new
+ * surfaces on demand during decoding.
+ * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
+ *   hardware API.
+ *
+ * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
+ * with basic frame parameters set.
+ *
+ * The function is stateless, and does not change the AVCodecContext or the
+ * device_ref AVHWDeviceContext.
+ *
+ * @param avctx The context which is currently calling get_format, and which
+ *              implicitly contains all state needed for filling the returned
+ *              AVHWFramesContext properly.
+ * @param device_ref A reference to the AVHWDeviceContext describing the device
+ *                   which will be used by the hardware decoder.
+ * @param hw_pix_fmt The hwaccel format you are going to return from get_format.
+ * @param out_frames_ref On success, set to a reference to an _uninitialized_
+ *                       AVHWFramesContext, created from the given device_ref.
+ *                       Fields will be set to values required for decoding.
+ *                       Not changed if an error is returned.
+ * @return zero on success, a negative value on error. The following error codes
+ *         have special semantics:
+ *      AVERROR(ENOENT): the decoder does not support this functionality. Setup
+ *                       is always manual, or it is a decoder which does not
+ *                       support setting AVCodecContext.hw_frames_ctx at all,
+ *                       or it is a software format.
+ *      AVERROR(EINVAL): it is known that hardware decoding is not supported for
+ *                       this configuration, or the device_ref is not supported
+ *                       for the hwaccel referenced by hw_pix_fmt.
+ */
+int avcodec_get_hw_frames_parameters(AVCodecContext* avctx,
+                                     AVBufferRef* device_ref,
+                                     enum AVPixelFormat hw_pix_fmt,
+                                     AVBufferRef** out_frames_ref);
+
+/**
+ * @defgroup lavc_parsing Frame parsing
+ * @{
+ */
+
+enum AVPictureStructure {
+  AV_PICTURE_STRUCTURE_UNKNOWN,       ///< unknown
+  AV_PICTURE_STRUCTURE_TOP_FIELD,     ///< coded as top field
+  AV_PICTURE_STRUCTURE_BOTTOM_FIELD,  ///< coded as bottom field
+  AV_PICTURE_STRUCTURE_FRAME,         ///< coded as frame
+};
+
+typedef struct AVCodecParserContext {
+  void* priv_data;
+  const struct AVCodecParser* parser;
+  int64_t frame_offset;      /* offset of the current frame */
+  int64_t cur_offset;        /* current offset
+                                (incremented by each av_parser_parse()) */
+  int64_t next_frame_offset; /* offset of the next frame */
+  /* video info */
+  int pict_type; /* XXX: Put it back in AVCodecContext. */
+  /**
+   * This field is used for proper frame duration computation in lavf.
+   * It signals, how much longer the frame duration of the current frame
+   * is compared to normal frame duration.
+   *
+   * frame_duration = (1 + repeat_pict) * time_base
+   *
+   * It is used by codecs like H.264 to display telecined material.
+   */
+  int repeat_pict; /* XXX: Put it back in AVCodecContext. */
+  int64_t pts;     /* pts of the current frame */
+  int64_t dts;     /* dts of the current frame */
+
+  /* private data */
+  int64_t last_pts;
+  int64_t last_dts;
+  int fetch_timestamp;
+
+#define AV_PARSER_PTS_NB 4
+  int cur_frame_start_index;
+  int64_t cur_frame_offset[AV_PARSER_PTS_NB];
+  int64_t cur_frame_pts[AV_PARSER_PTS_NB];
+  int64_t cur_frame_dts[AV_PARSER_PTS_NB];
+
+  int flags;
+#define PARSER_FLAG_COMPLETE_FRAMES 0x0001
+#define PARSER_FLAG_ONCE 0x0002
+/// Set if the parser has a valid file offset
+#define PARSER_FLAG_FETCHED_OFFSET 0x0004
+#define PARSER_FLAG_USE_CODEC_TS 0x1000
+
+  int64_t offset;  ///< byte offset from starting packet start
+  int64_t cur_frame_end[AV_PARSER_PTS_NB];
+
+  /**
+   * Set by parser to 1 for key frames and 0 for non-key frames.
+   * It is initialized to -1, so if the parser doesn't set this flag,
+   * old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
+   * will be used.
+   */
+  int key_frame;
+
+  // Timestamp generation support:
+  /**
+   * Synchronization point for start of timestamp generation.
+   *
+   * Set to >0 for sync point, 0 for no sync point and <0 for undefined
+   * (default).
+   *
+   * For example, this corresponds to presence of H.264 buffering period
+   * SEI message.
+   */
+  int dts_sync_point;
+
+  /**
+   * Offset of the current timestamp against last timestamp sync point in
+   * units of AVCodecContext.time_base.
+   *
+   * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
+   * contain a valid timestamp offset.
+   *
+   * Note that the timestamp of sync point has usually a nonzero
+   * dts_ref_dts_delta, which refers to the previous sync point. Offset of
+   * the next frame after timestamp sync point will be usually 1.
+   *
+   * For example, this corresponds to H.264 cpb_removal_delay.
+   */
+  int dts_ref_dts_delta;
+
+  /**
+   * Presentation delay of current frame in units of AVCodecContext.time_base.
+   *
+   * Set to INT_MIN when dts_sync_point unused. Otherwise, it must
+   * contain valid non-negative timestamp delta (presentation time of a frame
+   * must not lie in the past).
+   *
+   * This delay represents the difference between decoding and presentation
+   * time of the frame.
+   *
+   * For example, this corresponds to H.264 dpb_output_delay.
+   */
+  int pts_dts_delta;
+
+  /**
+   * Position of the packet in file.
+   *
+   * Analogous to cur_frame_pts/dts
+   */
+  int64_t cur_frame_pos[AV_PARSER_PTS_NB];
+
+  /**
+   * Byte position of currently parsed frame in stream.
+   */
+  int64_t pos;
+
+  /**
+   * Previous frame byte position.
+   */
+  int64_t last_pos;
+
+  /**
+   * Duration of the current frame.
+   * For audio, this is in units of 1 / AVCodecContext.sample_rate.
+   * For all other types, this is in units of AVCodecContext.time_base.
+   */
+  int duration;
+
+  enum AVFieldOrder field_order;
+
+  /**
+   * Indicate whether a picture is coded as a frame, top field or bottom field.
+   *
+   * For example, H.264 field_pic_flag equal to 0 corresponds to
+   * AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
+   * equal to 1 and bottom_field_flag equal to 0 corresponds to
+   * AV_PICTURE_STRUCTURE_TOP_FIELD.
+   */
+  enum AVPictureStructure picture_structure;
+
+  /**
+   * Picture number incremented in presentation or output order.
+   * This field may be reinitialized at the first picture of a new sequence.
+   *
+   * For example, this corresponds to H.264 PicOrderCnt.
+   */
+  int output_picture_number;
+
+  /**
+   * Dimensions of the decoded video intended for presentation.
+   */
+  int width;
+  int height;
+
+  /**
+   * Dimensions of the coded video.
+   */
+  int coded_width;
+  int coded_height;
+
+  /**
+   * The format of the coded data, corresponds to enum AVPixelFormat for video
+   * and for enum AVSampleFormat for audio.
+   *
+   * Note that a decoder can have considerable freedom in how exactly it
+   * decodes the data, so the format reported here might be different from the
+   * one returned by a decoder.
+   */
+  int format;
+} AVCodecParserContext;
+
+typedef struct AVCodecParser {
+  int codec_ids[7]; /* several codec IDs are permitted */
+  int priv_data_size;
+  int (*parser_init)(AVCodecParserContext* s);
+  /* This callback never returns an error, a negative value means that
+   * the frame start was in a previous packet. */
+  int (*parser_parse)(AVCodecParserContext* s, AVCodecContext* avctx,
+                      const uint8_t** poutbuf, int* poutbuf_size,
+                      const uint8_t* buf, int buf_size);
+  void (*parser_close)(AVCodecParserContext* s);
+  int (*split)(AVCodecContext* avctx, const uint8_t* buf, int buf_size);
+} AVCodecParser;
+
+/**
+ * Iterate over all registered codec parsers.
+ *
+ * @param opaque a pointer where libavcodec will store the iteration state. Must
+ *               point to NULL to start the iteration.
+ *
+ * @return the next registered codec parser or NULL when the iteration is
+ *         finished
+ */
+const AVCodecParser* av_parser_iterate(void** opaque);
+
+AVCodecParserContext* av_parser_init(int codec_id);
+
+/**
+ * Parse a packet.
+ *
+ * @param s             parser context.
+ * @param avctx         codec context.
+ * @param poutbuf       set to pointer to parsed buffer or NULL if not yet
+ finished.
+ * @param poutbuf_size  set to size of parsed buffer or zero if not yet
+ finished.
+ * @param buf           input buffer.
+ * @param buf_size      buffer size in bytes without the padding. I.e. the full
+ buffer size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE. To signal
+ EOF, this should be 0 (so that the last frame can be output).
+ * @param pts           input presentation timestamp.
+ * @param dts           input decoding timestamp.
+ * @param pos           input byte position in stream.
+ * @return the number of bytes of the input bitstream used.
+ *
+ * Example:
+ * @code
+ *   while(in_len){
+ *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
+ *                                        in_data, in_len,
+ *                                        pts, dts, pos);
+ *       in_data += len;
+ *       in_len  -= len;
+ *
+ *       if(size)
+ *          decode_frame(data, size);
+ *   }
+ * @endcode
+ */
+int av_parser_parse2(AVCodecParserContext* s, AVCodecContext* avctx,
+                     uint8_t** poutbuf, int* poutbuf_size, const uint8_t* buf,
+                     int buf_size, int64_t pts, int64_t dts, int64_t pos);
+
+void av_parser_close(AVCodecParserContext* s);
+
+/**
+ * @}
+ * @}
+ */
+
+/**
+ * @addtogroup lavc_encoding
+ * @{
+ */
+
+int avcodec_encode_subtitle(AVCodecContext* avctx, uint8_t* buf, int buf_size,
+                            const AVSubtitle* sub);
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lavc_misc Utility functions
+ * @ingroup libavc
+ *
+ * Miscellaneous utility functions related to both encoding and decoding
+ * (or neither).
+ * @{
+ */
+
+/**
+ * @defgroup lavc_misc_pixfmt Pixel formats
+ *
+ * Functions for working with pixel formats.
+ * @{
+ */
+
+/**
+ * Return a value representing the fourCC code associated to the
+ * pixel format pix_fmt, or 0 if no associated fourCC code can be
+ * found.
+ */
+unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt);
+
+/**
+ * Find the best pixel format to convert to given a certain source pixel
+ * format.  When converting from one pixel format to another, information loss
+ * may occur.  For example, when converting from RGB24 to GRAY, the color
+ * information will be lost. Similarly, other losses occur when converting from
+ * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches
+ * which of the given pixel formats should be used to suffer the least amount of
+ * loss. The pixel formats from which it chooses one, are determined by the
+ * pix_fmt_list parameter.
+ *
+ *
+ * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to
+ * choose from
+ * @param[in] src_pix_fmt source pixel format
+ * @param[in] has_alpha Whether the source pixel format alpha channel is used.
+ * @param[out] loss_ptr Combination of flags informing you what kind of losses
+ * will occur.
+ * @return The best pixel format to convert to or -1 if none was found.
+ */
+enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(
+    const enum AVPixelFormat* pix_fmt_list, enum AVPixelFormat src_pix_fmt,
+    int has_alpha, int* loss_ptr);
+
+enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext* s,
+                                              const enum AVPixelFormat* fmt);
+
+/**
+ * @}
+ */
+
+void avcodec_string(char* buf, int buf_size, AVCodecContext* enc, int encode);
+
+int avcodec_default_execute(AVCodecContext* c,
+                            int (*func)(AVCodecContext* c2, void* arg2),
+                            void* arg, int* ret, int count, int size);
+int avcodec_default_execute2(AVCodecContext* c,
+                             int (*func)(AVCodecContext* c2, void* arg2, int,
+                                         int),
+                             void* arg, int* ret, int count);
+// FIXME func typedef
+
+/**
+ * Fill AVFrame audio data and linesize pointers.
+ *
+ * The buffer buf must be a preallocated buffer with a size big enough
+ * to contain the specified samples amount. The filled AVFrame data
+ * pointers will point to this buffer.
+ *
+ * AVFrame extended_data channel pointers are allocated if necessary for
+ * planar audio.
+ *
+ * @param frame       the AVFrame
+ *                    frame->nb_samples must be set prior to calling the
+ *                    function. This function fills in frame->data,
+ *                    frame->extended_data, frame->linesize[0].
+ * @param nb_channels channel count
+ * @param sample_fmt  sample format
+ * @param buf         buffer to use for frame data
+ * @param buf_size    size of buffer
+ * @param align       plane size sample alignment (0 = default)
+ * @return            >=0 on success, negative error code on failure
+ * @todo return the size in bytes required to store the samples in
+ * case of success, at the next libavutil bump
+ */
+int avcodec_fill_audio_frame(AVFrame* frame, int nb_channels,
+                             enum AVSampleFormat sample_fmt, const uint8_t* buf,
+                             int buf_size, int align);
+
+/**
+ * Reset the internal codec state / flush internal buffers. Should be called
+ * e.g. when seeking or when switching to a different stream.
+ *
+ * @note for decoders, this function just releases any references the decoder
+ * might keep internally, but the caller's references remain valid.
+ *
+ * @note for encoders, this function will only do something if the encoder
+ * declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder
+ * will drain any remaining packets, and can then be re-used for a different
+ * stream (as opposed to sending a null frame which will leave the encoder
+ * in a permanent EOF state after draining). This can be desirable if the
+ * cost of tearing down and replacing the encoder instance is high.
+ */
+void avcodec_flush_buffers(AVCodecContext* avctx);
+
+/**
+ * Return audio frame duration.
+ *
+ * @param avctx        codec context
+ * @param frame_bytes  size of the frame, or 0 if unknown
+ * @return             frame duration, in samples, if known. 0 if not able to
+ *                     determine.
+ */
+int av_get_audio_frame_duration(AVCodecContext* avctx, int frame_bytes);
+
+/* memory */
+
+/**
+ * Same behaviour av_fast_malloc but the buffer has additional
+ * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
+ *
+ * In addition the whole buffer will initially and after resizes
+ * be 0-initialized so that no uninitialized data will ever appear.
+ */
+void av_fast_padded_malloc(void* ptr, unsigned int* size, size_t min_size);
+
+/**
+ * Same behaviour av_fast_padded_malloc except that buffer will always
+ * be 0-initialized after call.
+ */
+void av_fast_padded_mallocz(void* ptr, unsigned int* size, size_t min_size);
+
+/**
+ * @return a positive value if s is open (i.e. avcodec_open2() was called on it
+ * with no corresponding avcodec_close()), 0 otherwise.
+ */
+int avcodec_is_open(AVCodecContext* s);
+
+/**
+ * @}
+ */
+
+#endif /* AVCODEC_AVCODEC_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avdct.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avdct.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avdct.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avdct.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,85 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_AVDCT_H
+#define AVCODEC_AVDCT_H
+
+#include "libavutil/opt.h"
+
+/**
+ * AVDCT context.
+ * @note function pointers can be NULL if the specific features have been
+ *       disabled at build time.
+ */
+typedef struct AVDCT {
+  const AVClass* av_class;
+
+  void (*idct)(int16_t* block /* align 16 */);
+
+  /**
+   * IDCT input permutation.
+   * Several optimized IDCTs need a permutated input (relative to the
+   * normal order of the reference IDCT).
+   * This permutation must be performed before the idct_put/add.
+   * Note, normally this can be merged with the zigzag/alternate scan<br>
+   * An example to avoid confusion:
+   * - (->decode coeffs -> zigzag reorder -> dequant -> reference IDCT -> ...)
+   * - (x -> reference DCT -> reference IDCT -> x)
+   * - (x -> reference DCT -> simple_mmx_perm = idct_permutation
+   *    -> simple_idct_mmx -> x)
+   * - (-> decode coeffs -> zigzag reorder -> simple_mmx_perm -> dequant
+   *    -> simple_idct_mmx -> ...)
+   */
+  uint8_t idct_permutation[64];
+
+  void (*fdct)(int16_t* block /* align 16 */);
+
+  /**
+   * DCT algorithm.
+   * must use AVOptions to set this field.
+   */
+  int dct_algo;
+
+  /**
+   * IDCT algorithm.
+   * must use AVOptions to set this field.
+   */
+  int idct_algo;
+
+  void (*get_pixels)(int16_t* block /* align 16 */,
+                     const uint8_t* pixels /* align 8 */, ptrdiff_t line_size);
+
+  int bits_per_sample;
+
+  void (*get_pixels_unaligned)(int16_t* block /* align 16 */,
+                               const uint8_t* pixels, ptrdiff_t line_size);
+} AVDCT;
+
+/**
+ * Allocates a AVDCT context.
+ * This needs to be initialized with avcodec_dct_init() after optionally
+ * configuring it with AVOptions.
+ *
+ * To free it use av_free()
+ */
+AVDCT* avcodec_dct_alloc(void);
+int avcodec_dct_init(AVDCT*);
+
+const AVClass* avcodec_dct_get_class(void);
+
+#endif /* AVCODEC_AVDCT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avfft.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avfft.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avfft.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/avfft.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,119 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_AVFFT_H
+#define AVCODEC_AVFFT_H
+
+/**
+ * @file
+ * @ingroup lavc_fft
+ * FFT functions
+ */
+
+/**
+ * @defgroup lavc_fft FFT functions
+ * @ingroup lavc_misc
+ *
+ * @{
+ */
+
+typedef float FFTSample;
+
+typedef struct FFTComplex {
+  FFTSample re, im;
+} FFTComplex;
+
+typedef struct FFTContext FFTContext;
+
+/**
+ * Set up a complex FFT.
+ * @param nbits           log2 of the length of the input array
+ * @param inverse         if 0 perform the forward transform, if 1 perform the
+ * inverse
+ */
+FFTContext* av_fft_init(int nbits, int inverse);
+
+/**
+ * Do the permutation needed BEFORE calling ff_fft_calc().
+ */
+void av_fft_permute(FFTContext* s, FFTComplex* z);
+
+/**
+ * Do a complex FFT with the parameters defined in av_fft_init(). The
+ * input data must be permuted before. No 1.0/sqrt(n) normalization is done.
+ */
+void av_fft_calc(FFTContext* s, FFTComplex* z);
+
+void av_fft_end(FFTContext* s);
+
+FFTContext* av_mdct_init(int nbits, int inverse, double scale);
+void av_imdct_calc(FFTContext* s, FFTSample* output, const FFTSample* input);
+void av_imdct_half(FFTContext* s, FFTSample* output, const FFTSample* input);
+void av_mdct_calc(FFTContext* s, FFTSample* output, const FFTSample* input);
+void av_mdct_end(FFTContext* s);
+
+/* Real Discrete Fourier Transform */
+
+enum RDFTransformType {
+  DFT_R2C,
+  IDFT_C2R,
+  IDFT_R2C,
+  DFT_C2R,
+};
+
+typedef struct RDFTContext RDFTContext;
+
+/**
+ * Set up a real FFT.
+ * @param nbits           log2 of the length of the input array
+ * @param trans           the type of transform
+ */
+RDFTContext* av_rdft_init(int nbits, enum RDFTransformType trans);
+void av_rdft_calc(RDFTContext* s, FFTSample* data);
+void av_rdft_end(RDFTContext* s);
+
+/* Discrete Cosine Transform */
+
+typedef struct DCTContext DCTContext;
+
+enum DCTTransformType {
+  DCT_II = 0,
+  DCT_III,
+  DCT_I,
+  DST_I,
+};
+
+/**
+ * Set up DCT.
+ *
+ * @param nbits           size of the input array:
+ *                        (1 << nbits)     for DCT-II, DCT-III and DST-I
+ *                        (1 << nbits) + 1 for DCT-I
+ * @param type            the type of transform
+ *
+ * @note the first element of the input of DST-I is ignored
+ */
+DCTContext* av_dct_init(int nbits, enum DCTTransformType type);
+void av_dct_calc(DCTContext* s, FFTSample* data);
+void av_dct_end(DCTContext* s);
+
+/**
+ * @}
+ */
+
+#endif /* AVCODEC_AVFFT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/bsf.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/bsf.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/bsf.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/bsf.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,335 @@
+/*
+ * Bitstream filters public API
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_BSF_H
+#define AVCODEC_BSF_H
+
+#include "libavutil/dict.h"
+#include "libavutil/log.h"
+#include "libavutil/rational.h"
+
+#include "codec_id.h"
+#include "codec_par.h"
+#include "packet.h"
+
+/**
+ * @defgroup lavc_bsf Bitstream filters
+ * @ingroup libavc
+ *
+ * Bitstream filters transform encoded media data without decoding it. This
+ * allows e.g. manipulating various header values. Bitstream filters operate on
+ * @ref AVPacket "AVPackets".
+ *
+ * The bitstream filtering API is centered around two structures:
+ * AVBitStreamFilter and AVBSFContext. The former represents a bitstream filter
+ * in abstract, the latter a specific filtering process. Obtain an
+ * AVBitStreamFilter using av_bsf_get_by_name() or av_bsf_iterate(), then pass
+ * it to av_bsf_alloc() to create an AVBSFContext. Fill in the user-settable
+ * AVBSFContext fields, as described in its documentation, then call
+ * av_bsf_init() to prepare the filter context for use.
+ *
+ * Submit packets for filtering using av_bsf_send_packet(), obtain filtered
+ * results with av_bsf_receive_packet(). When no more input packets will be
+ * sent, submit a NULL AVPacket to signal the end of the stream to the filter.
+ * av_bsf_receive_packet() will then return trailing packets, if any are
+ * produced by the filter.
+ *
+ * Finally, free the filter context with av_bsf_free().
+ * @{
+ */
+
+/**
+ * The bitstream filter state.
+ *
+ * This struct must be allocated with av_bsf_alloc() and freed with
+ * av_bsf_free().
+ *
+ * The fields in the struct will only be changed (by the caller or by the
+ * filter) as described in their documentation, and are to be considered
+ * immutable otherwise.
+ */
+typedef struct AVBSFContext {
+  /**
+   * A class for logging and AVOptions
+   */
+  const AVClass* av_class;
+
+  /**
+   * The bitstream filter this context is an instance of.
+   */
+  const struct AVBitStreamFilter* filter;
+
+  /**
+   * Opaque filter-specific private data. If filter->priv_class is non-NULL,
+   * this is an AVOptions-enabled struct.
+   */
+  void* priv_data;
+
+  /**
+   * Parameters of the input stream. This field is allocated in
+   * av_bsf_alloc(), it needs to be filled by the caller before
+   * av_bsf_init().
+   */
+  AVCodecParameters* par_in;
+
+  /**
+   * Parameters of the output stream. This field is allocated in
+   * av_bsf_alloc(), it is set by the filter in av_bsf_init().
+   */
+  AVCodecParameters* par_out;
+
+  /**
+   * The timebase used for the timestamps of the input packets. Set by the
+   * caller before av_bsf_init().
+   */
+  AVRational time_base_in;
+
+  /**
+   * The timebase used for the timestamps of the output packets. Set by the
+   * filter in av_bsf_init().
+   */
+  AVRational time_base_out;
+} AVBSFContext;
+
+typedef struct AVBitStreamFilter {
+  const char* name;
+
+  /**
+   * A list of codec ids supported by the filter, terminated by
+   * AV_CODEC_ID_NONE.
+   * May be NULL, in that case the bitstream filter works with any codec id.
+   */
+  const enum AVCodecID* codec_ids;
+
+  /**
+   * A class for the private data, used to declare bitstream filter private
+   * AVOptions. This field is NULL for bitstream filters that do not declare
+   * any options.
+   *
+   * If this field is non-NULL, the first member of the filter private data
+   * must be a pointer to AVClass, which will be set by libavcodec generic
+   * code to this class.
+   */
+  const AVClass* priv_class;
+} AVBitStreamFilter;
+
+/**
+ * @return a bitstream filter with the specified name or NULL if no such
+ *         bitstream filter exists.
+ */
+const AVBitStreamFilter* av_bsf_get_by_name(const char* name);
+
+/**
+ * Iterate over all registered bitstream filters.
+ *
+ * @param opaque a pointer where libavcodec will store the iteration state. Must
+ *               point to NULL to start the iteration.
+ *
+ * @return the next registered bitstream filter or NULL when the iteration is
+ *         finished
+ */
+const AVBitStreamFilter* av_bsf_iterate(void** opaque);
+
+/**
+ * Allocate a context for a given bitstream filter. The caller must fill in the
+ * context parameters as described in the documentation and then call
+ * av_bsf_init() before sending any data to the filter.
+ *
+ * @param filter the filter for which to allocate an instance.
+ * @param[out] ctx a pointer into which the pointer to the newly-allocated
+ * context will be written. It must be freed with av_bsf_free() after the
+ *                 filtering is done.
+ *
+ * @return 0 on success, a negative AVERROR code on failure
+ */
+int av_bsf_alloc(const AVBitStreamFilter* filter, AVBSFContext** ctx);
+
+/**
+ * Prepare the filter for use, after all the parameters and options have been
+ * set.
+ *
+ * @param ctx a AVBSFContext previously allocated with av_bsf_alloc()
+ */
+int av_bsf_init(AVBSFContext* ctx);
+
+/**
+ * Submit a packet for filtering.
+ *
+ * After sending each packet, the filter must be completely drained by calling
+ * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
+ * AVERROR_EOF.
+ *
+ * @param ctx an initialized AVBSFContext
+ * @param pkt the packet to filter. The bitstream filter will take ownership of
+ * the packet and reset the contents of pkt. pkt is not touched if an error
+ * occurs. If pkt is empty (i.e. NULL, or pkt->data is NULL and
+ * pkt->side_data_elems zero), it signals the end of the stream (i.e. no more
+ * non-empty packets will be sent; sending more empty packets does nothing) and
+ * will cause the filter to output any packets it may have buffered internally.
+ *
+ * @return
+ *  - 0 on success.
+ *  - AVERROR(EAGAIN) if packets need to be retrieved from the filter (using
+ *    av_bsf_receive_packet()) before new input can be consumed.
+ *  - Another negative AVERROR value if an error occurs.
+ */
+int av_bsf_send_packet(AVBSFContext* ctx, AVPacket* pkt);
+
+/**
+ * Retrieve a filtered packet.
+ *
+ * @param ctx an initialized AVBSFContext
+ * @param[out] pkt this struct will be filled with the contents of the filtered
+ *                 packet. It is owned by the caller and must be freed using
+ *                 av_packet_unref() when it is no longer needed.
+ *                 This parameter should be "clean" (i.e. freshly allocated
+ *                 with av_packet_alloc() or unreffed with av_packet_unref())
+ *                 when this function is called. If this function returns
+ *                 successfully, the contents of pkt will be completely
+ *                 overwritten by the returned data. On failure, pkt is not
+ *                 touched.
+ *
+ * @return
+ *  - 0 on success.
+ *  - AVERROR(EAGAIN) if more packets need to be sent to the filter (using
+ *    av_bsf_send_packet()) to get more output.
+ *  - AVERROR_EOF if there will be no further output from the filter.
+ *  - Another negative AVERROR value if an error occurs.
+ *
+ * @note one input packet may result in several output packets, so after sending
+ * a packet with av_bsf_send_packet(), this function needs to be called
+ * repeatedly until it stops returning 0. It is also possible for a filter to
+ * output fewer packets than were sent to it, so this function may return
+ * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
+ */
+int av_bsf_receive_packet(AVBSFContext* ctx, AVPacket* pkt);
+
+/**
+ * Reset the internal bitstream filter state. Should be called e.g. when
+ * seeking.
+ */
+void av_bsf_flush(AVBSFContext* ctx);
+
+/**
+ * Free a bitstream filter context and everything associated with it; write NULL
+ * into the supplied pointer.
+ */
+void av_bsf_free(AVBSFContext** ctx);
+
+/**
+ * Get the AVClass for AVBSFContext. It can be used in combination with
+ * AV_OPT_SEARCH_FAKE_OBJ for examining options.
+ *
+ * @see av_opt_find().
+ */
+const AVClass* av_bsf_get_class(void);
+
+/**
+ * Structure for chain/list of bitstream filters.
+ * Empty list can be allocated by av_bsf_list_alloc().
+ */
+typedef struct AVBSFList AVBSFList;
+
+/**
+ * Allocate empty list of bitstream filters.
+ * The list must be later freed by av_bsf_list_free()
+ * or finalized by av_bsf_list_finalize().
+ *
+ * @return Pointer to @ref AVBSFList on success, NULL in case of failure
+ */
+AVBSFList* av_bsf_list_alloc(void);
+
+/**
+ * Free list of bitstream filters.
+ *
+ * @param lst Pointer to pointer returned by av_bsf_list_alloc()
+ */
+void av_bsf_list_free(AVBSFList** lst);
+
+/**
+ * Append bitstream filter to the list of bitstream filters.
+ *
+ * @param lst List to append to
+ * @param bsf Filter context to be appended
+ *
+ * @return >=0 on success, negative AVERROR in case of failure
+ */
+int av_bsf_list_append(AVBSFList* lst, AVBSFContext* bsf);
+
+/**
+ * Construct new bitstream filter context given it's name and options
+ * and append it to the list of bitstream filters.
+ *
+ * @param lst      List to append to
+ * @param bsf_name Name of the bitstream filter
+ * @param options  Options for the bitstream filter, can be set to NULL
+ *
+ * @return >=0 on success, negative AVERROR in case of failure
+ */
+int av_bsf_list_append2(AVBSFList* lst, const char* bsf_name,
+                        AVDictionary** options);
+/**
+ * Finalize list of bitstream filters.
+ *
+ * This function will transform @ref AVBSFList to single @ref AVBSFContext,
+ * so the whole chain of bitstream filters can be treated as single filter
+ * freshly allocated by av_bsf_alloc().
+ * If the call is successful, @ref AVBSFList structure is freed and lst
+ * will be set to NULL. In case of failure, caller is responsible for
+ * freeing the structure by av_bsf_list_free()
+ *
+ * @param      lst Filter list structure to be transformed
+ * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext
+ * structure representing the chain of bitstream filters
+ *
+ * @return >=0 on success, negative AVERROR in case of failure
+ */
+int av_bsf_list_finalize(AVBSFList** lst, AVBSFContext** bsf);
+
+/**
+ * Parse string describing list of bitstream filters and create single
+ * @ref AVBSFContext describing the whole chain of bitstream filters.
+ * Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext
+ * freshly allocated by av_bsf_alloc().
+ *
+ * @param      str String describing chain of bitstream filters in format
+ *                 `bsf1[=opt1=val1:opt2=val2][,bsf2]`
+ * @param[out] bsf Pointer to be set to newly created @ref AVBSFContext
+ * structure representing the chain of bitstream filters
+ *
+ * @return >=0 on success, negative AVERROR in case of failure
+ */
+int av_bsf_list_parse_str(const char* str, AVBSFContext** bsf);
+
+/**
+ * Get null/pass-through bitstream filter.
+ *
+ * @param[out] bsf Pointer to be set to new instance of pass-through bitstream
+ * filter
+ *
+ * @return
+ */
+int av_bsf_get_null_filter(AVBSFContext** bsf);
+
+/**
+ * @}
+ */
+
+#endif  // AVCODEC_BSF_H
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_desc.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_desc.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_desc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_desc.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,128 @@
+/*
+ * Codec descriptors public API
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_CODEC_DESC_H
+#define AVCODEC_CODEC_DESC_H
+
+#include "libavutil/avutil.h"
+
+#include "codec_id.h"
+
+/**
+ * @addtogroup lavc_core
+ * @{
+ */
+
+/**
+ * This struct describes the properties of a single codec described by an
+ * AVCodecID.
+ * @see avcodec_descriptor_get()
+ */
+typedef struct AVCodecDescriptor {
+  enum AVCodecID id;
+  enum AVMediaType type;
+  /**
+   * Name of the codec described by this descriptor. It is non-empty and
+   * unique for each codec descriptor. It should contain alphanumeric
+   * characters and '_' only.
+   */
+  const char* name;
+  /**
+   * A more descriptive name for this codec. May be NULL.
+   */
+  const char* long_name;
+  /**
+   * Codec properties, a combination of AV_CODEC_PROP_* flags.
+   */
+  int props;
+  /**
+   * MIME type(s) associated with the codec.
+   * May be NULL; if not, a NULL-terminated array of MIME types.
+   * The first item is always non-NULL and is the preferred MIME type.
+   */
+  const char* const* mime_types;
+  /**
+   * If non-NULL, an array of profiles recognized for this codec.
+   * Terminated with FF_PROFILE_UNKNOWN.
+   */
+  const struct AVProfile* profiles;
+} AVCodecDescriptor;
+
+/**
+ * Codec uses only intra compression.
+ * Video and audio codecs only.
+ */
+#define AV_CODEC_PROP_INTRA_ONLY (1 << 0)
+/**
+ * Codec supports lossy compression. Audio and video codecs only.
+ * @note a codec may support both lossy and lossless
+ * compression modes
+ */
+#define AV_CODEC_PROP_LOSSY (1 << 1)
+/**
+ * Codec supports lossless compression. Audio and video codecs only.
+ */
+#define AV_CODEC_PROP_LOSSLESS (1 << 2)
+/**
+ * Codec supports frame reordering. That is, the coded order (the order in which
+ * the encoded packets are output by the encoders / stored / input to the
+ * decoders) may be different from the presentation order of the corresponding
+ * frames.
+ *
+ * For codecs that do not have this property set, PTS and DTS should always be
+ * equal.
+ */
+#define AV_CODEC_PROP_REORDER (1 << 3)
+/**
+ * Subtitle codec is bitmap based
+ * Decoded AVSubtitle data can be read from the AVSubtitleRect->pict field.
+ */
+#define AV_CODEC_PROP_BITMAP_SUB (1 << 16)
+/**
+ * Subtitle codec is text based.
+ * Decoded AVSubtitle data can be read from the AVSubtitleRect->ass field.
+ */
+#define AV_CODEC_PROP_TEXT_SUB (1 << 17)
+
+/**
+ * @return descriptor for given codec ID or NULL if no descriptor exists.
+ */
+const AVCodecDescriptor* avcodec_descriptor_get(enum AVCodecID id);
+
+/**
+ * Iterate over all codec descriptors known to libavcodec.
+ *
+ * @param prev previous descriptor. NULL to get the first descriptor.
+ *
+ * @return next descriptor or NULL after the last descriptor
+ */
+const AVCodecDescriptor* avcodec_descriptor_next(const AVCodecDescriptor* prev);
+
+/**
+ * @return codec descriptor with the given name or NULL if no such descriptor
+ *         exists.
+ */
+const AVCodecDescriptor* avcodec_descriptor_get_by_name(const char* name);
+
+/**
+ * @}
+ */
+
+#endif  // AVCODEC_CODEC_DESC_H
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,387 @@
+/*
+ * AVCodec public API
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_CODEC_H
+#define AVCODEC_CODEC_H
+
+#include <stdint.h>
+
+#include "libavutil/avutil.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/log.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/rational.h"
+#include "libavutil/samplefmt.h"
+
+#include "libavcodec/codec_id.h"
+#include "libavcodec/version_major.h"
+
+/**
+ * @addtogroup lavc_core
+ * @{
+ */
+
+/**
+ * Decoder can use draw_horiz_band callback.
+ */
+#define AV_CODEC_CAP_DRAW_HORIZ_BAND (1 << 0)
+/**
+ * Codec uses get_buffer() or get_encode_buffer() for allocating buffers and
+ * supports custom allocators.
+ * If not set, it might not use get_buffer() or get_encode_buffer() at all, or
+ * use operations that assume the buffer was allocated by
+ * avcodec_default_get_buffer2 or avcodec_default_get_encode_buffer.
+ */
+#define AV_CODEC_CAP_DR1 (1 << 1)
+/**
+ * Encoder or decoder requires flushing with NULL input at the end in order to
+ * give the complete and correct output.
+ *
+ * NOTE: If this flag is not set, the codec is guaranteed to never be fed with
+ *       with NULL data. The user can still send NULL data to the public encode
+ *       or decode function, but libavcodec will not pass it along to the codec
+ *       unless this flag is set.
+ *
+ * Decoders:
+ * The decoder has a non-zero delay and needs to be fed with avpkt->data=NULL,
+ * avpkt->size=0 at the end to get the delayed data until the decoder no longer
+ * returns frames.
+ *
+ * Encoders:
+ * The encoder needs to be fed with NULL data at the end of encoding until the
+ * encoder no longer returns data.
+ *
+ * NOTE: For encoders implementing the AVCodec.encode2() function, setting this
+ *       flag also means that the encoder must set the pts and duration for
+ *       each output packet. If this flag is not set, the pts and duration will
+ *       be determined by libavcodec from the input frame.
+ */
+#define AV_CODEC_CAP_DELAY (1 << 5)
+/**
+ * Codec can be fed a final frame with a smaller size.
+ * This can be used to prevent truncation of the last audio samples.
+ */
+#define AV_CODEC_CAP_SMALL_LAST_FRAME (1 << 6)
+
+/**
+ * Codec can output multiple frames per AVPacket
+ * Normally demuxers return one frame at a time, demuxers which do not do
+ * are connected to a parser to split what they return into proper frames.
+ * This flag is reserved to the very rare category of codecs which have a
+ * bitstream that cannot be split into frames without timeconsuming
+ * operations like full decoding. Demuxers carrying such bitstreams thus
+ * may return multiple frames in a packet. This has many disadvantages like
+ * prohibiting stream copy in many cases thus it should only be considered
+ * as a last resort.
+ */
+#define AV_CODEC_CAP_SUBFRAMES (1 << 8)
+/**
+ * Codec is experimental and is thus avoided in favor of non experimental
+ * encoders
+ */
+#define AV_CODEC_CAP_EXPERIMENTAL (1 << 9)
+/**
+ * Codec should fill in channel configuration and samplerate instead of
+ * container
+ */
+#define AV_CODEC_CAP_CHANNEL_CONF (1 << 10)
+/**
+ * Codec supports frame-level multithreading.
+ */
+#define AV_CODEC_CAP_FRAME_THREADS (1 << 12)
+/**
+ * Codec supports slice-based (or partition-based) multithreading.
+ */
+#define AV_CODEC_CAP_SLICE_THREADS (1 << 13)
+/**
+ * Codec supports changed parameters at any point.
+ */
+#define AV_CODEC_CAP_PARAM_CHANGE (1 << 14)
+/**
+ * Codec supports multithreading through a method other than slice- or
+ * frame-level multithreading. Typically this marks wrappers around
+ * multithreading-capable external libraries.
+ */
+#define AV_CODEC_CAP_OTHER_THREADS (1 << 15)
+/**
+ * Audio encoder supports receiving a different number of samples in each call.
+ */
+#define AV_CODEC_CAP_VARIABLE_FRAME_SIZE (1 << 16)
+/**
+ * Decoder is not a preferred choice for probing.
+ * This indicates that the decoder is not a good choice for probing.
+ * It could for example be an expensive to spin up hardware decoder,
+ * or it could simply not provide a lot of useful information about
+ * the stream.
+ * A decoder marked with this flag should only be used as last resort
+ * choice for probing.
+ */
+#define AV_CODEC_CAP_AVOID_PROBING (1 << 17)
+
+/**
+ * Codec is backed by a hardware implementation. Typically used to
+ * identify a non-hwaccel hardware decoder. For information about hwaccels, use
+ * avcodec_get_hw_config() instead.
+ */
+#define AV_CODEC_CAP_HARDWARE (1 << 18)
+
+/**
+ * Codec is potentially backed by a hardware implementation, but not
+ * necessarily. This is used instead of AV_CODEC_CAP_HARDWARE, if the
+ * implementation provides some sort of internal fallback.
+ */
+#define AV_CODEC_CAP_HYBRID (1 << 19)
+
+/**
+ * This encoder can reorder user opaque values from input AVFrames and return
+ * them with corresponding output packets.
+ * @see AV_CODEC_FLAG_COPY_OPAQUE
+ */
+#define AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE (1 << 20)
+
+/**
+ * This encoder can be flushed using avcodec_flush_buffers(). If this flag is
+ * not set, the encoder must be closed and reopened to ensure that no frames
+ * remain pending.
+ */
+#define AV_CODEC_CAP_ENCODER_FLUSH (1 << 21)
+
+/**
+ * The encoder is able to output reconstructed frame data, i.e. raw frames that
+ * would be produced by decoding the encoded bitstream.
+ *
+ * Reconstructed frame output is enabled by the AV_CODEC_FLAG_RECON_FRAME flag.
+ */
+#define AV_CODEC_CAP_ENCODER_RECON_FRAME (1 << 22)
+
+/**
+ * AVProfile.
+ */
+typedef struct AVProfile {
+  int profile;
+  const char* name;  ///< short name for the profile
+} AVProfile;
+
+/**
+ * AVCodec.
+ */
+typedef struct AVCodec {
+  /**
+   * Name of the codec implementation.
+   * The name is globally unique among encoders and among decoders (but an
+   * encoder and a decoder can share the same name).
+   * This is the primary way to find a codec from the user perspective.
+   */
+  const char* name;
+  /**
+   * Descriptive name for the codec, meant to be more human readable than name.
+   * You should use the NULL_IF_CONFIG_SMALL() macro to define it.
+   */
+  const char* long_name;
+  enum AVMediaType type;
+  enum AVCodecID id;
+  /**
+   * Codec capabilities.
+   * see AV_CODEC_CAP_*
+   */
+  int capabilities;
+  uint8_t max_lowres;  ///< maximum value for lowres supported by the decoder
+  const AVRational*
+      supported_framerates;  ///< array of supported framerates, or NULL if any,
+                             ///< array is terminated by {0,0}
+  const enum AVPixelFormat*
+      pix_fmts;  ///< array of supported pixel formats, or NULL if unknown,
+                 ///< array is terminated by -1
+  const int*
+      supported_samplerates;  ///< array of supported audio samplerates, or NULL
+                              ///< if unknown, array is terminated by 0
+  const enum AVSampleFormat*
+      sample_fmts;  ///< array of supported sample formats, or NULL if unknown,
+                    ///< array is terminated by -1
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * @deprecated use ch_layouts instead
+   */
+  attribute_deprecated const uint64_t*
+      channel_layouts;  ///< array of support channel layouts, or NULL if
+                        ///< unknown. array is terminated by 0
+#endif
+  const AVClass* priv_class;  ///< AVClass for the private context
+  const AVProfile*
+      profiles;  ///< array of recognized profiles, or NULL if unknown, array is
+                 ///< terminated by {FF_PROFILE_UNKNOWN}
+
+  /**
+   * Group name of the codec implementation.
+   * This is a short symbolic name of the wrapper backing this codec. A
+   * wrapper uses some kind of external implementation for the codec, such
+   * as an external library, or a codec implementation provided by the OS or
+   * the hardware.
+   * If this field is NULL, this is a builtin, libavcodec native codec.
+   * If non-NULL, this will be the suffix in AVCodec.name in most cases
+   * (usually AVCodec.name will be of the form "<codec_name>_<wrapper_name>").
+   */
+  const char* wrapper_name;
+
+  /**
+   * Array of supported channel layouts, terminated with a zeroed layout.
+   */
+  const AVChannelLayout* ch_layouts;
+} AVCodec;
+
+/**
+ * Iterate over all registered codecs.
+ *
+ * @param opaque a pointer where libavcodec will store the iteration state. Must
+ *               point to NULL to start the iteration.
+ *
+ * @return the next registered codec or NULL when the iteration is
+ *         finished
+ */
+const AVCodec* av_codec_iterate(void** opaque);
+
+/**
+ * Find a registered decoder with a matching codec ID.
+ *
+ * @param id AVCodecID of the requested decoder
+ * @return A decoder if one was found, NULL otherwise.
+ */
+const AVCodec* avcodec_find_decoder(enum AVCodecID id);
+
+/**
+ * Find a registered decoder with the specified name.
+ *
+ * @param name name of the requested decoder
+ * @return A decoder if one was found, NULL otherwise.
+ */
+const AVCodec* avcodec_find_decoder_by_name(const char* name);
+
+/**
+ * Find a registered encoder with a matching codec ID.
+ *
+ * @param id AVCodecID of the requested encoder
+ * @return An encoder if one was found, NULL otherwise.
+ */
+const AVCodec* avcodec_find_encoder(enum AVCodecID id);
+
+/**
+ * Find a registered encoder with the specified name.
+ *
+ * @param name name of the requested encoder
+ * @return An encoder if one was found, NULL otherwise.
+ */
+const AVCodec* avcodec_find_encoder_by_name(const char* name);
+/**
+ * @return a non-zero number if codec is an encoder, zero otherwise
+ */
+int av_codec_is_encoder(const AVCodec* codec);
+
+/**
+ * @return a non-zero number if codec is a decoder, zero otherwise
+ */
+int av_codec_is_decoder(const AVCodec* codec);
+
+/**
+ * Return a name for the specified profile, if available.
+ *
+ * @param codec the codec that is searched for the given profile
+ * @param profile the profile value for which a name is requested
+ * @return A name for the profile if found, NULL otherwise.
+ */
+const char* av_get_profile_name(const AVCodec* codec, int profile);
+
+enum {
+  /**
+   * The codec supports this format via the hw_device_ctx interface.
+   *
+   * When selecting this format, AVCodecContext.hw_device_ctx should
+   * have been set to a device of the specified type before calling
+   * avcodec_open2().
+   */
+  AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 0x01,
+  /**
+   * The codec supports this format via the hw_frames_ctx interface.
+   *
+   * When selecting this format for a decoder,
+   * AVCodecContext.hw_frames_ctx should be set to a suitable frames
+   * context inside the get_format() callback.  The frames context
+   * must have been created on a device of the specified type.
+   *
+   * When selecting this format for an encoder,
+   * AVCodecContext.hw_frames_ctx should be set to the context which
+   * will be used for the input frames before calling avcodec_open2().
+   */
+  AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 0x02,
+  /**
+   * The codec supports this format by some internal method.
+   *
+   * This format can be selected without any additional configuration -
+   * no device or frames context is required.
+   */
+  AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 0x04,
+  /**
+   * The codec supports this format by some ad-hoc method.
+   *
+   * Additional settings and/or function calls are required.  See the
+   * codec-specific documentation for details.  (Methods requiring
+   * this sort of configuration are deprecated and others should be
+   * used in preference.)
+   */
+  AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 0x08,
+};
+
+typedef struct AVCodecHWConfig {
+  /**
+   * For decoders, a hardware pixel format which that decoder may be
+   * able to decode to if suitable hardware is available.
+   *
+   * For encoders, a pixel format which the encoder may be able to
+   * accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel
+   * formats supported by the codec.
+   */
+  enum AVPixelFormat pix_fmt;
+  /**
+   * Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible
+   * setup methods which can be used with this configuration.
+   */
+  int methods;
+  /**
+   * The device type associated with the configuration.
+   *
+   * Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and
+   * AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused.
+   */
+  enum AVHWDeviceType device_type;
+} AVCodecHWConfig;
+
+/**
+ * Retrieve supported hardware configurations for a codec.
+ *
+ * Values of index from zero to some maximum return the indexed configuration
+ * descriptor; all other values return NULL.  If the codec does not support
+ * any hardware configurations then it will always return NULL.
+ */
+const AVCodecHWConfig* avcodec_get_hw_config(const AVCodec* codec, int index);
+
+/**
+ * @}
+ */
+
+#endif /* AVCODEC_CODEC_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_id.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_id.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_id.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_id.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,669 @@
+/*
+ * Codec IDs
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_CODEC_ID_H
+#define AVCODEC_CODEC_ID_H
+
+#include "libavutil/avutil.h"
+#include "libavutil/samplefmt.h"
+
+#include "version_major.h"
+
+/**
+ * @addtogroup lavc_core
+ * @{
+ */
+
+/**
+ * Identify the syntax and semantics of the bitstream.
+ * The principle is roughly:
+ * Two decoders with the same ID can decode the same streams.
+ * Two encoders with the same ID can encode compatible streams.
+ * There may be slight deviations from the principle due to implementation
+ * details.
+ *
+ * If you add a codec ID to this list, add it so that
+ * 1. no value of an existing codec ID changes (that would break ABI),
+ * 2. it is as close as possible to similar codecs
+ *
+ * After adding new codec IDs, do not forget to add an entry to the codec
+ * descriptor list and bump libavcodec minor version.
+ */
+enum AVCodecID {
+  AV_CODEC_ID_NONE,
+
+  /* video codecs */
+  AV_CODEC_ID_MPEG1VIDEO,
+  AV_CODEC_ID_MPEG2VIDEO,  ///< preferred ID for MPEG-1/2 video decoding
+  AV_CODEC_ID_H261,
+  AV_CODEC_ID_H263,
+  AV_CODEC_ID_RV10,
+  AV_CODEC_ID_RV20,
+  AV_CODEC_ID_MJPEG,
+  AV_CODEC_ID_MJPEGB,
+  AV_CODEC_ID_LJPEG,
+  AV_CODEC_ID_SP5X,
+  AV_CODEC_ID_JPEGLS,
+  AV_CODEC_ID_MPEG4,
+  AV_CODEC_ID_RAWVIDEO,
+  AV_CODEC_ID_MSMPEG4V1,
+  AV_CODEC_ID_MSMPEG4V2,
+  AV_CODEC_ID_MSMPEG4V3,
+  AV_CODEC_ID_WMV1,
+  AV_CODEC_ID_WMV2,
+  AV_CODEC_ID_H263P,
+  AV_CODEC_ID_H263I,
+  AV_CODEC_ID_FLV1,
+  AV_CODEC_ID_SVQ1,
+  AV_CODEC_ID_SVQ3,
+  AV_CODEC_ID_DVVIDEO,
+  AV_CODEC_ID_HUFFYUV,
+  AV_CODEC_ID_CYUV,
+  AV_CODEC_ID_H264,
+  AV_CODEC_ID_INDEO3,
+  AV_CODEC_ID_VP3,
+  AV_CODEC_ID_THEORA,
+  AV_CODEC_ID_ASV1,
+  AV_CODEC_ID_ASV2,
+  AV_CODEC_ID_FFV1,
+  AV_CODEC_ID_4XM,
+  AV_CODEC_ID_VCR1,
+  AV_CODEC_ID_CLJR,
+  AV_CODEC_ID_MDEC,
+  AV_CODEC_ID_ROQ,
+  AV_CODEC_ID_INTERPLAY_VIDEO,
+  AV_CODEC_ID_XAN_WC3,
+  AV_CODEC_ID_XAN_WC4,
+  AV_CODEC_ID_RPZA,
+  AV_CODEC_ID_CINEPAK,
+  AV_CODEC_ID_WS_VQA,
+  AV_CODEC_ID_MSRLE,
+  AV_CODEC_ID_MSVIDEO1,
+  AV_CODEC_ID_IDCIN,
+  AV_CODEC_ID_8BPS,
+  AV_CODEC_ID_SMC,
+  AV_CODEC_ID_FLIC,
+  AV_CODEC_ID_TRUEMOTION1,
+  AV_CODEC_ID_VMDVIDEO,
+  AV_CODEC_ID_MSZH,
+  AV_CODEC_ID_ZLIB,
+  AV_CODEC_ID_QTRLE,
+  AV_CODEC_ID_TSCC,
+  AV_CODEC_ID_ULTI,
+  AV_CODEC_ID_QDRAW,
+  AV_CODEC_ID_VIXL,
+  AV_CODEC_ID_QPEG,
+  AV_CODEC_ID_PNG,
+  AV_CODEC_ID_PPM,
+  AV_CODEC_ID_PBM,
+  AV_CODEC_ID_PGM,
+  AV_CODEC_ID_PGMYUV,
+  AV_CODEC_ID_PAM,
+  AV_CODEC_ID_FFVHUFF,
+  AV_CODEC_ID_RV30,
+  AV_CODEC_ID_RV40,
+  AV_CODEC_ID_VC1,
+  AV_CODEC_ID_WMV3,
+  AV_CODEC_ID_LOCO,
+  AV_CODEC_ID_WNV1,
+  AV_CODEC_ID_AASC,
+  AV_CODEC_ID_INDEO2,
+  AV_CODEC_ID_FRAPS,
+  AV_CODEC_ID_TRUEMOTION2,
+  AV_CODEC_ID_BMP,
+  AV_CODEC_ID_CSCD,
+  AV_CODEC_ID_MMVIDEO,
+  AV_CODEC_ID_ZMBV,
+  AV_CODEC_ID_AVS,
+  AV_CODEC_ID_SMACKVIDEO,
+  AV_CODEC_ID_NUV,
+  AV_CODEC_ID_KMVC,
+  AV_CODEC_ID_FLASHSV,
+  AV_CODEC_ID_CAVS,
+  AV_CODEC_ID_JPEG2000,
+  AV_CODEC_ID_VMNC,
+  AV_CODEC_ID_VP5,
+  AV_CODEC_ID_VP6,
+  AV_CODEC_ID_VP6F,
+  AV_CODEC_ID_TARGA,
+  AV_CODEC_ID_DSICINVIDEO,
+  AV_CODEC_ID_TIERTEXSEQVIDEO,
+  AV_CODEC_ID_TIFF,
+  AV_CODEC_ID_GIF,
+  AV_CODEC_ID_DXA,
+  AV_CODEC_ID_DNXHD,
+  AV_CODEC_ID_THP,
+  AV_CODEC_ID_SGI,
+  AV_CODEC_ID_C93,
+  AV_CODEC_ID_BETHSOFTVID,
+  AV_CODEC_ID_PTX,
+  AV_CODEC_ID_TXD,
+  AV_CODEC_ID_VP6A,
+  AV_CODEC_ID_AMV,
+  AV_CODEC_ID_VB,
+  AV_CODEC_ID_PCX,
+  AV_CODEC_ID_SUNRAST,
+  AV_CODEC_ID_INDEO4,
+  AV_CODEC_ID_INDEO5,
+  AV_CODEC_ID_MIMIC,
+  AV_CODEC_ID_RL2,
+  AV_CODEC_ID_ESCAPE124,
+  AV_CODEC_ID_DIRAC,
+  AV_CODEC_ID_BFI,
+  AV_CODEC_ID_CMV,
+  AV_CODEC_ID_MOTIONPIXELS,
+  AV_CODEC_ID_TGV,
+  AV_CODEC_ID_TGQ,
+  AV_CODEC_ID_TQI,
+  AV_CODEC_ID_AURA,
+  AV_CODEC_ID_AURA2,
+  AV_CODEC_ID_V210X,
+  AV_CODEC_ID_TMV,
+  AV_CODEC_ID_V210,
+  AV_CODEC_ID_DPX,
+  AV_CODEC_ID_MAD,
+  AV_CODEC_ID_FRWU,
+  AV_CODEC_ID_FLASHSV2,
+  AV_CODEC_ID_CDGRAPHICS,
+  AV_CODEC_ID_R210,
+  AV_CODEC_ID_ANM,
+  AV_CODEC_ID_BINKVIDEO,
+  AV_CODEC_ID_IFF_ILBM,
+#define AV_CODEC_ID_IFF_BYTERUN1 AV_CODEC_ID_IFF_ILBM
+  AV_CODEC_ID_KGV1,
+  AV_CODEC_ID_YOP,
+  AV_CODEC_ID_VP8,
+  AV_CODEC_ID_PICTOR,
+  AV_CODEC_ID_ANSI,
+  AV_CODEC_ID_A64_MULTI,
+  AV_CODEC_ID_A64_MULTI5,
+  AV_CODEC_ID_R10K,
+  AV_CODEC_ID_MXPEG,
+  AV_CODEC_ID_LAGARITH,
+  AV_CODEC_ID_PRORES,
+  AV_CODEC_ID_JV,
+  AV_CODEC_ID_DFA,
+  AV_CODEC_ID_WMV3IMAGE,
+  AV_CODEC_ID_VC1IMAGE,
+  AV_CODEC_ID_UTVIDEO,
+  AV_CODEC_ID_BMV_VIDEO,
+  AV_CODEC_ID_VBLE,
+  AV_CODEC_ID_DXTORY,
+  AV_CODEC_ID_V410,
+  AV_CODEC_ID_XWD,
+  AV_CODEC_ID_CDXL,
+  AV_CODEC_ID_XBM,
+  AV_CODEC_ID_ZEROCODEC,
+  AV_CODEC_ID_MSS1,
+  AV_CODEC_ID_MSA1,
+  AV_CODEC_ID_TSCC2,
+  AV_CODEC_ID_MTS2,
+  AV_CODEC_ID_CLLC,
+  AV_CODEC_ID_MSS2,
+  AV_CODEC_ID_VP9,
+  AV_CODEC_ID_AIC,
+  AV_CODEC_ID_ESCAPE130,
+  AV_CODEC_ID_G2M,
+  AV_CODEC_ID_WEBP,
+  AV_CODEC_ID_HNM4_VIDEO,
+  AV_CODEC_ID_HEVC,
+#define AV_CODEC_ID_H265 AV_CODEC_ID_HEVC
+  AV_CODEC_ID_FIC,
+  AV_CODEC_ID_ALIAS_PIX,
+  AV_CODEC_ID_BRENDER_PIX,
+  AV_CODEC_ID_PAF_VIDEO,
+  AV_CODEC_ID_EXR,
+  AV_CODEC_ID_VP7,
+  AV_CODEC_ID_SANM,
+  AV_CODEC_ID_SGIRLE,
+  AV_CODEC_ID_MVC1,
+  AV_CODEC_ID_MVC2,
+  AV_CODEC_ID_HQX,
+  AV_CODEC_ID_TDSC,
+  AV_CODEC_ID_HQ_HQA,
+  AV_CODEC_ID_HAP,
+  AV_CODEC_ID_DDS,
+  AV_CODEC_ID_DXV,
+  AV_CODEC_ID_SCREENPRESSO,
+  AV_CODEC_ID_RSCC,
+  AV_CODEC_ID_AVS2,
+  AV_CODEC_ID_PGX,
+  AV_CODEC_ID_AVS3,
+  AV_CODEC_ID_MSP2,
+  AV_CODEC_ID_VVC,
+#define AV_CODEC_ID_H266 AV_CODEC_ID_VVC
+  AV_CODEC_ID_Y41P,
+  AV_CODEC_ID_AVRP,
+  AV_CODEC_ID_012V,
+  AV_CODEC_ID_AVUI,
+#if FF_API_AYUV_CODECID
+  AV_CODEC_ID_AYUV,
+#endif
+  AV_CODEC_ID_TARGA_Y216,
+  AV_CODEC_ID_V308,
+  AV_CODEC_ID_V408,
+  AV_CODEC_ID_YUV4,
+  AV_CODEC_ID_AVRN,
+  AV_CODEC_ID_CPIA,
+  AV_CODEC_ID_XFACE,
+  AV_CODEC_ID_SNOW,
+  AV_CODEC_ID_SMVJPEG,
+  AV_CODEC_ID_APNG,
+  AV_CODEC_ID_DAALA,
+  AV_CODEC_ID_CFHD,
+  AV_CODEC_ID_TRUEMOTION2RT,
+  AV_CODEC_ID_M101,
+  AV_CODEC_ID_MAGICYUV,
+  AV_CODEC_ID_SHEERVIDEO,
+  AV_CODEC_ID_YLC,
+  AV_CODEC_ID_PSD,
+  AV_CODEC_ID_PIXLET,
+  AV_CODEC_ID_SPEEDHQ,
+  AV_CODEC_ID_FMVC,
+  AV_CODEC_ID_SCPR,
+  AV_CODEC_ID_CLEARVIDEO,
+  AV_CODEC_ID_XPM,
+  AV_CODEC_ID_AV1,
+  AV_CODEC_ID_BITPACKED,
+  AV_CODEC_ID_MSCC,
+  AV_CODEC_ID_SRGC,
+  AV_CODEC_ID_SVG,
+  AV_CODEC_ID_GDV,
+  AV_CODEC_ID_FITS,
+  AV_CODEC_ID_IMM4,
+  AV_CODEC_ID_PROSUMER,
+  AV_CODEC_ID_MWSC,
+  AV_CODEC_ID_WCMV,
+  AV_CODEC_ID_RASC,
+  AV_CODEC_ID_HYMT,
+  AV_CODEC_ID_ARBC,
+  AV_CODEC_ID_AGM,
+  AV_CODEC_ID_LSCR,
+  AV_CODEC_ID_VP4,
+  AV_CODEC_ID_IMM5,
+  AV_CODEC_ID_MVDV,
+  AV_CODEC_ID_MVHA,
+  AV_CODEC_ID_CDTOONS,
+  AV_CODEC_ID_MV30,
+  AV_CODEC_ID_NOTCHLC,
+  AV_CODEC_ID_PFM,
+  AV_CODEC_ID_MOBICLIP,
+  AV_CODEC_ID_PHOTOCD,
+  AV_CODEC_ID_IPU,
+  AV_CODEC_ID_ARGO,
+  AV_CODEC_ID_CRI,
+  AV_CODEC_ID_SIMBIOSIS_IMX,
+  AV_CODEC_ID_SGA_VIDEO,
+  AV_CODEC_ID_GEM,
+  AV_CODEC_ID_VBN,
+  AV_CODEC_ID_JPEGXL,
+  AV_CODEC_ID_QOI,
+  AV_CODEC_ID_PHM,
+  AV_CODEC_ID_RADIANCE_HDR,
+  AV_CODEC_ID_WBMP,
+  AV_CODEC_ID_MEDIA100,
+  AV_CODEC_ID_VQC,
+
+  /* various PCM "codecs" */
+  AV_CODEC_ID_FIRST_AUDIO =
+      0x10000,  ///< A dummy id pointing at the start of audio codecs
+  AV_CODEC_ID_PCM_S16LE = 0x10000,
+  AV_CODEC_ID_PCM_S16BE,
+  AV_CODEC_ID_PCM_U16LE,
+  AV_CODEC_ID_PCM_U16BE,
+  AV_CODEC_ID_PCM_S8,
+  AV_CODEC_ID_PCM_U8,
+  AV_CODEC_ID_PCM_MULAW,
+  AV_CODEC_ID_PCM_ALAW,
+  AV_CODEC_ID_PCM_S32LE,
+  AV_CODEC_ID_PCM_S32BE,
+  AV_CODEC_ID_PCM_U32LE,
+  AV_CODEC_ID_PCM_U32BE,
+  AV_CODEC_ID_PCM_S24LE,
+  AV_CODEC_ID_PCM_S24BE,
+  AV_CODEC_ID_PCM_U24LE,
+  AV_CODEC_ID_PCM_U24BE,
+  AV_CODEC_ID_PCM_S24DAUD,
+  AV_CODEC_ID_PCM_ZORK,
+  AV_CODEC_ID_PCM_S16LE_PLANAR,
+  AV_CODEC_ID_PCM_DVD,
+  AV_CODEC_ID_PCM_F32BE,
+  AV_CODEC_ID_PCM_F32LE,
+  AV_CODEC_ID_PCM_F64BE,
+  AV_CODEC_ID_PCM_F64LE,
+  AV_CODEC_ID_PCM_BLURAY,
+  AV_CODEC_ID_PCM_LXF,
+  AV_CODEC_ID_S302M,
+  AV_CODEC_ID_PCM_S8_PLANAR,
+  AV_CODEC_ID_PCM_S24LE_PLANAR,
+  AV_CODEC_ID_PCM_S32LE_PLANAR,
+  AV_CODEC_ID_PCM_S16BE_PLANAR,
+  AV_CODEC_ID_PCM_S64LE,
+  AV_CODEC_ID_PCM_S64BE,
+  AV_CODEC_ID_PCM_F16LE,
+  AV_CODEC_ID_PCM_F24LE,
+  AV_CODEC_ID_PCM_VIDC,
+  AV_CODEC_ID_PCM_SGA,
+
+  /* various ADPCM codecs */
+  AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
+  AV_CODEC_ID_ADPCM_IMA_WAV,
+  AV_CODEC_ID_ADPCM_IMA_DK3,
+  AV_CODEC_ID_ADPCM_IMA_DK4,
+  AV_CODEC_ID_ADPCM_IMA_WS,
+  AV_CODEC_ID_ADPCM_IMA_SMJPEG,
+  AV_CODEC_ID_ADPCM_MS,
+  AV_CODEC_ID_ADPCM_4XM,
+  AV_CODEC_ID_ADPCM_XA,
+  AV_CODEC_ID_ADPCM_ADX,
+  AV_CODEC_ID_ADPCM_EA,
+  AV_CODEC_ID_ADPCM_G726,
+  AV_CODEC_ID_ADPCM_CT,
+  AV_CODEC_ID_ADPCM_SWF,
+  AV_CODEC_ID_ADPCM_YAMAHA,
+  AV_CODEC_ID_ADPCM_SBPRO_4,
+  AV_CODEC_ID_ADPCM_SBPRO_3,
+  AV_CODEC_ID_ADPCM_SBPRO_2,
+  AV_CODEC_ID_ADPCM_THP,
+  AV_CODEC_ID_ADPCM_IMA_AMV,
+  AV_CODEC_ID_ADPCM_EA_R1,
+  AV_CODEC_ID_ADPCM_EA_R3,
+  AV_CODEC_ID_ADPCM_EA_R2,
+  AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
+  AV_CODEC_ID_ADPCM_IMA_EA_EACS,
+  AV_CODEC_ID_ADPCM_EA_XAS,
+  AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
+  AV_CODEC_ID_ADPCM_IMA_ISS,
+  AV_CODEC_ID_ADPCM_G722,
+  AV_CODEC_ID_ADPCM_IMA_APC,
+  AV_CODEC_ID_ADPCM_VIMA,
+  AV_CODEC_ID_ADPCM_AFC,
+  AV_CODEC_ID_ADPCM_IMA_OKI,
+  AV_CODEC_ID_ADPCM_DTK,
+  AV_CODEC_ID_ADPCM_IMA_RAD,
+  AV_CODEC_ID_ADPCM_G726LE,
+  AV_CODEC_ID_ADPCM_THP_LE,
+  AV_CODEC_ID_ADPCM_PSX,
+  AV_CODEC_ID_ADPCM_AICA,
+  AV_CODEC_ID_ADPCM_IMA_DAT4,
+  AV_CODEC_ID_ADPCM_MTAF,
+  AV_CODEC_ID_ADPCM_AGM,
+  AV_CODEC_ID_ADPCM_ARGO,
+  AV_CODEC_ID_ADPCM_IMA_SSI,
+  AV_CODEC_ID_ADPCM_ZORK,
+  AV_CODEC_ID_ADPCM_IMA_APM,
+  AV_CODEC_ID_ADPCM_IMA_ALP,
+  AV_CODEC_ID_ADPCM_IMA_MTF,
+  AV_CODEC_ID_ADPCM_IMA_CUNNING,
+  AV_CODEC_ID_ADPCM_IMA_MOFLEX,
+  AV_CODEC_ID_ADPCM_IMA_ACORN,
+  AV_CODEC_ID_ADPCM_XMD,
+
+  /* AMR */
+  AV_CODEC_ID_AMR_NB = 0x12000,
+  AV_CODEC_ID_AMR_WB,
+
+  /* RealAudio codecs*/
+  AV_CODEC_ID_RA_144 = 0x13000,
+  AV_CODEC_ID_RA_288,
+
+  /* various DPCM codecs */
+  AV_CODEC_ID_ROQ_DPCM = 0x14000,
+  AV_CODEC_ID_INTERPLAY_DPCM,
+  AV_CODEC_ID_XAN_DPCM,
+  AV_CODEC_ID_SOL_DPCM,
+  AV_CODEC_ID_SDX2_DPCM,
+  AV_CODEC_ID_GREMLIN_DPCM,
+  AV_CODEC_ID_DERF_DPCM,
+  AV_CODEC_ID_WADY_DPCM,
+  AV_CODEC_ID_CBD2_DPCM,
+
+  /* audio codecs */
+  AV_CODEC_ID_MP2 = 0x15000,
+  AV_CODEC_ID_MP3,  ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
+  AV_CODEC_ID_AAC,
+  AV_CODEC_ID_AC3,
+  AV_CODEC_ID_DTS,
+  AV_CODEC_ID_VORBIS,
+  AV_CODEC_ID_DVAUDIO,
+  AV_CODEC_ID_WMAV1,
+  AV_CODEC_ID_WMAV2,
+  AV_CODEC_ID_MACE3,
+  AV_CODEC_ID_MACE6,
+  AV_CODEC_ID_VMDAUDIO,
+  AV_CODEC_ID_FLAC,
+  AV_CODEC_ID_MP3ADU,
+  AV_CODEC_ID_MP3ON4,
+  AV_CODEC_ID_SHORTEN,
+  AV_CODEC_ID_ALAC,
+  AV_CODEC_ID_WESTWOOD_SND1,
+  AV_CODEC_ID_GSM,  ///< as in Berlin toast format
+  AV_CODEC_ID_QDM2,
+  AV_CODEC_ID_COOK,
+  AV_CODEC_ID_TRUESPEECH,
+  AV_CODEC_ID_TTA,
+  AV_CODEC_ID_SMACKAUDIO,
+  AV_CODEC_ID_QCELP,
+  AV_CODEC_ID_WAVPACK,
+  AV_CODEC_ID_DSICINAUDIO,
+  AV_CODEC_ID_IMC,
+  AV_CODEC_ID_MUSEPACK7,
+  AV_CODEC_ID_MLP,
+  AV_CODEC_ID_GSM_MS, /* as found in WAV */
+  AV_CODEC_ID_ATRAC3,
+  AV_CODEC_ID_APE,
+  AV_CODEC_ID_NELLYMOSER,
+  AV_CODEC_ID_MUSEPACK8,
+  AV_CODEC_ID_SPEEX,
+  AV_CODEC_ID_WMAVOICE,
+  AV_CODEC_ID_WMAPRO,
+  AV_CODEC_ID_WMALOSSLESS,
+  AV_CODEC_ID_ATRAC3P,
+  AV_CODEC_ID_EAC3,
+  AV_CODEC_ID_SIPR,
+  AV_CODEC_ID_MP1,
+  AV_CODEC_ID_TWINVQ,
+  AV_CODEC_ID_TRUEHD,
+  AV_CODEC_ID_MP4ALS,
+  AV_CODEC_ID_ATRAC1,
+  AV_CODEC_ID_BINKAUDIO_RDFT,
+  AV_CODEC_ID_BINKAUDIO_DCT,
+  AV_CODEC_ID_AAC_LATM,
+  AV_CODEC_ID_QDMC,
+  AV_CODEC_ID_CELT,
+  AV_CODEC_ID_G723_1,
+  AV_CODEC_ID_G729,
+  AV_CODEC_ID_8SVX_EXP,
+  AV_CODEC_ID_8SVX_FIB,
+  AV_CODEC_ID_BMV_AUDIO,
+  AV_CODEC_ID_RALF,
+  AV_CODEC_ID_IAC,
+  AV_CODEC_ID_ILBC,
+  AV_CODEC_ID_OPUS,
+  AV_CODEC_ID_COMFORT_NOISE,
+  AV_CODEC_ID_TAK,
+  AV_CODEC_ID_METASOUND,
+  AV_CODEC_ID_PAF_AUDIO,
+  AV_CODEC_ID_ON2AVC,
+  AV_CODEC_ID_DSS_SP,
+  AV_CODEC_ID_CODEC2,
+  AV_CODEC_ID_FFWAVESYNTH,
+  AV_CODEC_ID_SONIC,
+  AV_CODEC_ID_SONIC_LS,
+  AV_CODEC_ID_EVRC,
+  AV_CODEC_ID_SMV,
+  AV_CODEC_ID_DSD_LSBF,
+  AV_CODEC_ID_DSD_MSBF,
+  AV_CODEC_ID_DSD_LSBF_PLANAR,
+  AV_CODEC_ID_DSD_MSBF_PLANAR,
+  AV_CODEC_ID_4GV,
+  AV_CODEC_ID_INTERPLAY_ACM,
+  AV_CODEC_ID_XMA1,
+  AV_CODEC_ID_XMA2,
+  AV_CODEC_ID_DST,
+  AV_CODEC_ID_ATRAC3AL,
+  AV_CODEC_ID_ATRAC3PAL,
+  AV_CODEC_ID_DOLBY_E,
+  AV_CODEC_ID_APTX,
+  AV_CODEC_ID_APTX_HD,
+  AV_CODEC_ID_SBC,
+  AV_CODEC_ID_ATRAC9,
+  AV_CODEC_ID_HCOM,
+  AV_CODEC_ID_ACELP_KELVIN,
+  AV_CODEC_ID_MPEGH_3D_AUDIO,
+  AV_CODEC_ID_SIREN,
+  AV_CODEC_ID_HCA,
+  AV_CODEC_ID_FASTAUDIO,
+  AV_CODEC_ID_MSNSIREN,
+  AV_CODEC_ID_DFPWM,
+  AV_CODEC_ID_BONK,
+  AV_CODEC_ID_MISC4,
+  AV_CODEC_ID_APAC,
+  AV_CODEC_ID_FTR,
+  AV_CODEC_ID_WAVARC,
+  AV_CODEC_ID_RKA,
+
+  /* subtitle codecs */
+  AV_CODEC_ID_FIRST_SUBTITLE =
+      0x17000,  ///< A dummy ID pointing at the start of subtitle codecs.
+  AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
+  AV_CODEC_ID_DVB_SUBTITLE,
+  AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
+  AV_CODEC_ID_XSUB,
+  AV_CODEC_ID_SSA,
+  AV_CODEC_ID_MOV_TEXT,
+  AV_CODEC_ID_HDMV_PGS_SUBTITLE,
+  AV_CODEC_ID_DVB_TELETEXT,
+  AV_CODEC_ID_SRT,
+  AV_CODEC_ID_MICRODVD,
+  AV_CODEC_ID_EIA_608,
+  AV_CODEC_ID_JACOSUB,
+  AV_CODEC_ID_SAMI,
+  AV_CODEC_ID_REALTEXT,
+  AV_CODEC_ID_STL,
+  AV_CODEC_ID_SUBVIEWER1,
+  AV_CODEC_ID_SUBVIEWER,
+  AV_CODEC_ID_SUBRIP,
+  AV_CODEC_ID_WEBVTT,
+  AV_CODEC_ID_MPL2,
+  AV_CODEC_ID_VPLAYER,
+  AV_CODEC_ID_PJS,
+  AV_CODEC_ID_ASS,
+  AV_CODEC_ID_HDMV_TEXT_SUBTITLE,
+  AV_CODEC_ID_TTML,
+  AV_CODEC_ID_ARIB_CAPTION,
+
+  /* other specific kind of codecs (generally used for attachments) */
+  AV_CODEC_ID_FIRST_UNKNOWN =
+      0x18000,  ///< A dummy ID pointing at the start of various fake codecs.
+  AV_CODEC_ID_TTF = 0x18000,
+
+  AV_CODEC_ID_SCTE_35,  ///< Contain timestamp estimated through PCR of program
+                        ///< stream.
+  AV_CODEC_ID_EPG,
+  AV_CODEC_ID_BINTEXT,
+  AV_CODEC_ID_XBIN,
+  AV_CODEC_ID_IDF,
+  AV_CODEC_ID_OTF,
+  AV_CODEC_ID_SMPTE_KLV,
+  AV_CODEC_ID_DVD_NAV,
+  AV_CODEC_ID_TIMED_ID3,
+  AV_CODEC_ID_BIN_DATA,
+
+  AV_CODEC_ID_PROBE =
+      0x19000,  ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf
+                ///< should attempt to identify it
+
+  AV_CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
+                                  * stream (only used by libavformat) */
+  AV_CODEC_ID_MPEG4SYSTEMS =
+      0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
+                * stream (only used by libavformat) */
+  AV_CODEC_ID_FFMETADATA = 0x21000,  ///< Dummy codec for streams containing
+                                     ///< only metadata information.
+  AV_CODEC_ID_WRAPPED_AVFRAME =
+      0x21001,  ///< Passthrough codec, AVFrames wrapped in AVPacket
+  /**
+   * Dummy null video codec, useful mainly for development and debugging.
+   * Null encoder/decoder discard all input and never return any output.
+   */
+  AV_CODEC_ID_VNULL,
+  /**
+   * Dummy null audio codec, useful mainly for development and debugging.
+   * Null encoder/decoder discard all input and never return any output.
+   */
+  AV_CODEC_ID_ANULL,
+};
+
+/**
+ * Get the type of the given codec.
+ */
+enum AVMediaType avcodec_get_type(enum AVCodecID codec_id);
+
+/**
+ * Get the name of a codec.
+ * @return  a static string identifying the codec; never NULL
+ */
+const char* avcodec_get_name(enum AVCodecID id);
+
+/**
+ * Return codec bits per sample.
+ *
+ * @param[in] codec_id the codec
+ * @return Number of bits per sample or zero if unknown for the given codec.
+ */
+int av_get_bits_per_sample(enum AVCodecID codec_id);
+
+/**
+ * Return codec bits per sample.
+ * Only return non-zero if the bits per sample is exactly correct, not an
+ * approximation.
+ *
+ * @param[in] codec_id the codec
+ * @return Number of bits per sample or zero if unknown for the given codec.
+ */
+int av_get_exact_bits_per_sample(enum AVCodecID codec_id);
+
+/**
+ * Return a name for the specified profile, if available.
+ *
+ * @param codec_id the ID of the codec to which the requested profile belongs
+ * @param profile the profile value for which a name is requested
+ * @return A name for the profile if found, NULL otherwise.
+ *
+ * @note unlike av_get_profile_name(), which searches a list of profiles
+ *       supported by a specific decoder or encoder implementation, this
+ *       function searches the list of profiles from the AVCodecDescriptor
+ */
+const char* avcodec_profile_name(enum AVCodecID codec_id, int profile);
+
+/**
+ * Return the PCM codec associated with a sample format.
+ * @param be  endianness, 0 for little, 1 for big,
+ *            -1 (or anything else) for native
+ * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
+ */
+enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be);
+
+/**
+ * @}
+ */
+
+#endif  // AVCODEC_CODEC_ID_H
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_par.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_par.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_par.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/codec_par.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,247 @@
+/*
+ * Codec parameters public API
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_CODEC_PAR_H
+#define AVCODEC_CODEC_PAR_H
+
+#include <stdint.h>
+
+#include "libavutil/avutil.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/rational.h"
+#include "libavutil/pixfmt.h"
+
+#include "codec_id.h"
+
+/**
+ * @addtogroup lavc_core
+ * @{
+ */
+
+enum AVFieldOrder {
+  AV_FIELD_UNKNOWN,
+  AV_FIELD_PROGRESSIVE,
+  AV_FIELD_TT,  ///< Top coded_first, top displayed first
+  AV_FIELD_BB,  ///< Bottom coded first, bottom displayed first
+  AV_FIELD_TB,  ///< Top coded first, bottom displayed first
+  AV_FIELD_BT,  ///< Bottom coded first, top displayed first
+};
+
+/**
+ * This struct describes the properties of an encoded stream.
+ *
+ * sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
+ * be allocated with avcodec_parameters_alloc() and freed with
+ * avcodec_parameters_free().
+ */
+typedef struct AVCodecParameters {
+  /**
+   * General type of the encoded data.
+   */
+  enum AVMediaType codec_type;
+  /**
+   * Specific type of the encoded data (the codec used).
+   */
+  enum AVCodecID codec_id;
+  /**
+   * Additional information about the codec (corresponds to the AVI FOURCC).
+   */
+  uint32_t codec_tag;
+
+  /**
+   * Extra binary data needed for initializing the decoder, codec-dependent.
+   *
+   * Must be allocated with av_malloc() and will be freed by
+   * avcodec_parameters_free(). The allocated size of extradata must be at
+   * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
+   * bytes zeroed.
+   */
+  uint8_t* extradata;
+  /**
+   * Size of the extradata content in bytes.
+   */
+  int extradata_size;
+
+  /**
+   * - video: the pixel format, the value corresponds to enum AVPixelFormat.
+   * - audio: the sample format, the value corresponds to enum AVSampleFormat.
+   */
+  int format;
+
+  /**
+   * The average bitrate of the encoded data (in bits per second).
+   */
+  int64_t bit_rate;
+
+  /**
+   * The number of bits per sample in the codedwords.
+   *
+   * This is basically the bitrate per sample. It is mandatory for a bunch of
+   * formats to actually decode them. It's the number of bits for one sample in
+   * the actual coded bitstream.
+   *
+   * This could be for example 4 for ADPCM
+   * For PCM formats this matches bits_per_raw_sample
+   * Can be 0
+   */
+  int bits_per_coded_sample;
+
+  /**
+   * This is the number of valid bits in each output sample. If the
+   * sample format has more bits, the least significant bits are additional
+   * padding bits, which are always 0. Use right shifts to reduce the sample
+   * to its actual size. For example, audio formats with 24 bit samples will
+   * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
+   * To get the original sample use "(int32_t)sample >> 8"."
+   *
+   * For ADPCM this might be 12 or 16 or similar
+   * Can be 0
+   */
+  int bits_per_raw_sample;
+
+  /**
+   * Codec-specific bitstream restrictions that the stream conforms to.
+   */
+  int profile;
+  int level;
+
+  /**
+   * Video only. The dimensions of the video frame in pixels.
+   */
+  int width;
+  int height;
+
+  /**
+   * Video only. The aspect ratio (width / height) which a single pixel
+   * should have when displayed.
+   *
+   * When the aspect ratio is unknown / undefined, the numerator should be
+   * set to 0 (the denominator may have any value).
+   */
+  AVRational sample_aspect_ratio;
+
+  /**
+   * Video only. The order of the fields in interlaced video.
+   */
+  enum AVFieldOrder field_order;
+
+  /**
+   * Video only. Additional colorspace characteristics.
+   */
+  enum AVColorRange color_range;
+  enum AVColorPrimaries color_primaries;
+  enum AVColorTransferCharacteristic color_trc;
+  enum AVColorSpace color_space;
+  enum AVChromaLocation chroma_location;
+
+  /**
+   * Video only. Number of delayed frames.
+   */
+  int video_delay;
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * Audio only. The channel layout bitmask. May be 0 if the channel layout is
+   * unknown or unspecified, otherwise the number of bits set must be equal to
+   * the channels field.
+   * @deprecated use ch_layout
+   */
+  attribute_deprecated uint64_t channel_layout;
+  /**
+   * Audio only. The number of audio channels.
+   * @deprecated use ch_layout.nb_channels
+   */
+  attribute_deprecated int channels;
+#endif
+  /**
+   * Audio only. The number of audio samples per second.
+   */
+  int sample_rate;
+  /**
+   * Audio only. The number of bytes per coded audio frame, required by some
+   * formats.
+   *
+   * Corresponds to nBlockAlign in WAVEFORMATEX.
+   */
+  int block_align;
+  /**
+   * Audio only. Audio frame size, if known. Required by some formats to be
+   * static.
+   */
+  int frame_size;
+
+  /**
+   * Audio only. The amount of padding (in samples) inserted by the encoder at
+   * the beginning of the audio. I.e. this number of leading decoded samples
+   * must be discarded by the caller to get the original audio without leading
+   * padding.
+   */
+  int initial_padding;
+  /**
+   * Audio only. The amount of padding (in samples) appended by the encoder to
+   * the end of the audio. I.e. this number of decoded samples must be
+   * discarded by the caller from the end of the stream to get the original
+   * audio without any trailing padding.
+   */
+  int trailing_padding;
+  /**
+   * Audio only. Number of samples to skip after a discontinuity.
+   */
+  int seek_preroll;
+
+  /**
+   * Audio only. The channel layout and number of channels.
+   */
+  AVChannelLayout ch_layout;
+} AVCodecParameters;
+
+/**
+ * Allocate a new AVCodecParameters and set its fields to default values
+ * (unknown/invalid/0). The returned struct must be freed with
+ * avcodec_parameters_free().
+ */
+AVCodecParameters* avcodec_parameters_alloc(void);
+
+/**
+ * Free an AVCodecParameters instance and everything associated with it and
+ * write NULL to the supplied pointer.
+ */
+void avcodec_parameters_free(AVCodecParameters** par);
+
+/**
+ * Copy the contents of src to dst. Any allocated fields in dst are freed and
+ * replaced with newly allocated duplicates of the corresponding fields in src.
+ *
+ * @return >= 0 on success, a negative AVERROR code on failure.
+ */
+int avcodec_parameters_copy(AVCodecParameters* dst,
+                            const AVCodecParameters* src);
+
+/**
+ * This function is the same as av_get_audio_frame_duration(), except it works
+ * with AVCodecParameters instead of an AVCodecContext.
+ */
+int av_get_audio_frame_duration2(AVCodecParameters* par, int frame_bytes);
+
+/**
+ * @}
+ */
+
+#endif  // AVCODEC_CODEC_PAR_H
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/defs.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/defs.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/defs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/defs.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,203 @@
+/*
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_DEFS_H
+#define AVCODEC_DEFS_H
+
+/**
+ * @file
+ * @ingroup libavc
+ * Misc types and constants that do not belong anywhere else.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+/**
+ * @ingroup lavc_decoding
+ * Required number of additionally allocated bytes at the end of the input
+ * bitstream for decoding. This is mainly needed because some optimized
+ * bitstream readers read 32 or 64 bit at once and could read over the end.<br>
+ * Note: If the first 23 bits of the additional bytes are not 0, then damaged
+ * MPEG bitstreams could cause overread and segfault.
+ */
+#define AV_INPUT_BUFFER_PADDING_SIZE 64
+
+/**
+ * Verify checksums embedded in the bitstream (could be of either encoded or
+ * decoded data, depending on the format) and print an error message on
+ * mismatch. If AV_EF_EXPLODE is also set, a mismatching checksum will result in
+ * the decoder/demuxer returning an error.
+ */
+#define AV_EF_CRCCHECK (1 << 0)
+#define AV_EF_BITSTREAM (1 << 1)  ///< detect bitstream specification deviations
+#define AV_EF_BUFFER (1 << 2)     ///< detect improper bitstream length
+#define AV_EF_EXPLODE (1 << 3)    ///< abort decoding on minor error detection
+
+#define AV_EF_IGNORE_ERR (1 << 15)  ///< ignore errors and continue
+#define AV_EF_CAREFUL \
+  (1 << 16)  ///< consider things that violate the spec, are fast to calculate
+             ///< and have not been seen in the wild as errors
+#define AV_EF_COMPLIANT \
+  (1 << 17)  ///< consider all spec non compliances as errors
+#define AV_EF_AGGRESSIVE \
+  (1 << 18)  ///< consider things that a sane encoder/muxer should not do as an
+             ///< error
+
+#define FF_COMPLIANCE_VERY_STRICT \
+  2  ///< Strictly conform to an older more strict version of the spec or
+     ///< reference software.
+#define FF_COMPLIANCE_STRICT \
+  1  ///< Strictly conform to all the things in the spec no matter what
+     ///< consequences.
+#define FF_COMPLIANCE_NORMAL 0
+#define FF_COMPLIANCE_UNOFFICIAL -1  ///< Allow unofficial extensions
+#define FF_COMPLIANCE_EXPERIMENTAL \
+  -2  ///< Allow nonstandardized experimental things.
+
+/**
+ * @ingroup lavc_decoding
+ */
+enum AVDiscard {
+  /* We leave some space between them for extensions (drop some
+   * keyframes for intra-only or drop just some bidir frames). */
+  AVDISCARD_NONE = -16,  ///< discard nothing
+  AVDISCARD_DEFAULT =
+      0,                 ///< discard useless packets like 0 size packets in avi
+  AVDISCARD_NONREF = 8,  ///< discard all non reference
+  AVDISCARD_BIDIR = 16,  ///< discard all bidirectional frames
+  AVDISCARD_NONINTRA = 24,  ///< discard all non intra frames
+  AVDISCARD_NONKEY = 32,    ///< discard all frames except keyframes
+  AVDISCARD_ALL = 48,       ///< discard all
+};
+
+enum AVAudioServiceType {
+  AV_AUDIO_SERVICE_TYPE_MAIN = 0,
+  AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
+  AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
+  AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
+  AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
+  AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
+  AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
+  AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
+  AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
+  AV_AUDIO_SERVICE_TYPE_NB,  ///< Not part of ABI
+};
+
+/**
+ * Pan Scan area.
+ * This specifies the area which should be displayed.
+ * Note there may be multiple such areas for one frame.
+ */
+typedef struct AVPanScan {
+  /**
+   * id
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  int id;
+
+  /**
+   * width and height in 1/16 pel
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  int width;
+  int height;
+
+  /**
+   * position of the top left corner in 1/16 pel for up to 3 fields/frames
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  int16_t position[3][2];
+} AVPanScan;
+
+/**
+ * This structure describes the bitrate properties of an encoded bitstream. It
+ * roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
+ * parameters for H.264/HEVC.
+ */
+typedef struct AVCPBProperties {
+  /**
+   * Maximum bitrate of the stream, in bits per second.
+   * Zero if unknown or unspecified.
+   */
+  int64_t max_bitrate;
+  /**
+   * Minimum bitrate of the stream, in bits per second.
+   * Zero if unknown or unspecified.
+   */
+  int64_t min_bitrate;
+  /**
+   * Average bitrate of the stream, in bits per second.
+   * Zero if unknown or unspecified.
+   */
+  int64_t avg_bitrate;
+
+  /**
+   * The size of the buffer to which the ratecontrol is applied, in bits.
+   * Zero if unknown or unspecified.
+   */
+  int64_t buffer_size;
+
+  /**
+   * The delay between the time the packet this structure is associated with
+   * is received and the time when it should be decoded, in periods of a 27MHz
+   * clock.
+   *
+   * UINT64_MAX when unknown or unspecified.
+   */
+  uint64_t vbv_delay;
+} AVCPBProperties;
+
+/**
+ * Allocate a CPB properties structure and initialize its fields to default
+ * values.
+ *
+ * @param size if non-NULL, the size of the allocated struct will be written
+ *             here. This is useful for embedding it in side data.
+ *
+ * @return the newly allocated struct or NULL on failure
+ */
+AVCPBProperties* av_cpb_properties_alloc(size_t* size);
+
+/**
+ * This structure supplies correlation between a packet timestamp and a wall
+ * clock production time. The definition follows the Producer Reference Time
+ * ('prft') as defined in ISO/IEC 14496-12
+ */
+typedef struct AVProducerReferenceTime {
+  /**
+   * A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime()).
+   */
+  int64_t wallclock;
+  int flags;
+} AVProducerReferenceTime;
+
+/**
+ * Encode extradata length to a buffer. Used by xiph codecs.
+ *
+ * @param s buffer to write to; must be at least (v/255+1) bytes long
+ * @param v size of extradata in bytes
+ * @return number of bytes written to the buffer.
+ */
+unsigned int av_xiphlacing(unsigned char* s, unsigned int v);
+
+#endif  // AVCODEC_DEFS_H
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/packet.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/packet.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/packet.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/packet.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,730 @@
+/*
+ * AVPacket public API
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_PACKET_H
+#define AVCODEC_PACKET_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "libavutil/attributes.h"
+#include "libavutil/buffer.h"
+#include "libavutil/dict.h"
+#include "libavutil/rational.h"
+#include "libavutil/version.h"
+
+#include "libavcodec/version_major.h"
+
+/**
+ * @defgroup lavc_packet AVPacket
+ *
+ * Types and functions for working with AVPacket.
+ * @{
+ */
+enum AVPacketSideDataType {
+  /**
+   * An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
+   * bytes worth of palette. This side data signals that a new palette is
+   * present.
+   */
+  AV_PKT_DATA_PALETTE,
+
+  /**
+   * The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
+   * that the extradata buffer was changed and the receiving side should
+   * act upon it appropriately. The new extradata is embedded in the side
+   * data buffer and should be immediately used for processing the current
+   * frame or packet.
+   */
+  AV_PKT_DATA_NEW_EXTRADATA,
+
+  /**
+   * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
+   * @code
+   * u32le param_flags
+   * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
+   *     s32le channel_count
+   * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
+   *     u64le channel_layout
+   * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
+   *     s32le sample_rate
+   * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
+   *     s32le width
+   *     s32le height
+   * @endcode
+   */
+  AV_PKT_DATA_PARAM_CHANGE,
+
+  /**
+   * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
+   * structures with info about macroblocks relevant to splitting the
+   * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
+   * That is, it does not necessarily contain info about all macroblocks,
+   * as long as the distance between macroblocks in the info is smaller
+   * than the target payload size.
+   * Each MB info structure is 12 bytes, and is laid out as follows:
+   * @code
+   * u32le bit offset from the start of the packet
+   * u8    current quantizer at the start of the macroblock
+   * u8    GOB number
+   * u16le macroblock address within the GOB
+   * u8    horizontal MV predictor
+   * u8    vertical MV predictor
+   * u8    horizontal MV predictor for block number 3
+   * u8    vertical MV predictor for block number 3
+   * @endcode
+   */
+  AV_PKT_DATA_H263_MB_INFO,
+
+  /**
+   * This side data should be associated with an audio stream and contains
+   * ReplayGain information in form of the AVReplayGain struct.
+   */
+  AV_PKT_DATA_REPLAYGAIN,
+
+  /**
+   * This side data contains a 3x3 transformation matrix describing an affine
+   * transformation that needs to be applied to the decoded video frames for
+   * correct presentation.
+   *
+   * See libavutil/display.h for a detailed description of the data.
+   */
+  AV_PKT_DATA_DISPLAYMATRIX,
+
+  /**
+   * This side data should be associated with a video stream and contains
+   * Stereoscopic 3D information in form of the AVStereo3D struct.
+   */
+  AV_PKT_DATA_STEREO3D,
+
+  /**
+   * This side data should be associated with an audio stream and corresponds
+   * to enum AVAudioServiceType.
+   */
+  AV_PKT_DATA_AUDIO_SERVICE_TYPE,
+
+  /**
+   * This side data contains quality related information from the encoder.
+   * @code
+   * u32le quality factor of the compressed frame. Allowed range is between 1
+   * (good) and FF_LAMBDA_MAX (bad). u8    picture type u8    error count u16
+   * reserved u64le[error count] sum of squared differences between encoder in
+   * and output
+   * @endcode
+   */
+  AV_PKT_DATA_QUALITY_STATS,
+
+  /**
+   * This side data contains an integer value representing the stream index
+   * of a "fallback" track.  A fallback track indicates an alternate
+   * track to use when the current track can not be decoded for some reason.
+   * e.g. no decoder available for codec.
+   */
+  AV_PKT_DATA_FALLBACK_TRACK,
+
+  /**
+   * This side data corresponds to the AVCPBProperties struct.
+   */
+  AV_PKT_DATA_CPB_PROPERTIES,
+
+  /**
+   * Recommmends skipping the specified number of samples
+   * @code
+   * u32le number of samples to skip from start of this packet
+   * u32le number of samples to skip from end of this packet
+   * u8    reason for start skip
+   * u8    reason for end   skip (0=padding silence, 1=convergence)
+   * @endcode
+   */
+  AV_PKT_DATA_SKIP_SAMPLES,
+
+  /**
+   * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
+   * the packet may contain "dual mono" audio specific to Japanese DTV
+   * and if it is true, recommends only the selected channel to be used.
+   * @code
+   * u8    selected channels (0=main/left, 1=sub/right, 2=both)
+   * @endcode
+   */
+  AV_PKT_DATA_JP_DUALMONO,
+
+  /**
+   * A list of zero terminated key/value strings. There is no end marker for
+   * the list, so it is required to rely on the side data size to stop.
+   */
+  AV_PKT_DATA_STRINGS_METADATA,
+
+  /**
+   * Subtitle event position
+   * @code
+   * u32le x1
+   * u32le y1
+   * u32le x2
+   * u32le y2
+   * @endcode
+   */
+  AV_PKT_DATA_SUBTITLE_POSITION,
+
+  /**
+   * Data found in BlockAdditional element of matroska container. There is
+   * no end marker for the data, so it is required to rely on the side data
+   * size to recognize the end. 8 byte id (as found in BlockAddId) followed
+   * by data.
+   */
+  AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
+
+  /**
+   * The optional first identifier line of a WebVTT cue.
+   */
+  AV_PKT_DATA_WEBVTT_IDENTIFIER,
+
+  /**
+   * The optional settings (rendering instructions) that immediately
+   * follow the timestamp specifier of a WebVTT cue.
+   */
+  AV_PKT_DATA_WEBVTT_SETTINGS,
+
+  /**
+   * A list of zero terminated key/value strings. There is no end marker for
+   * the list, so it is required to rely on the side data size to stop. This
+   * side data includes updated metadata which appeared in the stream.
+   */
+  AV_PKT_DATA_METADATA_UPDATE,
+
+  /**
+   * MPEGTS stream ID as uint8_t, this is required to pass the stream ID
+   * information from the demuxer to the corresponding muxer.
+   */
+  AV_PKT_DATA_MPEGTS_STREAM_ID,
+
+  /**
+   * Mastering display metadata (based on SMPTE-2086:2014). This metadata
+   * should be associated with a video stream and contains data in the form
+   * of the AVMasteringDisplayMetadata struct.
+   */
+  AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
+
+  /**
+   * This side data should be associated with a video stream and corresponds
+   * to the AVSphericalMapping structure.
+   */
+  AV_PKT_DATA_SPHERICAL,
+
+  /**
+   * Content light level (based on CTA-861.3). This metadata should be
+   * associated with a video stream and contains data in the form of the
+   * AVContentLightMetadata struct.
+   */
+  AV_PKT_DATA_CONTENT_LIGHT_LEVEL,
+
+  /**
+   * ATSC A53 Part 4 Closed Captions. This metadata should be associated with
+   * a video stream. A53 CC bitstream is stored as uint8_t in
+   * AVPacketSideData.data. The number of bytes of CC data is
+   * AVPacketSideData.size.
+   */
+  AV_PKT_DATA_A53_CC,
+
+  /**
+   * This side data is encryption initialization data.
+   * The format is not part of ABI, use av_encryption_init_info_* methods to
+   * access.
+   */
+  AV_PKT_DATA_ENCRYPTION_INIT_INFO,
+
+  /**
+   * This side data contains encryption info for how to decrypt the packet.
+   * The format is not part of ABI, use av_encryption_info_* methods to access.
+   */
+  AV_PKT_DATA_ENCRYPTION_INFO,
+
+  /**
+   * Active Format Description data consisting of a single byte as specified
+   * in ETSI TS 101 154 using AVActiveFormatDescription enum.
+   */
+  AV_PKT_DATA_AFD,
+
+  /**
+   * Producer Reference Time data corresponding to the AVProducerReferenceTime
+   * struct, usually exported by some encoders (on demand through the prft flag
+   * set in the AVCodecContext export_side_data field).
+   */
+  AV_PKT_DATA_PRFT,
+
+  /**
+   * ICC profile data consisting of an opaque octet buffer following the
+   * format described by ISO 15076-1.
+   */
+  AV_PKT_DATA_ICC_PROFILE,
+
+  /**
+   * DOVI configuration
+   * ref:
+   * dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2,
+   * section 2.2
+   * dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2,
+   * section 3.3 Tags are stored in struct AVDOVIDecoderConfigurationRecord.
+   */
+  AV_PKT_DATA_DOVI_CONF,
+
+  /**
+   * Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4
+   * uint32_t where the first uint32_t describes how many (1-3) of the other
+   * timecodes are used. The timecode format is described in the documentation
+   * of av_timecode_get_smpte_from_framenum() function in libavutil/timecode.h.
+   */
+  AV_PKT_DATA_S12M_TIMECODE,
+
+  /**
+   * HDR10+ dynamic metadata associated with a video frame. The metadata is in
+   * the form of the AVDynamicHDRPlus struct and contains
+   * information for color volume transform - application 4 of
+   * SMPTE 2094-40:2016 standard.
+   */
+  AV_PKT_DATA_DYNAMIC_HDR10_PLUS,
+
+  /**
+   * The number of side data types.
+   * This is not part of the public API/ABI in the sense that it may
+   * change when new side data types are added.
+   * This must stay the last enum value.
+   * If its value becomes huge, some code using it
+   * needs to be updated as it assumes it to be smaller than other limits.
+   */
+  AV_PKT_DATA_NB
+};
+
+#define AV_PKT_DATA_QUALITY_FACTOR AV_PKT_DATA_QUALITY_STATS  // DEPRECATED
+
+typedef struct AVPacketSideData {
+  uint8_t* data;
+  size_t size;
+  enum AVPacketSideDataType type;
+} AVPacketSideData;
+
+/**
+ * This structure stores compressed data. It is typically exported by demuxers
+ * and then passed as input to decoders, or received as output from encoders and
+ * then passed to muxers.
+ *
+ * For video, it should typically contain one compressed frame. For audio it may
+ * contain several compressed frames. Encoders are allowed to output empty
+ * packets, with no compressed data, containing only side data
+ * (e.g. to update some stream parameters at the end of encoding).
+ *
+ * The semantics of data ownership depends on the buf field.
+ * If it is set, the packet data is dynamically allocated and is
+ * valid indefinitely until a call to av_packet_unref() reduces the
+ * reference count to 0.
+ *
+ * If the buf field is not set av_packet_ref() would make a copy instead
+ * of increasing the reference count.
+ *
+ * The side data is always allocated with av_malloc(), copied by
+ * av_packet_ref() and freed by av_packet_unref().
+ *
+ * sizeof(AVPacket) being a part of the public ABI is deprecated. once
+ * av_init_packet() is removed, new packets will only be able to be allocated
+ * with av_packet_alloc(), and new fields may be added to the end of the struct
+ * with a minor bump.
+ *
+ * @see av_packet_alloc
+ * @see av_packet_ref
+ * @see av_packet_unref
+ */
+typedef struct AVPacket {
+  /**
+   * A reference to the reference-counted buffer where the packet data is
+   * stored.
+   * May be NULL, then the packet data is not reference-counted.
+   */
+  AVBufferRef* buf;
+  /**
+   * Presentation timestamp in AVStream->time_base units; the time at which
+   * the decompressed packet will be presented to the user.
+   * Can be AV_NOPTS_VALUE if it is not stored in the file.
+   * pts MUST be larger or equal to dts as presentation cannot happen before
+   * decompression, unless one wants to view hex dumps. Some formats misuse
+   * the terms dts and pts/cts to mean something different. Such timestamps
+   * must be converted to true pts/dts before they are stored in AVPacket.
+   */
+  int64_t pts;
+  /**
+   * Decompression timestamp in AVStream->time_base units; the time at which
+   * the packet is decompressed.
+   * Can be AV_NOPTS_VALUE if it is not stored in the file.
+   */
+  int64_t dts;
+  uint8_t* data;
+  int size;
+  int stream_index;
+  /**
+   * A combination of AV_PKT_FLAG values
+   */
+  int flags;
+  /**
+   * Additional packet data that can be provided by the container.
+   * Packet can contain several types of side information.
+   */
+  AVPacketSideData* side_data;
+  int side_data_elems;
+
+  /**
+   * Duration of this packet in AVStream->time_base units, 0 if unknown.
+   * Equals next_pts - this_pts in presentation order.
+   */
+  int64_t duration;
+
+  int64_t pos;  ///< byte position in stream, -1 if unknown
+
+  /**
+   * for some private data of the user
+   */
+  void* opaque;
+
+  /**
+   * AVBufferRef for free use by the API user. FFmpeg will never check the
+   * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
+   * the packet is unreferenced. av_packet_copy_props() calls create a new
+   * reference with av_buffer_ref() for the target packet's opaque_ref field.
+   *
+   * This is unrelated to the opaque field, although it serves a similar
+   * purpose.
+   */
+  AVBufferRef* opaque_ref;
+
+  /**
+   * Time base of the packet's timestamps.
+   * In the future, this field may be set on packets output by encoders or
+   * demuxers, but its value will be by default ignored on input to decoders
+   * or muxers.
+   */
+  AVRational time_base;
+} AVPacket;
+
+#if FF_API_INIT_PACKET
+attribute_deprecated typedef struct AVPacketList {
+  AVPacket pkt;
+  struct AVPacketList* next;
+} AVPacketList;
+#endif
+
+#define AV_PKT_FLAG_KEY 0x0001      ///< The packet contains a keyframe
+#define AV_PKT_FLAG_CORRUPT 0x0002  ///< The packet content is corrupted
+/**
+ * Flag is used to discard packets which are required to maintain valid
+ * decoder state but are not required for output and should be dropped
+ * after decoding.
+ **/
+#define AV_PKT_FLAG_DISCARD 0x0004
+/**
+ * The packet comes from a trusted source.
+ *
+ * Otherwise-unsafe constructs such as arbitrary pointers to data
+ * outside the packet may be followed.
+ */
+#define AV_PKT_FLAG_TRUSTED 0x0008
+/**
+ * Flag is used to indicate packets that contain frames that can
+ * be discarded by the decoder.  I.e. Non-reference frames.
+ */
+#define AV_PKT_FLAG_DISPOSABLE 0x0010
+
+enum AVSideDataParamChangeFlags {
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * @deprecated those are not used by any decoder
+   */
+  AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 0x0001,
+  AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002,
+#endif
+  AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 0x0004,
+  AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 0x0008,
+};
+
+/**
+ * Allocate an AVPacket and set its fields to default values.  The resulting
+ * struct must be freed using av_packet_free().
+ *
+ * @return An AVPacket filled with default values or NULL on failure.
+ *
+ * @note this only allocates the AVPacket itself, not the data buffers. Those
+ * must be allocated through other means such as av_new_packet.
+ *
+ * @see av_new_packet
+ */
+AVPacket* av_packet_alloc(void);
+
+/**
+ * Create a new packet that references the same data as src.
+ *
+ * This is a shortcut for av_packet_alloc()+av_packet_ref().
+ *
+ * @return newly created AVPacket on success, NULL on error.
+ *
+ * @see av_packet_alloc
+ * @see av_packet_ref
+ */
+AVPacket* av_packet_clone(const AVPacket* src);
+
+/**
+ * Free the packet, if the packet is reference counted, it will be
+ * unreferenced first.
+ *
+ * @param pkt packet to be freed. The pointer will be set to NULL.
+ * @note passing NULL is a no-op.
+ */
+void av_packet_free(AVPacket** pkt);
+
+#if FF_API_INIT_PACKET
+/**
+ * Initialize optional fields of a packet with default values.
+ *
+ * Note, this does not touch the data and size members, which have to be
+ * initialized separately.
+ *
+ * @param pkt packet
+ *
+ * @see av_packet_alloc
+ * @see av_packet_unref
+ *
+ * @deprecated This function is deprecated. Once it's removed,
+               sizeof(AVPacket) will not be a part of the ABI anymore.
+ */
+attribute_deprecated void av_init_packet(AVPacket* pkt);
+#endif
+
+/**
+ * Allocate the payload of a packet and initialize its fields with
+ * default values.
+ *
+ * @param pkt packet
+ * @param size wanted payload size
+ * @return 0 if OK, AVERROR_xxx otherwise
+ */
+int av_new_packet(AVPacket* pkt, int size);
+
+/**
+ * Reduce packet size, correctly zeroing padding
+ *
+ * @param pkt packet
+ * @param size new size
+ */
+void av_shrink_packet(AVPacket* pkt, int size);
+
+/**
+ * Increase packet size, correctly zeroing padding
+ *
+ * @param pkt packet
+ * @param grow_by number of bytes by which to increase the size of the packet
+ */
+int av_grow_packet(AVPacket* pkt, int grow_by);
+
+/**
+ * Initialize a reference-counted packet from av_malloc()ed data.
+ *
+ * @param pkt packet to be initialized. This function will set the data, size,
+ *        and buf fields, all others are left untouched.
+ * @param data Data allocated by av_malloc() to be used as packet data. If this
+ *        function returns successfully, the data is owned by the underlying
+ * AVBuffer. The caller may not access the data through other means.
+ * @param size size of data in bytes, without the padding. I.e. the full buffer
+ *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
+ *
+ * @return 0 on success, a negative AVERROR on error
+ */
+int av_packet_from_data(AVPacket* pkt, uint8_t* data, int size);
+
+/**
+ * Allocate new information of a packet.
+ *
+ * @param pkt packet
+ * @param type side information type
+ * @param size side information size
+ * @return pointer to fresh allocated data or NULL otherwise
+ */
+uint8_t* av_packet_new_side_data(AVPacket* pkt, enum AVPacketSideDataType type,
+                                 size_t size);
+
+/**
+ * Wrap an existing array as a packet side data.
+ *
+ * @param pkt packet
+ * @param type side information type
+ * @param data the side data array. It must be allocated with the av_malloc()
+ *             family of functions. The ownership of the data is transferred to
+ *             pkt.
+ * @param size side information size
+ * @return a non-negative number on success, a negative AVERROR code on
+ *         failure. On failure, the packet is unchanged and the data remains
+ *         owned by the caller.
+ */
+int av_packet_add_side_data(AVPacket* pkt, enum AVPacketSideDataType type,
+                            uint8_t* data, size_t size);
+
+/**
+ * Shrink the already allocated side data buffer
+ *
+ * @param pkt packet
+ * @param type side information type
+ * @param size new side information size
+ * @return 0 on success, < 0 on failure
+ */
+int av_packet_shrink_side_data(AVPacket* pkt, enum AVPacketSideDataType type,
+                               size_t size);
+
+/**
+ * Get side information from packet.
+ *
+ * @param pkt packet
+ * @param type desired side information type
+ * @param size If supplied, *size will be set to the size of the side data
+ *             or to zero if the desired side data is not present.
+ * @return pointer to data if present or NULL otherwise
+ */
+uint8_t* av_packet_get_side_data(const AVPacket* pkt,
+                                 enum AVPacketSideDataType type, size_t* size);
+
+const char* av_packet_side_data_name(enum AVPacketSideDataType type);
+
+/**
+ * Pack a dictionary for use in side_data.
+ *
+ * @param dict The dictionary to pack.
+ * @param size pointer to store the size of the returned data
+ * @return pointer to data if successful, NULL otherwise
+ */
+uint8_t* av_packet_pack_dictionary(AVDictionary* dict, size_t* size);
+/**
+ * Unpack a dictionary from side_data.
+ *
+ * @param data data from side_data
+ * @param size size of the data
+ * @param dict the metadata storage dictionary
+ * @return 0 on success, < 0 on failure
+ */
+int av_packet_unpack_dictionary(const uint8_t* data, size_t size,
+                                AVDictionary** dict);
+
+/**
+ * Convenience function to free all the side data stored.
+ * All the other fields stay untouched.
+ *
+ * @param pkt packet
+ */
+void av_packet_free_side_data(AVPacket* pkt);
+
+/**
+ * Setup a new reference to the data described by a given packet
+ *
+ * If src is reference-counted, setup dst as a new reference to the
+ * buffer in src. Otherwise allocate a new buffer in dst and copy the
+ * data from src into it.
+ *
+ * All the other fields are copied from src.
+ *
+ * @see av_packet_unref
+ *
+ * @param dst Destination packet. Will be completely overwritten.
+ * @param src Source packet
+ *
+ * @return 0 on success, a negative AVERROR on error. On error, dst
+ *         will be blank (as if returned by av_packet_alloc()).
+ */
+int av_packet_ref(AVPacket* dst, const AVPacket* src);
+
+/**
+ * Wipe the packet.
+ *
+ * Unreference the buffer referenced by the packet and reset the
+ * remaining packet fields to their default values.
+ *
+ * @param pkt The packet to be unreferenced.
+ */
+void av_packet_unref(AVPacket* pkt);
+
+/**
+ * Move every field in src to dst and reset src.
+ *
+ * @see av_packet_unref
+ *
+ * @param src Source packet, will be reset
+ * @param dst Destination packet
+ */
+void av_packet_move_ref(AVPacket* dst, AVPacket* src);
+
+/**
+ * Copy only "properties" fields from src to dst.
+ *
+ * Properties for the purpose of this function are all the fields
+ * beside those related to the packet data (buf, data, size)
+ *
+ * @param dst Destination packet
+ * @param src Source packet
+ *
+ * @return 0 on success AVERROR on failure.
+ */
+int av_packet_copy_props(AVPacket* dst, const AVPacket* src);
+
+/**
+ * Ensure the data described by a given packet is reference counted.
+ *
+ * @note This function does not ensure that the reference will be writable.
+ *       Use av_packet_make_writable instead for that purpose.
+ *
+ * @see av_packet_ref
+ * @see av_packet_make_writable
+ *
+ * @param pkt packet whose data should be made reference counted.
+ *
+ * @return 0 on success, a negative AVERROR on error. On failure, the
+ *         packet is unchanged.
+ */
+int av_packet_make_refcounted(AVPacket* pkt);
+
+/**
+ * Create a writable reference for the data described by a given packet,
+ * avoiding data copy if possible.
+ *
+ * @param pkt Packet whose data should be made writable.
+ *
+ * @return 0 on success, a negative AVERROR on failure. On failure, the
+ *         packet is unchanged.
+ */
+int av_packet_make_writable(AVPacket* pkt);
+
+/**
+ * Convert valid timing fields (timestamps / durations) in a packet from one
+ * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
+ * ignored.
+ *
+ * @param pkt packet on which the conversion will be performed
+ * @param tb_src source timebase, in which the timing fields in pkt are
+ *               expressed
+ * @param tb_dst destination timebase, to which the timing fields will be
+ *               converted
+ */
+void av_packet_rescale_ts(AVPacket* pkt, AVRational tb_src, AVRational tb_dst);
+
+/**
+ * @}
+ */
+
+#endif  // AVCODEC_PACKET_H
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/vdpau.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/vdpau.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/vdpau.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/vdpau.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,156 @@
+/*
+ * The Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VDPAU_H
+#define AVCODEC_VDPAU_H
+
+/**
+ * @file
+ * @ingroup lavc_codec_hwaccel_vdpau
+ * Public libavcodec VDPAU header.
+ */
+
+/**
+ * @defgroup lavc_codec_hwaccel_vdpau VDPAU Decoder and Renderer
+ * @ingroup lavc_codec_hwaccel
+ *
+ * VDPAU hardware acceleration has two modules
+ * - VDPAU decoding
+ * - VDPAU presentation
+ *
+ * The VDPAU decoding module parses all headers using FFmpeg
+ * parsing mechanisms and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding
+ * and rendering (API calls) are done as part of the VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ */
+
+#include <vdpau/vdpau.h>
+
+#include "libavutil/avconfig.h"
+#include "libavutil/attributes.h"
+
+#include "avcodec.h"
+
+struct AVCodecContext;
+struct AVFrame;
+
+typedef int (*AVVDPAU_Render2)(struct AVCodecContext*, struct AVFrame*,
+                               const VdpPictureInfo*, uint32_t,
+                               const VdpBitstreamBuffer*);
+
+/**
+ * This structure is used to share data between the libavcodec library and
+ * the client video application.
+ * The user shall allocate the structure via the av_alloc_vdpau_hwaccel
+ * function and make it available as
+ * AVCodecContext.hwaccel_context. Members can be set by the user once
+ * during initialization or through each AVCodecContext.get_buffer()
+ * function call. In any case, they must be valid prior to calling
+ * decoding functions.
+ *
+ * The size of this structure is not a part of the public ABI and must not
+ * be used outside of libavcodec. Use av_vdpau_alloc_context() to allocate an
+ * AVVDPAUContext.
+ */
+typedef struct AVVDPAUContext {
+  /**
+   * VDPAU decoder handle
+   *
+   * Set by user.
+   */
+  VdpDecoder decoder;
+
+  /**
+   * VDPAU decoder render callback
+   *
+   * Set by the user.
+   */
+  VdpDecoderRender* render;
+
+  AVVDPAU_Render2 render2;
+} AVVDPAUContext;
+
+/**
+ * @brief allocation function for AVVDPAUContext
+ *
+ * Allows extending the struct without breaking API/ABI
+ */
+AVVDPAUContext* av_alloc_vdpaucontext(void);
+
+AVVDPAU_Render2 av_vdpau_hwaccel_get_render2(const AVVDPAUContext*);
+void av_vdpau_hwaccel_set_render2(AVVDPAUContext*, AVVDPAU_Render2);
+
+/**
+ * Associate a VDPAU device with a codec context for hardware acceleration.
+ * This function is meant to be called from the get_format() codec callback,
+ * or earlier. It can also be called after avcodec_flush_buffers() to change
+ * the underlying VDPAU device mid-stream (e.g. to recover from non-transparent
+ * display preemption).
+ *
+ * @note get_format() must return AV_PIX_FMT_VDPAU if this function completes
+ * successfully.
+ *
+ * @param avctx decoding context whose get_format() callback is invoked
+ * @param device VDPAU device handle to use for hardware acceleration
+ * @param get_proc_address VDPAU device driver
+ * @param flags zero of more OR'd AV_HWACCEL_FLAG_* flags
+ *
+ * @return 0 on success, an AVERROR code on failure.
+ */
+int av_vdpau_bind_context(AVCodecContext* avctx, VdpDevice device,
+                          VdpGetProcAddress* get_proc_address, unsigned flags);
+
+/**
+ * Gets the parameters to create an adequate VDPAU video surface for the codec
+ * context using VDPAU hardware decoding acceleration.
+ *
+ * @note Behavior is undefined if the context was not successfully bound to a
+ * VDPAU device using av_vdpau_bind_context().
+ *
+ * @param avctx the codec context being used for decoding the stream
+ * @param type storage space for the VDPAU video surface chroma type
+ *              (or NULL to ignore)
+ * @param width storage space for the VDPAU video surface pixel width
+ *              (or NULL to ignore)
+ * @param height storage space for the VDPAU video surface pixel height
+ *              (or NULL to ignore)
+ *
+ * @return 0 on success, a negative AVERROR code on failure.
+ */
+int av_vdpau_get_surface_parameters(AVCodecContext* avctx, VdpChromaType* type,
+                                    uint32_t* width, uint32_t* height);
+
+/**
+ * Allocate an AVVDPAUContext.
+ *
+ * @return Newly-allocated AVVDPAUContext or NULL on failure.
+ */
+AVVDPAUContext* av_vdpau_alloc_context(void);
+
+/** @} */
+
+#endif /* AVCODEC_VDPAU_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,45 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VERSION_H
+#define AVCODEC_VERSION_H
+
+/**
+ * @file
+ * @ingroup libavc
+ * Libavcodec version macros.
+ */
+
+#include "libavutil/version.h"
+
+#include "version_major.h"
+
+#define LIBAVCODEC_VERSION_MINOR 5
+#define LIBAVCODEC_VERSION_MICRO 100
+
+#define LIBAVCODEC_VERSION_INT                                       \
+  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, \
+                 LIBAVCODEC_VERSION_MICRO)
+#define LIBAVCODEC_VERSION                                       \
+  AV_VERSION(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, \
+             LIBAVCODEC_VERSION_MICRO)
+#define LIBAVCODEC_BUILD LIBAVCODEC_VERSION_INT
+
+#define LIBAVCODEC_IDENT "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
+
+#endif /* AVCODEC_VERSION_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version_major.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version_major.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version_major.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavcodec/version_major.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,52 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VERSION_MAJOR_H
+#define AVCODEC_VERSION_MAJOR_H
+
+/**
+ * @file
+ * @ingroup libavc
+ * Libavcodec version macros.
+ */
+
+#define LIBAVCODEC_VERSION_MAJOR 60
+
+/**
+ * FF_API_* defines may be placed below to indicate public API that will be
+ * dropped at a future version bump. The defines themselves are not part of
+ * the public API and may change, break or disappear at any time.
+ *
+ * @note, when bumping the major version it is recommended to manually
+ * disable each FF_API_* in its own commit instead of disabling them all
+ * at once through the bump. This improves the git bisect-ability of the change.
+ */
+
+#define FF_API_INIT_PACKET (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_IDCT_NONE (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_SVTAV1_OPTS (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AYUV_CODECID (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_VT_OUTPUT_CALLBACK (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AVCODEC_CHROMA_POS (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_VT_HWACCEL_CONTEXT (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AVCTX_FRAME_NUMBER (LIBAVCODEC_VERSION_MAJOR < 61)
+
+// reminder to remove CrystalHD decoders on next major bump
+#define FF_CODEC_CRYSTAL_HD (LIBAVCODEC_VERSION_MAJOR < 61)
+
+#endif /* AVCODEC_VERSION_MAJOR_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/attributes.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/attributes.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/attributes.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/attributes.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,173 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Macro definitions for various function/variable attributes
+ */
+
+#ifndef AVUTIL_ATTRIBUTES_H
+#define AVUTIL_ATTRIBUTES_H
+
+#ifdef __GNUC__
+#  define AV_GCC_VERSION_AT_LEAST(x, y) \
+    (__GNUC__ > (x) || __GNUC__ == (x) && __GNUC_MINOR__ >= (y))
+#  define AV_GCC_VERSION_AT_MOST(x, y) \
+    (__GNUC__ < (x) || __GNUC__ == (x) && __GNUC_MINOR__ <= (y))
+#else
+#  define AV_GCC_VERSION_AT_LEAST(x, y) 0
+#  define AV_GCC_VERSION_AT_MOST(x, y) 0
+#endif
+
+#ifdef __has_builtin
+#  define AV_HAS_BUILTIN(x) __has_builtin(x)
+#else
+#  define AV_HAS_BUILTIN(x) 0
+#endif
+
+#ifndef av_always_inline
+#  if AV_GCC_VERSION_AT_LEAST(3, 1)
+#    define av_always_inline __attribute__((always_inline)) inline
+#  elif defined(_MSC_VER)
+#    define av_always_inline __forceinline
+#  else
+#    define av_always_inline inline
+#  endif
+#endif
+
+#ifndef av_extern_inline
+#  if defined(__ICL) && __ICL >= 1210 || defined(__GNUC_STDC_INLINE__)
+#    define av_extern_inline extern inline
+#  else
+#    define av_extern_inline inline
+#  endif
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(3, 4)
+#  define av_warn_unused_result __attribute__((warn_unused_result))
+#else
+#  define av_warn_unused_result
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(3, 1)
+#  define av_noinline __attribute__((noinline))
+#elif defined(_MSC_VER)
+#  define av_noinline __declspec(noinline)
+#else
+#  define av_noinline
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(3, 1) || defined(__clang__)
+#  define av_pure __attribute__((pure))
+#else
+#  define av_pure
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(2, 6) || defined(__clang__)
+#  define av_const __attribute__((const))
+#else
+#  define av_const
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(4, 3) || defined(__clang__)
+#  define av_cold __attribute__((cold))
+#else
+#  define av_cold
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(4, 1) && !defined(__llvm__)
+#  define av_flatten __attribute__((flatten))
+#else
+#  define av_flatten
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(3, 1)
+#  define attribute_deprecated __attribute__((deprecated))
+#elif defined(_MSC_VER)
+#  define attribute_deprecated __declspec(deprecated)
+#else
+#  define attribute_deprecated
+#endif
+
+/**
+ * Disable warnings about deprecated features
+ * This is useful for sections of code kept for backward compatibility and
+ * scheduled for removal.
+ */
+#ifndef AV_NOWARN_DEPRECATED
+#  if AV_GCC_VERSION_AT_LEAST(4, 6) || defined(__clang__)
+#    define AV_NOWARN_DEPRECATED(code)                                    \
+      _Pragma("GCC diagnostic push")                                      \
+          _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") \
+              code _Pragma("GCC diagnostic pop")
+#  elif defined(_MSC_VER)
+#    define AV_NOWARN_DEPRECATED(code)                                \
+      __pragma(warning(push)) __pragma(warning(disable : 4996)) code; \
+      __pragma(warning(pop))
+#  else
+#    define AV_NOWARN_DEPRECATED(code) code
+#  endif
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#  define av_unused __attribute__((unused))
+#else
+#  define av_unused
+#endif
+
+/**
+ * Mark a variable as used and prevent the compiler from optimizing it
+ * away.  This is useful for variables accessed only from inline
+ * assembler without the compiler being aware.
+ */
+#if AV_GCC_VERSION_AT_LEAST(3, 1) || defined(__clang__)
+#  define av_used __attribute__((used))
+#else
+#  define av_used
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(3, 3) || defined(__clang__)
+#  define av_alias __attribute__((may_alias))
+#else
+#  define av_alias
+#endif
+
+#if (defined(__GNUC__) || defined(__clang__)) && !defined(__INTEL_COMPILER)
+#  define av_uninit(x) x = x
+#else
+#  define av_uninit(x) x
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#  define av_builtin_constant_p __builtin_constant_p
+#  define av_printf_format(fmtpos, attrpos) \
+    __attribute__((__format__(__printf__, fmtpos, attrpos)))
+#else
+#  define av_builtin_constant_p(x) 0
+#  define av_printf_format(fmtpos, attrpos)
+#endif
+
+#if AV_GCC_VERSION_AT_LEAST(2, 5) || defined(__clang__)
+#  define av_noreturn __attribute__((noreturn))
+#else
+#  define av_noreturn
+#endif
+
+#endif /* AVUTIL_ATTRIBUTES_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avconfig.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avconfig.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avconfig.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,6 @@
+/* Generated by ffmpeg configure */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+#define AV_HAVE_BIGENDIAN 0
+#define AV_HAVE_FAST_UNALIGNED 1
+#endif /* AVUTIL_AVCONFIG_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avutil.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avutil.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avutil.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/avutil.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,371 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_AVUTIL_H
+#define AVUTIL_AVUTIL_H
+
+/**
+ * @file
+ * @ingroup lavu
+ * Convenience header that includes @ref lavu "libavutil"'s core.
+ */
+
+/**
+ * @mainpage
+ *
+ * @section ffmpeg_intro Introduction
+ *
+ * This document describes the usage of the different libraries
+ * provided by FFmpeg.
+ *
+ * @li @ref libavc "libavcodec" encoding/decoding library
+ * @li @ref lavfi "libavfilter" graph-based frame editing library
+ * @li @ref libavf "libavformat" I/O and muxing/demuxing library
+ * @li @ref lavd "libavdevice" special devices muxing/demuxing library
+ * @li @ref lavu "libavutil" common utility library
+ * @li @ref lswr "libswresample" audio resampling, format conversion and mixing
+ * @li @ref lpp  "libpostproc" post processing library
+ * @li @ref libsws "libswscale" color conversion and scaling library
+ *
+ * @section ffmpeg_versioning Versioning and compatibility
+ *
+ * Each of the FFmpeg libraries contains a version.h header, which defines a
+ * major, minor and micro version number with the
+ * <em>LIBRARYNAME_VERSION_{MAJOR,MINOR,MICRO}</em> macros. The major version
+ * number is incremented with backward incompatible changes - e.g. removing
+ * parts of the public API, reordering public struct members, etc. The minor
+ * version number is incremented for backward compatible API changes or major
+ * new features - e.g. adding a new public function or a new decoder. The micro
+ * version number is incremented for smaller changes that a calling program
+ * might still want to check for - e.g. changing behavior in a previously
+ * unspecified situation.
+ *
+ * FFmpeg guarantees backward API and ABI compatibility for each library as long
+ * as its major version number is unchanged. This means that no public symbols
+ * will be removed or renamed. Types and names of the public struct members and
+ * values of public macros and enums will remain the same (unless they were
+ * explicitly declared as not part of the public API). Documented behavior will
+ * not change.
+ *
+ * In other words, any correct program that works with a given FFmpeg snapshot
+ * should work just as well without any changes with any later snapshot with the
+ * same major versions. This applies to both rebuilding the program against new
+ * FFmpeg versions or to replacing the dynamic FFmpeg libraries that a program
+ * links against.
+ *
+ * However, new public symbols may be added and new members may be appended to
+ * public structs whose size is not part of public ABI (most public structs in
+ * FFmpeg). New macros and enum values may be added. Behavior in undocumented
+ * situations may change slightly (and be documented). All those are accompanied
+ * by an entry in doc/APIchanges and incrementing either the minor or micro
+ * version number.
+ */
+
+/**
+ * @defgroup lavu libavutil
+ * Common code shared across all FFmpeg libraries.
+ *
+ * @note
+ * libavutil is designed to be modular. In most cases, in order to use the
+ * functions provided by one component of libavutil you must explicitly include
+ * the specific header containing that feature. If you are only using
+ * media-related components, you could simply include libavutil/avutil.h, which
+ * brings in most of the "core" components.
+ *
+ * @{
+ *
+ * @defgroup lavu_crypto Crypto and Hashing
+ *
+ * @{
+ * @}
+ *
+ * @defgroup lavu_math Mathematics
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_string String Manipulation
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_mem Memory Management
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_data Data Structures
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_video Video related
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_audio Audio related
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_error Error Codes
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_log Logging Facility
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup lavu_misc Other
+ *
+ * @{
+ *
+ * @defgroup preproc_misc Preprocessor String Macros
+ *
+ * @{
+ *
+ * @}
+ *
+ * @defgroup version_utils Library Version Macros
+ *
+ * @{
+ *
+ * @}
+ */
+
+/**
+ * @addtogroup lavu_ver
+ * @{
+ */
+
+/**
+ * Return the LIBAVUTIL_VERSION_INT constant.
+ */
+unsigned avutil_version(void);
+
+/**
+ * Return an informative version string. This usually is the actual release
+ * version number or a git commit description. This string has no fixed format
+ * and can change any time. It should never be parsed by code.
+ */
+const char* av_version_info(void);
+
+/**
+ * Return the libavutil build-time configuration.
+ */
+const char* avutil_configuration(void);
+
+/**
+ * Return the libavutil license.
+ */
+const char* avutil_license(void);
+
+/**
+ * @}
+ */
+
+/**
+ * @addtogroup lavu_media Media Type
+ * @brief Media Type
+ */
+
+enum AVMediaType {
+  AVMEDIA_TYPE_UNKNOWN = -1,  ///< Usually treated as AVMEDIA_TYPE_DATA
+  AVMEDIA_TYPE_VIDEO,
+  AVMEDIA_TYPE_AUDIO,
+  AVMEDIA_TYPE_DATA,  ///< Opaque data information usually continuous
+  AVMEDIA_TYPE_SUBTITLE,
+  AVMEDIA_TYPE_ATTACHMENT,  ///< Opaque data information usually sparse
+  AVMEDIA_TYPE_NB
+};
+
+/**
+ * Return a string describing the media_type enum, NULL if media_type
+ * is unknown.
+ */
+const char* av_get_media_type_string(enum AVMediaType media_type);
+
+/**
+ * @defgroup lavu_const Constants
+ * @{
+ *
+ * @defgroup lavu_enc Encoding specific
+ *
+ * @note those definition should move to avcodec
+ * @{
+ */
+
+#define FF_LAMBDA_SHIFT 7
+#define FF_LAMBDA_SCALE (1 << FF_LAMBDA_SHIFT)
+#define FF_QP2LAMBDA 118  ///< factor to convert from H.263 QP to lambda
+#define FF_LAMBDA_MAX (256 * 128 - 1)
+
+#define FF_QUALITY_SCALE FF_LAMBDA_SCALE  // FIXME maybe remove
+
+/**
+ * @}
+ * @defgroup lavu_time Timestamp specific
+ *
+ * FFmpeg internal timebase and timestamp definitions
+ *
+ * @{
+ */
+
+/**
+ * @brief Undefined timestamp value
+ *
+ * Usually reported by demuxer that work on containers that do not provide
+ * either pts or dts.
+ */
+
+#define AV_NOPTS_VALUE ((int64_t)UINT64_C(0x8000000000000000))
+
+/**
+ * Internal time base represented as integer
+ */
+
+#define AV_TIME_BASE 1000000
+
+/**
+ * Internal time base represented as fractional value
+ */
+
+#define AV_TIME_BASE_Q \
+  (AVRational) { 1, AV_TIME_BASE }
+
+/**
+ * @}
+ * @}
+ * @defgroup lavu_picture Image related
+ *
+ * AVPicture types, pixel formats and basic image planes manipulation.
+ *
+ * @{
+ */
+
+enum AVPictureType {
+  AV_PICTURE_TYPE_NONE = 0,  ///< Undefined
+  AV_PICTURE_TYPE_I,         ///< Intra
+  AV_PICTURE_TYPE_P,         ///< Predicted
+  AV_PICTURE_TYPE_B,         ///< Bi-dir predicted
+  AV_PICTURE_TYPE_S,         ///< S(GMC)-VOP MPEG-4
+  AV_PICTURE_TYPE_SI,        ///< Switching Intra
+  AV_PICTURE_TYPE_SP,        ///< Switching Predicted
+  AV_PICTURE_TYPE_BI,        ///< BI type
+};
+
+/**
+ * Return a single letter to describe the given picture type
+ * pict_type.
+ *
+ * @param[in] pict_type the picture type @return a single character
+ * representing the picture type, '?' if pict_type is unknown
+ */
+char av_get_picture_type_char(enum AVPictureType pict_type);
+
+/**
+ * @}
+ */
+
+#include "common.h"
+#include "error.h"
+#include "rational.h"
+#include "version.h"
+#include "macros.h"
+#include "mathematics.h"
+#include "log.h"
+#include "pixfmt.h"
+
+/**
+ * Return x default pointer in case p is NULL.
+ */
+static inline void* av_x_if_null(const void* p, const void* x) {
+  return (void*)(intptr_t)(p ? p : x);
+}
+
+/**
+ * Compute the length of an integer list.
+ *
+ * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
+ * @param term    list terminator (usually 0 or -1)
+ * @param list    pointer to the list
+ * @return  length of the list, in elements, not counting the terminator
+ */
+unsigned av_int_list_length_for_size(unsigned elsize, const void* list,
+                                     uint64_t term) av_pure;
+
+/**
+ * Compute the length of an integer list.
+ *
+ * @param term  list terminator (usually 0 or -1)
+ * @param list  pointer to the list
+ * @return  length of the list, in elements, not counting the terminator
+ */
+#define av_int_list_length(list, term) \
+  av_int_list_length_for_size(sizeof(*(list)), list, term)
+
+#if FF_API_AV_FOPEN_UTF8
+/**
+ * Open a file using a UTF-8 filename.
+ * The API of this function matches POSIX fopen(), errors are returned through
+ * errno.
+ * @deprecated Avoid using it, as on Windows, the FILE* allocated by this
+ *             function may be allocated with a different CRT than the caller
+ *             who uses the FILE*. No replacement provided in public API.
+ */
+attribute_deprecated FILE* av_fopen_utf8(const char* path, const char* mode);
+#endif
+
+/**
+ * Return the fractional representation of the internal time base.
+ */
+AVRational av_get_time_base_q(void);
+
+#define AV_FOURCC_MAX_STRING_SIZE 32
+
+#define av_fourcc2str(fourcc) \
+  av_fourcc_make_string((char[AV_FOURCC_MAX_STRING_SIZE]){0}, fourcc)
+
+/**
+ * Fill the provided buffer with a string containing a FourCC (four-character
+ * code) representation.
+ *
+ * @param buf    a buffer with size in bytes of at least
+ * AV_FOURCC_MAX_STRING_SIZE
+ * @param fourcc the fourcc to represent
+ * @return the buffer in input
+ */
+char* av_fourcc_make_string(char* buf, uint32_t fourcc);
+
+/**
+ * @}
+ * @}
+ */
+
+#endif /* AVUTIL_AVUTIL_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/buffer.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/buffer.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/buffer.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/buffer.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,324 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @ingroup lavu_buffer
+ * refcounted data buffer API
+ */
+
+#ifndef AVUTIL_BUFFER_H
+#define AVUTIL_BUFFER_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+/**
+ * @defgroup lavu_buffer AVBuffer
+ * @ingroup lavu_data
+ *
+ * @{
+ * AVBuffer is an API for reference-counted data buffers.
+ *
+ * There are two core objects in this API -- AVBuffer and AVBufferRef. AVBuffer
+ * represents the data buffer itself; it is opaque and not meant to be accessed
+ * by the caller directly, but only through AVBufferRef. However, the caller may
+ * e.g. compare two AVBuffer pointers to check whether two different references
+ * are describing the same data buffer. AVBufferRef represents a single
+ * reference to an AVBuffer and it is the object that may be manipulated by the
+ * caller directly.
+ *
+ * There are two functions provided for creating a new AVBuffer with a single
+ * reference -- av_buffer_alloc() to just allocate a new buffer, and
+ * av_buffer_create() to wrap an existing array in an AVBuffer. From an existing
+ * reference, additional references may be created with av_buffer_ref().
+ * Use av_buffer_unref() to free a reference (this will automatically free the
+ * data once all the references are freed).
+ *
+ * The convention throughout this API and the rest of FFmpeg is such that the
+ * buffer is considered writable if there exists only one reference to it (and
+ * it has not been marked as read-only). The av_buffer_is_writable() function is
+ * provided to check whether this is true and av_buffer_make_writable() will
+ * automatically create a new writable buffer when necessary.
+ * Of course nothing prevents the calling code from violating this convention,
+ * however that is safe only when all the existing references are under its
+ * control.
+ *
+ * @note Referencing and unreferencing the buffers is thread-safe and thus
+ * may be done from multiple threads simultaneously without any need for
+ * additional locking.
+ *
+ * @note Two different references to the same buffer can point to different
+ * parts of the buffer (i.e. their AVBufferRef.data will not be equal).
+ */
+
+/**
+ * A reference counted buffer type. It is opaque and is meant to be used through
+ * references (AVBufferRef).
+ */
+typedef struct AVBuffer AVBuffer;
+
+/**
+ * A reference to a data buffer.
+ *
+ * The size of this struct is not a part of the public ABI and it is not meant
+ * to be allocated directly.
+ */
+typedef struct AVBufferRef {
+  AVBuffer* buffer;
+
+  /**
+   * The data buffer. It is considered writable if and only if
+   * this is the only reference to the buffer, in which case
+   * av_buffer_is_writable() returns 1.
+   */
+  uint8_t* data;
+  /**
+   * Size of data in bytes.
+   */
+  size_t size;
+} AVBufferRef;
+
+/**
+ * Allocate an AVBuffer of the given size using av_malloc().
+ *
+ * @return an AVBufferRef of given size or NULL when out of memory
+ */
+AVBufferRef* av_buffer_alloc(size_t size);
+
+/**
+ * Same as av_buffer_alloc(), except the returned buffer will be initialized
+ * to zero.
+ */
+AVBufferRef* av_buffer_allocz(size_t size);
+
+/**
+ * Always treat the buffer as read-only, even when it has only one
+ * reference.
+ */
+#define AV_BUFFER_FLAG_READONLY (1 << 0)
+
+/**
+ * Create an AVBuffer from an existing array.
+ *
+ * If this function is successful, data is owned by the AVBuffer. The caller may
+ * only access data through the returned AVBufferRef and references derived from
+ * it.
+ * If this function fails, data is left untouched.
+ * @param data   data array
+ * @param size   size of data in bytes
+ * @param free   a callback for freeing this buffer's data
+ * @param opaque parameter to be got for processing or passed to free
+ * @param flags  a combination of AV_BUFFER_FLAG_*
+ *
+ * @return an AVBufferRef referring to data on success, NULL on failure.
+ */
+AVBufferRef* av_buffer_create(uint8_t* data, size_t size,
+                              void (*free)(void* opaque, uint8_t* data),
+                              void* opaque, int flags);
+
+/**
+ * Default free callback, which calls av_free() on the buffer data.
+ * This function is meant to be passed to av_buffer_create(), not called
+ * directly.
+ */
+void av_buffer_default_free(void* opaque, uint8_t* data);
+
+/**
+ * Create a new reference to an AVBuffer.
+ *
+ * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
+ * failure.
+ */
+AVBufferRef* av_buffer_ref(const AVBufferRef* buf);
+
+/**
+ * Free a given reference and automatically free the buffer if there are no more
+ * references to it.
+ *
+ * @param buf the reference to be freed. The pointer is set to NULL on return.
+ */
+void av_buffer_unref(AVBufferRef** buf);
+
+/**
+ * @return 1 if the caller may write to the data referred to by buf (which is
+ * true if and only if buf is the only reference to the underlying AVBuffer).
+ * Return 0 otherwise.
+ * A positive answer is valid until av_buffer_ref() is called on buf.
+ */
+int av_buffer_is_writable(const AVBufferRef* buf);
+
+/**
+ * @return the opaque parameter set by av_buffer_create.
+ */
+void* av_buffer_get_opaque(const AVBufferRef* buf);
+
+int av_buffer_get_ref_count(const AVBufferRef* buf);
+
+/**
+ * Create a writable reference from a given buffer reference, avoiding data copy
+ * if possible.
+ *
+ * @param buf buffer reference to make writable. On success, buf is either left
+ *            untouched, or it is unreferenced and a new writable AVBufferRef is
+ *            written in its place. On failure, buf is left untouched.
+ * @return 0 on success, a negative AVERROR on failure.
+ */
+int av_buffer_make_writable(AVBufferRef** buf);
+
+/**
+ * Reallocate a given buffer.
+ *
+ * @param buf  a buffer reference to reallocate. On success, buf will be
+ *             unreferenced and a new reference with the required size will be
+ *             written in its place. On failure buf will be left untouched. *buf
+ *             may be NULL, then a new buffer is allocated.
+ * @param size required new buffer size.
+ * @return 0 on success, a negative AVERROR on failure.
+ *
+ * @note the buffer is actually reallocated with av_realloc() only if it was
+ * initially allocated through av_buffer_realloc(NULL) and there is only one
+ * reference to it (i.e. the one passed to this function). In all other cases
+ * a new buffer is allocated and the data is copied.
+ */
+int av_buffer_realloc(AVBufferRef** buf, size_t size);
+
+/**
+ * Ensure dst refers to the same data as src.
+ *
+ * When *dst is already equivalent to src, do nothing. Otherwise unreference dst
+ * and replace it with a new reference to src.
+ *
+ * @param dst Pointer to either a valid buffer reference or NULL. On success,
+ *            this will point to a buffer reference equivalent to src. On
+ *            failure, dst will be left untouched.
+ * @param src A buffer reference to replace dst with. May be NULL, then this
+ *            function is equivalent to av_buffer_unref(dst).
+ * @return 0 on success
+ *         AVERROR(ENOMEM) on memory allocation failure.
+ */
+int av_buffer_replace(AVBufferRef** dst, const AVBufferRef* src);
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lavu_bufferpool AVBufferPool
+ * @ingroup lavu_data
+ *
+ * @{
+ * AVBufferPool is an API for a lock-free thread-safe pool of AVBuffers.
+ *
+ * Frequently allocating and freeing large buffers may be slow. AVBufferPool is
+ * meant to solve this in cases when the caller needs a set of buffers of the
+ * same size (the most obvious use case being buffers for raw video or audio
+ * frames).
+ *
+ * At the beginning, the user must call av_buffer_pool_init() to create the
+ * buffer pool. Then whenever a buffer is needed, call av_buffer_pool_get() to
+ * get a reference to a new buffer, similar to av_buffer_alloc(). This new
+ * reference works in all aspects the same way as the one created by
+ * av_buffer_alloc(). However, when the last reference to this buffer is
+ * unreferenced, it is returned to the pool instead of being freed and will be
+ * reused for subsequent av_buffer_pool_get() calls.
+ *
+ * When the caller is done with the pool and no longer needs to allocate any new
+ * buffers, av_buffer_pool_uninit() must be called to mark the pool as freeable.
+ * Once all the buffers are released, it will automatically be freed.
+ *
+ * Allocating and releasing buffers with this API is thread-safe as long as
+ * either the default alloc callback is used, or the user-supplied one is
+ * thread-safe.
+ */
+
+/**
+ * The buffer pool. This structure is opaque and not meant to be accessed
+ * directly. It is allocated with av_buffer_pool_init() and freed with
+ * av_buffer_pool_uninit().
+ */
+typedef struct AVBufferPool AVBufferPool;
+
+/**
+ * Allocate and initialize a buffer pool.
+ *
+ * @param size size of each buffer in this pool
+ * @param alloc a function that will be used to allocate new buffers when the
+ * pool is empty. May be NULL, then the default allocator will be used
+ * (av_buffer_alloc()).
+ * @return newly created buffer pool on success, NULL on error.
+ */
+AVBufferPool* av_buffer_pool_init(size_t size,
+                                  AVBufferRef* (*alloc)(size_t size));
+
+/**
+ * Allocate and initialize a buffer pool with a more complex allocator.
+ *
+ * @param size size of each buffer in this pool
+ * @param opaque arbitrary user data used by the allocator
+ * @param alloc a function that will be used to allocate new buffers when the
+ *              pool is empty. May be NULL, then the default allocator will be
+ *              used (av_buffer_alloc()).
+ * @param pool_free a function that will be called immediately before the pool
+ *                  is freed. I.e. after av_buffer_pool_uninit() is called
+ *                  by the caller and all the frames are returned to the pool
+ *                  and freed. It is intended to uninitialize the user opaque
+ *                  data. May be NULL.
+ * @return newly created buffer pool on success, NULL on error.
+ */
+AVBufferPool* av_buffer_pool_init2(size_t size, void* opaque,
+                                   AVBufferRef* (*alloc)(void* opaque,
+                                                         size_t size),
+                                   void (*pool_free)(void* opaque));
+
+/**
+ * Mark the pool as being available for freeing. It will actually be freed only
+ * once all the allocated buffers associated with the pool are released. Thus it
+ * is safe to call this function while some of the allocated buffers are still
+ * in use.
+ *
+ * @param pool pointer to the pool to be freed. It will be set to NULL.
+ */
+void av_buffer_pool_uninit(AVBufferPool** pool);
+
+/**
+ * Allocate a new AVBuffer, reusing an old buffer from the pool when available.
+ * This function may be called simultaneously from multiple threads.
+ *
+ * @return a reference to the new buffer on success, NULL on error.
+ */
+AVBufferRef* av_buffer_pool_get(AVBufferPool* pool);
+
+/**
+ * Query the original opaque parameter of an allocated buffer in the pool.
+ *
+ * @param ref a buffer reference to a buffer returned by av_buffer_pool_get.
+ * @return the opaque parameter set by the buffer allocator function of the
+ *         buffer pool.
+ *
+ * @note the opaque parameter of ref is used by the buffer pool implementation,
+ * therefore you have to use this function to access the original opaque
+ * parameter of an allocated buffer.
+ */
+void* av_buffer_pool_buffer_get_opaque(const AVBufferRef* ref);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_BUFFER_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/channel_layout.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/channel_layout.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/channel_layout.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/channel_layout.h	2023-04-06 12:57:00.771081640 +0200
@@ -0,0 +1,842 @@
+/*
+ * Copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ * Copyright (c) 2008 Peter Ross
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_CHANNEL_LAYOUT_H
+#define AVUTIL_CHANNEL_LAYOUT_H
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "version.h"
+#include "attributes.h"
+
+/**
+ * @file
+ * @ingroup lavu_audio_channels
+ * Public libavutil channel layout APIs header.
+ */
+
+/**
+ * @defgroup lavu_audio_channels Audio channels
+ * @ingroup lavu_audio
+ *
+ * Audio channel layout utility functions
+ *
+ * @{
+ */
+
+enum AVChannel {
+  ///< Invalid channel index
+  AV_CHAN_NONE = -1,
+  AV_CHAN_FRONT_LEFT,
+  AV_CHAN_FRONT_RIGHT,
+  AV_CHAN_FRONT_CENTER,
+  AV_CHAN_LOW_FREQUENCY,
+  AV_CHAN_BACK_LEFT,
+  AV_CHAN_BACK_RIGHT,
+  AV_CHAN_FRONT_LEFT_OF_CENTER,
+  AV_CHAN_FRONT_RIGHT_OF_CENTER,
+  AV_CHAN_BACK_CENTER,
+  AV_CHAN_SIDE_LEFT,
+  AV_CHAN_SIDE_RIGHT,
+  AV_CHAN_TOP_CENTER,
+  AV_CHAN_TOP_FRONT_LEFT,
+  AV_CHAN_TOP_FRONT_CENTER,
+  AV_CHAN_TOP_FRONT_RIGHT,
+  AV_CHAN_TOP_BACK_LEFT,
+  AV_CHAN_TOP_BACK_CENTER,
+  AV_CHAN_TOP_BACK_RIGHT,
+  /** Stereo downmix. */
+  AV_CHAN_STEREO_LEFT = 29,
+  /** See above. */
+  AV_CHAN_STEREO_RIGHT,
+  AV_CHAN_WIDE_LEFT,
+  AV_CHAN_WIDE_RIGHT,
+  AV_CHAN_SURROUND_DIRECT_LEFT,
+  AV_CHAN_SURROUND_DIRECT_RIGHT,
+  AV_CHAN_LOW_FREQUENCY_2,
+  AV_CHAN_TOP_SIDE_LEFT,
+  AV_CHAN_TOP_SIDE_RIGHT,
+  AV_CHAN_BOTTOM_FRONT_CENTER,
+  AV_CHAN_BOTTOM_FRONT_LEFT,
+  AV_CHAN_BOTTOM_FRONT_RIGHT,
+
+  /** Channel is empty can be safely skipped. */
+  AV_CHAN_UNUSED = 0x200,
+
+  /** Channel contains data, but its position is unknown. */
+  AV_CHAN_UNKNOWN = 0x300,
+
+  /**
+   * Range of channels between AV_CHAN_AMBISONIC_BASE and
+   * AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.
+   *
+   * Given a channel id `<i>` between AV_CHAN_AMBISONIC_BASE and
+   * AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel `<n>` is
+   * `<n> = <i> - AV_CHAN_AMBISONIC_BASE`.
+   *
+   * @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel
+   * orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels
+   * implicitly by their position in the stream.
+   */
+  AV_CHAN_AMBISONIC_BASE = 0x400,
+  // leave space for 1024 ids, which correspond to maximum order-32 harmonics,
+  // which should be enough for the foreseeable use cases
+  AV_CHAN_AMBISONIC_END = 0x7ff,
+};
+
+enum AVChannelOrder {
+  /**
+   * Only the channel count is specified, without any further information
+   * about the channel order.
+   */
+  AV_CHANNEL_ORDER_UNSPEC,
+  /**
+   * The native channel order, i.e. the channels are in the same order in
+   * which they are defined in the AVChannel enum. This supports up to 63
+   * different channels.
+   */
+  AV_CHANNEL_ORDER_NATIVE,
+  /**
+   * The channel order does not correspond to any other predefined order and
+   * is stored as an explicit map. For example, this could be used to support
+   * layouts with 64 or more channels, or with empty/skipped (AV_CHAN_SILENCE)
+   * channels at arbitrary positions.
+   */
+  AV_CHANNEL_ORDER_CUSTOM,
+  /**
+   * The audio is represented as the decomposition of the sound field into
+   * spherical harmonics. Each channel corresponds to a single expansion
+   * component. Channels are ordered according to ACN (Ambisonic Channel
+   * Number).
+   *
+   * The channel with the index n in the stream contains the spherical
+   * harmonic of degree l and order m given by
+   * @code{.unparsed}
+   *   l   = floor(sqrt(n)),
+   *   m   = n - l * (l + 1).
+   * @endcode
+   *
+   * Conversely given a spherical harmonic of degree l and order m, the
+   * corresponding channel index n is given by
+   * @code{.unparsed}
+   *   n = l * (l + 1) + m.
+   * @endcode
+   *
+   * Normalization is assumed to be SN3D (Schmidt Semi-Normalization)
+   * as defined in AmbiX format $ 2.1.
+   */
+  AV_CHANNEL_ORDER_AMBISONIC,
+};
+
+/**
+ * @defgroup channel_masks Audio channel masks
+ *
+ * A channel layout is a 64-bits integer with a bit set for every channel.
+ * The number of bits set must be equal to the number of channels.
+ * The value 0 means that the channel layout is not known.
+ * @note this data structure is not powerful enough to handle channels
+ * combinations that have the same channel multiple times, such as
+ * dual-mono.
+ *
+ * @{
+ */
+#define AV_CH_FRONT_LEFT (1ULL << AV_CHAN_FRONT_LEFT)
+#define AV_CH_FRONT_RIGHT (1ULL << AV_CHAN_FRONT_RIGHT)
+#define AV_CH_FRONT_CENTER (1ULL << AV_CHAN_FRONT_CENTER)
+#define AV_CH_LOW_FREQUENCY (1ULL << AV_CHAN_LOW_FREQUENCY)
+#define AV_CH_BACK_LEFT (1ULL << AV_CHAN_BACK_LEFT)
+#define AV_CH_BACK_RIGHT (1ULL << AV_CHAN_BACK_RIGHT)
+#define AV_CH_FRONT_LEFT_OF_CENTER (1ULL << AV_CHAN_FRONT_LEFT_OF_CENTER)
+#define AV_CH_FRONT_RIGHT_OF_CENTER (1ULL << AV_CHAN_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_BACK_CENTER (1ULL << AV_CHAN_BACK_CENTER)
+#define AV_CH_SIDE_LEFT (1ULL << AV_CHAN_SIDE_LEFT)
+#define AV_CH_SIDE_RIGHT (1ULL << AV_CHAN_SIDE_RIGHT)
+#define AV_CH_TOP_CENTER (1ULL << AV_CHAN_TOP_CENTER)
+#define AV_CH_TOP_FRONT_LEFT (1ULL << AV_CHAN_TOP_FRONT_LEFT)
+#define AV_CH_TOP_FRONT_CENTER (1ULL << AV_CHAN_TOP_FRONT_CENTER)
+#define AV_CH_TOP_FRONT_RIGHT (1ULL << AV_CHAN_TOP_FRONT_RIGHT)
+#define AV_CH_TOP_BACK_LEFT (1ULL << AV_CHAN_TOP_BACK_LEFT)
+#define AV_CH_TOP_BACK_CENTER (1ULL << AV_CHAN_TOP_BACK_CENTER)
+#define AV_CH_TOP_BACK_RIGHT (1ULL << AV_CHAN_TOP_BACK_RIGHT)
+#define AV_CH_STEREO_LEFT (1ULL << AV_CHAN_STEREO_LEFT)
+#define AV_CH_STEREO_RIGHT (1ULL << AV_CHAN_STEREO_RIGHT)
+#define AV_CH_WIDE_LEFT (1ULL << AV_CHAN_WIDE_LEFT)
+#define AV_CH_WIDE_RIGHT (1ULL << AV_CHAN_WIDE_RIGHT)
+#define AV_CH_SURROUND_DIRECT_LEFT (1ULL << AV_CHAN_SURROUND_DIRECT_LEFT)
+#define AV_CH_SURROUND_DIRECT_RIGHT (1ULL << AV_CHAN_SURROUND_DIRECT_RIGHT)
+#define AV_CH_LOW_FREQUENCY_2 (1ULL << AV_CHAN_LOW_FREQUENCY_2)
+#define AV_CH_TOP_SIDE_LEFT (1ULL << AV_CHAN_TOP_SIDE_LEFT)
+#define AV_CH_TOP_SIDE_RIGHT (1ULL << AV_CHAN_TOP_SIDE_RIGHT)
+#define AV_CH_BOTTOM_FRONT_CENTER (1ULL << AV_CHAN_BOTTOM_FRONT_CENTER)
+#define AV_CH_BOTTOM_FRONT_LEFT (1ULL << AV_CHAN_BOTTOM_FRONT_LEFT)
+#define AV_CH_BOTTOM_FRONT_RIGHT (1ULL << AV_CHAN_BOTTOM_FRONT_RIGHT)
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+/** Channel mask value used for AVCodecContext.request_channel_layout
+    to indicate that the user requests the channel order of the decoder output
+    to be the native codec channel order.
+    @deprecated channel order is now indicated in a special field in
+                AVChannelLayout
+    */
+#  define AV_CH_LAYOUT_NATIVE 0x8000000000000000ULL
+#endif
+
+/**
+ * @}
+ * @defgroup channel_mask_c Audio channel layouts
+ * @{
+ * */
+#define AV_CH_LAYOUT_MONO (AV_CH_FRONT_CENTER)
+#define AV_CH_LAYOUT_STEREO (AV_CH_FRONT_LEFT | AV_CH_FRONT_RIGHT)
+#define AV_CH_LAYOUT_2POINT1 (AV_CH_LAYOUT_STEREO | AV_CH_LOW_FREQUENCY)
+#define AV_CH_LAYOUT_2_1 (AV_CH_LAYOUT_STEREO | AV_CH_BACK_CENTER)
+#define AV_CH_LAYOUT_SURROUND (AV_CH_LAYOUT_STEREO | AV_CH_FRONT_CENTER)
+#define AV_CH_LAYOUT_3POINT1 (AV_CH_LAYOUT_SURROUND | AV_CH_LOW_FREQUENCY)
+#define AV_CH_LAYOUT_4POINT0 (AV_CH_LAYOUT_SURROUND | AV_CH_BACK_CENTER)
+#define AV_CH_LAYOUT_4POINT1 (AV_CH_LAYOUT_4POINT0 | AV_CH_LOW_FREQUENCY)
+#define AV_CH_LAYOUT_2_2 \
+  (AV_CH_LAYOUT_STEREO | AV_CH_SIDE_LEFT | AV_CH_SIDE_RIGHT)
+#define AV_CH_LAYOUT_QUAD \
+  (AV_CH_LAYOUT_STEREO | AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT)
+#define AV_CH_LAYOUT_5POINT0 \
+  (AV_CH_LAYOUT_SURROUND | AV_CH_SIDE_LEFT | AV_CH_SIDE_RIGHT)
+#define AV_CH_LAYOUT_5POINT1 (AV_CH_LAYOUT_5POINT0 | AV_CH_LOW_FREQUENCY)
+#define AV_CH_LAYOUT_5POINT0_BACK \
+  (AV_CH_LAYOUT_SURROUND | AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT)
+#define AV_CH_LAYOUT_5POINT1_BACK \
+  (AV_CH_LAYOUT_5POINT0_BACK | AV_CH_LOW_FREQUENCY)
+#define AV_CH_LAYOUT_6POINT0 (AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_CENTER)
+#define AV_CH_LAYOUT_6POINT0_FRONT \
+  (AV_CH_LAYOUT_2_2 | AV_CH_FRONT_LEFT_OF_CENTER | AV_CH_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_LAYOUT_HEXAGONAL (AV_CH_LAYOUT_5POINT0_BACK | AV_CH_BACK_CENTER)
+#define AV_CH_LAYOUT_6POINT1 (AV_CH_LAYOUT_5POINT1 | AV_CH_BACK_CENTER)
+#define AV_CH_LAYOUT_6POINT1_BACK \
+  (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_BACK_CENTER)
+#define AV_CH_LAYOUT_6POINT1_FRONT \
+  (AV_CH_LAYOUT_6POINT0_FRONT | AV_CH_LOW_FREQUENCY)
+#define AV_CH_LAYOUT_7POINT0 \
+  (AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT)
+#define AV_CH_LAYOUT_7POINT0_FRONT                     \
+  (AV_CH_LAYOUT_5POINT0 | AV_CH_FRONT_LEFT_OF_CENTER | \
+   AV_CH_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_LAYOUT_7POINT1 \
+  (AV_CH_LAYOUT_5POINT1 | AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT)
+#define AV_CH_LAYOUT_7POINT1_WIDE                      \
+  (AV_CH_LAYOUT_5POINT1 | AV_CH_FRONT_LEFT_OF_CENTER | \
+   AV_CH_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_LAYOUT_7POINT1_WIDE_BACK                      \
+  (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_FRONT_LEFT_OF_CENTER | \
+   AV_CH_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_LAYOUT_7POINT1_TOP_BACK \
+  (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_TOP_FRONT_LEFT | AV_CH_TOP_FRONT_RIGHT)
+#define AV_CH_LAYOUT_OCTAGONAL                                  \
+  (AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_LEFT | AV_CH_BACK_CENTER | \
+   AV_CH_BACK_RIGHT)
+#define AV_CH_LAYOUT_CUBE                                             \
+  (AV_CH_LAYOUT_QUAD | AV_CH_TOP_FRONT_LEFT | AV_CH_TOP_FRONT_RIGHT | \
+   AV_CH_TOP_BACK_LEFT | AV_CH_TOP_BACK_RIGHT)
+#define AV_CH_LAYOUT_HEXADECAGONAL                                      \
+  (AV_CH_LAYOUT_OCTAGONAL | AV_CH_WIDE_LEFT | AV_CH_WIDE_RIGHT |        \
+   AV_CH_TOP_BACK_LEFT | AV_CH_TOP_BACK_RIGHT | AV_CH_TOP_BACK_CENTER | \
+   AV_CH_TOP_FRONT_CENTER | AV_CH_TOP_FRONT_LEFT | AV_CH_TOP_FRONT_RIGHT)
+#define AV_CH_LAYOUT_STEREO_DOWNMIX (AV_CH_STEREO_LEFT | AV_CH_STEREO_RIGHT)
+#define AV_CH_LAYOUT_22POINT2                                                 \
+  (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_FRONT_LEFT_OF_CENTER |                   \
+   AV_CH_FRONT_RIGHT_OF_CENTER | AV_CH_BACK_CENTER | AV_CH_LOW_FREQUENCY_2 |  \
+   AV_CH_SIDE_LEFT | AV_CH_SIDE_RIGHT | AV_CH_TOP_FRONT_LEFT |                \
+   AV_CH_TOP_FRONT_RIGHT | AV_CH_TOP_FRONT_CENTER | AV_CH_TOP_CENTER |        \
+   AV_CH_TOP_BACK_LEFT | AV_CH_TOP_BACK_RIGHT | AV_CH_TOP_SIDE_LEFT |         \
+   AV_CH_TOP_SIDE_RIGHT | AV_CH_TOP_BACK_CENTER | AV_CH_BOTTOM_FRONT_CENTER | \
+   AV_CH_BOTTOM_FRONT_LEFT | AV_CH_BOTTOM_FRONT_RIGHT)
+
+enum AVMatrixEncoding {
+  AV_MATRIX_ENCODING_NONE,
+  AV_MATRIX_ENCODING_DOLBY,
+  AV_MATRIX_ENCODING_DPLII,
+  AV_MATRIX_ENCODING_DPLIIX,
+  AV_MATRIX_ENCODING_DPLIIZ,
+  AV_MATRIX_ENCODING_DOLBYEX,
+  AV_MATRIX_ENCODING_DOLBYHEADPHONE,
+  AV_MATRIX_ENCODING_NB
+};
+
+/**
+ * @}
+ */
+
+/**
+ * An AVChannelCustom defines a single channel within a custom order layout
+ *
+ * Unlike most structures in FFmpeg, sizeof(AVChannelCustom) is a part of the
+ * public ABI.
+ *
+ * No new fields may be added to it without a major version bump.
+ */
+typedef struct AVChannelCustom {
+  enum AVChannel id;
+  char name[16];
+  void* opaque;
+} AVChannelCustom;
+
+/**
+ * An AVChannelLayout holds information about the channel layout of audio data.
+ *
+ * A channel layout here is defined as a set of channels ordered in a specific
+ * way (unless the channel order is AV_CHANNEL_ORDER_UNSPEC, in which case an
+ * AVChannelLayout carries only the channel count).
+ * All orders may be treated as if they were AV_CHANNEL_ORDER_UNSPEC by
+ * ignoring everything but the channel count, as long as
+ * av_channel_layout_check() considers they are valid.
+ *
+ * Unlike most structures in FFmpeg, sizeof(AVChannelLayout) is a part of the
+ * public ABI and may be used by the caller. E.g. it may be allocated on stack
+ * or embedded in caller-defined structs.
+ *
+ * AVChannelLayout can be initialized as follows:
+ * - default initialization with {0}, followed by setting all used fields
+ *   correctly;
+ * - by assigning one of the predefined AV_CHANNEL_LAYOUT_* initializers;
+ * - with a constructor function, such as av_channel_layout_default(),
+ *   av_channel_layout_from_mask() or av_channel_layout_from_string().
+ *
+ * The channel layout must be unitialized with av_channel_layout_uninit()
+ *
+ * Copying an AVChannelLayout via assigning is forbidden,
+ * av_channel_layout_copy() must be used instead (and its return value should
+ * be checked)
+ *
+ * No new fields may be added to it without a major version bump, except for
+ * new elements of the union fitting in sizeof(uint64_t).
+ */
+typedef struct AVChannelLayout {
+  /**
+   * Channel order used in this layout.
+   * This is a mandatory field.
+   */
+  enum AVChannelOrder order;
+
+  /**
+   * Number of channels in this layout. Mandatory field.
+   */
+  int nb_channels;
+
+  /**
+   * Details about which channels are present in this layout.
+   * For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
+   * used.
+   */
+  union {
+    /**
+     * This member must be used for AV_CHANNEL_ORDER_NATIVE, and may be used
+     * for AV_CHANNEL_ORDER_AMBISONIC to signal non-diegetic channels.
+     * It is a bitmask, where the position of each set bit means that the
+     * AVChannel with the corresponding value is present.
+     *
+     * I.e. when (mask & (1 << AV_CHAN_FOO)) is non-zero, then AV_CHAN_FOO
+     * is present in the layout. Otherwise it is not present.
+     *
+     * @note when a channel layout using a bitmask is constructed or
+     * modified manually (i.e.  not using any of the av_channel_layout_*
+     * functions), the code doing it must ensure that the number of set bits
+     * is equal to nb_channels.
+     */
+    uint64_t mask;
+    /**
+     * This member must be used when the channel order is
+     * AV_CHANNEL_ORDER_CUSTOM. It is a nb_channels-sized array, with each
+     * element signalling the presence of the AVChannel with the
+     * corresponding value in map[i].id.
+     *
+     * I.e. when map[i].id is equal to AV_CHAN_FOO, then AV_CH_FOO is the
+     * i-th channel in the audio data.
+     *
+     * When map[i].id is in the range between AV_CHAN_AMBISONIC_BASE and
+     * AV_CHAN_AMBISONIC_END (inclusive), the channel contains an ambisonic
+     * component with ACN index (as defined above)
+     * n = map[i].id - AV_CHAN_AMBISONIC_BASE.
+     *
+     * map[i].name may be filled with a 0-terminated string, in which case
+     * it will be used for the purpose of identifying the channel with the
+     * convenience functions below. Otherise it must be zeroed.
+     */
+    AVChannelCustom* map;
+  } u;
+
+  /**
+   * For some private data of the user.
+   */
+  void* opaque;
+} AVChannelLayout;
+
+#define AV_CHANNEL_LAYOUT_MASK(nb, m)                                          \
+  {                                                                            \
+    .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = (nb), .u = {.mask = (m) } \
+  }
+
+/**
+ * @name Common pre-defined channel layouts
+ * @{
+ */
+#define AV_CHANNEL_LAYOUT_MONO AV_CHANNEL_LAYOUT_MASK(1, AV_CH_LAYOUT_MONO)
+#define AV_CHANNEL_LAYOUT_STEREO AV_CHANNEL_LAYOUT_MASK(2, AV_CH_LAYOUT_STEREO)
+#define AV_CHANNEL_LAYOUT_2POINT1 \
+  AV_CHANNEL_LAYOUT_MASK(3, AV_CH_LAYOUT_2POINT1)
+#define AV_CHANNEL_LAYOUT_2_1 AV_CHANNEL_LAYOUT_MASK(3, AV_CH_LAYOUT_2_1)
+#define AV_CHANNEL_LAYOUT_SURROUND \
+  AV_CHANNEL_LAYOUT_MASK(3, AV_CH_LAYOUT_SURROUND)
+#define AV_CHANNEL_LAYOUT_3POINT1 \
+  AV_CHANNEL_LAYOUT_MASK(4, AV_CH_LAYOUT_3POINT1)
+#define AV_CHANNEL_LAYOUT_4POINT0 \
+  AV_CHANNEL_LAYOUT_MASK(4, AV_CH_LAYOUT_4POINT0)
+#define AV_CHANNEL_LAYOUT_4POINT1 \
+  AV_CHANNEL_LAYOUT_MASK(5, AV_CH_LAYOUT_4POINT1)
+#define AV_CHANNEL_LAYOUT_2_2 AV_CHANNEL_LAYOUT_MASK(4, AV_CH_LAYOUT_2_2)
+#define AV_CHANNEL_LAYOUT_QUAD AV_CHANNEL_LAYOUT_MASK(4, AV_CH_LAYOUT_QUAD)
+#define AV_CHANNEL_LAYOUT_5POINT0 \
+  AV_CHANNEL_LAYOUT_MASK(5, AV_CH_LAYOUT_5POINT0)
+#define AV_CHANNEL_LAYOUT_5POINT1 \
+  AV_CHANNEL_LAYOUT_MASK(6, AV_CH_LAYOUT_5POINT1)
+#define AV_CHANNEL_LAYOUT_5POINT0_BACK \
+  AV_CHANNEL_LAYOUT_MASK(5, AV_CH_LAYOUT_5POINT0_BACK)
+#define AV_CHANNEL_LAYOUT_5POINT1_BACK \
+  AV_CHANNEL_LAYOUT_MASK(6, AV_CH_LAYOUT_5POINT1_BACK)
+#define AV_CHANNEL_LAYOUT_6POINT0 \
+  AV_CHANNEL_LAYOUT_MASK(6, AV_CH_LAYOUT_6POINT0)
+#define AV_CHANNEL_LAYOUT_6POINT0_FRONT \
+  AV_CHANNEL_LAYOUT_MASK(6, AV_CH_LAYOUT_6POINT0_FRONT)
+#define AV_CHANNEL_LAYOUT_HEXAGONAL \
+  AV_CHANNEL_LAYOUT_MASK(6, AV_CH_LAYOUT_HEXAGONAL)
+#define AV_CHANNEL_LAYOUT_6POINT1 \
+  AV_CHANNEL_LAYOUT_MASK(7, AV_CH_LAYOUT_6POINT1)
+#define AV_CHANNEL_LAYOUT_6POINT1_BACK \
+  AV_CHANNEL_LAYOUT_MASK(7, AV_CH_LAYOUT_6POINT1_BACK)
+#define AV_CHANNEL_LAYOUT_6POINT1_FRONT \
+  AV_CHANNEL_LAYOUT_MASK(7, AV_CH_LAYOUT_6POINT1_FRONT)
+#define AV_CHANNEL_LAYOUT_7POINT0 \
+  AV_CHANNEL_LAYOUT_MASK(7, AV_CH_LAYOUT_7POINT0)
+#define AV_CHANNEL_LAYOUT_7POINT0_FRONT \
+  AV_CHANNEL_LAYOUT_MASK(7, AV_CH_LAYOUT_7POINT0_FRONT)
+#define AV_CHANNEL_LAYOUT_7POINT1 \
+  AV_CHANNEL_LAYOUT_MASK(8, AV_CH_LAYOUT_7POINT1)
+#define AV_CHANNEL_LAYOUT_7POINT1_WIDE \
+  AV_CHANNEL_LAYOUT_MASK(8, AV_CH_LAYOUT_7POINT1_WIDE)
+#define AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK \
+  AV_CHANNEL_LAYOUT_MASK(8, AV_CH_LAYOUT_7POINT1_WIDE_BACK)
+#define AV_CHANNEL_LAYOUT_7POINT1_TOP_BACK \
+  AV_CHANNEL_LAYOUT_MASK(8, AV_CH_LAYOUT_7POINT1_TOP_BACK)
+#define AV_CHANNEL_LAYOUT_OCTAGONAL \
+  AV_CHANNEL_LAYOUT_MASK(8, AV_CH_LAYOUT_OCTAGONAL)
+#define AV_CHANNEL_LAYOUT_CUBE AV_CHANNEL_LAYOUT_MASK(8, AV_CH_LAYOUT_CUBE)
+#define AV_CHANNEL_LAYOUT_HEXADECAGONAL \
+  AV_CHANNEL_LAYOUT_MASK(16, AV_CH_LAYOUT_HEXADECAGONAL)
+#define AV_CHANNEL_LAYOUT_STEREO_DOWNMIX \
+  AV_CHANNEL_LAYOUT_MASK(2, AV_CH_LAYOUT_STEREO_DOWNMIX)
+#define AV_CHANNEL_LAYOUT_22POINT2 \
+  AV_CHANNEL_LAYOUT_MASK(24, AV_CH_LAYOUT_22POINT2)
+#define AV_CHANNEL_LAYOUT_AMBISONIC_FIRST_ORDER                              \
+  {                                                                          \
+    .order = AV_CHANNEL_ORDER_AMBISONIC, .nb_channels = 4, .u = {.mask = 0 } \
+  }
+/** @} */
+
+struct AVBPrint;
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+/**
+ * @name Deprecated Functions
+ * @{
+ */
+
+/**
+ * Return a channel layout id that matches name, or 0 if no match is found.
+ *
+ * name can be one or several of the following notations,
+ * separated by '+' or '|':
+ * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
+ *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
+ * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
+ *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
+ * - a number of channels, in decimal, followed by 'c', yielding
+ *   the default channel layout for that number of channels (@see
+ *   av_get_default_channel_layout);
+ * - a channel layout mask, in hexadecimal starting with "0x" (see the
+ *   AV_CH_* macros).
+ *
+ * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
+ *
+ * @deprecated use av_channel_layout_from_string()
+ */
+attribute_deprecated uint64_t av_get_channel_layout(const char* name);
+
+/**
+ * Return a channel layout and the number of channels based on the specified
+ * name.
+ *
+ * This function is similar to (@see av_get_channel_layout), but can also parse
+ * unknown channel layout specifications.
+ *
+ * @param[in]  name             channel layout specification string
+ * @param[out] channel_layout   parsed channel layout (0 if unknown)
+ * @param[out] nb_channels      number of channels
+ *
+ * @return 0 on success, AVERROR(EINVAL) if the parsing fails.
+ * @deprecated use av_channel_layout_from_string()
+ */
+attribute_deprecated int av_get_extended_channel_layout(
+    const char* name, uint64_t* channel_layout, int* nb_channels);
+
+/**
+ * Return a description of a channel layout.
+ * If nb_channels is <= 0, it is guessed from the channel_layout.
+ *
+ * @param buf put here the string containing the channel layout
+ * @param buf_size size in bytes of the buffer
+ * @param nb_channels number of channels
+ * @param channel_layout channel layout bitset
+ * @deprecated use av_channel_layout_describe()
+ */
+attribute_deprecated void av_get_channel_layout_string(char* buf, int buf_size,
+                                                       int nb_channels,
+                                                       uint64_t channel_layout);
+
+/**
+ * Append a description of a channel layout to a bprint buffer.
+ * @deprecated use av_channel_layout_describe()
+ */
+attribute_deprecated void av_bprint_channel_layout(struct AVBPrint* bp,
+                                                   int nb_channels,
+                                                   uint64_t channel_layout);
+
+/**
+ * Return the number of channels in the channel layout.
+ * @deprecated use AVChannelLayout.nb_channels
+ */
+attribute_deprecated int av_get_channel_layout_nb_channels(
+    uint64_t channel_layout);
+
+/**
+ * Return default channel layout for a given number of channels.
+ *
+ * @deprecated use av_channel_layout_default()
+ */
+attribute_deprecated int64_t av_get_default_channel_layout(int nb_channels);
+
+/**
+ * Get the index of a channel in channel_layout.
+ *
+ * @param channel_layout channel layout bitset
+ * @param channel a channel layout describing exactly one channel which must be
+ *                present in channel_layout.
+ *
+ * @return index of channel in channel_layout on success, a negative AVERROR
+ *         on error.
+ *
+ * @deprecated use av_channel_layout_index_from_channel()
+ */
+attribute_deprecated int av_get_channel_layout_channel_index(
+    uint64_t channel_layout, uint64_t channel);
+
+/**
+ * Get the channel with the given index in channel_layout.
+ * @deprecated use av_channel_layout_channel_from_index()
+ */
+attribute_deprecated uint64_t
+av_channel_layout_extract_channel(uint64_t channel_layout, int index);
+
+/**
+ * Get the name of a given channel.
+ *
+ * @return channel name on success, NULL on error.
+ *
+ * @deprecated use av_channel_name()
+ */
+attribute_deprecated const char* av_get_channel_name(uint64_t channel);
+
+/**
+ * Get the description of a given channel.
+ *
+ * @param channel  a channel layout with a single channel
+ * @return  channel description on success, NULL on error
+ * @deprecated use av_channel_description()
+ */
+attribute_deprecated const char* av_get_channel_description(uint64_t channel);
+
+/**
+ * Get the value and name of a standard channel layout.
+ *
+ * @param[in]  index   index in an internal list, starting at 0
+ * @param[out] layout  channel layout mask
+ * @param[out] name    name of the layout
+ * @return  0  if the layout exists,
+ *          <0 if index is beyond the limits
+ * @deprecated use av_channel_layout_standard()
+ */
+attribute_deprecated int av_get_standard_channel_layout(unsigned index,
+                                                        uint64_t* layout,
+                                                        const char** name);
+/**
+ * @}
+ */
+#endif
+
+/**
+ * Get a human readable string in an abbreviated form describing a given
+ * channel. This is the inverse function of @ref av_channel_from_string().
+ *
+ * @param buf pre-allocated buffer where to put the generated string
+ * @param buf_size size in bytes of the buffer.
+ * @param channel the AVChannel whose name to get
+ * @return amount of bytes needed to hold the output string, or a negative
+ * AVERROR on failure. If the returned value is bigger than buf_size, then the
+ *         string was truncated.
+ */
+int av_channel_name(char* buf, size_t buf_size, enum AVChannel channel);
+
+/**
+ * bprint variant of av_channel_name().
+ *
+ * @note the string will be appended to the bprint buffer.
+ */
+void av_channel_name_bprint(struct AVBPrint* bp, enum AVChannel channel_id);
+
+/**
+ * Get a human readable string describing a given channel.
+ *
+ * @param buf pre-allocated buffer where to put the generated string
+ * @param buf_size size in bytes of the buffer.
+ * @param channel the AVChannel whose description to get
+ * @return amount of bytes needed to hold the output string, or a negative
+ * AVERROR on failure. If the returned value is bigger than buf_size, then the
+ *         string was truncated.
+ */
+int av_channel_description(char* buf, size_t buf_size, enum AVChannel channel);
+
+/**
+ * bprint variant of av_channel_description().
+ *
+ * @note the string will be appended to the bprint buffer.
+ */
+void av_channel_description_bprint(struct AVBPrint* bp,
+                                   enum AVChannel channel_id);
+
+/**
+ * This is the inverse function of @ref av_channel_name().
+ *
+ * @return the channel with the given name
+ *         AV_CHAN_NONE when name does not identify a known channel
+ */
+enum AVChannel av_channel_from_string(const char* name);
+
+/**
+ * Initialize a native channel layout from a bitmask indicating which channels
+ * are present.
+ *
+ * @param channel_layout the layout structure to be initialized
+ * @param mask bitmask describing the channel layout
+ *
+ * @return 0 on success
+ *         AVERROR(EINVAL) for invalid mask values
+ */
+int av_channel_layout_from_mask(AVChannelLayout* channel_layout, uint64_t mask);
+
+/**
+ * Initialize a channel layout from a given string description.
+ * The input string can be represented by:
+ *  - the formal channel layout name (returned by av_channel_layout_describe())
+ *  - single or multiple channel names (returned by av_channel_name(), eg. "FL",
+ *    or concatenated with "+", each optionally containing a custom name after
+ *    a "@", eg. "FL@Left+FR@Right+LFE")
+ *  - a decimal or hexadecimal value of a native channel layout (eg. "4" or
+ * "0x4")
+ *  - the number of channels with default layout (eg. "4c")
+ *  - the number of unordered channels (eg. "4C" or "4 channels")
+ *  - the ambisonic order followed by optional non-diegetic channels (eg.
+ *    "ambisonic 2+stereo")
+ *
+ * @param channel_layout input channel layout
+ * @param str string describing the channel layout
+ * @return 0 channel layout was detected, AVERROR_INVALIDATATA otherwise
+ */
+int av_channel_layout_from_string(AVChannelLayout* channel_layout,
+                                  const char* str);
+
+/**
+ * Get the default channel layout for a given number of channels.
+ *
+ * @param ch_layout the layout structure to be initialized
+ * @param nb_channels number of channels
+ */
+void av_channel_layout_default(AVChannelLayout* ch_layout, int nb_channels);
+
+/**
+ * Iterate over all standard channel layouts.
+ *
+ * @param opaque a pointer where libavutil will store the iteration state. Must
+ *               point to NULL to start the iteration.
+ *
+ * @return the standard channel layout or NULL when the iteration is
+ *         finished
+ */
+const AVChannelLayout* av_channel_layout_standard(void** opaque);
+
+/**
+ * Free any allocated data in the channel layout and reset the channel
+ * count to 0.
+ *
+ * @param channel_layout the layout structure to be uninitialized
+ */
+void av_channel_layout_uninit(AVChannelLayout* channel_layout);
+
+/**
+ * Make a copy of a channel layout. This differs from just assigning src to dst
+ * in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.
+ *
+ * @note the destination channel_layout will be always uninitialized before
+ * copy.
+ *
+ * @param dst destination channel layout
+ * @param src source channel layout
+ * @return 0 on success, a negative AVERROR on error.
+ */
+int av_channel_layout_copy(AVChannelLayout* dst, const AVChannelLayout* src);
+
+/**
+ * Get a human-readable string describing the channel layout properties.
+ * The string will be in the same format that is accepted by
+ * @ref av_channel_layout_from_string(), allowing to rebuild the same
+ * channel layout, except for opaque pointers.
+ *
+ * @param channel_layout channel layout to be described
+ * @param buf pre-allocated buffer where to put the generated string
+ * @param buf_size size in bytes of the buffer.
+ * @return amount of bytes needed to hold the output string, or a negative
+ * AVERROR on failure. If the returned value is bigger than buf_size, then the
+ *         string was truncated.
+ */
+int av_channel_layout_describe(const AVChannelLayout* channel_layout, char* buf,
+                               size_t buf_size);
+
+/**
+ * bprint variant of av_channel_layout_describe().
+ *
+ * @note the string will be appended to the bprint buffer.
+ * @return 0 on success, or a negative AVERROR value on failure.
+ */
+int av_channel_layout_describe_bprint(const AVChannelLayout* channel_layout,
+                                      struct AVBPrint* bp);
+
+/**
+ * Get the channel with the given index in a channel layout.
+ *
+ * @param channel_layout input channel layout
+ * @param idx index of the channel
+ * @return channel with the index idx in channel_layout on success or
+ *         AV_CHAN_NONE on failure (if idx is not valid or the channel order is
+ *         unspecified)
+ */
+enum AVChannel av_channel_layout_channel_from_index(
+    const AVChannelLayout* channel_layout, unsigned int idx);
+
+/**
+ * Get the index of a given channel in a channel layout. In case multiple
+ * channels are found, only the first match will be returned.
+ *
+ * @param channel_layout input channel layout
+ * @param channel the channel whose index to obtain
+ * @return index of channel in channel_layout on success or a negative number if
+ *         channel is not present in channel_layout.
+ */
+int av_channel_layout_index_from_channel(const AVChannelLayout* channel_layout,
+                                         enum AVChannel channel);
+
+/**
+ * Get the index in a channel layout of a channel described by the given string.
+ * In case multiple channels are found, only the first match will be returned.
+ *
+ * This function accepts channel names in the same format as
+ * @ref av_channel_from_string().
+ *
+ * @param channel_layout input channel layout
+ * @param name string describing the channel whose index to obtain
+ * @return a channel index described by the given string, or a negative AVERROR
+ *         value.
+ */
+int av_channel_layout_index_from_string(const AVChannelLayout* channel_layout,
+                                        const char* name);
+
+/**
+ * Get a channel described by the given string.
+ *
+ * This function accepts channel names in the same format as
+ * @ref av_channel_from_string().
+ *
+ * @param channel_layout input channel layout
+ * @param name string describing the channel to obtain
+ * @return a channel described by the given string in channel_layout on success
+ *         or AV_CHAN_NONE on failure (if the string is not valid or the channel
+ *         order is unspecified)
+ */
+enum AVChannel av_channel_layout_channel_from_string(
+    const AVChannelLayout* channel_layout, const char* name);
+
+/**
+ * Find out what channels from a given set are present in a channel layout,
+ * without regard for their positions.
+ *
+ * @param channel_layout input channel layout
+ * @param mask a combination of AV_CH_* representing a set of channels
+ * @return a bitfield representing all the channels from mask that are present
+ *         in channel_layout
+ */
+uint64_t av_channel_layout_subset(const AVChannelLayout* channel_layout,
+                                  uint64_t mask);
+
+/**
+ * Check whether a channel layout is valid, i.e. can possibly describe audio
+ * data.
+ *
+ * @param channel_layout input channel layout
+ * @return 1 if channel_layout is valid, 0 otherwise.
+ */
+int av_channel_layout_check(const AVChannelLayout* channel_layout);
+
+/**
+ * Check whether two channel layouts are semantically the same, i.e. the same
+ * channels are present on the same positions in both.
+ *
+ * If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is
+ * not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC,
+ * they are considered equal iff the channel counts are the same in both.
+ *
+ * @param chl input channel layout
+ * @param chl1 input channel layout
+ * @return 0 if chl and chl1 are equal, 1 if they are not equal. A negative
+ *         AVERROR code if one or both are invalid.
+ */
+int av_channel_layout_compare(const AVChannelLayout* chl,
+                              const AVChannelLayout* chl1);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_CHANNEL_LAYOUT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/common.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/common.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/common.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/common.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,589 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * common internal and external API header
+ */
+
+#ifndef AVUTIL_COMMON_H
+#define AVUTIL_COMMON_H
+
+#if defined(__cplusplus) && !defined(__STDC_CONSTANT_MACROS) && \
+    !defined(UINT64_C)
+#  error missing -D__STDC_CONSTANT_MACROS / #define __STDC_CONSTANT_MACROS
+#endif
+
+#include <errno.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <math.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "attributes.h"
+#include "macros.h"
+
+// rounded division & shift
+#define RSHIFT(a, b)                          \
+  ((a) > 0 ? ((a) + ((1 << (b)) >> 1)) >> (b) \
+           : ((a) + ((1 << (b)) >> 1) - 1) >> (b))
+/* assume b>0 */
+#define ROUNDED_DIV(a, b) \
+  (((a) >= 0 ? (a) + ((b) >> 1) : (a) - ((b) >> 1)) / (b))
+/* Fast a/(1<<b) rounded toward +inf. Assume a>=0 and b>=0 */
+#define AV_CEIL_RSHIFT(a, b) \
+  (!av_builtin_constant_p(b) ? -((-(a)) >> (b)) : ((a) + (1 << (b)) - 1) >> (b))
+/* Backwards compat. */
+#define FF_CEIL_RSHIFT AV_CEIL_RSHIFT
+
+#define FFUDIV(a, b) (((a) > 0 ? (a) : (a) - (b) + 1) / (b))
+#define FFUMOD(a, b) ((a) - (b)*FFUDIV(a, b))
+
+/**
+ * Absolute value, Note, INT_MIN / INT64_MIN result in undefined behavior as
+ * they are not representable as absolute values of their type. This is the same
+ * as with *abs()
+ * @see FFNABS()
+ */
+#define FFABS(a) ((a) >= 0 ? (a) : (-(a)))
+#define FFSIGN(a) ((a) > 0 ? 1 : -1)
+
+/**
+ * Negative Absolute value.
+ * this works for all integers of all types.
+ * As with many macros, this evaluates its argument twice, it thus must not have
+ * a sideeffect, that is FFNABS(x++) has undefined behavior.
+ */
+#define FFNABS(a) ((a) <= 0 ? (a) : (-(a)))
+
+/**
+ * Unsigned Absolute value.
+ * This takes the absolute value of a signed int and returns it as a unsigned.
+ * This also works with INT_MIN which would otherwise not be representable
+ * As with many macros, this evaluates its argument twice.
+ */
+#define FFABSU(a) ((a) <= 0 ? -(unsigned)(a) : (unsigned)(a))
+#define FFABS64U(a) ((a) <= 0 ? -(uint64_t)(a) : (uint64_t)(a))
+
+/* misc math functions */
+
+#ifdef HAVE_AV_CONFIG_H
+#  include "config.h"
+#  include "intmath.h"
+#endif
+
+#ifndef av_ceil_log2
+#  define av_ceil_log2 av_ceil_log2_c
+#endif
+#ifndef av_clip
+#  define av_clip av_clip_c
+#endif
+#ifndef av_clip64
+#  define av_clip64 av_clip64_c
+#endif
+#ifndef av_clip_uint8
+#  define av_clip_uint8 av_clip_uint8_c
+#endif
+#ifndef av_clip_int8
+#  define av_clip_int8 av_clip_int8_c
+#endif
+#ifndef av_clip_uint16
+#  define av_clip_uint16 av_clip_uint16_c
+#endif
+#ifndef av_clip_int16
+#  define av_clip_int16 av_clip_int16_c
+#endif
+#ifndef av_clipl_int32
+#  define av_clipl_int32 av_clipl_int32_c
+#endif
+#ifndef av_clip_intp2
+#  define av_clip_intp2 av_clip_intp2_c
+#endif
+#ifndef av_clip_uintp2
+#  define av_clip_uintp2 av_clip_uintp2_c
+#endif
+#ifndef av_mod_uintp2
+#  define av_mod_uintp2 av_mod_uintp2_c
+#endif
+#ifndef av_sat_add32
+#  define av_sat_add32 av_sat_add32_c
+#endif
+#ifndef av_sat_dadd32
+#  define av_sat_dadd32 av_sat_dadd32_c
+#endif
+#ifndef av_sat_sub32
+#  define av_sat_sub32 av_sat_sub32_c
+#endif
+#ifndef av_sat_dsub32
+#  define av_sat_dsub32 av_sat_dsub32_c
+#endif
+#ifndef av_sat_add64
+#  define av_sat_add64 av_sat_add64_c
+#endif
+#ifndef av_sat_sub64
+#  define av_sat_sub64 av_sat_sub64_c
+#endif
+#ifndef av_clipf
+#  define av_clipf av_clipf_c
+#endif
+#ifndef av_clipd
+#  define av_clipd av_clipd_c
+#endif
+#ifndef av_popcount
+#  define av_popcount av_popcount_c
+#endif
+#ifndef av_popcount64
+#  define av_popcount64 av_popcount64_c
+#endif
+#ifndef av_parity
+#  define av_parity av_parity_c
+#endif
+
+#ifndef av_log2
+av_const int av_log2(unsigned v);
+#endif
+
+#ifndef av_log2_16bit
+av_const int av_log2_16bit(unsigned v);
+#endif
+
+/**
+ * Clip a signed integer value into the amin-amax range.
+ * @param a value to clip
+ * @param amin minimum value of the clip range
+ * @param amax maximum value of the clip range
+ * @return clipped value
+ */
+static av_always_inline av_const int av_clip_c(int a, int amin, int amax) {
+#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
+  if (amin > amax) abort();
+#endif
+  if (a < amin)
+    return amin;
+  else if (a > amax)
+    return amax;
+  else
+    return a;
+}
+
+/**
+ * Clip a signed 64bit integer value into the amin-amax range.
+ * @param a value to clip
+ * @param amin minimum value of the clip range
+ * @param amax maximum value of the clip range
+ * @return clipped value
+ */
+static av_always_inline av_const int64_t av_clip64_c(int64_t a, int64_t amin,
+                                                     int64_t amax) {
+#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
+  if (amin > amax) abort();
+#endif
+  if (a < amin)
+    return amin;
+  else if (a > amax)
+    return amax;
+  else
+    return a;
+}
+
+/**
+ * Clip a signed integer value into the 0-255 range.
+ * @param a value to clip
+ * @return clipped value
+ */
+static av_always_inline av_const uint8_t av_clip_uint8_c(int a) {
+  if (a & (~0xFF))
+    return (~a) >> 31;
+  else
+    return a;
+}
+
+/**
+ * Clip a signed integer value into the -128,127 range.
+ * @param a value to clip
+ * @return clipped value
+ */
+static av_always_inline av_const int8_t av_clip_int8_c(int a) {
+  if ((a + 0x80U) & ~0xFF)
+    return (a >> 31) ^ 0x7F;
+  else
+    return a;
+}
+
+/**
+ * Clip a signed integer value into the 0-65535 range.
+ * @param a value to clip
+ * @return clipped value
+ */
+static av_always_inline av_const uint16_t av_clip_uint16_c(int a) {
+  if (a & (~0xFFFF))
+    return (~a) >> 31;
+  else
+    return a;
+}
+
+/**
+ * Clip a signed integer value into the -32768,32767 range.
+ * @param a value to clip
+ * @return clipped value
+ */
+static av_always_inline av_const int16_t av_clip_int16_c(int a) {
+  if ((a + 0x8000U) & ~0xFFFF)
+    return (a >> 31) ^ 0x7FFF;
+  else
+    return a;
+}
+
+/**
+ * Clip a signed 64-bit integer value into the -2147483648,2147483647 range.
+ * @param a value to clip
+ * @return clipped value
+ */
+static av_always_inline av_const int32_t av_clipl_int32_c(int64_t a) {
+  if ((a + 0x80000000u) & ~UINT64_C(0xFFFFFFFF))
+    return (int32_t)((a >> 63) ^ 0x7FFFFFFF);
+  else
+    return (int32_t)a;
+}
+
+/**
+ * Clip a signed integer into the -(2^p),(2^p-1) range.
+ * @param  a value to clip
+ * @param  p bit position to clip at
+ * @return clipped value
+ */
+static av_always_inline av_const int av_clip_intp2_c(int a, int p) {
+  if (((unsigned)a + (1 << p)) & ~((2 << p) - 1))
+    return (a >> 31) ^ ((1 << p) - 1);
+  else
+    return a;
+}
+
+/**
+ * Clip a signed integer to an unsigned power of two range.
+ * @param  a value to clip
+ * @param  p bit position to clip at
+ * @return clipped value
+ */
+static av_always_inline av_const unsigned av_clip_uintp2_c(int a, int p) {
+  if (a & ~((1 << p) - 1))
+    return (~a) >> 31 & ((1 << p) - 1);
+  else
+    return a;
+}
+
+/**
+ * Clear high bits from an unsigned integer starting with specific bit position
+ * @param  a value to clip
+ * @param  p bit position to clip at
+ * @return clipped value
+ */
+static av_always_inline av_const unsigned av_mod_uintp2_c(unsigned a,
+                                                          unsigned p) {
+  return a & ((1U << p) - 1);
+}
+
+/**
+ * Add two signed 32-bit values with saturation.
+ *
+ * @param  a one value
+ * @param  b another value
+ * @return sum with signed saturation
+ */
+static av_always_inline int av_sat_add32_c(int a, int b) {
+  return av_clipl_int32((int64_t)a + b);
+}
+
+/**
+ * Add a doubled value to another value with saturation at both stages.
+ *
+ * @param  a first value
+ * @param  b value doubled and added to a
+ * @return sum sat(a + sat(2*b)) with signed saturation
+ */
+static av_always_inline int av_sat_dadd32_c(int a, int b) {
+  return av_sat_add32(a, av_sat_add32(b, b));
+}
+
+/**
+ * Subtract two signed 32-bit values with saturation.
+ *
+ * @param  a one value
+ * @param  b another value
+ * @return difference with signed saturation
+ */
+static av_always_inline int av_sat_sub32_c(int a, int b) {
+  return av_clipl_int32((int64_t)a - b);
+}
+
+/**
+ * Subtract a doubled value from another value with saturation at both stages.
+ *
+ * @param  a first value
+ * @param  b value doubled and subtracted from a
+ * @return difference sat(a - sat(2*b)) with signed saturation
+ */
+static av_always_inline int av_sat_dsub32_c(int a, int b) {
+  return av_sat_sub32(a, av_sat_add32(b, b));
+}
+
+/**
+ * Add two signed 64-bit values with saturation.
+ *
+ * @param  a one value
+ * @param  b another value
+ * @return sum with signed saturation
+ */
+static av_always_inline int64_t av_sat_add64_c(int64_t a, int64_t b) {
+#if (!defined(__INTEL_COMPILER) && AV_GCC_VERSION_AT_LEAST(5, 1)) || \
+    AV_HAS_BUILTIN(__builtin_add_overflow)
+  int64_t tmp;
+  return !__builtin_add_overflow(a, b, &tmp)
+             ? tmp
+             : (tmp < 0 ? INT64_MAX : INT64_MIN);
+#else
+  int64_t s = a + (uint64_t)b;
+  if ((int64_t)(a ^ b | ~s ^ b) >= 0) return INT64_MAX ^ (b >> 63);
+  return s;
+#endif
+}
+
+/**
+ * Subtract two signed 64-bit values with saturation.
+ *
+ * @param  a one value
+ * @param  b another value
+ * @return difference with signed saturation
+ */
+static av_always_inline int64_t av_sat_sub64_c(int64_t a, int64_t b) {
+#if (!defined(__INTEL_COMPILER) && AV_GCC_VERSION_AT_LEAST(5, 1)) || \
+    AV_HAS_BUILTIN(__builtin_sub_overflow)
+  int64_t tmp;
+  return !__builtin_sub_overflow(a, b, &tmp)
+             ? tmp
+             : (tmp < 0 ? INT64_MAX : INT64_MIN);
+#else
+  if (b <= 0 && a >= INT64_MAX + b) return INT64_MAX;
+  if (b >= 0 && a <= INT64_MIN + b) return INT64_MIN;
+  return a - b;
+#endif
+}
+
+/**
+ * Clip a float value into the amin-amax range.
+ * If a is nan or -inf amin will be returned.
+ * If a is +inf amax will be returned.
+ * @param a value to clip
+ * @param amin minimum value of the clip range
+ * @param amax maximum value of the clip range
+ * @return clipped value
+ */
+static av_always_inline av_const float av_clipf_c(float a, float amin,
+                                                  float amax) {
+#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
+  if (amin > amax) abort();
+#endif
+  return FFMIN(FFMAX(a, amin), amax);
+}
+
+/**
+ * Clip a double value into the amin-amax range.
+ * If a is nan or -inf amin will be returned.
+ * If a is +inf amax will be returned.
+ * @param a value to clip
+ * @param amin minimum value of the clip range
+ * @param amax maximum value of the clip range
+ * @return clipped value
+ */
+static av_always_inline av_const double av_clipd_c(double a, double amin,
+                                                   double amax) {
+#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
+  if (amin > amax) abort();
+#endif
+  return FFMIN(FFMAX(a, amin), amax);
+}
+
+/** Compute ceil(log2(x)).
+ * @param x value used to compute ceil(log2(x))
+ * @return computed ceiling of log2(x)
+ */
+static av_always_inline av_const int av_ceil_log2_c(int x) {
+  return av_log2((x - 1U) << 1);
+}
+
+/**
+ * Count number of bits set to one in x
+ * @param x value to count bits of
+ * @return the number of bits set to one in x
+ */
+static av_always_inline av_const int av_popcount_c(uint32_t x) {
+  x -= (x >> 1) & 0x55555555;
+  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
+  x = (x + (x >> 4)) & 0x0F0F0F0F;
+  x += x >> 8;
+  return (x + (x >> 16)) & 0x3F;
+}
+
+/**
+ * Count number of bits set to one in x
+ * @param x value to count bits of
+ * @return the number of bits set to one in x
+ */
+static av_always_inline av_const int av_popcount64_c(uint64_t x) {
+  return av_popcount((uint32_t)x) + av_popcount((uint32_t)(x >> 32));
+}
+
+static av_always_inline av_const int av_parity_c(uint32_t v) {
+  return av_popcount(v) & 1;
+}
+
+/**
+ * Convert a UTF-8 character (up to 4 bytes) to its 32-bit UCS-4 encoded form.
+ *
+ * @param val      Output value, must be an lvalue of type uint32_t.
+ * @param GET_BYTE Expression reading one byte from the input.
+ *                 Evaluated up to 7 times (4 for the currently
+ *                 assigned Unicode range).  With a memory buffer
+ *                 input, this could be *ptr++, or if you want to make sure
+ *                 that *ptr stops at the end of a NULL terminated string then
+ *                 *ptr ? *ptr++ : 0
+ * @param ERROR    Expression to be evaluated on invalid input,
+ *                 typically a goto statement.
+ *
+ * @warning ERROR should not contain a loop control statement which
+ * could interact with the internal while loop, and should force an
+ * exit from the macro code (e.g. through a goto or a return) in order
+ * to prevent undefined results.
+ */
+#define GET_UTF8(val, GET_BYTE, ERROR)         \
+  val = (GET_BYTE);                            \
+  {                                            \
+    uint32_t top = (val & 128) >> 1;           \
+    if ((val & 0xc0) == 0x80 || val >= 0xFE) { \
+      ERROR                                    \
+    }                                          \
+    while (val & top) {                        \
+      unsigned int tmp = (GET_BYTE)-128;       \
+      if (tmp >> 6) {                          \
+        ERROR                                  \
+      }                                        \
+      val = (val << 6) + tmp;                  \
+      top <<= 5;                               \
+    }                                          \
+    val &= (top << 1) - 1;                     \
+  }
+
+/**
+ * Convert a UTF-16 character (2 or 4 bytes) to its 32-bit UCS-4 encoded form.
+ *
+ * @param val       Output value, must be an lvalue of type uint32_t.
+ * @param GET_16BIT Expression returning two bytes of UTF-16 data converted
+ *                  to native byte order.  Evaluated one or two times.
+ * @param ERROR     Expression to be evaluated on invalid input,
+ *                  typically a goto statement.
+ */
+#define GET_UTF16(val, GET_16BIT, ERROR) \
+  val = (GET_16BIT);                     \
+  {                                      \
+    unsigned int hi = val - 0xD800;      \
+    if (hi < 0x800) {                    \
+      val = (GET_16BIT)-0xDC00;          \
+      if (val > 0x3FFU || hi > 0x3FFU) { \
+        ERROR                            \
+      }                                  \
+      val += (hi << 10) + 0x10000;       \
+    }                                    \
+  }
+
+/**
+ * @def PUT_UTF8(val, tmp, PUT_BYTE)
+ * Convert a 32-bit Unicode character to its UTF-8 encoded form (up to 4 bytes
+ * long).
+ * @param val is an input-only argument and should be of type uint32_t. It holds
+ * a UCS-4 encoded Unicode character that is to be converted to UTF-8. If
+ * val is given as a function it is executed only once.
+ * @param tmp is a temporary variable and should be of type uint8_t. It
+ * represents an intermediate value during conversion that is to be
+ * output by PUT_BYTE.
+ * @param PUT_BYTE writes the converted UTF-8 bytes to any proper destination.
+ * It could be a function or a statement, and uses tmp as the input byte.
+ * For example, PUT_BYTE could be "*output++ = tmp;" PUT_BYTE will be
+ * executed up to 4 times for values in the valid UTF-8 range and up to
+ * 7 times in the general case, depending on the length of the converted
+ * Unicode character.
+ */
+#define PUT_UTF8(val, tmp, PUT_BYTE)                \
+  {                                                 \
+    int bytes, shift;                               \
+    uint32_t in = val;                              \
+    if (in < 0x80) {                                \
+      tmp = in;                                     \
+      PUT_BYTE                                      \
+    } else {                                        \
+      bytes = (av_log2(in) + 4) / 5;                \
+      shift = (bytes - 1) * 6;                      \
+      tmp = (256 - (256 >> bytes)) | (in >> shift); \
+      PUT_BYTE                                      \
+      while (shift >= 6) {                          \
+        shift -= 6;                                 \
+        tmp = 0x80 | ((in >> shift) & 0x3f);        \
+        PUT_BYTE                                    \
+      }                                             \
+    }                                               \
+  }
+
+/**
+ * @def PUT_UTF16(val, tmp, PUT_16BIT)
+ * Convert a 32-bit Unicode character to its UTF-16 encoded form (2 or 4 bytes).
+ * @param val is an input-only argument and should be of type uint32_t. It holds
+ * a UCS-4 encoded Unicode character that is to be converted to UTF-16. If
+ * val is given as a function it is executed only once.
+ * @param tmp is a temporary variable and should be of type uint16_t. It
+ * represents an intermediate value during conversion that is to be
+ * output by PUT_16BIT.
+ * @param PUT_16BIT writes the converted UTF-16 data to any proper destination
+ * in desired endianness. It could be a function or a statement, and uses tmp
+ * as the input byte.  For example, PUT_BYTE could be "*output++ = tmp;"
+ * PUT_BYTE will be executed 1 or 2 times depending on input character.
+ */
+#define PUT_UTF16(val, tmp, PUT_16BIT)         \
+  {                                            \
+    uint32_t in = val;                         \
+    if (in < 0x10000) {                        \
+      tmp = in;                                \
+      PUT_16BIT                                \
+    } else {                                   \
+      tmp = 0xD800 | ((in - 0x10000) >> 10);   \
+      PUT_16BIT                                \
+      tmp = 0xDC00 | ((in - 0x10000) & 0x3FF); \
+      PUT_16BIT                                \
+    }                                          \
+  }
+
+#include "mem.h"
+
+#ifdef HAVE_AV_CONFIG_H
+#  include "internal.h"
+#endif /* HAVE_AV_CONFIG_H */
+
+#endif /* AVUTIL_COMMON_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/cpu.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/cpu.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/cpu.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_CPU_H
+#define AVUTIL_CPU_H
+
+#include <stddef.h>
+
+#define AV_CPU_FLAG_FORCE 0x80000000 /* force usage of selected flags (OR) */
+
+/* lower 16 bits - CPU features */
+#define AV_CPU_FLAG_MMX 0x0001     ///< standard MMX
+#define AV_CPU_FLAG_MMXEXT 0x0002  ///< SSE integer functions or AMD MMX ext
+#define AV_CPU_FLAG_MMX2 0x0002    ///< SSE integer functions or AMD MMX ext
+#define AV_CPU_FLAG_3DNOW 0x0004   ///< AMD 3DNOW
+#define AV_CPU_FLAG_SSE 0x0008     ///< SSE functions
+#define AV_CPU_FLAG_SSE2 0x0010    ///< PIV SSE2 functions
+#define AV_CPU_FLAG_SSE2SLOW \
+  0x40000000                         ///< SSE2 supported, but usually not faster
+                                     ///< than regular MMX/SSE (e.g. Core1)
+#define AV_CPU_FLAG_3DNOWEXT 0x0020  ///< AMD 3DNowExt
+#define AV_CPU_FLAG_SSE3 0x0040      ///< Prescott SSE3 functions
+#define AV_CPU_FLAG_SSE3SLOW \
+  0x20000000                      ///< SSE3 supported, but usually not faster
+                                  ///< than regular MMX/SSE (e.g. Core1)
+#define AV_CPU_FLAG_SSSE3 0x0080  ///< Conroe SSSE3 functions
+#define AV_CPU_FLAG_SSSE3SLOW \
+  0x4000000  ///< SSSE3 supported, but usually not faster
+#define AV_CPU_FLAG_ATOM \
+  0x10000000  ///< Atom processor, some SSSE3 instructions are slower
+#define AV_CPU_FLAG_SSE4 0x0100    ///< Penryn SSE4.1 functions
+#define AV_CPU_FLAG_SSE42 0x0200   ///< Nehalem SSE4.2 functions
+#define AV_CPU_FLAG_AESNI 0x80000  ///< Advanced Encryption Standard functions
+#define AV_CPU_FLAG_AVX \
+  0x4000  ///< AVX functions: requires OS support even if YMM registers aren't
+          ///< used
+#define AV_CPU_FLAG_AVXSLOW \
+  0x8000000  ///< AVX supported, but slow when using YMM registers (e.g.
+             ///< Bulldozer)
+#define AV_CPU_FLAG_XOP 0x0400   ///< Bulldozer XOP functions
+#define AV_CPU_FLAG_FMA4 0x0800  ///< Bulldozer FMA4 functions
+#define AV_CPU_FLAG_CMOV 0x1000  ///< supports cmov instruction
+#define AV_CPU_FLAG_AVX2 \
+  0x8000  ///< AVX2 functions: requires OS support even if YMM registers aren't
+          ///< used
+#define AV_CPU_FLAG_FMA3 0x10000  ///< Haswell FMA3 functions
+#define AV_CPU_FLAG_BMI1 0x20000  ///< Bit Manipulation Instruction Set 1
+#define AV_CPU_FLAG_BMI2 0x40000  ///< Bit Manipulation Instruction Set 2
+#define AV_CPU_FLAG_AVX512 \
+  0x100000  ///< AVX-512 functions: requires OS support even if YMM/ZMM
+            ///< registers aren't used
+#define AV_CPU_FLAG_AVX512ICL \
+  0x200000  ///< F/CD/BW/DQ/VL/VNNI/IFMA/VBMI/VBMI2/VPOPCNTDQ/BITALG/GFNI/VAES/VPCLMULQDQ
+#define AV_CPU_FLAG_SLOW_GATHER 0x2000000  ///< CPU has slow gathers.
+
+#define AV_CPU_FLAG_ALTIVEC 0x0001  ///< standard
+#define AV_CPU_FLAG_VSX 0x0002      ///< ISA 2.06
+#define AV_CPU_FLAG_POWER8 0x0004   ///< ISA 2.07
+
+#define AV_CPU_FLAG_ARMV5TE (1 << 0)
+#define AV_CPU_FLAG_ARMV6 (1 << 1)
+#define AV_CPU_FLAG_ARMV6T2 (1 << 2)
+#define AV_CPU_FLAG_VFP (1 << 3)
+#define AV_CPU_FLAG_VFPV3 (1 << 4)
+#define AV_CPU_FLAG_NEON (1 << 5)
+#define AV_CPU_FLAG_ARMV8 (1 << 6)
+#define AV_CPU_FLAG_VFP_VM \
+  (1 << 7)  ///< VFPv2 vector mode, deprecated in ARMv7-A and unavailable in
+            ///< various CPUs implementations
+#define AV_CPU_FLAG_SETEND (1 << 16)
+
+#define AV_CPU_FLAG_MMI (1 << 0)
+#define AV_CPU_FLAG_MSA (1 << 1)
+
+// Loongarch SIMD extension.
+#define AV_CPU_FLAG_LSX (1 << 0)
+#define AV_CPU_FLAG_LASX (1 << 1)
+
+// RISC-V extensions
+#define AV_CPU_FLAG_RVI (1 << 0)        ///< I (full GPR bank)
+#define AV_CPU_FLAG_RVF (1 << 1)        ///< F (single precision FP)
+#define AV_CPU_FLAG_RVD (1 << 2)        ///< D (double precision FP)
+#define AV_CPU_FLAG_RVV_I32 (1 << 3)    ///< Vectors of 8/16/32-bit int's */
+#define AV_CPU_FLAG_RVV_F32 (1 << 4)    ///< Vectors of float's */
+#define AV_CPU_FLAG_RVV_I64 (1 << 5)    ///< Vectors of 64-bit int's */
+#define AV_CPU_FLAG_RVV_F64 (1 << 6)    ///< Vectors of double's
+#define AV_CPU_FLAG_RVB_BASIC (1 << 7)  ///< Basic bit-manipulations
+
+/**
+ * Return the flags which specify extensions supported by the CPU.
+ * The returned value is affected by av_force_cpu_flags() if that was used
+ * before. So av_get_cpu_flags() can easily be used in an application to
+ * detect the enabled cpu flags.
+ */
+int av_get_cpu_flags(void);
+
+/**
+ * Disables cpu detection and forces the specified flags.
+ * -1 is a special case that disables forcing of specific flags.
+ */
+void av_force_cpu_flags(int flags);
+
+/**
+ * Parse CPU caps from a string and update the given AV_CPU_* flags based on
+ * that.
+ *
+ * @return negative on error.
+ */
+int av_parse_cpu_caps(unsigned* flags, const char* s);
+
+/**
+ * @return the number of logical CPU cores present.
+ */
+int av_cpu_count(void);
+
+/**
+ * Overrides cpu count detection and forces the specified count.
+ * Count < 1 disables forcing of specific count.
+ */
+void av_cpu_force_count(int count);
+
+/**
+ * Get the maximum data alignment that may be required by FFmpeg.
+ *
+ * Note that this is affected by the build configuration and the CPU flags mask,
+ * so e.g. if the CPU supports AVX, but libavutil has been built with
+ * --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through
+ *  av_set_cpu_flags_mask(), then this function will behave as if AVX is not
+ *  present.
+ */
+size_t av_cpu_max_align(void);
+
+#endif /* AVUTIL_CPU_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/dict.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/dict.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/dict.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/dict.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,259 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Public dictionary API.
+ * @deprecated
+ *  AVDictionary is provided for compatibility with libav. It is both in
+ *  implementation as well as API inefficient. It does not scale and is
+ *  extremely slow with large dictionaries.
+ *  It is recommended that new code uses our tree container from tree.c/h
+ *  where applicable, which uses AVL trees to achieve O(log n) performance.
+ */
+
+#ifndef AVUTIL_DICT_H
+#define AVUTIL_DICT_H
+
+#include <stdint.h>
+
+/**
+ * @addtogroup lavu_dict AVDictionary
+ * @ingroup lavu_data
+ *
+ * @brief Simple key:value store
+ *
+ * @{
+ * Dictionaries are used for storing key-value pairs.
+ *
+ * - To **create an AVDictionary**, simply pass an address of a NULL
+ *   pointer to av_dict_set(). NULL can be used as an empty dictionary
+ *   wherever a pointer to an AVDictionary is required.
+ * - To **insert an entry**, use av_dict_set().
+ * - Use av_dict_get() to **retrieve an entry**.
+ * - To **iterate over all entries**, use av_dict_iterate().
+ * - In order to **free the dictionary and all its contents**, use
+ av_dict_free().
+ *
+ @code
+   AVDictionary *d = NULL;           // "create" an empty dictionary
+   AVDictionaryEntry *t = NULL;
+
+   av_dict_set(&d, "foo", "bar", 0); // add an entry
+
+   char *k = av_strdup("key");       // if your strings are already allocated,
+   char *v = av_strdup("value");     // you can avoid copying them like this
+   av_dict_set(&d, k, v, AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);
+
+   while ((t = av_dict_iterate(d, t))) {
+       <....>                        // iterate over all entries in d
+   }
+   av_dict_free(&d);
+ @endcode
+ */
+
+/**
+ * @name AVDictionary Flags
+ * Flags that influence behavior of the matching of keys or insertion to the
+ * dictionary.
+ * @{
+ */
+#define AV_DICT_MATCH_CASE                                             \
+  1 /**< Only get an entry with exact-case key match. Only relevant in \
+       av_dict_get(). */
+#define AV_DICT_IGNORE_SUFFIX                                               \
+  2 /**< Return first entry in a dictionary whose first part corresponds to \
+       the search key, ignoring the suffix of the found key string. Only                          \
+       relevant in av_dict_get(). */
+#define AV_DICT_DONT_STRDUP_KEY              \
+  4 /**< Take ownership of a key that's been \
+         allocated with av_malloc() or another memory allocation function. */
+#define AV_DICT_DONT_STRDUP_VAL                                              \
+  8                               /**< Take ownership of a value that's been \
+                                       allocated with av_malloc() or another memory allocation function. */
+#define AV_DICT_DONT_OVERWRITE 16 /**< Don't overwrite existing entries. */
+#define AV_DICT_APPEND                                             \
+  32 /**< If the entry already exists, append to it.  Note that no \
+          delimiter is added, the strings are simply concatenated. */
+#define AV_DICT_MULTIKEY \
+  64 /**< Allow to store several equal keys in the dictionary */
+/**
+ * @}
+ */
+
+typedef struct AVDictionaryEntry {
+  char* key;
+  char* value;
+} AVDictionaryEntry;
+
+typedef struct AVDictionary AVDictionary;
+
+/**
+ * Get a dictionary entry with matching key.
+ *
+ * The returned entry key or value must not be changed, or it will
+ * cause undefined behavior.
+ *
+ * @param prev  Set to the previous matching element to find the next.
+ *              If set to NULL the first matching element is returned.
+ * @param key   Matching key
+ * @param flags A collection of AV_DICT_* flags controlling how the
+ *              entry is retrieved
+ *
+ * @return      Found entry or NULL in case no matching entry was found in the
+ * dictionary
+ */
+AVDictionaryEntry* av_dict_get(const AVDictionary* m, const char* key,
+                               const AVDictionaryEntry* prev, int flags);
+
+/**
+ * Iterate over a dictionary
+ *
+ * Iterates through all entries in the dictionary.
+ *
+ * @warning The returned AVDictionaryEntry key/value must not be changed.
+ *
+ * @warning As av_dict_set() invalidates all previous entries returned
+ * by this function, it must not be called while iterating over the dict.
+ *
+ * Typical usage:
+ * @code
+ * const AVDictionaryEntry *e = NULL;
+ * while ((e = av_dict_iterate(m, e))) {
+ *     // ...
+ * }
+ * @endcode
+ *
+ * @param m     The dictionary to iterate over
+ * @param prev  Pointer to the previous AVDictionaryEntry, NULL initially
+ *
+ * @retval AVDictionaryEntry* The next element in the dictionary
+ * @retval NULL               No more elements in the dictionary
+ */
+const AVDictionaryEntry* av_dict_iterate(const AVDictionary* m,
+                                         const AVDictionaryEntry* prev);
+
+/**
+ * Get number of entries in dictionary.
+ *
+ * @param m dictionary
+ * @return  number of entries in dictionary
+ */
+int av_dict_count(const AVDictionary* m);
+
+/**
+ * Set the given entry in *pm, overwriting an existing entry.
+ *
+ * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
+ * these arguments will be freed on error.
+ *
+ * @warning Adding a new entry to a dictionary invalidates all existing entries
+ * previously returned with av_dict_get() or av_dict_iterate().
+ *
+ * @param pm        Pointer to a pointer to a dictionary struct. If *pm is NULL
+ *                  a dictionary struct is allocated and put in *pm.
+ * @param key       Entry key to add to *pm (will either be av_strduped or added
+ * as a new key depending on flags)
+ * @param value     Entry value to add to *pm (will be av_strduped or added as a
+ * new key depending on flags). Passing a NULL value will cause an existing
+ * entry to be deleted.
+ *
+ * @return          >= 0 on success otherwise an error code <0
+ */
+int av_dict_set(AVDictionary** pm, const char* key, const char* value,
+                int flags);
+
+/**
+ * Convenience wrapper for av_dict_set() that converts the value to a string
+ * and stores it.
+ *
+ * Note: If ::AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
+ */
+int av_dict_set_int(AVDictionary** pm, const char* key, int64_t value,
+                    int flags);
+
+/**
+ * Parse the key/value pairs list and add the parsed entries to a dictionary.
+ *
+ * In case of failure, all the successfully set entries are stored in
+ * *pm. You may need to manually free the created dictionary.
+ *
+ * @param key_val_sep  A 0-terminated list of characters used to separate
+ *                     key from value
+ * @param pairs_sep    A 0-terminated list of characters used to separate
+ *                     two pairs from each other
+ * @param flags        Flags to use when adding to the dictionary.
+ *                     ::AV_DICT_DONT_STRDUP_KEY and ::AV_DICT_DONT_STRDUP_VAL
+ *                     are ignored since the key/value tokens will always
+ *                     be duplicated.
+ *
+ * @return             0 on success, negative AVERROR code on failure
+ */
+int av_dict_parse_string(AVDictionary** pm, const char* str,
+                         const char* key_val_sep, const char* pairs_sep,
+                         int flags);
+
+/**
+ * Copy entries from one AVDictionary struct into another.
+ *
+ * @note Metadata is read using the ::AV_DICT_IGNORE_SUFFIX flag
+ *
+ * @param dst   Pointer to a pointer to a AVDictionary struct to copy into. If
+ * *dst is NULL, this function will allocate a struct for you and put it in *dst
+ * @param src   Pointer to the source AVDictionary struct to copy items from.
+ * @param flags Flags to use when setting entries in *dst
+ *
+ * @return 0 on success, negative AVERROR code on failure. If dst was allocated
+ *           by this function, callers should free the associated memory.
+ */
+int av_dict_copy(AVDictionary** dst, const AVDictionary* src, int flags);
+
+/**
+ * Free all the memory allocated for an AVDictionary struct
+ * and all keys and values.
+ */
+void av_dict_free(AVDictionary** m);
+
+/**
+ * Get dictionary entries as a string.
+ *
+ * Create a string containing dictionary's entries.
+ * Such string may be passed back to av_dict_parse_string().
+ * @note String is escaped with backslashes ('\').
+ *
+ * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the
+ * same.
+ *
+ * @param[in]  m             The dictionary
+ * @param[out] buffer        Pointer to buffer that will be allocated with
+ * string containg entries. Buffer must be freed by the caller when is no longer
+ * needed.
+ * @param[in]  key_val_sep   Character used to separate key from value
+ * @param[in]  pairs_sep     Character used to separate two pairs from each
+ * other
+ *
+ * @return                   >= 0 on success, negative on error
+ */
+int av_dict_get_string(const AVDictionary* m, char** buffer,
+                       const char key_val_sep, const char pairs_sep);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_DICT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/error.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/error.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/error.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/error.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,158 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * error code definitions
+ */
+
+#ifndef AVUTIL_ERROR_H
+#define AVUTIL_ERROR_H
+
+#include <errno.h>
+#include <stddef.h>
+
+#include "macros.h"
+
+/**
+ * @addtogroup lavu_error
+ *
+ * @{
+ */
+
+/* error handling */
+#if EDOM > 0
+#  define AVERROR(e) \
+    (-(e))  ///< Returns a negative error code from a POSIX error code, to
+            ///< return from library functions.
+#  define AVUNERROR(e) \
+    (-(e))  ///< Returns a POSIX error code from a library function error return
+            ///< value.
+#else
+/* Some platforms have E* and errno already negated. */
+#  define AVERROR(e) (e)
+#  define AVUNERROR(e) (e)
+#endif
+
+#define FFERRTAG(a, b, c, d) (-(int)MKTAG(a, b, c, d))
+
+#define AVERROR_BSF_NOT_FOUND \
+  FFERRTAG(0xF8, 'B', 'S', 'F')  ///< Bitstream filter not found
+#define AVERROR_BUG \
+  FFERRTAG('B', 'U', 'G', '!')  ///< Internal bug, also see AVERROR_BUG2
+#define AVERROR_BUFFER_TOO_SMALL \
+  FFERRTAG('B', 'U', 'F', 'S')  ///< Buffer too small
+#define AVERROR_DECODER_NOT_FOUND \
+  FFERRTAG(0xF8, 'D', 'E', 'C')  ///< Decoder not found
+#define AVERROR_DEMUXER_NOT_FOUND \
+  FFERRTAG(0xF8, 'D', 'E', 'M')  ///< Demuxer not found
+#define AVERROR_ENCODER_NOT_FOUND \
+  FFERRTAG(0xF8, 'E', 'N', 'C')                   ///< Encoder not found
+#define AVERROR_EOF FFERRTAG('E', 'O', 'F', ' ')  ///< End of file
+#define AVERROR_EXIT \
+  FFERRTAG('E', 'X', 'I', 'T')  ///< Immediate exit was requested; the called
+                                ///< function should not be restarted
+#define AVERROR_EXTERNAL \
+  FFERRTAG('E', 'X', 'T', ' ')  ///< Generic error in an external library
+#define AVERROR_FILTER_NOT_FOUND \
+  FFERRTAG(0xF8, 'F', 'I', 'L')  ///< Filter not found
+#define AVERROR_INVALIDDATA \
+  FFERRTAG('I', 'N', 'D', 'A')  ///< Invalid data found when processing input
+#define AVERROR_MUXER_NOT_FOUND \
+  FFERRTAG(0xF8, 'M', 'U', 'X')  ///< Muxer not found
+#define AVERROR_OPTION_NOT_FOUND \
+  FFERRTAG(0xF8, 'O', 'P', 'T')  ///< Option not found
+#define AVERROR_PATCHWELCOME \
+  FFERRTAG('P', 'A', 'W',    \
+           'E')  ///< Not yet implemented in FFmpeg, patches welcome
+#define AVERROR_PROTOCOL_NOT_FOUND \
+  FFERRTAG(0xF8, 'P', 'R', 'O')  ///< Protocol not found
+
+#define AVERROR_STREAM_NOT_FOUND \
+  FFERRTAG(0xF8, 'S', 'T', 'R')  ///< Stream not found
+/**
+ * This is semantically identical to AVERROR_BUG
+ * it has been introduced in Libav after our AVERROR_BUG and with a modified
+ * value.
+ */
+#define AVERROR_BUG2 FFERRTAG('B', 'U', 'G', ' ')
+#define AVERROR_UNKNOWN   \
+  FFERRTAG('U', 'N', 'K', \
+           'N')  ///< Unknown error, typically from an external library
+#define AVERROR_EXPERIMENTAL \
+  (-0x2bb2afa8)  ///< Requested feature is flagged experimental. Set
+                 ///< strict_std_compliance if you really want to use it.
+#define AVERROR_INPUT_CHANGED \
+  (-0x636e6701)  ///< Input changed between calls. Reconfiguration is required.
+                 ///< (can be OR-ed with AVERROR_OUTPUT_CHANGED)
+#define AVERROR_OUTPUT_CHANGED \
+  (-0x636e6702)  ///< Output changed between calls. Reconfiguration is required.
+                 ///< (can be OR-ed with AVERROR_INPUT_CHANGED)
+/* HTTP & RTSP errors */
+#define AVERROR_HTTP_BAD_REQUEST FFERRTAG(0xF8, '4', '0', '0')
+#define AVERROR_HTTP_UNAUTHORIZED FFERRTAG(0xF8, '4', '0', '1')
+#define AVERROR_HTTP_FORBIDDEN FFERRTAG(0xF8, '4', '0', '3')
+#define AVERROR_HTTP_NOT_FOUND FFERRTAG(0xF8, '4', '0', '4')
+#define AVERROR_HTTP_OTHER_4XX FFERRTAG(0xF8, '4', 'X', 'X')
+#define AVERROR_HTTP_SERVER_ERROR FFERRTAG(0xF8, '5', 'X', 'X')
+
+#define AV_ERROR_MAX_STRING_SIZE 64
+
+/**
+ * Put a description of the AVERROR code errnum in errbuf.
+ * In case of failure the global variable errno is set to indicate the
+ * error. Even in case of failure av_strerror() will print a generic
+ * error message indicating the errnum provided to errbuf.
+ *
+ * @param errnum      error code to describe
+ * @param errbuf      buffer to which description is written
+ * @param errbuf_size the size in bytes of errbuf
+ * @return 0 on success, a negative value if a description for errnum
+ * cannot be found
+ */
+int av_strerror(int errnum, char* errbuf, size_t errbuf_size);
+
+/**
+ * Fill the provided buffer with a string containing an error string
+ * corresponding to the AVERROR code errnum.
+ *
+ * @param errbuf         a buffer
+ * @param errbuf_size    size in bytes of errbuf
+ * @param errnum         error code to describe
+ * @return the buffer in input, filled with the error description
+ * @see av_strerror()
+ */
+static inline char* av_make_error_string(char* errbuf, size_t errbuf_size,
+                                         int errnum) {
+  av_strerror(errnum, errbuf, errbuf_size);
+  return errbuf;
+}
+
+/**
+ * Convenience macro, the return value should be used only directly in
+ * function arguments but never stand-alone.
+ */
+#define av_err2str(errnum)                                  \
+  av_make_error_string((char[AV_ERROR_MAX_STRING_SIZE]){0}, \
+                       AV_ERROR_MAX_STRING_SIZE, errnum)
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_ERROR_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/frame.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/frame.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/frame.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/frame.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,960 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @ingroup lavu_frame
+ * reference-counted frame API
+ */
+
+#ifndef AVUTIL_FRAME_H
+#define AVUTIL_FRAME_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "avutil.h"
+#include "buffer.h"
+#include "channel_layout.h"
+#include "dict.h"
+#include "rational.h"
+#include "samplefmt.h"
+#include "pixfmt.h"
+#include "version.h"
+
+/**
+ * @defgroup lavu_frame AVFrame
+ * @ingroup lavu_data
+ *
+ * @{
+ * AVFrame is an abstraction for reference-counted raw multimedia data.
+ */
+
+enum AVFrameSideDataType {
+  /**
+   * The data is the AVPanScan struct defined in libavcodec.
+   */
+  AV_FRAME_DATA_PANSCAN,
+  /**
+   * ATSC A53 Part 4 Closed Captions.
+   * A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.
+   * The number of bytes of CC data is AVFrameSideData.size.
+   */
+  AV_FRAME_DATA_A53_CC,
+  /**
+   * Stereoscopic 3d metadata.
+   * The data is the AVStereo3D struct defined in libavutil/stereo3d.h.
+   */
+  AV_FRAME_DATA_STEREO3D,
+  /**
+   * The data is the AVMatrixEncoding enum defined in
+   * libavutil/channel_layout.h.
+   */
+  AV_FRAME_DATA_MATRIXENCODING,
+  /**
+   * Metadata relevant to a downmix procedure.
+   * The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.
+   */
+  AV_FRAME_DATA_DOWNMIX_INFO,
+  /**
+   * ReplayGain information in the form of the AVReplayGain struct.
+   */
+  AV_FRAME_DATA_REPLAYGAIN,
+  /**
+   * This side data contains a 3x3 transformation matrix describing an affine
+   * transformation that needs to be applied to the frame for correct
+   * presentation.
+   *
+   * See libavutil/display.h for a detailed description of the data.
+   */
+  AV_FRAME_DATA_DISPLAYMATRIX,
+  /**
+   * Active Format Description data consisting of a single byte as specified
+   * in ETSI TS 101 154 using AVActiveFormatDescription enum.
+   */
+  AV_FRAME_DATA_AFD,
+  /**
+   * Motion vectors exported by some codecs (on demand through the export_mvs
+   * flag set in the libavcodec AVCodecContext flags2 option).
+   * The data is the AVMotionVector struct defined in
+   * libavutil/motion_vector.h.
+   */
+  AV_FRAME_DATA_MOTION_VECTORS,
+  /**
+   * Recommmends skipping the specified number of samples. This is exported
+   * only if the "skip_manual" AVOption is set in libavcodec.
+   * This has the same format as AV_PKT_DATA_SKIP_SAMPLES.
+   * @code
+   * u32le number of samples to skip from start of this packet
+   * u32le number of samples to skip from end of this packet
+   * u8    reason for start skip
+   * u8    reason for end   skip (0=padding silence, 1=convergence)
+   * @endcode
+   */
+  AV_FRAME_DATA_SKIP_SAMPLES,
+  /**
+   * This side data must be associated with an audio frame and corresponds to
+   * enum AVAudioServiceType defined in avcodec.h.
+   */
+  AV_FRAME_DATA_AUDIO_SERVICE_TYPE,
+  /**
+   * Mastering display metadata associated with a video frame. The payload is
+   * an AVMasteringDisplayMetadata type and contains information about the
+   * mastering display color volume.
+   */
+  AV_FRAME_DATA_MASTERING_DISPLAY_METADATA,
+  /**
+   * The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.
+   * This is set on the first frame of a GOP that has a temporal reference of 0.
+   */
+  AV_FRAME_DATA_GOP_TIMECODE,
+
+  /**
+   * The data represents the AVSphericalMapping structure defined in
+   * libavutil/spherical.h.
+   */
+  AV_FRAME_DATA_SPHERICAL,
+
+  /**
+   * Content light level (based on CTA-861.3). This payload contains data in
+   * the form of the AVContentLightMetadata struct.
+   */
+  AV_FRAME_DATA_CONTENT_LIGHT_LEVEL,
+
+  /**
+   * The data contains an ICC profile as an opaque octet buffer following the
+   * format described by ISO 15076-1 with an optional name defined in the
+   * metadata key entry "name".
+   */
+  AV_FRAME_DATA_ICC_PROFILE,
+
+  /**
+   * Timecode which conforms to SMPTE ST 12-1. The data is an array of 4
+   * uint32_t where the first uint32_t describes how many (1-3) of the other
+   * timecodes are used. The timecode format is described in the documentation
+   * of av_timecode_get_smpte_from_framenum() function in libavutil/timecode.h.
+   */
+  AV_FRAME_DATA_S12M_TIMECODE,
+
+  /**
+   * HDR dynamic metadata associated with a video frame. The payload is
+   * an AVDynamicHDRPlus type and contains information for color
+   * volume transform - application 4 of SMPTE 2094-40:2016 standard.
+   */
+  AV_FRAME_DATA_DYNAMIC_HDR_PLUS,
+
+  /**
+   * Regions Of Interest, the data is an array of AVRegionOfInterest type, the
+   * number of array element is implied by AVFrameSideData.size /
+   * AVRegionOfInterest.self_size.
+   */
+  AV_FRAME_DATA_REGIONS_OF_INTEREST,
+
+  /**
+   * Encoding parameters for a video frame, as described by AVVideoEncParams.
+   */
+  AV_FRAME_DATA_VIDEO_ENC_PARAMS,
+
+  /**
+   * User data unregistered metadata associated with a video frame.
+   * This is the H.26[45] UDU SEI message, and shouldn't be used for any other
+   * purpose The data is stored as uint8_t in AVFrameSideData.data which is 16
+   * bytes of uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of
+   * user_data_payload_byte.
+   */
+  AV_FRAME_DATA_SEI_UNREGISTERED,
+
+  /**
+   * Film grain parameters for a frame, described by AVFilmGrainParams.
+   * Must be present for every frame which should have film grain applied.
+   */
+  AV_FRAME_DATA_FILM_GRAIN_PARAMS,
+
+  /**
+   * Bounding boxes for object detection and classification,
+   * as described by AVDetectionBBoxHeader.
+   */
+  AV_FRAME_DATA_DETECTION_BBOXES,
+
+  /**
+   * Dolby Vision RPU raw data, suitable for passing to x265
+   * or other libraries. Array of uint8_t, with NAL emulation
+   * bytes intact.
+   */
+  AV_FRAME_DATA_DOVI_RPU_BUFFER,
+
+  /**
+   * Parsed Dolby Vision metadata, suitable for passing to a software
+   * implementation. The payload is the AVDOVIMetadata struct defined in
+   * libavutil/dovi_meta.h.
+   */
+  AV_FRAME_DATA_DOVI_METADATA,
+
+  /**
+   * HDR Vivid dynamic metadata associated with a video frame. The payload is
+   * an AVDynamicHDRVivid type and contains information for color
+   * volume transform - CUVA 005.1-2021.
+   */
+  AV_FRAME_DATA_DYNAMIC_HDR_VIVID,
+
+  /**
+   * Ambient viewing environment metadata, as defined by H.274.
+   */
+  AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT,
+};
+
+enum AVActiveFormatDescription {
+  AV_AFD_SAME = 8,
+  AV_AFD_4_3 = 9,
+  AV_AFD_16_9 = 10,
+  AV_AFD_14_9 = 11,
+  AV_AFD_4_3_SP_14_9 = 13,
+  AV_AFD_16_9_SP_14_9 = 14,
+  AV_AFD_SP_4_3 = 15,
+};
+
+/**
+ * Structure to hold side data for an AVFrame.
+ *
+ * sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be
+ * added to the end with a minor bump.
+ */
+typedef struct AVFrameSideData {
+  enum AVFrameSideDataType type;
+  uint8_t* data;
+  size_t size;
+  AVDictionary* metadata;
+  AVBufferRef* buf;
+} AVFrameSideData;
+
+/**
+ * Structure describing a single Region Of Interest.
+ *
+ * When multiple regions are defined in a single side-data block, they
+ * should be ordered from most to least important - some encoders are only
+ * capable of supporting a limited number of distinct regions, so will have
+ * to truncate the list.
+ *
+ * When overlapping regions are defined, the first region containing a given
+ * area of the frame applies.
+ */
+typedef struct AVRegionOfInterest {
+  /**
+   * Must be set to the size of this data structure (that is,
+   * sizeof(AVRegionOfInterest)).
+   */
+  uint32_t self_size;
+  /**
+   * Distance in pixels from the top edge of the frame to the top and
+   * bottom edges and from the left edge of the frame to the left and
+   * right edges of the rectangle defining this region of interest.
+   *
+   * The constraints on a region are encoder dependent, so the region
+   * actually affected may be slightly larger for alignment or other
+   * reasons.
+   */
+  int top;
+  int bottom;
+  int left;
+  int right;
+  /**
+   * Quantisation offset.
+   *
+   * Must be in the range -1 to +1.  A value of zero indicates no quality
+   * change.  A negative value asks for better quality (less quantisation),
+   * while a positive value asks for worse quality (greater quantisation).
+   *
+   * The range is calibrated so that the extreme values indicate the
+   * largest possible offset - if the rest of the frame is encoded with the
+   * worst possible quality, an offset of -1 indicates that this region
+   * should be encoded with the best possible quality anyway.  Intermediate
+   * values are then interpolated in some codec-dependent way.
+   *
+   * For example, in 10-bit H.264 the quantisation parameter varies between
+   * -12 and 51.  A typical qoffset value of -1/10 therefore indicates that
+   * this region should be encoded with a QP around one-tenth of the full
+   * range better than the rest of the frame.  So, if most of the frame
+   * were to be encoded with a QP of around 30, this region would get a QP
+   * of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).
+   * An extreme value of -1 would indicate that this region should be
+   * encoded with the best possible quality regardless of the treatment of
+   * the rest of the frame - that is, should be encoded at a QP of -12.
+   */
+  AVRational qoffset;
+} AVRegionOfInterest;
+
+/**
+ * This structure describes decoded (raw) audio or video data.
+ *
+ * AVFrame must be allocated using av_frame_alloc(). Note that this only
+ * allocates the AVFrame itself, the buffers for the data must be managed
+ * through other means (see below).
+ * AVFrame must be freed with av_frame_free().
+ *
+ * AVFrame is typically allocated once and then reused multiple times to hold
+ * different data (e.g. a single AVFrame to hold frames received from a
+ * decoder). In such a case, av_frame_unref() will free any references held by
+ * the frame and reset it to its original clean state before it
+ * is reused again.
+ *
+ * The data described by an AVFrame is usually reference counted through the
+ * AVBuffer API. The underlying buffer references are stored in AVFrame.buf /
+ * AVFrame.extended_buf. An AVFrame is considered to be reference counted if at
+ * least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,
+ * every single data plane must be contained in one of the buffers in
+ * AVFrame.buf or AVFrame.extended_buf.
+ * There may be a single buffer for all the data, or one separate buffer for
+ * each plane, or anything in between.
+ *
+ * sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
+ * to the end with a minor bump.
+ *
+ * Fields can be accessed through AVOptions, the name string used, matches the
+ * C structure field name for fields accessible through AVOptions. The AVClass
+ * for AVFrame can be obtained from avcodec_get_frame_class()
+ */
+typedef struct AVFrame {
+#define AV_NUM_DATA_POINTERS 8
+  /**
+   * pointer to the picture/channel planes.
+   * This might be different from the first allocated byte. For video,
+   * it could even point to the end of the image data.
+   *
+   * All pointers in data and extended_data must point into one of the
+   * AVBufferRef in buf or extended_buf.
+   *
+   * Some decoders access areas outside 0,0 - width,height, please
+   * see avcodec_align_dimensions2(). Some filters and swscale can read
+   * up to 16 bytes beyond the planes, if these filters are to be used,
+   * then 16 extra bytes must be allocated.
+   *
+   * NOTE: Pointers not needed by the format MUST be set to NULL.
+   *
+   * @attention In case of video, the data[] pointers can point to the
+   * end of image data in order to reverse line order, when used in
+   * combination with negative values in the linesize[] array.
+   */
+  uint8_t* data[AV_NUM_DATA_POINTERS];
+
+  /**
+   * For video, a positive or negative value, which is typically indicating
+   * the size in bytes of each picture line, but it can also be:
+   * - the negative byte size of lines for vertical flipping
+   *   (with data[n] pointing to the end of the data
+   * - a positive or negative multiple of the byte size as for accessing
+   *   even and odd fields of a frame (possibly flipped)
+   *
+   * For audio, only linesize[0] may be set. For planar audio, each channel
+   * plane must be the same size.
+   *
+   * For video the linesizes should be multiples of the CPUs alignment
+   * preference, this is 16 or 32 for modern desktop CPUs.
+   * Some code requires such alignment other code can be slower without
+   * correct alignment, for yet other it makes no difference.
+   *
+   * @note The linesize may be larger than the size of usable data -- there
+   * may be extra padding present for performance reasons.
+   *
+   * @attention In case of video, line size values can be negative to achieve
+   * a vertically inverted iteration over image lines.
+   */
+  int linesize[AV_NUM_DATA_POINTERS];
+
+  /**
+   * pointers to the data planes/channels.
+   *
+   * For video, this should simply point to data[].
+   *
+   * For planar audio, each channel has a separate data pointer, and
+   * linesize[0] contains the size of each channel buffer.
+   * For packed audio, there is just one data pointer, and linesize[0]
+   * contains the total size of the buffer for all channels.
+   *
+   * Note: Both data and extended_data should always be set in a valid frame,
+   * but for planar audio with more channels that can fit in data,
+   * extended_data must be used in order to access all channels.
+   */
+  uint8_t** extended_data;
+
+  /**
+   * @name Video dimensions
+   * Video frames only. The coded dimensions (in pixels) of the video frame,
+   * i.e. the size of the rectangle that contains some well-defined values.
+   *
+   * @note The part of the frame intended for display/presentation is further
+   * restricted by the @ref cropping "Cropping rectangle".
+   * @{
+   */
+  int width, height;
+  /**
+   * @}
+   */
+
+  /**
+   * number of audio samples (per channel) described by this frame
+   */
+  int nb_samples;
+
+  /**
+   * format of the frame, -1 if unknown or unset
+   * Values correspond to enum AVPixelFormat for video frames,
+   * enum AVSampleFormat for audio)
+   */
+  int format;
+
+  /**
+   * 1 -> keyframe, 0-> not
+   */
+  int key_frame;
+
+  /**
+   * Picture type of the frame.
+   */
+  enum AVPictureType pict_type;
+
+  /**
+   * Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
+   */
+  AVRational sample_aspect_ratio;
+
+  /**
+   * Presentation timestamp in time_base units (time when frame should be shown
+   * to user).
+   */
+  int64_t pts;
+
+  /**
+   * DTS copied from the AVPacket that triggered returning this frame. (if frame
+   * threading isn't used) This is also the Presentation time of this AVFrame
+   * calculated from only AVPacket.dts values without pts values.
+   */
+  int64_t pkt_dts;
+
+  /**
+   * Time base for the timestamps in this frame.
+   * In the future, this field may be set on frames output by decoders or
+   * filters, but its value will be by default ignored on input to encoders
+   * or filters.
+   */
+  AVRational time_base;
+
+#if FF_API_FRAME_PICTURE_NUMBER
+  /**
+   * picture number in bitstream order
+   */
+  attribute_deprecated int coded_picture_number;
+  /**
+   * picture number in display order
+   */
+  attribute_deprecated int display_picture_number;
+#endif
+
+  /**
+   * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
+   */
+  int quality;
+
+  /**
+   * for some private data of the user
+   */
+  void* opaque;
+
+  /**
+   * When decoding, this signals how much the picture must be delayed.
+   * extra_delay = repeat_pict / (2*fps)
+   */
+  int repeat_pict;
+
+  /**
+   * The content of the picture is interlaced.
+   */
+  int interlaced_frame;
+
+  /**
+   * If the content is interlaced, is top field displayed first.
+   */
+  int top_field_first;
+
+  /**
+   * Tell user application that palette has changed from previous frame.
+   */
+  int palette_has_changed;
+
+#if FF_API_REORDERED_OPAQUE
+  /**
+   * reordered opaque 64 bits (generally an integer or a double precision float
+   * PTS but can be anything).
+   * The user sets AVCodecContext.reordered_opaque to represent the input at
+   * that time,
+   * the decoder reorders values as needed and sets AVFrame.reordered_opaque
+   * to exactly one of the values provided by the user through
+   * AVCodecContext.reordered_opaque
+   *
+   * @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead
+   */
+  attribute_deprecated int64_t reordered_opaque;
+#endif
+
+  /**
+   * Sample rate of the audio data.
+   */
+  int sample_rate;
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * Channel layout of the audio data.
+   * @deprecated use ch_layout instead
+   */
+  attribute_deprecated uint64_t channel_layout;
+#endif
+
+  /**
+   * AVBuffer references backing the data for this frame. All the pointers in
+   * data and extended_data must point inside one of the buffers in buf or
+   * extended_buf. This array must be filled contiguously -- if buf[i] is
+   * non-NULL then buf[j] must also be non-NULL for all j < i.
+   *
+   * There may be at most one AVBuffer per data plane, so for video this array
+   * always contains all the references. For planar audio with more than
+   * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
+   * this array. Then the extra AVBufferRef pointers are stored in the
+   * extended_buf array.
+   */
+  AVBufferRef* buf[AV_NUM_DATA_POINTERS];
+
+  /**
+   * For planar audio which requires more than AV_NUM_DATA_POINTERS
+   * AVBufferRef pointers, this array will hold all the references which
+   * cannot fit into AVFrame.buf.
+   *
+   * Note that this is different from AVFrame.extended_data, which always
+   * contains all the pointers. This array only contains the extra pointers,
+   * which cannot fit into AVFrame.buf.
+   *
+   * This array is always allocated using av_malloc() by whoever constructs
+   * the frame. It is freed in av_frame_unref().
+   */
+  AVBufferRef** extended_buf;
+  /**
+   * Number of elements in extended_buf.
+   */
+  int nb_extended_buf;
+
+  AVFrameSideData** side_data;
+  int nb_side_data;
+
+/**
+ * @defgroup lavu_frame_flags AV_FRAME_FLAGS
+ * @ingroup lavu_frame
+ * Flags describing additional frame properties.
+ *
+ * @{
+ */
+
+/**
+ * The frame data may be corrupted, e.g. due to decoding errors.
+ */
+#define AV_FRAME_FLAG_CORRUPT (1 << 0)
+/**
+ * A flag to mark the frames which need to be decoded, but shouldn't be output.
+ */
+#define AV_FRAME_FLAG_DISCARD (1 << 2)
+  /**
+   * @}
+   */
+
+  /**
+   * Frame flags, a combination of @ref lavu_frame_flags
+   */
+  int flags;
+
+  /**
+   * MPEG vs JPEG YUV range.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVColorRange color_range;
+
+  enum AVColorPrimaries color_primaries;
+
+  enum AVColorTransferCharacteristic color_trc;
+
+  /**
+   * YUV colorspace type.
+   * - encoding: Set by user
+   * - decoding: Set by libavcodec
+   */
+  enum AVColorSpace colorspace;
+
+  enum AVChromaLocation chroma_location;
+
+  /**
+   * frame timestamp estimated using various heuristics, in stream time base
+   * - encoding: unused
+   * - decoding: set by libavcodec, read by user.
+   */
+  int64_t best_effort_timestamp;
+
+  /**
+   * reordered pos from the last AVPacket that has been input into the decoder
+   * - encoding: unused
+   * - decoding: Read by user.
+   */
+  int64_t pkt_pos;
+
+#if FF_API_PKT_DURATION
+  /**
+   * duration of the corresponding packet, expressed in
+   * AVStream->time_base units, 0 if unknown.
+   * - encoding: unused
+   * - decoding: Read by user.
+   *
+   * @deprecated use duration instead
+   */
+  attribute_deprecated int64_t pkt_duration;
+#endif
+
+  /**
+   * metadata.
+   * - encoding: Set by user.
+   * - decoding: Set by libavcodec.
+   */
+  AVDictionary* metadata;
+
+  /**
+   * decode error flags of the frame, set to a combination of
+   * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
+   * were errors during the decoding.
+   * - encoding: unused
+   * - decoding: set by libavcodec, read by user.
+   */
+  int decode_error_flags;
+#define FF_DECODE_ERROR_INVALID_BITSTREAM 1
+#define FF_DECODE_ERROR_MISSING_REFERENCE 2
+#define FF_DECODE_ERROR_CONCEALMENT_ACTIVE 4
+#define FF_DECODE_ERROR_DECODE_SLICES 8
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+  /**
+   * number of audio channels, only used for audio.
+   * - encoding: unused
+   * - decoding: Read by user.
+   * @deprecated use ch_layout instead
+   */
+  attribute_deprecated int channels;
+#endif
+
+  /**
+   * size of the corresponding packet containing the compressed
+   * frame.
+   * It is set to a negative value if unknown.
+   * - encoding: unused
+   * - decoding: set by libavcodec, read by user.
+   */
+  int pkt_size;
+
+  /**
+   * For hwaccel-format frames, this should be a reference to the
+   * AVHWFramesContext describing the frame.
+   */
+  AVBufferRef* hw_frames_ctx;
+
+  /**
+   * AVBufferRef for free use by the API user. FFmpeg will never check the
+   * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
+   * the frame is unreferenced. av_frame_copy_props() calls create a new
+   * reference with av_buffer_ref() for the target frame's opaque_ref field.
+   *
+   * This is unrelated to the opaque field, although it serves a similar
+   * purpose.
+   */
+  AVBufferRef* opaque_ref;
+
+  /**
+   * @anchor cropping
+   * @name Cropping
+   * Video frames only. The number of pixels to discard from the the
+   * top/bottom/left/right border of the frame to obtain the sub-rectangle of
+   * the frame intended for presentation.
+   * @{
+   */
+  size_t crop_top;
+  size_t crop_bottom;
+  size_t crop_left;
+  size_t crop_right;
+  /**
+   * @}
+   */
+
+  /**
+   * AVBufferRef for internal use by a single libav* library.
+   * Must not be used to transfer data between libraries.
+   * Has to be NULL when ownership of the frame leaves the respective library.
+   *
+   * Code outside the FFmpeg libs should never check or change the contents of
+   * the buffer ref.
+   *
+   * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
+   * av_frame_copy_props() calls create a new reference with av_buffer_ref()
+   * for the target frame's private_ref field.
+   */
+  AVBufferRef* private_ref;
+
+  /**
+   * Channel layout of the audio data.
+   */
+  AVChannelLayout ch_layout;
+
+  /**
+   * Duration of the frame, in the same units as pts. 0 if unknown.
+   */
+  int64_t duration;
+} AVFrame;
+
+/**
+ * Allocate an AVFrame and set its fields to default values.  The resulting
+ * struct must be freed using av_frame_free().
+ *
+ * @return An AVFrame filled with default values or NULL on failure.
+ *
+ * @note this only allocates the AVFrame itself, not the data buffers. Those
+ * must be allocated through other means, e.g. with av_frame_get_buffer() or
+ * manually.
+ */
+AVFrame* av_frame_alloc(void);
+
+/**
+ * Free the frame and any dynamically allocated objects in it,
+ * e.g. extended_data. If the frame is reference counted, it will be
+ * unreferenced first.
+ *
+ * @param frame frame to be freed. The pointer will be set to NULL.
+ */
+void av_frame_free(AVFrame** frame);
+
+/**
+ * Set up a new reference to the data described by the source frame.
+ *
+ * Copy frame properties from src to dst and create a new reference for each
+ * AVBufferRef from src.
+ *
+ * If src is not reference counted, new buffers are allocated and the data is
+ * copied.
+ *
+ * @warning: dst MUST have been either unreferenced with av_frame_unref(dst),
+ *           or newly allocated with av_frame_alloc() before calling this
+ *           function, or undefined behavior will occur.
+ *
+ * @return 0 on success, a negative AVERROR on error
+ */
+int av_frame_ref(AVFrame* dst, const AVFrame* src);
+
+/**
+ * Create a new frame that references the same data as src.
+ *
+ * This is a shortcut for av_frame_alloc()+av_frame_ref().
+ *
+ * @return newly created AVFrame on success, NULL on error.
+ */
+AVFrame* av_frame_clone(const AVFrame* src);
+
+/**
+ * Unreference all the buffers referenced by frame and reset the frame fields.
+ */
+void av_frame_unref(AVFrame* frame);
+
+/**
+ * Move everything contained in src to dst and reset src.
+ *
+ * @warning: dst is not unreferenced, but directly overwritten without reading
+ *           or deallocating its contents. Call av_frame_unref(dst) manually
+ *           before calling this function to ensure that no memory is leaked.
+ */
+void av_frame_move_ref(AVFrame* dst, AVFrame* src);
+
+/**
+ * Allocate new buffer(s) for audio or video data.
+ *
+ * The following fields must be set on frame before calling this function:
+ * - format (pixel format for video, sample format for audio)
+ * - width and height for video
+ * - nb_samples and ch_layout for audio
+ *
+ * This function will fill AVFrame.data and AVFrame.buf arrays and, if
+ * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
+ * For planar formats, one buffer will be allocated for each plane.
+ *
+ * @warning: if frame already has been allocated, calling this function will
+ *           leak memory. In addition, undefined behavior can occur in certain
+ *           cases.
+ *
+ * @param frame frame in which to store the new buffers.
+ * @param align Required buffer size alignment. If equal to 0, alignment will be
+ *              chosen automatically for the current CPU. It is highly
+ *              recommended to pass 0 here unless you know what you are doing.
+ *
+ * @return 0 on success, a negative AVERROR on error.
+ */
+int av_frame_get_buffer(AVFrame* frame, int align);
+
+/**
+ * Check if the frame data is writable.
+ *
+ * @return A positive value if the frame data is writable (which is true if and
+ * only if each of the underlying buffers has only one reference, namely the one
+ * stored in this frame). Return 0 otherwise.
+ *
+ * If 1 is returned the answer is valid until av_buffer_ref() is called on any
+ * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
+ *
+ * @see av_frame_make_writable(), av_buffer_is_writable()
+ */
+int av_frame_is_writable(AVFrame* frame);
+
+/**
+ * Ensure that the frame data is writable, avoiding data copy if possible.
+ *
+ * Do nothing if the frame is writable, allocate new buffers and copy the data
+ * if it is not. Non-refcounted frames behave as non-writable, i.e. a copy
+ * is always made.
+ *
+ * @return 0 on success, a negative AVERROR on error.
+ *
+ * @see av_frame_is_writable(), av_buffer_is_writable(),
+ * av_buffer_make_writable()
+ */
+int av_frame_make_writable(AVFrame* frame);
+
+/**
+ * Copy the frame data from src to dst.
+ *
+ * This function does not allocate anything, dst must be already initialized and
+ * allocated with the same parameters as src.
+ *
+ * This function only copies the frame data (i.e. the contents of the data /
+ * extended data arrays), not any other properties.
+ *
+ * @return >= 0 on success, a negative AVERROR on error.
+ */
+int av_frame_copy(AVFrame* dst, const AVFrame* src);
+
+/**
+ * Copy only "metadata" fields from src to dst.
+ *
+ * Metadata for the purpose of this function are those fields that do not affect
+ * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
+ * aspect ratio (for video), but not width/height or channel layout.
+ * Side data is also copied.
+ */
+int av_frame_copy_props(AVFrame* dst, const AVFrame* src);
+
+/**
+ * Get the buffer reference a given data plane is stored in.
+ *
+ * @param frame the frame to get the plane's buffer from
+ * @param plane index of the data plane of interest in frame->extended_data.
+ *
+ * @return the buffer reference that contains the plane or NULL if the input
+ * frame is not valid.
+ */
+AVBufferRef* av_frame_get_plane_buffer(AVFrame* frame, int plane);
+
+/**
+ * Add a new side data to a frame.
+ *
+ * @param frame a frame to which the side data should be added
+ * @param type type of the added side data
+ * @param size size of the side data
+ *
+ * @return newly added side data on success, NULL on error
+ */
+AVFrameSideData* av_frame_new_side_data(AVFrame* frame,
+                                        enum AVFrameSideDataType type,
+                                        size_t size);
+
+/**
+ * Add a new side data to a frame from an existing AVBufferRef
+ *
+ * @param frame a frame to which the side data should be added
+ * @param type  the type of the added side data
+ * @param buf   an AVBufferRef to add as side data. The ownership of
+ *              the reference is transferred to the frame.
+ *
+ * @return newly added side data on success, NULL on error. On failure
+ *         the frame is unchanged and the AVBufferRef remains owned by
+ *         the caller.
+ */
+AVFrameSideData* av_frame_new_side_data_from_buf(AVFrame* frame,
+                                                 enum AVFrameSideDataType type,
+                                                 AVBufferRef* buf);
+
+/**
+ * @return a pointer to the side data of a given type on success, NULL if there
+ * is no side data with such type in this frame.
+ */
+AVFrameSideData* av_frame_get_side_data(const AVFrame* frame,
+                                        enum AVFrameSideDataType type);
+
+/**
+ * Remove and free all side data instances of the given type.
+ */
+void av_frame_remove_side_data(AVFrame* frame, enum AVFrameSideDataType type);
+
+/**
+ * Flags for frame cropping.
+ */
+enum {
+  /**
+   * Apply the maximum possible cropping, even if it requires setting the
+   * AVFrame.data[] entries to unaligned pointers. Passing unaligned data
+   * to FFmpeg API is generally not allowed, and causes undefined behavior
+   * (such as crashes). You can pass unaligned data only to FFmpeg APIs that
+   * are explicitly documented to accept it. Use this flag only if you
+   * absolutely know what you are doing.
+   */
+  AV_FRAME_CROP_UNALIGNED = 1 << 0,
+};
+
+/**
+ * Crop the given video AVFrame according to its crop_left/crop_top/crop_right/
+ * crop_bottom fields. If cropping is successful, the function will adjust the
+ * data pointers and the width/height fields, and set the crop fields to 0.
+ *
+ * In all cases, the cropping boundaries will be rounded to the inherent
+ * alignment of the pixel format. In some cases, such as for opaque hwaccel
+ * formats, the left/top cropping is ignored. The crop fields are set to 0 even
+ * if the cropping was rounded or ignored.
+ *
+ * @param frame the frame which should be cropped
+ * @param flags Some combination of AV_FRAME_CROP_* flags, or 0.
+ *
+ * @return >= 0 on success, a negative AVERROR on error. If the cropping fields
+ * were invalid, AVERROR(ERANGE) is returned, and nothing is changed.
+ */
+int av_frame_apply_cropping(AVFrame* frame, int flags);
+
+/**
+ * @return a string identifying the side data type
+ */
+const char* av_frame_side_data_name(enum AVFrameSideDataType type);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_FRAME_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,606 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_HWCONTEXT_H
+#define AVUTIL_HWCONTEXT_H
+
+#include "buffer.h"
+#include "frame.h"
+#include "log.h"
+#include "pixfmt.h"
+
+enum AVHWDeviceType {
+  AV_HWDEVICE_TYPE_NONE,
+  AV_HWDEVICE_TYPE_VDPAU,
+  AV_HWDEVICE_TYPE_CUDA,
+  AV_HWDEVICE_TYPE_VAAPI,
+  AV_HWDEVICE_TYPE_DXVA2,
+  AV_HWDEVICE_TYPE_QSV,
+  AV_HWDEVICE_TYPE_VIDEOTOOLBOX,
+  AV_HWDEVICE_TYPE_D3D11VA,
+  AV_HWDEVICE_TYPE_DRM,
+  AV_HWDEVICE_TYPE_OPENCL,
+  AV_HWDEVICE_TYPE_MEDIACODEC,
+  AV_HWDEVICE_TYPE_VULKAN,
+};
+
+typedef struct AVHWDeviceInternal AVHWDeviceInternal;
+
+/**
+ * This struct aggregates all the (hardware/vendor-specific) "high-level" state,
+ * i.e. state that is not tied to a concrete processing configuration.
+ * E.g., in an API that supports hardware-accelerated encoding and decoding,
+ * this struct will (if possible) wrap the state that is common to both encoding
+ * and decoding and from which specific instances of encoders or decoders can be
+ * derived.
+ *
+ * This struct is reference-counted with the AVBuffer mechanism. The
+ * av_hwdevice_ctx_alloc() constructor yields a reference, whose data field
+ * points to the actual AVHWDeviceContext. Further objects derived from
+ * AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with
+ * specific properties) will hold an internal reference to it. After all the
+ * references are released, the AVHWDeviceContext itself will be freed,
+ * optionally invoking a user-specified callback for uninitializing the hardware
+ * state.
+ */
+typedef struct AVHWDeviceContext {
+  /**
+   * A class for logging. Set by av_hwdevice_ctx_alloc().
+   */
+  const AVClass* av_class;
+
+  /**
+   * Private data used internally by libavutil. Must not be accessed in any
+   * way by the caller.
+   */
+  AVHWDeviceInternal* internal;
+
+  /**
+   * This field identifies the underlying API used for hardware access.
+   *
+   * This field is set when this struct is allocated and never changed
+   * afterwards.
+   */
+  enum AVHWDeviceType type;
+
+  /**
+   * The format-specific data, allocated and freed by libavutil along with
+   * this context.
+   *
+   * Should be cast by the user to the format-specific context defined in the
+   * corresponding header (hwcontext_*.h) and filled as described in the
+   * documentation before calling av_hwdevice_ctx_init().
+   *
+   * After calling av_hwdevice_ctx_init() this struct should not be modified
+   * by the caller.
+   */
+  void* hwctx;
+
+  /**
+   * This field may be set by the caller before calling av_hwdevice_ctx_init().
+   *
+   * If non-NULL, this callback will be called when the last reference to
+   * this context is unreferenced, immediately before it is freed.
+   *
+   * @note when other objects (e.g an AVHWFramesContext) are derived from this
+   *       struct, this callback will be invoked after all such child objects
+   *       are fully uninitialized and their respective destructors invoked.
+   */
+  void (*free)(struct AVHWDeviceContext* ctx);
+
+  /**
+   * Arbitrary user data, to be used e.g. by the free() callback.
+   */
+  void* user_opaque;
+} AVHWDeviceContext;
+
+typedef struct AVHWFramesInternal AVHWFramesInternal;
+
+/**
+ * This struct describes a set or pool of "hardware" frames (i.e. those with
+ * data not located in normal system memory). All the frames in the pool are
+ * assumed to be allocated in the same way and interchangeable.
+ *
+ * This struct is reference-counted with the AVBuffer mechanism and tied to a
+ * given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor
+ * yields a reference, whose data field points to the actual AVHWFramesContext
+ * struct.
+ */
+typedef struct AVHWFramesContext {
+  /**
+   * A class for logging.
+   */
+  const AVClass* av_class;
+
+  /**
+   * Private data used internally by libavutil. Must not be accessed in any
+   * way by the caller.
+   */
+  AVHWFramesInternal* internal;
+
+  /**
+   * A reference to the parent AVHWDeviceContext. This reference is owned and
+   * managed by the enclosing AVHWFramesContext, but the caller may derive
+   * additional references from it.
+   */
+  AVBufferRef* device_ref;
+
+  /**
+   * The parent AVHWDeviceContext. This is simply a pointer to
+   * device_ref->data provided for convenience.
+   *
+   * Set by libavutil in av_hwframe_ctx_init().
+   */
+  AVHWDeviceContext* device_ctx;
+
+  /**
+   * The format-specific data, allocated and freed automatically along with
+   * this context.
+   *
+   * Should be cast by the user to the format-specific context defined in the
+   * corresponding header (hwframe_*.h) and filled as described in the
+   * documentation before calling av_hwframe_ctx_init().
+   *
+   * After any frames using this context are created, the contents of this
+   * struct should not be modified by the caller.
+   */
+  void* hwctx;
+
+  /**
+   * This field may be set by the caller before calling av_hwframe_ctx_init().
+   *
+   * If non-NULL, this callback will be called when the last reference to
+   * this context is unreferenced, immediately before it is freed.
+   */
+  void (*free)(struct AVHWFramesContext* ctx);
+
+  /**
+   * Arbitrary user data, to be used e.g. by the free() callback.
+   */
+  void* user_opaque;
+
+  /**
+   * A pool from which the frames are allocated by av_hwframe_get_buffer().
+   * This field may be set by the caller before calling av_hwframe_ctx_init().
+   * The buffers returned by calling av_buffer_pool_get() on this pool must
+   * have the properties described in the documentation in the corresponding hw
+   * type's header (hwcontext_*.h). The pool will be freed strictly before
+   * this struct's free() callback is invoked.
+   *
+   * This field may be NULL, then libavutil will attempt to allocate a pool
+   * internally. Note that certain device types enforce pools allocated at
+   * fixed size (frame count), which cannot be extended dynamically. In such a
+   * case, initial_pool_size must be set appropriately.
+   */
+  AVBufferPool* pool;
+
+  /**
+   * Initial size of the frame pool. If a device type does not support
+   * dynamically resizing the pool, then this is also the maximum pool size.
+   *
+   * May be set by the caller before calling av_hwframe_ctx_init(). Must be
+   * set if pool is NULL and the device type does not support dynamic pools.
+   */
+  int initial_pool_size;
+
+  /**
+   * The pixel format identifying the underlying HW surface type.
+   *
+   * Must be a hwaccel format, i.e. the corresponding descriptor must have the
+   * AV_PIX_FMT_FLAG_HWACCEL flag set.
+   *
+   * Must be set by the user before calling av_hwframe_ctx_init().
+   */
+  enum AVPixelFormat format;
+
+  /**
+   * The pixel format identifying the actual data layout of the hardware
+   * frames.
+   *
+   * Must be set by the caller before calling av_hwframe_ctx_init().
+   *
+   * @note when the underlying API does not provide the exact data layout, but
+   * only the colorspace/bit depth, this field should be set to the fully
+   * planar version of that format (e.g. for 8-bit 420 YUV it should be
+   * AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else).
+   */
+  enum AVPixelFormat sw_format;
+
+  /**
+   * The allocated dimensions of the frames in this pool.
+   *
+   * Must be set by the user before calling av_hwframe_ctx_init().
+   */
+  int width, height;
+} AVHWFramesContext;
+
+/**
+ * Look up an AVHWDeviceType by name.
+ *
+ * @param name String name of the device type (case-insensitive).
+ * @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if
+ *         not found.
+ */
+enum AVHWDeviceType av_hwdevice_find_type_by_name(const char* name);
+
+/** Get the string name of an AVHWDeviceType.
+ *
+ * @param type Type from enum AVHWDeviceType.
+ * @return Pointer to a static string containing the name, or NULL if the type
+ *         is not valid.
+ */
+const char* av_hwdevice_get_type_name(enum AVHWDeviceType type);
+
+/**
+ * Iterate over supported device types.
+ *
+ * @param prev AV_HWDEVICE_TYPE_NONE initially, then the previous type
+ *             returned by this function in subsequent iterations.
+ * @return The next usable device type from enum AVHWDeviceType, or
+ *         AV_HWDEVICE_TYPE_NONE if there are no more.
+ */
+enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev);
+
+/**
+ * Allocate an AVHWDeviceContext for a given hardware type.
+ *
+ * @param type the type of the hardware device to allocate.
+ * @return a reference to the newly created AVHWDeviceContext on success or NULL
+ *         on failure.
+ */
+AVBufferRef* av_hwdevice_ctx_alloc(enum AVHWDeviceType type);
+
+/**
+ * Finalize the device context before use. This function must be called after
+ * the context is filled with all the required information and before it is
+ * used in any way.
+ *
+ * @param ref a reference to the AVHWDeviceContext
+ * @return 0 on success, a negative AVERROR code on failure
+ */
+int av_hwdevice_ctx_init(AVBufferRef* ref);
+
+/**
+ * Open a device of the specified type and create an AVHWDeviceContext for it.
+ *
+ * This is a convenience function intended to cover the simple cases. Callers
+ * who need to fine-tune device creation/management should open the device
+ * manually and then wrap it in an AVHWDeviceContext using
+ * av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().
+ *
+ * The returned context is already initialized and ready for use, the caller
+ * should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of
+ * the created AVHWDeviceContext are set by this function and should not be
+ * touched by the caller.
+ *
+ * @param device_ctx On success, a reference to the newly-created device context
+ *                   will be written here. The reference is owned by the caller
+ *                   and must be released with av_buffer_unref() when no longer
+ *                   needed. On failure, NULL will be written to this pointer.
+ * @param type The type of the device to create.
+ * @param device A type-specific string identifying the device to open.
+ * @param opts A dictionary of additional (type-specific) options to use in
+ *             opening the device. The dictionary remains owned by the caller.
+ * @param flags currently unused
+ *
+ * @return 0 on success, a negative AVERROR code on failure.
+ */
+int av_hwdevice_ctx_create(AVBufferRef** device_ctx, enum AVHWDeviceType type,
+                           const char* device, AVDictionary* opts, int flags);
+
+/**
+ * Create a new device of the specified type from an existing device.
+ *
+ * If the source device is a device of the target type or was originally
+ * derived from such a device (possibly through one or more intermediate
+ * devices of other types), then this will return a reference to the
+ * existing device of the same type as is requested.
+ *
+ * Otherwise, it will attempt to derive a new device from the given source
+ * device.  If direct derivation to the new type is not implemented, it will
+ * attempt the same derivation from each ancestor of the source device in
+ * turn looking for an implemented derivation method.
+ *
+ * @param dst_ctx On success, a reference to the newly-created
+ *                AVHWDeviceContext.
+ * @param type    The type of the new device to create.
+ * @param src_ctx A reference to an existing AVHWDeviceContext which will be
+ *                used to create the new device.
+ * @param flags   Currently unused; should be set to zero.
+ * @return        Zero on success, a negative AVERROR code on failure.
+ */
+int av_hwdevice_ctx_create_derived(AVBufferRef** dst_ctx,
+                                   enum AVHWDeviceType type,
+                                   AVBufferRef* src_ctx, int flags);
+
+/**
+ * Create a new device of the specified type from an existing device.
+ *
+ * This function performs the same action as av_hwdevice_ctx_create_derived,
+ * however, it is able to set options for the new device to be derived.
+ *
+ * @param dst_ctx On success, a reference to the newly-created
+ *                AVHWDeviceContext.
+ * @param type    The type of the new device to create.
+ * @param src_ctx A reference to an existing AVHWDeviceContext which will be
+ *                used to create the new device.
+ * @param options Options for the new device to create, same format as in
+ *                av_hwdevice_ctx_create.
+ * @param flags   Currently unused; should be set to zero.
+ * @return        Zero on success, a negative AVERROR code on failure.
+ */
+int av_hwdevice_ctx_create_derived_opts(AVBufferRef** dst_ctx,
+                                        enum AVHWDeviceType type,
+                                        AVBufferRef* src_ctx,
+                                        AVDictionary* options, int flags);
+
+/**
+ * Allocate an AVHWFramesContext tied to a given device context.
+ *
+ * @param device_ctx a reference to a AVHWDeviceContext. This function will make
+ *                   a new reference for internal use, the one passed to the
+ *                   function remains owned by the caller.
+ * @return a reference to the newly created AVHWFramesContext on success or NULL
+ *         on failure.
+ */
+AVBufferRef* av_hwframe_ctx_alloc(AVBufferRef* device_ctx);
+
+/**
+ * Finalize the context before use. This function must be called after the
+ * context is filled with all the required information and before it is attached
+ * to any frames.
+ *
+ * @param ref a reference to the AVHWFramesContext
+ * @return 0 on success, a negative AVERROR code on failure
+ */
+int av_hwframe_ctx_init(AVBufferRef* ref);
+
+/**
+ * Allocate a new frame attached to the given AVHWFramesContext.
+ *
+ * @param hwframe_ctx a reference to an AVHWFramesContext
+ * @param frame an empty (freshly allocated or unreffed) frame to be filled with
+ *              newly allocated buffers.
+ * @param flags currently unused, should be set to zero
+ * @return 0 on success, a negative AVERROR code on failure
+ */
+int av_hwframe_get_buffer(AVBufferRef* hwframe_ctx, AVFrame* frame, int flags);
+
+/**
+ * Copy data to or from a hw surface. At least one of dst/src must have an
+ * AVHWFramesContext attached.
+ *
+ * If src has an AVHWFramesContext attached, then the format of dst (if set)
+ * must use one of the formats returned by av_hwframe_transfer_get_formats(src,
+ * AV_HWFRAME_TRANSFER_DIRECTION_FROM).
+ * If dst has an AVHWFramesContext attached, then the format of src must use one
+ * of the formats returned by av_hwframe_transfer_get_formats(dst,
+ * AV_HWFRAME_TRANSFER_DIRECTION_TO)
+ *
+ * dst may be "clean" (i.e. with data/buf pointers unset), in which case the
+ * data buffers will be allocated by this function using av_frame_get_buffer().
+ * If dst->format is set, then this format will be used, otherwise (when
+ * dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.
+ *
+ * The two frames must have matching allocated dimensions (i.e. equal to
+ * AVHWFramesContext.width/height), since not all device types support
+ * transferring a sub-rectangle of the whole surface. The display dimensions
+ * (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but
+ * also have to be equal for both frames. When the display dimensions are
+ * smaller than the allocated dimensions, the content of the padding in the
+ * destination frame is unspecified.
+ *
+ * @param dst the destination frame. dst is not touched on failure.
+ * @param src the source frame.
+ * @param flags currently unused, should be set to zero
+ * @return 0 on success, a negative AVERROR error code on failure.
+ */
+int av_hwframe_transfer_data(AVFrame* dst, const AVFrame* src, int flags);
+
+enum AVHWFrameTransferDirection {
+  /**
+   * Transfer the data from the queried hw frame.
+   */
+  AV_HWFRAME_TRANSFER_DIRECTION_FROM,
+
+  /**
+   * Transfer the data to the queried hw frame.
+   */
+  AV_HWFRAME_TRANSFER_DIRECTION_TO,
+};
+
+/**
+ * Get a list of possible source or target formats usable in
+ * av_hwframe_transfer_data().
+ *
+ * @param hwframe_ctx the frame context to obtain the information for
+ * @param dir the direction of the transfer
+ * @param formats the pointer to the output format list will be written here.
+ *                The list is terminated with AV_PIX_FMT_NONE and must be freed
+ *                by the caller when no longer needed using av_free().
+ *                If this function returns successfully, the format list will
+ *                have at least one item (not counting the terminator).
+ *                On failure, the contents of this pointer are unspecified.
+ * @param flags currently unused, should be set to zero
+ * @return 0 on success, a negative AVERROR code on failure.
+ */
+int av_hwframe_transfer_get_formats(AVBufferRef* hwframe_ctx,
+                                    enum AVHWFrameTransferDirection dir,
+                                    enum AVPixelFormat** formats, int flags);
+
+/**
+ * This struct describes the constraints on hardware frames attached to
+ * a given device with a hardware-specific configuration.  This is returned
+ * by av_hwdevice_get_hwframe_constraints() and must be freed by
+ * av_hwframe_constraints_free() after use.
+ */
+typedef struct AVHWFramesConstraints {
+  /**
+   * A list of possible values for format in the hw_frames_ctx,
+   * terminated by AV_PIX_FMT_NONE.  This member will always be filled.
+   */
+  enum AVPixelFormat* valid_hw_formats;
+
+  /**
+   * A list of possible values for sw_format in the hw_frames_ctx,
+   * terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is
+   * not known.
+   */
+  enum AVPixelFormat* valid_sw_formats;
+
+  /**
+   * The minimum size of frames in this hw_frames_ctx.
+   * (Zero if not known.)
+   */
+  int min_width;
+  int min_height;
+
+  /**
+   * The maximum size of frames in this hw_frames_ctx.
+   * (INT_MAX if not known / no limit.)
+   */
+  int max_width;
+  int max_height;
+} AVHWFramesConstraints;
+
+/**
+ * Allocate a HW-specific configuration structure for a given HW device.
+ * After use, the user must free all members as required by the specific
+ * hardware structure being used, then free the structure itself with
+ * av_free().
+ *
+ * @param device_ctx a reference to the associated AVHWDeviceContext.
+ * @return The newly created HW-specific configuration structure on
+ *         success or NULL on failure.
+ */
+void* av_hwdevice_hwconfig_alloc(AVBufferRef* device_ctx);
+
+/**
+ * Get the constraints on HW frames given a device and the HW-specific
+ * configuration to be used with that device.  If no HW-specific
+ * configuration is provided, returns the maximum possible capabilities
+ * of the device.
+ *
+ * @param ref a reference to the associated AVHWDeviceContext.
+ * @param hwconfig a filled HW-specific configuration structure, or NULL
+ *        to return the maximum possible capabilities of the device.
+ * @return AVHWFramesConstraints structure describing the constraints
+ *         on the device, or NULL if not available.
+ */
+AVHWFramesConstraints* av_hwdevice_get_hwframe_constraints(
+    AVBufferRef* ref, const void* hwconfig);
+
+/**
+ * Free an AVHWFrameConstraints structure.
+ *
+ * @param constraints The (filled or unfilled) AVHWFrameConstraints structure.
+ */
+void av_hwframe_constraints_free(AVHWFramesConstraints** constraints);
+
+/**
+ * Flags to apply to frame mappings.
+ */
+enum {
+  /**
+   * The mapping must be readable.
+   */
+  AV_HWFRAME_MAP_READ = 1 << 0,
+  /**
+   * The mapping must be writeable.
+   */
+  AV_HWFRAME_MAP_WRITE = 1 << 1,
+  /**
+   * The mapped frame will be overwritten completely in subsequent
+   * operations, so the current frame data need not be loaded.  Any values
+   * which are not overwritten are unspecified.
+   */
+  AV_HWFRAME_MAP_OVERWRITE = 1 << 2,
+  /**
+   * The mapping must be direct.  That is, there must not be any copying in
+   * the map or unmap steps.  Note that performance of direct mappings may
+   * be much lower than normal memory.
+   */
+  AV_HWFRAME_MAP_DIRECT = 1 << 3,
+};
+
+/**
+ * Map a hardware frame.
+ *
+ * This has a number of different possible effects, depending on the format
+ * and origin of the src and dst frames.  On input, src should be a usable
+ * frame with valid buffers and dst should be blank (typically as just created
+ * by av_frame_alloc()).  src should have an associated hwframe context, and
+ * dst may optionally have a format and associated hwframe context.
+ *
+ * If src was created by mapping a frame from the hwframe context of dst,
+ * then this function undoes the mapping - dst is replaced by a reference to
+ * the frame that src was originally mapped from.
+ *
+ * If both src and dst have an associated hwframe context, then this function
+ * attempts to map the src frame from its hardware context to that of dst and
+ * then fill dst with appropriate data to be usable there.  This will only be
+ * possible if the hwframe contexts and associated devices are compatible -
+ * given compatible devices, av_hwframe_ctx_create_derived() can be used to
+ * create a hwframe context for dst in which mapping should be possible.
+ *
+ * If src has a hwframe context but dst does not, then the src frame is
+ * mapped to normal memory and should thereafter be usable as a normal frame.
+ * If the format is set on dst, then the mapping will attempt to create dst
+ * with that format and fail if it is not possible.  If format is unset (is
+ * AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate
+ * format to use is (probably the sw_format of the src hwframe context).
+ *
+ * A return value of AVERROR(ENOSYS) indicates that the mapping is not
+ * possible with the given arguments and hwframe setup, while other return
+ * values indicate that it failed somehow.
+ *
+ * On failure, the destination frame will be left blank, except for the
+ * hw_frames_ctx/format fields thay may have been set by the caller - those will
+ * be preserved as they were.
+ *
+ * @param dst Destination frame, to contain the mapping.
+ * @param src Source frame, to be mapped.
+ * @param flags Some combination of AV_HWFRAME_MAP_* flags.
+ * @return Zero on success, negative AVERROR code on failure.
+ */
+int av_hwframe_map(AVFrame* dst, const AVFrame* src, int flags);
+
+/**
+ * Create and initialise an AVHWFramesContext as a mapping of another existing
+ * AVHWFramesContext on a different device.
+ *
+ * av_hwframe_ctx_init() should not be called after this.
+ *
+ * @param derived_frame_ctx  On success, a reference to the newly created
+ *                           AVHWFramesContext.
+ * @param format             The AVPixelFormat for the derived context.
+ * @param derived_device_ctx A reference to the device to create the new
+ *                           AVHWFramesContext on.
+ * @param source_frame_ctx   A reference to an existing AVHWFramesContext
+ *                           which will be mapped to the derived context.
+ * @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the
+ *               mapping parameters to apply to frames which are allocated
+ *               in the derived device.
+ * @return       Zero on success, negative AVERROR code on failure.
+ */
+int av_hwframe_ctx_create_derived(AVBufferRef** derived_frame_ctx,
+                                  enum AVPixelFormat format,
+                                  AVBufferRef* derived_device_ctx,
+                                  AVBufferRef* source_frame_ctx, int flags);
+
+#endif /* AVUTIL_HWCONTEXT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext_vaapi.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext_vaapi.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext_vaapi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/hwcontext_vaapi.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,117 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_HWCONTEXT_VAAPI_H
+#define AVUTIL_HWCONTEXT_VAAPI_H
+
+#include <va/va.h>
+
+/**
+ * @file
+ * API-specific header for AV_HWDEVICE_TYPE_VAAPI.
+ *
+ * Dynamic frame pools are supported, but note that any pool used as a render
+ * target is required to be of fixed size in order to be be usable as an
+ * argument to vaCreateContext().
+ *
+ * For user-allocated pools, AVHWFramesContext.pool must return AVBufferRefs
+ * with the data pointer set to a VASurfaceID.
+ */
+
+enum {
+  /**
+   * The quirks field has been set by the user and should not be detected
+   * automatically by av_hwdevice_ctx_init().
+   */
+  AV_VAAPI_DRIVER_QUIRK_USER_SET = (1 << 0),
+  /**
+   * The driver does not destroy parameter buffers when they are used by
+   * vaRenderPicture().  Additional code will be required to destroy them
+   * separately afterwards.
+   */
+  AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS = (1 << 1),
+
+  /**
+   * The driver does not support the VASurfaceAttribMemoryType attribute,
+   * so the surface allocation code will not try to use it.
+   */
+  AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE = (1 << 2),
+
+  /**
+   * The driver does not support surface attributes at all.
+   * The surface allocation code will never pass them to surface allocation,
+   * and the results of the vaQuerySurfaceAttributes() call will be faked.
+   */
+  AV_VAAPI_DRIVER_QUIRK_SURFACE_ATTRIBUTES = (1 << 3),
+};
+
+/**
+ * VAAPI connection details.
+ *
+ * Allocated as AVHWDeviceContext.hwctx
+ */
+typedef struct AVVAAPIDeviceContext {
+  /**
+   * The VADisplay handle, to be filled by the user.
+   */
+  VADisplay display;
+  /**
+   * Driver quirks to apply - this is filled by av_hwdevice_ctx_init(),
+   * with reference to a table of known drivers, unless the
+   * AV_VAAPI_DRIVER_QUIRK_USER_SET bit is already present.  The user
+   * may need to refer to this field when performing any later
+   * operations using VAAPI with the same VADisplay.
+   */
+  unsigned int driver_quirks;
+} AVVAAPIDeviceContext;
+
+/**
+ * VAAPI-specific data associated with a frame pool.
+ *
+ * Allocated as AVHWFramesContext.hwctx.
+ */
+typedef struct AVVAAPIFramesContext {
+  /**
+   * Set by the user to apply surface attributes to all surfaces in
+   * the frame pool.  If null, default settings are used.
+   */
+  VASurfaceAttrib* attributes;
+  int nb_attributes;
+  /**
+   * The surfaces IDs of all surfaces in the pool after creation.
+   * Only valid if AVHWFramesContext.initial_pool_size was positive.
+   * These are intended to be used as the render_targets arguments to
+   * vaCreateContext().
+   */
+  VASurfaceID* surface_ids;
+  int nb_surfaces;
+} AVVAAPIFramesContext;
+
+/**
+ * VAAPI hardware pipeline configuration details.
+ *
+ * Allocated with av_hwdevice_hwconfig_alloc().
+ */
+typedef struct AVVAAPIHWConfig {
+  /**
+   * ID of a VAAPI pipeline configuration.
+   */
+  VAConfigID config_id;
+} AVVAAPIHWConfig;
+
+#endif /* AVUTIL_HWCONTEXT_VAAPI_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/intfloat.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/intfloat.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/intfloat.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/intfloat.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2011 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_INTFLOAT_H
+#define AVUTIL_INTFLOAT_H
+
+#include <stdint.h>
+#include "attributes.h"
+
+union av_intfloat32 {
+  uint32_t i;
+  float f;
+};
+
+union av_intfloat64 {
+  uint64_t i;
+  double f;
+};
+
+/**
+ * Reinterpret a 32-bit integer as a float.
+ */
+static av_always_inline float av_int2float(uint32_t i) {
+  union av_intfloat32 v;
+  v.i = i;
+  return v.f;
+}
+
+/**
+ * Reinterpret a float as a 32-bit integer.
+ */
+static av_always_inline uint32_t av_float2int(float f) {
+  union av_intfloat32 v;
+  v.f = f;
+  return v.i;
+}
+
+/**
+ * Reinterpret a 64-bit integer as a double.
+ */
+static av_always_inline double av_int2double(uint64_t i) {
+  union av_intfloat64 v;
+  v.i = i;
+  return v.f;
+}
+
+/**
+ * Reinterpret a double as a 64-bit integer.
+ */
+static av_always_inline uint64_t av_double2int(double f) {
+  union av_intfloat64 v;
+  v.f = f;
+  return v.i;
+}
+
+#endif /* AVUTIL_INTFLOAT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/log.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/log.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/log.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/log.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,388 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_LOG_H
+#define AVUTIL_LOG_H
+
+#include <stdarg.h>
+#include "attributes.h"
+#include "version.h"
+
+typedef enum {
+  AV_CLASS_CATEGORY_NA = 0,
+  AV_CLASS_CATEGORY_INPUT,
+  AV_CLASS_CATEGORY_OUTPUT,
+  AV_CLASS_CATEGORY_MUXER,
+  AV_CLASS_CATEGORY_DEMUXER,
+  AV_CLASS_CATEGORY_ENCODER,
+  AV_CLASS_CATEGORY_DECODER,
+  AV_CLASS_CATEGORY_FILTER,
+  AV_CLASS_CATEGORY_BITSTREAM_FILTER,
+  AV_CLASS_CATEGORY_SWSCALER,
+  AV_CLASS_CATEGORY_SWRESAMPLER,
+  AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
+  AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT,
+  AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT,
+  AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT,
+  AV_CLASS_CATEGORY_DEVICE_OUTPUT,
+  AV_CLASS_CATEGORY_DEVICE_INPUT,
+  AV_CLASS_CATEGORY_NB  ///< not part of ABI/API
+} AVClassCategory;
+
+#define AV_IS_INPUT_DEVICE(category)                       \
+  (((category) == AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT) || \
+   ((category) == AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT) || \
+   ((category) == AV_CLASS_CATEGORY_DEVICE_INPUT))
+
+#define AV_IS_OUTPUT_DEVICE(category)                       \
+  (((category) == AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT) || \
+   ((category) == AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT) || \
+   ((category) == AV_CLASS_CATEGORY_DEVICE_OUTPUT))
+
+struct AVOptionRanges;
+
+/**
+ * Describe the class of an AVClass context structure. That is an
+ * arbitrary struct of which the first field is a pointer to an
+ * AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
+ */
+typedef struct AVClass {
+  /**
+   * The name of the class; usually it is the same name as the
+   * context structure type to which the AVClass is associated.
+   */
+  const char* class_name;
+
+  /**
+   * A pointer to a function which returns the name of a context
+   * instance ctx associated with the class.
+   */
+  const char* (*item_name)(void* ctx);
+
+  /**
+   * a pointer to the first option specified in the class if any or NULL
+   *
+   * @see av_set_default_options()
+   */
+  const struct AVOption* option;
+
+  /**
+   * LIBAVUTIL_VERSION with which this structure was created.
+   * This is used to allow fields to be added without requiring major
+   * version bumps everywhere.
+   */
+
+  int version;
+
+  /**
+   * Offset in the structure where log_level_offset is stored.
+   * 0 means there is no such variable
+   */
+  int log_level_offset_offset;
+
+  /**
+   * Offset in the structure where a pointer to the parent context for
+   * logging is stored. For example a decoder could pass its AVCodecContext
+   * to eval as such a parent context, which an av_log() implementation
+   * could then leverage to display the parent context.
+   * The offset can be NULL.
+   */
+  int parent_log_context_offset;
+
+  /**
+   * Category used for visualization (like color)
+   * This is only set if the category is equal for all objects using this class.
+   * available since version (51 << 16 | 56 << 8 | 100)
+   */
+  AVClassCategory category;
+
+  /**
+   * Callback to return the category.
+   * available since version (51 << 16 | 59 << 8 | 100)
+   */
+  AVClassCategory (*get_category)(void* ctx);
+
+  /**
+   * Callback to return the supported/allowed ranges.
+   * available since version (52.12)
+   */
+  int (*query_ranges)(struct AVOptionRanges**, void* obj, const char* key,
+                      int flags);
+
+  /**
+   * Return next AVOptions-enabled child or NULL
+   */
+  void* (*child_next)(void* obj, void* prev);
+
+  /**
+   * Iterate over the AVClasses corresponding to potential AVOptions-enabled
+   * children.
+   *
+   * @param iter pointer to opaque iteration state. The caller must initialize
+   *             *iter to NULL before the first call.
+   * @return AVClass for the next AVOptions-enabled child or NULL if there are
+   *         no more such children.
+   *
+   * @note The difference between child_next and this is that child_next
+   *       iterates over _already existing_ objects, while child_class_iterate
+   *       iterates over _all possible_ children.
+   */
+  const struct AVClass* (*child_class_iterate)(void** iter);
+} AVClass;
+
+/**
+ * @addtogroup lavu_log
+ *
+ * @{
+ *
+ * @defgroup lavu_log_constants Logging Constants
+ *
+ * @{
+ */
+
+/**
+ * Print no output.
+ */
+#define AV_LOG_QUIET -8
+
+/**
+ * Something went really wrong and we will crash now.
+ */
+#define AV_LOG_PANIC 0
+
+/**
+ * Something went wrong and recovery is not possible.
+ * For example, no header was found for a format which depends
+ * on headers or an illegal combination of parameters is used.
+ */
+#define AV_LOG_FATAL 8
+
+/**
+ * Something went wrong and cannot losslessly be recovered.
+ * However, not all future data is affected.
+ */
+#define AV_LOG_ERROR 16
+
+/**
+ * Something somehow does not look correct. This may or may not
+ * lead to problems. An example would be the use of '-vstrict -2'.
+ */
+#define AV_LOG_WARNING 24
+
+/**
+ * Standard information.
+ */
+#define AV_LOG_INFO 32
+
+/**
+ * Detailed information.
+ */
+#define AV_LOG_VERBOSE 40
+
+/**
+ * Stuff which is only useful for libav* developers.
+ */
+#define AV_LOG_DEBUG 48
+
+/**
+ * Extremely verbose debugging, useful for libav* development.
+ */
+#define AV_LOG_TRACE 56
+
+#define AV_LOG_MAX_OFFSET (AV_LOG_TRACE - AV_LOG_QUIET)
+
+/**
+ * @}
+ */
+
+/**
+ * Sets additional colors for extended debugging sessions.
+ * @code
+   av_log(ctx, AV_LOG_DEBUG|AV_LOG_C(134), "Message in purple\n");
+   @endcode
+ * Requires 256color terminal support. Uses outside debugging is not
+ * recommended.
+ */
+#define AV_LOG_C(x) ((x) << 8)
+
+/**
+ * Send the specified message to the log if the level is less than or equal
+ * to the current av_log_level. By default, all logging messages are sent to
+ * stderr. This behavior can be altered by setting a different logging callback
+ * function.
+ * @see av_log_set_callback
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ *        pointer to an AVClass struct or NULL if general log.
+ * @param level The importance level of the message expressed using a @ref
+ *        lavu_log_constants "Logging Constant".
+ * @param fmt The format string (printf-compatible) that specifies how
+ *        subsequent arguments are converted to output.
+ */
+void av_log(void* avcl, int level, const char* fmt, ...) av_printf_format(3, 4);
+
+/**
+ * Send the specified message to the log once with the initial_level and then
+ * with the subsequent_level. By default, all logging messages are sent to
+ * stderr. This behavior can be altered by setting a different logging callback
+ * function.
+ * @see av_log
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ *        pointer to an AVClass struct or NULL if general log.
+ * @param initial_level importance level of the message expressed using a @ref
+ *        lavu_log_constants "Logging Constant" for the first occurance.
+ * @param subsequent_level importance level of the message expressed using a
+ * @ref lavu_log_constants "Logging Constant" after the first occurance.
+ * @param fmt The format string (printf-compatible) that specifies how
+ *        subsequent arguments are converted to output.
+ * @param state a variable to keep trak of if a message has already been printed
+ *        this must be initialized to 0 before the first use. The same state
+ *        must not be accessed by 2 Threads simultaneously.
+ */
+void av_log_once(void* avcl, int initial_level, int subsequent_level,
+                 int* state, const char* fmt, ...) av_printf_format(5, 6);
+
+/**
+ * Send the specified message to the log if the level is less than or equal
+ * to the current av_log_level. By default, all logging messages are sent to
+ * stderr. This behavior can be altered by setting a different logging callback
+ * function.
+ * @see av_log_set_callback
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ *        pointer to an AVClass struct.
+ * @param level The importance level of the message expressed using a @ref
+ *        lavu_log_constants "Logging Constant".
+ * @param fmt The format string (printf-compatible) that specifies how
+ *        subsequent arguments are converted to output.
+ * @param vl The arguments referenced by the format string.
+ */
+void av_vlog(void* avcl, int level, const char* fmt, va_list vl);
+
+/**
+ * Get the current log level
+ *
+ * @see lavu_log_constants
+ *
+ * @return Current log level
+ */
+int av_log_get_level(void);
+
+/**
+ * Set the log level
+ *
+ * @see lavu_log_constants
+ *
+ * @param level Logging level
+ */
+void av_log_set_level(int level);
+
+/**
+ * Set the logging callback
+ *
+ * @note The callback must be thread safe, even if the application does not use
+ *       threads itself as some codecs are multithreaded.
+ *
+ * @see av_log_default_callback
+ *
+ * @param callback A logging function with a compatible signature.
+ */
+void av_log_set_callback(void (*callback)(void*, int, const char*, va_list));
+
+/**
+ * Default logging callback
+ *
+ * It prints the message to stderr, optionally colorizing it.
+ *
+ * @param avcl A pointer to an arbitrary struct of which the first field is a
+ *        pointer to an AVClass struct.
+ * @param level The importance level of the message expressed using a @ref
+ *        lavu_log_constants "Logging Constant".
+ * @param fmt The format string (printf-compatible) that specifies how
+ *        subsequent arguments are converted to output.
+ * @param vl The arguments referenced by the format string.
+ */
+void av_log_default_callback(void* avcl, int level, const char* fmt,
+                             va_list vl);
+
+/**
+ * Return the context name
+ *
+ * @param  ctx The AVClass context
+ *
+ * @return The AVClass class_name
+ */
+const char* av_default_item_name(void* ctx);
+AVClassCategory av_default_get_category(void* ptr);
+
+/**
+ * Format a line of log the same way as the default callback.
+ * @param line          buffer to receive the formatted line
+ * @param line_size     size of the buffer
+ * @param print_prefix  used to store whether the prefix must be printed;
+ *                      must point to a persistent integer initially set to 1
+ */
+void av_log_format_line(void* ptr, int level, const char* fmt, va_list vl,
+                        char* line, int line_size, int* print_prefix);
+
+/**
+ * Format a line of log the same way as the default callback.
+ * @param line          buffer to receive the formatted line;
+ *                      may be NULL if line_size is 0
+ * @param line_size     size of the buffer; at most line_size-1 characters will
+ *                      be written to the buffer, plus one null terminator
+ * @param print_prefix  used to store whether the prefix must be printed;
+ *                      must point to a persistent integer initially set to 1
+ * @return Returns a negative value if an error occurred, otherwise returns
+ *         the number of characters that would have been written for a
+ *         sufficiently large buffer, not including the terminating null
+ *         character. If the return value is not less than line_size, it means
+ *         that the log message was truncated to fit the buffer.
+ */
+int av_log_format_line2(void* ptr, int level, const char* fmt, va_list vl,
+                        char* line, int line_size, int* print_prefix);
+
+/**
+ * Skip repeated messages, this requires the user app to use av_log() instead of
+ * (f)printf as the 2 would otherwise interfere and lead to
+ * "Last message repeated x times" messages below (f)printf messages with some
+ * bad luck.
+ * Also to receive the last, "last repeated" line if any, the user app must
+ * call av_log(NULL, AV_LOG_QUIET, "%s", ""); at the end
+ */
+#define AV_LOG_SKIP_REPEATED 1
+
+/**
+ * Include the log severity in messages originating from codecs.
+ *
+ * Results in messages such as:
+ * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts
+ */
+#define AV_LOG_PRINT_LEVEL 2
+
+void av_log_set_flags(int arg);
+int av_log_get_flags(void);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_LOG_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/macros.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/macros.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/macros.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/macros.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,87 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @ingroup lavu
+ * Utility Preprocessor macros
+ */
+
+#ifndef AVUTIL_MACROS_H
+#define AVUTIL_MACROS_H
+
+#include "libavutil/avconfig.h"
+
+#if AV_HAVE_BIGENDIAN
+#  define AV_NE(be, le) (be)
+#else
+#  define AV_NE(be, le) (le)
+#endif
+
+/**
+ * Comparator.
+ * For two numerical expressions x and y, gives 1 if x > y, -1 if x < y, and 0
+ * if x == y. This is useful for instance in a qsort comparator callback.
+ * Furthermore, compilers are able to optimize this to branchless code, and
+ * there is no risk of overflow with signed types.
+ * As with many macros, this evaluates its argument multiple times, it thus
+ * must not have a side-effect.
+ */
+#define FFDIFFSIGN(x, y) (((x) > (y)) - ((x) < (y)))
+
+#define FFMAX(a, b) ((a) > (b) ? (a) : (b))
+#define FFMAX3(a, b, c) FFMAX(FFMAX(a, b), c)
+#define FFMIN(a, b) ((a) > (b) ? (b) : (a))
+#define FFMIN3(a, b, c) FFMIN(FFMIN(a, b), c)
+
+#define FFSWAP(type, a, b) \
+  do {                     \
+    type SWAP_tmp = b;     \
+    b = a;                 \
+    a = SWAP_tmp;          \
+  } while (0)
+#define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
+
+#define MKTAG(a, b, c, d) \
+  ((a) | ((b) << 8) | ((c) << 16) | ((unsigned)(d) << 24))
+#define MKBETAG(a, b, c, d) \
+  ((d) | ((c) << 8) | ((b) << 16) | ((unsigned)(a) << 24))
+
+/**
+ * @addtogroup preproc_misc Preprocessor String Macros
+ *
+ * String manipulation macros
+ *
+ * @{
+ */
+
+#define AV_STRINGIFY(s) AV_TOSTRING(s)
+#define AV_TOSTRING(s) #s
+
+#define AV_GLUE(a, b) a##b
+#define AV_JOIN(a, b) AV_GLUE(a, b)
+
+/**
+ * @}
+ */
+
+#define AV_PRAGMA(s) _Pragma(#s)
+
+#define FFALIGN(x, a) (((x) + (a)-1) & ~((a)-1))
+
+#endif /* AVUTIL_MACROS_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mathematics.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mathematics.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mathematics.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mathematics.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,249 @@
+/*
+ * copyright (c) 2005-2012 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @addtogroup lavu_math
+ * Mathematical utilities for working with timestamp and time base.
+ */
+
+#ifndef AVUTIL_MATHEMATICS_H
+#define AVUTIL_MATHEMATICS_H
+
+#include <stdint.h>
+#include <math.h>
+#include "attributes.h"
+#include "rational.h"
+#include "intfloat.h"
+
+#ifndef M_E
+#  define M_E 2.7182818284590452354 /* e */
+#endif
+#ifndef M_LN2
+#  define M_LN2 0.69314718055994530942 /* log_e 2 */
+#endif
+#ifndef M_LN10
+#  define M_LN10 2.30258509299404568402 /* log_e 10 */
+#endif
+#ifndef M_LOG2_10
+#  define M_LOG2_10 3.32192809488736234787 /* log_2 10 */
+#endif
+#ifndef M_PHI
+#  define M_PHI 1.61803398874989484820 /* phi / golden ratio */
+#endif
+#ifndef M_PI
+#  define M_PI 3.14159265358979323846 /* pi */
+#endif
+#ifndef M_PI_2
+#  define M_PI_2 1.57079632679489661923 /* pi/2 */
+#endif
+#ifndef M_SQRT1_2
+#  define M_SQRT1_2 0.70710678118654752440 /* 1/sqrt(2) */
+#endif
+#ifndef M_SQRT2
+#  define M_SQRT2 1.41421356237309504880 /* sqrt(2) */
+#endif
+#ifndef NAN
+#  define NAN av_int2float(0x7fc00000)
+#endif
+#ifndef INFINITY
+#  define INFINITY av_int2float(0x7f800000)
+#endif
+
+/**
+ * @addtogroup lavu_math
+ *
+ * @{
+ */
+
+/**
+ * Rounding methods.
+ */
+enum AVRounding {
+  AV_ROUND_ZERO = 0,  ///< Round toward zero.
+  AV_ROUND_INF = 1,   ///< Round away from zero.
+  AV_ROUND_DOWN = 2,  ///< Round toward -infinity.
+  AV_ROUND_UP = 3,    ///< Round toward +infinity.
+  AV_ROUND_NEAR_INF =
+      5,  ///< Round to nearest and halfway cases away from zero.
+  /**
+   * Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
+   * unchanged, avoiding special cases for #AV_NOPTS_VALUE.
+   *
+   * Unlike other values of the enumeration AVRounding, this value is a
+   * bitmask that must be used in conjunction with another value of the
+   * enumeration through a bitwise OR, in order to set behavior for normal
+   * cases.
+   *
+   * @code{.c}
+   * av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
+   * // Rescaling 3:
+   * //     Calculating 3 * 1 / 2
+   * //     3 / 2 is rounded up to 2
+   * //     => 2
+   *
+   * av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
+   * // Rescaling AV_NOPTS_VALUE:
+   * //     AV_NOPTS_VALUE == INT64_MIN
+   * //     AV_NOPTS_VALUE is passed through
+   * //     => AV_NOPTS_VALUE
+   * @endcode
+   */
+  AV_ROUND_PASS_MINMAX = 8192,
+};
+
+/**
+ * Compute the greatest common divisor of two integer operands.
+ *
+ * @param a Operand
+ * @param b Operand
+ * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >=
+ * 0; if a == 0 and b == 0, returns 0.
+ */
+int64_t av_const av_gcd(int64_t a, int64_t b);
+
+/**
+ * Rescale a 64-bit integer with rounding to nearest.
+ *
+ * The operation is mathematically equivalent to `a * b / c`, but writing that
+ * directly can overflow.
+ *
+ * This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
+ *
+ * @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
+ */
+int64_t av_rescale(int64_t a, int64_t b, int64_t c) av_const;
+
+/**
+ * Rescale a 64-bit integer with specified rounding.
+ *
+ * The operation is mathematically equivalent to `a * b / c`, but writing that
+ * directly can overflow, and does not support different rounding methods.
+ * If the result is not representable then INT64_MIN is returned.
+ *
+ * @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
+ */
+int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c,
+                       enum AVRounding rnd) av_const;
+
+/**
+ * Rescale a 64-bit integer by 2 rational numbers.
+ *
+ * The operation is mathematically equivalent to `a * bq / cq`.
+ *
+ * This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.
+ *
+ * @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()
+ */
+int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq) av_const;
+
+/**
+ * Rescale a 64-bit integer by 2 rational numbers with specified rounding.
+ *
+ * The operation is mathematically equivalent to `a * bq / cq`.
+ *
+ * @see av_rescale(), av_rescale_rnd(), av_rescale_q()
+ */
+int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq,
+                         enum AVRounding rnd) av_const;
+
+/**
+ * Compare two timestamps each in its own time base.
+ *
+ * @return One of the following values:
+ *         - -1 if `ts_a` is before `ts_b`
+ *         - 1 if `ts_a` is after `ts_b`
+ *         - 0 if they represent the same position
+ *
+ * @warning
+ * The result of the function is undefined if one of the timestamps is outside
+ * the `int64_t` range when represented in the other's timebase.
+ */
+int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b);
+
+/**
+ * Compare the remainders of two integer operands divided by a common divisor.
+ *
+ * In other words, compare the least significant `log2(mod)` bits of integers
+ * `a` and `b`.
+ *
+ * @code{.c}
+ * av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 %
+ * 0x10  (0x2) av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11)
+ * > 0x02 % 0x20 (0x02)
+ * @endcode
+ *
+ * @param a Operand
+ * @param b Operand
+ * @param mod Divisor; must be a power of 2
+ * @return
+ *         - a negative value if `a % mod < b % mod`
+ *         - a positive value if `a % mod > b % mod`
+ *         - zero             if `a % mod == b % mod`
+ */
+int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod);
+
+/**
+ * Rescale a timestamp while preserving known durations.
+ *
+ * This function is designed to be called per audio packet to scale the input
+ * timestamp to a different time base. Compared to a simple av_rescale_q()
+ * call, this function is robust against possible inconsistent frame durations.
+ *
+ * The `last` parameter is a state variable that must be preserved for all
+ * subsequent calls for the same stream. For the first call, `*last` should be
+ * initialized to #AV_NOPTS_VALUE.
+ *
+ * @param[in]     in_tb    Input time base
+ * @param[in]     in_ts    Input timestamp
+ * @param[in]     fs_tb    Duration time base; typically this is finer-grained
+ *                         (greater) than `in_tb` and `out_tb`
+ * @param[in]     duration Duration till the next call to this function (i.e.
+ *                         duration of the current packet/frame)
+ * @param[in,out] last     Pointer to a timestamp expressed in terms of
+ *                         `fs_tb`, acting as a state variable
+ * @param[in]     out_tb   Output timebase
+ * @return        Timestamp expressed in terms of `out_tb`
+ *
+ * @note In the context of this function, "duration" is in term of samples, not
+ *       seconds.
+ */
+int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb,
+                         int duration, int64_t* last, AVRational out_tb);
+
+/**
+ * Add a value to a timestamp.
+ *
+ * This function guarantees that when the same value is repeatly added that
+ * no accumulation of rounding errors occurs.
+ *
+ * @param[in] ts     Input timestamp
+ * @param[in] ts_tb  Input timestamp time base
+ * @param[in] inc    Value to be added
+ * @param[in] inc_tb Time base of `inc`
+ */
+int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb,
+                      int64_t inc);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_MATHEMATICS_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mem.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mem.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mem.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/mem.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,613 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @ingroup lavu_mem
+ * Memory handling functions
+ */
+
+#ifndef AVUTIL_MEM_H
+#define AVUTIL_MEM_H
+
+#include <limits.h>
+#include <stdint.h>
+
+#include "attributes.h"
+#include "avutil.h"
+#include "version.h"
+
+/**
+ * @addtogroup lavu_mem
+ * Utilities for manipulating memory.
+ *
+ * FFmpeg has several applications of memory that are not required of a typical
+ * program. For example, the computing-heavy components like video decoding and
+ * encoding can be sped up significantly through the use of aligned memory.
+ *
+ * However, for each of FFmpeg's applications of memory, there might not be a
+ * recognized or standardized API for that specific use. Memory alignment, for
+ * instance, varies wildly depending on operating systems, architectures, and
+ * compilers. Hence, this component of @ref libavutil is created to make
+ * dealing with memory consistently possible on all platforms.
+ *
+ * @{
+ */
+
+/**
+ * @defgroup lavu_mem_attrs Function Attributes
+ * Function attributes applicable to memory handling functions.
+ *
+ * These function attributes can help compilers emit more useful warnings, or
+ * generate better code.
+ * @{
+ */
+
+/**
+ * @def av_malloc_attrib
+ * Function attribute denoting a malloc-like function.
+ *
+ * @see <a
+ * href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-g_t_0040code_007bmalloc_007d-function-attribute-3251">Function
+ * attribute `malloc` in GCC's documentation</a>
+ */
+
+#if AV_GCC_VERSION_AT_LEAST(3, 1)
+#  define av_malloc_attrib __attribute__((__malloc__))
+#else
+#  define av_malloc_attrib
+#endif
+
+/**
+ * @def av_alloc_size(...)
+ * Function attribute used on a function that allocates memory, whose size is
+ * given by the specified parameter(s).
+ *
+ * @code{.c}
+ * void *av_malloc(size_t size) av_alloc_size(1);
+ * void *av_calloc(size_t nmemb, size_t size) av_alloc_size(1, 2);
+ * @endcode
+ *
+ * @param ... One or two parameter indexes, separated by a comma
+ *
+ * @see <a
+ * href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-g_t_0040code_007balloc_005fsize_007d-function-attribute-3220">Function
+ * attribute `alloc_size` in GCC's documentation</a>
+ */
+
+#if AV_GCC_VERSION_AT_LEAST(4, 3)
+#  define av_alloc_size(...) __attribute__((alloc_size(__VA_ARGS__)))
+#else
+#  define av_alloc_size(...)
+#endif
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lavu_mem_funcs Heap Management
+ * Functions responsible for allocating, freeing, and copying memory.
+ *
+ * All memory allocation functions have a built-in upper limit of `INT_MAX`
+ * bytes. This may be changed with av_max_alloc(), although exercise extreme
+ * caution when doing so.
+ *
+ * @{
+ */
+
+/**
+ * Allocate a memory block with alignment suitable for all memory accesses
+ * (including vectors if available on the CPU).
+ *
+ * @param size Size in bytes for the memory block to be allocated
+ * @return Pointer to the allocated block, or `NULL` if the block cannot
+ *         be allocated
+ * @see av_mallocz()
+ */
+void* av_malloc(size_t size) av_malloc_attrib av_alloc_size(1);
+
+/**
+ * Allocate a memory block with alignment suitable for all memory accesses
+ * (including vectors if available on the CPU) and zero all the bytes of the
+ * block.
+ *
+ * @param size Size in bytes for the memory block to be allocated
+ * @return Pointer to the allocated block, or `NULL` if it cannot be allocated
+ * @see av_malloc()
+ */
+void* av_mallocz(size_t size) av_malloc_attrib av_alloc_size(1);
+
+/**
+ * Allocate a memory block for an array with av_malloc().
+ *
+ * The allocated memory will have size `size * nmemb` bytes.
+ *
+ * @param nmemb Number of element
+ * @param size  Size of a single element
+ * @return Pointer to the allocated block, or `NULL` if the block cannot
+ *         be allocated
+ * @see av_malloc()
+ */
+av_alloc_size(1, 2) void* av_malloc_array(size_t nmemb, size_t size);
+
+/**
+ * Allocate a memory block for an array with av_mallocz().
+ *
+ * The allocated memory will have size `size * nmemb` bytes.
+ *
+ * @param nmemb Number of elements
+ * @param size  Size of the single element
+ * @return Pointer to the allocated block, or `NULL` if the block cannot
+ *         be allocated
+ *
+ * @see av_mallocz()
+ * @see av_malloc_array()
+ */
+void* av_calloc(size_t nmemb, size_t size) av_malloc_attrib av_alloc_size(1, 2);
+
+/**
+ * Allocate, reallocate, or free a block of memory.
+ *
+ * If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or
+ * shrink that block of memory according to `size`.
+ *
+ * @param ptr  Pointer to a memory block already allocated with
+ *             av_realloc() or `NULL`
+ * @param size Size in bytes of the memory block to be allocated or
+ *             reallocated
+ *
+ * @return Pointer to a newly-reallocated block or `NULL` if the block
+ *         cannot be reallocated
+ *
+ * @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
+ *          correctly aligned. The returned pointer must be freed after even
+ *          if size is zero.
+ * @see av_fast_realloc()
+ * @see av_reallocp()
+ */
+void* av_realloc(void* ptr, size_t size) av_alloc_size(2);
+
+/**
+ * Allocate, reallocate, or free a block of memory through a pointer to a
+ * pointer.
+ *
+ * If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
+ * zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
+ * shrink that block of memory according to `size`.
+ *
+ * @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
+ *                     with av_realloc(), or a pointer to `NULL`. The pointer
+ *                     is updated on success, or freed on failure.
+ * @param[in]     size Size in bytes for the memory block to be allocated or
+ *                     reallocated
+ *
+ * @return Zero on success, an AVERROR error code on failure
+ *
+ * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
+ *          correctly aligned.
+ */
+av_warn_unused_result int av_reallocp(void* ptr, size_t size);
+
+/**
+ * Allocate, reallocate, or free a block of memory.
+ *
+ * This function does the same thing as av_realloc(), except:
+ * - It takes two size arguments and allocates `nelem * elsize` bytes,
+ *   after checking the result of the multiplication for integer overflow.
+ * - It frees the input block in case of failure, thus avoiding the memory
+ *   leak with the classic
+ *   @code{.c}
+ *   buf = realloc(buf);
+ *   if (!buf)
+ *       return -1;
+ *   @endcode
+ *   pattern.
+ */
+void* av_realloc_f(void* ptr, size_t nelem, size_t elsize);
+
+/**
+ * Allocate, reallocate, or free an array.
+ *
+ * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.
+ *
+ * @param ptr   Pointer to a memory block already allocated with
+ *              av_realloc() or `NULL`
+ * @param nmemb Number of elements in the array
+ * @param size  Size of the single element of the array
+ *
+ * @return Pointer to a newly-reallocated block or NULL if the block
+ *         cannot be reallocated
+ *
+ * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
+ *          correctly aligned. The returned pointer must be freed after even if
+ *          nmemb is zero.
+ * @see av_reallocp_array()
+ */
+av_alloc_size(2, 3) void* av_realloc_array(void* ptr, size_t nmemb,
+                                           size_t size);
+
+/**
+ * Allocate, reallocate an array through a pointer to a pointer.
+ *
+ * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.
+ *
+ * @param[in,out] ptr   Pointer to a pointer to a memory block already
+ *                      allocated with av_realloc(), or a pointer to `NULL`.
+ *                      The pointer is updated on success, or freed on failure.
+ * @param[in]     nmemb Number of elements
+ * @param[in]     size  Size of the single element
+ *
+ * @return Zero on success, an AVERROR error code on failure
+ *
+ * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
+ *          correctly aligned. *ptr must be freed after even if nmemb is zero.
+ */
+int av_reallocp_array(void* ptr, size_t nmemb, size_t size);
+
+/**
+ * Reallocate the given buffer if it is not large enough, otherwise do nothing.
+ *
+ * If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
+ *
+ * If the given buffer is not large enough, and reallocation fails, `NULL` is
+ * returned and `*size` is set to 0, but the original buffer is not changed or
+ * freed.
+ *
+ * A typical use pattern follows:
+ *
+ * @code{.c}
+ * uint8_t *buf = ...;
+ * uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
+ * if (!new_buf) {
+ *     // Allocation failed; clean up original buffer
+ *     av_freep(&buf);
+ *     return AVERROR(ENOMEM);
+ * }
+ * @endcode
+ *
+ * @param[in,out] ptr      Already allocated buffer, or `NULL`
+ * @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is
+ *                         updated to the new allocated size, in particular 0
+ *                         in case of failure.
+ * @param[in]     min_size Desired minimal size of buffer `ptr`
+ * @return `ptr` if the buffer is large enough, a pointer to newly reallocated
+ *         buffer if the buffer was not large enough, or `NULL` in case of
+ *         error
+ * @see av_realloc()
+ * @see av_fast_malloc()
+ */
+void* av_fast_realloc(void* ptr, unsigned int* size, size_t min_size);
+
+/**
+ * Allocate a buffer, reusing the given one if large enough.
+ *
+ * Contrary to av_fast_realloc(), the current buffer contents might not be
+ * preserved and on error the old buffer is freed, thus no special handling to
+ * avoid memleaks is necessary.
+ *
+ * `*ptr` is allowed to be `NULL`, in which case allocation always happens if
+ * `size_needed` is greater than 0.
+ *
+ * @code{.c}
+ * uint8_t *buf = ...;
+ * av_fast_malloc(&buf, &current_size, size_needed);
+ * if (!buf) {
+ *     // Allocation failed; buf already freed
+ *     return AVERROR(ENOMEM);
+ * }
+ * @endcode
+ *
+ * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
+ *                         `*ptr` will be overwritten with pointer to new
+ *                         buffer on success or `NULL` on failure
+ * @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
+ *                         updated to the new allocated size, in particular 0
+ *                         in case of failure.
+ * @param[in]     min_size Desired minimal size of buffer `*ptr`
+ * @see av_realloc()
+ * @see av_fast_mallocz()
+ */
+void av_fast_malloc(void* ptr, unsigned int* size, size_t min_size);
+
+/**
+ * Allocate and clear a buffer, reusing the given one if large enough.
+ *
+ * Like av_fast_malloc(), but all newly allocated space is initially cleared.
+ * Reused buffer is not cleared.
+ *
+ * `*ptr` is allowed to be `NULL`, in which case allocation always happens if
+ * `size_needed` is greater than 0.
+ *
+ * @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
+ *                         `*ptr` will be overwritten with pointer to new
+ *                         buffer on success or `NULL` on failure
+ * @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
+ *                         updated to the new allocated size, in particular 0
+ *                         in case of failure.
+ * @param[in]     min_size Desired minimal size of buffer `*ptr`
+ * @see av_fast_malloc()
+ */
+void av_fast_mallocz(void* ptr, unsigned int* size, size_t min_size);
+
+/**
+ * Free a memory block which has been allocated with a function of av_malloc()
+ * or av_realloc() family.
+ *
+ * @param ptr Pointer to the memory block which should be freed.
+ *
+ * @note `ptr = NULL` is explicitly allowed.
+ * @note It is recommended that you use av_freep() instead, to prevent leaving
+ *       behind dangling pointers.
+ * @see av_freep()
+ */
+void av_free(void* ptr);
+
+/**
+ * Free a memory block which has been allocated with a function of av_malloc()
+ * or av_realloc() family, and set the pointer pointing to it to `NULL`.
+ *
+ * @code{.c}
+ * uint8_t *buf = av_malloc(16);
+ * av_free(buf);
+ * // buf now contains a dangling pointer to freed memory, and accidental
+ * // dereference of buf will result in a use-after-free, which may be a
+ * // security risk.
+ *
+ * uint8_t *buf = av_malloc(16);
+ * av_freep(&buf);
+ * // buf is now NULL, and accidental dereference will only result in a
+ * // NULL-pointer dereference.
+ * @endcode
+ *
+ * @param ptr Pointer to the pointer to the memory block which should be freed
+ * @note `*ptr = NULL` is safe and leads to no action.
+ * @see av_free()
+ */
+void av_freep(void* ptr);
+
+/**
+ * Duplicate a string.
+ *
+ * @param s String to be duplicated
+ * @return Pointer to a newly-allocated string containing a
+ *         copy of `s` or `NULL` if the string cannot be allocated
+ * @see av_strndup()
+ */
+char* av_strdup(const char* s) av_malloc_attrib;
+
+/**
+ * Duplicate a substring of a string.
+ *
+ * @param s   String to be duplicated
+ * @param len Maximum length of the resulting string (not counting the
+ *            terminating byte)
+ * @return Pointer to a newly-allocated string containing a
+ *         substring of `s` or `NULL` if the string cannot be allocated
+ */
+char* av_strndup(const char* s, size_t len) av_malloc_attrib;
+
+/**
+ * Duplicate a buffer with av_malloc().
+ *
+ * @param p    Buffer to be duplicated
+ * @param size Size in bytes of the buffer copied
+ * @return Pointer to a newly allocated buffer containing a
+ *         copy of `p` or `NULL` if the buffer cannot be allocated
+ */
+void* av_memdup(const void* p, size_t size);
+
+/**
+ * Overlapping memcpy() implementation.
+ *
+ * @param dst  Destination buffer
+ * @param back Number of bytes back to start copying (i.e. the initial size of
+ *             the overlapping window); must be > 0
+ * @param cnt  Number of bytes to copy; must be >= 0
+ *
+ * @note `cnt > back` is valid, this will copy the bytes we just copied,
+ *       thus creating a repeating pattern with a period length of `back`.
+ */
+void av_memcpy_backptr(uint8_t* dst, int back, int cnt);
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lavu_mem_dynarray Dynamic Array
+ *
+ * Utilities to make an array grow when needed.
+ *
+ * Sometimes, the programmer would want to have an array that can grow when
+ * needed. The libavutil dynamic array utilities fill that need.
+ *
+ * libavutil supports two systems of appending elements onto a dynamically
+ * allocated array, the first one storing the pointer to the value in the
+ * array, and the second storing the value directly. In both systems, the
+ * caller is responsible for maintaining a variable containing the length of
+ * the array, as well as freeing of the array after use.
+ *
+ * The first system stores pointers to values in a block of dynamically
+ * allocated memory. Since only pointers are stored, the function does not need
+ * to know the size of the type. Both av_dynarray_add() and
+ * av_dynarray_add_nofree() implement this system.
+ *
+ * @code
+ * type **array = NULL; //< an array of pointers to values
+ * int    nb    = 0;    //< a variable to keep track of the length of the array
+ *
+ * type to_be_added  = ...;
+ * type to_be_added2 = ...;
+ *
+ * av_dynarray_add(&array, &nb, &to_be_added);
+ * if (nb == 0)
+ *     return AVERROR(ENOMEM);
+ *
+ * av_dynarray_add(&array, &nb, &to_be_added2);
+ * if (nb == 0)
+ *     return AVERROR(ENOMEM);
+ *
+ * // Now:
+ * //  nb           == 2
+ * // &to_be_added  == array[0]
+ * // &to_be_added2 == array[1]
+ *
+ * av_freep(&array);
+ * @endcode
+ *
+ * The second system stores the value directly in a block of memory. As a
+ * result, the function has to know the size of the type. av_dynarray2_add()
+ * implements this mechanism.
+ *
+ * @code
+ * type *array = NULL; //< an array of values
+ * int   nb    = 0;    //< a variable to keep track of the length of the array
+ *
+ * type to_be_added  = ...;
+ * type to_be_added2 = ...;
+ *
+ * type *addr = av_dynarray2_add((void **)&array, &nb, sizeof(*array), NULL);
+ * if (!addr)
+ *     return AVERROR(ENOMEM);
+ * memcpy(addr, &to_be_added, sizeof(to_be_added));
+ *
+ * // Shortcut of the above.
+ * type *addr = av_dynarray2_add((void **)&array, &nb, sizeof(*array),
+ *                               (const void *)&to_be_added2);
+ * if (!addr)
+ *     return AVERROR(ENOMEM);
+ *
+ * // Now:
+ * //  nb           == 2
+ * //  to_be_added  == array[0]
+ * //  to_be_added2 == array[1]
+ *
+ * av_freep(&array);
+ * @endcode
+ *
+ * @{
+ */
+
+/**
+ * Add the pointer to an element to a dynamic array.
+ *
+ * The array to grow is supposed to be an array of pointers to
+ * structures, and the element to add must be a pointer to an already
+ * allocated structure.
+ *
+ * The array is reallocated when its size reaches powers of 2.
+ * Therefore, the amortized cost of adding an element is constant.
+ *
+ * In case of success, the pointer to the array is updated in order to
+ * point to the new grown array, and the number pointed to by `nb_ptr`
+ * is incremented.
+ * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
+ * `*nb_ptr` is set to 0.
+ *
+ * @param[in,out] tab_ptr Pointer to the array to grow
+ * @param[in,out] nb_ptr  Pointer to the number of elements in the array
+ * @param[in]     elem    Element to add
+ * @see av_dynarray_add_nofree(), av_dynarray2_add()
+ */
+void av_dynarray_add(void* tab_ptr, int* nb_ptr, void* elem);
+
+/**
+ * Add an element to a dynamic array.
+ *
+ * Function has the same functionality as av_dynarray_add(),
+ * but it doesn't free memory on fails. It returns error code
+ * instead and leave current buffer untouched.
+ *
+ * @return >=0 on success, negative otherwise
+ * @see av_dynarray_add(), av_dynarray2_add()
+ */
+av_warn_unused_result int av_dynarray_add_nofree(void* tab_ptr, int* nb_ptr,
+                                                 void* elem);
+
+/**
+ * Add an element of size `elem_size` to a dynamic array.
+ *
+ * The array is reallocated when its number of elements reaches powers of 2.
+ * Therefore, the amortized cost of adding an element is constant.
+ *
+ * In case of success, the pointer to the array is updated in order to
+ * point to the new grown array, and the number pointed to by `nb_ptr`
+ * is incremented.
+ * In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
+ * `*nb_ptr` is set to 0.
+ *
+ * @param[in,out] tab_ptr   Pointer to the array to grow
+ * @param[in,out] nb_ptr    Pointer to the number of elements in the array
+ * @param[in]     elem_size Size in bytes of an element in the array
+ * @param[in]     elem_data Pointer to the data of the element to add. If
+ *                          `NULL`, the space of the newly added element is
+ *                          allocated but left uninitialized.
+ *
+ * @return Pointer to the data of the element to copy in the newly allocated
+ *         space
+ * @see av_dynarray_add(), av_dynarray_add_nofree()
+ */
+void* av_dynarray2_add(void** tab_ptr, int* nb_ptr, size_t elem_size,
+                       const uint8_t* elem_data);
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lavu_mem_misc Miscellaneous Functions
+ *
+ * Other functions related to memory allocation.
+ *
+ * @{
+ */
+
+/**
+ * Multiply two `size_t` values checking for overflow.
+ *
+ * @param[in]  a   Operand of multiplication
+ * @param[in]  b   Operand of multiplication
+ * @param[out] r   Pointer to the result of the operation
+ * @return 0 on success, AVERROR(EINVAL) on overflow
+ */
+int av_size_mult(size_t a, size_t b, size_t* r);
+
+/**
+ * Set the maximum size that may be allocated in one block.
+ *
+ * The value specified with this function is effective for all libavutil's @ref
+ * lavu_mem_funcs "heap management functions."
+ *
+ * By default, the max value is defined as `INT_MAX`.
+ *
+ * @param max Value to be set as the new maximum size
+ *
+ * @warning Exercise extreme caution when using this function. Don't touch
+ *          this if you do not understand the full consequence of doing so.
+ */
+void av_max_alloc(size_t max);
+
+/**
+ * @}
+ * @}
+ */
+
+#endif /* AVUTIL_MEM_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/pixfmt.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/pixfmt.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/pixfmt.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/pixfmt.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,891 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_PIXFMT_H
+#define AVUTIL_PIXFMT_H
+
+/**
+ * @file
+ * pixel format definitions
+ */
+
+#include "libavutil/avconfig.h"
+#include "version.h"
+
+#define AVPALETTE_SIZE 1024
+#define AVPALETTE_COUNT 256
+
+/**
+ * Pixel format.
+ *
+ * @note
+ * AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
+ * color is put together as:
+ *  (A << 24) | (R << 16) | (G << 8) | B
+ * This is stored as BGRA on little-endian CPU architectures and ARGB on
+ * big-endian CPUs.
+ *
+ * @note
+ * If the resolution is not a multiple of the chroma subsampling factor
+ * then the chroma plane resolution must be rounded up.
+ *
+ * @par
+ * When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
+ * image data is stored in AVFrame.data[0]. The palette is transported in
+ * AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
+ * formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
+ * also endian-specific). Note also that the individual RGB32 palette
+ * components stored in AVFrame.data[1] should be in the range 0..255.
+ * This is important as many custom PAL8 video codecs that were designed
+ * to run on the IBM VGA graphics adapter use 6-bit palette components.
+ *
+ * @par
+ * For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
+ * for pal8. This palette is filled in automatically by the function
+ * allocating the picture.
+ */
+enum AVPixelFormat {
+  AV_PIX_FMT_NONE = -1,
+  AV_PIX_FMT_YUV420P,  ///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y
+                       ///< samples)
+  AV_PIX_FMT_YUYV422,  ///< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
+  AV_PIX_FMT_RGB24,    ///< packed RGB 8:8:8, 24bpp, RGBRGB...
+  AV_PIX_FMT_BGR24,    ///< packed RGB 8:8:8, 24bpp, BGRBGR...
+  AV_PIX_FMT_YUV422P,  ///< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y
+                       ///< samples)
+  AV_PIX_FMT_YUV444P,  ///< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y
+                       ///< samples)
+  AV_PIX_FMT_YUV410P,  ///< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y
+                       ///< samples)
+  AV_PIX_FMT_YUV411P,  ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y
+                       ///< samples)
+  AV_PIX_FMT_GRAY8,    ///<        Y        ,  8bpp
+  AV_PIX_FMT_MONOWHITE,  ///<        Y        ,  1bpp, 0 is white, 1 is black,
+                         ///<        in each byte pixels are ordered from the
+                         ///<        msb to the lsb
+  AV_PIX_FMT_MONOBLACK,  ///<        Y        ,  1bpp, 0 is black, 1 is white,
+                         ///<        in each byte pixels are ordered from the
+                         ///<        msb to the lsb
+  AV_PIX_FMT_PAL8,       ///< 8 bits with AV_PIX_FMT_RGB32 palette
+  AV_PIX_FMT_YUVJ420P,   ///< planar YUV 4:2:0, 12bpp, full scale (JPEG),
+                         ///< deprecated in favor of AV_PIX_FMT_YUV420P and
+                         ///< setting color_range
+  AV_PIX_FMT_YUVJ422P,   ///< planar YUV 4:2:2, 16bpp, full scale (JPEG),
+                         ///< deprecated in favor of AV_PIX_FMT_YUV422P and
+                         ///< setting color_range
+  AV_PIX_FMT_YUVJ444P,   ///< planar YUV 4:4:4, 24bpp, full scale (JPEG),
+                         ///< deprecated in favor of AV_PIX_FMT_YUV444P and
+                         ///< setting color_range
+  AV_PIX_FMT_UYVY422,    ///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
+  AV_PIX_FMT_UYYVYY411,  ///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
+  AV_PIX_FMT_BGR8,       ///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
+  AV_PIX_FMT_BGR4,  ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb),
+                    ///< a byte contains two pixels, the first pixel in the byte
+                    ///< is the one composed by the 4 msb bits
+  AV_PIX_FMT_BGR4_BYTE,  ///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
+  AV_PIX_FMT_RGB8,       ///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
+  AV_PIX_FMT_RGB4,  ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb),
+                    ///< a byte contains two pixels, the first pixel in the byte
+                    ///< is the one composed by the 4 msb bits
+  AV_PIX_FMT_RGB4_BYTE,  ///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
+  AV_PIX_FMT_NV12,  ///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for
+                    ///< the UV components, which are interleaved (first byte U
+                    ///< and the following byte V)
+  AV_PIX_FMT_NV21,  ///< as above, but U and V bytes are swapped
+
+  AV_PIX_FMT_ARGB,  ///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
+  AV_PIX_FMT_RGBA,  ///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
+  AV_PIX_FMT_ABGR,  ///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
+  AV_PIX_FMT_BGRA,  ///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
+
+  AV_PIX_FMT_GRAY16BE,  ///<        Y        , 16bpp, big-endian
+  AV_PIX_FMT_GRAY16LE,  ///<        Y        , 16bpp, little-endian
+  AV_PIX_FMT_YUV440P,   ///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y
+                        ///< samples)
+  AV_PIX_FMT_YUVJ440P,  ///< planar YUV 4:4:0 full scale (JPEG), deprecated in
+                        ///< favor of AV_PIX_FMT_YUV440P and setting color_range
+  AV_PIX_FMT_YUVA420P,  ///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2
+                        ///< Y & A samples)
+  AV_PIX_FMT_RGB48BE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the
+                        ///< 2-byte value for each R/G/B component is stored as
+                        ///< big-endian
+  AV_PIX_FMT_RGB48LE,   ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the
+                        ///< 2-byte value for each R/G/B component is stored as
+                        ///< little-endian
+
+  AV_PIX_FMT_RGB565BE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb),
+                        ///< big-endian
+  AV_PIX_FMT_RGB565LE,  ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb),
+                        ///< little-endian
+  AV_PIX_FMT_RGB555BE,  ///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb),
+                        ///< big-endian   , X=unused/undefined
+  AV_PIX_FMT_RGB555LE,  ///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb),
+                        ///< little-endian, X=unused/undefined
+
+  AV_PIX_FMT_BGR565BE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb),
+                        ///< big-endian
+  AV_PIX_FMT_BGR565LE,  ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb),
+                        ///< little-endian
+  AV_PIX_FMT_BGR555BE,  ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb),
+                        ///< big-endian   , X=unused/undefined
+  AV_PIX_FMT_BGR555LE,  ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb),
+                        ///< little-endian, X=unused/undefined
+
+  /**
+   *  Hardware acceleration through VA-API, data[3] contains a
+   *  VASurfaceID.
+   */
+  AV_PIX_FMT_VAAPI,
+
+  AV_PIX_FMT_YUV420P16LE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), little-endian
+  AV_PIX_FMT_YUV420P16BE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), big-endian
+  AV_PIX_FMT_YUV422P16LE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), little-endian
+  AV_PIX_FMT_YUV422P16BE,  ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), big-endian
+  AV_PIX_FMT_YUV444P16LE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), little-endian
+  AV_PIX_FMT_YUV444P16BE,  ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), big-endian
+  AV_PIX_FMT_DXVA2_VLD,    ///< HW decoding through DXVA2, Picture.data[3]
+                           ///< contains a LPDIRECT3DSURFACE9 pointer
+
+  AV_PIX_FMT_RGB444LE,  ///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb),
+                        ///< little-endian, X=unused/undefined
+  AV_PIX_FMT_RGB444BE,  ///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb),
+                        ///< big-endian,    X=unused/undefined
+  AV_PIX_FMT_BGR444LE,  ///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb),
+                        ///< little-endian, X=unused/undefined
+  AV_PIX_FMT_BGR444BE,  ///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb),
+                        ///< big-endian,    X=unused/undefined
+  AV_PIX_FMT_YA8,       ///< 8 bits gray, 8 bits alpha
+
+  AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8,   ///< alias for AV_PIX_FMT_YA8
+  AV_PIX_FMT_GRAY8A = AV_PIX_FMT_YA8,  ///< alias for AV_PIX_FMT_YA8
+
+  AV_PIX_FMT_BGR48BE,  ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the
+                       ///< 2-byte value for each R/G/B component is stored as
+                       ///< big-endian
+  AV_PIX_FMT_BGR48LE,  ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the
+                       ///< 2-byte value for each R/G/B component is stored as
+                       ///< little-endian
+
+  /**
+   * The following 12 formats have the disadvantage of needing 1 format for each
+   * bit depth. Notice that each 9/10 bits sample is stored in 16 bits with
+   * extra padding. If you want to support multiple bit depths, then using
+   * AV_PIX_FMT_YUV420P16* with the bpp stored separately is better.
+   */
+  AV_PIX_FMT_YUV420P9BE,   ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), big-endian
+  AV_PIX_FMT_YUV420P9LE,   ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), little-endian
+  AV_PIX_FMT_YUV420P10BE,  ///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), big-endian
+  AV_PIX_FMT_YUV420P10LE,  ///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), little-endian
+  AV_PIX_FMT_YUV422P10BE,  ///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), big-endian
+  AV_PIX_FMT_YUV422P10LE,  ///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), little-endian
+  AV_PIX_FMT_YUV444P9BE,   ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), big-endian
+  AV_PIX_FMT_YUV444P9LE,   ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), little-endian
+  AV_PIX_FMT_YUV444P10BE,  ///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), big-endian
+  AV_PIX_FMT_YUV444P10LE,  ///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), little-endian
+  AV_PIX_FMT_YUV422P9BE,   ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), big-endian
+  AV_PIX_FMT_YUV422P9LE,   ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), little-endian
+  AV_PIX_FMT_GBRP,         ///< planar GBR 4:4:4 24bpp
+  AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP,  // alias for #AV_PIX_FMT_GBRP
+  AV_PIX_FMT_GBRP9BE,                   ///< planar GBR 4:4:4 27bpp, big-endian
+  AV_PIX_FMT_GBRP9LE,   ///< planar GBR 4:4:4 27bpp, little-endian
+  AV_PIX_FMT_GBRP10BE,  ///< planar GBR 4:4:4 30bpp, big-endian
+  AV_PIX_FMT_GBRP10LE,  ///< planar GBR 4:4:4 30bpp, little-endian
+  AV_PIX_FMT_GBRP16BE,  ///< planar GBR 4:4:4 48bpp, big-endian
+  AV_PIX_FMT_GBRP16LE,  ///< planar GBR 4:4:4 48bpp, little-endian
+  AV_PIX_FMT_YUVA422P,  ///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y
+                        ///< & A samples)
+  AV_PIX_FMT_YUVA444P,  ///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y
+                        ///< & A samples)
+  AV_PIX_FMT_YUVA420P9BE,   ///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per
+                            ///< 2x2 Y & A samples), big-endian
+  AV_PIX_FMT_YUVA420P9LE,   ///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per
+                            ///< 2x2 Y & A samples), little-endian
+  AV_PIX_FMT_YUVA422P9BE,   ///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y & A samples), big-endian
+  AV_PIX_FMT_YUVA422P9LE,   ///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y & A samples), little-endian
+  AV_PIX_FMT_YUVA444P9BE,   ///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y & A samples), big-endian
+  AV_PIX_FMT_YUVA444P9LE,   ///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y & A samples), little-endian
+  AV_PIX_FMT_YUVA420P10BE,  ///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per
+                            ///< 2x2 Y & A samples, big-endian)
+  AV_PIX_FMT_YUVA420P10LE,  ///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per
+                            ///< 2x2 Y & A samples, little-endian)
+  AV_PIX_FMT_YUVA422P10BE,  ///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y & A samples, big-endian)
+  AV_PIX_FMT_YUVA422P10LE,  ///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y & A samples, little-endian)
+  AV_PIX_FMT_YUVA444P10BE,  ///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y & A samples, big-endian)
+  AV_PIX_FMT_YUVA444P10LE,  ///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y & A samples, little-endian)
+  AV_PIX_FMT_YUVA420P16BE,  ///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per
+                            ///< 2x2 Y & A samples, big-endian)
+  AV_PIX_FMT_YUVA420P16LE,  ///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per
+                            ///< 2x2 Y & A samples, little-endian)
+  AV_PIX_FMT_YUVA422P16BE,  ///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y & A samples, big-endian)
+  AV_PIX_FMT_YUVA422P16LE,  ///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y & A samples, little-endian)
+  AV_PIX_FMT_YUVA444P16BE,  ///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y & A samples, big-endian)
+  AV_PIX_FMT_YUVA444P16LE,  ///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y & A samples, little-endian)
+
+  AV_PIX_FMT_VDPAU,  ///< HW acceleration through VDPAU, Picture.data[3]
+                     ///< contains a VdpVideoSurface
+
+  AV_PIX_FMT_XYZ12LE,  ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb),
+                       ///< the 2-byte value for each X/Y/Z is stored as
+                       ///< little-endian, the 4 lower bits are set to 0
+  AV_PIX_FMT_XYZ12BE,  ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb),
+                       ///< the 2-byte value for each X/Y/Z is stored as
+                       ///< big-endian, the 4 lower bits are set to 0
+  AV_PIX_FMT_NV16,  ///< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample
+                    ///< per 2x1 Y samples)
+  AV_PIX_FMT_NV20LE,  ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb
+                      ///< sample per 2x1 Y samples), little-endian
+  AV_PIX_FMT_NV20BE,  ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb
+                      ///< sample per 2x1 Y samples), big-endian
+
+  AV_PIX_FMT_RGBA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A,
+                        ///< the 2-byte value for each R/G/B/A component is
+                        ///< stored as big-endian
+  AV_PIX_FMT_RGBA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A,
+                        ///< the 2-byte value for each R/G/B/A component is
+                        ///< stored as little-endian
+  AV_PIX_FMT_BGRA64BE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A,
+                        ///< the 2-byte value for each R/G/B/A component is
+                        ///< stored as big-endian
+  AV_PIX_FMT_BGRA64LE,  ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A,
+                        ///< the 2-byte value for each R/G/B/A component is
+                        ///< stored as little-endian
+
+  AV_PIX_FMT_YVYU422,  ///< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb
+
+  AV_PIX_FMT_YA16BE,  ///< 16 bits gray, 16 bits alpha (big-endian)
+  AV_PIX_FMT_YA16LE,  ///< 16 bits gray, 16 bits alpha (little-endian)
+
+  AV_PIX_FMT_GBRAP,      ///< planar GBRA 4:4:4:4 32bpp
+  AV_PIX_FMT_GBRAP16BE,  ///< planar GBRA 4:4:4:4 64bpp, big-endian
+  AV_PIX_FMT_GBRAP16LE,  ///< planar GBRA 4:4:4:4 64bpp, little-endian
+  /**
+   * HW acceleration through QSV, data[3] contains a pointer to the
+   * mfxFrameSurface1 structure.
+   *
+   * Before FFmpeg 5.0:
+   * mfxFrameSurface1.Data.MemId contains a pointer when importing
+   * the following frames as QSV frames:
+   *
+   * VAAPI:
+   * mfxFrameSurface1.Data.MemId contains a pointer to VASurfaceID
+   *
+   * DXVA2:
+   * mfxFrameSurface1.Data.MemId contains a pointer to IDirect3DSurface9
+   *
+   * FFmpeg 5.0 and above:
+   * mfxFrameSurface1.Data.MemId contains a pointer to the mfxHDLPair
+   * structure when importing the following frames as QSV frames:
+   *
+   * VAAPI:
+   * mfxHDLPair.first contains a VASurfaceID pointer.
+   * mfxHDLPair.second is always MFX_INFINITE.
+   *
+   * DXVA2:
+   * mfxHDLPair.first contains IDirect3DSurface9 pointer.
+   * mfxHDLPair.second is always MFX_INFINITE.
+   *
+   * D3D11:
+   * mfxHDLPair.first contains a ID3D11Texture2D pointer.
+   * mfxHDLPair.second contains the texture array index of the frame if the
+   * ID3D11Texture2D is an array texture, or always MFX_INFINITE if it is a
+   * normal texture.
+   */
+  AV_PIX_FMT_QSV,
+  /**
+   * HW acceleration though MMAL, data[3] contains a pointer to the
+   * MMAL_BUFFER_HEADER_T structure.
+   */
+  AV_PIX_FMT_MMAL,
+
+  AV_PIX_FMT_D3D11VA_VLD,  ///< HW decoding through Direct3D11 via old API,
+                           ///< Picture.data[3] contains a
+                           ///< ID3D11VideoDecoderOutputView pointer
+
+  /**
+   * HW acceleration through CUDA. data[i] contain CUdeviceptr pointers
+   * exactly as for system memory frames.
+   */
+  AV_PIX_FMT_CUDA,
+
+  AV_PIX_FMT_0RGB,  ///< packed RGB 8:8:8, 32bpp, XRGBXRGB... X=unused/undefined
+  AV_PIX_FMT_RGB0,  ///< packed RGB 8:8:8, 32bpp, RGBXRGBX... X=unused/undefined
+  AV_PIX_FMT_0BGR,  ///< packed BGR 8:8:8, 32bpp, XBGRXBGR... X=unused/undefined
+  AV_PIX_FMT_BGR0,  ///< packed BGR 8:8:8, 32bpp, BGRXBGRX... X=unused/undefined
+
+  AV_PIX_FMT_YUV420P12BE,  ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), big-endian
+  AV_PIX_FMT_YUV420P12LE,  ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), little-endian
+  AV_PIX_FMT_YUV420P14BE,  ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), big-endian
+  AV_PIX_FMT_YUV420P14LE,  ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per
+                           ///< 2x2 Y samples), little-endian
+  AV_PIX_FMT_YUV422P12BE,  ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), big-endian
+  AV_PIX_FMT_YUV422P12LE,  ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), little-endian
+  AV_PIX_FMT_YUV422P14BE,  ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), big-endian
+  AV_PIX_FMT_YUV422P14LE,  ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per
+                           ///< 2x1 Y samples), little-endian
+  AV_PIX_FMT_YUV444P12BE,  ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), big-endian
+  AV_PIX_FMT_YUV444P12LE,  ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), little-endian
+  AV_PIX_FMT_YUV444P14BE,  ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), big-endian
+  AV_PIX_FMT_YUV444P14LE,  ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per
+                           ///< 1x1 Y samples), little-endian
+  AV_PIX_FMT_GBRP12BE,     ///< planar GBR 4:4:4 36bpp, big-endian
+  AV_PIX_FMT_GBRP12LE,     ///< planar GBR 4:4:4 36bpp, little-endian
+  AV_PIX_FMT_GBRP14BE,     ///< planar GBR 4:4:4 42bpp, big-endian
+  AV_PIX_FMT_GBRP14LE,     ///< planar GBR 4:4:4 42bpp, little-endian
+  AV_PIX_FMT_YUVJ411P,  ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1
+                        ///< Y samples) full scale (JPEG), deprecated in favor
+                        ///< of AV_PIX_FMT_YUV411P and setting color_range
+
+  AV_PIX_FMT_BAYER_BGGR8,     ///< bayer, BGBG..(odd line), GRGR..(even line),
+                              ///< 8-bit samples
+  AV_PIX_FMT_BAYER_RGGB8,     ///< bayer, RGRG..(odd line), GBGB..(even line),
+                              ///< 8-bit samples
+  AV_PIX_FMT_BAYER_GBRG8,     ///< bayer, GBGB..(odd line), RGRG..(even line),
+                              ///< 8-bit samples
+  AV_PIX_FMT_BAYER_GRBG8,     ///< bayer, GRGR..(odd line), BGBG..(even line),
+                              ///< 8-bit samples
+  AV_PIX_FMT_BAYER_BGGR16LE,  ///< bayer, BGBG..(odd line), GRGR..(even line),
+                              ///< 16-bit samples, little-endian
+  AV_PIX_FMT_BAYER_BGGR16BE,  ///< bayer, BGBG..(odd line), GRGR..(even line),
+                              ///< 16-bit samples, big-endian
+  AV_PIX_FMT_BAYER_RGGB16LE,  ///< bayer, RGRG..(odd line), GBGB..(even line),
+                              ///< 16-bit samples, little-endian
+  AV_PIX_FMT_BAYER_RGGB16BE,  ///< bayer, RGRG..(odd line), GBGB..(even line),
+                              ///< 16-bit samples, big-endian
+  AV_PIX_FMT_BAYER_GBRG16LE,  ///< bayer, GBGB..(odd line), RGRG..(even line),
+                              ///< 16-bit samples, little-endian
+  AV_PIX_FMT_BAYER_GBRG16BE,  ///< bayer, GBGB..(odd line), RGRG..(even line),
+                              ///< 16-bit samples, big-endian
+  AV_PIX_FMT_BAYER_GRBG16LE,  ///< bayer, GRGR..(odd line), BGBG..(even line),
+                              ///< 16-bit samples, little-endian
+  AV_PIX_FMT_BAYER_GRBG16BE,  ///< bayer, GRGR..(odd line), BGBG..(even line),
+                              ///< 16-bit samples, big-endian
+
+#if FF_API_XVMC
+  AV_PIX_FMT_XVMC,  ///< XVideo Motion Acceleration via common packet passing
+#endif
+
+  AV_PIX_FMT_YUV440P10LE,  ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per
+                           ///< 1x2 Y samples), little-endian
+  AV_PIX_FMT_YUV440P10BE,  ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per
+                           ///< 1x2 Y samples), big-endian
+  AV_PIX_FMT_YUV440P12LE,  ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per
+                           ///< 1x2 Y samples), little-endian
+  AV_PIX_FMT_YUV440P12BE,  ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per
+                           ///< 1x2 Y samples), big-endian
+  AV_PIX_FMT_AYUV64LE,  ///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y
+                        ///< & A samples), little-endian
+  AV_PIX_FMT_AYUV64BE,  ///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y
+                        ///< & A samples), big-endian
+
+  AV_PIX_FMT_VIDEOTOOLBOX,  ///< hardware decoding through Videotoolbox
+
+  AV_PIX_FMT_P010LE,  ///< like NV12, with 10bpp per component, data in the high
+                      ///< bits, zeros in the low bits, little-endian
+  AV_PIX_FMT_P010BE,  ///< like NV12, with 10bpp per component, data in the high
+                      ///< bits, zeros in the low bits, big-endian
+
+  AV_PIX_FMT_GBRAP12BE,  ///< planar GBR 4:4:4:4 48bpp, big-endian
+  AV_PIX_FMT_GBRAP12LE,  ///< planar GBR 4:4:4:4 48bpp, little-endian
+
+  AV_PIX_FMT_GBRAP10BE,  ///< planar GBR 4:4:4:4 40bpp, big-endian
+  AV_PIX_FMT_GBRAP10LE,  ///< planar GBR 4:4:4:4 40bpp, little-endian
+
+  AV_PIX_FMT_MEDIACODEC,  ///< hardware decoding through MediaCodec
+
+  AV_PIX_FMT_GRAY12BE,  ///<        Y        , 12bpp, big-endian
+  AV_PIX_FMT_GRAY12LE,  ///<        Y        , 12bpp, little-endian
+  AV_PIX_FMT_GRAY10BE,  ///<        Y        , 10bpp, big-endian
+  AV_PIX_FMT_GRAY10LE,  ///<        Y        , 10bpp, little-endian
+
+  AV_PIX_FMT_P016LE,  ///< like NV12, with 16bpp per component, little-endian
+  AV_PIX_FMT_P016BE,  ///< like NV12, with 16bpp per component, big-endian
+
+  /**
+   * Hardware surfaces for Direct3D11.
+   *
+   * This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11
+   * hwaccel API and filtering support AV_PIX_FMT_D3D11 only.
+   *
+   * data[0] contains a ID3D11Texture2D pointer, and data[1] contains the
+   * texture array index of the frame as intptr_t if the ID3D11Texture2D is
+   * an array texture (or always 0 if it's a normal texture).
+   */
+  AV_PIX_FMT_D3D11,
+
+  AV_PIX_FMT_GRAY9BE,  ///<        Y        , 9bpp, big-endian
+  AV_PIX_FMT_GRAY9LE,  ///<        Y        , 9bpp, little-endian
+
+  AV_PIX_FMT_GBRPF32BE,  ///< IEEE-754 single precision planar GBR 4:4:4, 96bpp,
+                         ///< big-endian
+  AV_PIX_FMT_GBRPF32LE,  ///< IEEE-754 single precision planar GBR 4:4:4, 96bpp,
+                         ///< little-endian
+  AV_PIX_FMT_GBRAPF32BE,  ///< IEEE-754 single precision planar GBRA 4:4:4:4,
+                          ///< 128bpp, big-endian
+  AV_PIX_FMT_GBRAPF32LE,  ///< IEEE-754 single precision planar GBRA 4:4:4:4,
+                          ///< 128bpp, little-endian
+
+  /**
+   * DRM-managed buffers exposed through PRIME buffer sharing.
+   *
+   * data[0] points to an AVDRMFrameDescriptor.
+   */
+  AV_PIX_FMT_DRM_PRIME,
+  /**
+   * Hardware surfaces for OpenCL.
+   *
+   * data[i] contain 2D image objects (typed in C as cl_mem, used
+   * in OpenCL as image2d_t) for each plane of the surface.
+   */
+  AV_PIX_FMT_OPENCL,
+
+  AV_PIX_FMT_GRAY14BE,  ///<        Y        , 14bpp, big-endian
+  AV_PIX_FMT_GRAY14LE,  ///<        Y        , 14bpp, little-endian
+
+  AV_PIX_FMT_GRAYF32BE,  ///< IEEE-754 single precision Y, 32bpp, big-endian
+  AV_PIX_FMT_GRAYF32LE,  ///< IEEE-754 single precision Y, 32bpp, little-endian
+
+  AV_PIX_FMT_YUVA422P12BE,  ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y samples), 12b alpha, big-endian
+  AV_PIX_FMT_YUVA422P12LE,  ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per
+                            ///< 2x1 Y samples), 12b alpha, little-endian
+  AV_PIX_FMT_YUVA444P12BE,  ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y samples), 12b alpha, big-endian
+  AV_PIX_FMT_YUVA444P12LE,  ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per
+                            ///< 1x1 Y samples), 12b alpha, little-endian
+
+  AV_PIX_FMT_NV24,  ///< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for
+                    ///< the UV components, which are interleaved (first byte U
+                    ///< and the following byte V)
+  AV_PIX_FMT_NV42,  ///< as above, but U and V bytes are swapped
+
+  /**
+   * Vulkan hardware images.
+   *
+   * data[0] points to an AVVkFrame
+   */
+  AV_PIX_FMT_VULKAN,
+
+  AV_PIX_FMT_Y210BE,  ///< packed YUV 4:2:2 like YUYV422, 20bpp, data in the
+                      ///< high bits, big-endian
+  AV_PIX_FMT_Y210LE,  ///< packed YUV 4:2:2 like YUYV422, 20bpp, data in the
+                      ///< high bits, little-endian
+
+  AV_PIX_FMT_X2RGB10LE,  ///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G
+                         ///< 10B(lsb), little-endian, X=unused/undefined
+  AV_PIX_FMT_X2RGB10BE,  ///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G
+                         ///< 10B(lsb), big-endian, X=unused/undefined
+  AV_PIX_FMT_X2BGR10LE,  ///< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G
+                         ///< 10R(lsb), little-endian, X=unused/undefined
+  AV_PIX_FMT_X2BGR10BE,  ///< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G
+                         ///< 10R(lsb), big-endian, X=unused/undefined
+
+  AV_PIX_FMT_P210BE,  ///< interleaved chroma YUV 4:2:2, 20bpp, data in the high
+                      ///< bits, big-endian
+  AV_PIX_FMT_P210LE,  ///< interleaved chroma YUV 4:2:2, 20bpp, data in the high
+                      ///< bits, little-endian
+
+  AV_PIX_FMT_P410BE,  ///< interleaved chroma YUV 4:4:4, 30bpp, data in the high
+                      ///< bits, big-endian
+  AV_PIX_FMT_P410LE,  ///< interleaved chroma YUV 4:4:4, 30bpp, data in the high
+                      ///< bits, little-endian
+
+  AV_PIX_FMT_P216BE,  ///< interleaved chroma YUV 4:2:2, 32bpp, big-endian
+  AV_PIX_FMT_P216LE,  ///< interleaved chroma YUV 4:2:2, 32bpp, little-endian
+
+  AV_PIX_FMT_P416BE,  ///< interleaved chroma YUV 4:4:4, 48bpp, big-endian
+  AV_PIX_FMT_P416LE,  ///< interleaved chroma YUV 4:4:4, 48bpp, little-endian
+
+  AV_PIX_FMT_VUYA,  ///< packed VUYA 4:4:4, 32bpp, VUYAVUYA...
+
+  AV_PIX_FMT_RGBAF16BE,  ///< IEEE-754 half precision packed RGBA 16:16:16:16,
+                         ///< 64bpp, RGBARGBA..., big-endian
+  AV_PIX_FMT_RGBAF16LE,  ///< IEEE-754 half precision packed RGBA 16:16:16:16,
+                         ///< 64bpp, RGBARGBA..., little-endian
+
+  AV_PIX_FMT_VUYX,  ///< packed VUYX 4:4:4, 32bpp, Variant of VUYA where alpha
+                    ///< channel is left undefined
+
+  AV_PIX_FMT_P012LE,  ///< like NV12, with 12bpp per component, data in the high
+                      ///< bits, zeros in the low bits, little-endian
+  AV_PIX_FMT_P012BE,  ///< like NV12, with 12bpp per component, data in the high
+                      ///< bits, zeros in the low bits, big-endian
+
+  AV_PIX_FMT_Y212BE,  ///< packed YUV 4:2:2 like YUYV422, 24bpp, data in the
+                      ///< high bits, zeros in the low bits, big-endian
+  AV_PIX_FMT_Y212LE,  ///< packed YUV 4:2:2 like YUYV422, 24bpp, data in the
+                      ///< high bits, zeros in the low bits, little-endian
+
+  AV_PIX_FMT_XV30BE,  ///< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb),
+                      ///< big-endian, variant of Y410 where alpha channel is
+                      ///< left undefined
+  AV_PIX_FMT_XV30LE,  ///< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb),
+                      ///< little-endian, variant of Y410 where alpha channel is
+                      ///< left undefined
+
+  AV_PIX_FMT_XV36BE,  ///< packed XVYU 4:4:4, 48bpp, data in the high bits,
+                      ///< zeros in the low bits, big-endian, variant of Y412
+                      ///< where alpha channel is left undefined
+  AV_PIX_FMT_XV36LE,  ///< packed XVYU 4:4:4, 48bpp, data in the high bits,
+                      ///< zeros in the low bits, little-endian, variant of Y412
+                      ///< where alpha channel is left undefined
+
+  AV_PIX_FMT_RGBF32BE,  ///< IEEE-754 single precision packed RGB 32:32:32,
+                        ///< 96bpp, RGBRGB..., big-endian
+  AV_PIX_FMT_RGBF32LE,  ///< IEEE-754 single precision packed RGB 32:32:32,
+                        ///< 96bpp, RGBRGB..., little-endian
+
+  AV_PIX_FMT_RGBAF32BE,  ///< IEEE-754 single precision packed RGBA 32:32:32:32,
+                         ///< 128bpp, RGBARGBA..., big-endian
+  AV_PIX_FMT_RGBAF32LE,  ///< IEEE-754 single precision packed RGBA 32:32:32:32,
+                         ///< 128bpp, RGBARGBA..., little-endian
+
+  AV_PIX_FMT_NB  ///< number of pixel formats, DO NOT USE THIS if you want to
+                 ///< link with shared libav* because the number of formats
+                 ///< might differ between versions
+};
+
+#if AV_HAVE_BIGENDIAN
+#  define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##be
+#else
+#  define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##le
+#endif
+
+#define AV_PIX_FMT_RGB32 AV_PIX_FMT_NE(ARGB, BGRA)
+#define AV_PIX_FMT_RGB32_1 AV_PIX_FMT_NE(RGBA, ABGR)
+#define AV_PIX_FMT_BGR32 AV_PIX_FMT_NE(ABGR, RGBA)
+#define AV_PIX_FMT_BGR32_1 AV_PIX_FMT_NE(BGRA, ARGB)
+#define AV_PIX_FMT_0RGB32 AV_PIX_FMT_NE(0RGB, BGR0)
+#define AV_PIX_FMT_0BGR32 AV_PIX_FMT_NE(0BGR, RGB0)
+
+#define AV_PIX_FMT_GRAY9 AV_PIX_FMT_NE(GRAY9BE, GRAY9LE)
+#define AV_PIX_FMT_GRAY10 AV_PIX_FMT_NE(GRAY10BE, GRAY10LE)
+#define AV_PIX_FMT_GRAY12 AV_PIX_FMT_NE(GRAY12BE, GRAY12LE)
+#define AV_PIX_FMT_GRAY14 AV_PIX_FMT_NE(GRAY14BE, GRAY14LE)
+#define AV_PIX_FMT_GRAY16 AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)
+#define AV_PIX_FMT_YA16 AV_PIX_FMT_NE(YA16BE, YA16LE)
+#define AV_PIX_FMT_RGB48 AV_PIX_FMT_NE(RGB48BE, RGB48LE)
+#define AV_PIX_FMT_RGB565 AV_PIX_FMT_NE(RGB565BE, RGB565LE)
+#define AV_PIX_FMT_RGB555 AV_PIX_FMT_NE(RGB555BE, RGB555LE)
+#define AV_PIX_FMT_RGB444 AV_PIX_FMT_NE(RGB444BE, RGB444LE)
+#define AV_PIX_FMT_RGBA64 AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)
+#define AV_PIX_FMT_BGR48 AV_PIX_FMT_NE(BGR48BE, BGR48LE)
+#define AV_PIX_FMT_BGR565 AV_PIX_FMT_NE(BGR565BE, BGR565LE)
+#define AV_PIX_FMT_BGR555 AV_PIX_FMT_NE(BGR555BE, BGR555LE)
+#define AV_PIX_FMT_BGR444 AV_PIX_FMT_NE(BGR444BE, BGR444LE)
+#define AV_PIX_FMT_BGRA64 AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)
+
+#define AV_PIX_FMT_YUV420P9 AV_PIX_FMT_NE(YUV420P9BE, YUV420P9LE)
+#define AV_PIX_FMT_YUV422P9 AV_PIX_FMT_NE(YUV422P9BE, YUV422P9LE)
+#define AV_PIX_FMT_YUV444P9 AV_PIX_FMT_NE(YUV444P9BE, YUV444P9LE)
+#define AV_PIX_FMT_YUV420P10 AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)
+#define AV_PIX_FMT_YUV422P10 AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)
+#define AV_PIX_FMT_YUV440P10 AV_PIX_FMT_NE(YUV440P10BE, YUV440P10LE)
+#define AV_PIX_FMT_YUV444P10 AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)
+#define AV_PIX_FMT_YUV420P12 AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)
+#define AV_PIX_FMT_YUV422P12 AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)
+#define AV_PIX_FMT_YUV440P12 AV_PIX_FMT_NE(YUV440P12BE, YUV440P12LE)
+#define AV_PIX_FMT_YUV444P12 AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)
+#define AV_PIX_FMT_YUV420P14 AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)
+#define AV_PIX_FMT_YUV422P14 AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)
+#define AV_PIX_FMT_YUV444P14 AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)
+#define AV_PIX_FMT_YUV420P16 AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
+#define AV_PIX_FMT_YUV422P16 AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
+#define AV_PIX_FMT_YUV444P16 AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
+
+#define AV_PIX_FMT_GBRP9 AV_PIX_FMT_NE(GBRP9BE, GBRP9LE)
+#define AV_PIX_FMT_GBRP10 AV_PIX_FMT_NE(GBRP10BE, GBRP10LE)
+#define AV_PIX_FMT_GBRP12 AV_PIX_FMT_NE(GBRP12BE, GBRP12LE)
+#define AV_PIX_FMT_GBRP14 AV_PIX_FMT_NE(GBRP14BE, GBRP14LE)
+#define AV_PIX_FMT_GBRP16 AV_PIX_FMT_NE(GBRP16BE, GBRP16LE)
+#define AV_PIX_FMT_GBRAP10 AV_PIX_FMT_NE(GBRAP10BE, GBRAP10LE)
+#define AV_PIX_FMT_GBRAP12 AV_PIX_FMT_NE(GBRAP12BE, GBRAP12LE)
+#define AV_PIX_FMT_GBRAP16 AV_PIX_FMT_NE(GBRAP16BE, GBRAP16LE)
+
+#define AV_PIX_FMT_BAYER_BGGR16 AV_PIX_FMT_NE(BAYER_BGGR16BE, BAYER_BGGR16LE)
+#define AV_PIX_FMT_BAYER_RGGB16 AV_PIX_FMT_NE(BAYER_RGGB16BE, BAYER_RGGB16LE)
+#define AV_PIX_FMT_BAYER_GBRG16 AV_PIX_FMT_NE(BAYER_GBRG16BE, BAYER_GBRG16LE)
+#define AV_PIX_FMT_BAYER_GRBG16 AV_PIX_FMT_NE(BAYER_GRBG16BE, BAYER_GRBG16LE)
+
+#define AV_PIX_FMT_GBRPF32 AV_PIX_FMT_NE(GBRPF32BE, GBRPF32LE)
+#define AV_PIX_FMT_GBRAPF32 AV_PIX_FMT_NE(GBRAPF32BE, GBRAPF32LE)
+
+#define AV_PIX_FMT_GRAYF32 AV_PIX_FMT_NE(GRAYF32BE, GRAYF32LE)
+
+#define AV_PIX_FMT_YUVA420P9 AV_PIX_FMT_NE(YUVA420P9BE, YUVA420P9LE)
+#define AV_PIX_FMT_YUVA422P9 AV_PIX_FMT_NE(YUVA422P9BE, YUVA422P9LE)
+#define AV_PIX_FMT_YUVA444P9 AV_PIX_FMT_NE(YUVA444P9BE, YUVA444P9LE)
+#define AV_PIX_FMT_YUVA420P10 AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)
+#define AV_PIX_FMT_YUVA422P10 AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)
+#define AV_PIX_FMT_YUVA444P10 AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)
+#define AV_PIX_FMT_YUVA422P12 AV_PIX_FMT_NE(YUVA422P12BE, YUVA422P12LE)
+#define AV_PIX_FMT_YUVA444P12 AV_PIX_FMT_NE(YUVA444P12BE, YUVA444P12LE)
+#define AV_PIX_FMT_YUVA420P16 AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)
+#define AV_PIX_FMT_YUVA422P16 AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)
+#define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
+
+#define AV_PIX_FMT_XYZ12 AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
+#define AV_PIX_FMT_NV20 AV_PIX_FMT_NE(NV20BE, NV20LE)
+#define AV_PIX_FMT_AYUV64 AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
+#define AV_PIX_FMT_P010 AV_PIX_FMT_NE(P010BE, P010LE)
+#define AV_PIX_FMT_P012 AV_PIX_FMT_NE(P012BE, P012LE)
+#define AV_PIX_FMT_P016 AV_PIX_FMT_NE(P016BE, P016LE)
+
+#define AV_PIX_FMT_Y210 AV_PIX_FMT_NE(Y210BE, Y210LE)
+#define AV_PIX_FMT_Y212 AV_PIX_FMT_NE(Y212BE, Y212LE)
+#define AV_PIX_FMT_XV30 AV_PIX_FMT_NE(XV30BE, XV30LE)
+#define AV_PIX_FMT_XV36 AV_PIX_FMT_NE(XV36BE, XV36LE)
+#define AV_PIX_FMT_X2RGB10 AV_PIX_FMT_NE(X2RGB10BE, X2RGB10LE)
+#define AV_PIX_FMT_X2BGR10 AV_PIX_FMT_NE(X2BGR10BE, X2BGR10LE)
+
+#define AV_PIX_FMT_P210 AV_PIX_FMT_NE(P210BE, P210LE)
+#define AV_PIX_FMT_P410 AV_PIX_FMT_NE(P410BE, P410LE)
+#define AV_PIX_FMT_P216 AV_PIX_FMT_NE(P216BE, P216LE)
+#define AV_PIX_FMT_P416 AV_PIX_FMT_NE(P416BE, P416LE)
+
+#define AV_PIX_FMT_RGBAF16 AV_PIX_FMT_NE(RGBAF16BE, RGBAF16LE)
+
+#define AV_PIX_FMT_RGBF32 AV_PIX_FMT_NE(RGBF32BE, RGBF32LE)
+#define AV_PIX_FMT_RGBAF32 AV_PIX_FMT_NE(RGBAF32BE, RGBAF32LE)
+
+/**
+ * Chromaticity coordinates of the source primaries.
+ * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and
+ * ITU-T H.273.
+ */
+enum AVColorPrimaries {
+  AVCOL_PRI_RESERVED0 = 0,
+  AVCOL_PRI_BT709 =
+      1,  ///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B
+  AVCOL_PRI_UNSPECIFIED = 2,
+  AVCOL_PRI_RESERVED = 3,
+  AVCOL_PRI_BT470M =
+      4,  ///< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
+
+  AVCOL_PRI_BT470BG = 5,  ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R
+                          ///< BT1700 625 PAL & SECAM
+  AVCOL_PRI_SMPTE170M =
+      6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
+  AVCOL_PRI_SMPTE240M =
+      7,  ///< identical to above, also called "SMPTE C" even though it uses D65
+  AVCOL_PRI_FILM = 8,       ///< colour filters using Illuminant C
+  AVCOL_PRI_BT2020 = 9,     ///< ITU-R BT2020
+  AVCOL_PRI_SMPTE428 = 10,  ///< SMPTE ST 428-1 (CIE 1931 XYZ)
+  AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
+  AVCOL_PRI_SMPTE431 = 11,  ///< SMPTE ST 431-2 (2011) / DCI P3
+  AVCOL_PRI_SMPTE432 = 12,  ///< SMPTE ST 432-1 (2010) / P3 D65 / Display P3
+  AVCOL_PRI_EBU3213 = 22,   ///< EBU Tech. 3213-E (nothing there) / one of JEDEC
+                            ///< P22 group phosphors
+  AVCOL_PRI_JEDEC_P22 = AVCOL_PRI_EBU3213,
+  AVCOL_PRI_NB  ///< Not part of ABI
+};
+
+/**
+ * Color Transfer Characteristic.
+ * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2.
+ */
+enum AVColorTransferCharacteristic {
+  AVCOL_TRC_RESERVED0 = 0,
+  AVCOL_TRC_BT709 = 1,  ///< also ITU-R BT1361
+  AVCOL_TRC_UNSPECIFIED = 2,
+  AVCOL_TRC_RESERVED = 3,
+  AVCOL_TRC_GAMMA22 = 4,  ///< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
+  AVCOL_TRC_GAMMA28 = 5,  ///< also ITU-R BT470BG
+  AVCOL_TRC_SMPTE170M = 6,  ///< also ITU-R BT601-6 525 or 625 / ITU-R BT1358
+                            ///< 525 or 625 / ITU-R BT1700 NTSC
+  AVCOL_TRC_SMPTE240M = 7,
+  AVCOL_TRC_LINEAR = 8,  ///< "Linear transfer characteristics"
+  AVCOL_TRC_LOG = 9,  ///< "Logarithmic transfer characteristic (100:1 range)"
+  AVCOL_TRC_LOG_SQRT =
+      10,  ///< "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"
+  AVCOL_TRC_IEC61966_2_4 = 11,  ///< IEC 61966-2-4
+  AVCOL_TRC_BT1361_ECG = 12,    ///< ITU-R BT1361 Extended Colour Gamut
+  AVCOL_TRC_IEC61966_2_1 = 13,  ///< IEC 61966-2-1 (sRGB or sYCC)
+  AVCOL_TRC_BT2020_10 = 14,     ///< ITU-R BT2020 for 10-bit system
+  AVCOL_TRC_BT2020_12 = 15,     ///< ITU-R BT2020 for 12-bit system
+  AVCOL_TRC_SMPTE2084 =
+      16,  ///< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems
+  AVCOL_TRC_SMPTEST2084 = AVCOL_TRC_SMPTE2084,
+  AVCOL_TRC_SMPTE428 = 17,  ///< SMPTE ST 428-1
+  AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
+  AVCOL_TRC_ARIB_STD_B67 = 18,  ///< ARIB STD-B67, known as "Hybrid log-gamma"
+  AVCOL_TRC_NB                  ///< Not part of ABI
+};
+
+/**
+ * YUV colorspace type.
+ * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3.
+ */
+enum AVColorSpace {
+  AVCOL_SPC_RGB = 0,    ///< order of coefficients is actually GBR, also IEC
+                        ///< 61966-2-1 (sRGB), YZX and ST 428-1
+  AVCOL_SPC_BT709 = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 /
+                        ///< derived in SMPTE RP 177 Annex B
+  AVCOL_SPC_UNSPECIFIED = 2,
+  AVCOL_SPC_RESERVED =
+      3,  ///< reserved for future use by ITU-T and ISO/IEC just like 15-255 are
+  AVCOL_SPC_FCC =
+      4,  ///< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
+  AVCOL_SPC_BT470BG = 5,  ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R
+                          ///< BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
+  AVCOL_SPC_SMPTE170M =
+      6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC /
+          ///< functionally identical to above
+  AVCOL_SPC_SMPTE240M =
+      7,  ///< derived from 170M primaries and D65 white point, 170M is derived
+          ///< from BT470 System M's primaries
+  AVCOL_SPC_YCGCO =
+      8,  ///< used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
+  AVCOL_SPC_YCOCG = AVCOL_SPC_YCGCO,
+  AVCOL_SPC_BT2020_NCL = 9,  ///< ITU-R BT2020 non-constant luminance system
+  AVCOL_SPC_BT2020_CL = 10,  ///< ITU-R BT2020 constant luminance system
+  AVCOL_SPC_SMPTE2085 = 11,  ///< SMPTE 2085, Y'D'zD'x
+  AVCOL_SPC_CHROMA_DERIVED_NCL =
+      12,  ///< Chromaticity-derived non-constant luminance system
+  AVCOL_SPC_CHROMA_DERIVED_CL =
+      13,                ///< Chromaticity-derived constant luminance system
+  AVCOL_SPC_ICTCP = 14,  ///< ITU-R BT.2100-0, ICtCp
+  AVCOL_SPC_NB           ///< Not part of ABI
+};
+
+/**
+ * Visual content value range.
+ *
+ * These values are based on definitions that can be found in multiple
+ * specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance
+ * and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital
+ * Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit
+ * integer representation). At the time of writing, the BT.2100 one is
+ * recommended, as it also defines the full range representation.
+ *
+ * Common definitions:
+ *   - For RGB and luma planes such as Y in YCbCr and I in ICtCp,
+ *     'E' is the original value in range of 0.0 to 1.0.
+ *   - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original
+ *     value in range of -0.5 to 0.5.
+ *   - 'n' is the output bit depth.
+ *   - For additional definitions such as rounding and clipping to valid n
+ *     bit unsigned integer range, please refer to BT.2100 (Table 9).
+ */
+enum AVColorRange {
+  AVCOL_RANGE_UNSPECIFIED = 0,
+
+  /**
+   * Narrow or limited range content.
+   *
+   * - For luma planes:
+   *
+   *       (219 * E + 16) * 2^(n-8)
+   *
+   *   F.ex. the range of 16-235 for 8 bits
+   *
+   * - For chroma planes:
+   *
+   *       (224 * E + 128) * 2^(n-8)
+   *
+   *   F.ex. the range of 16-240 for 8 bits
+   */
+  AVCOL_RANGE_MPEG = 1,
+
+  /**
+   * Full range content.
+   *
+   * - For RGB and luma planes:
+   *
+   *       (2^n - 1) * E
+   *
+   *   F.ex. the range of 0-255 for 8 bits
+   *
+   * - For chroma planes:
+   *
+   *       (2^n - 1) * E + 2^(n - 1)
+   *
+   *   F.ex. the range of 1-255 for 8 bits
+   */
+  AVCOL_RANGE_JPEG = 2,
+  AVCOL_RANGE_NB  ///< Not part of ABI
+};
+
+/**
+ * Location of chroma samples.
+ *
+ * Illustration showing the location of the first (top left) chroma sample of
+ *the image, the left shows only luma, the right shows the location of the
+ *chroma sample, the 2 could be imagined to overlay each other but are drawn
+ *separately due to limitations of ASCII
+ *
+ *                1st 2nd       1st 2nd horizontal luma sample positions
+ *                 v   v         v   v
+ *                 ______        ______
+ *1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
+ *                |             |1 2           1-6 are possible chroma positions
+ *2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
+ */
+enum AVChromaLocation {
+  AVCHROMA_LOC_UNSPECIFIED = 0,
+  AVCHROMA_LOC_LEFT = 1,    ///< MPEG-2/4 4:2:0, H.264 default for 4:2:0
+  AVCHROMA_LOC_CENTER = 2,  ///< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0
+  AVCHROMA_LOC_TOPLEFT =
+      3,  ///< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2
+  AVCHROMA_LOC_TOP = 4,
+  AVCHROMA_LOC_BOTTOMLEFT = 5,
+  AVCHROMA_LOC_BOTTOM = 6,
+  AVCHROMA_LOC_NB  ///< Not part of ABI
+};
+
+#endif /* AVUTIL_PIXFMT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/rational.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/rational.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/rational.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/rational.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,222 @@
+/*
+ * rational numbers
+ * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @ingroup lavu_math_rational
+ * Utilties for rational number calculation.
+ * @author Michael Niedermayer <michaelni@gmx.at>
+ */
+
+#ifndef AVUTIL_RATIONAL_H
+#define AVUTIL_RATIONAL_H
+
+#include <stdint.h>
+#include <limits.h>
+#include "attributes.h"
+
+/**
+ * @defgroup lavu_math_rational AVRational
+ * @ingroup lavu_math
+ * Rational number calculation.
+ *
+ * While rational numbers can be expressed as floating-point numbers, the
+ * conversion process is a lossy one, so are floating-point operations. On the
+ * other hand, the nature of FFmpeg demands highly accurate calculation of
+ * timestamps. This set of rational number utilities serves as a generic
+ * interface for manipulating rational numbers as pairs of numerators and
+ * denominators.
+ *
+ * Many of the functions that operate on AVRational's have the suffix `_q`, in
+ * reference to the mathematical symbol "ℚ" (Q) which denotes the set of all
+ * rational numbers.
+ *
+ * @{
+ */
+
+/**
+ * Rational number (pair of numerator and denominator).
+ */
+typedef struct AVRational {
+  int num;  ///< Numerator
+  int den;  ///< Denominator
+} AVRational;
+
+/**
+ * Create an AVRational.
+ *
+ * Useful for compilers that do not support compound literals.
+ *
+ * @note The return value is not reduced.
+ * @see av_reduce()
+ */
+static inline AVRational av_make_q(int num, int den) {
+  AVRational r = {num, den};
+  return r;
+}
+
+/**
+ * Compare two rationals.
+ *
+ * @param a First rational
+ * @param b Second rational
+ *
+ * @return One of the following values:
+ *         - 0 if `a == b`
+ *         - 1 if `a > b`
+ *         - -1 if `a < b`
+ *         - `INT_MIN` if one of the values is of the form `0 / 0`
+ */
+static inline int av_cmp_q(AVRational a, AVRational b) {
+  const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
+
+  if (tmp)
+    return (int)((tmp ^ a.den ^ b.den) >> 63) | 1;
+  else if (b.den && a.den)
+    return 0;
+  else if (a.num && b.num)
+    return (a.num >> 31) - (b.num >> 31);
+  else
+    return INT_MIN;
+}
+
+/**
+ * Convert an AVRational to a `double`.
+ * @param a AVRational to convert
+ * @return `a` in floating-point form
+ * @see av_d2q()
+ */
+static inline double av_q2d(AVRational a) { return a.num / (double)a.den; }
+
+/**
+ * Reduce a fraction.
+ *
+ * This is useful for framerate calculations.
+ *
+ * @param[out] dst_num Destination numerator
+ * @param[out] dst_den Destination denominator
+ * @param[in]      num Source numerator
+ * @param[in]      den Source denominator
+ * @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
+ * @return 1 if the operation is exact, 0 otherwise
+ */
+int av_reduce(int* dst_num, int* dst_den, int64_t num, int64_t den,
+              int64_t max);
+
+/**
+ * Multiply two rationals.
+ * @param b First rational
+ * @param c Second rational
+ * @return b*c
+ */
+AVRational av_mul_q(AVRational b, AVRational c) av_const;
+
+/**
+ * Divide one rational by another.
+ * @param b First rational
+ * @param c Second rational
+ * @return b/c
+ */
+AVRational av_div_q(AVRational b, AVRational c) av_const;
+
+/**
+ * Add two rationals.
+ * @param b First rational
+ * @param c Second rational
+ * @return b+c
+ */
+AVRational av_add_q(AVRational b, AVRational c) av_const;
+
+/**
+ * Subtract one rational from another.
+ * @param b First rational
+ * @param c Second rational
+ * @return b-c
+ */
+AVRational av_sub_q(AVRational b, AVRational c) av_const;
+
+/**
+ * Invert a rational.
+ * @param q value
+ * @return 1 / q
+ */
+static av_always_inline AVRational av_inv_q(AVRational q) {
+  AVRational r = {q.den, q.num};
+  return r;
+}
+
+/**
+ * Convert a double precision floating point number to a rational.
+ *
+ * In case of infinity, the returned value is expressed as `{1, 0}` or
+ * `{-1, 0}` depending on the sign.
+ *
+ * @param d   `double` to convert
+ * @param max Maximum allowed numerator and denominator
+ * @return `d` in AVRational form
+ * @see av_q2d()
+ */
+AVRational av_d2q(double d, int max) av_const;
+
+/**
+ * Find which of the two rationals is closer to another rational.
+ *
+ * @param q     Rational to be compared against
+ * @param q1    Rational to be tested
+ * @param q2    Rational to be tested
+ * @return One of the following values:
+ *         - 1 if `q1` is nearer to `q` than `q2`
+ *         - -1 if `q2` is nearer to `q` than `q1`
+ *         - 0 if they have the same distance
+ */
+int av_nearer_q(AVRational q, AVRational q1, AVRational q2);
+
+/**
+ * Find the value in a list of rationals nearest a given reference rational.
+ *
+ * @param q      Reference rational
+ * @param q_list Array of rationals terminated by `{0, 0}`
+ * @return Index of the nearest value found in the array
+ */
+int av_find_nearest_q_idx(AVRational q, const AVRational* q_list);
+
+/**
+ * Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point
+ * format.
+ *
+ * @param q Rational to be converted
+ * @return Equivalent floating-point value, expressed as an unsigned 32-bit
+ *         integer.
+ * @note The returned value is platform-indepedant.
+ */
+uint32_t av_q2intfloat(AVRational q);
+
+/**
+ * Return the best rational so that a and b are multiple of it.
+ * If the resulting denominator is larger than max_den, return def.
+ */
+AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_RATIONAL_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/samplefmt.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/samplefmt.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/samplefmt.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/samplefmt.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,274 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_SAMPLEFMT_H
+#define AVUTIL_SAMPLEFMT_H
+
+#include <stdint.h>
+
+/**
+ * @addtogroup lavu_audio
+ * @{
+ *
+ * @defgroup lavu_sampfmts Audio sample formats
+ *
+ * Audio sample format enumeration and related convenience functions.
+ * @{
+ */
+
+/**
+ * Audio sample formats
+ *
+ * - The data described by the sample format is always in native-endian order.
+ *   Sample values can be expressed by native C types, hence the lack of a
+ * signed 24-bit sample format even though it is a common raw audio data format.
+ *
+ * - The floating-point formats are based on full volume being in the range
+ *   [-1.0, 1.0]. Any values outside this range are beyond full volume level.
+ *
+ * - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg
+ *   (such as AVFrame in libavcodec) is as follows:
+ *
+ * @par
+ * For planar sample formats, each audio channel is in a separate data plane,
+ * and linesize is the buffer size, in bytes, for a single plane. All data
+ * planes must be the same size. For packed sample formats, only the first data
+ * plane is used, and samples for each channel are interleaved. In this case,
+ * linesize is the buffer size, in bytes, for the 1 plane.
+ *
+ */
+enum AVSampleFormat {
+  AV_SAMPLE_FMT_NONE = -1,
+  AV_SAMPLE_FMT_U8,   ///< unsigned 8 bits
+  AV_SAMPLE_FMT_S16,  ///< signed 16 bits
+  AV_SAMPLE_FMT_S32,  ///< signed 32 bits
+  AV_SAMPLE_FMT_FLT,  ///< float
+  AV_SAMPLE_FMT_DBL,  ///< double
+
+  AV_SAMPLE_FMT_U8P,   ///< unsigned 8 bits, planar
+  AV_SAMPLE_FMT_S16P,  ///< signed 16 bits, planar
+  AV_SAMPLE_FMT_S32P,  ///< signed 32 bits, planar
+  AV_SAMPLE_FMT_FLTP,  ///< float, planar
+  AV_SAMPLE_FMT_DBLP,  ///< double, planar
+  AV_SAMPLE_FMT_S64,   ///< signed 64 bits
+  AV_SAMPLE_FMT_S64P,  ///< signed 64 bits, planar
+
+  AV_SAMPLE_FMT_NB  ///< Number of sample formats. DO NOT USE if linking
+                    ///< dynamically
+};
+
+/**
+ * Return the name of sample_fmt, or NULL if sample_fmt is not
+ * recognized.
+ */
+const char* av_get_sample_fmt_name(enum AVSampleFormat sample_fmt);
+
+/**
+ * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
+ * on error.
+ */
+enum AVSampleFormat av_get_sample_fmt(const char* name);
+
+/**
+ * Return the planar<->packed alternative form of the given sample format, or
+ * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
+ * requested planar/packed format, the format returned is the same as the
+ * input.
+ */
+enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt,
+                                          int planar);
+
+/**
+ * Get the packed alternative form of the given sample format.
+ *
+ * If the passed sample_fmt is already in packed format, the format returned is
+ * the same as the input.
+ *
+ * @return  the packed alternative form of the given sample format or
+            AV_SAMPLE_FMT_NONE on error.
+ */
+enum AVSampleFormat av_get_packed_sample_fmt(enum AVSampleFormat sample_fmt);
+
+/**
+ * Get the planar alternative form of the given sample format.
+ *
+ * If the passed sample_fmt is already in planar format, the format returned is
+ * the same as the input.
+ *
+ * @return  the planar alternative form of the given sample format or
+            AV_SAMPLE_FMT_NONE on error.
+ */
+enum AVSampleFormat av_get_planar_sample_fmt(enum AVSampleFormat sample_fmt);
+
+/**
+ * Generate a string corresponding to the sample format with
+ * sample_fmt, or a header if sample_fmt is negative.
+ *
+ * @param buf the buffer where to write the string
+ * @param buf_size the size of buf
+ * @param sample_fmt the number of the sample format to print the
+ * corresponding info string, or a negative value to print the
+ * corresponding header.
+ * @return the pointer to the filled buffer or NULL if sample_fmt is
+ * unknown or in case of other errors
+ */
+char* av_get_sample_fmt_string(char* buf, int buf_size,
+                               enum AVSampleFormat sample_fmt);
+
+/**
+ * Return number of bytes per sample.
+ *
+ * @param sample_fmt the sample format
+ * @return number of bytes per sample or zero if unknown for the given
+ * sample format
+ */
+int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt);
+
+/**
+ * Check if the sample format is planar.
+ *
+ * @param sample_fmt the sample format to inspect
+ * @return 1 if the sample format is planar, 0 if it is interleaved
+ */
+int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt);
+
+/**
+ * Get the required buffer size for the given audio parameters.
+ *
+ * @param[out] linesize calculated linesize, may be NULL
+ * @param nb_channels   the number of channels
+ * @param nb_samples    the number of samples in a single channel
+ * @param sample_fmt    the sample format
+ * @param align         buffer size alignment (0 = default, 1 = no alignment)
+ * @return              required buffer size, or negative error code on failure
+ */
+int av_samples_get_buffer_size(int* linesize, int nb_channels, int nb_samples,
+                               enum AVSampleFormat sample_fmt, int align);
+
+/**
+ * @}
+ *
+ * @defgroup lavu_sampmanip Samples manipulation
+ *
+ * Functions that manipulate audio samples
+ * @{
+ */
+
+/**
+ * Fill plane data pointers and linesize for samples with sample
+ * format sample_fmt.
+ *
+ * The audio_data array is filled with the pointers to the samples data planes:
+ * for planar, set the start point of each channel's data within the buffer,
+ * for packed, set the start point of the entire buffer only.
+ *
+ * The value pointed to by linesize is set to the aligned size of each
+ * channel's data buffer for planar layout, or to the aligned size of the
+ * buffer for all channels for packed layout.
+ *
+ * The buffer in buf must be big enough to contain all the samples
+ * (use av_samples_get_buffer_size() to compute its minimum size),
+ * otherwise the audio_data pointers will point to invalid data.
+ *
+ * @see enum AVSampleFormat
+ * The documentation for AVSampleFormat describes the data layout.
+ *
+ * @param[out] audio_data  array to be filled with the pointer for each channel
+ * @param[out] linesize    calculated linesize, may be NULL
+ * @param buf              the pointer to a buffer containing the samples
+ * @param nb_channels      the number of channels
+ * @param nb_samples       the number of samples in a single channel
+ * @param sample_fmt       the sample format
+ * @param align            buffer size alignment (0 = default, 1 = no alignment)
+ * @return                 minimum size in bytes required for the buffer on
+ * success, or a negative error code on failure
+ */
+int av_samples_fill_arrays(uint8_t** audio_data, int* linesize,
+                           const uint8_t* buf, int nb_channels, int nb_samples,
+                           enum AVSampleFormat sample_fmt, int align);
+
+/**
+ * Allocate a samples buffer for nb_samples samples, and fill data pointers and
+ * linesize accordingly.
+ * The allocated samples buffer can be freed by using av_freep(&audio_data[0])
+ * Allocated data will be initialized to silence.
+ *
+ * @see enum AVSampleFormat
+ * The documentation for AVSampleFormat describes the data layout.
+ *
+ * @param[out] audio_data  array to be filled with the pointer for each channel
+ * @param[out] linesize    aligned size for audio buffer(s), may be NULL
+ * @param nb_channels      number of audio channels
+ * @param nb_samples       number of samples per channel
+ * @param sample_fmt       the sample format
+ * @param align            buffer size alignment (0 = default, 1 = no alignment)
+ * @return                 >=0 on success or a negative error code on failure
+ * @todo return the size of the allocated buffer in case of success at the next
+ * bump
+ * @see av_samples_fill_arrays()
+ * @see av_samples_alloc_array_and_samples()
+ */
+int av_samples_alloc(uint8_t** audio_data, int* linesize, int nb_channels,
+                     int nb_samples, enum AVSampleFormat sample_fmt, int align);
+
+/**
+ * Allocate a data pointers array, samples buffer for nb_samples
+ * samples, and fill data pointers and linesize accordingly.
+ *
+ * This is the same as av_samples_alloc(), but also allocates the data
+ * pointers array.
+ *
+ * @see av_samples_alloc()
+ */
+int av_samples_alloc_array_and_samples(uint8_t*** audio_data, int* linesize,
+                                       int nb_channels, int nb_samples,
+                                       enum AVSampleFormat sample_fmt,
+                                       int align);
+
+/**
+ * Copy samples from src to dst.
+ *
+ * @param dst destination array of pointers to data planes
+ * @param src source array of pointers to data planes
+ * @param dst_offset offset in samples at which the data will be written to dst
+ * @param src_offset offset in samples at which the data will be read from src
+ * @param nb_samples number of samples to be copied
+ * @param nb_channels number of audio channels
+ * @param sample_fmt audio sample format
+ */
+int av_samples_copy(uint8_t** dst, uint8_t* const* src, int dst_offset,
+                    int src_offset, int nb_samples, int nb_channels,
+                    enum AVSampleFormat sample_fmt);
+
+/**
+ * Fill an audio buffer with silence.
+ *
+ * @param audio_data  array of pointers to data planes
+ * @param offset      offset in samples at which to start filling
+ * @param nb_samples  number of samples to fill
+ * @param nb_channels number of audio channels
+ * @param sample_fmt  audio sample format
+ */
+int av_samples_set_silence(uint8_t** audio_data, int offset, int nb_samples,
+                           int nb_channels, enum AVSampleFormat sample_fmt);
+
+/**
+ * @}
+ * @}
+ */
+#endif /* AVUTIL_SAMPLEFMT_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/version.h b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/version.h
--- a/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/version.h	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/include/libavutil/version.h	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,122 @@
+/*
+ * copyright (c) 2003 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * @ingroup lavu
+ * Libavutil version macros
+ */
+
+#ifndef AVUTIL_VERSION_H
+#define AVUTIL_VERSION_H
+
+#include "macros.h"
+
+/**
+ * @addtogroup version_utils
+ *
+ * Useful to check and match library version in order to maintain
+ * backward compatibility.
+ *
+ * The FFmpeg libraries follow a versioning sheme very similar to
+ * Semantic Versioning (http://semver.org/)
+ * The difference is that the component called PATCH is called MICRO in FFmpeg
+ * and its value is reset to 100 instead of 0 to keep it above or equal to 100.
+ * Also we do not increase MICRO for every bugfix or change in git master.
+ *
+ * Prior to FFmpeg 3.2 point releases did not change any lib version number to
+ * avoid aliassing different git master checkouts.
+ * Starting with FFmpeg 3.2, the released library versions will occupy
+ * a separate MAJOR.MINOR that is not used on the master development branch.
+ * That is if we branch a release of master 55.10.123 we will bump to 55.11.100
+ * for the release and master will continue at 55.12.100 after it. Each new
+ * point release will then bump the MICRO improving the usefulness of the lib
+ * versions.
+ *
+ * @{
+ */
+
+#define AV_VERSION_INT(a, b, c) ((a) << 16 | (b) << 8 | (c))
+#define AV_VERSION_DOT(a, b, c) a##.##b##.##c
+#define AV_VERSION(a, b, c) AV_VERSION_DOT(a, b, c)
+
+/**
+ * Extract version components from the full ::AV_VERSION_INT int as returned
+ * by functions like ::avformat_version() and ::avcodec_version()
+ */
+#define AV_VERSION_MAJOR(a) ((a) >> 16)
+#define AV_VERSION_MINOR(a) (((a)&0x00FF00) >> 8)
+#define AV_VERSION_MICRO(a) ((a)&0xFF)
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lavu_ver Version and Build diagnostics
+ *
+ * Macros and function useful to check at compiletime and at runtime
+ * which version of libavutil is in use.
+ *
+ * @{
+ */
+
+#define LIBAVUTIL_VERSION_MAJOR 58
+#define LIBAVUTIL_VERSION_MINOR 3
+#define LIBAVUTIL_VERSION_MICRO 100
+
+#define LIBAVUTIL_VERSION_INT                                      \
+  AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, \
+                 LIBAVUTIL_VERSION_MICRO)
+#define LIBAVUTIL_VERSION                                      \
+  AV_VERSION(LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, \
+             LIBAVUTIL_VERSION_MICRO)
+#define LIBAVUTIL_BUILD LIBAVUTIL_VERSION_INT
+
+#define LIBAVUTIL_IDENT "Lavu" AV_STRINGIFY(LIBAVUTIL_VERSION)
+
+/**
+ * @defgroup lavu_depr_guards Deprecation Guards
+ * FF_API_* defines may be placed below to indicate public API that will be
+ * dropped at a future version bump. The defines themselves are not part of
+ * the public API and may change, break or disappear at any time.
+ *
+ * @note, when bumping the major version it is recommended to manually
+ * disable each FF_API_* in its own commit instead of disabling them all
+ * at once through the bump. This improves the git bisect-ability of the change.
+ *
+ * @{
+ */
+
+#define FF_API_FIFO_PEEK2 (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_FIFO_OLD_API (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_XVMC (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_OLD_CHANNEL_LAYOUT (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_AV_FOPEN_UTF8 (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_PKT_DURATION (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_REORDERED_OPAQUE (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_FRAME_PICTURE_NUMBER (LIBAVUTIL_VERSION_MAJOR < 59)
+
+/**
+ * @}
+ * @}
+ */
+
+#endif /* AVUTIL_VERSION_H */
diff -Naur a/dom/media/platforms/ffmpeg/ffmpeg60/moz.build b/dom/media/platforms/ffmpeg/ffmpeg60/moz.build
--- a/dom/media/platforms/ffmpeg/ffmpeg60/moz.build	1970-01-01 01:00:00.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffmpeg60/moz.build	2023-04-06 12:57:00.772081680 +0200
@@ -0,0 +1,39 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+UNIFIED_SOURCES += [
+    "../FFmpegAudioDecoder.cpp",
+    "../FFmpegDataDecoder.cpp",
+    "../FFmpegDecoderModule.cpp",
+    "../FFmpegVideoDecoder.cpp",
+]
+LOCAL_INCLUDES += [
+    "..",
+    "/media/mozva",
+    "include",
+]
+
+if CONFIG["CC_TYPE"] in ("clang", "gcc"):
+    CXXFLAGS += ["-Wno-deprecated-declarations"]
+if CONFIG["CC_TYPE"] == "clang":
+    CXXFLAGS += [
+        "-Wno-unknown-attributes",
+    ]
+if CONFIG["CC_TYPE"] == "gcc":
+    CXXFLAGS += [
+        "-Wno-attributes",
+    ]
+if CONFIG["MOZ_WAYLAND"]:
+    CXXFLAGS += CONFIG["MOZ_GTK3_CFLAGS"]
+    DEFINES["MOZ_WAYLAND_USE_VAAPI"] = 1
+    USE_LIBS += ["mozva"]
+    UNIFIED_SOURCES += [
+        "../FFmpegVideoFramePool.cpp",
+    ]
+
+include("/ipc/chromium/chromium-config.mozbuild")
+
+FINAL_LIBRARY = "xul"
diff -Naur a/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp	2023-03-10 00:59:36.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp	2023-04-06 12:49:55.231998224 +0200
@@ -269,35 +269,35 @@
     }
 #else
 #  define AVRESULT_OK 0
-
-    int ret = mLib->avcodec_receive_frame(mCodecContext, mFrame);
+    int ret = mLib->avcodec_send_packet(mCodecContext, &packet);
     switch (ret) {
       case AVRESULT_OK:
-        decoded = true;
+        bytesConsumed = packet.size;
         break;
       case AVERROR(EAGAIN):
         break;
-      case AVERROR_EOF: {
+      case AVERROR_EOF:
         FFMPEG_LOG("  End of stream.");
         return MediaResult(NS_ERROR_DOM_MEDIA_END_OF_STREAM,
                            RESULT_DETAIL("End of stream"));
-      }
+      default:
+        NS_WARNING("FFmpeg audio decoder error.");
+        return MediaResult(NS_ERROR_DOM_MEDIA_DECODE_ERR,
+                           RESULT_DETAIL("FFmpeg audio error"));
     }
-    ret = mLib->avcodec_send_packet(mCodecContext, &packet);
+
+    ret = mLib->avcodec_receive_frame(mCodecContext, mFrame);
     switch (ret) {
       case AVRESULT_OK:
-        bytesConsumed = packet.size;
+        decoded = true;
         break;
       case AVERROR(EAGAIN):
         break;
-      case AVERROR_EOF:
+      case AVERROR_EOF: {
         FFMPEG_LOG("  End of stream.");
         return MediaResult(NS_ERROR_DOM_MEDIA_END_OF_STREAM,
                            RESULT_DETAIL("End of stream"));
-      default:
-        NS_WARNING("FFmpeg audio decoder error.");
-        return MediaResult(NS_ERROR_DOM_MEDIA_DECODE_ERR,
-                           RESULT_DETAIL("FFmpeg audio error"));
+      }
     }
 #endif
 
diff -Naur a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp	2023-03-10 00:59:36.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/FFmpegLibWrapper.cpp	2023-04-06 12:57:00.770081600 +0200
@@ -65,6 +65,7 @@
     AV_FUNC_57 = 1 << 4,
     AV_FUNC_58 = 1 << 5,
     AV_FUNC_59 = 1 << 6,
+    AV_FUNC_60 = 1 << 7,
     AV_FUNC_AVUTIL_53 = AV_FUNC_53 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_54 = AV_FUNC_54 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_55 = AV_FUNC_55 | AV_FUNC_AVUTIL_MASK,
@@ -72,8 +73,9 @@
     AV_FUNC_AVUTIL_57 = AV_FUNC_57 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_58 = AV_FUNC_58 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVUTIL_59 = AV_FUNC_59 | AV_FUNC_AVUTIL_MASK,
+    AV_FUNC_AVUTIL_60 = AV_FUNC_60 | AV_FUNC_AVUTIL_MASK,
     AV_FUNC_AVCODEC_ALL = AV_FUNC_53 | AV_FUNC_54 | AV_FUNC_55 | AV_FUNC_56 |
-                          AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59,
+                          AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60,
     AV_FUNC_AVUTIL_ALL = AV_FUNC_AVCODEC_ALL | AV_FUNC_AVUTIL_MASK
   };
 
@@ -99,8 +101,11 @@
     case 59:
       version = AV_FUNC_59;
       break;
+    case 60:
+      version = AV_FUNC_60;
+      break;
     default:
-      FFMPEG_LOG("Unknown avcodec version");
+      FFMPEG_LOG("Unknown avcodec version: %d", macro);
       Unlink();
       return isFFMpeg ? ((macro > 57) ? LinkResult::UnknownFutureFFMpegVersion
                                       : LinkResult::UnknownOlderFFMpegVersion)
@@ -154,10 +159,10 @@
   AV_FUNC(avcodec_alloc_frame, (AV_FUNC_53 | AV_FUNC_54))
   AV_FUNC(avcodec_get_frame_defaults, (AV_FUNC_53 | AV_FUNC_54))
   AV_FUNC(avcodec_free_frame, AV_FUNC_54)
-  AV_FUNC(avcodec_send_packet, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC(avcodec_receive_frame, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC(avcodec_default_get_buffer2,
-          (AV_FUNC_55 | AV_FUNC_56 | AV_FUNC_57 | AV_FUNC_58 | AV_FUNC_59))
+  AV_FUNC(avcodec_send_packet, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC(avcodec_receive_frame, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC(avcodec_default_get_buffer2, (AV_FUNC_55 | AV_FUNC_56 | AV_FUNC_57 |
+                                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60))
   AV_FUNC_OPTION(av_rdft_init, AV_FUNC_AVCODEC_ALL)
   AV_FUNC_OPTION(av_rdft_calc, AV_FUNC_AVCODEC_ALL)
   AV_FUNC_OPTION(av_rdft_end, AV_FUNC_AVCODEC_ALL)
@@ -166,49 +171,62 @@
   AV_FUNC(av_freep, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_frame_alloc,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
   AV_FUNC(av_frame_free,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
   AV_FUNC(av_frame_unref,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
   AV_FUNC(av_image_check_size, AV_FUNC_AVUTIL_ALL)
   AV_FUNC(av_image_get_buffer_size, AV_FUNC_AVUTIL_ALL)
-  AV_FUNC_OPTION(av_buffer_get_opaque, (AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-                                        AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59))
+  AV_FUNC_OPTION(av_buffer_get_opaque,
+                 (AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 | AV_FUNC_AVUTIL_58 |
+                  AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
   AV_FUNC(av_buffer_create,
           (AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
-           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59))
+           AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60))
   AV_FUNC_OPTION(av_frame_get_colorspace,
                  AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
                      AV_FUNC_AVUTIL_58)
   AV_FUNC_OPTION(av_frame_get_color_range,
                  AV_FUNC_AVUTIL_55 | AV_FUNC_AVUTIL_56 | AV_FUNC_AVUTIL_57 |
                      AV_FUNC_AVUTIL_58)
-  AV_FUNC(av_strerror, AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59)
+  AV_FUNC(av_strerror,
+          AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59 | AV_FUNC_AVUTIL_60)
 
 #ifdef MOZ_WAYLAND
-  AV_FUNC_OPTION_SILENT(avcodec_get_hw_config, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_codec_iterate, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_codec_is_decoder, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_init, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_alloc, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_hwdevice_hwconfig_alloc, AV_FUNC_58 | AV_FUNC_59)
+  AV_FUNC_OPTION_SILENT(avcodec_get_hw_config,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_codec_iterate, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_codec_is_decoder,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_init,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_alloc,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_hwdevice_hwconfig_alloc,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
   AV_FUNC_OPTION_SILENT(av_hwdevice_get_hwframe_constraints,
-                        AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_hwframe_constraints_free, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_buffer_ref, AV_FUNC_AVUTIL_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_buffer_unref, AV_FUNC_AVUTIL_58 | AV_FUNC_59)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_hwframe_constraints_free,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_buffer_ref,
+                        AV_FUNC_AVUTIL_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_buffer_unref,
+                        AV_FUNC_AVUTIL_58 | AV_FUNC_59 | AV_FUNC_60)
   AV_FUNC_OPTION_SILENT(av_hwframe_transfer_get_formats,
-                        AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_create_derived, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_hwframe_ctx_alloc, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_dict_set, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_dict_free, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(avcodec_get_name, AV_FUNC_58 | AV_FUNC_59)
-  AV_FUNC_OPTION_SILENT(av_get_pix_fmt_string,
-                        AV_FUNC_AVUTIL_58 | AV_FUNC_AVUTIL_59)
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_hwdevice_ctx_create_derived,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_hwframe_ctx_alloc,
+                        AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_dict_set, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_dict_free, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(avcodec_get_name, AV_FUNC_58 | AV_FUNC_59 | AV_FUNC_60)
+  AV_FUNC_OPTION_SILENT(av_get_pix_fmt_string, AV_FUNC_AVUTIL_58 |
+                                                   AV_FUNC_AVUTIL_59 |
+                                                   AV_FUNC_AVUTIL_60)
 #endif
 #undef AV_FUNC
 #undef AV_FUNC_OPTION
diff -Naur a/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp b/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp	2023-03-10 00:59:36.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/FFmpegRuntimeLinker.cpp	2023-04-06 12:57:00.770081600 +0200
@@ -27,6 +27,7 @@
 static const char* sLibs[] = {
 // clang-format off
 #if defined(XP_DARWIN)
+  "libavcodec.60.dylib",
   "libavcodec.59.dylib",
   "libavcodec.58.dylib",
   "libavcodec.57.dylib",
@@ -38,6 +39,7 @@
   "libavcodec.so", // OpenBSD hardly controls the major/minor library version
                    // of ffmpeg and update it regulary on ABI/API changes
 #else
+  "libavcodec.so.60",
   "libavcodec.so.59",
   "libavcodec.so.58",
   "libavcodec-ffmpeg.so.58",
@@ -160,6 +162,9 @@
     case 59:
       module = FFmpegDecoderModule<59>::Create(&sLibAV);
       break;
+    case 60:
+      module = FFmpegDecoderModule<60>::Create(&sLibAV);
+      break;
     default:
       module = nullptr;
   }
diff -Naur a/dom/media/platforms/ffmpeg/ffvpx/moz.build b/dom/media/platforms/ffmpeg/ffvpx/moz.build
--- a/dom/media/platforms/ffmpeg/ffvpx/moz.build	2023-03-10 00:59:36.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/ffvpx/moz.build	2023-04-06 12:59:24.031810491 +0200
@@ -20,7 +20,7 @@
 ]
 LOCAL_INCLUDES += [
     "..",
-    "../ffmpeg58/include",
+    "../ffmpeg60/include",
     "/media/mozva",
 ]
 
diff -Naur a/dom/media/platforms/ffmpeg/moz.build b/dom/media/platforms/ffmpeg/moz.build
--- a/dom/media/platforms/ffmpeg/moz.build	2023-03-10 00:59:36.000000000 +0100
+++ b/dom/media/platforms/ffmpeg/moz.build	2023-04-06 12:57:00.773081719 +0200
@@ -15,6 +15,7 @@
     "ffmpeg57",
     "ffmpeg58",
     "ffmpeg59",
+    "ffmpeg60",
 ]
 
 UNIFIED_SOURCES += [
diff -Naur a/media/ffvpx/changes.patch b/media/ffvpx/changes.patch
--- a/media/ffvpx/changes.patch	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/changes.patch	2023-04-06 12:50:15.513815093 +0200
@@ -11,10 +11,6 @@
  #include "avstring.h"
  #include "timer.h"
  
-diff --git a/media/ffvpx/libavutil/time.h b/media/ffvpx/libavutil/fftime.h
-similarity index 100%
-rename from media/ffvpx/libavutil/time.h
-rename to media/ffvpx/libavutil/fftime.h
 diff --git a/media/ffvpx/libavutil/time.c b/media/ffvpx/libavutil/time.c
 index dbaee02..69419e6 100644
 --- a/media/ffvpx/libavutil/time.c
@@ -73,10 +69,8 @@
  
  
  typedef struct VAAPIDevicePriv {
-
-diff -up media/ffvpx/libavcodec/vaapi_decode.c.old media/ffvpx/libavcodec/vaapi_decode.c
-diff -up media/ffvpx/libavutil/fftime.h.old media/ffvpx/libavutil/fftime.h
---- media/ffvpx/libavutil/fftime.h.old	2021-12-06 14:51:40.378642713 +0100
+diff -up media/ffvpx/libavutil/fftime.h media/ffvpx/libavutil/fftime.h
+--- media/ffvpx/libavutil/fftime.h	2021-12-06 14:51:40.378642713 +0100
 +++ media/ffvpx/libavutil/fftime.h	2021-12-06 14:51:54.618098212 +0100
 @@ -22,6 +22,7 @@
  #define AVUTIL_TIME_H
@@ -86,3 +80,26 @@
  
  /**
   * Get the current time in microseconds.
+  *
+diff --git a/media/ffvpx/compat/w32pthreads.h b/media/ffvpx/compat/w32pthreads.h
+--- a/media/ffvpx/compat/w32pthreads.h
++++ b/media/ffvpx/compat/w32pthreads.h
+@@ -39,17 +39,17 @@
+ #include <windows.h>
+ #include <process.h>
+ #include <time.h>
+ 
+ #include "libavutil/attributes.h"
+ #include "libavutil/common.h"
+ #include "libavutil/internal.h"
+ #include "libavutil/mem.h"
+-#include "libavutil/time.h"
++#include "libavutil/fftime.h"
+ 
+ typedef struct pthread_t {
+     void *handle;
+     void *(*func)(void* arg);
+     void *arg;
+     void *ret;
+ } pthread_t;
+ 
diff -Naur a/media/ffvpx/compat/atomics/win32/stdatomic.h b/media/ffvpx/compat/atomics/win32/stdatomic.h
--- a/media/ffvpx/compat/atomics/win32/stdatomic.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/compat/atomics/win32/stdatomic.h	2023-04-06 12:49:40.248394688 +0200
@@ -96,7 +96,7 @@
     atomic_load(object)
 
 #define atomic_exchange(object, desired) \
-    InterlockedExchangePointer(object, desired);
+    InterlockedExchangePointer((PVOID volatile *)object, (PVOID)desired)
 
 #define atomic_exchange_explicit(object, desired, order) \
     atomic_exchange(object, desired)
diff -Naur a/media/ffvpx/compat/w32pthreads.h b/media/ffvpx/compat/w32pthreads.h
--- a/media/ffvpx/compat/w32pthreads.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/compat/w32pthreads.h	2023-04-06 12:50:20.234005184 +0200
@@ -38,11 +38,13 @@
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #include <process.h>
+#include <time.h>
 
 #include "libavutil/attributes.h"
 #include "libavutil/common.h"
 #include "libavutil/internal.h"
 #include "libavutil/mem.h"
+#include "libavutil/fftime.h"
 
 typedef struct pthread_t {
     void *handle;
@@ -61,6 +63,9 @@
 #define InitializeCriticalSection(x) InitializeCriticalSectionEx(x, 0, 0)
 #define WaitForSingleObject(a, b) WaitForSingleObjectEx(a, b, FALSE)
 
+#define PTHREAD_CANCEL_ENABLE 1
+#define PTHREAD_CANCEL_DISABLE 0
+
 static av_unused unsigned __stdcall attribute_align_arg win32thread_worker(void *arg)
 {
     pthread_t *h = (pthread_t*)arg;
@@ -156,10 +161,31 @@
     return 0;
 }
 
+static inline int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
+                                         const struct timespec *abstime)
+{
+    int64_t abs_milli = abstime->tv_sec * 1000LL + abstime->tv_nsec / 1000000;
+    DWORD t = av_clip64(abs_milli - av_gettime() / 1000, 0, UINT32_MAX);
+
+    if (!SleepConditionVariableSRW(cond, mutex, t, 0)) {
+        DWORD err = GetLastError();
+        if (err == ERROR_TIMEOUT)
+            return ETIMEDOUT;
+        else
+            return EINVAL;
+    }
+    return 0;
+}
+
 static inline int pthread_cond_signal(pthread_cond_t *cond)
 {
     WakeConditionVariable(cond);
     return 0;
 }
 
+static inline int pthread_setcancelstate(int state, int *oldstate)
+{
+    return 0;
+}
+
 #endif /* COMPAT_W32PTHREADS_H */
diff -Naur a/media/ffvpx/config_aarch64_win64.h b/media/ffvpx/config_aarch64_win64.h
--- a/media/ffvpx/config_aarch64_win64.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_aarch64_win64.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,680 +0,0 @@
-/* Automatically generated by configure - do not modify! */
-#ifndef FFMPEG_CONFIG_H
-#define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-parser='vp8,vp9' --enable-decoder='vp8,vp9,mp3,flac' --disable-static --enable-shared --disable-autodetect --toolchain=msvc --enable-cross-compile --target-os=win32 --arch=arm64"
-#define FFMPEG_LICENSE "LGPL version 2.1 or later"
-#define CONFIG_THIS_YEAR 2019
-#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
-#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "Microsoft (R) C/C++ Optimizing Compiler Version 19.24.28315 for ARM64"
-#define av_restrict __restrict
-#define EXTERN_PREFIX ""
-#define EXTERN_ASM 
-#define BUILDSUF ""
-#define SLIBSUF ".dll"
-#define HAVE_MMX2 HAVE_MMXEXT
-#define SWS_MAX_FILTER_SIZE 256
-#define ARCH_AARCH64 1
-#define ARCH_ALPHA 0
-#define ARCH_ARM 0
-#define ARCH_AVR32 0
-#define ARCH_AVR32_AP 0
-#define ARCH_AVR32_UC 0
-#define ARCH_BFIN 0
-#define ARCH_IA64 0
-#define ARCH_M68K 0
-#define ARCH_MIPS 0
-#define ARCH_MIPS64 0
-#define ARCH_PARISC 0
-#define ARCH_PPC 0
-#define ARCH_PPC64 0
-#define ARCH_S390 0
-#define ARCH_SH4 0
-#define ARCH_SPARC 0
-#define ARCH_SPARC64 0
-#define ARCH_TILEGX 0
-#define ARCH_TILEPRO 0
-#define ARCH_TOMI 0
-#define ARCH_X86 0
-#define ARCH_X86_32 0
-#define ARCH_X86_64 0
-#define HAVE_ARMV5TE 0
-#define HAVE_ARMV6 0
-#define HAVE_ARMV6T2 0
-#define HAVE_ARMV8 1
-#define HAVE_NEON 1
-#define HAVE_VFP 1
-#define HAVE_VFPV3 0
-#define HAVE_SETEND 0
-#define HAVE_ALTIVEC 0
-#define HAVE_DCBZL 0
-#define HAVE_LDBRX 0
-#define HAVE_POWER8 0
-#define HAVE_PPC4XX 0
-#define HAVE_VSX 0
-#define HAVE_AESNI 0
-#define HAVE_AMD3DNOW 0
-#define HAVE_AMD3DNOWEXT 0
-#define HAVE_AVX 0
-#define HAVE_AVX2 0
-#define HAVE_AVX512 0
-#define HAVE_FMA3 0
-#define HAVE_FMA4 0
-#define HAVE_MMX 0
-#define HAVE_MMXEXT 0
-#define HAVE_SSE 0
-#define HAVE_SSE2 0
-#define HAVE_SSE3 0
-#define HAVE_SSE4 0
-#define HAVE_SSE42 0
-#define HAVE_SSSE3 0
-#define HAVE_XOP 0
-#define HAVE_CPUNOP 0
-#define HAVE_I686 0
-#define HAVE_MIPSFPU 0
-#define HAVE_MIPS32R2 0
-#define HAVE_MIPS32R5 0
-#define HAVE_MIPS64R2 0
-#define HAVE_MIPS32R6 0
-#define HAVE_MIPS64R6 0
-#define HAVE_MIPSDSP 0
-#define HAVE_MIPSDSPR2 0
-#define HAVE_MSA 0
-#define HAVE_MSA2 0
-#define HAVE_LOONGSON2 0
-#define HAVE_LOONGSON3 0
-#define HAVE_MMI 0
-#define HAVE_ARMV5TE_EXTERNAL 0
-#define HAVE_ARMV6_EXTERNAL 0
-#define HAVE_ARMV6T2_EXTERNAL 0
-#define HAVE_ARMV8_EXTERNAL 1
-#define HAVE_NEON_EXTERNAL 1
-#define HAVE_VFP_EXTERNAL 1
-#define HAVE_VFPV3_EXTERNAL 0
-#define HAVE_SETEND_EXTERNAL 0
-#define HAVE_ALTIVEC_EXTERNAL 0
-#define HAVE_DCBZL_EXTERNAL 0
-#define HAVE_LDBRX_EXTERNAL 0
-#define HAVE_POWER8_EXTERNAL 0
-#define HAVE_PPC4XX_EXTERNAL 0
-#define HAVE_VSX_EXTERNAL 0
-#define HAVE_AESNI_EXTERNAL 0
-#define HAVE_AMD3DNOW_EXTERNAL 0
-#define HAVE_AMD3DNOWEXT_EXTERNAL 0
-#define HAVE_AVX_EXTERNAL 0
-#define HAVE_AVX2_EXTERNAL 0
-#define HAVE_AVX512_EXTERNAL 0
-#define HAVE_FMA3_EXTERNAL 0
-#define HAVE_FMA4_EXTERNAL 0
-#define HAVE_MMX_EXTERNAL 0
-#define HAVE_MMXEXT_EXTERNAL 0
-#define HAVE_SSE_EXTERNAL 0
-#define HAVE_SSE2_EXTERNAL 0
-#define HAVE_SSE3_EXTERNAL 0
-#define HAVE_SSE4_EXTERNAL 0
-#define HAVE_SSE42_EXTERNAL 0
-#define HAVE_SSSE3_EXTERNAL 0
-#define HAVE_XOP_EXTERNAL 0
-#define HAVE_CPUNOP_EXTERNAL 0
-#define HAVE_I686_EXTERNAL 0
-#define HAVE_MIPSFPU_EXTERNAL 0
-#define HAVE_MIPS32R2_EXTERNAL 0
-#define HAVE_MIPS32R5_EXTERNAL 0
-#define HAVE_MIPS64R2_EXTERNAL 0
-#define HAVE_MIPS32R6_EXTERNAL 0
-#define HAVE_MIPS64R6_EXTERNAL 0
-#define HAVE_MIPSDSP_EXTERNAL 0
-#define HAVE_MIPSDSPR2_EXTERNAL 0
-#define HAVE_MSA_EXTERNAL 0
-#define HAVE_MSA2_EXTERNAL 0
-#define HAVE_LOONGSON2_EXTERNAL 0
-#define HAVE_LOONGSON3_EXTERNAL 0
-#define HAVE_MMI_EXTERNAL 0
-#define HAVE_ARMV5TE_INLINE 0
-#define HAVE_ARMV6_INLINE 0
-#define HAVE_ARMV6T2_INLINE 0
-#define HAVE_ARMV8_INLINE 0
-#define HAVE_NEON_INLINE 0
-#define HAVE_VFP_INLINE 0
-#define HAVE_VFPV3_INLINE 0
-#define HAVE_SETEND_INLINE 0
-#define HAVE_ALTIVEC_INLINE 0
-#define HAVE_DCBZL_INLINE 0
-#define HAVE_LDBRX_INLINE 0
-#define HAVE_POWER8_INLINE 0
-#define HAVE_PPC4XX_INLINE 0
-#define HAVE_VSX_INLINE 0
-#define HAVE_AESNI_INLINE 0
-#define HAVE_AMD3DNOW_INLINE 0
-#define HAVE_AMD3DNOWEXT_INLINE 0
-#define HAVE_AVX_INLINE 0
-#define HAVE_AVX2_INLINE 0
-#define HAVE_AVX512_INLINE 0
-#define HAVE_FMA3_INLINE 0
-#define HAVE_FMA4_INLINE 0
-#define HAVE_MMX_INLINE 0
-#define HAVE_MMXEXT_INLINE 0
-#define HAVE_SSE_INLINE 0
-#define HAVE_SSE2_INLINE 0
-#define HAVE_SSE3_INLINE 0
-#define HAVE_SSE4_INLINE 0
-#define HAVE_SSE42_INLINE 0
-#define HAVE_SSSE3_INLINE 0
-#define HAVE_XOP_INLINE 0
-#define HAVE_CPUNOP_INLINE 0
-#define HAVE_I686_INLINE 0
-#define HAVE_MIPSFPU_INLINE 0
-#define HAVE_MIPS32R2_INLINE 0
-#define HAVE_MIPS32R5_INLINE 0
-#define HAVE_MIPS64R2_INLINE 0
-#define HAVE_MIPS32R6_INLINE 0
-#define HAVE_MIPS64R6_INLINE 0
-#define HAVE_MIPSDSP_INLINE 0
-#define HAVE_MIPSDSPR2_INLINE 0
-#define HAVE_MSA_INLINE 0
-#define HAVE_MSA2_INLINE 0
-#define HAVE_LOONGSON2_INLINE 0
-#define HAVE_LOONGSON3_INLINE 0
-#define HAVE_MMI_INLINE 0
-#define HAVE_ALIGNED_STACK 1
-#define HAVE_FAST_64BIT 1
-#define HAVE_FAST_CLZ 0
-#define HAVE_FAST_CMOV 0
-#define HAVE_LOCAL_ALIGNED 0
-#define HAVE_SIMD_ALIGN_16 1
-#define HAVE_SIMD_ALIGN_32 0
-#define HAVE_SIMD_ALIGN_64 0
-#define HAVE_ATOMIC_CAS_PTR 0
-#define HAVE_MACHINE_RW_BARRIER 0
-#define HAVE_MEMORYBARRIER 1
-#define HAVE_MM_EMPTY 0
-#define HAVE_RDTSC 0
-#define HAVE_SEM_TIMEDWAIT 0
-#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 0
-#define HAVE_CABS 0
-#define HAVE_CEXP 0
-#define HAVE_INLINE_ASM 0
-#define HAVE_SYMVER 0
-#define HAVE_X86ASM 0
-#define HAVE_BIGENDIAN 0
-#define HAVE_FAST_UNALIGNED 1
-#define HAVE_ARPA_INET_H 0
-#define HAVE_ASM_TYPES_H 0
-#define HAVE_CDIO_PARANOIA_H 0
-#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
-#define HAVE_CUDA_H 0
-#define HAVE_DISPATCH_DISPATCH_H 0
-#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
-#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
-#define HAVE_DEV_IC_BT8XX_H 0
-#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
-#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
-#define HAVE_DIRECT_H 1
-#define HAVE_DIRENT_H 0
-#define HAVE_DXGIDEBUG_H 1
-#define HAVE_DXVA_H 1
-#define HAVE_ES2_GL_H 0
-#define HAVE_GSM_H 0
-#define HAVE_IO_H 1
-#define HAVE_LINUX_PERF_EVENT_H 0
-#define HAVE_MACHINE_IOCTL_BT848_H 0
-#define HAVE_MACHINE_IOCTL_METEOR_H 0
-#define HAVE_OPENCV2_CORE_CORE_C_H 0
-#define HAVE_OPENGL_GL3_H 0
-#define HAVE_POLL_H 0
-#define HAVE_SYS_PARAM_H 0
-#define HAVE_SYS_RESOURCE_H 0
-#define HAVE_SYS_SELECT_H 0
-#define HAVE_SYS_SOUNDCARD_H 0
-#define HAVE_SYS_TIME_H 0
-#define HAVE_SYS_UN_H 0
-#define HAVE_SYS_VIDEOIO_H 0
-#define HAVE_TERMIOS_H 0
-#define HAVE_UDPLITE_H 0
-#define HAVE_UNISTD_H 0
-#define HAVE_VALGRIND_VALGRIND_H 0
-#define HAVE_WINDOWS_H 1
-#define HAVE_WINSOCK2_H 1
-#define HAVE_INTRINSICS_NEON 1
-#define HAVE_ATANF 1
-#define HAVE_ATAN2F 1
-#define HAVE_CBRT 1
-#define HAVE_CBRTF 1
-#define HAVE_COPYSIGN 1
-#define HAVE_COSF 1
-#define HAVE_ERF 1
-#define HAVE_EXP2 1
-#define HAVE_EXP2F 1
-#define HAVE_EXPF 1
-#define HAVE_HYPOT 1
-#define HAVE_ISFINITE 1
-#define HAVE_ISINF 1
-#define HAVE_ISNAN 1
-#define HAVE_LDEXPF 1
-#define HAVE_LLRINT 1
-#define HAVE_LLRINTF 1
-#define HAVE_LOG2 1
-#define HAVE_LOG2F 1
-#define HAVE_LOG10F 1
-#define HAVE_LRINT 1
-#define HAVE_LRINTF 1
-#define HAVE_POWF 1
-#define HAVE_RINT 1
-#define HAVE_ROUND 1
-#define HAVE_ROUNDF 1
-#define HAVE_SINF 1
-#define HAVE_TRUNC 1
-#define HAVE_TRUNCF 1
-#define HAVE_DOS_PATHS 1
-#define HAVE_LIBC_MSVCRT 1
-#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
-#define HAVE_SECTION_DATA_REL_RO 0
-#define HAVE_THREADS 1
-#define HAVE_UWP 0
-#define HAVE_WINRT 0
-#define HAVE_ACCESS 1
-#define HAVE_ALIGNED_MALLOC 1
-#define HAVE_CLOCK_GETTIME 0
-#define HAVE_CLOSESOCKET 1
-#define HAVE_COMMANDLINETOARGVW 1
-#define HAVE_FCNTL 0
-#define HAVE_GETADDRINFO 1
-#define HAVE_GETHRTIME 0
-#define HAVE_GETOPT 0
-#define HAVE_GETPROCESSAFFINITYMASK 1
-#define HAVE_GETPROCESSMEMORYINFO 1
-#define HAVE_GETPROCESSTIMES 1
-#define HAVE_GETRUSAGE 0
-#define HAVE_GETSYSTEMTIMEASFILETIME 1
-#define HAVE_GETTIMEOFDAY 0
-#define HAVE_GLOB 0
-#define HAVE_GLXGETPROCADDRESS 0
-#define HAVE_GMTIME_R 0
-#define HAVE_INET_ATON 0
-#define HAVE_ISATTY 1
-#define HAVE_KBHIT 1
-#define HAVE_LSTAT 0
-#define HAVE_LZO1X_999_COMPRESS 0
-#define HAVE_MACH_ABSOLUTE_TIME 0
-#define HAVE_MAPVIEWOFFILE 1
-#define HAVE_MKSTEMP 0
-#define HAVE_MMAP 0
-#define HAVE_MPROTECT 0
-#define HAVE_NANOSLEEP 0
-#define HAVE_PEEKNAMEDPIPE 1
-#define HAVE_PTHREAD_CANCEL 0
-#define HAVE_SCHED_GETAFFINITY 0
-#define HAVE_SECITEMIMPORT 0
-#define HAVE_SETCONSOLETEXTATTRIBUTE 1
-#define HAVE_SETCONSOLECTRLHANDLER 1
-#define HAVE_SETMODE 1
-#define HAVE_SETRLIMIT 0
-#define HAVE_SLEEP 1
-#define HAVE_STRERROR_R 0
-#define HAVE_SYSCONF 0
-#define HAVE_SYSCTL 0
-#define HAVE_USLEEP 0
-#define HAVE_UTGETOSTYPEFROMSTRING 0
-#define HAVE_VIRTUALALLOC 1
-#define HAVE_WGLGETPROCADDRESS 0
-#define HAVE_BCRYPT 1
-#define HAVE_VAAPI_DRM 0
-#define HAVE_VAAPI_X11 0
-#define HAVE_VDPAU_X11 0
-#define HAVE_PTHREADS 0
-#define HAVE_OS2THREADS 0
-#define HAVE_W32THREADS 1
-#define HAVE_AS_ARCH_DIRECTIVE 0
-#define HAVE_AS_DN_DIRECTIVE 0
-#define HAVE_AS_FPU_DIRECTIVE 0
-#define HAVE_AS_FUNC 1
-#define HAVE_AS_OBJECT_ARCH 0
-#define HAVE_ASM_MOD_Q 0
-#define HAVE_BLOCKS_EXTENSION 0
-#define HAVE_EBP_AVAILABLE 0
-#define HAVE_EBX_AVAILABLE 0
-#define HAVE_GNU_AS 0
-#define HAVE_GNU_WINDRES 0
-#define HAVE_IBM_ASM 0
-#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
-#define HAVE_INLINE_ASM_LABELS 0
-#define HAVE_INLINE_ASM_NONLOCAL_LABELS 0
-#define HAVE_PRAGMA_DEPRECATED 1
-#define HAVE_RSYNC_CONTIMEOUT 1
-#define HAVE_SYMVER_ASM_LABEL 0
-#define HAVE_SYMVER_GNU_ASM 0
-#define HAVE_VFP_ARGS 0
-#define HAVE_XFORM_ASM 0
-#define HAVE_XMM_CLOBBERS 0
-#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
-#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
-#define HAVE_SOCKLEN_T 1
-#define HAVE_STRUCT_ADDRINFO 1
-#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
-#define HAVE_STRUCT_IP_MREQ_SOURCE 1
-#define HAVE_STRUCT_IPV6_MREQ 1
-#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 0
-#define HAVE_STRUCT_POLLFD 1
-#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 0
-#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
-#define HAVE_STRUCT_SOCKADDR_IN6 1
-#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
-#define HAVE_STRUCT_SOCKADDR_STORAGE 1
-#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
-#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
-#define HAVE_MAKEINFO 0
-#define HAVE_MAKEINFO_HTML 0
-#define HAVE_OPENCL_D3D11 0
-#define HAVE_OPENCL_DRM_ARM 0
-#define HAVE_OPENCL_DRM_BEIGNET 0
-#define HAVE_OPENCL_DXVA2 0
-#define HAVE_OPENCL_VAAPI_BEIGNET 0
-#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
-#define HAVE_PERL 1
-#define HAVE_POD2MAN 1
-#define HAVE_TEXI2HTML 0
-#define CONFIG_DOC 0
-#define CONFIG_HTMLPAGES 0
-#define CONFIG_MANPAGES 1
-#define CONFIG_PODPAGES 1
-#define CONFIG_TXTPAGES 0
-#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
-#define CONFIG_AVIO_READING_EXAMPLE 1
-#define CONFIG_DECODE_AUDIO_EXAMPLE 1
-#define CONFIG_DECODE_VIDEO_EXAMPLE 1
-#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
-#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
-#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
-#define CONFIG_EXTRACT_MVS_EXAMPLE 0
-#define CONFIG_FILTER_AUDIO_EXAMPLE 0
-#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
-#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
-#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
-#define CONFIG_HW_DECODE_EXAMPLE 0
-#define CONFIG_METADATA_EXAMPLE 0
-#define CONFIG_MUXING_EXAMPLE 0
-#define CONFIG_QSVDEC_EXAMPLE 0
-#define CONFIG_REMUXING_EXAMPLE 0
-#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
-#define CONFIG_SCALING_VIDEO_EXAMPLE 0
-#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
-#define CONFIG_TRANSCODING_EXAMPLE 0
-#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
-#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
-#define CONFIG_AVISYNTH 0
-#define CONFIG_FREI0R 0
-#define CONFIG_LIBCDIO 0
-#define CONFIG_LIBDAVS2 0
-#define CONFIG_LIBRUBBERBAND 0
-#define CONFIG_LIBVIDSTAB 0
-#define CONFIG_LIBX264 0
-#define CONFIG_LIBX265 0
-#define CONFIG_LIBXAVS 0
-#define CONFIG_LIBXAVS2 0
-#define CONFIG_LIBXVID 0
-#define CONFIG_DECKLINK 0
-#define CONFIG_LIBFDK_AAC 0
-#define CONFIG_OPENSSL 0
-#define CONFIG_LIBTLS 0
-#define CONFIG_GMP 0
-#define CONFIG_LIBARIBB24 0
-#define CONFIG_LIBLENSFUN 0
-#define CONFIG_LIBOPENCORE_AMRNB 0
-#define CONFIG_LIBOPENCORE_AMRWB 0
-#define CONFIG_LIBVMAF 0
-#define CONFIG_LIBVO_AMRWBENC 0
-#define CONFIG_MBEDTLS 0
-#define CONFIG_RKMPP 0
-#define CONFIG_LIBSMBCLIENT 0
-#define CONFIG_CHROMAPRINT 0
-#define CONFIG_GCRYPT 0
-#define CONFIG_GNUTLS 0
-#define CONFIG_JNI 0
-#define CONFIG_LADSPA 0
-#define CONFIG_LIBAOM 0
-#define CONFIG_LIBASS 0
-#define CONFIG_LIBBLURAY 0
-#define CONFIG_LIBBS2B 0
-#define CONFIG_LIBCACA 0
-#define CONFIG_LIBCELT 0
-#define CONFIG_LIBCODEC2 0
-#define CONFIG_LIBDAV1D 0
-#define CONFIG_LIBDC1394 0
-#define CONFIG_LIBDRM 0
-#define CONFIG_LIBFLITE 0
-#define CONFIG_LIBFONTCONFIG 0
-#define CONFIG_LIBFREETYPE 0
-#define CONFIG_LIBFRIBIDI 0
-#define CONFIG_LIBGME 0
-#define CONFIG_LIBGSM 0
-#define CONFIG_LIBIEC61883 0
-#define CONFIG_LIBILBC 0
-#define CONFIG_LIBJACK 0
-#define CONFIG_LIBKLVANC 0
-#define CONFIG_LIBKVAZAAR 0
-#define CONFIG_LIBMODPLUG 0
-#define CONFIG_LIBMP3LAME 0
-#define CONFIG_LIBMYSOFA 0
-#define CONFIG_LIBOPENCV 0
-#define CONFIG_LIBOPENH264 0
-#define CONFIG_LIBOPENJPEG 0
-#define CONFIG_LIBOPENMPT 0
-#define CONFIG_LIBOPUS 0
-#define CONFIG_LIBPULSE 0
-#define CONFIG_LIBRSVG 0
-#define CONFIG_LIBRTMP 0
-#define CONFIG_LIBSHINE 0
-#define CONFIG_LIBSMBCLIENT 0
-#define CONFIG_LIBSNAPPY 0
-#define CONFIG_LIBSOXR 0
-#define CONFIG_LIBSPEEX 0
-#define CONFIG_LIBSRT 0
-#define CONFIG_LIBSSH 0
-#define CONFIG_LIBTENSORFLOW 0
-#define CONFIG_LIBTESSERACT 0
-#define CONFIG_LIBTHEORA 0
-#define CONFIG_LIBTWOLAME 0
-#define CONFIG_LIBV4L2 0
-#define CONFIG_LIBVORBIS 0
-#define CONFIG_LIBVPX 0
-#define CONFIG_LIBWAVPACK 0
-#define CONFIG_LIBWEBP 0
-#define CONFIG_LIBXML2 0
-#define CONFIG_LIBZIMG 0
-#define CONFIG_LIBZMQ 0
-#define CONFIG_LIBZVBI 0
-#define CONFIG_LV2 0
-#define CONFIG_MEDIACODEC 0
-#define CONFIG_OPENAL 0
-#define CONFIG_OPENGL 0
-#define CONFIG_POCKETSPHINX 0
-#define CONFIG_VAPOURSYNTH 0
-#define CONFIG_ALSA 0
-#define CONFIG_APPKIT 0
-#define CONFIG_AVFOUNDATION 0
-#define CONFIG_BZLIB 0
-#define CONFIG_COREIMAGE 0
-#define CONFIG_ICONV 0
-#define CONFIG_LIBXCB 0
-#define CONFIG_LIBXCB_SHM 0
-#define CONFIG_LIBXCB_SHAPE 0
-#define CONFIG_LIBXCB_XFIXES 0
-#define CONFIG_LZMA 0
-#define CONFIG_SCHANNEL 0
-#define CONFIG_SDL2 0
-#define CONFIG_SECURETRANSPORT 0
-#define CONFIG_SNDIO 0
-#define CONFIG_XLIB 0
-#define CONFIG_ZLIB 0
-#define CONFIG_CUDA_NVCC 0
-#define CONFIG_CUDA_SDK 0
-#define CONFIG_LIBNPP 0
-#define CONFIG_LIBMFX 0
-#define CONFIG_MMAL 0
-#define CONFIG_OMX 0
-#define CONFIG_OPENCL 0
-#define CONFIG_AMF 0
-#define CONFIG_AUDIOTOOLBOX 0
-#define CONFIG_CRYSTALHD 0
-#define CONFIG_CUDA 0
-#define CONFIG_CUDA_LLVM 0
-#define CONFIG_CUVID 0
-#define CONFIG_D3D11VA 0
-#define CONFIG_DXVA2 0
-#define CONFIG_FFNVCODEC 0
-#define CONFIG_NVDEC 0
-#define CONFIG_NVENC 0
-#define CONFIG_VAAPI 0
-#define CONFIG_VDPAU 0
-#define CONFIG_VIDEOTOOLBOX 0
-#define CONFIG_V4L2_M2M 0
-#define CONFIG_XVMC 0
-#define CONFIG_FTRAPV 0
-#define CONFIG_GRAY 0
-#define CONFIG_HARDCODED_TABLES 0
-#define CONFIG_OMX_RPI 0
-#define CONFIG_RUNTIME_CPUDETECT 1
-#define CONFIG_SAFE_BITSTREAM_READER 1
-#define CONFIG_SHARED 1
-#define CONFIG_SMALL 0
-#define CONFIG_STATIC 0
-#define CONFIG_SWSCALE_ALPHA 1
-#define CONFIG_GPL 0
-#define CONFIG_NONFREE 0
-#define CONFIG_VERSION3 0
-#define CONFIG_AVDEVICE 0
-#define CONFIG_AVFILTER 0
-#define CONFIG_SWSCALE 0
-#define CONFIG_POSTPROC 0
-#define CONFIG_AVFORMAT 0
-#define CONFIG_AVCODEC 1
-#define CONFIG_SWRESAMPLE 0
-#define CONFIG_AVRESAMPLE 0
-#define CONFIG_AVUTIL 1
-#define CONFIG_FFPLAY 0
-#define CONFIG_FFPROBE 0
-#define CONFIG_FFMPEG 0
-#define CONFIG_DCT 1
-#define CONFIG_DWT 0
-#define CONFIG_ERROR_RESILIENCE 0
-#define CONFIG_FAAN 1
-#define CONFIG_FAST_UNALIGNED 1
-#define CONFIG_FFT 1
-#define CONFIG_LSP 0
-#define CONFIG_LZO 0
-#define CONFIG_MDCT 0
-#define CONFIG_PIXELUTILS 0
-#define CONFIG_NETWORK 0
-#define CONFIG_RDFT 1
-#define CONFIG_AUTODETECT 0
-#define CONFIG_FONTCONFIG 0
-#define CONFIG_LINUX_PERF 0
-#define CONFIG_MEMORY_POISONING 0
-#define CONFIG_NEON_CLOBBER_TEST 0
-#define CONFIG_OSSFUZZ 0
-#define CONFIG_PIC 1
-#define CONFIG_THUMB 0
-#define CONFIG_VALGRIND_BACKTRACE 0
-#define CONFIG_XMM_CLOBBER_TEST 0
-#define CONFIG_BSFS 1
-#define CONFIG_DECODERS 1
-#define CONFIG_PARSERS 1
-#define CONFIG_AANDCTTABLES 0
-#define CONFIG_AC3DSP 0
-#define CONFIG_ADTS_HEADER 0
-#define CONFIG_AUDIO_FRAME_QUEUE 0
-#define CONFIG_AUDIODSP 0
-#define CONFIG_BLOCKDSP 0
-#define CONFIG_BSWAPDSP 0
-#define CONFIG_CABAC 0
-#define CONFIG_CBS 0
-#define CONFIG_CBS_AV1 0
-#define CONFIG_CBS_H264 0
-#define CONFIG_CBS_H265 0
-#define CONFIG_CBS_JPEG 0
-#define CONFIG_CBS_MPEG2 0
-#define CONFIG_CBS_VP9 0
-#define CONFIG_DIRAC_PARSE 0
-#define CONFIG_DNN 0
-#define CONFIG_DVPROFILE 0
-#define CONFIG_EXIF 0
-#define CONFIG_FAANDCT 1
-#define CONFIG_FAANIDCT 1
-#define CONFIG_FDCTDSP 1
-#define CONFIG_FLACDSP 1
-#define CONFIG_FMTCONVERT 0
-#define CONFIG_FRAME_THREAD_ENCODER 0
-#define CONFIG_G722DSP 0
-#define CONFIG_GOLOMB 0
-#define CONFIG_GPLV3 0
-#define CONFIG_H263DSP 0
-#define CONFIG_H264CHROMA 0
-#define CONFIG_H264DSP 0
-#define CONFIG_H264PARSE 0
-#define CONFIG_H264PRED 1
-#define CONFIG_H264QPEL 0
-#define CONFIG_HEVCPARSE 0
-#define CONFIG_HPELDSP 0
-#define CONFIG_HUFFMAN 0
-#define CONFIG_HUFFYUVDSP 0
-#define CONFIG_HUFFYUVENCDSP 0
-#define CONFIG_IDCTDSP 1
-#define CONFIG_IIRFILTER 0
-#define CONFIG_MDCT15 0
-#define CONFIG_INTRAX8 0
-#define CONFIG_ISO_MEDIA 0
-#define CONFIG_IVIDSP 0
-#define CONFIG_JPEGTABLES 0
-#define CONFIG_LGPLV3 0
-#define CONFIG_LIBX262 0
-#define CONFIG_LLAUDDSP 0
-#define CONFIG_LLVIDDSP 0
-#define CONFIG_LLVIDENCDSP 0
-#define CONFIG_LPC 0
-#define CONFIG_LZF 0
-#define CONFIG_ME_CMP 0
-#define CONFIG_MPEG_ER 0
-#define CONFIG_MPEGAUDIO 1
-#define CONFIG_MPEGAUDIODSP 1
-#define CONFIG_MPEGAUDIOHEADER 1
-#define CONFIG_MPEGVIDEO 0
-#define CONFIG_MPEGVIDEOENC 0
-#define CONFIG_MSS34DSP 0
-#define CONFIG_PIXBLOCKDSP 0
-#define CONFIG_QPELDSP 0
-#define CONFIG_QSV 0
-#define CONFIG_QSVDEC 0
-#define CONFIG_QSVENC 0
-#define CONFIG_QSVVPP 0
-#define CONFIG_RANGECODER 0
-#define CONFIG_RIFFDEC 0
-#define CONFIG_RIFFENC 0
-#define CONFIG_RTPDEC 0
-#define CONFIG_RTPENC_CHAIN 0
-#define CONFIG_RV34DSP 0
-#define CONFIG_SCENE_SAD 0
-#define CONFIG_SINEWIN 0
-#define CONFIG_SNAPPY 0
-#define CONFIG_SRTP 0
-#define CONFIG_STARTCODE 0
-#define CONFIG_TEXTUREDSP 0
-#define CONFIG_TEXTUREDSPENC 0
-#define CONFIG_TPELDSP 0
-#define CONFIG_VAAPI_1 0
-#define CONFIG_VAAPI_ENCODE 0
-#define CONFIG_VC1DSP 0
-#define CONFIG_VIDEODSP 1
-#define CONFIG_VP3DSP 0
-#define CONFIG_VP56DSP 0
-#define CONFIG_VP8DSP 1
-#define CONFIG_WMA_FREQS 0
-#define CONFIG_WMV2DSP 0
-#define CONFIG_NULL_BSF 1
-#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-#define CONFIG_VP8_DECODER 1
-#define CONFIG_VP9_DECODER 1
-#define CONFIG_FLAC_DECODER 1
-#define CONFIG_MP3_DECODER 1
-#define CONFIG_VP8_PARSER 1
-#define CONFIG_VP9_PARSER 1
-#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_android32.h b/media/ffvpx/config_android32.h
--- a/media/ffvpx/config_android32.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_android32.h	2023-04-06 12:49:19.191546429 +0200
@@ -1,15 +1,16 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "--cross-prefix=/home/jyavenard/.mozbuild/android-ndk-r15c/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi- --target-os=linux --arch=arm --enable-cross-compile --sysroot=/home/jyavenard/.mozbuild/android-ndk-r15c/platforms/android-24/arch-arm --disable-everything --disable-protocols --disable-demuxers --disable-muxers --disable-filters --disable-programs --disable-doc --disable-parsers --disable-static --enable-shared --disable-debug --disable-sdl2 --disable-libxcb --disable-securetransport --disable-iconv --disable-swresample --disable-swscale --disable-avdevice --disable-avfilter --disable-avformat --disable-d3d11va --disable-dxva2 --disable-vaapi --disable-vdpau --disable-videotoolbox --enable-decoder=flac --disable-cuda --disable-cuvid --enable-decoder=mp3"
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='mp3,flac' --disable-static --enable-shared --disable-autodetect --enable-small --target-os=linux --arch=arm --enable-cross-compile --cc=/Users/padenot/.mozbuild/android-ndk-r21d/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi16-clang"
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
-#define CONFIG_THIS_YEAR 2017
+#define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "gcc 4.9.x (GCC) 20150123 (prerelease)"
+#define CC_IDENT "Android (6454773 based on r365631c2) clang version 9.0.8 (https://android.googlesource.com/toolchain/llvm-project 98c855489587874b2a325e7a516b99d838599c6f) (based on LLVM 9.0.8svn)"
+#define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
-#define EXTERN_ASM
+#define EXTERN_ASM 
 #define BUILDSUF ""
 #define SLIBSUF ".so"
 #define HAVE_MMX2 HAVE_MMXEXT
@@ -22,12 +23,16 @@
 #define ARCH_AVR32_UC 0
 #define ARCH_BFIN 0
 #define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
 #define ARCH_M68K 0
 #define ARCH_MIPS 0
 #define ARCH_MIPS64 0
 #define ARCH_PARISC 0
 #define ARCH_PPC 0
 #define ARCH_PPC64 0
+#define ARCH_RISCV 0
 #define ARCH_S390 0
 #define ARCH_SH4 0
 #define ARCH_SPARC 0
@@ -58,6 +63,7 @@
 #define HAVE_AVX 0
 #define HAVE_AVX2 0
 #define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
 #define HAVE_FMA3 0
 #define HAVE_FMA4 0
 #define HAVE_MMX 0
@@ -80,18 +86,19 @@
 #define HAVE_MIPSDSP 0
 #define HAVE_MIPSDSPR2 0
 #define HAVE_MSA 0
-#define HAVE_MSA2 0
 #define HAVE_LOONGSON2 0
 #define HAVE_LOONGSON3 0
 #define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
 #define HAVE_ARMV5TE_EXTERNAL 1
-#define HAVE_ARMV6_EXTERNAL 0
-#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 1
+#define HAVE_ARMV6T2_EXTERNAL 1
 #define HAVE_ARMV8_EXTERNAL 0
-#define HAVE_NEON_EXTERNAL 0
+#define HAVE_NEON_EXTERNAL 1
 #define HAVE_VFP_EXTERNAL 1
-#define HAVE_VFPV3_EXTERNAL 0
-#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_VFPV3_EXTERNAL 1
+#define HAVE_SETEND_EXTERNAL 1
 #define HAVE_ALTIVEC_EXTERNAL 0
 #define HAVE_DCBZL_EXTERNAL 0
 #define HAVE_LDBRX_EXTERNAL 0
@@ -104,6 +111,7 @@
 #define HAVE_AVX_EXTERNAL 0
 #define HAVE_AVX2_EXTERNAL 0
 #define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
 #define HAVE_FMA3_EXTERNAL 0
 #define HAVE_FMA4_EXTERNAL 0
 #define HAVE_MMX_EXTERNAL 0
@@ -126,18 +134,19 @@
 #define HAVE_MIPSDSP_EXTERNAL 0
 #define HAVE_MIPSDSPR2_EXTERNAL 0
 #define HAVE_MSA_EXTERNAL 0
-#define HAVE_MSA2_EXTERNAL 0
 #define HAVE_LOONGSON2_EXTERNAL 0
 #define HAVE_LOONGSON3_EXTERNAL 0
 #define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 1
-#define HAVE_ARMV6_INLINE 0
-#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV6_INLINE 1
+#define HAVE_ARMV6T2_INLINE 1
 #define HAVE_ARMV8_INLINE 0
-#define HAVE_NEON_INLINE 0
-#define HAVE_VFP_INLINE 0
-#define HAVE_VFPV3_INLINE 0
-#define HAVE_SETEND_INLINE 0
+#define HAVE_NEON_INLINE 1
+#define HAVE_VFP_INLINE 1
+#define HAVE_VFPV3_INLINE 1
+#define HAVE_SETEND_INLINE 1
 #define HAVE_ALTIVEC_INLINE 0
 #define HAVE_DCBZL_INLINE 0
 #define HAVE_LDBRX_INLINE 0
@@ -150,6 +159,7 @@
 #define HAVE_AVX_INLINE 0
 #define HAVE_AVX2_INLINE 0
 #define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
 #define HAVE_FMA3_INLINE 0
 #define HAVE_FMA4_INLINE 0
 #define HAVE_MMX_INLINE 0
@@ -172,10 +182,11 @@
 #define HAVE_MIPSDSP_INLINE 0
 #define HAVE_MIPSDSPR2_INLINE 0
 #define HAVE_MSA_INLINE 0
-#define HAVE_MSA2_INLINE 0
 #define HAVE_LOONGSON2_INLINE 0
 #define HAVE_LOONGSON3_INLINE 0
 #define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
 #define HAVE_ALIGNED_STACK 0
 #define HAVE_FAST_64BIT 0
 #define HAVE_FAST_CLZ 1
@@ -191,13 +202,13 @@
 #define HAVE_RDTSC 0
 #define HAVE_SEM_TIMEDWAIT 1
 #define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
-#define HAVE_CABS 1
-#define HAVE_CEXP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
 #define HAVE_INLINE_ASM 1
 #define HAVE_SYMVER 1
 #define HAVE_X86ASM 0
 #define HAVE_BIGENDIAN 0
-#define HAVE_FAST_UNALIGNED 0
+#define HAVE_FAST_UNALIGNED 1
 #define HAVE_ARPA_INET_H 1
 #define HAVE_ASM_TYPES_H 1
 #define HAVE_CDIO_PARANOIA_H 0
@@ -216,9 +227,11 @@
 #define HAVE_ES2_GL_H 0
 #define HAVE_GSM_H 0
 #define HAVE_IO_H 0
-#define HAVE_LINUX_PERF_EVENT_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
 #define HAVE_MACHINE_IOCTL_BT848_H 0
 #define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 1
 #define HAVE_OPENCV2_CORE_CORE_C_H 0
 #define HAVE_OPENGL_GL3_H 0
 #define HAVE_POLL_H 1
@@ -235,7 +248,7 @@
 #define HAVE_VALGRIND_VALGRIND_H 0
 #define HAVE_WINDOWS_H 0
 #define HAVE_WINSOCK2_H 0
-#define HAVE_INTRINSICS_NEON 0
+#define HAVE_INTRINSICS_NEON 1
 #define HAVE_ATANF 1
 #define HAVE_ATAN2F 1
 #define HAVE_CBRT 1
@@ -253,8 +266,8 @@
 #define HAVE_LDEXPF 1
 #define HAVE_LLRINT 1
 #define HAVE_LLRINTF 1
-#define HAVE_LOG2 1
-#define HAVE_LOG2F 1
+#define HAVE_LOG2 0
+#define HAVE_LOG2F 0
 #define HAVE_LOG10F 1
 #define HAVE_LRINT 1
 #define HAVE_LRINTF 1
@@ -274,17 +287,22 @@
 #define HAVE_WINRT 0
 #define HAVE_ACCESS 1
 #define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 1
 #define HAVE_CLOCK_GETTIME 1
 #define HAVE_CLOSESOCKET 0
 #define HAVE_COMMANDLINETOARGVW 0
 #define HAVE_FCNTL 1
 #define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 0
+#define HAVE_GETENV 1
 #define HAVE_GETHRTIME 0
 #define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
 #define HAVE_GETPROCESSAFFINITYMASK 0
 #define HAVE_GETPROCESSMEMORYINFO 0
 #define HAVE_GETPROCESSTIMES 0
 #define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
 #define HAVE_GETSYSTEMTIMEASFILETIME 0
 #define HAVE_GETTIMEOFDAY 1
 #define HAVE_GLOB 0
@@ -293,20 +311,24 @@
 #define HAVE_INET_ATON 1
 #define HAVE_ISATTY 1
 #define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
 #define HAVE_LSTAT 1
 #define HAVE_LZO1X_999_COMPRESS 0
 #define HAVE_MACH_ABSOLUTE_TIME 0
 #define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 1
 #define HAVE_MKSTEMP 1
 #define HAVE_MMAP 1
 #define HAVE_MPROTECT 1
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 0
 #define HAVE_PTHREAD_CANCEL 0
 #define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
 #define HAVE_SETCONSOLETEXTATTRIBUTE 0
 #define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
 #define HAVE_SETMODE 0
 #define HAVE_SETRLIMIT 1
 #define HAVE_SLEEP 0
@@ -325,7 +347,7 @@
 #define HAVE_OS2THREADS 0
 #define HAVE_W32THREADS 0
 #define HAVE_AS_ARCH_DIRECTIVE 1
-#define HAVE_AS_DN_DIRECTIVE 1
+#define HAVE_AS_DN_DIRECTIVE 0
 #define HAVE_AS_FPU_DIRECTIVE 1
 #define HAVE_AS_FUNC 0
 #define HAVE_AS_OBJECT_ARCH 1
@@ -340,14 +362,29 @@
 #define HAVE_INLINE_ASM_LABELS 1
 #define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
 #define HAVE_PRAGMA_DEPRECATED 1
-#define HAVE_RSYNC_CONTIMEOUT 1
-#define HAVE_SYMVER_ASM_LABEL 0
+#define HAVE_RSYNC_CONTIMEOUT 0
+#define HAVE_SYMVER_ASM_LABEL 1
 #define HAVE_SYMVER_GNU_ASM 1
 #define HAVE_VFP_ARGS 0
 #define HAVE_XFORM_ASM 0
 #define HAVE_XMM_CLOBBERS 0
 #define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
 #define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 #define HAVE_SOCKLEN_T 1
 #define HAVE_STRUCT_ADDRINFO 1
 #define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -360,8 +397,10 @@
 #define HAVE_STRUCT_SOCKADDR_IN6 1
 #define HAVE_STRUCT_SOCKADDR_SA_LEN 0
 #define HAVE_STRUCT_SOCKADDR_STORAGE 1
-#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
-#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
 #define HAVE_MAKEINFO 1
 #define HAVE_MAKEINFO_HTML 0
 #define HAVE_OPENCL_D3D11 0
@@ -373,12 +412,14 @@
 #define HAVE_PERL 1
 #define HAVE_POD2MAN 1
 #define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
 #define CONFIG_DOC 0
 #define CONFIG_HTMLPAGES 0
 #define CONFIG_MANPAGES 1
 #define CONFIG_PODPAGES 1
 #define CONFIG_TXTPAGES 1
-#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 #define CONFIG_AVIO_READING_EXAMPLE 1
 #define CONFIG_DECODE_AUDIO_EXAMPLE 1
 #define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -414,14 +455,12 @@
 #define CONFIG_LIBXVID 0
 #define CONFIG_DECKLINK 0
 #define CONFIG_LIBFDK_AAC 0
-#define CONFIG_OPENSSL 0
 #define CONFIG_LIBTLS 0
 #define CONFIG_GMP 0
 #define CONFIG_LIBARIBB24 0
 #define CONFIG_LIBLENSFUN 0
 #define CONFIG_LIBOPENCORE_AMRNB 0
 #define CONFIG_LIBOPENCORE_AMRWB 0
-#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVO_AMRWBENC 0
 #define CONFIG_MBEDTLS 0
 #define CONFIG_RKMPP 0
@@ -431,6 +470,7 @@
 #define CONFIG_GNUTLS 0
 #define CONFIG_JNI 0
 #define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
 #define CONFIG_LIBAOM 0
 #define CONFIG_LIBASS 0
 #define CONFIG_LIBBLURAY 0
@@ -445,11 +485,13 @@
 #define CONFIG_LIBFONTCONFIG 0
 #define CONFIG_LIBFREETYPE 0
 #define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
 #define CONFIG_LIBGME 0
 #define CONFIG_LIBGSM 0
 #define CONFIG_LIBIEC61883 0
 #define CONFIG_LIBILBC 0
 #define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
 #define CONFIG_LIBKLVANC 0
 #define CONFIG_LIBKVAZAAR 0
 #define CONFIG_LIBMODPLUG 0
@@ -459,10 +501,16 @@
 #define CONFIG_LIBOPENH264 0
 #define CONFIG_LIBOPENJPEG 0
 #define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
 #define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
 #define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
 #define CONFIG_LIBRSVG 0
 #define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
 #define CONFIG_LIBSHINE 0
 #define CONFIG_LIBSMBCLIENT 0
 #define CONFIG_LIBSNAPPY 0
@@ -470,14 +518,16 @@
 #define CONFIG_LIBSPEEX 0
 #define CONFIG_LIBSRT 0
 #define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
 #define CONFIG_LIBTENSORFLOW 0
 #define CONFIG_LIBTESSERACT 0
 #define CONFIG_LIBTHEORA 0
 #define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
 #define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVORBIS 0
 #define CONFIG_LIBVPX 0
-#define CONFIG_LIBWAVPACK 0
 #define CONFIG_LIBWEBP 0
 #define CONFIG_LIBXML2 0
 #define CONFIG_LIBZIMG 0
@@ -487,25 +537,28 @@
 #define CONFIG_MEDIACODEC 0
 #define CONFIG_OPENAL 0
 #define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
 #define CONFIG_POCKETSPHINX 0
 #define CONFIG_VAPOURSYNTH 0
 #define CONFIG_ALSA 0
-#define CONFIG_APPKIT 1
-#define CONFIG_AVFOUNDATION 1
-#define CONFIG_BZLIB 1
-#define CONFIG_COREIMAGE 1
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
 #define CONFIG_ICONV 0
 #define CONFIG_LIBXCB 0
 #define CONFIG_LIBXCB_SHM 0
 #define CONFIG_LIBXCB_SHAPE 0
 #define CONFIG_LIBXCB_XFIXES 0
-#define CONFIG_LZMA 1
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
 #define CONFIG_SCHANNEL 0
 #define CONFIG_SDL2 0
 #define CONFIG_SECURETRANSPORT 0
 #define CONFIG_SNDIO 0
-#define CONFIG_XLIB 1
-#define CONFIG_ZLIB 1
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
 #define CONFIG_CUDA_NVCC 0
 #define CONFIG_CUDA_SDK 0
 #define CONFIG_LIBNPP 0
@@ -527,8 +580,8 @@
 #define CONFIG_VAAPI 0
 #define CONFIG_VDPAU 0
 #define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
 #define CONFIG_V4L2_M2M 0
-#define CONFIG_XVMC 0
 #define CONFIG_FTRAPV 0
 #define CONFIG_GRAY 0
 #define CONFIG_HARDCODED_TABLES 0
@@ -549,7 +602,6 @@
 #define CONFIG_AVFORMAT 0
 #define CONFIG_AVCODEC 1
 #define CONFIG_SWRESAMPLE 0
-#define CONFIG_AVRESAMPLE 0
 #define CONFIG_AVUTIL 1
 #define CONFIG_FFPLAY 0
 #define CONFIG_FFPROBE 0
@@ -558,30 +610,41 @@
 #define CONFIG_DWT 0
 #define CONFIG_ERROR_RESILIENCE 0
 #define CONFIG_FAAN 1
-#define CONFIG_FAST_UNALIGNED 0
-#define CONFIG_FFT 0
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
 #define CONFIG_LSP 0
-#define CONFIG_LZO 0
 #define CONFIG_MDCT 0
 #define CONFIG_PIXELUTILS 0
 #define CONFIG_NETWORK 0
 #define CONFIG_RDFT 1
 #define CONFIG_AUTODETECT 0
 #define CONFIG_FONTCONFIG 0
-#define CONFIG_LINUX_PERF 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 1
+#define CONFIG_MACOS_KPERF 0
 #define CONFIG_MEMORY_POISONING 0
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
 #define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
-#define CONFIG_BSFS 1
+#define CONFIG_BSFS 0
 #define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
 #define CONFIG_PARSERS 0
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
 #define CONFIG_AANDCTTABLES 0
 #define CONFIG_AC3DSP 0
 #define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
 #define CONFIG_AUDIO_FRAME_QUEUE 0
 #define CONFIG_AUDIODSP 0
 #define CONFIG_BLOCKDSP 0
@@ -594,15 +657,18 @@
 #define CONFIG_CBS_JPEG 0
 #define CONFIG_CBS_MPEG2 0
 #define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
 #define CONFIG_DIRAC_PARSE 0
 #define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
 #define CONFIG_DVPROFILE 0
 #define CONFIG_EXIF 0
-#define CONFIG_FAANDCT 0
-#define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
 #define CONFIG_FLACDSP 1
 #define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
 #define CONFIG_G722DSP 0
 #define CONFIG_GOLOMB 0
 #define CONFIG_GPLV3 0
@@ -617,9 +683,10 @@
 #define CONFIG_HUFFMAN 0
 #define CONFIG_HUFFYUVDSP 0
 #define CONFIG_HUFFYUVENCDSP 0
-#define CONFIG_IDCTDSP 0
+#define CONFIG_IDCTDSP 1
 #define CONFIG_IIRFILTER 0
 #define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
 #define CONFIG_INTRAX8 0
 #define CONFIG_ISO_MEDIA 0
 #define CONFIG_IVIDSP 0
@@ -636,7 +703,9 @@
 #define CONFIG_MPEGAUDIO 1
 #define CONFIG_MPEGAUDIODSP 1
 #define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
 #define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
 #define CONFIG_MPEGVIDEOENC 0
 #define CONFIG_MSS34DSP 0
 #define CONFIG_PIXBLOCKDSP 0
@@ -668,12 +737,4 @@
 #define CONFIG_VP8DSP 0
 #define CONFIG_WMA_FREQS 0
 #define CONFIG_WMV2DSP 0
-#define CONFIG_NULL_BSF 1
-#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 0
-#define CONFIG_VP8_DECODER 0
-#define CONFIG_VP9_DECODER 0
-#define CONFIG_FLAC_DECODER 1
-#define CONFIG_MP3_DECODER 1
-#define CONFIG_VP8_PARSER 0
-#define CONFIG_VP9_PARSER 0
 #endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_android64.h b/media/ffvpx/config_android64.h
--- a/media/ffvpx/config_android64.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_android64.h	2023-04-06 12:49:19.191546429 +0200
@@ -0,0 +1,740 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='mp3,flac' --disable-static --enable-shared --disable-autodetect --enable-small --target-os=linux --arch=aarch64 --enable-cross-compile --cc=/Users/padenot/.mozbuild/android-ndk-r21d/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2022
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "Android (6454773 based on r365631c2) clang version 9.0.8 (https://android.googlesource.com/toolchain/llvm-project 98c855489587874b2a325e7a516b99d838599c6f) (based on LLVM 9.0.8svn)"
+#define OS_NAME linux
+#define av_restrict restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define BUILDSUF ""
+#define SLIBSUF ".so"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 1
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_RISCV 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 1
+#define HAVE_NEON 1
+#define HAVE_VFP 1
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 1
+#define HAVE_NEON_EXTERNAL 1
+#define HAVE_VFP_EXTERNAL 1
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 1
+#define HAVE_NEON_INLINE 1
+#define HAVE_VFP_INLINE 1
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
+#define HAVE_ALIGNED_STACK 1
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 1
+#define HAVE_FAST_CMOV 0
+#define HAVE_LOCAL_ALIGNED 0
+#define HAVE_SIMD_ALIGN_16 1
+#define HAVE_SIMD_ALIGN_32 0
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 1
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 1
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 1
+#define HAVE_ARPA_INET_H 1
+#define HAVE_ASM_TYPES_H 1
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 1
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 0
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VALGRIND_VALGRIND_H 0
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 1
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 1
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_GETENV 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 0
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 1
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 1
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PTHREAD_CANCEL 0
+#define HAVE_SCHED_GETAFFINITY 1
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 0
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 0
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 0
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 1
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
+#define HAVE_STRUCT_IP_MREQ_SOURCE 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 1
+#define HAVE_STRUCT_POLLFD 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 1
+#define CONFIG_PODPAGES 1
+#define CONFIG_TXTPAGES 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 0
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 0
+#define CONFIG_METADATA_EXAMPLE 0
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 0
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 1
+#define CONFIG_SMALL 1
+#define CONFIG_STATIC 0
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 1
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 1
+#define CONFIG_MACOS_KPERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 0
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 0
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
+#define CONFIG_DIRAC_PARSE 0
+#define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 0
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 0
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 0
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 1
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 0
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 0
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 0
+#define CONFIG_VP3DSP 0
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 0
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_android_x86_64.h b/media/ffvpx/config_android_x86_64.h
--- a/media/ffvpx/config_android_x86_64.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_android_x86_64.h	2023-04-06 12:49:19.191546429 +0200
@@ -0,0 +1,740 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-parser='vp8,vp9' --enable-decoder='mp3,flac,vp8,vp9' --disable-static --enable-shared --disable-autodetect --enable-small --target-os=linux --arch=x86_64 --enable-cross-compile --cc=/Users/padenot/.mozbuild/android-ndk-r21d/toolchains/llvm/prebuilt/darwin-x86_64/bin/x86_64-linux-android21-clang"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2022
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "Android (6454773 based on r365631c2) clang version 9.0.8 (https://android.googlesource.com/toolchain/llvm-project 98c855489587874b2a325e7a516b99d838599c6f) (based on LLVM 9.0.8svn)"
+#define OS_NAME linux
+#define av_restrict restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define BUILDSUF ""
+#define SLIBSUF ".so"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 0
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_RISCV 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 1
+#define ARCH_X86_32 0
+#define ARCH_X86_64 1
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 0
+#define HAVE_NEON 0
+#define HAVE_VFP 0
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 1
+#define HAVE_AMD3DNOW 1
+#define HAVE_AMD3DNOWEXT 1
+#define HAVE_AVX 1
+#define HAVE_AVX2 1
+#define HAVE_AVX512 1
+#define HAVE_AVX512ICL 1
+#define HAVE_FMA3 1
+#define HAVE_FMA4 1
+#define HAVE_MMX 1
+#define HAVE_MMXEXT 1
+#define HAVE_SSE 1
+#define HAVE_SSE2 1
+#define HAVE_SSE3 1
+#define HAVE_SSE4 1
+#define HAVE_SSE42 1
+#define HAVE_SSSE3 1
+#define HAVE_XOP 1
+#define HAVE_CPUNOP 0
+#define HAVE_I686 1
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 0
+#define HAVE_NEON_EXTERNAL 0
+#define HAVE_VFP_EXTERNAL 0
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 1
+#define HAVE_AMD3DNOW_EXTERNAL 1
+#define HAVE_AMD3DNOWEXT_EXTERNAL 1
+#define HAVE_AVX_EXTERNAL 1
+#define HAVE_AVX2_EXTERNAL 1
+#define HAVE_AVX512_EXTERNAL 1
+#define HAVE_AVX512ICL_EXTERNAL 1
+#define HAVE_FMA3_EXTERNAL 1
+#define HAVE_FMA4_EXTERNAL 1
+#define HAVE_MMX_EXTERNAL 1
+#define HAVE_MMXEXT_EXTERNAL 1
+#define HAVE_SSE_EXTERNAL 1
+#define HAVE_SSE2_EXTERNAL 1
+#define HAVE_SSE3_EXTERNAL 1
+#define HAVE_SSE4_EXTERNAL 1
+#define HAVE_SSE42_EXTERNAL 1
+#define HAVE_SSSE3_EXTERNAL 1
+#define HAVE_XOP_EXTERNAL 1
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 0
+#define HAVE_NEON_INLINE 0
+#define HAVE_VFP_INLINE 0
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 1
+#define HAVE_AMD3DNOW_INLINE 1
+#define HAVE_AMD3DNOWEXT_INLINE 1
+#define HAVE_AVX_INLINE 1
+#define HAVE_AVX2_INLINE 1
+#define HAVE_AVX512_INLINE 1
+#define HAVE_AVX512ICL_INLINE 1
+#define HAVE_FMA3_INLINE 1
+#define HAVE_FMA4_INLINE 1
+#define HAVE_MMX_INLINE 1
+#define HAVE_MMXEXT_INLINE 1
+#define HAVE_SSE_INLINE 1
+#define HAVE_SSE2_INLINE 1
+#define HAVE_SSE3_INLINE 1
+#define HAVE_SSE4_INLINE 1
+#define HAVE_SSE42_INLINE 1
+#define HAVE_SSSE3_INLINE 1
+#define HAVE_XOP_INLINE 1
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
+#define HAVE_ALIGNED_STACK 1
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 1
+#define HAVE_FAST_CMOV 1
+#define HAVE_LOCAL_ALIGNED 1
+#define HAVE_SIMD_ALIGN_16 1
+#define HAVE_SIMD_ALIGN_32 1
+#define HAVE_SIMD_ALIGN_64 1
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 1
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 1
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 1
+#define HAVE_X86ASM 1
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 1
+#define HAVE_ARPA_INET_H 1
+#define HAVE_ASM_TYPES_H 1
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 1
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 0
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VALGRIND_VALGRIND_H 0
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 0
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 1
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 1
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_GETENV 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 0
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 1
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 1
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PTHREAD_CANCEL 0
+#define HAVE_SCHED_GETAFFINITY 1
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 0
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 0
+#define HAVE_EBP_AVAILABLE 1
+#define HAVE_EBX_AVAILABLE 1
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 1
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 0
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 1
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 1
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
+#define HAVE_STRUCT_IP_MREQ_SOURCE 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 1
+#define HAVE_STRUCT_POLLFD 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 1
+#define CONFIG_PODPAGES 1
+#define CONFIG_TXTPAGES 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 0
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 0
+#define CONFIG_METADATA_EXAMPLE 0
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 0
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 1
+#define CONFIG_SMALL 1
+#define CONFIG_STATIC 0
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 1
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 0
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
+#define CONFIG_DIRAC_PARSE 0
+#define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 0
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 1
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 0
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 1
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 0
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 0
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 1
+#define CONFIG_VP3DSP 0
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 1
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_common.h b/media/ffvpx/config_common.h
--- a/media/ffvpx/config_common.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_common.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-#ifndef MOZ_FFVPX_CONFIG_COMMON_H
-#define MOZ_FFVPX_CONFIG_COMMON_H
-#include "defaults_disabled.h"
-
-#ifdef YASM_MISSING_AVX2
-#undef HAVE_AVX2
-#undef HAVE_AVX2_INTERNAL
-#undef HAVE_AVX2_EXTERNAL
-#define HAVE_AVX2 0
-#define HAVE_AVX2_INTERNAL 0
-#define HAVE_AVX2_EXTERNAL 0
-#endif
-
-#ifdef MOZ_LIBAV_FFT
-#undef CONFIG_FFT
-#undef CONFIG_RDFT
-#define CONFIG_FFT 1
-#define CONFIG_RDFT 1
-#endif
-
-#if defined(MOZ_WAYLAND) && !defined(MOZ_FFVPX_AUDIOONLY)
-#undef CONFIG_VAAPI
-#undef CONFIG_VAAPI_1
-#undef CONFIG_VP8_VAAPI_HWACCEL
-#undef CONFIG_VP9_VAAPI_HWACCEL
-#undef CONFIG_AV1_VAAPI_HWACCEL
-#undef CONFIG_LIBDAV1D
-#undef CONFIG_AV1_DECODER
-#define CONFIG_VAAPI 1
-#define CONFIG_VAAPI_1 1
-#define CONFIG_VP8_VAAPI_HWACCEL 1
-#define CONFIG_VP9_VAAPI_HWACCEL 1
-#define CONFIG_AV1_VAAPI_HWACCEL 1
-#define CONFIG_LIBDAV1D 1
-#define CONFIG_AV1_DECODER 1
-#endif
-
-#endif
diff -Naur a/media/ffvpx/config_components_audio_only.h b/media/ffvpx/config_components_audio_only.h
--- a/media/ffvpx/config_components_audio_only.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_components_audio_only.h	2023-04-06 12:50:11.785664945 +0200
@@ -0,0 +1,2091 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_COMPONENTS_H
+#define FFMPEG_CONFIG_COMPONENTS_H
+#define CONFIG_AAC_ADTSTOASC_BSF 0
+#define CONFIG_AV1_FRAME_MERGE_BSF 0
+#define CONFIG_AV1_FRAME_SPLIT_BSF 0
+#define CONFIG_AV1_METADATA_BSF 0
+#define CONFIG_CHOMP_BSF 0
+#define CONFIG_DUMP_EXTRADATA_BSF 0
+#define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DV_ERROR_MARKER_BSF 0
+#define CONFIG_EAC3_CORE_BSF 0
+#define CONFIG_EXTRACT_EXTRADATA_BSF 0
+#define CONFIG_FILTER_UNITS_BSF 0
+#define CONFIG_H264_METADATA_BSF 0
+#define CONFIG_H264_MP4TOANNEXB_BSF 0
+#define CONFIG_H264_REDUNDANT_PPS_BSF 0
+#define CONFIG_HAPQA_EXTRACT_BSF 0
+#define CONFIG_HEVC_METADATA_BSF 0
+#define CONFIG_HEVC_MP4TOANNEXB_BSF 0
+#define CONFIG_IMX_DUMP_HEADER_BSF 0
+#define CONFIG_MJPEG2JPEG_BSF 0
+#define CONFIG_MJPEGA_DUMP_HEADER_BSF 0
+#define CONFIG_MP3_HEADER_DECOMPRESS_BSF 0
+#define CONFIG_MPEG2_METADATA_BSF 0
+#define CONFIG_MPEG4_UNPACK_BFRAMES_BSF 0
+#define CONFIG_MOV2TEXTSUB_BSF 0
+#define CONFIG_NOISE_BSF 0
+#define CONFIG_NULL_BSF 0
+#define CONFIG_OPUS_METADATA_BSF 0
+#define CONFIG_PCM_RECHUNK_BSF 0
+#define CONFIG_PGS_FRAME_MERGE_BSF 0
+#define CONFIG_PRORES_METADATA_BSF 0
+#define CONFIG_REMOVE_EXTRADATA_BSF 0
+#define CONFIG_SETTS_BSF 0
+#define CONFIG_TEXT2MOVSUB_BSF 0
+#define CONFIG_TRACE_HEADERS_BSF 0
+#define CONFIG_TRUEHD_CORE_BSF 0
+#define CONFIG_VP9_METADATA_BSF 0
+#define CONFIG_VP9_RAW_REORDER_BSF 0
+#define CONFIG_VP9_SUPERFRAME_BSF 0
+#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 0
+#define CONFIG_AASC_DECODER 0
+#define CONFIG_AIC_DECODER 0
+#define CONFIG_ALIAS_PIX_DECODER 0
+#define CONFIG_AGM_DECODER 0
+#define CONFIG_AMV_DECODER 0
+#define CONFIG_ANM_DECODER 0
+#define CONFIG_ANSI_DECODER 0
+#define CONFIG_APNG_DECODER 0
+#define CONFIG_ARBC_DECODER 0
+#define CONFIG_ARGO_DECODER 0
+#define CONFIG_ASV1_DECODER 0
+#define CONFIG_ASV2_DECODER 0
+#define CONFIG_AURA_DECODER 0
+#define CONFIG_AURA2_DECODER 0
+#define CONFIG_AVRP_DECODER 0
+#define CONFIG_AVRN_DECODER 0
+#define CONFIG_AVS_DECODER 0
+#define CONFIG_AVUI_DECODER 0
+#define CONFIG_AYUV_DECODER 0
+#define CONFIG_BETHSOFTVID_DECODER 0
+#define CONFIG_BFI_DECODER 0
+#define CONFIG_BINK_DECODER 0
+#define CONFIG_BITPACKED_DECODER 0
+#define CONFIG_BMP_DECODER 0
+#define CONFIG_BMV_VIDEO_DECODER 0
+#define CONFIG_BRENDER_PIX_DECODER 0
+#define CONFIG_C93_DECODER 0
+#define CONFIG_CAVS_DECODER 0
+#define CONFIG_CDGRAPHICS_DECODER 0
+#define CONFIG_CDTOONS_DECODER 0
+#define CONFIG_CDXL_DECODER 0
+#define CONFIG_CFHD_DECODER 0
+#define CONFIG_CINEPAK_DECODER 0
+#define CONFIG_CLEARVIDEO_DECODER 0
+#define CONFIG_CLJR_DECODER 0
+#define CONFIG_CLLC_DECODER 0
+#define CONFIG_COMFORTNOISE_DECODER 0
+#define CONFIG_CPIA_DECODER 0
+#define CONFIG_CRI_DECODER 0
+#define CONFIG_CSCD_DECODER 0
+#define CONFIG_CYUV_DECODER 0
+#define CONFIG_DDS_DECODER 0
+#define CONFIG_DFA_DECODER 0
+#define CONFIG_DIRAC_DECODER 0
+#define CONFIG_DNXHD_DECODER 0
+#define CONFIG_DPX_DECODER 0
+#define CONFIG_DSICINVIDEO_DECODER 0
+#define CONFIG_DVAUDIO_DECODER 0
+#define CONFIG_DVVIDEO_DECODER 0
+#define CONFIG_DXA_DECODER 0
+#define CONFIG_DXTORY_DECODER 0
+#define CONFIG_DXV_DECODER 0
+#define CONFIG_EACMV_DECODER 0
+#define CONFIG_EAMAD_DECODER 0
+#define CONFIG_EATGQ_DECODER 0
+#define CONFIG_EATGV_DECODER 0
+#define CONFIG_EATQI_DECODER 0
+#define CONFIG_EIGHTBPS_DECODER 0
+#define CONFIG_EIGHTSVX_EXP_DECODER 0
+#define CONFIG_EIGHTSVX_FIB_DECODER 0
+#define CONFIG_ESCAPE124_DECODER 0
+#define CONFIG_ESCAPE130_DECODER 0
+#define CONFIG_EXR_DECODER 0
+#define CONFIG_FFV1_DECODER 0
+#define CONFIG_FFVHUFF_DECODER 0
+#define CONFIG_FIC_DECODER 0
+#define CONFIG_FITS_DECODER 0
+#define CONFIG_FLASHSV_DECODER 0
+#define CONFIG_FLASHSV2_DECODER 0
+#define CONFIG_FLIC_DECODER 0
+#define CONFIG_FLV_DECODER 0
+#define CONFIG_FMVC_DECODER 0
+#define CONFIG_FOURXM_DECODER 0
+#define CONFIG_FRAPS_DECODER 0
+#define CONFIG_FRWU_DECODER 0
+#define CONFIG_G2M_DECODER 0
+#define CONFIG_GDV_DECODER 0
+#define CONFIG_GEM_DECODER 0
+#define CONFIG_GIF_DECODER 0
+#define CONFIG_H261_DECODER 0
+#define CONFIG_H263_DECODER 0
+#define CONFIG_H263I_DECODER 0
+#define CONFIG_H263P_DECODER 0
+#define CONFIG_H263_V4L2M2M_DECODER 0
+#define CONFIG_H264_DECODER 0
+#define CONFIG_H264_CRYSTALHD_DECODER 0
+#define CONFIG_H264_V4L2M2M_DECODER 0
+#define CONFIG_H264_MEDIACODEC_DECODER 0
+#define CONFIG_H264_MMAL_DECODER 0
+#define CONFIG_H264_QSV_DECODER 0
+#define CONFIG_H264_RKMPP_DECODER 0
+#define CONFIG_HAP_DECODER 0
+#define CONFIG_HEVC_DECODER 0
+#define CONFIG_HEVC_QSV_DECODER 0
+#define CONFIG_HEVC_RKMPP_DECODER 0
+#define CONFIG_HEVC_V4L2M2M_DECODER 0
+#define CONFIG_HNM4_VIDEO_DECODER 0
+#define CONFIG_HQ_HQA_DECODER 0
+#define CONFIG_HQX_DECODER 0
+#define CONFIG_HUFFYUV_DECODER 0
+#define CONFIG_HYMT_DECODER 0
+#define CONFIG_IDCIN_DECODER 0
+#define CONFIG_IFF_ILBM_DECODER 0
+#define CONFIG_IMM4_DECODER 0
+#define CONFIG_IMM5_DECODER 0
+#define CONFIG_INDEO2_DECODER 0
+#define CONFIG_INDEO3_DECODER 0
+#define CONFIG_INDEO4_DECODER 0
+#define CONFIG_INDEO5_DECODER 0
+#define CONFIG_INTERPLAY_VIDEO_DECODER 0
+#define CONFIG_IPU_DECODER 0
+#define CONFIG_JPEG2000_DECODER 0
+#define CONFIG_JPEGLS_DECODER 0
+#define CONFIG_JV_DECODER 0
+#define CONFIG_KGV1_DECODER 0
+#define CONFIG_KMVC_DECODER 0
+#define CONFIG_LAGARITH_DECODER 0
+#define CONFIG_LOCO_DECODER 0
+#define CONFIG_LSCR_DECODER 0
+#define CONFIG_M101_DECODER 0
+#define CONFIG_MAGICYUV_DECODER 0
+#define CONFIG_MDEC_DECODER 0
+#define CONFIG_MIMIC_DECODER 0
+#define CONFIG_MJPEG_DECODER 0
+#define CONFIG_MJPEGB_DECODER 0
+#define CONFIG_MMVIDEO_DECODER 0
+#define CONFIG_MOBICLIP_DECODER 0
+#define CONFIG_MOTIONPIXELS_DECODER 0
+#define CONFIG_MPEG1VIDEO_DECODER 0
+#define CONFIG_MPEG2VIDEO_DECODER 0
+#define CONFIG_MPEG4_DECODER 0
+#define CONFIG_MPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG4_V4L2M2M_DECODER 0
+#define CONFIG_MPEG4_MMAL_DECODER 0
+#define CONFIG_MPEGVIDEO_DECODER 0
+#define CONFIG_MPEG1_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_MMAL_DECODER 0
+#define CONFIG_MPEG2_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG2_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_QSV_DECODER 0
+#define CONFIG_MPEG2_MEDIACODEC_DECODER 0
+#define CONFIG_MSA1_DECODER 0
+#define CONFIG_MSCC_DECODER 0
+#define CONFIG_MSMPEG4V1_DECODER 0
+#define CONFIG_MSMPEG4V2_DECODER 0
+#define CONFIG_MSMPEG4V3_DECODER 0
+#define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MSP2_DECODER 0
+#define CONFIG_MSRLE_DECODER 0
+#define CONFIG_MSS1_DECODER 0
+#define CONFIG_MSS2_DECODER 0
+#define CONFIG_MSVIDEO1_DECODER 0
+#define CONFIG_MSZH_DECODER 0
+#define CONFIG_MTS2_DECODER 0
+#define CONFIG_MV30_DECODER 0
+#define CONFIG_MVC1_DECODER 0
+#define CONFIG_MVC2_DECODER 0
+#define CONFIG_MVDV_DECODER 0
+#define CONFIG_MVHA_DECODER 0
+#define CONFIG_MWSC_DECODER 0
+#define CONFIG_MXPEG_DECODER 0
+#define CONFIG_NOTCHLC_DECODER 0
+#define CONFIG_NUV_DECODER 0
+#define CONFIG_PAF_VIDEO_DECODER 0
+#define CONFIG_PAM_DECODER 0
+#define CONFIG_PBM_DECODER 0
+#define CONFIG_PCX_DECODER 0
+#define CONFIG_PFM_DECODER 0
+#define CONFIG_PGM_DECODER 0
+#define CONFIG_PGMYUV_DECODER 0
+#define CONFIG_PGX_DECODER 0
+#define CONFIG_PHOTOCD_DECODER 0
+#define CONFIG_PICTOR_DECODER 0
+#define CONFIG_PIXLET_DECODER 0
+#define CONFIG_PNG_DECODER 0
+#define CONFIG_PPM_DECODER 0
+#define CONFIG_PRORES_DECODER 0
+#define CONFIG_PROSUMER_DECODER 0
+#define CONFIG_PSD_DECODER 0
+#define CONFIG_PTX_DECODER 0
+#define CONFIG_QDRAW_DECODER 0
+#define CONFIG_QOI_DECODER 0
+#define CONFIG_QPEG_DECODER 0
+#define CONFIG_QTRLE_DECODER 0
+#define CONFIG_R10K_DECODER 0
+#define CONFIG_R210_DECODER 0
+#define CONFIG_RASC_DECODER 0
+#define CONFIG_RAWVIDEO_DECODER 0
+#define CONFIG_RL2_DECODER 0
+#define CONFIG_ROQ_DECODER 0
+#define CONFIG_RPZA_DECODER 0
+#define CONFIG_RSCC_DECODER 0
+#define CONFIG_RV10_DECODER 0
+#define CONFIG_RV20_DECODER 0
+#define CONFIG_RV30_DECODER 0
+#define CONFIG_RV40_DECODER 0
+#define CONFIG_S302M_DECODER 0
+#define CONFIG_SANM_DECODER 0
+#define CONFIG_SCPR_DECODER 0
+#define CONFIG_SCREENPRESSO_DECODER 0
+#define CONFIG_SGA_DECODER 0
+#define CONFIG_SGI_DECODER 0
+#define CONFIG_SGIRLE_DECODER 0
+#define CONFIG_SHEERVIDEO_DECODER 0
+#define CONFIG_SIMBIOSIS_IMX_DECODER 0
+#define CONFIG_SMACKER_DECODER 0
+#define CONFIG_SMC_DECODER 0
+#define CONFIG_SMVJPEG_DECODER 0
+#define CONFIG_SNOW_DECODER 0
+#define CONFIG_SP5X_DECODER 0
+#define CONFIG_SPEEDHQ_DECODER 0
+#define CONFIG_SPEEX_DECODER 0
+#define CONFIG_SRGC_DECODER 0
+#define CONFIG_SUNRAST_DECODER 0
+#define CONFIG_SVQ1_DECODER 0
+#define CONFIG_SVQ3_DECODER 0
+#define CONFIG_TARGA_DECODER 0
+#define CONFIG_TARGA_Y216_DECODER 0
+#define CONFIG_TDSC_DECODER 0
+#define CONFIG_THEORA_DECODER 0
+#define CONFIG_THP_DECODER 0
+#define CONFIG_TIERTEXSEQVIDEO_DECODER 0
+#define CONFIG_TIFF_DECODER 0
+#define CONFIG_TMV_DECODER 0
+#define CONFIG_TRUEMOTION1_DECODER 0
+#define CONFIG_TRUEMOTION2_DECODER 0
+#define CONFIG_TRUEMOTION2RT_DECODER 0
+#define CONFIG_TSCC_DECODER 0
+#define CONFIG_TSCC2_DECODER 0
+#define CONFIG_TXD_DECODER 0
+#define CONFIG_ULTI_DECODER 0
+#define CONFIG_UTVIDEO_DECODER 0
+#define CONFIG_V210_DECODER 0
+#define CONFIG_V210X_DECODER 0
+#define CONFIG_V308_DECODER 0
+#define CONFIG_V408_DECODER 0
+#define CONFIG_V410_DECODER 0
+#define CONFIG_VB_DECODER 0
+#define CONFIG_VBN_DECODER 0
+#define CONFIG_VBLE_DECODER 0
+#define CONFIG_VC1_DECODER 0
+#define CONFIG_VC1_CRYSTALHD_DECODER 0
+#define CONFIG_VC1IMAGE_DECODER 0
+#define CONFIG_VC1_MMAL_DECODER 0
+#define CONFIG_VC1_QSV_DECODER 0
+#define CONFIG_VC1_V4L2M2M_DECODER 0
+#define CONFIG_VCR1_DECODER 0
+#define CONFIG_VMDVIDEO_DECODER 0
+#define CONFIG_VMNC_DECODER 0
+#define CONFIG_VP3_DECODER 0
+#define CONFIG_VP4_DECODER 0
+#define CONFIG_VP5_DECODER 0
+#define CONFIG_VP6_DECODER 0
+#define CONFIG_VP6A_DECODER 0
+#define CONFIG_VP6F_DECODER 0
+#define CONFIG_VP7_DECODER 0
+#define CONFIG_VP8_DECODER 0
+#define CONFIG_VP8_RKMPP_DECODER 0
+#define CONFIG_VP8_V4L2M2M_DECODER 0
+#define CONFIG_VP9_DECODER 0
+#define CONFIG_VP9_RKMPP_DECODER 0
+#define CONFIG_VP9_V4L2M2M_DECODER 0
+#define CONFIG_VQA_DECODER 0
+#define CONFIG_WEBP_DECODER 0
+#define CONFIG_WCMV_DECODER 0
+#define CONFIG_WRAPPED_AVFRAME_DECODER 0
+#define CONFIG_WMV1_DECODER 0
+#define CONFIG_WMV2_DECODER 0
+#define CONFIG_WMV3_DECODER 0
+#define CONFIG_WMV3_CRYSTALHD_DECODER 0
+#define CONFIG_WMV3IMAGE_DECODER 0
+#define CONFIG_WNV1_DECODER 0
+#define CONFIG_XAN_WC3_DECODER 0
+#define CONFIG_XAN_WC4_DECODER 0
+#define CONFIG_XBM_DECODER 0
+#define CONFIG_XFACE_DECODER 0
+#define CONFIG_XL_DECODER 0
+#define CONFIG_XPM_DECODER 0
+#define CONFIG_XWD_DECODER 0
+#define CONFIG_Y41P_DECODER 0
+#define CONFIG_YLC_DECODER 0
+#define CONFIG_YOP_DECODER 0
+#define CONFIG_YUV4_DECODER 0
+#define CONFIG_ZERO12V_DECODER 0
+#define CONFIG_ZEROCODEC_DECODER 0
+#define CONFIG_ZLIB_DECODER 0
+#define CONFIG_ZMBV_DECODER 0
+#define CONFIG_AAC_DECODER 0
+#define CONFIG_AAC_FIXED_DECODER 0
+#define CONFIG_AAC_LATM_DECODER 0
+#define CONFIG_AC3_DECODER 0
+#define CONFIG_AC3_FIXED_DECODER 0
+#define CONFIG_ACELP_KELVIN_DECODER 0
+#define CONFIG_ALAC_DECODER 0
+#define CONFIG_ALS_DECODER 0
+#define CONFIG_AMRNB_DECODER 0
+#define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APE_DECODER 0
+#define CONFIG_APTX_DECODER 0
+#define CONFIG_APTX_HD_DECODER 0
+#define CONFIG_ATRAC1_DECODER 0
+#define CONFIG_ATRAC3_DECODER 0
+#define CONFIG_ATRAC3AL_DECODER 0
+#define CONFIG_ATRAC3P_DECODER 0
+#define CONFIG_ATRAC3PAL_DECODER 0
+#define CONFIG_ATRAC9_DECODER 0
+#define CONFIG_BINKAUDIO_DCT_DECODER 0
+#define CONFIG_BINKAUDIO_RDFT_DECODER 0
+#define CONFIG_BMV_AUDIO_DECODER 0
+#define CONFIG_COOK_DECODER 0
+#define CONFIG_DCA_DECODER 0
+#define CONFIG_DFPWM_DECODER 0
+#define CONFIG_DOLBY_E_DECODER 0
+#define CONFIG_DSD_LSBF_DECODER 0
+#define CONFIG_DSD_MSBF_DECODER 0
+#define CONFIG_DSD_LSBF_PLANAR_DECODER 0
+#define CONFIG_DSD_MSBF_PLANAR_DECODER 0
+#define CONFIG_DSICINAUDIO_DECODER 0
+#define CONFIG_DSS_SP_DECODER 0
+#define CONFIG_DST_DECODER 0
+#define CONFIG_EAC3_DECODER 0
+#define CONFIG_EVRC_DECODER 0
+#define CONFIG_FASTAUDIO_DECODER 0
+#define CONFIG_FFWAVESYNTH_DECODER 0
+#define CONFIG_FLAC_DECODER 1
+#define CONFIG_G723_1_DECODER 0
+#define CONFIG_G729_DECODER 0
+#define CONFIG_GSM_DECODER 0
+#define CONFIG_GSM_MS_DECODER 0
+#define CONFIG_HCA_DECODER 0
+#define CONFIG_HCOM_DECODER 0
+#define CONFIG_IAC_DECODER 0
+#define CONFIG_ILBC_DECODER 0
+#define CONFIG_IMC_DECODER 0
+#define CONFIG_INTERPLAY_ACM_DECODER 0
+#define CONFIG_MACE3_DECODER 0
+#define CONFIG_MACE6_DECODER 0
+#define CONFIG_METASOUND_DECODER 0
+#define CONFIG_MLP_DECODER 0
+#define CONFIG_MP1_DECODER 0
+#define CONFIG_MP1FLOAT_DECODER 0
+#define CONFIG_MP2_DECODER 0
+#define CONFIG_MP2FLOAT_DECODER 0
+#define CONFIG_MP3FLOAT_DECODER 0
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_MP3ADUFLOAT_DECODER 0
+#define CONFIG_MP3ADU_DECODER 0
+#define CONFIG_MP3ON4FLOAT_DECODER 0
+#define CONFIG_MP3ON4_DECODER 0
+#define CONFIG_MPC7_DECODER 0
+#define CONFIG_MPC8_DECODER 0
+#define CONFIG_MSNSIREN_DECODER 0
+#define CONFIG_NELLYMOSER_DECODER 0
+#define CONFIG_ON2AVC_DECODER 0
+#define CONFIG_OPUS_DECODER 0
+#define CONFIG_PAF_AUDIO_DECODER 0
+#define CONFIG_QCELP_DECODER 0
+#define CONFIG_QDM2_DECODER 0
+#define CONFIG_QDMC_DECODER 0
+#define CONFIG_RA_144_DECODER 0
+#define CONFIG_RA_288_DECODER 0
+#define CONFIG_RALF_DECODER 0
+#define CONFIG_SBC_DECODER 0
+#define CONFIG_SHORTEN_DECODER 0
+#define CONFIG_SIPR_DECODER 0
+#define CONFIG_SIREN_DECODER 0
+#define CONFIG_SMACKAUD_DECODER 0
+#define CONFIG_SONIC_DECODER 0
+#define CONFIG_TAK_DECODER 0
+#define CONFIG_TRUEHD_DECODER 0
+#define CONFIG_TRUESPEECH_DECODER 0
+#define CONFIG_TTA_DECODER 0
+#define CONFIG_TWINVQ_DECODER 0
+#define CONFIG_VMDAUDIO_DECODER 0
+#define CONFIG_VORBIS_DECODER 0
+#define CONFIG_WAVPACK_DECODER 0
+#define CONFIG_WMALOSSLESS_DECODER 0
+#define CONFIG_WMAPRO_DECODER 0
+#define CONFIG_WMAV1_DECODER 0
+#define CONFIG_WMAV2_DECODER 0
+#define CONFIG_WMAVOICE_DECODER 0
+#define CONFIG_WS_SND1_DECODER 0
+#define CONFIG_XMA1_DECODER 0
+#define CONFIG_XMA2_DECODER 0
+#define CONFIG_PCM_ALAW_DECODER 0
+#define CONFIG_PCM_BLURAY_DECODER 0
+#define CONFIG_PCM_DVD_DECODER 0
+#define CONFIG_PCM_F16LE_DECODER 0
+#define CONFIG_PCM_F24LE_DECODER 0
+#define CONFIG_PCM_F32BE_DECODER 0
+#define CONFIG_PCM_F32LE_DECODER 0
+#define CONFIG_PCM_F64BE_DECODER 0
+#define CONFIG_PCM_F64LE_DECODER 0
+#define CONFIG_PCM_LXF_DECODER 0
+#define CONFIG_PCM_MULAW_DECODER 0
+#define CONFIG_PCM_S8_DECODER 0
+#define CONFIG_PCM_S8_PLANAR_DECODER 0
+#define CONFIG_PCM_S16BE_DECODER 0
+#define CONFIG_PCM_S16BE_PLANAR_DECODER 0
+#define CONFIG_PCM_S16LE_DECODER 0
+#define CONFIG_PCM_S16LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S24BE_DECODER 0
+#define CONFIG_PCM_S24DAUD_DECODER 0
+#define CONFIG_PCM_S24LE_DECODER 0
+#define CONFIG_PCM_S24LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S32BE_DECODER 0
+#define CONFIG_PCM_S32LE_DECODER 0
+#define CONFIG_PCM_S32LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S64BE_DECODER 0
+#define CONFIG_PCM_S64LE_DECODER 0
+#define CONFIG_PCM_SGA_DECODER 0
+#define CONFIG_PCM_U8_DECODER 0
+#define CONFIG_PCM_U16BE_DECODER 0
+#define CONFIG_PCM_U16LE_DECODER 0
+#define CONFIG_PCM_U24BE_DECODER 0
+#define CONFIG_PCM_U24LE_DECODER 0
+#define CONFIG_PCM_U32BE_DECODER 0
+#define CONFIG_PCM_U32LE_DECODER 0
+#define CONFIG_PCM_VIDC_DECODER 0
+#define CONFIG_DERF_DPCM_DECODER 0
+#define CONFIG_GREMLIN_DPCM_DECODER 0
+#define CONFIG_INTERPLAY_DPCM_DECODER 0
+#define CONFIG_ROQ_DPCM_DECODER 0
+#define CONFIG_SDX2_DPCM_DECODER 0
+#define CONFIG_SOL_DPCM_DECODER 0
+#define CONFIG_XAN_DPCM_DECODER 0
+#define CONFIG_ADPCM_4XM_DECODER 0
+#define CONFIG_ADPCM_ADX_DECODER 0
+#define CONFIG_ADPCM_AFC_DECODER 0
+#define CONFIG_ADPCM_AGM_DECODER 0
+#define CONFIG_ADPCM_AICA_DECODER 0
+#define CONFIG_ADPCM_ARGO_DECODER 0
+#define CONFIG_ADPCM_CT_DECODER 0
+#define CONFIG_ADPCM_DTK_DECODER 0
+#define CONFIG_ADPCM_EA_DECODER 0
+#define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 0
+#define CONFIG_ADPCM_EA_R1_DECODER 0
+#define CONFIG_ADPCM_EA_R2_DECODER 0
+#define CONFIG_ADPCM_EA_R3_DECODER 0
+#define CONFIG_ADPCM_EA_XAS_DECODER 0
+#define CONFIG_ADPCM_G722_DECODER 0
+#define CONFIG_ADPCM_G726_DECODER 0
+#define CONFIG_ADPCM_G726LE_DECODER 0
+#define CONFIG_ADPCM_IMA_ACORN_DECODER 0
+#define CONFIG_ADPCM_IMA_AMV_DECODER 0
+#define CONFIG_ADPCM_IMA_ALP_DECODER 0
+#define CONFIG_ADPCM_IMA_APC_DECODER 0
+#define CONFIG_ADPCM_IMA_APM_DECODER 0
+#define CONFIG_ADPCM_IMA_CUNNING_DECODER 0
+#define CONFIG_ADPCM_IMA_DAT4_DECODER 0
+#define CONFIG_ADPCM_IMA_DK3_DECODER 0
+#define CONFIG_ADPCM_IMA_DK4_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_EACS_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 0
+#define CONFIG_ADPCM_IMA_ISS_DECODER 0
+#define CONFIG_ADPCM_IMA_MOFLEX_DECODER 0
+#define CONFIG_ADPCM_IMA_MTF_DECODER 0
+#define CONFIG_ADPCM_IMA_OKI_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_DECODER 0
+#define CONFIG_ADPCM_IMA_RAD_DECODER 0
+#define CONFIG_ADPCM_IMA_SSI_DECODER 0
+#define CONFIG_ADPCM_IMA_SMJPEG_DECODER 0
+#define CONFIG_ADPCM_IMA_WAV_DECODER 0
+#define CONFIG_ADPCM_IMA_WS_DECODER 0
+#define CONFIG_ADPCM_MS_DECODER 0
+#define CONFIG_ADPCM_MTAF_DECODER 0
+#define CONFIG_ADPCM_PSX_DECODER 0
+#define CONFIG_ADPCM_SBPRO_2_DECODER 0
+#define CONFIG_ADPCM_SBPRO_3_DECODER 0
+#define CONFIG_ADPCM_SBPRO_4_DECODER 0
+#define CONFIG_ADPCM_SWF_DECODER 0
+#define CONFIG_ADPCM_THP_DECODER 0
+#define CONFIG_ADPCM_THP_LE_DECODER 0
+#define CONFIG_ADPCM_VIMA_DECODER 0
+#define CONFIG_ADPCM_XA_DECODER 0
+#define CONFIG_ADPCM_YAMAHA_DECODER 0
+#define CONFIG_ADPCM_ZORK_DECODER 0
+#define CONFIG_SSA_DECODER 0
+#define CONFIG_ASS_DECODER 0
+#define CONFIG_CCAPTION_DECODER 0
+#define CONFIG_DVBSUB_DECODER 0
+#define CONFIG_DVDSUB_DECODER 0
+#define CONFIG_JACOSUB_DECODER 0
+#define CONFIG_MICRODVD_DECODER 0
+#define CONFIG_MOVTEXT_DECODER 0
+#define CONFIG_MPL2_DECODER 0
+#define CONFIG_PGSSUB_DECODER 0
+#define CONFIG_PJS_DECODER 0
+#define CONFIG_REALTEXT_DECODER 0
+#define CONFIG_SAMI_DECODER 0
+#define CONFIG_SRT_DECODER 0
+#define CONFIG_STL_DECODER 0
+#define CONFIG_SUBRIP_DECODER 0
+#define CONFIG_SUBVIEWER_DECODER 0
+#define CONFIG_SUBVIEWER1_DECODER 0
+#define CONFIG_TEXT_DECODER 0
+#define CONFIG_VPLAYER_DECODER 0
+#define CONFIG_WEBVTT_DECODER 0
+#define CONFIG_XSUB_DECODER 0
+#define CONFIG_AAC_AT_DECODER 0
+#define CONFIG_AC3_AT_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_AT_DECODER 0
+#define CONFIG_ALAC_AT_DECODER 0
+#define CONFIG_AMR_NB_AT_DECODER 0
+#define CONFIG_EAC3_AT_DECODER 0
+#define CONFIG_GSM_MS_AT_DECODER 0
+#define CONFIG_ILBC_AT_DECODER 0
+#define CONFIG_MP1_AT_DECODER 0
+#define CONFIG_MP2_AT_DECODER 0
+#define CONFIG_MP3_AT_DECODER 0
+#define CONFIG_PCM_ALAW_AT_DECODER 0
+#define CONFIG_PCM_MULAW_AT_DECODER 0
+#define CONFIG_QDMC_AT_DECODER 0
+#define CONFIG_QDM2_AT_DECODER 0
+#define CONFIG_LIBARIBB24_DECODER 0
+#define CONFIG_LIBCELT_DECODER 0
+#define CONFIG_LIBCODEC2_DECODER 0
+#define CONFIG_LIBDAV1D_DECODER 0
+#define CONFIG_LIBDAVS2_DECODER 0
+#define CONFIG_LIBFDK_AAC_DECODER 0
+#define CONFIG_LIBGSM_DECODER 0
+#define CONFIG_LIBGSM_MS_DECODER 0
+#define CONFIG_LIBILBC_DECODER 0
+#define CONFIG_LIBJXL_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
+#define CONFIG_LIBOPENJPEG_DECODER 0
+#define CONFIG_LIBOPUS_DECODER 0
+#define CONFIG_LIBRSVG_DECODER 0
+#define CONFIG_LIBSPEEX_DECODER 0
+#define CONFIG_LIBUAVS3D_DECODER 0
+#define CONFIG_LIBVORBIS_DECODER 0
+#define CONFIG_LIBVPX_VP8_DECODER 0
+#define CONFIG_LIBVPX_VP9_DECODER 0
+#define CONFIG_LIBZVBI_TELETEXT_DECODER 0
+#define CONFIG_BINTEXT_DECODER 0
+#define CONFIG_XBIN_DECODER 0
+#define CONFIG_IDF_DECODER 0
+#define CONFIG_LIBAOM_AV1_DECODER 0
+#define CONFIG_AV1_DECODER 0
+#define CONFIG_AV1_CUVID_DECODER 0
+#define CONFIG_AV1_QSV_DECODER 0
+#define CONFIG_LIBOPENH264_DECODER 0
+#define CONFIG_H264_CUVID_DECODER 0
+#define CONFIG_HEVC_CUVID_DECODER 0
+#define CONFIG_HEVC_MEDIACODEC_DECODER 0
+#define CONFIG_MJPEG_CUVID_DECODER 0
+#define CONFIG_MJPEG_QSV_DECODER 0
+#define CONFIG_MPEG1_CUVID_DECODER 0
+#define CONFIG_MPEG2_CUVID_DECODER 0
+#define CONFIG_MPEG4_CUVID_DECODER 0
+#define CONFIG_MPEG4_MEDIACODEC_DECODER 0
+#define CONFIG_VC1_CUVID_DECODER 0
+#define CONFIG_VP8_CUVID_DECODER 0
+#define CONFIG_VP8_MEDIACODEC_DECODER 0
+#define CONFIG_VP8_QSV_DECODER 0
+#define CONFIG_VP9_CUVID_DECODER 0
+#define CONFIG_VP9_MEDIACODEC_DECODER 0
+#define CONFIG_VP9_QSV_DECODER 0
+#define CONFIG_A64MULTI_ENCODER 0
+#define CONFIG_A64MULTI5_ENCODER 0
+#define CONFIG_ALIAS_PIX_ENCODER 0
+#define CONFIG_AMV_ENCODER 0
+#define CONFIG_APNG_ENCODER 0
+#define CONFIG_ASV1_ENCODER 0
+#define CONFIG_ASV2_ENCODER 0
+#define CONFIG_AVRP_ENCODER 0
+#define CONFIG_AVUI_ENCODER 0
+#define CONFIG_AYUV_ENCODER 0
+#define CONFIG_BITPACKED_ENCODER 0
+#define CONFIG_BMP_ENCODER 0
+#define CONFIG_CFHD_ENCODER 0
+#define CONFIG_CINEPAK_ENCODER 0
+#define CONFIG_CLJR_ENCODER 0
+#define CONFIG_COMFORTNOISE_ENCODER 0
+#define CONFIG_DNXHD_ENCODER 0
+#define CONFIG_DPX_ENCODER 0
+#define CONFIG_DVVIDEO_ENCODER 0
+#define CONFIG_EXR_ENCODER 0
+#define CONFIG_FFV1_ENCODER 0
+#define CONFIG_FFVHUFF_ENCODER 0
+#define CONFIG_FITS_ENCODER 0
+#define CONFIG_FLASHSV_ENCODER 0
+#define CONFIG_FLASHSV2_ENCODER 0
+#define CONFIG_FLV_ENCODER 0
+#define CONFIG_GIF_ENCODER 0
+#define CONFIG_H261_ENCODER 0
+#define CONFIG_H263_ENCODER 0
+#define CONFIG_H263P_ENCODER 0
+#define CONFIG_HAP_ENCODER 0
+#define CONFIG_HUFFYUV_ENCODER 0
+#define CONFIG_JPEG2000_ENCODER 0
+#define CONFIG_JPEGLS_ENCODER 0
+#define CONFIG_LJPEG_ENCODER 0
+#define CONFIG_MAGICYUV_ENCODER 0
+#define CONFIG_MJPEG_ENCODER 0
+#define CONFIG_MPEG1VIDEO_ENCODER 0
+#define CONFIG_MPEG2VIDEO_ENCODER 0
+#define CONFIG_MPEG4_ENCODER 0
+#define CONFIG_MSMPEG4V2_ENCODER 0
+#define CONFIG_MSMPEG4V3_ENCODER 0
+#define CONFIG_MSVIDEO1_ENCODER 0
+#define CONFIG_PAM_ENCODER 0
+#define CONFIG_PBM_ENCODER 0
+#define CONFIG_PCX_ENCODER 0
+#define CONFIG_PFM_ENCODER 0
+#define CONFIG_PGM_ENCODER 0
+#define CONFIG_PGMYUV_ENCODER 0
+#define CONFIG_PNG_ENCODER 0
+#define CONFIG_PPM_ENCODER 0
+#define CONFIG_PRORES_ENCODER 0
+#define CONFIG_PRORES_AW_ENCODER 0
+#define CONFIG_PRORES_KS_ENCODER 0
+#define CONFIG_QOI_ENCODER 0
+#define CONFIG_QTRLE_ENCODER 0
+#define CONFIG_R10K_ENCODER 0
+#define CONFIG_R210_ENCODER 0
+#define CONFIG_RAWVIDEO_ENCODER 0
+#define CONFIG_ROQ_ENCODER 0
+#define CONFIG_RPZA_ENCODER 0
+#define CONFIG_RV10_ENCODER 0
+#define CONFIG_RV20_ENCODER 0
+#define CONFIG_S302M_ENCODER 0
+#define CONFIG_SGI_ENCODER 0
+#define CONFIG_SMC_ENCODER 0
+#define CONFIG_SNOW_ENCODER 0
+#define CONFIG_SPEEDHQ_ENCODER 0
+#define CONFIG_SUNRAST_ENCODER 0
+#define CONFIG_SVQ1_ENCODER 0
+#define CONFIG_TARGA_ENCODER 0
+#define CONFIG_TIFF_ENCODER 0
+#define CONFIG_UTVIDEO_ENCODER 0
+#define CONFIG_V210_ENCODER 0
+#define CONFIG_V308_ENCODER 0
+#define CONFIG_V408_ENCODER 0
+#define CONFIG_V410_ENCODER 0
+#define CONFIG_VBN_ENCODER 0
+#define CONFIG_VC2_ENCODER 0
+#define CONFIG_WRAPPED_AVFRAME_ENCODER 0
+#define CONFIG_WMV1_ENCODER 0
+#define CONFIG_WMV2_ENCODER 0
+#define CONFIG_XBM_ENCODER 0
+#define CONFIG_XFACE_ENCODER 0
+#define CONFIG_XWD_ENCODER 0
+#define CONFIG_Y41P_ENCODER 0
+#define CONFIG_YUV4_ENCODER 0
+#define CONFIG_ZLIB_ENCODER 0
+#define CONFIG_ZMBV_ENCODER 0
+#define CONFIG_AAC_ENCODER 0
+#define CONFIG_AC3_ENCODER 0
+#define CONFIG_AC3_FIXED_ENCODER 0
+#define CONFIG_ALAC_ENCODER 0
+#define CONFIG_APTX_ENCODER 0
+#define CONFIG_APTX_HD_ENCODER 0
+#define CONFIG_DCA_ENCODER 0
+#define CONFIG_DFPWM_ENCODER 0
+#define CONFIG_EAC3_ENCODER 0
+#define CONFIG_FLAC_ENCODER 0
+#define CONFIG_G723_1_ENCODER 0
+#define CONFIG_MLP_ENCODER 0
+#define CONFIG_MP2_ENCODER 0
+#define CONFIG_MP2FIXED_ENCODER 0
+#define CONFIG_NELLYMOSER_ENCODER 0
+#define CONFIG_OPUS_ENCODER 0
+#define CONFIG_RA_144_ENCODER 0
+#define CONFIG_SBC_ENCODER 0
+#define CONFIG_SONIC_ENCODER 0
+#define CONFIG_SONIC_LS_ENCODER 0
+#define CONFIG_TRUEHD_ENCODER 0
+#define CONFIG_TTA_ENCODER 0
+#define CONFIG_VORBIS_ENCODER 0
+#define CONFIG_WAVPACK_ENCODER 0
+#define CONFIG_WMAV1_ENCODER 0
+#define CONFIG_WMAV2_ENCODER 0
+#define CONFIG_PCM_ALAW_ENCODER 0
+#define CONFIG_PCM_BLURAY_ENCODER 0
+#define CONFIG_PCM_DVD_ENCODER 0
+#define CONFIG_PCM_F32BE_ENCODER 0
+#define CONFIG_PCM_F32LE_ENCODER 0
+#define CONFIG_PCM_F64BE_ENCODER 0
+#define CONFIG_PCM_F64LE_ENCODER 0
+#define CONFIG_PCM_MULAW_ENCODER 0
+#define CONFIG_PCM_S8_ENCODER 0
+#define CONFIG_PCM_S8_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16BE_ENCODER 0
+#define CONFIG_PCM_S16BE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16LE_ENCODER 0
+#define CONFIG_PCM_S16LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S24BE_ENCODER 0
+#define CONFIG_PCM_S24DAUD_ENCODER 0
+#define CONFIG_PCM_S24LE_ENCODER 0
+#define CONFIG_PCM_S24LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S32BE_ENCODER 0
+#define CONFIG_PCM_S32LE_ENCODER 0
+#define CONFIG_PCM_S32LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S64BE_ENCODER 0
+#define CONFIG_PCM_S64LE_ENCODER 0
+#define CONFIG_PCM_U8_ENCODER 0
+#define CONFIG_PCM_U16BE_ENCODER 0
+#define CONFIG_PCM_U16LE_ENCODER 0
+#define CONFIG_PCM_U24BE_ENCODER 0
+#define CONFIG_PCM_U24LE_ENCODER 0
+#define CONFIG_PCM_U32BE_ENCODER 0
+#define CONFIG_PCM_U32LE_ENCODER 0
+#define CONFIG_PCM_VIDC_ENCODER 0
+#define CONFIG_ROQ_DPCM_ENCODER 0
+#define CONFIG_ADPCM_ADX_ENCODER 0
+#define CONFIG_ADPCM_ARGO_ENCODER 0
+#define CONFIG_ADPCM_G722_ENCODER 0
+#define CONFIG_ADPCM_G726_ENCODER 0
+#define CONFIG_ADPCM_G726LE_ENCODER 0
+#define CONFIG_ADPCM_IMA_AMV_ENCODER 0
+#define CONFIG_ADPCM_IMA_ALP_ENCODER 0
+#define CONFIG_ADPCM_IMA_APM_ENCODER 0
+#define CONFIG_ADPCM_IMA_QT_ENCODER 0
+#define CONFIG_ADPCM_IMA_SSI_ENCODER 0
+#define CONFIG_ADPCM_IMA_WAV_ENCODER 0
+#define CONFIG_ADPCM_IMA_WS_ENCODER 0
+#define CONFIG_ADPCM_MS_ENCODER 0
+#define CONFIG_ADPCM_SWF_ENCODER 0
+#define CONFIG_ADPCM_YAMAHA_ENCODER 0
+#define CONFIG_SSA_ENCODER 0
+#define CONFIG_ASS_ENCODER 0
+#define CONFIG_DVBSUB_ENCODER 0
+#define CONFIG_DVDSUB_ENCODER 0
+#define CONFIG_MOVTEXT_ENCODER 0
+#define CONFIG_SRT_ENCODER 0
+#define CONFIG_SUBRIP_ENCODER 0
+#define CONFIG_TEXT_ENCODER 0
+#define CONFIG_TTML_ENCODER 0
+#define CONFIG_WEBVTT_ENCODER 0
+#define CONFIG_XSUB_ENCODER 0
+#define CONFIG_AAC_AT_ENCODER 0
+#define CONFIG_ALAC_AT_ENCODER 0
+#define CONFIG_ILBC_AT_ENCODER 0
+#define CONFIG_PCM_ALAW_AT_ENCODER 0
+#define CONFIG_PCM_MULAW_AT_ENCODER 0
+#define CONFIG_LIBAOM_AV1_ENCODER 0
+#define CONFIG_LIBCODEC2_ENCODER 0
+#define CONFIG_LIBFDK_AAC_ENCODER 0
+#define CONFIG_LIBGSM_ENCODER 0
+#define CONFIG_LIBGSM_MS_ENCODER 0
+#define CONFIG_LIBILBC_ENCODER 0
+#define CONFIG_LIBJXL_ENCODER 0
+#define CONFIG_LIBMP3LAME_ENCODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
+#define CONFIG_LIBOPENJPEG_ENCODER 0
+#define CONFIG_LIBOPUS_ENCODER 0
+#define CONFIG_LIBRAV1E_ENCODER 0
+#define CONFIG_LIBSHINE_ENCODER 0
+#define CONFIG_LIBSPEEX_ENCODER 0
+#define CONFIG_LIBSVTAV1_ENCODER 0
+#define CONFIG_LIBTHEORA_ENCODER 0
+#define CONFIG_LIBTWOLAME_ENCODER 0
+#define CONFIG_LIBVO_AMRWBENC_ENCODER 0
+#define CONFIG_LIBVORBIS_ENCODER 0
+#define CONFIG_LIBVPX_VP8_ENCODER 0
+#define CONFIG_LIBVPX_VP9_ENCODER 0
+#define CONFIG_LIBWEBP_ANIM_ENCODER 0
+#define CONFIG_LIBWEBP_ENCODER 0
+#define CONFIG_LIBX262_ENCODER 0
+#define CONFIG_LIBX264_ENCODER 0
+#define CONFIG_LIBX264RGB_ENCODER 0
+#define CONFIG_LIBX265_ENCODER 0
+#define CONFIG_LIBXAVS_ENCODER 0
+#define CONFIG_LIBXAVS2_ENCODER 0
+#define CONFIG_LIBXVID_ENCODER 0
+#define CONFIG_AAC_MF_ENCODER 0
+#define CONFIG_AC3_MF_ENCODER 0
+#define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_LIBOPENH264_ENCODER 0
+#define CONFIG_H264_AMF_ENCODER 0
+#define CONFIG_H264_MF_ENCODER 0
+#define CONFIG_H264_NVENC_ENCODER 0
+#define CONFIG_H264_OMX_ENCODER 0
+#define CONFIG_H264_QSV_ENCODER 0
+#define CONFIG_H264_V4L2M2M_ENCODER 0
+#define CONFIG_H264_VAAPI_ENCODER 0
+#define CONFIG_H264_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_HEVC_AMF_ENCODER 0
+#define CONFIG_HEVC_MF_ENCODER 0
+#define CONFIG_HEVC_NVENC_ENCODER 0
+#define CONFIG_HEVC_QSV_ENCODER 0
+#define CONFIG_HEVC_V4L2M2M_ENCODER 0
+#define CONFIG_HEVC_VAAPI_ENCODER 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_LIBKVAZAAR_ENCODER 0
+#define CONFIG_MJPEG_QSV_ENCODER 0
+#define CONFIG_MJPEG_VAAPI_ENCODER 0
+#define CONFIG_MP3_MF_ENCODER 0
+#define CONFIG_MPEG2_QSV_ENCODER 0
+#define CONFIG_MPEG2_VAAPI_ENCODER 0
+#define CONFIG_MPEG4_OMX_ENCODER 0
+#define CONFIG_MPEG4_V4L2M2M_ENCODER 0
+#define CONFIG_PRORES_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_VP8_V4L2M2M_ENCODER 0
+#define CONFIG_VP8_VAAPI_ENCODER 0
+#define CONFIG_VP9_VAAPI_ENCODER 0
+#define CONFIG_VP9_QSV_ENCODER 0
+#define CONFIG_AV1_D3D11VA_HWACCEL 0
+#define CONFIG_AV1_D3D11VA2_HWACCEL 0
+#define CONFIG_AV1_DXVA2_HWACCEL 0
+#define CONFIG_AV1_NVDEC_HWACCEL 0
+#define CONFIG_AV1_VAAPI_HWACCEL 0
+#define CONFIG_AV1_VDPAU_HWACCEL 0
+#define CONFIG_H263_VAAPI_HWACCEL 0
+#define CONFIG_H263_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_H264_D3D11VA_HWACCEL 0
+#define CONFIG_H264_D3D11VA2_HWACCEL 0
+#define CONFIG_H264_DXVA2_HWACCEL 0
+#define CONFIG_H264_NVDEC_HWACCEL 0
+#define CONFIG_H264_VAAPI_HWACCEL 0
+#define CONFIG_H264_VDPAU_HWACCEL 0
+#define CONFIG_H264_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA2_HWACCEL 0
+#define CONFIG_HEVC_DXVA2_HWACCEL 0
+#define CONFIG_HEVC_NVDEC_HWACCEL 0
+#define CONFIG_HEVC_VAAPI_HWACCEL 0
+#define CONFIG_HEVC_VDPAU_HWACCEL 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MJPEG_NVDEC_HWACCEL 0
+#define CONFIG_MJPEG_VAAPI_HWACCEL 0
+#define CONFIG_MPEG1_NVDEC_HWACCEL 0
+#define CONFIG_MPEG1_VDPAU_HWACCEL 0
+#define CONFIG_MPEG1_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA2_HWACCEL 0
+#define CONFIG_MPEG2_NVDEC_HWACCEL 0
+#define CONFIG_MPEG2_DXVA2_HWACCEL 0
+#define CONFIG_MPEG2_VAAPI_HWACCEL 0
+#define CONFIG_MPEG2_VDPAU_HWACCEL 0
+#define CONFIG_MPEG2_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG4_NVDEC_HWACCEL 0
+#define CONFIG_MPEG4_VAAPI_HWACCEL 0
+#define CONFIG_MPEG4_VDPAU_HWACCEL 0
+#define CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_PRORES_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_VC1_D3D11VA_HWACCEL 0
+#define CONFIG_VC1_D3D11VA2_HWACCEL 0
+#define CONFIG_VC1_DXVA2_HWACCEL 0
+#define CONFIG_VC1_NVDEC_HWACCEL 0
+#define CONFIG_VC1_VAAPI_HWACCEL 0
+#define CONFIG_VC1_VDPAU_HWACCEL 0
+#define CONFIG_VP8_NVDEC_HWACCEL 0
+#define CONFIG_VP8_VAAPI_HWACCEL 0
+#define CONFIG_VP9_D3D11VA_HWACCEL 0
+#define CONFIG_VP9_D3D11VA2_HWACCEL 0
+#define CONFIG_VP9_DXVA2_HWACCEL 0
+#define CONFIG_VP9_NVDEC_HWACCEL 0
+#define CONFIG_VP9_VAAPI_HWACCEL 0
+#define CONFIG_VP9_VDPAU_HWACCEL 0
+#define CONFIG_VP9_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA2_HWACCEL 0
+#define CONFIG_WMV3_DXVA2_HWACCEL 0
+#define CONFIG_WMV3_NVDEC_HWACCEL 0
+#define CONFIG_WMV3_VAAPI_HWACCEL 0
+#define CONFIG_WMV3_VDPAU_HWACCEL 0
+#define CONFIG_AAC_PARSER 0
+#define CONFIG_AAC_LATM_PARSER 0
+#define CONFIG_AC3_PARSER 0
+#define CONFIG_ADX_PARSER 0
+#define CONFIG_AMR_PARSER 0
+#define CONFIG_AV1_PARSER 0
+#define CONFIG_AVS2_PARSER 0
+#define CONFIG_AVS3_PARSER 0
+#define CONFIG_BMP_PARSER 0
+#define CONFIG_CAVSVIDEO_PARSER 0
+#define CONFIG_COOK_PARSER 0
+#define CONFIG_CRI_PARSER 0
+#define CONFIG_DCA_PARSER 0
+#define CONFIG_DIRAC_PARSER 0
+#define CONFIG_DNXHD_PARSER 0
+#define CONFIG_DOLBY_E_PARSER 0
+#define CONFIG_DPX_PARSER 0
+#define CONFIG_DVAUDIO_PARSER 0
+#define CONFIG_DVBSUB_PARSER 0
+#define CONFIG_DVDSUB_PARSER 0
+#define CONFIG_DVD_NAV_PARSER 0
+#define CONFIG_FLAC_PARSER 0
+#define CONFIG_G723_1_PARSER 0
+#define CONFIG_G729_PARSER 0
+#define CONFIG_GIF_PARSER 0
+#define CONFIG_GSM_PARSER 0
+#define CONFIG_H261_PARSER 0
+#define CONFIG_H263_PARSER 0
+#define CONFIG_H264_PARSER 0
+#define CONFIG_HEVC_PARSER 0
+#define CONFIG_IPU_PARSER 0
+#define CONFIG_JPEG2000_PARSER 0
+#define CONFIG_MJPEG_PARSER 0
+#define CONFIG_MLP_PARSER 0
+#define CONFIG_MPEG4VIDEO_PARSER 0
+#define CONFIG_MPEGAUDIO_PARSER 0
+#define CONFIG_MPEGVIDEO_PARSER 0
+#define CONFIG_OPUS_PARSER 0
+#define CONFIG_PNG_PARSER 0
+#define CONFIG_PNM_PARSER 0
+#define CONFIG_QOI_PARSER 0
+#define CONFIG_RV30_PARSER 0
+#define CONFIG_RV40_PARSER 0
+#define CONFIG_SBC_PARSER 0
+#define CONFIG_SIPR_PARSER 0
+#define CONFIG_TAK_PARSER 0
+#define CONFIG_VC1_PARSER 0
+#define CONFIG_VORBIS_PARSER 0
+#define CONFIG_VP3_PARSER 0
+#define CONFIG_VP8_PARSER 0
+#define CONFIG_VP9_PARSER 0
+#define CONFIG_WEBP_PARSER 0
+#define CONFIG_XBM_PARSER 0
+#define CONFIG_XMA_PARSER 0
+#define CONFIG_ALSA_INDEV 0
+#define CONFIG_ANDROID_CAMERA_INDEV 0
+#define CONFIG_AVFOUNDATION_INDEV 0
+#define CONFIG_BKTR_INDEV 0
+#define CONFIG_DECKLINK_INDEV 0
+#define CONFIG_DSHOW_INDEV 0
+#define CONFIG_FBDEV_INDEV 0
+#define CONFIG_GDIGRAB_INDEV 0
+#define CONFIG_IEC61883_INDEV 0
+#define CONFIG_JACK_INDEV 0
+#define CONFIG_KMSGRAB_INDEV 0
+#define CONFIG_LAVFI_INDEV 0
+#define CONFIG_OPENAL_INDEV 0
+#define CONFIG_OSS_INDEV 0
+#define CONFIG_PULSE_INDEV 0
+#define CONFIG_SNDIO_INDEV 0
+#define CONFIG_V4L2_INDEV 0
+#define CONFIG_VFWCAP_INDEV 0
+#define CONFIG_XCBGRAB_INDEV 0
+#define CONFIG_LIBCDIO_INDEV 0
+#define CONFIG_LIBDC1394_INDEV 0
+#define CONFIG_ALSA_OUTDEV 0
+#define CONFIG_AUDIOTOOLBOX_OUTDEV 0
+#define CONFIG_CACA_OUTDEV 0
+#define CONFIG_DECKLINK_OUTDEV 0
+#define CONFIG_FBDEV_OUTDEV 0
+#define CONFIG_OPENGL_OUTDEV 0
+#define CONFIG_OSS_OUTDEV 0
+#define CONFIG_PULSE_OUTDEV 0
+#define CONFIG_SDL2_OUTDEV 0
+#define CONFIG_SNDIO_OUTDEV 0
+#define CONFIG_V4L2_OUTDEV 0
+#define CONFIG_XV_OUTDEV 0
+#define CONFIG_ABENCH_FILTER 0
+#define CONFIG_ACOMPRESSOR_FILTER 0
+#define CONFIG_ACONTRAST_FILTER 0
+#define CONFIG_ACOPY_FILTER 0
+#define CONFIG_ACUE_FILTER 0
+#define CONFIG_ACROSSFADE_FILTER 0
+#define CONFIG_ACROSSOVER_FILTER 0
+#define CONFIG_ACRUSHER_FILTER 0
+#define CONFIG_ADECLICK_FILTER 0
+#define CONFIG_ADECLIP_FILTER 0
+#define CONFIG_ADECORRELATE_FILTER 0
+#define CONFIG_ADELAY_FILTER 0
+#define CONFIG_ADENORM_FILTER 0
+#define CONFIG_ADERIVATIVE_FILTER 0
+#define CONFIG_ADYNAMICEQUALIZER_FILTER 0
+#define CONFIG_ADYNAMICSMOOTH_FILTER 0
+#define CONFIG_AECHO_FILTER 0
+#define CONFIG_AEMPHASIS_FILTER 0
+#define CONFIG_AEVAL_FILTER 0
+#define CONFIG_AEXCITER_FILTER 0
+#define CONFIG_AFADE_FILTER 0
+#define CONFIG_AFFTDN_FILTER 0
+#define CONFIG_AFFTFILT_FILTER 0
+#define CONFIG_AFIR_FILTER 0
+#define CONFIG_AFORMAT_FILTER 0
+#define CONFIG_AFREQSHIFT_FILTER 0
+#define CONFIG_AFWTDN_FILTER 0
+#define CONFIG_AGATE_FILTER 0
+#define CONFIG_AIIR_FILTER 0
+#define CONFIG_AINTEGRAL_FILTER 0
+#define CONFIG_AINTERLEAVE_FILTER 0
+#define CONFIG_ALATENCY_FILTER 0
+#define CONFIG_ALIMITER_FILTER 0
+#define CONFIG_ALLPASS_FILTER 0
+#define CONFIG_ALOOP_FILTER 0
+#define CONFIG_AMERGE_FILTER 0
+#define CONFIG_AMETADATA_FILTER 0
+#define CONFIG_AMIX_FILTER 0
+#define CONFIG_AMULTIPLY_FILTER 0
+#define CONFIG_ANEQUALIZER_FILTER 0
+#define CONFIG_ANLMDN_FILTER 0
+#define CONFIG_ANLMF_FILTER 0
+#define CONFIG_ANLMS_FILTER 0
+#define CONFIG_ANULL_FILTER 0
+#define CONFIG_APAD_FILTER 0
+#define CONFIG_APERMS_FILTER 0
+#define CONFIG_APHASER_FILTER 0
+#define CONFIG_APHASESHIFT_FILTER 0
+#define CONFIG_APSYCLIP_FILTER 0
+#define CONFIG_APULSATOR_FILTER 0
+#define CONFIG_AREALTIME_FILTER 0
+#define CONFIG_ARESAMPLE_FILTER 0
+#define CONFIG_AREVERSE_FILTER 0
+#define CONFIG_ARNNDN_FILTER 0
+#define CONFIG_ASDR_FILTER 0
+#define CONFIG_ASEGMENT_FILTER 0
+#define CONFIG_ASELECT_FILTER 0
+#define CONFIG_ASENDCMD_FILTER 0
+#define CONFIG_ASETNSAMPLES_FILTER 0
+#define CONFIG_ASETPTS_FILTER 0
+#define CONFIG_ASETRATE_FILTER 0
+#define CONFIG_ASETTB_FILTER 0
+#define CONFIG_ASHOWINFO_FILTER 0
+#define CONFIG_ASIDEDATA_FILTER 0
+#define CONFIG_ASOFTCLIP_FILTER 0
+#define CONFIG_ASPECTRALSTATS_FILTER 0
+#define CONFIG_ASPLIT_FILTER 0
+#define CONFIG_ASR_FILTER 0
+#define CONFIG_ASTATS_FILTER 0
+#define CONFIG_ASTREAMSELECT_FILTER 0
+#define CONFIG_ASUBBOOST_FILTER 0
+#define CONFIG_ASUBCUT_FILTER 0
+#define CONFIG_ASUPERCUT_FILTER 0
+#define CONFIG_ASUPERPASS_FILTER 0
+#define CONFIG_ASUPERSTOP_FILTER 0
+#define CONFIG_ATEMPO_FILTER 0
+#define CONFIG_ATILT_FILTER 0
+#define CONFIG_ATRIM_FILTER 0
+#define CONFIG_AXCORRELATE_FILTER 0
+#define CONFIG_AZMQ_FILTER 0
+#define CONFIG_BANDPASS_FILTER 0
+#define CONFIG_BANDREJECT_FILTER 0
+#define CONFIG_BASS_FILTER 0
+#define CONFIG_BIQUAD_FILTER 0
+#define CONFIG_BS2B_FILTER 0
+#define CONFIG_CHANNELMAP_FILTER 0
+#define CONFIG_CHANNELSPLIT_FILTER 0
+#define CONFIG_CHORUS_FILTER 0
+#define CONFIG_COMPAND_FILTER 0
+#define CONFIG_COMPENSATIONDELAY_FILTER 0
+#define CONFIG_CROSSFEED_FILTER 0
+#define CONFIG_CRYSTALIZER_FILTER 0
+#define CONFIG_DCSHIFT_FILTER 0
+#define CONFIG_DEESSER_FILTER 0
+#define CONFIG_DIALOGUENHANCE_FILTER 0
+#define CONFIG_DRMETER_FILTER 0
+#define CONFIG_DYNAUDNORM_FILTER 0
+#define CONFIG_EARWAX_FILTER 0
+#define CONFIG_EBUR128_FILTER 0
+#define CONFIG_EQUALIZER_FILTER 0
+#define CONFIG_EXTRASTEREO_FILTER 0
+#define CONFIG_FIREQUALIZER_FILTER 0
+#define CONFIG_FLANGER_FILTER 0
+#define CONFIG_HAAS_FILTER 0
+#define CONFIG_HDCD_FILTER 0
+#define CONFIG_HEADPHONE_FILTER 0
+#define CONFIG_HIGHPASS_FILTER 0
+#define CONFIG_HIGHSHELF_FILTER 0
+#define CONFIG_JOIN_FILTER 0
+#define CONFIG_LADSPA_FILTER 0
+#define CONFIG_LOUDNORM_FILTER 0
+#define CONFIG_LOWPASS_FILTER 0
+#define CONFIG_LOWSHELF_FILTER 0
+#define CONFIG_LV2_FILTER 0
+#define CONFIG_MCOMPAND_FILTER 0
+#define CONFIG_PAN_FILTER 0
+#define CONFIG_REPLAYGAIN_FILTER 0
+#define CONFIG_RUBBERBAND_FILTER 0
+#define CONFIG_SIDECHAINCOMPRESS_FILTER 0
+#define CONFIG_SIDECHAINGATE_FILTER 0
+#define CONFIG_SILENCEDETECT_FILTER 0
+#define CONFIG_SILENCEREMOVE_FILTER 0
+#define CONFIG_SOFALIZER_FILTER 0
+#define CONFIG_SPEECHNORM_FILTER 0
+#define CONFIG_STEREOTOOLS_FILTER 0
+#define CONFIG_STEREOWIDEN_FILTER 0
+#define CONFIG_SUPEREQUALIZER_FILTER 0
+#define CONFIG_SURROUND_FILTER 0
+#define CONFIG_TILTSHELF_FILTER 0
+#define CONFIG_TREBLE_FILTER 0
+#define CONFIG_TREMOLO_FILTER 0
+#define CONFIG_VIBRATO_FILTER 0
+#define CONFIG_VIRTUALBASS_FILTER 0
+#define CONFIG_VOLUME_FILTER 0
+#define CONFIG_VOLUMEDETECT_FILTER 0
+#define CONFIG_AEVALSRC_FILTER 0
+#define CONFIG_AFIRSRC_FILTER 0
+#define CONFIG_ANOISESRC_FILTER 0
+#define CONFIG_ANULLSRC_FILTER 0
+#define CONFIG_FLITE_FILTER 0
+#define CONFIG_HILBERT_FILTER 0
+#define CONFIG_SINC_FILTER 0
+#define CONFIG_SINE_FILTER 0
+#define CONFIG_ANULLSINK_FILTER 0
+#define CONFIG_ADDROI_FILTER 0
+#define CONFIG_ALPHAEXTRACT_FILTER 0
+#define CONFIG_ALPHAMERGE_FILTER 0
+#define CONFIG_AMPLIFY_FILTER 0
+#define CONFIG_ASS_FILTER 0
+#define CONFIG_ATADENOISE_FILTER 0
+#define CONFIG_AVGBLUR_FILTER 0
+#define CONFIG_AVGBLUR_OPENCL_FILTER 0
+#define CONFIG_AVGBLUR_VULKAN_FILTER 0
+#define CONFIG_BBOX_FILTER 0
+#define CONFIG_BENCH_FILTER 0
+#define CONFIG_BILATERAL_FILTER 0
+#define CONFIG_BITPLANENOISE_FILTER 0
+#define CONFIG_BLACKDETECT_FILTER 0
+#define CONFIG_BLACKFRAME_FILTER 0
+#define CONFIG_BLEND_FILTER 0
+#define CONFIG_BLEND_VULKAN_FILTER 0
+#define CONFIG_BLOCKDETECT_FILTER 0
+#define CONFIG_BLURDETECT_FILTER 0
+#define CONFIG_BM3D_FILTER 0
+#define CONFIG_BOXBLUR_FILTER 0
+#define CONFIG_BOXBLUR_OPENCL_FILTER 0
+#define CONFIG_BWDIF_FILTER 0
+#define CONFIG_CAS_FILTER 0
+#define CONFIG_CHROMABER_VULKAN_FILTER 0
+#define CONFIG_CHROMAHOLD_FILTER 0
+#define CONFIG_CHROMAKEY_FILTER 0
+#define CONFIG_CHROMANR_FILTER 0
+#define CONFIG_CHROMASHIFT_FILTER 0
+#define CONFIG_CIESCOPE_FILTER 0
+#define CONFIG_CODECVIEW_FILTER 0
+#define CONFIG_COLORBALANCE_FILTER 0
+#define CONFIG_COLORCHANNELMIXER_FILTER 0
+#define CONFIG_COLORCONTRAST_FILTER 0
+#define CONFIG_COLORCORRECT_FILTER 0
+#define CONFIG_COLORIZE_FILTER 0
+#define CONFIG_COLORKEY_FILTER 0
+#define CONFIG_COLORKEY_OPENCL_FILTER 0
+#define CONFIG_COLORHOLD_FILTER 0
+#define CONFIG_COLORLEVELS_FILTER 0
+#define CONFIG_COLORMAP_FILTER 0
+#define CONFIG_COLORMATRIX_FILTER 0
+#define CONFIG_COLORSPACE_FILTER 0
+#define CONFIG_COLORTEMPERATURE_FILTER 0
+#define CONFIG_CONVOLUTION_FILTER 0
+#define CONFIG_CONVOLUTION_OPENCL_FILTER 0
+#define CONFIG_CONVOLVE_FILTER 0
+#define CONFIG_COPY_FILTER 0
+#define CONFIG_COREIMAGE_FILTER 0
+#define CONFIG_COVER_RECT_FILTER 0
+#define CONFIG_CROP_FILTER 0
+#define CONFIG_CROPDETECT_FILTER 0
+#define CONFIG_CUE_FILTER 0
+#define CONFIG_CURVES_FILTER 0
+#define CONFIG_DATASCOPE_FILTER 0
+#define CONFIG_DBLUR_FILTER 0
+#define CONFIG_DCTDNOIZ_FILTER 0
+#define CONFIG_DEBAND_FILTER 0
+#define CONFIG_DEBLOCK_FILTER 0
+#define CONFIG_DECIMATE_FILTER 0
+#define CONFIG_DECONVOLVE_FILTER 0
+#define CONFIG_DEDOT_FILTER 0
+#define CONFIG_DEFLATE_FILTER 0
+#define CONFIG_DEFLICKER_FILTER 0
+#define CONFIG_DEINTERLACE_QSV_FILTER 0
+#define CONFIG_DEINTERLACE_VAAPI_FILTER 0
+#define CONFIG_DEJUDDER_FILTER 0
+#define CONFIG_DELOGO_FILTER 0
+#define CONFIG_DENOISE_VAAPI_FILTER 0
+#define CONFIG_DERAIN_FILTER 0
+#define CONFIG_DESHAKE_FILTER 0
+#define CONFIG_DESHAKE_OPENCL_FILTER 0
+#define CONFIG_DESPILL_FILTER 0
+#define CONFIG_DETELECINE_FILTER 0
+#define CONFIG_DILATION_FILTER 0
+#define CONFIG_DILATION_OPENCL_FILTER 0
+#define CONFIG_DISPLACE_FILTER 0
+#define CONFIG_DNN_CLASSIFY_FILTER 0
+#define CONFIG_DNN_DETECT_FILTER 0
+#define CONFIG_DNN_PROCESSING_FILTER 0
+#define CONFIG_DOUBLEWEAVE_FILTER 0
+#define CONFIG_DRAWBOX_FILTER 0
+#define CONFIG_DRAWGRAPH_FILTER 0
+#define CONFIG_DRAWGRID_FILTER 0
+#define CONFIG_DRAWTEXT_FILTER 0
+#define CONFIG_EDGEDETECT_FILTER 0
+#define CONFIG_ELBG_FILTER 0
+#define CONFIG_ENTROPY_FILTER 0
+#define CONFIG_EPX_FILTER 0
+#define CONFIG_EQ_FILTER 0
+#define CONFIG_EROSION_FILTER 0
+#define CONFIG_EROSION_OPENCL_FILTER 0
+#define CONFIG_ESTDIF_FILTER 0
+#define CONFIG_EXPOSURE_FILTER 0
+#define CONFIG_EXTRACTPLANES_FILTER 0
+#define CONFIG_FADE_FILTER 0
+#define CONFIG_FEEDBACK_FILTER 0
+#define CONFIG_FFTDNOIZ_FILTER 0
+#define CONFIG_FFTFILT_FILTER 0
+#define CONFIG_FIELD_FILTER 0
+#define CONFIG_FIELDHINT_FILTER 0
+#define CONFIG_FIELDMATCH_FILTER 0
+#define CONFIG_FIELDORDER_FILTER 0
+#define CONFIG_FILLBORDERS_FILTER 0
+#define CONFIG_FIND_RECT_FILTER 0
+#define CONFIG_FLIP_VULKAN_FILTER 0
+#define CONFIG_FLOODFILL_FILTER 0
+#define CONFIG_FORMAT_FILTER 0
+#define CONFIG_FPS_FILTER 0
+#define CONFIG_FRAMEPACK_FILTER 0
+#define CONFIG_FRAMERATE_FILTER 0
+#define CONFIG_FRAMESTEP_FILTER 0
+#define CONFIG_FREEZEDETECT_FILTER 0
+#define CONFIG_FREEZEFRAMES_FILTER 0
+#define CONFIG_FREI0R_FILTER 0
+#define CONFIG_FSPP_FILTER 0
+#define CONFIG_GBLUR_FILTER 0
+#define CONFIG_GBLUR_VULKAN_FILTER 0
+#define CONFIG_GEQ_FILTER 0
+#define CONFIG_GRADFUN_FILTER 0
+#define CONFIG_GRAPHMONITOR_FILTER 0
+#define CONFIG_GRAYWORLD_FILTER 0
+#define CONFIG_GREYEDGE_FILTER 0
+#define CONFIG_GUIDED_FILTER 0
+#define CONFIG_HALDCLUT_FILTER 0
+#define CONFIG_HFLIP_FILTER 0
+#define CONFIG_HFLIP_VULKAN_FILTER 0
+#define CONFIG_HISTEQ_FILTER 0
+#define CONFIG_HISTOGRAM_FILTER 0
+#define CONFIG_HQDN3D_FILTER 0
+#define CONFIG_HQX_FILTER 0
+#define CONFIG_HSTACK_FILTER 0
+#define CONFIG_HSVHOLD_FILTER 0
+#define CONFIG_HSVKEY_FILTER 0
+#define CONFIG_HUE_FILTER 0
+#define CONFIG_HUESATURATION_FILTER 0
+#define CONFIG_HWDOWNLOAD_FILTER 0
+#define CONFIG_HWMAP_FILTER 0
+#define CONFIG_HWUPLOAD_FILTER 0
+#define CONFIG_HWUPLOAD_CUDA_FILTER 0
+#define CONFIG_HYSTERESIS_FILTER 0
+#define CONFIG_ICCDETECT_FILTER 0
+#define CONFIG_ICCGEN_FILTER 0
+#define CONFIG_IDENTITY_FILTER 0
+#define CONFIG_IDET_FILTER 0
+#define CONFIG_IL_FILTER 0
+#define CONFIG_INFLATE_FILTER 0
+#define CONFIG_INTERLACE_FILTER 0
+#define CONFIG_INTERLEAVE_FILTER 0
+#define CONFIG_KERNDEINT_FILTER 0
+#define CONFIG_KIRSCH_FILTER 0
+#define CONFIG_LAGFUN_FILTER 0
+#define CONFIG_LATENCY_FILTER 0
+#define CONFIG_LENSCORRECTION_FILTER 0
+#define CONFIG_LENSFUN_FILTER 0
+#define CONFIG_LIBPLACEBO_FILTER 0
+#define CONFIG_LIBVMAF_FILTER 0
+#define CONFIG_LIMITDIFF_FILTER 0
+#define CONFIG_LIMITER_FILTER 0
+#define CONFIG_LOOP_FILTER 0
+#define CONFIG_LUMAKEY_FILTER 0
+#define CONFIG_LUT_FILTER 0
+#define CONFIG_LUT1D_FILTER 0
+#define CONFIG_LUT2_FILTER 0
+#define CONFIG_LUT3D_FILTER 0
+#define CONFIG_LUTRGB_FILTER 0
+#define CONFIG_LUTYUV_FILTER 0
+#define CONFIG_MASKEDCLAMP_FILTER 0
+#define CONFIG_MASKEDMAX_FILTER 0
+#define CONFIG_MASKEDMERGE_FILTER 0
+#define CONFIG_MASKEDMIN_FILTER 0
+#define CONFIG_MASKEDTHRESHOLD_FILTER 0
+#define CONFIG_MASKFUN_FILTER 0
+#define CONFIG_MCDEINT_FILTER 0
+#define CONFIG_MEDIAN_FILTER 0
+#define CONFIG_MERGEPLANES_FILTER 0
+#define CONFIG_MESTIMATE_FILTER 0
+#define CONFIG_METADATA_FILTER 0
+#define CONFIG_MIDEQUALIZER_FILTER 0
+#define CONFIG_MINTERPOLATE_FILTER 0
+#define CONFIG_MIX_FILTER 0
+#define CONFIG_MONOCHROME_FILTER 0
+#define CONFIG_MORPHO_FILTER 0
+#define CONFIG_MPDECIMATE_FILTER 0
+#define CONFIG_MSAD_FILTER 0
+#define CONFIG_MULTIPLY_FILTER 0
+#define CONFIG_NEGATE_FILTER 0
+#define CONFIG_NLMEANS_FILTER 0
+#define CONFIG_NLMEANS_OPENCL_FILTER 0
+#define CONFIG_NNEDI_FILTER 0
+#define CONFIG_NOFORMAT_FILTER 0
+#define CONFIG_NOISE_FILTER 0
+#define CONFIG_NORMALIZE_FILTER 0
+#define CONFIG_NULL_FILTER 0
+#define CONFIG_OCR_FILTER 0
+#define CONFIG_OCV_FILTER 0
+#define CONFIG_OSCILLOSCOPE_FILTER 0
+#define CONFIG_OVERLAY_FILTER 0
+#define CONFIG_OVERLAY_OPENCL_FILTER 0
+#define CONFIG_OVERLAY_QSV_FILTER 0
+#define CONFIG_OVERLAY_VAAPI_FILTER 0
+#define CONFIG_OVERLAY_VULKAN_FILTER 0
+#define CONFIG_OVERLAY_CUDA_FILTER 0
+#define CONFIG_OWDENOISE_FILTER 0
+#define CONFIG_PAD_FILTER 0
+#define CONFIG_PAD_OPENCL_FILTER 0
+#define CONFIG_PALETTEGEN_FILTER 0
+#define CONFIG_PALETTEUSE_FILTER 0
+#define CONFIG_PERMS_FILTER 0
+#define CONFIG_PERSPECTIVE_FILTER 0
+#define CONFIG_PHASE_FILTER 0
+#define CONFIG_PHOTOSENSITIVITY_FILTER 0
+#define CONFIG_PIXDESCTEST_FILTER 0
+#define CONFIG_PIXELIZE_FILTER 0
+#define CONFIG_PIXSCOPE_FILTER 0
+#define CONFIG_PP_FILTER 0
+#define CONFIG_PP7_FILTER 0
+#define CONFIG_PREMULTIPLY_FILTER 0
+#define CONFIG_PREWITT_FILTER 0
+#define CONFIG_PREWITT_OPENCL_FILTER 0
+#define CONFIG_PROCAMP_VAAPI_FILTER 0
+#define CONFIG_PROGRAM_OPENCL_FILTER 0
+#define CONFIG_PSEUDOCOLOR_FILTER 0
+#define CONFIG_PSNR_FILTER 0
+#define CONFIG_PULLUP_FILTER 0
+#define CONFIG_QP_FILTER 0
+#define CONFIG_RANDOM_FILTER 0
+#define CONFIG_READEIA608_FILTER 0
+#define CONFIG_READVITC_FILTER 0
+#define CONFIG_REALTIME_FILTER 0
+#define CONFIG_REMAP_FILTER 0
+#define CONFIG_REMOVEGRAIN_FILTER 0
+#define CONFIG_REMOVELOGO_FILTER 0
+#define CONFIG_REPEATFIELDS_FILTER 0
+#define CONFIG_REVERSE_FILTER 0
+#define CONFIG_RGBASHIFT_FILTER 0
+#define CONFIG_ROBERTS_FILTER 0
+#define CONFIG_ROBERTS_OPENCL_FILTER 0
+#define CONFIG_ROTATE_FILTER 0
+#define CONFIG_SAB_FILTER 0
+#define CONFIG_SCALE_FILTER 0
+#define CONFIG_SCALE_CUDA_FILTER 0
+#define CONFIG_SCALE_NPP_FILTER 0
+#define CONFIG_SCALE_QSV_FILTER 0
+#define CONFIG_SCALE_VAAPI_FILTER 0
+#define CONFIG_SCALE_VULKAN_FILTER 0
+#define CONFIG_SCALE2REF_FILTER 0
+#define CONFIG_SCALE2REF_NPP_FILTER 0
+#define CONFIG_SCDET_FILTER 0
+#define CONFIG_SCHARR_FILTER 0
+#define CONFIG_SCROLL_FILTER 0
+#define CONFIG_SEGMENT_FILTER 0
+#define CONFIG_SELECT_FILTER 0
+#define CONFIG_SELECTIVECOLOR_FILTER 0
+#define CONFIG_SENDCMD_FILTER 0
+#define CONFIG_SEPARATEFIELDS_FILTER 0
+#define CONFIG_SETDAR_FILTER 0
+#define CONFIG_SETFIELD_FILTER 0
+#define CONFIG_SETPARAMS_FILTER 0
+#define CONFIG_SETPTS_FILTER 0
+#define CONFIG_SETRANGE_FILTER 0
+#define CONFIG_SETSAR_FILTER 0
+#define CONFIG_SETTB_FILTER 0
+#define CONFIG_SHARPEN_NPP_FILTER 0
+#define CONFIG_SHARPNESS_VAAPI_FILTER 0
+#define CONFIG_SHEAR_FILTER 0
+#define CONFIG_SHOWINFO_FILTER 0
+#define CONFIG_SHOWPALETTE_FILTER 0
+#define CONFIG_SHUFFLEFRAMES_FILTER 0
+#define CONFIG_SHUFFLEPIXELS_FILTER 0
+#define CONFIG_SHUFFLEPLANES_FILTER 0
+#define CONFIG_SIDEDATA_FILTER 0
+#define CONFIG_SIGNALSTATS_FILTER 0
+#define CONFIG_SIGNATURE_FILTER 0
+#define CONFIG_SITI_FILTER 0
+#define CONFIG_SMARTBLUR_FILTER 0
+#define CONFIG_SOBEL_FILTER 0
+#define CONFIG_SOBEL_OPENCL_FILTER 0
+#define CONFIG_SPLIT_FILTER 0
+#define CONFIG_SPP_FILTER 0
+#define CONFIG_SR_FILTER 0
+#define CONFIG_SSIM_FILTER 0
+#define CONFIG_STEREO3D_FILTER 0
+#define CONFIG_STREAMSELECT_FILTER 0
+#define CONFIG_SUBTITLES_FILTER 0
+#define CONFIG_SUPER2XSAI_FILTER 0
+#define CONFIG_SWAPRECT_FILTER 0
+#define CONFIG_SWAPUV_FILTER 0
+#define CONFIG_TBLEND_FILTER 0
+#define CONFIG_TELECINE_FILTER 0
+#define CONFIG_THISTOGRAM_FILTER 0
+#define CONFIG_THRESHOLD_FILTER 0
+#define CONFIG_THUMBNAIL_FILTER 0
+#define CONFIG_THUMBNAIL_CUDA_FILTER 0
+#define CONFIG_TILE_FILTER 0
+#define CONFIG_TINTERLACE_FILTER 0
+#define CONFIG_TLUT2_FILTER 0
+#define CONFIG_TMEDIAN_FILTER 0
+#define CONFIG_TMIDEQUALIZER_FILTER 0
+#define CONFIG_TMIX_FILTER 0
+#define CONFIG_TONEMAP_FILTER 0
+#define CONFIG_TONEMAP_OPENCL_FILTER 0
+#define CONFIG_TONEMAP_VAAPI_FILTER 0
+#define CONFIG_TPAD_FILTER 0
+#define CONFIG_TRANSPOSE_FILTER 0
+#define CONFIG_TRANSPOSE_NPP_FILTER 0
+#define CONFIG_TRANSPOSE_OPENCL_FILTER 0
+#define CONFIG_TRANSPOSE_VAAPI_FILTER 0
+#define CONFIG_TRANSPOSE_VULKAN_FILTER 0
+#define CONFIG_TRIM_FILTER 0
+#define CONFIG_UNPREMULTIPLY_FILTER 0
+#define CONFIG_UNSHARP_FILTER 0
+#define CONFIG_UNSHARP_OPENCL_FILTER 0
+#define CONFIG_UNTILE_FILTER 0
+#define CONFIG_USPP_FILTER 0
+#define CONFIG_V360_FILTER 0
+#define CONFIG_VAGUEDENOISER_FILTER 0
+#define CONFIG_VARBLUR_FILTER 0
+#define CONFIG_VECTORSCOPE_FILTER 0
+#define CONFIG_VFLIP_FILTER 0
+#define CONFIG_VFLIP_VULKAN_FILTER 0
+#define CONFIG_VFRDET_FILTER 0
+#define CONFIG_VIBRANCE_FILTER 0
+#define CONFIG_VIDSTABDETECT_FILTER 0
+#define CONFIG_VIDSTABTRANSFORM_FILTER 0
+#define CONFIG_VIF_FILTER 0
+#define CONFIG_VIGNETTE_FILTER 0
+#define CONFIG_VMAFMOTION_FILTER 0
+#define CONFIG_VPP_QSV_FILTER 0
+#define CONFIG_VSTACK_FILTER 0
+#define CONFIG_W3FDIF_FILTER 0
+#define CONFIG_WAVEFORM_FILTER 0
+#define CONFIG_WEAVE_FILTER 0
+#define CONFIG_XBR_FILTER 0
+#define CONFIG_XCORRELATE_FILTER 0
+#define CONFIG_XFADE_FILTER 0
+#define CONFIG_XFADE_OPENCL_FILTER 0
+#define CONFIG_XMEDIAN_FILTER 0
+#define CONFIG_XSTACK_FILTER 0
+#define CONFIG_YADIF_FILTER 0
+#define CONFIG_YADIF_CUDA_FILTER 0
+#define CONFIG_YADIF_VIDEOTOOLBOX_FILTER 0
+#define CONFIG_YAEPBLUR_FILTER 0
+#define CONFIG_ZMQ_FILTER 0
+#define CONFIG_ZOOMPAN_FILTER 0
+#define CONFIG_ZSCALE_FILTER 0
+#define CONFIG_ALLRGB_FILTER 0
+#define CONFIG_ALLYUV_FILTER 0
+#define CONFIG_CELLAUTO_FILTER 0
+#define CONFIG_COLOR_FILTER 0
+#define CONFIG_COLORCHART_FILTER 0
+#define CONFIG_COLORSPECTRUM_FILTER 0
+#define CONFIG_COREIMAGESRC_FILTER 0
+#define CONFIG_FREI0R_SRC_FILTER 0
+#define CONFIG_GRADIENTS_FILTER 0
+#define CONFIG_HALDCLUTSRC_FILTER 0
+#define CONFIG_LIFE_FILTER 0
+#define CONFIG_MANDELBROT_FILTER 0
+#define CONFIG_MPTESTSRC_FILTER 0
+#define CONFIG_NULLSRC_FILTER 0
+#define CONFIG_OPENCLSRC_FILTER 0
+#define CONFIG_PAL75BARS_FILTER 0
+#define CONFIG_PAL100BARS_FILTER 0
+#define CONFIG_RGBTESTSRC_FILTER 0
+#define CONFIG_SIERPINSKI_FILTER 0
+#define CONFIG_SMPTEBARS_FILTER 0
+#define CONFIG_SMPTEHDBARS_FILTER 0
+#define CONFIG_TESTSRC_FILTER 0
+#define CONFIG_TESTSRC2_FILTER 0
+#define CONFIG_YUVTESTSRC_FILTER 0
+#define CONFIG_NULLSINK_FILTER 0
+#define CONFIG_ABITSCOPE_FILTER 0
+#define CONFIG_ADRAWGRAPH_FILTER 0
+#define CONFIG_AGRAPHMONITOR_FILTER 0
+#define CONFIG_AHISTOGRAM_FILTER 0
+#define CONFIG_APHASEMETER_FILTER 0
+#define CONFIG_AVECTORSCOPE_FILTER 0
+#define CONFIG_CONCAT_FILTER 0
+#define CONFIG_SHOWCQT_FILTER 0
+#define CONFIG_SHOWFREQS_FILTER 0
+#define CONFIG_SHOWSPATIAL_FILTER 0
+#define CONFIG_SHOWSPECTRUM_FILTER 0
+#define CONFIG_SHOWSPECTRUMPIC_FILTER 0
+#define CONFIG_SHOWVOLUME_FILTER 0
+#define CONFIG_SHOWWAVES_FILTER 0
+#define CONFIG_SHOWWAVESPIC_FILTER 0
+#define CONFIG_SPECTRUMSYNTH_FILTER 0
+#define CONFIG_AVSYNCTEST_FILTER 0
+#define CONFIG_AMOVIE_FILTER 0
+#define CONFIG_MOVIE_FILTER 0
+#define CONFIG_AFIFO_FILTER 0
+#define CONFIG_FIFO_FILTER 0
+#define CONFIG_AA_DEMUXER 0
+#define CONFIG_AAC_DEMUXER 0
+#define CONFIG_AAX_DEMUXER 0
+#define CONFIG_AC3_DEMUXER 0
+#define CONFIG_ACE_DEMUXER 0
+#define CONFIG_ACM_DEMUXER 0
+#define CONFIG_ACT_DEMUXER 0
+#define CONFIG_ADF_DEMUXER 0
+#define CONFIG_ADP_DEMUXER 0
+#define CONFIG_ADS_DEMUXER 0
+#define CONFIG_ADX_DEMUXER 0
+#define CONFIG_AEA_DEMUXER 0
+#define CONFIG_AFC_DEMUXER 0
+#define CONFIG_AIFF_DEMUXER 0
+#define CONFIG_AIX_DEMUXER 0
+#define CONFIG_ALP_DEMUXER 0
+#define CONFIG_AMR_DEMUXER 0
+#define CONFIG_AMRNB_DEMUXER 0
+#define CONFIG_AMRWB_DEMUXER 0
+#define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APC_DEMUXER 0
+#define CONFIG_APE_DEMUXER 0
+#define CONFIG_APM_DEMUXER 0
+#define CONFIG_APNG_DEMUXER 0
+#define CONFIG_APTX_DEMUXER 0
+#define CONFIG_APTX_HD_DEMUXER 0
+#define CONFIG_AQTITLE_DEMUXER 0
+#define CONFIG_ARGO_ASF_DEMUXER 0
+#define CONFIG_ARGO_BRP_DEMUXER 0
+#define CONFIG_ARGO_CVG_DEMUXER 0
+#define CONFIG_ASF_DEMUXER 0
+#define CONFIG_ASF_O_DEMUXER 0
+#define CONFIG_ASS_DEMUXER 0
+#define CONFIG_AST_DEMUXER 0
+#define CONFIG_AU_DEMUXER 0
+#define CONFIG_AV1_DEMUXER 0
+#define CONFIG_AVI_DEMUXER 0
+#define CONFIG_AVISYNTH_DEMUXER 0
+#define CONFIG_AVR_DEMUXER 0
+#define CONFIG_AVS_DEMUXER 0
+#define CONFIG_AVS2_DEMUXER 0
+#define CONFIG_AVS3_DEMUXER 0
+#define CONFIG_BETHSOFTVID_DEMUXER 0
+#define CONFIG_BFI_DEMUXER 0
+#define CONFIG_BINTEXT_DEMUXER 0
+#define CONFIG_BINK_DEMUXER 0
+#define CONFIG_BINKA_DEMUXER 0
+#define CONFIG_BIT_DEMUXER 0
+#define CONFIG_BITPACKED_DEMUXER 0
+#define CONFIG_BMV_DEMUXER 0
+#define CONFIG_BFSTM_DEMUXER 0
+#define CONFIG_BRSTM_DEMUXER 0
+#define CONFIG_BOA_DEMUXER 0
+#define CONFIG_C93_DEMUXER 0
+#define CONFIG_CAF_DEMUXER 0
+#define CONFIG_CAVSVIDEO_DEMUXER 0
+#define CONFIG_CDG_DEMUXER 0
+#define CONFIG_CDXL_DEMUXER 0
+#define CONFIG_CINE_DEMUXER 0
+#define CONFIG_CODEC2_DEMUXER 0
+#define CONFIG_CODEC2RAW_DEMUXER 0
+#define CONFIG_CONCAT_DEMUXER 0
+#define CONFIG_DASH_DEMUXER 0
+#define CONFIG_DATA_DEMUXER 0
+#define CONFIG_DAUD_DEMUXER 0
+#define CONFIG_DCSTR_DEMUXER 0
+#define CONFIG_DERF_DEMUXER 0
+#define CONFIG_DFA_DEMUXER 0
+#define CONFIG_DFPWM_DEMUXER 0
+#define CONFIG_DHAV_DEMUXER 0
+#define CONFIG_DIRAC_DEMUXER 0
+#define CONFIG_DNXHD_DEMUXER 0
+#define CONFIG_DSF_DEMUXER 0
+#define CONFIG_DSICIN_DEMUXER 0
+#define CONFIG_DSS_DEMUXER 0
+#define CONFIG_DTS_DEMUXER 0
+#define CONFIG_DTSHD_DEMUXER 0
+#define CONFIG_DV_DEMUXER 0
+#define CONFIG_DVBSUB_DEMUXER 0
+#define CONFIG_DVBTXT_DEMUXER 0
+#define CONFIG_DXA_DEMUXER 0
+#define CONFIG_EA_DEMUXER 0
+#define CONFIG_EA_CDATA_DEMUXER 0
+#define CONFIG_EAC3_DEMUXER 0
+#define CONFIG_EPAF_DEMUXER 0
+#define CONFIG_FFMETADATA_DEMUXER 0
+#define CONFIG_FILMSTRIP_DEMUXER 0
+#define CONFIG_FITS_DEMUXER 0
+#define CONFIG_FLAC_DEMUXER 0
+#define CONFIG_FLIC_DEMUXER 0
+#define CONFIG_FLV_DEMUXER 0
+#define CONFIG_LIVE_FLV_DEMUXER 0
+#define CONFIG_FOURXM_DEMUXER 0
+#define CONFIG_FRM_DEMUXER 0
+#define CONFIG_FSB_DEMUXER 0
+#define CONFIG_FWSE_DEMUXER 0
+#define CONFIG_G722_DEMUXER 0
+#define CONFIG_G723_1_DEMUXER 0
+#define CONFIG_G726_DEMUXER 0
+#define CONFIG_G726LE_DEMUXER 0
+#define CONFIG_G729_DEMUXER 0
+#define CONFIG_GDV_DEMUXER 0
+#define CONFIG_GENH_DEMUXER 0
+#define CONFIG_GIF_DEMUXER 0
+#define CONFIG_GSM_DEMUXER 0
+#define CONFIG_GXF_DEMUXER 0
+#define CONFIG_H261_DEMUXER 0
+#define CONFIG_H263_DEMUXER 0
+#define CONFIG_H264_DEMUXER 0
+#define CONFIG_HCA_DEMUXER 0
+#define CONFIG_HCOM_DEMUXER 0
+#define CONFIG_HEVC_DEMUXER 0
+#define CONFIG_HLS_DEMUXER 0
+#define CONFIG_HNM_DEMUXER 0
+#define CONFIG_ICO_DEMUXER 0
+#define CONFIG_IDCIN_DEMUXER 0
+#define CONFIG_IDF_DEMUXER 0
+#define CONFIG_IFF_DEMUXER 0
+#define CONFIG_IFV_DEMUXER 0
+#define CONFIG_ILBC_DEMUXER 0
+#define CONFIG_IMAGE2_DEMUXER 0
+#define CONFIG_IMAGE2PIPE_DEMUXER 0
+#define CONFIG_IMAGE2_ALIAS_PIX_DEMUXER 0
+#define CONFIG_IMAGE2_BRENDER_PIX_DEMUXER 0
+#define CONFIG_IMF_DEMUXER 0
+#define CONFIG_INGENIENT_DEMUXER 0
+#define CONFIG_IPMOVIE_DEMUXER 0
+#define CONFIG_IPU_DEMUXER 0
+#define CONFIG_IRCAM_DEMUXER 0
+#define CONFIG_ISS_DEMUXER 0
+#define CONFIG_IV8_DEMUXER 0
+#define CONFIG_IVF_DEMUXER 0
+#define CONFIG_IVR_DEMUXER 0
+#define CONFIG_JACOSUB_DEMUXER 0
+#define CONFIG_JV_DEMUXER 0
+#define CONFIG_KUX_DEMUXER 0
+#define CONFIG_KVAG_DEMUXER 0
+#define CONFIG_LMLM4_DEMUXER 0
+#define CONFIG_LOAS_DEMUXER 0
+#define CONFIG_LUODAT_DEMUXER 0
+#define CONFIG_LRC_DEMUXER 0
+#define CONFIG_LVF_DEMUXER 0
+#define CONFIG_LXF_DEMUXER 0
+#define CONFIG_M4V_DEMUXER 0
+#define CONFIG_MCA_DEMUXER 0
+#define CONFIG_MCC_DEMUXER 0
+#define CONFIG_MATROSKA_DEMUXER 0
+#define CONFIG_MGSTS_DEMUXER 0
+#define CONFIG_MICRODVD_DEMUXER 0
+#define CONFIG_MJPEG_DEMUXER 0
+#define CONFIG_MJPEG_2000_DEMUXER 0
+#define CONFIG_MLP_DEMUXER 0
+#define CONFIG_MLV_DEMUXER 0
+#define CONFIG_MM_DEMUXER 0
+#define CONFIG_MMF_DEMUXER 0
+#define CONFIG_MODS_DEMUXER 0
+#define CONFIG_MOFLEX_DEMUXER 0
+#define CONFIG_MOV_DEMUXER 0
+#define CONFIG_MP3_DEMUXER 0
+#define CONFIG_MPC_DEMUXER 0
+#define CONFIG_MPC8_DEMUXER 0
+#define CONFIG_MPEGPS_DEMUXER 0
+#define CONFIG_MPEGTS_DEMUXER 0
+#define CONFIG_MPEGTSRAW_DEMUXER 0
+#define CONFIG_MPEGVIDEO_DEMUXER 0
+#define CONFIG_MPJPEG_DEMUXER 0
+#define CONFIG_MPL2_DEMUXER 0
+#define CONFIG_MPSUB_DEMUXER 0
+#define CONFIG_MSF_DEMUXER 0
+#define CONFIG_MSNWC_TCP_DEMUXER 0
+#define CONFIG_MSP_DEMUXER 0
+#define CONFIG_MTAF_DEMUXER 0
+#define CONFIG_MTV_DEMUXER 0
+#define CONFIG_MUSX_DEMUXER 0
+#define CONFIG_MV_DEMUXER 0
+#define CONFIG_MVI_DEMUXER 0
+#define CONFIG_MXF_DEMUXER 0
+#define CONFIG_MXG_DEMUXER 0
+#define CONFIG_NC_DEMUXER 0
+#define CONFIG_NISTSPHERE_DEMUXER 0
+#define CONFIG_NSP_DEMUXER 0
+#define CONFIG_NSV_DEMUXER 0
+#define CONFIG_NUT_DEMUXER 0
+#define CONFIG_NUV_DEMUXER 0
+#define CONFIG_OBU_DEMUXER 0
+#define CONFIG_OGG_DEMUXER 0
+#define CONFIG_OMA_DEMUXER 0
+#define CONFIG_PAF_DEMUXER 0
+#define CONFIG_PCM_ALAW_DEMUXER 0
+#define CONFIG_PCM_MULAW_DEMUXER 0
+#define CONFIG_PCM_VIDC_DEMUXER 0
+#define CONFIG_PCM_F64BE_DEMUXER 0
+#define CONFIG_PCM_F64LE_DEMUXER 0
+#define CONFIG_PCM_F32BE_DEMUXER 0
+#define CONFIG_PCM_F32LE_DEMUXER 0
+#define CONFIG_PCM_S32BE_DEMUXER 0
+#define CONFIG_PCM_S32LE_DEMUXER 0
+#define CONFIG_PCM_S24BE_DEMUXER 0
+#define CONFIG_PCM_S24LE_DEMUXER 0
+#define CONFIG_PCM_S16BE_DEMUXER 0
+#define CONFIG_PCM_S16LE_DEMUXER 0
+#define CONFIG_PCM_S8_DEMUXER 0
+#define CONFIG_PCM_U32BE_DEMUXER 0
+#define CONFIG_PCM_U32LE_DEMUXER 0
+#define CONFIG_PCM_U24BE_DEMUXER 0
+#define CONFIG_PCM_U24LE_DEMUXER 0
+#define CONFIG_PCM_U16BE_DEMUXER 0
+#define CONFIG_PCM_U16LE_DEMUXER 0
+#define CONFIG_PCM_U8_DEMUXER 0
+#define CONFIG_PJS_DEMUXER 0
+#define CONFIG_PMP_DEMUXER 0
+#define CONFIG_PP_BNK_DEMUXER 0
+#define CONFIG_PVA_DEMUXER 0
+#define CONFIG_PVF_DEMUXER 0
+#define CONFIG_QCP_DEMUXER 0
+#define CONFIG_R3D_DEMUXER 0
+#define CONFIG_RAWVIDEO_DEMUXER 0
+#define CONFIG_REALTEXT_DEMUXER 0
+#define CONFIG_REDSPARK_DEMUXER 0
+#define CONFIG_RL2_DEMUXER 0
+#define CONFIG_RM_DEMUXER 0
+#define CONFIG_ROQ_DEMUXER 0
+#define CONFIG_RPL_DEMUXER 0
+#define CONFIG_RSD_DEMUXER 0
+#define CONFIG_RSO_DEMUXER 0
+#define CONFIG_RTP_DEMUXER 0
+#define CONFIG_RTSP_DEMUXER 0
+#define CONFIG_S337M_DEMUXER 0
+#define CONFIG_SAMI_DEMUXER 0
+#define CONFIG_SAP_DEMUXER 0
+#define CONFIG_SBC_DEMUXER 0
+#define CONFIG_SBG_DEMUXER 0
+#define CONFIG_SCC_DEMUXER 0
+#define CONFIG_SCD_DEMUXER 0
+#define CONFIG_SDP_DEMUXER 0
+#define CONFIG_SDR2_DEMUXER 0
+#define CONFIG_SDS_DEMUXER 0
+#define CONFIG_SDX_DEMUXER 0
+#define CONFIG_SEGAFILM_DEMUXER 0
+#define CONFIG_SER_DEMUXER 0
+#define CONFIG_SGA_DEMUXER 0
+#define CONFIG_SHORTEN_DEMUXER 0
+#define CONFIG_SIFF_DEMUXER 0
+#define CONFIG_SIMBIOSIS_IMX_DEMUXER 0
+#define CONFIG_SLN_DEMUXER 0
+#define CONFIG_SMACKER_DEMUXER 0
+#define CONFIG_SMJPEG_DEMUXER 0
+#define CONFIG_SMUSH_DEMUXER 0
+#define CONFIG_SOL_DEMUXER 0
+#define CONFIG_SOX_DEMUXER 0
+#define CONFIG_SPDIF_DEMUXER 0
+#define CONFIG_SRT_DEMUXER 0
+#define CONFIG_STR_DEMUXER 0
+#define CONFIG_STL_DEMUXER 0
+#define CONFIG_SUBVIEWER1_DEMUXER 0
+#define CONFIG_SUBVIEWER_DEMUXER 0
+#define CONFIG_SUP_DEMUXER 0
+#define CONFIG_SVAG_DEMUXER 0
+#define CONFIG_SVS_DEMUXER 0
+#define CONFIG_SWF_DEMUXER 0
+#define CONFIG_TAK_DEMUXER 0
+#define CONFIG_TEDCAPTIONS_DEMUXER 0
+#define CONFIG_THP_DEMUXER 0
+#define CONFIG_THREEDOSTR_DEMUXER 0
+#define CONFIG_TIERTEXSEQ_DEMUXER 0
+#define CONFIG_TMV_DEMUXER 0
+#define CONFIG_TRUEHD_DEMUXER 0
+#define CONFIG_TTA_DEMUXER 0
+#define CONFIG_TXD_DEMUXER 0
+#define CONFIG_TTY_DEMUXER 0
+#define CONFIG_TY_DEMUXER 0
+#define CONFIG_V210_DEMUXER 0
+#define CONFIG_V210X_DEMUXER 0
+#define CONFIG_VAG_DEMUXER 0
+#define CONFIG_VC1_DEMUXER 0
+#define CONFIG_VC1T_DEMUXER 0
+#define CONFIG_VIVIDAS_DEMUXER 0
+#define CONFIG_VIVO_DEMUXER 0
+#define CONFIG_VMD_DEMUXER 0
+#define CONFIG_VOBSUB_DEMUXER 0
+#define CONFIG_VOC_DEMUXER 0
+#define CONFIG_VPK_DEMUXER 0
+#define CONFIG_VPLAYER_DEMUXER 0
+#define CONFIG_VQF_DEMUXER 0
+#define CONFIG_W64_DEMUXER 0
+#define CONFIG_WAV_DEMUXER 0
+#define CONFIG_WC3_DEMUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_DEMUXER 0
+#define CONFIG_WEBVTT_DEMUXER 0
+#define CONFIG_WSAUD_DEMUXER 0
+#define CONFIG_WSD_DEMUXER 0
+#define CONFIG_WSVQA_DEMUXER 0
+#define CONFIG_WTV_DEMUXER 0
+#define CONFIG_WVE_DEMUXER 0
+#define CONFIG_WV_DEMUXER 0
+#define CONFIG_XA_DEMUXER 0
+#define CONFIG_XBIN_DEMUXER 0
+#define CONFIG_XMV_DEMUXER 0
+#define CONFIG_XVAG_DEMUXER 0
+#define CONFIG_XWMA_DEMUXER 0
+#define CONFIG_YOP_DEMUXER 0
+#define CONFIG_YUV4MPEGPIPE_DEMUXER 0
+#define CONFIG_IMAGE_BMP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_CRI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DDS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DPX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_EXR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GEM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GIF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_J2K_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGXL_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PAM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PCX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGMYUV_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PHOTOCD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PICTOR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PNG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PSD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QDRAW_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QOI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SGI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SVG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SUNRAST_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_TIFF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_VBN_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_WEBP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XWD_PIPE_DEMUXER 0
+#define CONFIG_LIBGME_DEMUXER 0
+#define CONFIG_LIBMODPLUG_DEMUXER 0
+#define CONFIG_LIBOPENMPT_DEMUXER 0
+#define CONFIG_VAPOURSYNTH_DEMUXER 0
+#define CONFIG_A64_MUXER 0
+#define CONFIG_AC3_MUXER 0
+#define CONFIG_ADTS_MUXER 0
+#define CONFIG_ADX_MUXER 0
+#define CONFIG_AIFF_MUXER 0
+#define CONFIG_ALP_MUXER 0
+#define CONFIG_AMR_MUXER 0
+#define CONFIG_AMV_MUXER 0
+#define CONFIG_APM_MUXER 0
+#define CONFIG_APNG_MUXER 0
+#define CONFIG_APTX_MUXER 0
+#define CONFIG_APTX_HD_MUXER 0
+#define CONFIG_ARGO_ASF_MUXER 0
+#define CONFIG_ARGO_CVG_MUXER 0
+#define CONFIG_ASF_MUXER 0
+#define CONFIG_ASS_MUXER 0
+#define CONFIG_AST_MUXER 0
+#define CONFIG_ASF_STREAM_MUXER 0
+#define CONFIG_AU_MUXER 0
+#define CONFIG_AVI_MUXER 0
+#define CONFIG_AVIF_MUXER 0
+#define CONFIG_AVM2_MUXER 0
+#define CONFIG_AVS2_MUXER 0
+#define CONFIG_AVS3_MUXER 0
+#define CONFIG_BIT_MUXER 0
+#define CONFIG_CAF_MUXER 0
+#define CONFIG_CAVSVIDEO_MUXER 0
+#define CONFIG_CODEC2_MUXER 0
+#define CONFIG_CODEC2RAW_MUXER 0
+#define CONFIG_CRC_MUXER 0
+#define CONFIG_DASH_MUXER 0
+#define CONFIG_DATA_MUXER 0
+#define CONFIG_DAUD_MUXER 0
+#define CONFIG_DFPWM_MUXER 0
+#define CONFIG_DIRAC_MUXER 0
+#define CONFIG_DNXHD_MUXER 0
+#define CONFIG_DTS_MUXER 0
+#define CONFIG_DV_MUXER 0
+#define CONFIG_EAC3_MUXER 0
+#define CONFIG_F4V_MUXER 0
+#define CONFIG_FFMETADATA_MUXER 0
+#define CONFIG_FIFO_MUXER 0
+#define CONFIG_FIFO_TEST_MUXER 0
+#define CONFIG_FILMSTRIP_MUXER 0
+#define CONFIG_FITS_MUXER 0
+#define CONFIG_FLAC_MUXER 0
+#define CONFIG_FLV_MUXER 0
+#define CONFIG_FRAMECRC_MUXER 0
+#define CONFIG_FRAMEHASH_MUXER 0
+#define CONFIG_FRAMEMD5_MUXER 0
+#define CONFIG_G722_MUXER 0
+#define CONFIG_G723_1_MUXER 0
+#define CONFIG_G726_MUXER 0
+#define CONFIG_G726LE_MUXER 0
+#define CONFIG_GIF_MUXER 0
+#define CONFIG_GSM_MUXER 0
+#define CONFIG_GXF_MUXER 0
+#define CONFIG_H261_MUXER 0
+#define CONFIG_H263_MUXER 0
+#define CONFIG_H264_MUXER 0
+#define CONFIG_HASH_MUXER 0
+#define CONFIG_HDS_MUXER 0
+#define CONFIG_HEVC_MUXER 0
+#define CONFIG_HLS_MUXER 0
+#define CONFIG_ICO_MUXER 0
+#define CONFIG_ILBC_MUXER 0
+#define CONFIG_IMAGE2_MUXER 0
+#define CONFIG_IMAGE2PIPE_MUXER 0
+#define CONFIG_IPOD_MUXER 0
+#define CONFIG_IRCAM_MUXER 0
+#define CONFIG_ISMV_MUXER 0
+#define CONFIG_IVF_MUXER 0
+#define CONFIG_JACOSUB_MUXER 0
+#define CONFIG_KVAG_MUXER 0
+#define CONFIG_LATM_MUXER 0
+#define CONFIG_LRC_MUXER 0
+#define CONFIG_M4V_MUXER 0
+#define CONFIG_MD5_MUXER 0
+#define CONFIG_MATROSKA_MUXER 0
+#define CONFIG_MATROSKA_AUDIO_MUXER 0
+#define CONFIG_MICRODVD_MUXER 0
+#define CONFIG_MJPEG_MUXER 0
+#define CONFIG_MLP_MUXER 0
+#define CONFIG_MMF_MUXER 0
+#define CONFIG_MOV_MUXER 0
+#define CONFIG_MP2_MUXER 0
+#define CONFIG_MP3_MUXER 0
+#define CONFIG_MP4_MUXER 0
+#define CONFIG_MPEG1SYSTEM_MUXER 0
+#define CONFIG_MPEG1VCD_MUXER 0
+#define CONFIG_MPEG1VIDEO_MUXER 0
+#define CONFIG_MPEG2DVD_MUXER 0
+#define CONFIG_MPEG2SVCD_MUXER 0
+#define CONFIG_MPEG2VIDEO_MUXER 0
+#define CONFIG_MPEG2VOB_MUXER 0
+#define CONFIG_MPEGTS_MUXER 0
+#define CONFIG_MPJPEG_MUXER 0
+#define CONFIG_MXF_MUXER 0
+#define CONFIG_MXF_D10_MUXER 0
+#define CONFIG_MXF_OPATOM_MUXER 0
+#define CONFIG_NULL_MUXER 0
+#define CONFIG_NUT_MUXER 0
+#define CONFIG_OBU_MUXER 0
+#define CONFIG_OGA_MUXER 0
+#define CONFIG_OGG_MUXER 0
+#define CONFIG_OGV_MUXER 0
+#define CONFIG_OMA_MUXER 0
+#define CONFIG_OPUS_MUXER 0
+#define CONFIG_PCM_ALAW_MUXER 0
+#define CONFIG_PCM_MULAW_MUXER 0
+#define CONFIG_PCM_VIDC_MUXER 0
+#define CONFIG_PCM_F64BE_MUXER 0
+#define CONFIG_PCM_F64LE_MUXER 0
+#define CONFIG_PCM_F32BE_MUXER 0
+#define CONFIG_PCM_F32LE_MUXER 0
+#define CONFIG_PCM_S32BE_MUXER 0
+#define CONFIG_PCM_S32LE_MUXER 0
+#define CONFIG_PCM_S24BE_MUXER 0
+#define CONFIG_PCM_S24LE_MUXER 0
+#define CONFIG_PCM_S16BE_MUXER 0
+#define CONFIG_PCM_S16LE_MUXER 0
+#define CONFIG_PCM_S8_MUXER 0
+#define CONFIG_PCM_U32BE_MUXER 0
+#define CONFIG_PCM_U32LE_MUXER 0
+#define CONFIG_PCM_U24BE_MUXER 0
+#define CONFIG_PCM_U24LE_MUXER 0
+#define CONFIG_PCM_U16BE_MUXER 0
+#define CONFIG_PCM_U16LE_MUXER 0
+#define CONFIG_PCM_U8_MUXER 0
+#define CONFIG_PSP_MUXER 0
+#define CONFIG_RAWVIDEO_MUXER 0
+#define CONFIG_RM_MUXER 0
+#define CONFIG_ROQ_MUXER 0
+#define CONFIG_RSO_MUXER 0
+#define CONFIG_RTP_MUXER 0
+#define CONFIG_RTP_MPEGTS_MUXER 0
+#define CONFIG_RTSP_MUXER 0
+#define CONFIG_SAP_MUXER 0
+#define CONFIG_SBC_MUXER 0
+#define CONFIG_SCC_MUXER 0
+#define CONFIG_SEGAFILM_MUXER 0
+#define CONFIG_SEGMENT_MUXER 0
+#define CONFIG_STREAM_SEGMENT_MUXER 0
+#define CONFIG_SMJPEG_MUXER 0
+#define CONFIG_SMOOTHSTREAMING_MUXER 0
+#define CONFIG_SOX_MUXER 0
+#define CONFIG_SPX_MUXER 0
+#define CONFIG_SPDIF_MUXER 0
+#define CONFIG_SRT_MUXER 0
+#define CONFIG_STREAMHASH_MUXER 0
+#define CONFIG_SUP_MUXER 0
+#define CONFIG_SWF_MUXER 0
+#define CONFIG_TEE_MUXER 0
+#define CONFIG_TG2_MUXER 0
+#define CONFIG_TGP_MUXER 0
+#define CONFIG_MKVTIMESTAMP_V2_MUXER 0
+#define CONFIG_TRUEHD_MUXER 0
+#define CONFIG_TTA_MUXER 0
+#define CONFIG_TTML_MUXER 0
+#define CONFIG_UNCODEDFRAMECRC_MUXER 0
+#define CONFIG_VC1_MUXER 0
+#define CONFIG_VC1T_MUXER 0
+#define CONFIG_VOC_MUXER 0
+#define CONFIG_W64_MUXER 0
+#define CONFIG_WAV_MUXER 0
+#define CONFIG_WEBM_MUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_MUXER 0
+#define CONFIG_WEBM_CHUNK_MUXER 0
+#define CONFIG_WEBP_MUXER 0
+#define CONFIG_WEBVTT_MUXER 0
+#define CONFIG_WSAUD_MUXER 0
+#define CONFIG_WTV_MUXER 0
+#define CONFIG_WV_MUXER 0
+#define CONFIG_YUV4MPEGPIPE_MUXER 0
+#define CONFIG_CHROMAPRINT_MUXER 0
+#define CONFIG_ASYNC_PROTOCOL 0
+#define CONFIG_BLURAY_PROTOCOL 0
+#define CONFIG_CACHE_PROTOCOL 0
+#define CONFIG_CONCAT_PROTOCOL 0
+#define CONFIG_CONCATF_PROTOCOL 0
+#define CONFIG_CRYPTO_PROTOCOL 0
+#define CONFIG_DATA_PROTOCOL 0
+#define CONFIG_FFRTMPCRYPT_PROTOCOL 0
+#define CONFIG_FFRTMPHTTP_PROTOCOL 0
+#define CONFIG_FILE_PROTOCOL 0
+#define CONFIG_FTP_PROTOCOL 0
+#define CONFIG_GOPHER_PROTOCOL 0
+#define CONFIG_GOPHERS_PROTOCOL 0
+#define CONFIG_HLS_PROTOCOL 0
+#define CONFIG_HTTP_PROTOCOL 0
+#define CONFIG_HTTPPROXY_PROTOCOL 0
+#define CONFIG_HTTPS_PROTOCOL 0
+#define CONFIG_ICECAST_PROTOCOL 0
+#define CONFIG_MMSH_PROTOCOL 0
+#define CONFIG_MMST_PROTOCOL 0
+#define CONFIG_MD5_PROTOCOL 0
+#define CONFIG_PIPE_PROTOCOL 0
+#define CONFIG_PROMPEG_PROTOCOL 0
+#define CONFIG_RTMP_PROTOCOL 0
+#define CONFIG_RTMPE_PROTOCOL 0
+#define CONFIG_RTMPS_PROTOCOL 0
+#define CONFIG_RTMPT_PROTOCOL 0
+#define CONFIG_RTMPTE_PROTOCOL 0
+#define CONFIG_RTMPTS_PROTOCOL 0
+#define CONFIG_RTP_PROTOCOL 0
+#define CONFIG_SCTP_PROTOCOL 0
+#define CONFIG_SRTP_PROTOCOL 0
+#define CONFIG_SUBFILE_PROTOCOL 0
+#define CONFIG_TEE_PROTOCOL 0
+#define CONFIG_TCP_PROTOCOL 0
+#define CONFIG_TLS_PROTOCOL 0
+#define CONFIG_UDP_PROTOCOL 0
+#define CONFIG_UDPLITE_PROTOCOL 0
+#define CONFIG_UNIX_PROTOCOL 0
+#define CONFIG_LIBAMQP_PROTOCOL 0
+#define CONFIG_LIBRIST_PROTOCOL 0
+#define CONFIG_LIBRTMP_PROTOCOL 0
+#define CONFIG_LIBRTMPE_PROTOCOL 0
+#define CONFIG_LIBRTMPS_PROTOCOL 0
+#define CONFIG_LIBRTMPT_PROTOCOL 0
+#define CONFIG_LIBRTMPTE_PROTOCOL 0
+#define CONFIG_LIBSRT_PROTOCOL 0
+#define CONFIG_LIBSSH_PROTOCOL 0
+#define CONFIG_LIBSMBCLIENT_PROTOCOL 0
+#define CONFIG_LIBZMQ_PROTOCOL 0
+#define CONFIG_IPFS_PROTOCOL 0
+#define CONFIG_IPNS_PROTOCOL 0
+#endif /* FFMPEG_CONFIG_COMPONENTS_H */
diff -Naur a/media/ffvpx/config_components_audio_video.h b/media/ffvpx/config_components_audio_video.h
--- a/media/ffvpx/config_components_audio_video.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_components_audio_video.h	2023-04-06 12:50:11.785664945 +0200
@@ -0,0 +1,2091 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_COMPONENTS_H
+#define FFMPEG_CONFIG_COMPONENTS_H
+#define CONFIG_AAC_ADTSTOASC_BSF 0
+#define CONFIG_AV1_FRAME_MERGE_BSF 0
+#define CONFIG_AV1_FRAME_SPLIT_BSF 0
+#define CONFIG_AV1_METADATA_BSF 0
+#define CONFIG_CHOMP_BSF 0
+#define CONFIG_DUMP_EXTRADATA_BSF 0
+#define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DV_ERROR_MARKER_BSF 0
+#define CONFIG_EAC3_CORE_BSF 0
+#define CONFIG_EXTRACT_EXTRADATA_BSF 0
+#define CONFIG_FILTER_UNITS_BSF 0
+#define CONFIG_H264_METADATA_BSF 0
+#define CONFIG_H264_MP4TOANNEXB_BSF 0
+#define CONFIG_H264_REDUNDANT_PPS_BSF 0
+#define CONFIG_HAPQA_EXTRACT_BSF 0
+#define CONFIG_HEVC_METADATA_BSF 0
+#define CONFIG_HEVC_MP4TOANNEXB_BSF 0
+#define CONFIG_IMX_DUMP_HEADER_BSF 0
+#define CONFIG_MJPEG2JPEG_BSF 0
+#define CONFIG_MJPEGA_DUMP_HEADER_BSF 0
+#define CONFIG_MP3_HEADER_DECOMPRESS_BSF 0
+#define CONFIG_MPEG2_METADATA_BSF 0
+#define CONFIG_MPEG4_UNPACK_BFRAMES_BSF 0
+#define CONFIG_MOV2TEXTSUB_BSF 0
+#define CONFIG_NOISE_BSF 0
+#define CONFIG_NULL_BSF 0
+#define CONFIG_OPUS_METADATA_BSF 0
+#define CONFIG_PCM_RECHUNK_BSF 0
+#define CONFIG_PGS_FRAME_MERGE_BSF 0
+#define CONFIG_PRORES_METADATA_BSF 0
+#define CONFIG_REMOVE_EXTRADATA_BSF 0
+#define CONFIG_SETTS_BSF 0
+#define CONFIG_TEXT2MOVSUB_BSF 0
+#define CONFIG_TRACE_HEADERS_BSF 0
+#define CONFIG_TRUEHD_CORE_BSF 0
+#define CONFIG_VP9_METADATA_BSF 0
+#define CONFIG_VP9_RAW_REORDER_BSF 0
+#define CONFIG_VP9_SUPERFRAME_BSF 0
+#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
+#define CONFIG_AASC_DECODER 0
+#define CONFIG_AIC_DECODER 0
+#define CONFIG_ALIAS_PIX_DECODER 0
+#define CONFIG_AGM_DECODER 0
+#define CONFIG_AMV_DECODER 0
+#define CONFIG_ANM_DECODER 0
+#define CONFIG_ANSI_DECODER 0
+#define CONFIG_APNG_DECODER 0
+#define CONFIG_ARBC_DECODER 0
+#define CONFIG_ARGO_DECODER 0
+#define CONFIG_ASV1_DECODER 0
+#define CONFIG_ASV2_DECODER 0
+#define CONFIG_AURA_DECODER 0
+#define CONFIG_AURA2_DECODER 0
+#define CONFIG_AVRP_DECODER 0
+#define CONFIG_AVRN_DECODER 0
+#define CONFIG_AVS_DECODER 0
+#define CONFIG_AVUI_DECODER 0
+#define CONFIG_AYUV_DECODER 0
+#define CONFIG_BETHSOFTVID_DECODER 0
+#define CONFIG_BFI_DECODER 0
+#define CONFIG_BINK_DECODER 0
+#define CONFIG_BITPACKED_DECODER 0
+#define CONFIG_BMP_DECODER 0
+#define CONFIG_BMV_VIDEO_DECODER 0
+#define CONFIG_BRENDER_PIX_DECODER 0
+#define CONFIG_C93_DECODER 0
+#define CONFIG_CAVS_DECODER 0
+#define CONFIG_CDGRAPHICS_DECODER 0
+#define CONFIG_CDTOONS_DECODER 0
+#define CONFIG_CDXL_DECODER 0
+#define CONFIG_CFHD_DECODER 0
+#define CONFIG_CINEPAK_DECODER 0
+#define CONFIG_CLEARVIDEO_DECODER 0
+#define CONFIG_CLJR_DECODER 0
+#define CONFIG_CLLC_DECODER 0
+#define CONFIG_COMFORTNOISE_DECODER 0
+#define CONFIG_CPIA_DECODER 0
+#define CONFIG_CRI_DECODER 0
+#define CONFIG_CSCD_DECODER 0
+#define CONFIG_CYUV_DECODER 0
+#define CONFIG_DDS_DECODER 0
+#define CONFIG_DFA_DECODER 0
+#define CONFIG_DIRAC_DECODER 0
+#define CONFIG_DNXHD_DECODER 0
+#define CONFIG_DPX_DECODER 0
+#define CONFIG_DSICINVIDEO_DECODER 0
+#define CONFIG_DVAUDIO_DECODER 0
+#define CONFIG_DVVIDEO_DECODER 0
+#define CONFIG_DXA_DECODER 0
+#define CONFIG_DXTORY_DECODER 0
+#define CONFIG_DXV_DECODER 0
+#define CONFIG_EACMV_DECODER 0
+#define CONFIG_EAMAD_DECODER 0
+#define CONFIG_EATGQ_DECODER 0
+#define CONFIG_EATGV_DECODER 0
+#define CONFIG_EATQI_DECODER 0
+#define CONFIG_EIGHTBPS_DECODER 0
+#define CONFIG_EIGHTSVX_EXP_DECODER 0
+#define CONFIG_EIGHTSVX_FIB_DECODER 0
+#define CONFIG_ESCAPE124_DECODER 0
+#define CONFIG_ESCAPE130_DECODER 0
+#define CONFIG_EXR_DECODER 0
+#define CONFIG_FFV1_DECODER 0
+#define CONFIG_FFVHUFF_DECODER 0
+#define CONFIG_FIC_DECODER 0
+#define CONFIG_FITS_DECODER 0
+#define CONFIG_FLASHSV_DECODER 0
+#define CONFIG_FLASHSV2_DECODER 0
+#define CONFIG_FLIC_DECODER 0
+#define CONFIG_FLV_DECODER 0
+#define CONFIG_FMVC_DECODER 0
+#define CONFIG_FOURXM_DECODER 0
+#define CONFIG_FRAPS_DECODER 0
+#define CONFIG_FRWU_DECODER 0
+#define CONFIG_G2M_DECODER 0
+#define CONFIG_GDV_DECODER 0
+#define CONFIG_GEM_DECODER 0
+#define CONFIG_GIF_DECODER 0
+#define CONFIG_H261_DECODER 0
+#define CONFIG_H263_DECODER 0
+#define CONFIG_H263I_DECODER 0
+#define CONFIG_H263P_DECODER 0
+#define CONFIG_H263_V4L2M2M_DECODER 0
+#define CONFIG_H264_DECODER 0
+#define CONFIG_H264_CRYSTALHD_DECODER 0
+#define CONFIG_H264_V4L2M2M_DECODER 0
+#define CONFIG_H264_MEDIACODEC_DECODER 0
+#define CONFIG_H264_MMAL_DECODER 0
+#define CONFIG_H264_QSV_DECODER 0
+#define CONFIG_H264_RKMPP_DECODER 0
+#define CONFIG_HAP_DECODER 0
+#define CONFIG_HEVC_DECODER 0
+#define CONFIG_HEVC_QSV_DECODER 0
+#define CONFIG_HEVC_RKMPP_DECODER 0
+#define CONFIG_HEVC_V4L2M2M_DECODER 0
+#define CONFIG_HNM4_VIDEO_DECODER 0
+#define CONFIG_HQ_HQA_DECODER 0
+#define CONFIG_HQX_DECODER 0
+#define CONFIG_HUFFYUV_DECODER 0
+#define CONFIG_HYMT_DECODER 0
+#define CONFIG_IDCIN_DECODER 0
+#define CONFIG_IFF_ILBM_DECODER 0
+#define CONFIG_IMM4_DECODER 0
+#define CONFIG_IMM5_DECODER 0
+#define CONFIG_INDEO2_DECODER 0
+#define CONFIG_INDEO3_DECODER 0
+#define CONFIG_INDEO4_DECODER 0
+#define CONFIG_INDEO5_DECODER 0
+#define CONFIG_INTERPLAY_VIDEO_DECODER 0
+#define CONFIG_IPU_DECODER 0
+#define CONFIG_JPEG2000_DECODER 0
+#define CONFIG_JPEGLS_DECODER 0
+#define CONFIG_JV_DECODER 0
+#define CONFIG_KGV1_DECODER 0
+#define CONFIG_KMVC_DECODER 0
+#define CONFIG_LAGARITH_DECODER 0
+#define CONFIG_LOCO_DECODER 0
+#define CONFIG_LSCR_DECODER 0
+#define CONFIG_M101_DECODER 0
+#define CONFIG_MAGICYUV_DECODER 0
+#define CONFIG_MDEC_DECODER 0
+#define CONFIG_MIMIC_DECODER 0
+#define CONFIG_MJPEG_DECODER 0
+#define CONFIG_MJPEGB_DECODER 0
+#define CONFIG_MMVIDEO_DECODER 0
+#define CONFIG_MOBICLIP_DECODER 0
+#define CONFIG_MOTIONPIXELS_DECODER 0
+#define CONFIG_MPEG1VIDEO_DECODER 0
+#define CONFIG_MPEG2VIDEO_DECODER 0
+#define CONFIG_MPEG4_DECODER 0
+#define CONFIG_MPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG4_V4L2M2M_DECODER 0
+#define CONFIG_MPEG4_MMAL_DECODER 0
+#define CONFIG_MPEGVIDEO_DECODER 0
+#define CONFIG_MPEG1_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_MMAL_DECODER 0
+#define CONFIG_MPEG2_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG2_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_QSV_DECODER 0
+#define CONFIG_MPEG2_MEDIACODEC_DECODER 0
+#define CONFIG_MSA1_DECODER 0
+#define CONFIG_MSCC_DECODER 0
+#define CONFIG_MSMPEG4V1_DECODER 0
+#define CONFIG_MSMPEG4V2_DECODER 0
+#define CONFIG_MSMPEG4V3_DECODER 0
+#define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MSP2_DECODER 0
+#define CONFIG_MSRLE_DECODER 0
+#define CONFIG_MSS1_DECODER 0
+#define CONFIG_MSS2_DECODER 0
+#define CONFIG_MSVIDEO1_DECODER 0
+#define CONFIG_MSZH_DECODER 0
+#define CONFIG_MTS2_DECODER 0
+#define CONFIG_MV30_DECODER 0
+#define CONFIG_MVC1_DECODER 0
+#define CONFIG_MVC2_DECODER 0
+#define CONFIG_MVDV_DECODER 0
+#define CONFIG_MVHA_DECODER 0
+#define CONFIG_MWSC_DECODER 0
+#define CONFIG_MXPEG_DECODER 0
+#define CONFIG_NOTCHLC_DECODER 0
+#define CONFIG_NUV_DECODER 0
+#define CONFIG_PAF_VIDEO_DECODER 0
+#define CONFIG_PAM_DECODER 0
+#define CONFIG_PBM_DECODER 0
+#define CONFIG_PCX_DECODER 0
+#define CONFIG_PFM_DECODER 0
+#define CONFIG_PGM_DECODER 0
+#define CONFIG_PGMYUV_DECODER 0
+#define CONFIG_PGX_DECODER 0
+#define CONFIG_PHOTOCD_DECODER 0
+#define CONFIG_PICTOR_DECODER 0
+#define CONFIG_PIXLET_DECODER 0
+#define CONFIG_PNG_DECODER 0
+#define CONFIG_PPM_DECODER 0
+#define CONFIG_PRORES_DECODER 0
+#define CONFIG_PROSUMER_DECODER 0
+#define CONFIG_PSD_DECODER 0
+#define CONFIG_PTX_DECODER 0
+#define CONFIG_QDRAW_DECODER 0
+#define CONFIG_QOI_DECODER 0
+#define CONFIG_QPEG_DECODER 0
+#define CONFIG_QTRLE_DECODER 0
+#define CONFIG_R10K_DECODER 0
+#define CONFIG_R210_DECODER 0
+#define CONFIG_RASC_DECODER 0
+#define CONFIG_RAWVIDEO_DECODER 0
+#define CONFIG_RL2_DECODER 0
+#define CONFIG_ROQ_DECODER 0
+#define CONFIG_RPZA_DECODER 0
+#define CONFIG_RSCC_DECODER 0
+#define CONFIG_RV10_DECODER 0
+#define CONFIG_RV20_DECODER 0
+#define CONFIG_RV30_DECODER 0
+#define CONFIG_RV40_DECODER 0
+#define CONFIG_S302M_DECODER 0
+#define CONFIG_SANM_DECODER 0
+#define CONFIG_SCPR_DECODER 0
+#define CONFIG_SCREENPRESSO_DECODER 0
+#define CONFIG_SGA_DECODER 0
+#define CONFIG_SGI_DECODER 0
+#define CONFIG_SGIRLE_DECODER 0
+#define CONFIG_SHEERVIDEO_DECODER 0
+#define CONFIG_SIMBIOSIS_IMX_DECODER 0
+#define CONFIG_SMACKER_DECODER 0
+#define CONFIG_SMC_DECODER 0
+#define CONFIG_SMVJPEG_DECODER 0
+#define CONFIG_SNOW_DECODER 0
+#define CONFIG_SP5X_DECODER 0
+#define CONFIG_SPEEDHQ_DECODER 0
+#define CONFIG_SPEEX_DECODER 0
+#define CONFIG_SRGC_DECODER 0
+#define CONFIG_SUNRAST_DECODER 0
+#define CONFIG_SVQ1_DECODER 0
+#define CONFIG_SVQ3_DECODER 0
+#define CONFIG_TARGA_DECODER 0
+#define CONFIG_TARGA_Y216_DECODER 0
+#define CONFIG_TDSC_DECODER 0
+#define CONFIG_THEORA_DECODER 0
+#define CONFIG_THP_DECODER 0
+#define CONFIG_TIERTEXSEQVIDEO_DECODER 0
+#define CONFIG_TIFF_DECODER 0
+#define CONFIG_TMV_DECODER 0
+#define CONFIG_TRUEMOTION1_DECODER 0
+#define CONFIG_TRUEMOTION2_DECODER 0
+#define CONFIG_TRUEMOTION2RT_DECODER 0
+#define CONFIG_TSCC_DECODER 0
+#define CONFIG_TSCC2_DECODER 0
+#define CONFIG_TXD_DECODER 0
+#define CONFIG_ULTI_DECODER 0
+#define CONFIG_UTVIDEO_DECODER 0
+#define CONFIG_V210_DECODER 0
+#define CONFIG_V210X_DECODER 0
+#define CONFIG_V308_DECODER 0
+#define CONFIG_V408_DECODER 0
+#define CONFIG_V410_DECODER 0
+#define CONFIG_VB_DECODER 0
+#define CONFIG_VBN_DECODER 0
+#define CONFIG_VBLE_DECODER 0
+#define CONFIG_VC1_DECODER 0
+#define CONFIG_VC1_CRYSTALHD_DECODER 0
+#define CONFIG_VC1IMAGE_DECODER 0
+#define CONFIG_VC1_MMAL_DECODER 0
+#define CONFIG_VC1_QSV_DECODER 0
+#define CONFIG_VC1_V4L2M2M_DECODER 0
+#define CONFIG_VCR1_DECODER 0
+#define CONFIG_VMDVIDEO_DECODER 0
+#define CONFIG_VMNC_DECODER 0
+#define CONFIG_VP3_DECODER 0
+#define CONFIG_VP4_DECODER 0
+#define CONFIG_VP5_DECODER 0
+#define CONFIG_VP6_DECODER 0
+#define CONFIG_VP6A_DECODER 0
+#define CONFIG_VP6F_DECODER 0
+#define CONFIG_VP7_DECODER 0
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP8_RKMPP_DECODER 0
+#define CONFIG_VP8_V4L2M2M_DECODER 0
+#define CONFIG_VP9_DECODER 1
+#define CONFIG_VP9_RKMPP_DECODER 0
+#define CONFIG_VP9_V4L2M2M_DECODER 0
+#define CONFIG_VQA_DECODER 0
+#define CONFIG_WEBP_DECODER 0
+#define CONFIG_WCMV_DECODER 0
+#define CONFIG_WRAPPED_AVFRAME_DECODER 0
+#define CONFIG_WMV1_DECODER 0
+#define CONFIG_WMV2_DECODER 0
+#define CONFIG_WMV3_DECODER 0
+#define CONFIG_WMV3_CRYSTALHD_DECODER 0
+#define CONFIG_WMV3IMAGE_DECODER 0
+#define CONFIG_WNV1_DECODER 0
+#define CONFIG_XAN_WC3_DECODER 0
+#define CONFIG_XAN_WC4_DECODER 0
+#define CONFIG_XBM_DECODER 0
+#define CONFIG_XFACE_DECODER 0
+#define CONFIG_XL_DECODER 0
+#define CONFIG_XPM_DECODER 0
+#define CONFIG_XWD_DECODER 0
+#define CONFIG_Y41P_DECODER 0
+#define CONFIG_YLC_DECODER 0
+#define CONFIG_YOP_DECODER 0
+#define CONFIG_YUV4_DECODER 0
+#define CONFIG_ZERO12V_DECODER 0
+#define CONFIG_ZEROCODEC_DECODER 0
+#define CONFIG_ZLIB_DECODER 0
+#define CONFIG_ZMBV_DECODER 0
+#define CONFIG_AAC_DECODER 0
+#define CONFIG_AAC_FIXED_DECODER 0
+#define CONFIG_AAC_LATM_DECODER 0
+#define CONFIG_AC3_DECODER 0
+#define CONFIG_AC3_FIXED_DECODER 0
+#define CONFIG_ACELP_KELVIN_DECODER 0
+#define CONFIG_ALAC_DECODER 0
+#define CONFIG_ALS_DECODER 0
+#define CONFIG_AMRNB_DECODER 0
+#define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APE_DECODER 0
+#define CONFIG_APTX_DECODER 0
+#define CONFIG_APTX_HD_DECODER 0
+#define CONFIG_ATRAC1_DECODER 0
+#define CONFIG_ATRAC3_DECODER 0
+#define CONFIG_ATRAC3AL_DECODER 0
+#define CONFIG_ATRAC3P_DECODER 0
+#define CONFIG_ATRAC3PAL_DECODER 0
+#define CONFIG_ATRAC9_DECODER 0
+#define CONFIG_BINKAUDIO_DCT_DECODER 0
+#define CONFIG_BINKAUDIO_RDFT_DECODER 0
+#define CONFIG_BMV_AUDIO_DECODER 0
+#define CONFIG_COOK_DECODER 0
+#define CONFIG_DCA_DECODER 0
+#define CONFIG_DFPWM_DECODER 0
+#define CONFIG_DOLBY_E_DECODER 0
+#define CONFIG_DSD_LSBF_DECODER 0
+#define CONFIG_DSD_MSBF_DECODER 0
+#define CONFIG_DSD_LSBF_PLANAR_DECODER 0
+#define CONFIG_DSD_MSBF_PLANAR_DECODER 0
+#define CONFIG_DSICINAUDIO_DECODER 0
+#define CONFIG_DSS_SP_DECODER 0
+#define CONFIG_DST_DECODER 0
+#define CONFIG_EAC3_DECODER 0
+#define CONFIG_EVRC_DECODER 0
+#define CONFIG_FASTAUDIO_DECODER 0
+#define CONFIG_FFWAVESYNTH_DECODER 0
+#define CONFIG_FLAC_DECODER 1
+#define CONFIG_G723_1_DECODER 0
+#define CONFIG_G729_DECODER 0
+#define CONFIG_GSM_DECODER 0
+#define CONFIG_GSM_MS_DECODER 0
+#define CONFIG_HCA_DECODER 0
+#define CONFIG_HCOM_DECODER 0
+#define CONFIG_IAC_DECODER 0
+#define CONFIG_ILBC_DECODER 0
+#define CONFIG_IMC_DECODER 0
+#define CONFIG_INTERPLAY_ACM_DECODER 0
+#define CONFIG_MACE3_DECODER 0
+#define CONFIG_MACE6_DECODER 0
+#define CONFIG_METASOUND_DECODER 0
+#define CONFIG_MLP_DECODER 0
+#define CONFIG_MP1_DECODER 0
+#define CONFIG_MP1FLOAT_DECODER 0
+#define CONFIG_MP2_DECODER 0
+#define CONFIG_MP2FLOAT_DECODER 0
+#define CONFIG_MP3FLOAT_DECODER 0
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_MP3ADUFLOAT_DECODER 0
+#define CONFIG_MP3ADU_DECODER 0
+#define CONFIG_MP3ON4FLOAT_DECODER 0
+#define CONFIG_MP3ON4_DECODER 0
+#define CONFIG_MPC7_DECODER 0
+#define CONFIG_MPC8_DECODER 0
+#define CONFIG_MSNSIREN_DECODER 0
+#define CONFIG_NELLYMOSER_DECODER 0
+#define CONFIG_ON2AVC_DECODER 0
+#define CONFIG_OPUS_DECODER 0
+#define CONFIG_PAF_AUDIO_DECODER 0
+#define CONFIG_QCELP_DECODER 0
+#define CONFIG_QDM2_DECODER 0
+#define CONFIG_QDMC_DECODER 0
+#define CONFIG_RA_144_DECODER 0
+#define CONFIG_RA_288_DECODER 0
+#define CONFIG_RALF_DECODER 0
+#define CONFIG_SBC_DECODER 0
+#define CONFIG_SHORTEN_DECODER 0
+#define CONFIG_SIPR_DECODER 0
+#define CONFIG_SIREN_DECODER 0
+#define CONFIG_SMACKAUD_DECODER 0
+#define CONFIG_SONIC_DECODER 0
+#define CONFIG_TAK_DECODER 0
+#define CONFIG_TRUEHD_DECODER 0
+#define CONFIG_TRUESPEECH_DECODER 0
+#define CONFIG_TTA_DECODER 0
+#define CONFIG_TWINVQ_DECODER 0
+#define CONFIG_VMDAUDIO_DECODER 0
+#define CONFIG_VORBIS_DECODER 0
+#define CONFIG_WAVPACK_DECODER 0
+#define CONFIG_WMALOSSLESS_DECODER 0
+#define CONFIG_WMAPRO_DECODER 0
+#define CONFIG_WMAV1_DECODER 0
+#define CONFIG_WMAV2_DECODER 0
+#define CONFIG_WMAVOICE_DECODER 0
+#define CONFIG_WS_SND1_DECODER 0
+#define CONFIG_XMA1_DECODER 0
+#define CONFIG_XMA2_DECODER 0
+#define CONFIG_PCM_ALAW_DECODER 0
+#define CONFIG_PCM_BLURAY_DECODER 0
+#define CONFIG_PCM_DVD_DECODER 0
+#define CONFIG_PCM_F16LE_DECODER 0
+#define CONFIG_PCM_F24LE_DECODER 0
+#define CONFIG_PCM_F32BE_DECODER 0
+#define CONFIG_PCM_F32LE_DECODER 0
+#define CONFIG_PCM_F64BE_DECODER 0
+#define CONFIG_PCM_F64LE_DECODER 0
+#define CONFIG_PCM_LXF_DECODER 0
+#define CONFIG_PCM_MULAW_DECODER 0
+#define CONFIG_PCM_S8_DECODER 0
+#define CONFIG_PCM_S8_PLANAR_DECODER 0
+#define CONFIG_PCM_S16BE_DECODER 0
+#define CONFIG_PCM_S16BE_PLANAR_DECODER 0
+#define CONFIG_PCM_S16LE_DECODER 0
+#define CONFIG_PCM_S16LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S24BE_DECODER 0
+#define CONFIG_PCM_S24DAUD_DECODER 0
+#define CONFIG_PCM_S24LE_DECODER 0
+#define CONFIG_PCM_S24LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S32BE_DECODER 0
+#define CONFIG_PCM_S32LE_DECODER 0
+#define CONFIG_PCM_S32LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S64BE_DECODER 0
+#define CONFIG_PCM_S64LE_DECODER 0
+#define CONFIG_PCM_SGA_DECODER 0
+#define CONFIG_PCM_U8_DECODER 0
+#define CONFIG_PCM_U16BE_DECODER 0
+#define CONFIG_PCM_U16LE_DECODER 0
+#define CONFIG_PCM_U24BE_DECODER 0
+#define CONFIG_PCM_U24LE_DECODER 0
+#define CONFIG_PCM_U32BE_DECODER 0
+#define CONFIG_PCM_U32LE_DECODER 0
+#define CONFIG_PCM_VIDC_DECODER 0
+#define CONFIG_DERF_DPCM_DECODER 0
+#define CONFIG_GREMLIN_DPCM_DECODER 0
+#define CONFIG_INTERPLAY_DPCM_DECODER 0
+#define CONFIG_ROQ_DPCM_DECODER 0
+#define CONFIG_SDX2_DPCM_DECODER 0
+#define CONFIG_SOL_DPCM_DECODER 0
+#define CONFIG_XAN_DPCM_DECODER 0
+#define CONFIG_ADPCM_4XM_DECODER 0
+#define CONFIG_ADPCM_ADX_DECODER 0
+#define CONFIG_ADPCM_AFC_DECODER 0
+#define CONFIG_ADPCM_AGM_DECODER 0
+#define CONFIG_ADPCM_AICA_DECODER 0
+#define CONFIG_ADPCM_ARGO_DECODER 0
+#define CONFIG_ADPCM_CT_DECODER 0
+#define CONFIG_ADPCM_DTK_DECODER 0
+#define CONFIG_ADPCM_EA_DECODER 0
+#define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 0
+#define CONFIG_ADPCM_EA_R1_DECODER 0
+#define CONFIG_ADPCM_EA_R2_DECODER 0
+#define CONFIG_ADPCM_EA_R3_DECODER 0
+#define CONFIG_ADPCM_EA_XAS_DECODER 0
+#define CONFIG_ADPCM_G722_DECODER 0
+#define CONFIG_ADPCM_G726_DECODER 0
+#define CONFIG_ADPCM_G726LE_DECODER 0
+#define CONFIG_ADPCM_IMA_ACORN_DECODER 0
+#define CONFIG_ADPCM_IMA_AMV_DECODER 0
+#define CONFIG_ADPCM_IMA_ALP_DECODER 0
+#define CONFIG_ADPCM_IMA_APC_DECODER 0
+#define CONFIG_ADPCM_IMA_APM_DECODER 0
+#define CONFIG_ADPCM_IMA_CUNNING_DECODER 0
+#define CONFIG_ADPCM_IMA_DAT4_DECODER 0
+#define CONFIG_ADPCM_IMA_DK3_DECODER 0
+#define CONFIG_ADPCM_IMA_DK4_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_EACS_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 0
+#define CONFIG_ADPCM_IMA_ISS_DECODER 0
+#define CONFIG_ADPCM_IMA_MOFLEX_DECODER 0
+#define CONFIG_ADPCM_IMA_MTF_DECODER 0
+#define CONFIG_ADPCM_IMA_OKI_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_DECODER 0
+#define CONFIG_ADPCM_IMA_RAD_DECODER 0
+#define CONFIG_ADPCM_IMA_SSI_DECODER 0
+#define CONFIG_ADPCM_IMA_SMJPEG_DECODER 0
+#define CONFIG_ADPCM_IMA_WAV_DECODER 0
+#define CONFIG_ADPCM_IMA_WS_DECODER 0
+#define CONFIG_ADPCM_MS_DECODER 0
+#define CONFIG_ADPCM_MTAF_DECODER 0
+#define CONFIG_ADPCM_PSX_DECODER 0
+#define CONFIG_ADPCM_SBPRO_2_DECODER 0
+#define CONFIG_ADPCM_SBPRO_3_DECODER 0
+#define CONFIG_ADPCM_SBPRO_4_DECODER 0
+#define CONFIG_ADPCM_SWF_DECODER 0
+#define CONFIG_ADPCM_THP_DECODER 0
+#define CONFIG_ADPCM_THP_LE_DECODER 0
+#define CONFIG_ADPCM_VIMA_DECODER 0
+#define CONFIG_ADPCM_XA_DECODER 0
+#define CONFIG_ADPCM_YAMAHA_DECODER 0
+#define CONFIG_ADPCM_ZORK_DECODER 0
+#define CONFIG_SSA_DECODER 0
+#define CONFIG_ASS_DECODER 0
+#define CONFIG_CCAPTION_DECODER 0
+#define CONFIG_DVBSUB_DECODER 0
+#define CONFIG_DVDSUB_DECODER 0
+#define CONFIG_JACOSUB_DECODER 0
+#define CONFIG_MICRODVD_DECODER 0
+#define CONFIG_MOVTEXT_DECODER 0
+#define CONFIG_MPL2_DECODER 0
+#define CONFIG_PGSSUB_DECODER 0
+#define CONFIG_PJS_DECODER 0
+#define CONFIG_REALTEXT_DECODER 0
+#define CONFIG_SAMI_DECODER 0
+#define CONFIG_SRT_DECODER 0
+#define CONFIG_STL_DECODER 0
+#define CONFIG_SUBRIP_DECODER 0
+#define CONFIG_SUBVIEWER_DECODER 0
+#define CONFIG_SUBVIEWER1_DECODER 0
+#define CONFIG_TEXT_DECODER 0
+#define CONFIG_VPLAYER_DECODER 0
+#define CONFIG_WEBVTT_DECODER 0
+#define CONFIG_XSUB_DECODER 0
+#define CONFIG_AAC_AT_DECODER 0
+#define CONFIG_AC3_AT_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_AT_DECODER 0
+#define CONFIG_ALAC_AT_DECODER 0
+#define CONFIG_AMR_NB_AT_DECODER 0
+#define CONFIG_EAC3_AT_DECODER 0
+#define CONFIG_GSM_MS_AT_DECODER 0
+#define CONFIG_ILBC_AT_DECODER 0
+#define CONFIG_MP1_AT_DECODER 0
+#define CONFIG_MP2_AT_DECODER 0
+#define CONFIG_MP3_AT_DECODER 0
+#define CONFIG_PCM_ALAW_AT_DECODER 0
+#define CONFIG_PCM_MULAW_AT_DECODER 0
+#define CONFIG_QDMC_AT_DECODER 0
+#define CONFIG_QDM2_AT_DECODER 0
+#define CONFIG_LIBARIBB24_DECODER 0
+#define CONFIG_LIBCELT_DECODER 0
+#define CONFIG_LIBCODEC2_DECODER 0
+#define CONFIG_LIBDAV1D_DECODER 1
+#define CONFIG_LIBDAVS2_DECODER 0
+#define CONFIG_LIBFDK_AAC_DECODER 0
+#define CONFIG_LIBGSM_DECODER 0
+#define CONFIG_LIBGSM_MS_DECODER 0
+#define CONFIG_LIBILBC_DECODER 0
+#define CONFIG_LIBJXL_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
+#define CONFIG_LIBOPENJPEG_DECODER 0
+#define CONFIG_LIBOPUS_DECODER 0
+#define CONFIG_LIBRSVG_DECODER 0
+#define CONFIG_LIBSPEEX_DECODER 0
+#define CONFIG_LIBUAVS3D_DECODER 0
+#define CONFIG_LIBVORBIS_DECODER 0
+#define CONFIG_LIBVPX_VP8_DECODER 0
+#define CONFIG_LIBVPX_VP9_DECODER 0
+#define CONFIG_LIBZVBI_TELETEXT_DECODER 0
+#define CONFIG_BINTEXT_DECODER 0
+#define CONFIG_XBIN_DECODER 0
+#define CONFIG_IDF_DECODER 0
+#define CONFIG_LIBAOM_AV1_DECODER 0
+#define CONFIG_AV1_DECODER 1
+#define CONFIG_AV1_CUVID_DECODER 0
+#define CONFIG_AV1_QSV_DECODER 0
+#define CONFIG_LIBOPENH264_DECODER 0
+#define CONFIG_H264_CUVID_DECODER 0
+#define CONFIG_HEVC_CUVID_DECODER 0
+#define CONFIG_HEVC_MEDIACODEC_DECODER 0
+#define CONFIG_MJPEG_CUVID_DECODER 0
+#define CONFIG_MJPEG_QSV_DECODER 0
+#define CONFIG_MPEG1_CUVID_DECODER 0
+#define CONFIG_MPEG2_CUVID_DECODER 0
+#define CONFIG_MPEG4_CUVID_DECODER 0
+#define CONFIG_MPEG4_MEDIACODEC_DECODER 0
+#define CONFIG_VC1_CUVID_DECODER 0
+#define CONFIG_VP8_CUVID_DECODER 0
+#define CONFIG_VP8_MEDIACODEC_DECODER 0
+#define CONFIG_VP8_QSV_DECODER 0
+#define CONFIG_VP9_CUVID_DECODER 0
+#define CONFIG_VP9_MEDIACODEC_DECODER 0
+#define CONFIG_VP9_QSV_DECODER 0
+#define CONFIG_A64MULTI_ENCODER 0
+#define CONFIG_A64MULTI5_ENCODER 0
+#define CONFIG_ALIAS_PIX_ENCODER 0
+#define CONFIG_AMV_ENCODER 0
+#define CONFIG_APNG_ENCODER 0
+#define CONFIG_ASV1_ENCODER 0
+#define CONFIG_ASV2_ENCODER 0
+#define CONFIG_AVRP_ENCODER 0
+#define CONFIG_AVUI_ENCODER 0
+#define CONFIG_AYUV_ENCODER 0
+#define CONFIG_BITPACKED_ENCODER 0
+#define CONFIG_BMP_ENCODER 0
+#define CONFIG_CFHD_ENCODER 0
+#define CONFIG_CINEPAK_ENCODER 0
+#define CONFIG_CLJR_ENCODER 0
+#define CONFIG_COMFORTNOISE_ENCODER 0
+#define CONFIG_DNXHD_ENCODER 0
+#define CONFIG_DPX_ENCODER 0
+#define CONFIG_DVVIDEO_ENCODER 0
+#define CONFIG_EXR_ENCODER 0
+#define CONFIG_FFV1_ENCODER 0
+#define CONFIG_FFVHUFF_ENCODER 0
+#define CONFIG_FITS_ENCODER 0
+#define CONFIG_FLASHSV_ENCODER 0
+#define CONFIG_FLASHSV2_ENCODER 0
+#define CONFIG_FLV_ENCODER 0
+#define CONFIG_GIF_ENCODER 0
+#define CONFIG_H261_ENCODER 0
+#define CONFIG_H263_ENCODER 0
+#define CONFIG_H263P_ENCODER 0
+#define CONFIG_HAP_ENCODER 0
+#define CONFIG_HUFFYUV_ENCODER 0
+#define CONFIG_JPEG2000_ENCODER 0
+#define CONFIG_JPEGLS_ENCODER 0
+#define CONFIG_LJPEG_ENCODER 0
+#define CONFIG_MAGICYUV_ENCODER 0
+#define CONFIG_MJPEG_ENCODER 0
+#define CONFIG_MPEG1VIDEO_ENCODER 0
+#define CONFIG_MPEG2VIDEO_ENCODER 0
+#define CONFIG_MPEG4_ENCODER 0
+#define CONFIG_MSMPEG4V2_ENCODER 0
+#define CONFIG_MSMPEG4V3_ENCODER 0
+#define CONFIG_MSVIDEO1_ENCODER 0
+#define CONFIG_PAM_ENCODER 0
+#define CONFIG_PBM_ENCODER 0
+#define CONFIG_PCX_ENCODER 0
+#define CONFIG_PFM_ENCODER 0
+#define CONFIG_PGM_ENCODER 0
+#define CONFIG_PGMYUV_ENCODER 0
+#define CONFIG_PNG_ENCODER 0
+#define CONFIG_PPM_ENCODER 0
+#define CONFIG_PRORES_ENCODER 0
+#define CONFIG_PRORES_AW_ENCODER 0
+#define CONFIG_PRORES_KS_ENCODER 0
+#define CONFIG_QOI_ENCODER 0
+#define CONFIG_QTRLE_ENCODER 0
+#define CONFIG_R10K_ENCODER 0
+#define CONFIG_R210_ENCODER 0
+#define CONFIG_RAWVIDEO_ENCODER 0
+#define CONFIG_ROQ_ENCODER 0
+#define CONFIG_RPZA_ENCODER 0
+#define CONFIG_RV10_ENCODER 0
+#define CONFIG_RV20_ENCODER 0
+#define CONFIG_S302M_ENCODER 0
+#define CONFIG_SGI_ENCODER 0
+#define CONFIG_SMC_ENCODER 0
+#define CONFIG_SNOW_ENCODER 0
+#define CONFIG_SPEEDHQ_ENCODER 0
+#define CONFIG_SUNRAST_ENCODER 0
+#define CONFIG_SVQ1_ENCODER 0
+#define CONFIG_TARGA_ENCODER 0
+#define CONFIG_TIFF_ENCODER 0
+#define CONFIG_UTVIDEO_ENCODER 0
+#define CONFIG_V210_ENCODER 0
+#define CONFIG_V308_ENCODER 0
+#define CONFIG_V408_ENCODER 0
+#define CONFIG_V410_ENCODER 0
+#define CONFIG_VBN_ENCODER 0
+#define CONFIG_VC2_ENCODER 0
+#define CONFIG_WRAPPED_AVFRAME_ENCODER 0
+#define CONFIG_WMV1_ENCODER 0
+#define CONFIG_WMV2_ENCODER 0
+#define CONFIG_XBM_ENCODER 0
+#define CONFIG_XFACE_ENCODER 0
+#define CONFIG_XWD_ENCODER 0
+#define CONFIG_Y41P_ENCODER 0
+#define CONFIG_YUV4_ENCODER 0
+#define CONFIG_ZLIB_ENCODER 0
+#define CONFIG_ZMBV_ENCODER 0
+#define CONFIG_AAC_ENCODER 0
+#define CONFIG_AC3_ENCODER 0
+#define CONFIG_AC3_FIXED_ENCODER 0
+#define CONFIG_ALAC_ENCODER 0
+#define CONFIG_APTX_ENCODER 0
+#define CONFIG_APTX_HD_ENCODER 0
+#define CONFIG_DCA_ENCODER 0
+#define CONFIG_DFPWM_ENCODER 0
+#define CONFIG_EAC3_ENCODER 0
+#define CONFIG_FLAC_ENCODER 0
+#define CONFIG_G723_1_ENCODER 0
+#define CONFIG_MLP_ENCODER 0
+#define CONFIG_MP2_ENCODER 0
+#define CONFIG_MP2FIXED_ENCODER 0
+#define CONFIG_NELLYMOSER_ENCODER 0
+#define CONFIG_OPUS_ENCODER 0
+#define CONFIG_RA_144_ENCODER 0
+#define CONFIG_SBC_ENCODER 0
+#define CONFIG_SONIC_ENCODER 0
+#define CONFIG_SONIC_LS_ENCODER 0
+#define CONFIG_TRUEHD_ENCODER 0
+#define CONFIG_TTA_ENCODER 0
+#define CONFIG_VORBIS_ENCODER 0
+#define CONFIG_WAVPACK_ENCODER 0
+#define CONFIG_WMAV1_ENCODER 0
+#define CONFIG_WMAV2_ENCODER 0
+#define CONFIG_PCM_ALAW_ENCODER 0
+#define CONFIG_PCM_BLURAY_ENCODER 0
+#define CONFIG_PCM_DVD_ENCODER 0
+#define CONFIG_PCM_F32BE_ENCODER 0
+#define CONFIG_PCM_F32LE_ENCODER 0
+#define CONFIG_PCM_F64BE_ENCODER 0
+#define CONFIG_PCM_F64LE_ENCODER 0
+#define CONFIG_PCM_MULAW_ENCODER 0
+#define CONFIG_PCM_S8_ENCODER 0
+#define CONFIG_PCM_S8_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16BE_ENCODER 0
+#define CONFIG_PCM_S16BE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16LE_ENCODER 0
+#define CONFIG_PCM_S16LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S24BE_ENCODER 0
+#define CONFIG_PCM_S24DAUD_ENCODER 0
+#define CONFIG_PCM_S24LE_ENCODER 0
+#define CONFIG_PCM_S24LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S32BE_ENCODER 0
+#define CONFIG_PCM_S32LE_ENCODER 0
+#define CONFIG_PCM_S32LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S64BE_ENCODER 0
+#define CONFIG_PCM_S64LE_ENCODER 0
+#define CONFIG_PCM_U8_ENCODER 0
+#define CONFIG_PCM_U16BE_ENCODER 0
+#define CONFIG_PCM_U16LE_ENCODER 0
+#define CONFIG_PCM_U24BE_ENCODER 0
+#define CONFIG_PCM_U24LE_ENCODER 0
+#define CONFIG_PCM_U32BE_ENCODER 0
+#define CONFIG_PCM_U32LE_ENCODER 0
+#define CONFIG_PCM_VIDC_ENCODER 0
+#define CONFIG_ROQ_DPCM_ENCODER 0
+#define CONFIG_ADPCM_ADX_ENCODER 0
+#define CONFIG_ADPCM_ARGO_ENCODER 0
+#define CONFIG_ADPCM_G722_ENCODER 0
+#define CONFIG_ADPCM_G726_ENCODER 0
+#define CONFIG_ADPCM_G726LE_ENCODER 0
+#define CONFIG_ADPCM_IMA_AMV_ENCODER 0
+#define CONFIG_ADPCM_IMA_ALP_ENCODER 0
+#define CONFIG_ADPCM_IMA_APM_ENCODER 0
+#define CONFIG_ADPCM_IMA_QT_ENCODER 0
+#define CONFIG_ADPCM_IMA_SSI_ENCODER 0
+#define CONFIG_ADPCM_IMA_WAV_ENCODER 0
+#define CONFIG_ADPCM_IMA_WS_ENCODER 0
+#define CONFIG_ADPCM_MS_ENCODER 0
+#define CONFIG_ADPCM_SWF_ENCODER 0
+#define CONFIG_ADPCM_YAMAHA_ENCODER 0
+#define CONFIG_SSA_ENCODER 0
+#define CONFIG_ASS_ENCODER 0
+#define CONFIG_DVBSUB_ENCODER 0
+#define CONFIG_DVDSUB_ENCODER 0
+#define CONFIG_MOVTEXT_ENCODER 0
+#define CONFIG_SRT_ENCODER 0
+#define CONFIG_SUBRIP_ENCODER 0
+#define CONFIG_TEXT_ENCODER 0
+#define CONFIG_TTML_ENCODER 0
+#define CONFIG_WEBVTT_ENCODER 0
+#define CONFIG_XSUB_ENCODER 0
+#define CONFIG_AAC_AT_ENCODER 0
+#define CONFIG_ALAC_AT_ENCODER 0
+#define CONFIG_ILBC_AT_ENCODER 0
+#define CONFIG_PCM_ALAW_AT_ENCODER 0
+#define CONFIG_PCM_MULAW_AT_ENCODER 0
+#define CONFIG_LIBAOM_AV1_ENCODER 0
+#define CONFIG_LIBCODEC2_ENCODER 0
+#define CONFIG_LIBFDK_AAC_ENCODER 0
+#define CONFIG_LIBGSM_ENCODER 0
+#define CONFIG_LIBGSM_MS_ENCODER 0
+#define CONFIG_LIBILBC_ENCODER 0
+#define CONFIG_LIBJXL_ENCODER 0
+#define CONFIG_LIBMP3LAME_ENCODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
+#define CONFIG_LIBOPENJPEG_ENCODER 0
+#define CONFIG_LIBOPUS_ENCODER 0
+#define CONFIG_LIBRAV1E_ENCODER 0
+#define CONFIG_LIBSHINE_ENCODER 0
+#define CONFIG_LIBSPEEX_ENCODER 0
+#define CONFIG_LIBSVTAV1_ENCODER 0
+#define CONFIG_LIBTHEORA_ENCODER 0
+#define CONFIG_LIBTWOLAME_ENCODER 0
+#define CONFIG_LIBVO_AMRWBENC_ENCODER 0
+#define CONFIG_LIBVORBIS_ENCODER 0
+#define CONFIG_LIBVPX_VP8_ENCODER 0
+#define CONFIG_LIBVPX_VP9_ENCODER 0
+#define CONFIG_LIBWEBP_ANIM_ENCODER 0
+#define CONFIG_LIBWEBP_ENCODER 0
+#define CONFIG_LIBX262_ENCODER 0
+#define CONFIG_LIBX264_ENCODER 0
+#define CONFIG_LIBX264RGB_ENCODER 0
+#define CONFIG_LIBX265_ENCODER 0
+#define CONFIG_LIBXAVS_ENCODER 0
+#define CONFIG_LIBXAVS2_ENCODER 0
+#define CONFIG_LIBXVID_ENCODER 0
+#define CONFIG_AAC_MF_ENCODER 0
+#define CONFIG_AC3_MF_ENCODER 0
+#define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_LIBOPENH264_ENCODER 0
+#define CONFIG_H264_AMF_ENCODER 0
+#define CONFIG_H264_MF_ENCODER 0
+#define CONFIG_H264_NVENC_ENCODER 0
+#define CONFIG_H264_OMX_ENCODER 0
+#define CONFIG_H264_QSV_ENCODER 0
+#define CONFIG_H264_V4L2M2M_ENCODER 0
+#define CONFIG_H264_VAAPI_ENCODER 0
+#define CONFIG_H264_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_HEVC_AMF_ENCODER 0
+#define CONFIG_HEVC_MF_ENCODER 0
+#define CONFIG_HEVC_NVENC_ENCODER 0
+#define CONFIG_HEVC_QSV_ENCODER 0
+#define CONFIG_HEVC_V4L2M2M_ENCODER 0
+#define CONFIG_HEVC_VAAPI_ENCODER 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_LIBKVAZAAR_ENCODER 0
+#define CONFIG_MJPEG_QSV_ENCODER 0
+#define CONFIG_MJPEG_VAAPI_ENCODER 0
+#define CONFIG_MP3_MF_ENCODER 0
+#define CONFIG_MPEG2_QSV_ENCODER 0
+#define CONFIG_MPEG2_VAAPI_ENCODER 0
+#define CONFIG_MPEG4_OMX_ENCODER 0
+#define CONFIG_MPEG4_V4L2M2M_ENCODER 0
+#define CONFIG_PRORES_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_VP8_V4L2M2M_ENCODER 0
+#define CONFIG_VP8_VAAPI_ENCODER 0
+#define CONFIG_VP9_VAAPI_ENCODER 0
+#define CONFIG_VP9_QSV_ENCODER 0
+#define CONFIG_AV1_D3D11VA_HWACCEL 0
+#define CONFIG_AV1_D3D11VA2_HWACCEL 0
+#define CONFIG_AV1_DXVA2_HWACCEL 0
+#define CONFIG_AV1_NVDEC_HWACCEL 0
+#define CONFIG_AV1_VAAPI_HWACCEL 0
+#define CONFIG_AV1_VDPAU_HWACCEL 0
+#define CONFIG_H263_VAAPI_HWACCEL 0
+#define CONFIG_H263_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_H264_D3D11VA_HWACCEL 0
+#define CONFIG_H264_D3D11VA2_HWACCEL 0
+#define CONFIG_H264_DXVA2_HWACCEL 0
+#define CONFIG_H264_NVDEC_HWACCEL 0
+#define CONFIG_H264_VAAPI_HWACCEL 0
+#define CONFIG_H264_VDPAU_HWACCEL 0
+#define CONFIG_H264_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA2_HWACCEL 0
+#define CONFIG_HEVC_DXVA2_HWACCEL 0
+#define CONFIG_HEVC_NVDEC_HWACCEL 0
+#define CONFIG_HEVC_VAAPI_HWACCEL 0
+#define CONFIG_HEVC_VDPAU_HWACCEL 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MJPEG_NVDEC_HWACCEL 0
+#define CONFIG_MJPEG_VAAPI_HWACCEL 0
+#define CONFIG_MPEG1_NVDEC_HWACCEL 0
+#define CONFIG_MPEG1_VDPAU_HWACCEL 0
+#define CONFIG_MPEG1_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA2_HWACCEL 0
+#define CONFIG_MPEG2_NVDEC_HWACCEL 0
+#define CONFIG_MPEG2_DXVA2_HWACCEL 0
+#define CONFIG_MPEG2_VAAPI_HWACCEL 0
+#define CONFIG_MPEG2_VDPAU_HWACCEL 0
+#define CONFIG_MPEG2_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG4_NVDEC_HWACCEL 0
+#define CONFIG_MPEG4_VAAPI_HWACCEL 0
+#define CONFIG_MPEG4_VDPAU_HWACCEL 0
+#define CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_PRORES_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_VC1_D3D11VA_HWACCEL 0
+#define CONFIG_VC1_D3D11VA2_HWACCEL 0
+#define CONFIG_VC1_DXVA2_HWACCEL 0
+#define CONFIG_VC1_NVDEC_HWACCEL 0
+#define CONFIG_VC1_VAAPI_HWACCEL 0
+#define CONFIG_VC1_VDPAU_HWACCEL 0
+#define CONFIG_VP8_NVDEC_HWACCEL 0
+#define CONFIG_VP8_VAAPI_HWACCEL 0
+#define CONFIG_VP9_D3D11VA_HWACCEL 0
+#define CONFIG_VP9_D3D11VA2_HWACCEL 0
+#define CONFIG_VP9_DXVA2_HWACCEL 0
+#define CONFIG_VP9_NVDEC_HWACCEL 0
+#define CONFIG_VP9_VAAPI_HWACCEL 0
+#define CONFIG_VP9_VDPAU_HWACCEL 0
+#define CONFIG_VP9_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA2_HWACCEL 0
+#define CONFIG_WMV3_DXVA2_HWACCEL 0
+#define CONFIG_WMV3_NVDEC_HWACCEL 0
+#define CONFIG_WMV3_VAAPI_HWACCEL 0
+#define CONFIG_WMV3_VDPAU_HWACCEL 0
+#define CONFIG_AAC_PARSER 0
+#define CONFIG_AAC_LATM_PARSER 0
+#define CONFIG_AC3_PARSER 0
+#define CONFIG_ADX_PARSER 0
+#define CONFIG_AMR_PARSER 0
+#define CONFIG_AV1_PARSER 0
+#define CONFIG_AVS2_PARSER 0
+#define CONFIG_AVS3_PARSER 0
+#define CONFIG_BMP_PARSER 0
+#define CONFIG_CAVSVIDEO_PARSER 0
+#define CONFIG_COOK_PARSER 0
+#define CONFIG_CRI_PARSER 0
+#define CONFIG_DCA_PARSER 0
+#define CONFIG_DIRAC_PARSER 0
+#define CONFIG_DNXHD_PARSER 0
+#define CONFIG_DOLBY_E_PARSER 0
+#define CONFIG_DPX_PARSER 0
+#define CONFIG_DVAUDIO_PARSER 0
+#define CONFIG_DVBSUB_PARSER 0
+#define CONFIG_DVDSUB_PARSER 0
+#define CONFIG_DVD_NAV_PARSER 0
+#define CONFIG_FLAC_PARSER 0
+#define CONFIG_G723_1_PARSER 0
+#define CONFIG_G729_PARSER 0
+#define CONFIG_GIF_PARSER 0
+#define CONFIG_GSM_PARSER 0
+#define CONFIG_H261_PARSER 0
+#define CONFIG_H263_PARSER 0
+#define CONFIG_H264_PARSER 0
+#define CONFIG_HEVC_PARSER 0
+#define CONFIG_IPU_PARSER 0
+#define CONFIG_JPEG2000_PARSER 0
+#define CONFIG_MJPEG_PARSER 0
+#define CONFIG_MLP_PARSER 0
+#define CONFIG_MPEG4VIDEO_PARSER 0
+#define CONFIG_MPEGAUDIO_PARSER 0
+#define CONFIG_MPEGVIDEO_PARSER 0
+#define CONFIG_OPUS_PARSER 0
+#define CONFIG_PNG_PARSER 0
+#define CONFIG_PNM_PARSER 0
+#define CONFIG_QOI_PARSER 0
+#define CONFIG_RV30_PARSER 0
+#define CONFIG_RV40_PARSER 0
+#define CONFIG_SBC_PARSER 0
+#define CONFIG_SIPR_PARSER 0
+#define CONFIG_TAK_PARSER 0
+#define CONFIG_VC1_PARSER 0
+#define CONFIG_VORBIS_PARSER 0
+#define CONFIG_VP3_PARSER 0
+#define CONFIG_VP8_PARSER 1
+#define CONFIG_VP9_PARSER 1
+#define CONFIG_WEBP_PARSER 0
+#define CONFIG_XBM_PARSER 0
+#define CONFIG_XMA_PARSER 0
+#define CONFIG_ALSA_INDEV 0
+#define CONFIG_ANDROID_CAMERA_INDEV 0
+#define CONFIG_AVFOUNDATION_INDEV 0
+#define CONFIG_BKTR_INDEV 0
+#define CONFIG_DECKLINK_INDEV 0
+#define CONFIG_DSHOW_INDEV 0
+#define CONFIG_FBDEV_INDEV 0
+#define CONFIG_GDIGRAB_INDEV 0
+#define CONFIG_IEC61883_INDEV 0
+#define CONFIG_JACK_INDEV 0
+#define CONFIG_KMSGRAB_INDEV 0
+#define CONFIG_LAVFI_INDEV 0
+#define CONFIG_OPENAL_INDEV 0
+#define CONFIG_OSS_INDEV 0
+#define CONFIG_PULSE_INDEV 0
+#define CONFIG_SNDIO_INDEV 0
+#define CONFIG_V4L2_INDEV 0
+#define CONFIG_VFWCAP_INDEV 0
+#define CONFIG_XCBGRAB_INDEV 0
+#define CONFIG_LIBCDIO_INDEV 0
+#define CONFIG_LIBDC1394_INDEV 0
+#define CONFIG_ALSA_OUTDEV 0
+#define CONFIG_AUDIOTOOLBOX_OUTDEV 0
+#define CONFIG_CACA_OUTDEV 0
+#define CONFIG_DECKLINK_OUTDEV 0
+#define CONFIG_FBDEV_OUTDEV 0
+#define CONFIG_OPENGL_OUTDEV 0
+#define CONFIG_OSS_OUTDEV 0
+#define CONFIG_PULSE_OUTDEV 0
+#define CONFIG_SDL2_OUTDEV 0
+#define CONFIG_SNDIO_OUTDEV 0
+#define CONFIG_V4L2_OUTDEV 0
+#define CONFIG_XV_OUTDEV 0
+#define CONFIG_ABENCH_FILTER 0
+#define CONFIG_ACOMPRESSOR_FILTER 0
+#define CONFIG_ACONTRAST_FILTER 0
+#define CONFIG_ACOPY_FILTER 0
+#define CONFIG_ACUE_FILTER 0
+#define CONFIG_ACROSSFADE_FILTER 0
+#define CONFIG_ACROSSOVER_FILTER 0
+#define CONFIG_ACRUSHER_FILTER 0
+#define CONFIG_ADECLICK_FILTER 0
+#define CONFIG_ADECLIP_FILTER 0
+#define CONFIG_ADECORRELATE_FILTER 0
+#define CONFIG_ADELAY_FILTER 0
+#define CONFIG_ADENORM_FILTER 0
+#define CONFIG_ADERIVATIVE_FILTER 0
+#define CONFIG_ADYNAMICEQUALIZER_FILTER 0
+#define CONFIG_ADYNAMICSMOOTH_FILTER 0
+#define CONFIG_AECHO_FILTER 0
+#define CONFIG_AEMPHASIS_FILTER 0
+#define CONFIG_AEVAL_FILTER 0
+#define CONFIG_AEXCITER_FILTER 0
+#define CONFIG_AFADE_FILTER 0
+#define CONFIG_AFFTDN_FILTER 0
+#define CONFIG_AFFTFILT_FILTER 0
+#define CONFIG_AFIR_FILTER 0
+#define CONFIG_AFORMAT_FILTER 0
+#define CONFIG_AFREQSHIFT_FILTER 0
+#define CONFIG_AFWTDN_FILTER 0
+#define CONFIG_AGATE_FILTER 0
+#define CONFIG_AIIR_FILTER 0
+#define CONFIG_AINTEGRAL_FILTER 0
+#define CONFIG_AINTERLEAVE_FILTER 0
+#define CONFIG_ALATENCY_FILTER 0
+#define CONFIG_ALIMITER_FILTER 0
+#define CONFIG_ALLPASS_FILTER 0
+#define CONFIG_ALOOP_FILTER 0
+#define CONFIG_AMERGE_FILTER 0
+#define CONFIG_AMETADATA_FILTER 0
+#define CONFIG_AMIX_FILTER 0
+#define CONFIG_AMULTIPLY_FILTER 0
+#define CONFIG_ANEQUALIZER_FILTER 0
+#define CONFIG_ANLMDN_FILTER 0
+#define CONFIG_ANLMF_FILTER 0
+#define CONFIG_ANLMS_FILTER 0
+#define CONFIG_ANULL_FILTER 0
+#define CONFIG_APAD_FILTER 0
+#define CONFIG_APERMS_FILTER 0
+#define CONFIG_APHASER_FILTER 0
+#define CONFIG_APHASESHIFT_FILTER 0
+#define CONFIG_APSYCLIP_FILTER 0
+#define CONFIG_APULSATOR_FILTER 0
+#define CONFIG_AREALTIME_FILTER 0
+#define CONFIG_ARESAMPLE_FILTER 0
+#define CONFIG_AREVERSE_FILTER 0
+#define CONFIG_ARNNDN_FILTER 0
+#define CONFIG_ASDR_FILTER 0
+#define CONFIG_ASEGMENT_FILTER 0
+#define CONFIG_ASELECT_FILTER 0
+#define CONFIG_ASENDCMD_FILTER 0
+#define CONFIG_ASETNSAMPLES_FILTER 0
+#define CONFIG_ASETPTS_FILTER 0
+#define CONFIG_ASETRATE_FILTER 0
+#define CONFIG_ASETTB_FILTER 0
+#define CONFIG_ASHOWINFO_FILTER 0
+#define CONFIG_ASIDEDATA_FILTER 0
+#define CONFIG_ASOFTCLIP_FILTER 0
+#define CONFIG_ASPECTRALSTATS_FILTER 0
+#define CONFIG_ASPLIT_FILTER 0
+#define CONFIG_ASR_FILTER 0
+#define CONFIG_ASTATS_FILTER 0
+#define CONFIG_ASTREAMSELECT_FILTER 0
+#define CONFIG_ASUBBOOST_FILTER 0
+#define CONFIG_ASUBCUT_FILTER 0
+#define CONFIG_ASUPERCUT_FILTER 0
+#define CONFIG_ASUPERPASS_FILTER 0
+#define CONFIG_ASUPERSTOP_FILTER 0
+#define CONFIG_ATEMPO_FILTER 0
+#define CONFIG_ATILT_FILTER 0
+#define CONFIG_ATRIM_FILTER 0
+#define CONFIG_AXCORRELATE_FILTER 0
+#define CONFIG_AZMQ_FILTER 0
+#define CONFIG_BANDPASS_FILTER 0
+#define CONFIG_BANDREJECT_FILTER 0
+#define CONFIG_BASS_FILTER 0
+#define CONFIG_BIQUAD_FILTER 0
+#define CONFIG_BS2B_FILTER 0
+#define CONFIG_CHANNELMAP_FILTER 0
+#define CONFIG_CHANNELSPLIT_FILTER 0
+#define CONFIG_CHORUS_FILTER 0
+#define CONFIG_COMPAND_FILTER 0
+#define CONFIG_COMPENSATIONDELAY_FILTER 0
+#define CONFIG_CROSSFEED_FILTER 0
+#define CONFIG_CRYSTALIZER_FILTER 0
+#define CONFIG_DCSHIFT_FILTER 0
+#define CONFIG_DEESSER_FILTER 0
+#define CONFIG_DIALOGUENHANCE_FILTER 0
+#define CONFIG_DRMETER_FILTER 0
+#define CONFIG_DYNAUDNORM_FILTER 0
+#define CONFIG_EARWAX_FILTER 0
+#define CONFIG_EBUR128_FILTER 0
+#define CONFIG_EQUALIZER_FILTER 0
+#define CONFIG_EXTRASTEREO_FILTER 0
+#define CONFIG_FIREQUALIZER_FILTER 0
+#define CONFIG_FLANGER_FILTER 0
+#define CONFIG_HAAS_FILTER 0
+#define CONFIG_HDCD_FILTER 0
+#define CONFIG_HEADPHONE_FILTER 0
+#define CONFIG_HIGHPASS_FILTER 0
+#define CONFIG_HIGHSHELF_FILTER 0
+#define CONFIG_JOIN_FILTER 0
+#define CONFIG_LADSPA_FILTER 0
+#define CONFIG_LOUDNORM_FILTER 0
+#define CONFIG_LOWPASS_FILTER 0
+#define CONFIG_LOWSHELF_FILTER 0
+#define CONFIG_LV2_FILTER 0
+#define CONFIG_MCOMPAND_FILTER 0
+#define CONFIG_PAN_FILTER 0
+#define CONFIG_REPLAYGAIN_FILTER 0
+#define CONFIG_RUBBERBAND_FILTER 0
+#define CONFIG_SIDECHAINCOMPRESS_FILTER 0
+#define CONFIG_SIDECHAINGATE_FILTER 0
+#define CONFIG_SILENCEDETECT_FILTER 0
+#define CONFIG_SILENCEREMOVE_FILTER 0
+#define CONFIG_SOFALIZER_FILTER 0
+#define CONFIG_SPEECHNORM_FILTER 0
+#define CONFIG_STEREOTOOLS_FILTER 0
+#define CONFIG_STEREOWIDEN_FILTER 0
+#define CONFIG_SUPEREQUALIZER_FILTER 0
+#define CONFIG_SURROUND_FILTER 0
+#define CONFIG_TILTSHELF_FILTER 0
+#define CONFIG_TREBLE_FILTER 0
+#define CONFIG_TREMOLO_FILTER 0
+#define CONFIG_VIBRATO_FILTER 0
+#define CONFIG_VIRTUALBASS_FILTER 0
+#define CONFIG_VOLUME_FILTER 0
+#define CONFIG_VOLUMEDETECT_FILTER 0
+#define CONFIG_AEVALSRC_FILTER 0
+#define CONFIG_AFIRSRC_FILTER 0
+#define CONFIG_ANOISESRC_FILTER 0
+#define CONFIG_ANULLSRC_FILTER 0
+#define CONFIG_FLITE_FILTER 0
+#define CONFIG_HILBERT_FILTER 0
+#define CONFIG_SINC_FILTER 0
+#define CONFIG_SINE_FILTER 0
+#define CONFIG_ANULLSINK_FILTER 0
+#define CONFIG_ADDROI_FILTER 0
+#define CONFIG_ALPHAEXTRACT_FILTER 0
+#define CONFIG_ALPHAMERGE_FILTER 0
+#define CONFIG_AMPLIFY_FILTER 0
+#define CONFIG_ASS_FILTER 0
+#define CONFIG_ATADENOISE_FILTER 0
+#define CONFIG_AVGBLUR_FILTER 0
+#define CONFIG_AVGBLUR_OPENCL_FILTER 0
+#define CONFIG_AVGBLUR_VULKAN_FILTER 0
+#define CONFIG_BBOX_FILTER 0
+#define CONFIG_BENCH_FILTER 0
+#define CONFIG_BILATERAL_FILTER 0
+#define CONFIG_BITPLANENOISE_FILTER 0
+#define CONFIG_BLACKDETECT_FILTER 0
+#define CONFIG_BLACKFRAME_FILTER 0
+#define CONFIG_BLEND_FILTER 0
+#define CONFIG_BLEND_VULKAN_FILTER 0
+#define CONFIG_BLOCKDETECT_FILTER 0
+#define CONFIG_BLURDETECT_FILTER 0
+#define CONFIG_BM3D_FILTER 0
+#define CONFIG_BOXBLUR_FILTER 0
+#define CONFIG_BOXBLUR_OPENCL_FILTER 0
+#define CONFIG_BWDIF_FILTER 0
+#define CONFIG_CAS_FILTER 0
+#define CONFIG_CHROMABER_VULKAN_FILTER 0
+#define CONFIG_CHROMAHOLD_FILTER 0
+#define CONFIG_CHROMAKEY_FILTER 0
+#define CONFIG_CHROMANR_FILTER 0
+#define CONFIG_CHROMASHIFT_FILTER 0
+#define CONFIG_CIESCOPE_FILTER 0
+#define CONFIG_CODECVIEW_FILTER 0
+#define CONFIG_COLORBALANCE_FILTER 0
+#define CONFIG_COLORCHANNELMIXER_FILTER 0
+#define CONFIG_COLORCONTRAST_FILTER 0
+#define CONFIG_COLORCORRECT_FILTER 0
+#define CONFIG_COLORIZE_FILTER 0
+#define CONFIG_COLORKEY_FILTER 0
+#define CONFIG_COLORKEY_OPENCL_FILTER 0
+#define CONFIG_COLORHOLD_FILTER 0
+#define CONFIG_COLORLEVELS_FILTER 0
+#define CONFIG_COLORMAP_FILTER 0
+#define CONFIG_COLORMATRIX_FILTER 0
+#define CONFIG_COLORSPACE_FILTER 0
+#define CONFIG_COLORTEMPERATURE_FILTER 0
+#define CONFIG_CONVOLUTION_FILTER 0
+#define CONFIG_CONVOLUTION_OPENCL_FILTER 0
+#define CONFIG_CONVOLVE_FILTER 0
+#define CONFIG_COPY_FILTER 0
+#define CONFIG_COREIMAGE_FILTER 0
+#define CONFIG_COVER_RECT_FILTER 0
+#define CONFIG_CROP_FILTER 0
+#define CONFIG_CROPDETECT_FILTER 0
+#define CONFIG_CUE_FILTER 0
+#define CONFIG_CURVES_FILTER 0
+#define CONFIG_DATASCOPE_FILTER 0
+#define CONFIG_DBLUR_FILTER 0
+#define CONFIG_DCTDNOIZ_FILTER 0
+#define CONFIG_DEBAND_FILTER 0
+#define CONFIG_DEBLOCK_FILTER 0
+#define CONFIG_DECIMATE_FILTER 0
+#define CONFIG_DECONVOLVE_FILTER 0
+#define CONFIG_DEDOT_FILTER 0
+#define CONFIG_DEFLATE_FILTER 0
+#define CONFIG_DEFLICKER_FILTER 0
+#define CONFIG_DEINTERLACE_QSV_FILTER 0
+#define CONFIG_DEINTERLACE_VAAPI_FILTER 0
+#define CONFIG_DEJUDDER_FILTER 0
+#define CONFIG_DELOGO_FILTER 0
+#define CONFIG_DENOISE_VAAPI_FILTER 0
+#define CONFIG_DERAIN_FILTER 0
+#define CONFIG_DESHAKE_FILTER 0
+#define CONFIG_DESHAKE_OPENCL_FILTER 0
+#define CONFIG_DESPILL_FILTER 0
+#define CONFIG_DETELECINE_FILTER 0
+#define CONFIG_DILATION_FILTER 0
+#define CONFIG_DILATION_OPENCL_FILTER 0
+#define CONFIG_DISPLACE_FILTER 0
+#define CONFIG_DNN_CLASSIFY_FILTER 0
+#define CONFIG_DNN_DETECT_FILTER 0
+#define CONFIG_DNN_PROCESSING_FILTER 0
+#define CONFIG_DOUBLEWEAVE_FILTER 0
+#define CONFIG_DRAWBOX_FILTER 0
+#define CONFIG_DRAWGRAPH_FILTER 0
+#define CONFIG_DRAWGRID_FILTER 0
+#define CONFIG_DRAWTEXT_FILTER 0
+#define CONFIG_EDGEDETECT_FILTER 0
+#define CONFIG_ELBG_FILTER 0
+#define CONFIG_ENTROPY_FILTER 0
+#define CONFIG_EPX_FILTER 0
+#define CONFIG_EQ_FILTER 0
+#define CONFIG_EROSION_FILTER 0
+#define CONFIG_EROSION_OPENCL_FILTER 0
+#define CONFIG_ESTDIF_FILTER 0
+#define CONFIG_EXPOSURE_FILTER 0
+#define CONFIG_EXTRACTPLANES_FILTER 0
+#define CONFIG_FADE_FILTER 0
+#define CONFIG_FEEDBACK_FILTER 0
+#define CONFIG_FFTDNOIZ_FILTER 0
+#define CONFIG_FFTFILT_FILTER 0
+#define CONFIG_FIELD_FILTER 0
+#define CONFIG_FIELDHINT_FILTER 0
+#define CONFIG_FIELDMATCH_FILTER 0
+#define CONFIG_FIELDORDER_FILTER 0
+#define CONFIG_FILLBORDERS_FILTER 0
+#define CONFIG_FIND_RECT_FILTER 0
+#define CONFIG_FLIP_VULKAN_FILTER 0
+#define CONFIG_FLOODFILL_FILTER 0
+#define CONFIG_FORMAT_FILTER 0
+#define CONFIG_FPS_FILTER 0
+#define CONFIG_FRAMEPACK_FILTER 0
+#define CONFIG_FRAMERATE_FILTER 0
+#define CONFIG_FRAMESTEP_FILTER 0
+#define CONFIG_FREEZEDETECT_FILTER 0
+#define CONFIG_FREEZEFRAMES_FILTER 0
+#define CONFIG_FREI0R_FILTER 0
+#define CONFIG_FSPP_FILTER 0
+#define CONFIG_GBLUR_FILTER 0
+#define CONFIG_GBLUR_VULKAN_FILTER 0
+#define CONFIG_GEQ_FILTER 0
+#define CONFIG_GRADFUN_FILTER 0
+#define CONFIG_GRAPHMONITOR_FILTER 0
+#define CONFIG_GRAYWORLD_FILTER 0
+#define CONFIG_GREYEDGE_FILTER 0
+#define CONFIG_GUIDED_FILTER 0
+#define CONFIG_HALDCLUT_FILTER 0
+#define CONFIG_HFLIP_FILTER 0
+#define CONFIG_HFLIP_VULKAN_FILTER 0
+#define CONFIG_HISTEQ_FILTER 0
+#define CONFIG_HISTOGRAM_FILTER 0
+#define CONFIG_HQDN3D_FILTER 0
+#define CONFIG_HQX_FILTER 0
+#define CONFIG_HSTACK_FILTER 0
+#define CONFIG_HSVHOLD_FILTER 0
+#define CONFIG_HSVKEY_FILTER 0
+#define CONFIG_HUE_FILTER 0
+#define CONFIG_HUESATURATION_FILTER 0
+#define CONFIG_HWDOWNLOAD_FILTER 0
+#define CONFIG_HWMAP_FILTER 0
+#define CONFIG_HWUPLOAD_FILTER 0
+#define CONFIG_HWUPLOAD_CUDA_FILTER 0
+#define CONFIG_HYSTERESIS_FILTER 0
+#define CONFIG_ICCDETECT_FILTER 0
+#define CONFIG_ICCGEN_FILTER 0
+#define CONFIG_IDENTITY_FILTER 0
+#define CONFIG_IDET_FILTER 0
+#define CONFIG_IL_FILTER 0
+#define CONFIG_INFLATE_FILTER 0
+#define CONFIG_INTERLACE_FILTER 0
+#define CONFIG_INTERLEAVE_FILTER 0
+#define CONFIG_KERNDEINT_FILTER 0
+#define CONFIG_KIRSCH_FILTER 0
+#define CONFIG_LAGFUN_FILTER 0
+#define CONFIG_LATENCY_FILTER 0
+#define CONFIG_LENSCORRECTION_FILTER 0
+#define CONFIG_LENSFUN_FILTER 0
+#define CONFIG_LIBPLACEBO_FILTER 0
+#define CONFIG_LIBVMAF_FILTER 0
+#define CONFIG_LIMITDIFF_FILTER 0
+#define CONFIG_LIMITER_FILTER 0
+#define CONFIG_LOOP_FILTER 0
+#define CONFIG_LUMAKEY_FILTER 0
+#define CONFIG_LUT_FILTER 0
+#define CONFIG_LUT1D_FILTER 0
+#define CONFIG_LUT2_FILTER 0
+#define CONFIG_LUT3D_FILTER 0
+#define CONFIG_LUTRGB_FILTER 0
+#define CONFIG_LUTYUV_FILTER 0
+#define CONFIG_MASKEDCLAMP_FILTER 0
+#define CONFIG_MASKEDMAX_FILTER 0
+#define CONFIG_MASKEDMERGE_FILTER 0
+#define CONFIG_MASKEDMIN_FILTER 0
+#define CONFIG_MASKEDTHRESHOLD_FILTER 0
+#define CONFIG_MASKFUN_FILTER 0
+#define CONFIG_MCDEINT_FILTER 0
+#define CONFIG_MEDIAN_FILTER 0
+#define CONFIG_MERGEPLANES_FILTER 0
+#define CONFIG_MESTIMATE_FILTER 0
+#define CONFIG_METADATA_FILTER 0
+#define CONFIG_MIDEQUALIZER_FILTER 0
+#define CONFIG_MINTERPOLATE_FILTER 0
+#define CONFIG_MIX_FILTER 0
+#define CONFIG_MONOCHROME_FILTER 0
+#define CONFIG_MORPHO_FILTER 0
+#define CONFIG_MPDECIMATE_FILTER 0
+#define CONFIG_MSAD_FILTER 0
+#define CONFIG_MULTIPLY_FILTER 0
+#define CONFIG_NEGATE_FILTER 0
+#define CONFIG_NLMEANS_FILTER 0
+#define CONFIG_NLMEANS_OPENCL_FILTER 0
+#define CONFIG_NNEDI_FILTER 0
+#define CONFIG_NOFORMAT_FILTER 0
+#define CONFIG_NOISE_FILTER 0
+#define CONFIG_NORMALIZE_FILTER 0
+#define CONFIG_NULL_FILTER 0
+#define CONFIG_OCR_FILTER 0
+#define CONFIG_OCV_FILTER 0
+#define CONFIG_OSCILLOSCOPE_FILTER 0
+#define CONFIG_OVERLAY_FILTER 0
+#define CONFIG_OVERLAY_OPENCL_FILTER 0
+#define CONFIG_OVERLAY_QSV_FILTER 0
+#define CONFIG_OVERLAY_VAAPI_FILTER 0
+#define CONFIG_OVERLAY_VULKAN_FILTER 0
+#define CONFIG_OVERLAY_CUDA_FILTER 0
+#define CONFIG_OWDENOISE_FILTER 0
+#define CONFIG_PAD_FILTER 0
+#define CONFIG_PAD_OPENCL_FILTER 0
+#define CONFIG_PALETTEGEN_FILTER 0
+#define CONFIG_PALETTEUSE_FILTER 0
+#define CONFIG_PERMS_FILTER 0
+#define CONFIG_PERSPECTIVE_FILTER 0
+#define CONFIG_PHASE_FILTER 0
+#define CONFIG_PHOTOSENSITIVITY_FILTER 0
+#define CONFIG_PIXDESCTEST_FILTER 0
+#define CONFIG_PIXELIZE_FILTER 0
+#define CONFIG_PIXSCOPE_FILTER 0
+#define CONFIG_PP_FILTER 0
+#define CONFIG_PP7_FILTER 0
+#define CONFIG_PREMULTIPLY_FILTER 0
+#define CONFIG_PREWITT_FILTER 0
+#define CONFIG_PREWITT_OPENCL_FILTER 0
+#define CONFIG_PROCAMP_VAAPI_FILTER 0
+#define CONFIG_PROGRAM_OPENCL_FILTER 0
+#define CONFIG_PSEUDOCOLOR_FILTER 0
+#define CONFIG_PSNR_FILTER 0
+#define CONFIG_PULLUP_FILTER 0
+#define CONFIG_QP_FILTER 0
+#define CONFIG_RANDOM_FILTER 0
+#define CONFIG_READEIA608_FILTER 0
+#define CONFIG_READVITC_FILTER 0
+#define CONFIG_REALTIME_FILTER 0
+#define CONFIG_REMAP_FILTER 0
+#define CONFIG_REMOVEGRAIN_FILTER 0
+#define CONFIG_REMOVELOGO_FILTER 0
+#define CONFIG_REPEATFIELDS_FILTER 0
+#define CONFIG_REVERSE_FILTER 0
+#define CONFIG_RGBASHIFT_FILTER 0
+#define CONFIG_ROBERTS_FILTER 0
+#define CONFIG_ROBERTS_OPENCL_FILTER 0
+#define CONFIG_ROTATE_FILTER 0
+#define CONFIG_SAB_FILTER 0
+#define CONFIG_SCALE_FILTER 0
+#define CONFIG_SCALE_CUDA_FILTER 0
+#define CONFIG_SCALE_NPP_FILTER 0
+#define CONFIG_SCALE_QSV_FILTER 0
+#define CONFIG_SCALE_VAAPI_FILTER 0
+#define CONFIG_SCALE_VULKAN_FILTER 0
+#define CONFIG_SCALE2REF_FILTER 0
+#define CONFIG_SCALE2REF_NPP_FILTER 0
+#define CONFIG_SCDET_FILTER 0
+#define CONFIG_SCHARR_FILTER 0
+#define CONFIG_SCROLL_FILTER 0
+#define CONFIG_SEGMENT_FILTER 0
+#define CONFIG_SELECT_FILTER 0
+#define CONFIG_SELECTIVECOLOR_FILTER 0
+#define CONFIG_SENDCMD_FILTER 0
+#define CONFIG_SEPARATEFIELDS_FILTER 0
+#define CONFIG_SETDAR_FILTER 0
+#define CONFIG_SETFIELD_FILTER 0
+#define CONFIG_SETPARAMS_FILTER 0
+#define CONFIG_SETPTS_FILTER 0
+#define CONFIG_SETRANGE_FILTER 0
+#define CONFIG_SETSAR_FILTER 0
+#define CONFIG_SETTB_FILTER 0
+#define CONFIG_SHARPEN_NPP_FILTER 0
+#define CONFIG_SHARPNESS_VAAPI_FILTER 0
+#define CONFIG_SHEAR_FILTER 0
+#define CONFIG_SHOWINFO_FILTER 0
+#define CONFIG_SHOWPALETTE_FILTER 0
+#define CONFIG_SHUFFLEFRAMES_FILTER 0
+#define CONFIG_SHUFFLEPIXELS_FILTER 0
+#define CONFIG_SHUFFLEPLANES_FILTER 0
+#define CONFIG_SIDEDATA_FILTER 0
+#define CONFIG_SIGNALSTATS_FILTER 0
+#define CONFIG_SIGNATURE_FILTER 0
+#define CONFIG_SITI_FILTER 0
+#define CONFIG_SMARTBLUR_FILTER 0
+#define CONFIG_SOBEL_FILTER 0
+#define CONFIG_SOBEL_OPENCL_FILTER 0
+#define CONFIG_SPLIT_FILTER 0
+#define CONFIG_SPP_FILTER 0
+#define CONFIG_SR_FILTER 0
+#define CONFIG_SSIM_FILTER 0
+#define CONFIG_STEREO3D_FILTER 0
+#define CONFIG_STREAMSELECT_FILTER 0
+#define CONFIG_SUBTITLES_FILTER 0
+#define CONFIG_SUPER2XSAI_FILTER 0
+#define CONFIG_SWAPRECT_FILTER 0
+#define CONFIG_SWAPUV_FILTER 0
+#define CONFIG_TBLEND_FILTER 0
+#define CONFIG_TELECINE_FILTER 0
+#define CONFIG_THISTOGRAM_FILTER 0
+#define CONFIG_THRESHOLD_FILTER 0
+#define CONFIG_THUMBNAIL_FILTER 0
+#define CONFIG_THUMBNAIL_CUDA_FILTER 0
+#define CONFIG_TILE_FILTER 0
+#define CONFIG_TINTERLACE_FILTER 0
+#define CONFIG_TLUT2_FILTER 0
+#define CONFIG_TMEDIAN_FILTER 0
+#define CONFIG_TMIDEQUALIZER_FILTER 0
+#define CONFIG_TMIX_FILTER 0
+#define CONFIG_TONEMAP_FILTER 0
+#define CONFIG_TONEMAP_OPENCL_FILTER 0
+#define CONFIG_TONEMAP_VAAPI_FILTER 0
+#define CONFIG_TPAD_FILTER 0
+#define CONFIG_TRANSPOSE_FILTER 0
+#define CONFIG_TRANSPOSE_NPP_FILTER 0
+#define CONFIG_TRANSPOSE_OPENCL_FILTER 0
+#define CONFIG_TRANSPOSE_VAAPI_FILTER 0
+#define CONFIG_TRANSPOSE_VULKAN_FILTER 0
+#define CONFIG_TRIM_FILTER 0
+#define CONFIG_UNPREMULTIPLY_FILTER 0
+#define CONFIG_UNSHARP_FILTER 0
+#define CONFIG_UNSHARP_OPENCL_FILTER 0
+#define CONFIG_UNTILE_FILTER 0
+#define CONFIG_USPP_FILTER 0
+#define CONFIG_V360_FILTER 0
+#define CONFIG_VAGUEDENOISER_FILTER 0
+#define CONFIG_VARBLUR_FILTER 0
+#define CONFIG_VECTORSCOPE_FILTER 0
+#define CONFIG_VFLIP_FILTER 0
+#define CONFIG_VFLIP_VULKAN_FILTER 0
+#define CONFIG_VFRDET_FILTER 0
+#define CONFIG_VIBRANCE_FILTER 0
+#define CONFIG_VIDSTABDETECT_FILTER 0
+#define CONFIG_VIDSTABTRANSFORM_FILTER 0
+#define CONFIG_VIF_FILTER 0
+#define CONFIG_VIGNETTE_FILTER 0
+#define CONFIG_VMAFMOTION_FILTER 0
+#define CONFIG_VPP_QSV_FILTER 0
+#define CONFIG_VSTACK_FILTER 0
+#define CONFIG_W3FDIF_FILTER 0
+#define CONFIG_WAVEFORM_FILTER 0
+#define CONFIG_WEAVE_FILTER 0
+#define CONFIG_XBR_FILTER 0
+#define CONFIG_XCORRELATE_FILTER 0
+#define CONFIG_XFADE_FILTER 0
+#define CONFIG_XFADE_OPENCL_FILTER 0
+#define CONFIG_XMEDIAN_FILTER 0
+#define CONFIG_XSTACK_FILTER 0
+#define CONFIG_YADIF_FILTER 0
+#define CONFIG_YADIF_CUDA_FILTER 0
+#define CONFIG_YADIF_VIDEOTOOLBOX_FILTER 0
+#define CONFIG_YAEPBLUR_FILTER 0
+#define CONFIG_ZMQ_FILTER 0
+#define CONFIG_ZOOMPAN_FILTER 0
+#define CONFIG_ZSCALE_FILTER 0
+#define CONFIG_ALLRGB_FILTER 0
+#define CONFIG_ALLYUV_FILTER 0
+#define CONFIG_CELLAUTO_FILTER 0
+#define CONFIG_COLOR_FILTER 0
+#define CONFIG_COLORCHART_FILTER 0
+#define CONFIG_COLORSPECTRUM_FILTER 0
+#define CONFIG_COREIMAGESRC_FILTER 0
+#define CONFIG_FREI0R_SRC_FILTER 0
+#define CONFIG_GRADIENTS_FILTER 0
+#define CONFIG_HALDCLUTSRC_FILTER 0
+#define CONFIG_LIFE_FILTER 0
+#define CONFIG_MANDELBROT_FILTER 0
+#define CONFIG_MPTESTSRC_FILTER 0
+#define CONFIG_NULLSRC_FILTER 0
+#define CONFIG_OPENCLSRC_FILTER 0
+#define CONFIG_PAL75BARS_FILTER 0
+#define CONFIG_PAL100BARS_FILTER 0
+#define CONFIG_RGBTESTSRC_FILTER 0
+#define CONFIG_SIERPINSKI_FILTER 0
+#define CONFIG_SMPTEBARS_FILTER 0
+#define CONFIG_SMPTEHDBARS_FILTER 0
+#define CONFIG_TESTSRC_FILTER 0
+#define CONFIG_TESTSRC2_FILTER 0
+#define CONFIG_YUVTESTSRC_FILTER 0
+#define CONFIG_NULLSINK_FILTER 0
+#define CONFIG_ABITSCOPE_FILTER 0
+#define CONFIG_ADRAWGRAPH_FILTER 0
+#define CONFIG_AGRAPHMONITOR_FILTER 0
+#define CONFIG_AHISTOGRAM_FILTER 0
+#define CONFIG_APHASEMETER_FILTER 0
+#define CONFIG_AVECTORSCOPE_FILTER 0
+#define CONFIG_CONCAT_FILTER 0
+#define CONFIG_SHOWCQT_FILTER 0
+#define CONFIG_SHOWFREQS_FILTER 0
+#define CONFIG_SHOWSPATIAL_FILTER 0
+#define CONFIG_SHOWSPECTRUM_FILTER 0
+#define CONFIG_SHOWSPECTRUMPIC_FILTER 0
+#define CONFIG_SHOWVOLUME_FILTER 0
+#define CONFIG_SHOWWAVES_FILTER 0
+#define CONFIG_SHOWWAVESPIC_FILTER 0
+#define CONFIG_SPECTRUMSYNTH_FILTER 0
+#define CONFIG_AVSYNCTEST_FILTER 0
+#define CONFIG_AMOVIE_FILTER 0
+#define CONFIG_MOVIE_FILTER 0
+#define CONFIG_AFIFO_FILTER 0
+#define CONFIG_FIFO_FILTER 0
+#define CONFIG_AA_DEMUXER 0
+#define CONFIG_AAC_DEMUXER 0
+#define CONFIG_AAX_DEMUXER 0
+#define CONFIG_AC3_DEMUXER 0
+#define CONFIG_ACE_DEMUXER 0
+#define CONFIG_ACM_DEMUXER 0
+#define CONFIG_ACT_DEMUXER 0
+#define CONFIG_ADF_DEMUXER 0
+#define CONFIG_ADP_DEMUXER 0
+#define CONFIG_ADS_DEMUXER 0
+#define CONFIG_ADX_DEMUXER 0
+#define CONFIG_AEA_DEMUXER 0
+#define CONFIG_AFC_DEMUXER 0
+#define CONFIG_AIFF_DEMUXER 0
+#define CONFIG_AIX_DEMUXER 0
+#define CONFIG_ALP_DEMUXER 0
+#define CONFIG_AMR_DEMUXER 0
+#define CONFIG_AMRNB_DEMUXER 0
+#define CONFIG_AMRWB_DEMUXER 0
+#define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APC_DEMUXER 0
+#define CONFIG_APE_DEMUXER 0
+#define CONFIG_APM_DEMUXER 0
+#define CONFIG_APNG_DEMUXER 0
+#define CONFIG_APTX_DEMUXER 0
+#define CONFIG_APTX_HD_DEMUXER 0
+#define CONFIG_AQTITLE_DEMUXER 0
+#define CONFIG_ARGO_ASF_DEMUXER 0
+#define CONFIG_ARGO_BRP_DEMUXER 0
+#define CONFIG_ARGO_CVG_DEMUXER 0
+#define CONFIG_ASF_DEMUXER 0
+#define CONFIG_ASF_O_DEMUXER 0
+#define CONFIG_ASS_DEMUXER 0
+#define CONFIG_AST_DEMUXER 0
+#define CONFIG_AU_DEMUXER 0
+#define CONFIG_AV1_DEMUXER 0
+#define CONFIG_AVI_DEMUXER 0
+#define CONFIG_AVISYNTH_DEMUXER 0
+#define CONFIG_AVR_DEMUXER 0
+#define CONFIG_AVS_DEMUXER 0
+#define CONFIG_AVS2_DEMUXER 0
+#define CONFIG_AVS3_DEMUXER 0
+#define CONFIG_BETHSOFTVID_DEMUXER 0
+#define CONFIG_BFI_DEMUXER 0
+#define CONFIG_BINTEXT_DEMUXER 0
+#define CONFIG_BINK_DEMUXER 0
+#define CONFIG_BINKA_DEMUXER 0
+#define CONFIG_BIT_DEMUXER 0
+#define CONFIG_BITPACKED_DEMUXER 0
+#define CONFIG_BMV_DEMUXER 0
+#define CONFIG_BFSTM_DEMUXER 0
+#define CONFIG_BRSTM_DEMUXER 0
+#define CONFIG_BOA_DEMUXER 0
+#define CONFIG_C93_DEMUXER 0
+#define CONFIG_CAF_DEMUXER 0
+#define CONFIG_CAVSVIDEO_DEMUXER 0
+#define CONFIG_CDG_DEMUXER 0
+#define CONFIG_CDXL_DEMUXER 0
+#define CONFIG_CINE_DEMUXER 0
+#define CONFIG_CODEC2_DEMUXER 0
+#define CONFIG_CODEC2RAW_DEMUXER 0
+#define CONFIG_CONCAT_DEMUXER 0
+#define CONFIG_DASH_DEMUXER 0
+#define CONFIG_DATA_DEMUXER 0
+#define CONFIG_DAUD_DEMUXER 0
+#define CONFIG_DCSTR_DEMUXER 0
+#define CONFIG_DERF_DEMUXER 0
+#define CONFIG_DFA_DEMUXER 0
+#define CONFIG_DFPWM_DEMUXER 0
+#define CONFIG_DHAV_DEMUXER 0
+#define CONFIG_DIRAC_DEMUXER 0
+#define CONFIG_DNXHD_DEMUXER 0
+#define CONFIG_DSF_DEMUXER 0
+#define CONFIG_DSICIN_DEMUXER 0
+#define CONFIG_DSS_DEMUXER 0
+#define CONFIG_DTS_DEMUXER 0
+#define CONFIG_DTSHD_DEMUXER 0
+#define CONFIG_DV_DEMUXER 0
+#define CONFIG_DVBSUB_DEMUXER 0
+#define CONFIG_DVBTXT_DEMUXER 0
+#define CONFIG_DXA_DEMUXER 0
+#define CONFIG_EA_DEMUXER 0
+#define CONFIG_EA_CDATA_DEMUXER 0
+#define CONFIG_EAC3_DEMUXER 0
+#define CONFIG_EPAF_DEMUXER 0
+#define CONFIG_FFMETADATA_DEMUXER 0
+#define CONFIG_FILMSTRIP_DEMUXER 0
+#define CONFIG_FITS_DEMUXER 0
+#define CONFIG_FLAC_DEMUXER 0
+#define CONFIG_FLIC_DEMUXER 0
+#define CONFIG_FLV_DEMUXER 0
+#define CONFIG_LIVE_FLV_DEMUXER 0
+#define CONFIG_FOURXM_DEMUXER 0
+#define CONFIG_FRM_DEMUXER 0
+#define CONFIG_FSB_DEMUXER 0
+#define CONFIG_FWSE_DEMUXER 0
+#define CONFIG_G722_DEMUXER 0
+#define CONFIG_G723_1_DEMUXER 0
+#define CONFIG_G726_DEMUXER 0
+#define CONFIG_G726LE_DEMUXER 0
+#define CONFIG_G729_DEMUXER 0
+#define CONFIG_GDV_DEMUXER 0
+#define CONFIG_GENH_DEMUXER 0
+#define CONFIG_GIF_DEMUXER 0
+#define CONFIG_GSM_DEMUXER 0
+#define CONFIG_GXF_DEMUXER 0
+#define CONFIG_H261_DEMUXER 0
+#define CONFIG_H263_DEMUXER 0
+#define CONFIG_H264_DEMUXER 0
+#define CONFIG_HCA_DEMUXER 0
+#define CONFIG_HCOM_DEMUXER 0
+#define CONFIG_HEVC_DEMUXER 0
+#define CONFIG_HLS_DEMUXER 0
+#define CONFIG_HNM_DEMUXER 0
+#define CONFIG_ICO_DEMUXER 0
+#define CONFIG_IDCIN_DEMUXER 0
+#define CONFIG_IDF_DEMUXER 0
+#define CONFIG_IFF_DEMUXER 0
+#define CONFIG_IFV_DEMUXER 0
+#define CONFIG_ILBC_DEMUXER 0
+#define CONFIG_IMAGE2_DEMUXER 0
+#define CONFIG_IMAGE2PIPE_DEMUXER 0
+#define CONFIG_IMAGE2_ALIAS_PIX_DEMUXER 0
+#define CONFIG_IMAGE2_BRENDER_PIX_DEMUXER 0
+#define CONFIG_IMF_DEMUXER 0
+#define CONFIG_INGENIENT_DEMUXER 0
+#define CONFIG_IPMOVIE_DEMUXER 0
+#define CONFIG_IPU_DEMUXER 0
+#define CONFIG_IRCAM_DEMUXER 0
+#define CONFIG_ISS_DEMUXER 0
+#define CONFIG_IV8_DEMUXER 0
+#define CONFIG_IVF_DEMUXER 0
+#define CONFIG_IVR_DEMUXER 0
+#define CONFIG_JACOSUB_DEMUXER 0
+#define CONFIG_JV_DEMUXER 0
+#define CONFIG_KUX_DEMUXER 0
+#define CONFIG_KVAG_DEMUXER 0
+#define CONFIG_LMLM4_DEMUXER 0
+#define CONFIG_LOAS_DEMUXER 0
+#define CONFIG_LUODAT_DEMUXER 0
+#define CONFIG_LRC_DEMUXER 0
+#define CONFIG_LVF_DEMUXER 0
+#define CONFIG_LXF_DEMUXER 0
+#define CONFIG_M4V_DEMUXER 0
+#define CONFIG_MCA_DEMUXER 0
+#define CONFIG_MCC_DEMUXER 0
+#define CONFIG_MATROSKA_DEMUXER 0
+#define CONFIG_MGSTS_DEMUXER 0
+#define CONFIG_MICRODVD_DEMUXER 0
+#define CONFIG_MJPEG_DEMUXER 0
+#define CONFIG_MJPEG_2000_DEMUXER 0
+#define CONFIG_MLP_DEMUXER 0
+#define CONFIG_MLV_DEMUXER 0
+#define CONFIG_MM_DEMUXER 0
+#define CONFIG_MMF_DEMUXER 0
+#define CONFIG_MODS_DEMUXER 0
+#define CONFIG_MOFLEX_DEMUXER 0
+#define CONFIG_MOV_DEMUXER 0
+#define CONFIG_MP3_DEMUXER 0
+#define CONFIG_MPC_DEMUXER 0
+#define CONFIG_MPC8_DEMUXER 0
+#define CONFIG_MPEGPS_DEMUXER 0
+#define CONFIG_MPEGTS_DEMUXER 0
+#define CONFIG_MPEGTSRAW_DEMUXER 0
+#define CONFIG_MPEGVIDEO_DEMUXER 0
+#define CONFIG_MPJPEG_DEMUXER 0
+#define CONFIG_MPL2_DEMUXER 0
+#define CONFIG_MPSUB_DEMUXER 0
+#define CONFIG_MSF_DEMUXER 0
+#define CONFIG_MSNWC_TCP_DEMUXER 0
+#define CONFIG_MSP_DEMUXER 0
+#define CONFIG_MTAF_DEMUXER 0
+#define CONFIG_MTV_DEMUXER 0
+#define CONFIG_MUSX_DEMUXER 0
+#define CONFIG_MV_DEMUXER 0
+#define CONFIG_MVI_DEMUXER 0
+#define CONFIG_MXF_DEMUXER 0
+#define CONFIG_MXG_DEMUXER 0
+#define CONFIG_NC_DEMUXER 0
+#define CONFIG_NISTSPHERE_DEMUXER 0
+#define CONFIG_NSP_DEMUXER 0
+#define CONFIG_NSV_DEMUXER 0
+#define CONFIG_NUT_DEMUXER 0
+#define CONFIG_NUV_DEMUXER 0
+#define CONFIG_OBU_DEMUXER 0
+#define CONFIG_OGG_DEMUXER 0
+#define CONFIG_OMA_DEMUXER 0
+#define CONFIG_PAF_DEMUXER 0
+#define CONFIG_PCM_ALAW_DEMUXER 0
+#define CONFIG_PCM_MULAW_DEMUXER 0
+#define CONFIG_PCM_VIDC_DEMUXER 0
+#define CONFIG_PCM_F64BE_DEMUXER 0
+#define CONFIG_PCM_F64LE_DEMUXER 0
+#define CONFIG_PCM_F32BE_DEMUXER 0
+#define CONFIG_PCM_F32LE_DEMUXER 0
+#define CONFIG_PCM_S32BE_DEMUXER 0
+#define CONFIG_PCM_S32LE_DEMUXER 0
+#define CONFIG_PCM_S24BE_DEMUXER 0
+#define CONFIG_PCM_S24LE_DEMUXER 0
+#define CONFIG_PCM_S16BE_DEMUXER 0
+#define CONFIG_PCM_S16LE_DEMUXER 0
+#define CONFIG_PCM_S8_DEMUXER 0
+#define CONFIG_PCM_U32BE_DEMUXER 0
+#define CONFIG_PCM_U32LE_DEMUXER 0
+#define CONFIG_PCM_U24BE_DEMUXER 0
+#define CONFIG_PCM_U24LE_DEMUXER 0
+#define CONFIG_PCM_U16BE_DEMUXER 0
+#define CONFIG_PCM_U16LE_DEMUXER 0
+#define CONFIG_PCM_U8_DEMUXER 0
+#define CONFIG_PJS_DEMUXER 0
+#define CONFIG_PMP_DEMUXER 0
+#define CONFIG_PP_BNK_DEMUXER 0
+#define CONFIG_PVA_DEMUXER 0
+#define CONFIG_PVF_DEMUXER 0
+#define CONFIG_QCP_DEMUXER 0
+#define CONFIG_R3D_DEMUXER 0
+#define CONFIG_RAWVIDEO_DEMUXER 0
+#define CONFIG_REALTEXT_DEMUXER 0
+#define CONFIG_REDSPARK_DEMUXER 0
+#define CONFIG_RL2_DEMUXER 0
+#define CONFIG_RM_DEMUXER 0
+#define CONFIG_ROQ_DEMUXER 0
+#define CONFIG_RPL_DEMUXER 0
+#define CONFIG_RSD_DEMUXER 0
+#define CONFIG_RSO_DEMUXER 0
+#define CONFIG_RTP_DEMUXER 0
+#define CONFIG_RTSP_DEMUXER 0
+#define CONFIG_S337M_DEMUXER 0
+#define CONFIG_SAMI_DEMUXER 0
+#define CONFIG_SAP_DEMUXER 0
+#define CONFIG_SBC_DEMUXER 0
+#define CONFIG_SBG_DEMUXER 0
+#define CONFIG_SCC_DEMUXER 0
+#define CONFIG_SCD_DEMUXER 0
+#define CONFIG_SDP_DEMUXER 0
+#define CONFIG_SDR2_DEMUXER 0
+#define CONFIG_SDS_DEMUXER 0
+#define CONFIG_SDX_DEMUXER 0
+#define CONFIG_SEGAFILM_DEMUXER 0
+#define CONFIG_SER_DEMUXER 0
+#define CONFIG_SGA_DEMUXER 0
+#define CONFIG_SHORTEN_DEMUXER 0
+#define CONFIG_SIFF_DEMUXER 0
+#define CONFIG_SIMBIOSIS_IMX_DEMUXER 0
+#define CONFIG_SLN_DEMUXER 0
+#define CONFIG_SMACKER_DEMUXER 0
+#define CONFIG_SMJPEG_DEMUXER 0
+#define CONFIG_SMUSH_DEMUXER 0
+#define CONFIG_SOL_DEMUXER 0
+#define CONFIG_SOX_DEMUXER 0
+#define CONFIG_SPDIF_DEMUXER 0
+#define CONFIG_SRT_DEMUXER 0
+#define CONFIG_STR_DEMUXER 0
+#define CONFIG_STL_DEMUXER 0
+#define CONFIG_SUBVIEWER1_DEMUXER 0
+#define CONFIG_SUBVIEWER_DEMUXER 0
+#define CONFIG_SUP_DEMUXER 0
+#define CONFIG_SVAG_DEMUXER 0
+#define CONFIG_SVS_DEMUXER 0
+#define CONFIG_SWF_DEMUXER 0
+#define CONFIG_TAK_DEMUXER 0
+#define CONFIG_TEDCAPTIONS_DEMUXER 0
+#define CONFIG_THP_DEMUXER 0
+#define CONFIG_THREEDOSTR_DEMUXER 0
+#define CONFIG_TIERTEXSEQ_DEMUXER 0
+#define CONFIG_TMV_DEMUXER 0
+#define CONFIG_TRUEHD_DEMUXER 0
+#define CONFIG_TTA_DEMUXER 0
+#define CONFIG_TXD_DEMUXER 0
+#define CONFIG_TTY_DEMUXER 0
+#define CONFIG_TY_DEMUXER 0
+#define CONFIG_V210_DEMUXER 0
+#define CONFIG_V210X_DEMUXER 0
+#define CONFIG_VAG_DEMUXER 0
+#define CONFIG_VC1_DEMUXER 0
+#define CONFIG_VC1T_DEMUXER 0
+#define CONFIG_VIVIDAS_DEMUXER 0
+#define CONFIG_VIVO_DEMUXER 0
+#define CONFIG_VMD_DEMUXER 0
+#define CONFIG_VOBSUB_DEMUXER 0
+#define CONFIG_VOC_DEMUXER 0
+#define CONFIG_VPK_DEMUXER 0
+#define CONFIG_VPLAYER_DEMUXER 0
+#define CONFIG_VQF_DEMUXER 0
+#define CONFIG_W64_DEMUXER 0
+#define CONFIG_WAV_DEMUXER 0
+#define CONFIG_WC3_DEMUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_DEMUXER 0
+#define CONFIG_WEBVTT_DEMUXER 0
+#define CONFIG_WSAUD_DEMUXER 0
+#define CONFIG_WSD_DEMUXER 0
+#define CONFIG_WSVQA_DEMUXER 0
+#define CONFIG_WTV_DEMUXER 0
+#define CONFIG_WVE_DEMUXER 0
+#define CONFIG_WV_DEMUXER 0
+#define CONFIG_XA_DEMUXER 0
+#define CONFIG_XBIN_DEMUXER 0
+#define CONFIG_XMV_DEMUXER 0
+#define CONFIG_XVAG_DEMUXER 0
+#define CONFIG_XWMA_DEMUXER 0
+#define CONFIG_YOP_DEMUXER 0
+#define CONFIG_YUV4MPEGPIPE_DEMUXER 0
+#define CONFIG_IMAGE_BMP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_CRI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DDS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DPX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_EXR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GEM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GIF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_J2K_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGXL_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PAM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PCX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGMYUV_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PHOTOCD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PICTOR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PNG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PSD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QDRAW_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QOI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SGI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SVG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SUNRAST_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_TIFF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_VBN_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_WEBP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XWD_PIPE_DEMUXER 0
+#define CONFIG_LIBGME_DEMUXER 0
+#define CONFIG_LIBMODPLUG_DEMUXER 0
+#define CONFIG_LIBOPENMPT_DEMUXER 0
+#define CONFIG_VAPOURSYNTH_DEMUXER 0
+#define CONFIG_A64_MUXER 0
+#define CONFIG_AC3_MUXER 0
+#define CONFIG_ADTS_MUXER 0
+#define CONFIG_ADX_MUXER 0
+#define CONFIG_AIFF_MUXER 0
+#define CONFIG_ALP_MUXER 0
+#define CONFIG_AMR_MUXER 0
+#define CONFIG_AMV_MUXER 0
+#define CONFIG_APM_MUXER 0
+#define CONFIG_APNG_MUXER 0
+#define CONFIG_APTX_MUXER 0
+#define CONFIG_APTX_HD_MUXER 0
+#define CONFIG_ARGO_ASF_MUXER 0
+#define CONFIG_ARGO_CVG_MUXER 0
+#define CONFIG_ASF_MUXER 0
+#define CONFIG_ASS_MUXER 0
+#define CONFIG_AST_MUXER 0
+#define CONFIG_ASF_STREAM_MUXER 0
+#define CONFIG_AU_MUXER 0
+#define CONFIG_AVI_MUXER 0
+#define CONFIG_AVIF_MUXER 0
+#define CONFIG_AVM2_MUXER 0
+#define CONFIG_AVS2_MUXER 0
+#define CONFIG_AVS3_MUXER 0
+#define CONFIG_BIT_MUXER 0
+#define CONFIG_CAF_MUXER 0
+#define CONFIG_CAVSVIDEO_MUXER 0
+#define CONFIG_CODEC2_MUXER 0
+#define CONFIG_CODEC2RAW_MUXER 0
+#define CONFIG_CRC_MUXER 0
+#define CONFIG_DASH_MUXER 0
+#define CONFIG_DATA_MUXER 0
+#define CONFIG_DAUD_MUXER 0
+#define CONFIG_DFPWM_MUXER 0
+#define CONFIG_DIRAC_MUXER 0
+#define CONFIG_DNXHD_MUXER 0
+#define CONFIG_DTS_MUXER 0
+#define CONFIG_DV_MUXER 0
+#define CONFIG_EAC3_MUXER 0
+#define CONFIG_F4V_MUXER 0
+#define CONFIG_FFMETADATA_MUXER 0
+#define CONFIG_FIFO_MUXER 0
+#define CONFIG_FIFO_TEST_MUXER 0
+#define CONFIG_FILMSTRIP_MUXER 0
+#define CONFIG_FITS_MUXER 0
+#define CONFIG_FLAC_MUXER 0
+#define CONFIG_FLV_MUXER 0
+#define CONFIG_FRAMECRC_MUXER 0
+#define CONFIG_FRAMEHASH_MUXER 0
+#define CONFIG_FRAMEMD5_MUXER 0
+#define CONFIG_G722_MUXER 0
+#define CONFIG_G723_1_MUXER 0
+#define CONFIG_G726_MUXER 0
+#define CONFIG_G726LE_MUXER 0
+#define CONFIG_GIF_MUXER 0
+#define CONFIG_GSM_MUXER 0
+#define CONFIG_GXF_MUXER 0
+#define CONFIG_H261_MUXER 0
+#define CONFIG_H263_MUXER 0
+#define CONFIG_H264_MUXER 0
+#define CONFIG_HASH_MUXER 0
+#define CONFIG_HDS_MUXER 0
+#define CONFIG_HEVC_MUXER 0
+#define CONFIG_HLS_MUXER 0
+#define CONFIG_ICO_MUXER 0
+#define CONFIG_ILBC_MUXER 0
+#define CONFIG_IMAGE2_MUXER 0
+#define CONFIG_IMAGE2PIPE_MUXER 0
+#define CONFIG_IPOD_MUXER 0
+#define CONFIG_IRCAM_MUXER 0
+#define CONFIG_ISMV_MUXER 0
+#define CONFIG_IVF_MUXER 0
+#define CONFIG_JACOSUB_MUXER 0
+#define CONFIG_KVAG_MUXER 0
+#define CONFIG_LATM_MUXER 0
+#define CONFIG_LRC_MUXER 0
+#define CONFIG_M4V_MUXER 0
+#define CONFIG_MD5_MUXER 0
+#define CONFIG_MATROSKA_MUXER 0
+#define CONFIG_MATROSKA_AUDIO_MUXER 0
+#define CONFIG_MICRODVD_MUXER 0
+#define CONFIG_MJPEG_MUXER 0
+#define CONFIG_MLP_MUXER 0
+#define CONFIG_MMF_MUXER 0
+#define CONFIG_MOV_MUXER 0
+#define CONFIG_MP2_MUXER 0
+#define CONFIG_MP3_MUXER 0
+#define CONFIG_MP4_MUXER 0
+#define CONFIG_MPEG1SYSTEM_MUXER 0
+#define CONFIG_MPEG1VCD_MUXER 0
+#define CONFIG_MPEG1VIDEO_MUXER 0
+#define CONFIG_MPEG2DVD_MUXER 0
+#define CONFIG_MPEG2SVCD_MUXER 0
+#define CONFIG_MPEG2VIDEO_MUXER 0
+#define CONFIG_MPEG2VOB_MUXER 0
+#define CONFIG_MPEGTS_MUXER 0
+#define CONFIG_MPJPEG_MUXER 0
+#define CONFIG_MXF_MUXER 0
+#define CONFIG_MXF_D10_MUXER 0
+#define CONFIG_MXF_OPATOM_MUXER 0
+#define CONFIG_NULL_MUXER 0
+#define CONFIG_NUT_MUXER 0
+#define CONFIG_OBU_MUXER 0
+#define CONFIG_OGA_MUXER 0
+#define CONFIG_OGG_MUXER 0
+#define CONFIG_OGV_MUXER 0
+#define CONFIG_OMA_MUXER 0
+#define CONFIG_OPUS_MUXER 0
+#define CONFIG_PCM_ALAW_MUXER 0
+#define CONFIG_PCM_MULAW_MUXER 0
+#define CONFIG_PCM_VIDC_MUXER 0
+#define CONFIG_PCM_F64BE_MUXER 0
+#define CONFIG_PCM_F64LE_MUXER 0
+#define CONFIG_PCM_F32BE_MUXER 0
+#define CONFIG_PCM_F32LE_MUXER 0
+#define CONFIG_PCM_S32BE_MUXER 0
+#define CONFIG_PCM_S32LE_MUXER 0
+#define CONFIG_PCM_S24BE_MUXER 0
+#define CONFIG_PCM_S24LE_MUXER 0
+#define CONFIG_PCM_S16BE_MUXER 0
+#define CONFIG_PCM_S16LE_MUXER 0
+#define CONFIG_PCM_S8_MUXER 0
+#define CONFIG_PCM_U32BE_MUXER 0
+#define CONFIG_PCM_U32LE_MUXER 0
+#define CONFIG_PCM_U24BE_MUXER 0
+#define CONFIG_PCM_U24LE_MUXER 0
+#define CONFIG_PCM_U16BE_MUXER 0
+#define CONFIG_PCM_U16LE_MUXER 0
+#define CONFIG_PCM_U8_MUXER 0
+#define CONFIG_PSP_MUXER 0
+#define CONFIG_RAWVIDEO_MUXER 0
+#define CONFIG_RM_MUXER 0
+#define CONFIG_ROQ_MUXER 0
+#define CONFIG_RSO_MUXER 0
+#define CONFIG_RTP_MUXER 0
+#define CONFIG_RTP_MPEGTS_MUXER 0
+#define CONFIG_RTSP_MUXER 0
+#define CONFIG_SAP_MUXER 0
+#define CONFIG_SBC_MUXER 0
+#define CONFIG_SCC_MUXER 0
+#define CONFIG_SEGAFILM_MUXER 0
+#define CONFIG_SEGMENT_MUXER 0
+#define CONFIG_STREAM_SEGMENT_MUXER 0
+#define CONFIG_SMJPEG_MUXER 0
+#define CONFIG_SMOOTHSTREAMING_MUXER 0
+#define CONFIG_SOX_MUXER 0
+#define CONFIG_SPX_MUXER 0
+#define CONFIG_SPDIF_MUXER 0
+#define CONFIG_SRT_MUXER 0
+#define CONFIG_STREAMHASH_MUXER 0
+#define CONFIG_SUP_MUXER 0
+#define CONFIG_SWF_MUXER 0
+#define CONFIG_TEE_MUXER 0
+#define CONFIG_TG2_MUXER 0
+#define CONFIG_TGP_MUXER 0
+#define CONFIG_MKVTIMESTAMP_V2_MUXER 0
+#define CONFIG_TRUEHD_MUXER 0
+#define CONFIG_TTA_MUXER 0
+#define CONFIG_TTML_MUXER 0
+#define CONFIG_UNCODEDFRAMECRC_MUXER 0
+#define CONFIG_VC1_MUXER 0
+#define CONFIG_VC1T_MUXER 0
+#define CONFIG_VOC_MUXER 0
+#define CONFIG_W64_MUXER 0
+#define CONFIG_WAV_MUXER 0
+#define CONFIG_WEBM_MUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_MUXER 0
+#define CONFIG_WEBM_CHUNK_MUXER 0
+#define CONFIG_WEBP_MUXER 0
+#define CONFIG_WEBVTT_MUXER 0
+#define CONFIG_WSAUD_MUXER 0
+#define CONFIG_WTV_MUXER 0
+#define CONFIG_WV_MUXER 0
+#define CONFIG_YUV4MPEGPIPE_MUXER 0
+#define CONFIG_CHROMAPRINT_MUXER 0
+#define CONFIG_ASYNC_PROTOCOL 0
+#define CONFIG_BLURAY_PROTOCOL 0
+#define CONFIG_CACHE_PROTOCOL 0
+#define CONFIG_CONCAT_PROTOCOL 0
+#define CONFIG_CONCATF_PROTOCOL 0
+#define CONFIG_CRYPTO_PROTOCOL 0
+#define CONFIG_DATA_PROTOCOL 0
+#define CONFIG_FFRTMPCRYPT_PROTOCOL 0
+#define CONFIG_FFRTMPHTTP_PROTOCOL 0
+#define CONFIG_FILE_PROTOCOL 0
+#define CONFIG_FTP_PROTOCOL 0
+#define CONFIG_GOPHER_PROTOCOL 0
+#define CONFIG_GOPHERS_PROTOCOL 0
+#define CONFIG_HLS_PROTOCOL 0
+#define CONFIG_HTTP_PROTOCOL 0
+#define CONFIG_HTTPPROXY_PROTOCOL 0
+#define CONFIG_HTTPS_PROTOCOL 0
+#define CONFIG_ICECAST_PROTOCOL 0
+#define CONFIG_MMSH_PROTOCOL 0
+#define CONFIG_MMST_PROTOCOL 0
+#define CONFIG_MD5_PROTOCOL 0
+#define CONFIG_PIPE_PROTOCOL 0
+#define CONFIG_PROMPEG_PROTOCOL 0
+#define CONFIG_RTMP_PROTOCOL 0
+#define CONFIG_RTMPE_PROTOCOL 0
+#define CONFIG_RTMPS_PROTOCOL 0
+#define CONFIG_RTMPT_PROTOCOL 0
+#define CONFIG_RTMPTE_PROTOCOL 0
+#define CONFIG_RTMPTS_PROTOCOL 0
+#define CONFIG_RTP_PROTOCOL 0
+#define CONFIG_SCTP_PROTOCOL 0
+#define CONFIG_SRTP_PROTOCOL 0
+#define CONFIG_SUBFILE_PROTOCOL 0
+#define CONFIG_TEE_PROTOCOL 0
+#define CONFIG_TCP_PROTOCOL 0
+#define CONFIG_TLS_PROTOCOL 0
+#define CONFIG_UDP_PROTOCOL 0
+#define CONFIG_UDPLITE_PROTOCOL 0
+#define CONFIG_UNIX_PROTOCOL 0
+#define CONFIG_LIBAMQP_PROTOCOL 0
+#define CONFIG_LIBRIST_PROTOCOL 0
+#define CONFIG_LIBRTMP_PROTOCOL 0
+#define CONFIG_LIBRTMPE_PROTOCOL 0
+#define CONFIG_LIBRTMPS_PROTOCOL 0
+#define CONFIG_LIBRTMPT_PROTOCOL 0
+#define CONFIG_LIBRTMPTE_PROTOCOL 0
+#define CONFIG_LIBSRT_PROTOCOL 0
+#define CONFIG_LIBSSH_PROTOCOL 0
+#define CONFIG_LIBSMBCLIENT_PROTOCOL 0
+#define CONFIG_LIBZMQ_PROTOCOL 0
+#define CONFIG_IPFS_PROTOCOL 0
+#define CONFIG_IPNS_PROTOCOL 0
+#endif /* FFMPEG_CONFIG_COMPONENTS_H */
diff -Naur a/media/ffvpx/config_components.h b/media/ffvpx/config_components.h
--- a/media/ffvpx/config_components.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_components.h	2023-04-06 12:49:58.993149715 +0200
@@ -0,0 +1,27 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef MOZ_FFVPX_CONFIG__COMPONENTS_H
+#define MOZ_FFVPX_CONFIG__COMPONENTS_H
+
+
+#ifdef CONFIG_VAAPI
+#undef CONFIG_VAAPI
+#undef CONFIG_VAAPI_1
+#undef CONFIG_VP8_VAAPI_HWACCEL
+#undef CONFIG_VP9_VAAPI_HWACCEL
+#undef CONFIG_AV1_VAAPI_HWACCEL
+#endif
+
+#if defined(MOZ_FFVPX_AUDIOONLY)
+#    include "config_components_audio_only.h"
+#else
+#    include "config_components_audio_video.h"
+#endif
+
+#include "config_override.h"
+
+#endif // MOZ_FFVPX_CONFIG__COMPONENTS_H
diff -Naur a/media/ffvpx/config_darwin_aarch64.h b/media/ffvpx/config_darwin_aarch64.h
--- a/media/ffvpx/config_darwin_aarch64.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_darwin_aarch64.h	2023-04-06 12:49:19.192546469 +0200
@@ -0,0 +1,740 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='vp8,vp9,mp3,flac' --enable-parser='vp8,vp9' --disable-static --enable-shared --disable-autodetect --enable-neon"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2022
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "Apple clang version 13.1.6 (clang-1316.0.21.2.5)"
+#define OS_NAME darwin
+#define av_restrict restrict
+#define EXTERN_PREFIX "_"
+#define EXTERN_ASM _
+#define BUILDSUF ""
+#define SLIBSUF ".dylib"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 1
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_RISCV 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 1
+#define HAVE_NEON 1
+#define HAVE_VFP 1
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 1
+#define HAVE_NEON_EXTERNAL 1
+#define HAVE_VFP_EXTERNAL 1
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 1
+#define HAVE_NEON_INLINE 1
+#define HAVE_VFP_INLINE 1
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
+#define HAVE_ALIGNED_STACK 1
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 1
+#define HAVE_FAST_CMOV 0
+#define HAVE_LOCAL_ALIGNED 0
+#define HAVE_SIMD_ALIGN_16 1
+#define HAVE_SIMD_ALIGN_32 0
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 0
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_CABS 1
+#define HAVE_CEXP 1
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 1
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 1
+#define HAVE_ARPA_INET_H 1
+#define HAVE_ASM_TYPES_H 0
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 1
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 0
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 0
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 0
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VALGRIND_VALGRIND_H 0
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 0
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 1
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 0
+#define HAVE_GETENV 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 1
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 1
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 1
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 0
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PTHREAD_CANCEL 1
+#define HAVE_SCHED_GETAFFINITY 0
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 1
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 1
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 0
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 0
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
+#define HAVE_STRUCT_IP_MREQ_SOURCE 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 1
+#define HAVE_STRUCT_POLLFD 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 1
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 1
+#define CONFIG_PODPAGES 1
+#define CONFIG_TXTPAGES 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 0
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 0
+#define CONFIG_METADATA_EXAMPLE 0
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 0
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 1
+#define CONFIG_SMALL 0
+#define CONFIG_STATIC 0
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 1
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 0
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
+#define CONFIG_DIRAC_PARSE 0
+#define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 0
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 1
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 0
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 1
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 0
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 0
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 1
+#define CONFIG_VP3DSP 0
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 1
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_generic.h b/media/ffvpx/config_generic.h
--- a/media/ffvpx/config_generic.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_generic.h	2023-04-06 12:49:19.192546469 +0200
@@ -0,0 +1,740 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='mp3,flac' --disable-static --enable-shared --disable-autodetect --enable-small --disable-asm"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2022
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "Apple clang version 13.1.6 (clang-1316.0.21.2.5)"
+#define OS_NAME darwin
+#define av_restrict restrict
+#define EXTERN_PREFIX "_"
+#define EXTERN_ASM _
+#define BUILDSUF ""
+#define SLIBSUF ".dylib"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 0
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_RISCV 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 0
+#define HAVE_NEON 0
+#define HAVE_VFP 0
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 1
+#define HAVE_NEON_EXTERNAL 1
+#define HAVE_VFP_EXTERNAL 1
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 1
+#define HAVE_NEON_INLINE 1
+#define HAVE_VFP_INLINE 1
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
+#define HAVE_ALIGNED_STACK 0
+#define HAVE_FAST_64BIT 0
+#define HAVE_FAST_CLZ 0
+#define HAVE_FAST_CMOV 0
+#define HAVE_LOCAL_ALIGNED 0
+#define HAVE_SIMD_ALIGN_16 0
+#define HAVE_SIMD_ALIGN_32 0
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 0
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_CABS 1
+#define HAVE_CEXP 1
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 1
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 0
+#define HAVE_ARPA_INET_H 1
+#define HAVE_ASM_TYPES_H 0
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 1
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 0
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 0
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 0
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VALGRIND_VALGRIND_H 0
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 0
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 0
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 1
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 0
+#define HAVE_GETENV 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 1
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 1
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 0
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 0
+#define HAVE_PTHREAD_CANCEL 1
+#define HAVE_SCHED_GETAFFINITY 0
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 0
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 1
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 0
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 0
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
+#define HAVE_STRUCT_IP_MREQ_SOURCE 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 1
+#define HAVE_STRUCT_POLLFD 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 1
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 1
+#define CONFIG_PODPAGES 1
+#define CONFIG_TXTPAGES 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 0
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 0
+#define CONFIG_METADATA_EXAMPLE 0
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 0
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 1
+#define CONFIG_SMALL 1
+#define CONFIG_STATIC 0
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 1
+#define CONFIG_FAST_UNALIGNED 0
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 0
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 0
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
+#define CONFIG_DIRAC_PARSE 0
+#define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 0
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 0
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 0
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 1
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 0
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 0
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 0
+#define CONFIG_VP3DSP 0
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 0
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config.h b/media/ffvpx/config.h
--- a/media/ffvpx/config.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config.h	2023-04-06 12:49:58.993149715 +0200
@@ -10,8 +10,13 @@
 #if defined(MOZ_FFVPX_AUDIOONLY)
 #  if defined(MOZ_WIDGET_ANDROID) && defined(__arm__)
 #    include "config_android32.h"
+#  elif defined(MOZ_WIDGET_ANDROID) && defined(__aarch64__)
+#    include "config_android64.h"
+#  elif defined(__aarch64__)
+#    include "config_unix_aarch64.h"
 #  else
-#    include "config_audio.h"
+      // no assembly
+#    include "config_generic.h"
 #  endif
 #else  // MOZ_FFVPX_AUDIOONLY
 #  if defined(XP_WIN)
@@ -21,7 +26,7 @@
 #      undef HAVE_UNISTD_H
 #    endif
 #    if defined(_ARM64_)
-#      include "config_aarch64_win64.h"
+#      include "config_win64_aarch64.h"
 #    else
 #      if defined(HAVE_64BIT_BUILD)
 #        include "config_win64.h"
@@ -39,7 +44,13 @@
 #      define HAVE_LIBC_MSVCRT 0
 #    endif
 #  elif defined(XP_DARWIN)
-#    include "config_darwin64.h"
+#    if defined(__aarch64__)
+#      include "config_darwin_aarch64.h"
+#    else
+#      include "config_darwin64.h"
+#    endif
+#  elif defined(MOZ_WIDGET_ANDROID) && defined(HAVE_64BIT_BUILD)
+#      include "config_android_x86_64.h"
 #  elif defined(XP_UNIX)
 #    if defined(HAVE_64BIT_BUILD)
 #      include "config_unix64.h"
@@ -48,7 +59,7 @@
 #    endif
 #  endif
 #endif  // else MOZ_FFVPX_AUDIOONLY
-
-#include "config_common.h"
+        //
+#include "config_override.h"
 
 #endif  // MOZ_FFVPX_CONFIG_H
diff -Naur a/media/ffvpx/config_override.h b/media/ffvpx/config_override.h
--- a/media/ffvpx/config_override.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_override.h	2023-04-06 12:49:58.993149715 +0200
@@ -0,0 +1,32 @@
+#ifndef MOZ_FFVPX_CONFIG_OVERRIDE_H
+#define MOZ_FFVPX_CONFIG_OVERRIDE_H
+
+// This file contains overrides for config.h, that can be platform-specific.
+
+#ifdef MOZ_LIBAV_FFT
+#undef CONFIG_FFT
+#undef CONFIG_RDFT
+#define CONFIG_FFT 1
+#define CONFIG_RDFT 1
+#endif
+
+#if defined(MOZ_WAYLAND) && !defined(MOZ_FFVPX_AUDIOONLY)
+#undef CONFIG_VAAPI
+#undef CONFIG_VAAPI_1
+#undef CONFIG_VP8_VAAPI_HWACCEL
+#undef CONFIG_VP9_VAAPI_HWACCEL
+#undef CONFIG_AV1_VAAPI_HWACCEL
+#define CONFIG_VAAPI 1
+#define CONFIG_VAAPI_1 1
+#define CONFIG_VP8_VAAPI_HWACCEL 1
+#define CONFIG_VP9_VAAPI_HWACCEL 1
+#define CONFIG_AV1_VAAPI_HWACCEL 1
+#else
+#define CONFIG_VAAPI 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VP8_VAAPI_HWACCEL 0
+#define CONFIG_VP9_VAAPI_HWACCEL 0
+#define CONFIG_AV1_VAAPI_HWACCEL 0
+#endif
+
+#endif
diff -Naur a/media/ffvpx/config_unix32.h b/media/ffvpx/config_unix32.h
--- a/media/ffvpx/config_unix32.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_unix32.h	2023-04-06 12:49:19.192546469 +0200
@@ -1,15 +1,16 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "--disable-everything --disable-protocols --disable-demuxers --disable-muxers --disable-filters --disable-programs --disable-doc --disable-parsers --enable-parser=vp8 --enable-parser=vp9 --enable-decoder=vp8 --enable-decoder=vp9 --disable-static --enable-shared --disable-debug --disable-sdl2 --disable-libxcb --disable-securetransport --disable-iconv --disable-swresample --disable-swscale --disable-avdevice --disable-avfilter --disable-avformat --disable-d3d11va --disable-dxva2 --disable-vaapi --disable-vdpau --disable-videotoolbox --enable-decoder=flac --disable-asm --disable-x86asm --disable-cuda --disable-cuvid --enable-decoder=mp3"
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='vp8,vp9,mp3,flac' --enable-parser='vp8,vp9' --disable-static --enable-shared --disable-autodetect --disable-asm --disable-x86asm --cc='clang -m32' --disable-iconv"
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
-#define CONFIG_THIS_YEAR 2019
+#define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "gcc 6.3.0 (Ubuntu 6.3.0-12ubuntu2) 20170406"
+#define CC_IDENT "Ubuntu clang version 14.0.0-1ubuntu1"
+#define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
-#define EXTERN_ASM
+#define EXTERN_ASM 
 #define BUILDSUF ""
 #define SLIBSUF ".so"
 #define HAVE_MMX2 HAVE_MMXEXT
@@ -22,12 +23,16 @@
 #define ARCH_AVR32_UC 0
 #define ARCH_BFIN 0
 #define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
 #define ARCH_M68K 0
 #define ARCH_MIPS 0
 #define ARCH_MIPS64 0
 #define ARCH_PARISC 0
 #define ARCH_PPC 0
 #define ARCH_PPC64 0
+#define ARCH_RISCV 0
 #define ARCH_S390 0
 #define ARCH_SH4 0
 #define ARCH_SPARC 0
@@ -58,6 +63,7 @@
 #define HAVE_AVX 0
 #define HAVE_AVX2 0
 #define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
 #define HAVE_FMA3 0
 #define HAVE_FMA4 0
 #define HAVE_MMX 0
@@ -80,10 +86,11 @@
 #define HAVE_MIPSDSP 0
 #define HAVE_MIPSDSPR2 0
 #define HAVE_MSA 0
-#define HAVE_MSA2 0
 #define HAVE_LOONGSON2 0
 #define HAVE_LOONGSON3 0
 #define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
 #define HAVE_ARMV5TE_EXTERNAL 0
 #define HAVE_ARMV6_EXTERNAL 0
 #define HAVE_ARMV6T2_EXTERNAL 0
@@ -104,6 +111,7 @@
 #define HAVE_AVX_EXTERNAL 0
 #define HAVE_AVX2_EXTERNAL 0
 #define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
 #define HAVE_FMA3_EXTERNAL 0
 #define HAVE_FMA4_EXTERNAL 0
 #define HAVE_MMX_EXTERNAL 0
@@ -126,10 +134,11 @@
 #define HAVE_MIPSDSP_EXTERNAL 0
 #define HAVE_MIPSDSPR2_EXTERNAL 0
 #define HAVE_MSA_EXTERNAL 0
-#define HAVE_MSA2_EXTERNAL 0
 #define HAVE_LOONGSON2_EXTERNAL 0
 #define HAVE_LOONGSON3_EXTERNAL 0
 #define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 0
 #define HAVE_ARMV6_INLINE 0
 #define HAVE_ARMV6T2_INLINE 0
@@ -150,6 +159,7 @@
 #define HAVE_AVX_INLINE 0
 #define HAVE_AVX2_INLINE 0
 #define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
 #define HAVE_FMA3_INLINE 0
 #define HAVE_FMA4_INLINE 0
 #define HAVE_MMX_INLINE 0
@@ -172,10 +182,11 @@
 #define HAVE_MIPSDSP_INLINE 0
 #define HAVE_MIPSDSPR2_INLINE 0
 #define HAVE_MSA_INLINE 0
-#define HAVE_MSA2_INLINE 0
 #define HAVE_LOONGSON2_INLINE 0
 #define HAVE_LOONGSON3_INLINE 0
 #define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
 #define HAVE_ALIGNED_STACK 0
 #define HAVE_FAST_64BIT 0
 #define HAVE_FAST_CLZ 0
@@ -191,8 +202,8 @@
 #define HAVE_RDTSC 0
 #define HAVE_SEM_TIMEDWAIT 1
 #define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
-#define HAVE_CABS 1
-#define HAVE_CEXP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
 #define HAVE_INLINE_ASM 1
 #define HAVE_SYMVER 1
 #define HAVE_X86ASM 0
@@ -216,7 +227,8 @@
 #define HAVE_ES2_GL_H 0
 #define HAVE_GSM_H 0
 #define HAVE_IO_H 0
-#define HAVE_LINUX_PERF_EVENT_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
 #define HAVE_MACHINE_IOCTL_BT848_H 0
 #define HAVE_MACHINE_IOCTL_METEOR_H 0
 #define HAVE_OPENCV2_CORE_CORE_C_H 0
@@ -268,7 +280,7 @@
 #define HAVE_DOS_PATHS 0
 #define HAVE_LIBC_MSVCRT 0
 #define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
-#define HAVE_SECTION_DATA_REL_RO 0
+#define HAVE_SECTION_DATA_REL_RO 1
 #define HAVE_THREADS 1
 #define HAVE_UWP 0
 #define HAVE_WINRT 0
@@ -279,12 +291,16 @@
 #define HAVE_COMMANDLINETOARGVW 0
 #define HAVE_FCNTL 1
 #define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_GETENV 1
 #define HAVE_GETHRTIME 0
 #define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
 #define HAVE_GETPROCESSAFFINITYMASK 0
 #define HAVE_GETPROCESSMEMORYINFO 0
 #define HAVE_GETPROCESSTIMES 0
 #define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
 #define HAVE_GETSYSTEMTIMEASFILETIME 0
 #define HAVE_GETTIMEOFDAY 1
 #define HAVE_GLOB 1
@@ -303,10 +319,11 @@
 #define HAVE_NANOSLEEP 1
 #define HAVE_PEEKNAMEDPIPE 0
 #define HAVE_PTHREAD_CANCEL 1
-#define HAVE_SCHED_GETAFFINITY 0
+#define HAVE_SCHED_GETAFFINITY 1
 #define HAVE_SECITEMIMPORT 0
 #define HAVE_SETCONSOLETEXTATTRIBUTE 0
 #define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
 #define HAVE_SETMODE 0
 #define HAVE_SETRLIMIT 1
 #define HAVE_SLEEP 0
@@ -341,13 +358,28 @@
 #define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
 #define HAVE_PRAGMA_DEPRECATED 1
 #define HAVE_RSYNC_CONTIMEOUT 1
-#define HAVE_SYMVER_ASM_LABEL 0
+#define HAVE_SYMVER_ASM_LABEL 1
 #define HAVE_SYMVER_GNU_ASM 1
 #define HAVE_VFP_ARGS 0
 #define HAVE_XFORM_ASM 0
-#define HAVE_XMM_CLOBBERS 0
+#define HAVE_XMM_CLOBBERS 1
 #define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
 #define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 #define HAVE_SOCKLEN_T 1
 #define HAVE_STRUCT_ADDRINFO 1
 #define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -361,9 +393,11 @@
 #define HAVE_STRUCT_SOCKADDR_SA_LEN 0
 #define HAVE_STRUCT_SOCKADDR_STORAGE 1
 #define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
-#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 1
-#define HAVE_MAKEINFO 0
-#define HAVE_MAKEINFO_HTML 0
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 1
 #define HAVE_OPENCL_D3D11 0
 #define HAVE_OPENCL_DRM_ARM 0
 #define HAVE_OPENCL_DRM_BEIGNET 0
@@ -372,13 +406,15 @@
 #define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
 #define HAVE_PERL 1
 #define HAVE_POD2MAN 1
-#define HAVE_TEXI2HTML 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
 #define CONFIG_DOC 0
 #define CONFIG_HTMLPAGES 1
 #define CONFIG_MANPAGES 1
 #define CONFIG_PODPAGES 1
 #define CONFIG_TXTPAGES 1
-#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 #define CONFIG_AVIO_READING_EXAMPLE 1
 #define CONFIG_DECODE_AUDIO_EXAMPLE 1
 #define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -414,14 +450,12 @@
 #define CONFIG_LIBXVID 0
 #define CONFIG_DECKLINK 0
 #define CONFIG_LIBFDK_AAC 0
-#define CONFIG_OPENSSL 0
 #define CONFIG_LIBTLS 0
 #define CONFIG_GMP 0
 #define CONFIG_LIBARIBB24 0
 #define CONFIG_LIBLENSFUN 0
 #define CONFIG_LIBOPENCORE_AMRNB 0
 #define CONFIG_LIBOPENCORE_AMRWB 0
-#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVO_AMRWBENC 0
 #define CONFIG_MBEDTLS 0
 #define CONFIG_RKMPP 0
@@ -431,6 +465,7 @@
 #define CONFIG_GNUTLS 0
 #define CONFIG_JNI 0
 #define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
 #define CONFIG_LIBAOM 0
 #define CONFIG_LIBASS 0
 #define CONFIG_LIBBLURAY 0
@@ -438,18 +473,20 @@
 #define CONFIG_LIBCACA 0
 #define CONFIG_LIBCELT 0
 #define CONFIG_LIBCODEC2 0
-#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDAV1D 1
 #define CONFIG_LIBDC1394 0
 #define CONFIG_LIBDRM 0
 #define CONFIG_LIBFLITE 0
 #define CONFIG_LIBFONTCONFIG 0
 #define CONFIG_LIBFREETYPE 0
 #define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
 #define CONFIG_LIBGME 0
 #define CONFIG_LIBGSM 0
 #define CONFIG_LIBIEC61883 0
 #define CONFIG_LIBILBC 0
 #define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
 #define CONFIG_LIBKLVANC 0
 #define CONFIG_LIBKVAZAAR 0
 #define CONFIG_LIBMODPLUG 0
@@ -459,10 +496,16 @@
 #define CONFIG_LIBOPENH264 0
 #define CONFIG_LIBOPENJPEG 0
 #define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
 #define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
 #define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
 #define CONFIG_LIBRSVG 0
 #define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
 #define CONFIG_LIBSHINE 0
 #define CONFIG_LIBSMBCLIENT 0
 #define CONFIG_LIBSNAPPY 0
@@ -470,14 +513,16 @@
 #define CONFIG_LIBSPEEX 0
 #define CONFIG_LIBSRT 0
 #define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
 #define CONFIG_LIBTENSORFLOW 0
 #define CONFIG_LIBTESSERACT 0
 #define CONFIG_LIBTHEORA 0
 #define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
 #define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVORBIS 0
 #define CONFIG_LIBVPX 0
-#define CONFIG_LIBWAVPACK 0
 #define CONFIG_LIBWEBP 0
 #define CONFIG_LIBXML2 0
 #define CONFIG_LIBZIMG 0
@@ -487,25 +532,28 @@
 #define CONFIG_MEDIACODEC 0
 #define CONFIG_OPENAL 0
 #define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
 #define CONFIG_POCKETSPHINX 0
 #define CONFIG_VAPOURSYNTH 0
 #define CONFIG_ALSA 0
-#define CONFIG_APPKIT 1
-#define CONFIG_AVFOUNDATION 1
-#define CONFIG_BZLIB 1
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
 #define CONFIG_COREIMAGE 0
 #define CONFIG_ICONV 0
 #define CONFIG_LIBXCB 0
 #define CONFIG_LIBXCB_SHM 0
 #define CONFIG_LIBXCB_SHAPE 0
 #define CONFIG_LIBXCB_XFIXES 0
-#define CONFIG_LZMA 1
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
 #define CONFIG_SCHANNEL 0
 #define CONFIG_SDL2 0
 #define CONFIG_SECURETRANSPORT 0
 #define CONFIG_SNDIO 0
-#define CONFIG_XLIB 1
-#define CONFIG_ZLIB 1
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
 #define CONFIG_CUDA_NVCC 0
 #define CONFIG_CUDA_SDK 0
 #define CONFIG_LIBNPP 0
@@ -514,7 +562,7 @@
 #define CONFIG_OMX 0
 #define CONFIG_OPENCL 0
 #define CONFIG_AMF 0
-#define CONFIG_AUDIOTOOLBOX 1
+#define CONFIG_AUDIOTOOLBOX 0
 #define CONFIG_CRYSTALHD 0
 #define CONFIG_CUDA 0
 #define CONFIG_CUDA_LLVM 0
@@ -527,8 +575,8 @@
 #define CONFIG_VAAPI 0
 #define CONFIG_VDPAU 0
 #define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
 #define CONFIG_V4L2_M2M 0
-#define CONFIG_XVMC 0
 #define CONFIG_FTRAPV 0
 #define CONFIG_GRAY 0
 #define CONFIG_HARDCODED_TABLES 0
@@ -549,7 +597,6 @@
 #define CONFIG_AVFORMAT 0
 #define CONFIG_AVCODEC 1
 #define CONFIG_SWRESAMPLE 0
-#define CONFIG_AVRESAMPLE 0
 #define CONFIG_AVUTIL 1
 #define CONFIG_FFPLAY 0
 #define CONFIG_FFPROBE 0
@@ -561,46 +608,59 @@
 #define CONFIG_FAST_UNALIGNED 0
 #define CONFIG_FFT 1
 #define CONFIG_LSP 0
-#define CONFIG_LZO 0
 #define CONFIG_MDCT 0
 #define CONFIG_PIXELUTILS 0
 #define CONFIG_NETWORK 0
 #define CONFIG_RDFT 1
 #define CONFIG_AUTODETECT 0
 #define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
 #define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
 #define CONFIG_MEMORY_POISONING 0
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
 #define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
-#define CONFIG_BSFS 1
+#define CONFIG_BSFS 0
 #define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
 #define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
 #define CONFIG_AANDCTTABLES 0
 #define CONFIG_AC3DSP 0
 #define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
 #define CONFIG_AUDIO_FRAME_QUEUE 0
 #define CONFIG_AUDIODSP 0
 #define CONFIG_BLOCKDSP 0
 #define CONFIG_BSWAPDSP 0
 #define CONFIG_CABAC 0
-#define CONFIG_CBS 1
-#define CONFIG_CBS_AV1 1
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
 #define CONFIG_CBS_H264 0
 #define CONFIG_CBS_H265 0
 #define CONFIG_CBS_JPEG 0
 #define CONFIG_CBS_MPEG2 0
 #define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
 #define CONFIG_DIRAC_PARSE 0
 #define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
 #define CONFIG_DVPROFILE 0
 #define CONFIG_EXIF 0
-#define CONFIG_FAANDCT 0
-#define CONFIG_FAANIDCT 0
-#define CONFIG_FDCTDSP 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
 #define CONFIG_FLACDSP 1
 #define CONFIG_FMTCONVERT 0
 #define CONFIG_FRAME_THREAD_ENCODER 0
@@ -618,9 +678,10 @@
 #define CONFIG_HUFFMAN 0
 #define CONFIG_HUFFYUVDSP 0
 #define CONFIG_HUFFYUVENCDSP 0
-#define CONFIG_IDCTDSP 0
+#define CONFIG_IDCTDSP 1
 #define CONFIG_IIRFILTER 0
 #define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
 #define CONFIG_INTRAX8 0
 #define CONFIG_ISO_MEDIA 0
 #define CONFIG_IVIDSP 0
@@ -637,7 +698,9 @@
 #define CONFIG_MPEGAUDIO 1
 #define CONFIG_MPEGAUDIODSP 1
 #define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
 #define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
 #define CONFIG_MPEGVIDEOENC 0
 #define CONFIG_MSS34DSP 0
 #define CONFIG_PIXBLOCKDSP 0
@@ -669,14 +732,4 @@
 #define CONFIG_VP8DSP 1
 #define CONFIG_WMA_FREQS 0
 #define CONFIG_WMV2DSP 0
-#define CONFIG_NULL_BSF 1
-#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-#define CONFIG_VP8_DECODER 1
-#define CONFIG_VP9_DECODER 1
-#define CONFIG_AV1_DECODER 1
-#define CONFIG_FLAC_DECODER 1
-#define CONFIG_MP3_DECODER 1
-#define CONFIG_VP8_PARSER 1
-#define CONFIG_VP9_PARSER 1
-#define CONFIG_AV1_PARSER 1
 #endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_unix64.asm b/media/ffvpx/config_unix64.asm
--- a/media/ffvpx/config_unix64.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_unix64.asm	2023-04-06 12:49:19.192546469 +0200
@@ -7,12 +7,16 @@
 %define ARCH_AVR32_UC 0
 %define ARCH_BFIN 0
 %define ARCH_IA64 0
+%define ARCH_LOONGARCH 0
+%define ARCH_LOONGARCH32 0
+%define ARCH_LOONGARCH64 0
 %define ARCH_M68K 0
 %define ARCH_MIPS 0
 %define ARCH_MIPS64 0
 %define ARCH_PARISC 0
 %define ARCH_PPC 0
 %define ARCH_PPC64 0
+%define ARCH_RISCV 0
 %define ARCH_S390 0
 %define ARCH_SH4 0
 %define ARCH_SPARC 0
@@ -43,6 +47,7 @@
 %define HAVE_AVX 1
 %define HAVE_AVX2 1
 %define HAVE_AVX512 1
+%define HAVE_AVX512ICL 1
 %define HAVE_FMA3 1
 %define HAVE_FMA4 1
 %define HAVE_MMX 1
@@ -65,10 +70,11 @@
 %define HAVE_MIPSDSP 0
 %define HAVE_MIPSDSPR2 0
 %define HAVE_MSA 0
-%define HAVE_MSA2 0
 %define HAVE_LOONGSON2 0
 %define HAVE_LOONGSON3 0
 %define HAVE_MMI 0
+%define HAVE_LSX 0
+%define HAVE_LASX 0
 %define HAVE_ARMV5TE_EXTERNAL 0
 %define HAVE_ARMV6_EXTERNAL 0
 %define HAVE_ARMV6T2_EXTERNAL 0
@@ -89,6 +95,7 @@
 %define HAVE_AVX_EXTERNAL 1
 %define HAVE_AVX2_EXTERNAL 1
 %define HAVE_AVX512_EXTERNAL 1
+%define HAVE_AVX512ICL_EXTERNAL 1
 %define HAVE_FMA3_EXTERNAL 1
 %define HAVE_FMA4_EXTERNAL 1
 %define HAVE_MMX_EXTERNAL 1
@@ -111,10 +118,11 @@
 %define HAVE_MIPSDSP_EXTERNAL 0
 %define HAVE_MIPSDSPR2_EXTERNAL 0
 %define HAVE_MSA_EXTERNAL 0
-%define HAVE_MSA2_EXTERNAL 0
 %define HAVE_LOONGSON2_EXTERNAL 0
 %define HAVE_LOONGSON3_EXTERNAL 0
 %define HAVE_MMI_EXTERNAL 0
+%define HAVE_LSX_EXTERNAL 0
+%define HAVE_LASX_EXTERNAL 0
 %define HAVE_ARMV5TE_INLINE 0
 %define HAVE_ARMV6_INLINE 0
 %define HAVE_ARMV6T2_INLINE 0
@@ -135,6 +143,7 @@
 %define HAVE_AVX_INLINE 1
 %define HAVE_AVX2_INLINE 1
 %define HAVE_AVX512_INLINE 1
+%define HAVE_AVX512ICL_INLINE 1
 %define HAVE_FMA3_INLINE 1
 %define HAVE_FMA4_INLINE 1
 %define HAVE_MMX_INLINE 1
@@ -157,10 +166,11 @@
 %define HAVE_MIPSDSP_INLINE 0
 %define HAVE_MIPSDSPR2_INLINE 0
 %define HAVE_MSA_INLINE 0
-%define HAVE_MSA2_INLINE 0
 %define HAVE_LOONGSON2_INLINE 0
 %define HAVE_LOONGSON3_INLINE 0
 %define HAVE_MMI_INLINE 0
+%define HAVE_LSX_INLINE 0
+%define HAVE_LASX_INLINE 0
 %define HAVE_ALIGNED_STACK 1
 %define HAVE_FAST_64BIT 1
 %define HAVE_FAST_CLZ 1
@@ -176,8 +186,8 @@
 %define HAVE_RDTSC 0
 %define HAVE_SEM_TIMEDWAIT 1
 %define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
-%define HAVE_CABS 1
-%define HAVE_CEXP 1
+%define HAVE_CABS 0
+%define HAVE_CEXP 0
 %define HAVE_INLINE_ASM 1
 %define HAVE_SYMVER 1
 %define HAVE_X86ASM 1
@@ -201,9 +211,11 @@
 %define HAVE_ES2_GL_H 0
 %define HAVE_GSM_H 0
 %define HAVE_IO_H 0
-%define HAVE_LINUX_PERF_EVENT_H 0
+%define HAVE_LINUX_DMA_BUF_H 0
+%define HAVE_LINUX_PERF_EVENT_H 1
 %define HAVE_MACHINE_IOCTL_BT848_H 0
 %define HAVE_MACHINE_IOCTL_METEOR_H 0
+%define HAVE_MALLOC_H 1
 %define HAVE_OPENCV2_CORE_CORE_C_H 0
 %define HAVE_OPENGL_GL3_H 0
 %define HAVE_POLL_H 1
@@ -253,23 +265,28 @@
 %define HAVE_DOS_PATHS 0
 %define HAVE_LIBC_MSVCRT 0
 %define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
-%define HAVE_SECTION_DATA_REL_RO 0
+%define HAVE_SECTION_DATA_REL_RO 1
 %define HAVE_THREADS 1
 %define HAVE_UWP 0
 %define HAVE_WINRT 0
 %define HAVE_ACCESS 1
 %define HAVE_ALIGNED_MALLOC 0
+%define HAVE_ARC4RANDOM 0
 %define HAVE_CLOCK_GETTIME 1
 %define HAVE_CLOSESOCKET 0
 %define HAVE_COMMANDLINETOARGVW 0
 %define HAVE_FCNTL 1
 %define HAVE_GETADDRINFO 1
+%define HAVE_GETAUXVAL 1
+%define HAVE_GETENV 1
 %define HAVE_GETHRTIME 0
 %define HAVE_GETOPT 1
+%define HAVE_GETMODULEHANDLE 0
 %define HAVE_GETPROCESSAFFINITYMASK 0
 %define HAVE_GETPROCESSMEMORYINFO 0
 %define HAVE_GETPROCESSTIMES 0
 %define HAVE_GETRUSAGE 1
+%define HAVE_GETSTDHANDLE 0
 %define HAVE_GETSYSTEMTIMEASFILETIME 0
 %define HAVE_GETTIMEOFDAY 1
 %define HAVE_GLOB 1
@@ -278,20 +295,24 @@
 %define HAVE_INET_ATON 1
 %define HAVE_ISATTY 1
 %define HAVE_KBHIT 0
+%define HAVE_LOCALTIME_R 1
 %define HAVE_LSTAT 1
 %define HAVE_LZO1X_999_COMPRESS 0
 %define HAVE_MACH_ABSOLUTE_TIME 0
 %define HAVE_MAPVIEWOFFILE 0
+%define HAVE_MEMALIGN 1
 %define HAVE_MKSTEMP 1
 %define HAVE_MMAP 1
 %define HAVE_MPROTECT 1
 %define HAVE_NANOSLEEP 1
 %define HAVE_PEEKNAMEDPIPE 0
+%define HAVE_POSIX_MEMALIGN 1
 %define HAVE_PTHREAD_CANCEL 1
 %define HAVE_SCHED_GETAFFINITY 1
 %define HAVE_SECITEMIMPORT 0
 %define HAVE_SETCONSOLETEXTATTRIBUTE 0
 %define HAVE_SETCONSOLECTRLHANDLER 0
+%define HAVE_SETDLLDIRECTORY 0
 %define HAVE_SETMODE 0
 %define HAVE_SETRLIMIT 1
 %define HAVE_SLEEP 0
@@ -303,7 +324,7 @@
 %define HAVE_VIRTUALALLOC 0
 %define HAVE_WGLGETPROCADDRESS 0
 %define HAVE_BCRYPT 0
-%define HAVE_VAAPI_DRM 0
+%define HAVE_VAAPI_DRM 1
 %define HAVE_VAAPI_X11 0
 %define HAVE_VDPAU_X11 0
 %define HAVE_PTHREADS 1
@@ -332,7 +353,22 @@
 %define HAVE_XFORM_ASM 0
 %define HAVE_XMM_CLOBBERS 1
 %define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+%define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+%define HAVE_KCMVIDEOCODECTYPE_VP9 0
 %define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+%define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 %define HAVE_SOCKLEN_T 1
 %define HAVE_STRUCT_ADDRINFO 1
 %define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -346,9 +382,11 @@
 %define HAVE_STRUCT_SOCKADDR_SA_LEN 0
 %define HAVE_STRUCT_SOCKADDR_STORAGE 1
 %define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
-%define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 1
-%define HAVE_MAKEINFO 0
-%define HAVE_MAKEINFO_HTML 0
+%define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+%define HAVE_GZIP 1
+%define HAVE_LIBDRM_GETFB2 0
+%define HAVE_MAKEINFO 1
+%define HAVE_MAKEINFO_HTML 1
 %define HAVE_OPENCL_D3D11 0
 %define HAVE_OPENCL_DRM_ARM 0
 %define HAVE_OPENCL_DRM_BEIGNET 0
@@ -357,13 +395,15 @@
 %define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
 %define HAVE_PERL 1
 %define HAVE_POD2MAN 1
-%define HAVE_TEXI2HTML 1
+%define HAVE_TEXI2HTML 0
+%define HAVE_XMLLINT 1
+%define HAVE_ZLIB_GZIP 0
 %define CONFIG_DOC 0
 %define CONFIG_HTMLPAGES 1
 %define CONFIG_MANPAGES 1
 %define CONFIG_PODPAGES 1
 %define CONFIG_TXTPAGES 1
-%define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+%define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 %define CONFIG_AVIO_READING_EXAMPLE 1
 %define CONFIG_DECODE_AUDIO_EXAMPLE 1
 %define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -398,16 +438,13 @@
 %define CONFIG_LIBXAVS2 0
 %define CONFIG_LIBXVID 0
 %define CONFIG_DECKLINK 0
-%define CONFIG_LIBNDI_NEWTEK 0
 %define CONFIG_LIBFDK_AAC 0
-%define CONFIG_OPENSSL 0
 %define CONFIG_LIBTLS 0
 %define CONFIG_GMP 0
 %define CONFIG_LIBARIBB24 0
 %define CONFIG_LIBLENSFUN 0
 %define CONFIG_LIBOPENCORE_AMRNB 0
 %define CONFIG_LIBOPENCORE_AMRWB 0
-%define CONFIG_LIBVMAF 0
 %define CONFIG_LIBVO_AMRWBENC 0
 %define CONFIG_MBEDTLS 0
 %define CONFIG_RKMPP 0
@@ -417,6 +454,7 @@
 %define CONFIG_GNUTLS 0
 %define CONFIG_JNI 0
 %define CONFIG_LADSPA 0
+%define CONFIG_LCMS2 0
 %define CONFIG_LIBAOM 0
 %define CONFIG_LIBASS 0
 %define CONFIG_LIBBLURAY 0
@@ -431,11 +469,13 @@
 %define CONFIG_LIBFONTCONFIG 0
 %define CONFIG_LIBFREETYPE 0
 %define CONFIG_LIBFRIBIDI 0
+%define CONFIG_LIBGLSLANG 0
 %define CONFIG_LIBGME 0
 %define CONFIG_LIBGSM 0
 %define CONFIG_LIBIEC61883 0
 %define CONFIG_LIBILBC 0
 %define CONFIG_LIBJACK 0
+%define CONFIG_LIBJXL 0
 %define CONFIG_LIBKLVANC 0
 %define CONFIG_LIBKVAZAAR 0
 %define CONFIG_LIBMODPLUG 0
@@ -445,10 +485,16 @@
 %define CONFIG_LIBOPENH264 0
 %define CONFIG_LIBOPENJPEG 0
 %define CONFIG_LIBOPENMPT 0
+%define CONFIG_LIBOPENVINO 0
 %define CONFIG_LIBOPUS 0
+%define CONFIG_LIBPLACEBO 0
 %define CONFIG_LIBPULSE 0
+%define CONFIG_LIBRABBITMQ 0
+%define CONFIG_LIBRAV1E 0
+%define CONFIG_LIBRIST 0
 %define CONFIG_LIBRSVG 0
 %define CONFIG_LIBRTMP 0
+%define CONFIG_LIBSHADERC 0
 %define CONFIG_LIBSHINE 0
 %define CONFIG_LIBSMBCLIENT 0
 %define CONFIG_LIBSNAPPY 0
@@ -456,14 +502,16 @@
 %define CONFIG_LIBSPEEX 0
 %define CONFIG_LIBSRT 0
 %define CONFIG_LIBSSH 0
+%define CONFIG_LIBSVTAV1 0
 %define CONFIG_LIBTENSORFLOW 0
 %define CONFIG_LIBTESSERACT 0
 %define CONFIG_LIBTHEORA 0
 %define CONFIG_LIBTWOLAME 0
+%define CONFIG_LIBUAVS3D 0
 %define CONFIG_LIBV4L2 0
+%define CONFIG_LIBVMAF 0
 %define CONFIG_LIBVORBIS 0
 %define CONFIG_LIBVPX 0
-%define CONFIG_LIBWAVPACK 0
 %define CONFIG_LIBWEBP 0
 %define CONFIG_LIBXML2 0
 %define CONFIG_LIBZIMG 0
@@ -473,25 +521,28 @@
 %define CONFIG_MEDIACODEC 0
 %define CONFIG_OPENAL 0
 %define CONFIG_OPENGL 0
+%define CONFIG_OPENSSL 0
 %define CONFIG_POCKETSPHINX 0
 %define CONFIG_VAPOURSYNTH 0
 %define CONFIG_ALSA 0
-%define CONFIG_APPKIT 1
-%define CONFIG_AVFOUNDATION 1
-%define CONFIG_BZLIB 1
+%define CONFIG_APPKIT 0
+%define CONFIG_AVFOUNDATION 0
+%define CONFIG_BZLIB 0
 %define CONFIG_COREIMAGE 0
 %define CONFIG_ICONV 0
 %define CONFIG_LIBXCB 0
 %define CONFIG_LIBXCB_SHM 0
 %define CONFIG_LIBXCB_SHAPE 0
 %define CONFIG_LIBXCB_XFIXES 0
-%define CONFIG_LZMA 1
+%define CONFIG_LZMA 0
+%define CONFIG_MEDIAFOUNDATION 0
+%define CONFIG_METAL 0
 %define CONFIG_SCHANNEL 0
 %define CONFIG_SDL2 0
 %define CONFIG_SECURETRANSPORT 0
 %define CONFIG_SNDIO 0
-%define CONFIG_XLIB 1
-%define CONFIG_ZLIB 1
+%define CONFIG_XLIB 0
+%define CONFIG_ZLIB 0
 %define CONFIG_CUDA_NVCC 0
 %define CONFIG_CUDA_SDK 0
 %define CONFIG_LIBNPP 0
@@ -500,7 +551,7 @@
 %define CONFIG_OMX 0
 %define CONFIG_OPENCL 0
 %define CONFIG_AMF 0
-%define CONFIG_AUDIOTOOLBOX 1
+%define CONFIG_AUDIOTOOLBOX 0
 %define CONFIG_CRYSTALHD 0
 %define CONFIG_CUDA 0
 %define CONFIG_CUDA_LLVM 0
@@ -510,11 +561,11 @@
 %define CONFIG_FFNVCODEC 0
 %define CONFIG_NVDEC 0
 %define CONFIG_NVENC 0
-%define CONFIG_VAAPI 0
+%define CONFIG_VAAPI 1
 %define CONFIG_VDPAU 0
 %define CONFIG_VIDEOTOOLBOX 0
-%define CONFIG_V4L2_M2M 1
-%define CONFIG_XVMC 0
+%define CONFIG_VULKAN 0
+%define CONFIG_V4L2_M2M 0
 %define CONFIG_FTRAPV 0
 %define CONFIG_GRAY 0
 %define CONFIG_HARDCODED_TABLES 0
@@ -535,7 +586,6 @@
 %define CONFIG_AVFORMAT 0
 %define CONFIG_AVCODEC 1
 %define CONFIG_SWRESAMPLE 0
-%define CONFIG_AVRESAMPLE 0
 %define CONFIG_AVUTIL 1
 %define CONFIG_FFPLAY 0
 %define CONFIG_FFPROBE 0
@@ -547,27 +597,38 @@
 %define CONFIG_FAST_UNALIGNED 1
 %define CONFIG_FFT 1
 %define CONFIG_LSP 0
-%define CONFIG_LZO 0
 %define CONFIG_MDCT 0
 %define CONFIG_PIXELUTILS 0
 %define CONFIG_NETWORK 0
 %define CONFIG_RDFT 1
 %define CONFIG_AUTODETECT 0
 %define CONFIG_FONTCONFIG 0
+%define CONFIG_LARGE_TESTS 1
 %define CONFIG_LINUX_PERF 0
+%define CONFIG_MACOS_KPERF 0
 %define CONFIG_MEMORY_POISONING 0
 %define CONFIG_NEON_CLOBBER_TEST 0
 %define CONFIG_OSSFUZZ 0
 %define CONFIG_PIC 1
+%define CONFIG_PTX_COMPRESSION 0
 %define CONFIG_THUMB 0
 %define CONFIG_VALGRIND_BACKTRACE 0
 %define CONFIG_XMM_CLOBBER_TEST 0
-%define CONFIG_BSFS 1
+%define CONFIG_BSFS 0
 %define CONFIG_DECODERS 1
+%define CONFIG_ENCODERS 0
+%define CONFIG_HWACCELS 1
 %define CONFIG_PARSERS 1
+%define CONFIG_INDEVS 0
+%define CONFIG_OUTDEVS 0
+%define CONFIG_FILTERS 0
+%define CONFIG_DEMUXERS 0
+%define CONFIG_MUXERS 0
+%define CONFIG_PROTOCOLS 0
 %define CONFIG_AANDCTTABLES 0
 %define CONFIG_AC3DSP 0
 %define CONFIG_ADTS_HEADER 0
+%define CONFIG_ATSC_A53 0
 %define CONFIG_AUDIO_FRAME_QUEUE 0
 %define CONFIG_AUDIODSP 0
 %define CONFIG_BLOCKDSP 0
@@ -580,8 +641,10 @@
 %define CONFIG_CBS_JPEG 0
 %define CONFIG_CBS_MPEG2 0
 %define CONFIG_CBS_VP9 0
+%define CONFIG_DEFLATE_WRAPPER 0
 %define CONFIG_DIRAC_PARSE 0
 %define CONFIG_DNN 0
+%define CONFIG_DOVI_RPU 0
 %define CONFIG_DVPROFILE 0
 %define CONFIG_EXIF 0
 %define CONFIG_FAANDCT 1
@@ -607,6 +670,7 @@
 %define CONFIG_IDCTDSP 1
 %define CONFIG_IIRFILTER 0
 %define CONFIG_MDCT15 0
+%define CONFIG_INFLATE_WRAPPER 0
 %define CONFIG_INTRAX8 0
 %define CONFIG_ISO_MEDIA 0
 %define CONFIG_IVIDSP 0
@@ -623,7 +687,9 @@
 %define CONFIG_MPEGAUDIO 1
 %define CONFIG_MPEGAUDIODSP 1
 %define CONFIG_MPEGAUDIOHEADER 1
+%define CONFIG_MPEG4AUDIO 0
 %define CONFIG_MPEGVIDEO 0
+%define CONFIG_MPEGVIDEODEC 0
 %define CONFIG_MPEGVIDEOENC 0
 %define CONFIG_MSS34DSP 0
 %define CONFIG_PIXBLOCKDSP 0
@@ -646,7 +712,7 @@
 %define CONFIG_TEXTUREDSP 0
 %define CONFIG_TEXTUREDSPENC 0
 %define CONFIG_TPELDSP 0
-%define CONFIG_VAAPI_1 0
+%define CONFIG_VAAPI_1 1
 %define CONFIG_VAAPI_ENCODE 0
 %define CONFIG_VC1DSP 0
 %define CONFIG_VIDEODSP 1
@@ -655,13 +721,3 @@
 %define CONFIG_VP8DSP 1
 %define CONFIG_WMA_FREQS 0
 %define CONFIG_WMV2DSP 0
-%define CONFIG_NULL_BSF 1
-%define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-%define CONFIG_VP8_DECODER 1
-%define CONFIG_VP9_DECODER 1
-%define CONFIG_AV1_DECODER 1
-%define CONFIG_FLAC_DECODER 1
-%define CONFIG_MP3_DECODER 1
-%define CONFIG_VP8_PARSER 1
-%define CONFIG_VP9_PARSER 1
-%define CONFIG_AV1_PARSER 1
diff -Naur a/media/ffvpx/config_unix64.h b/media/ffvpx/config_unix64.h
--- a/media/ffvpx/config_unix64.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_unix64.h	2023-04-06 12:49:19.192546469 +0200
@@ -1,15 +1,16 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "--disable-everything --disable-protocols --disable-demuxers --disable-muxers --disable-filters --disable-programs --disable-doc --disable-parsers --enable-parser=vp8 --enable-parser=vp9 --enable-decoder=vp8 --enable-decoder=vp9 --disable-static --enable-shared --disable-debug --disable-sdl2 --disable-libxcb --disable-securetransport --disable-iconv --disable-swresample --disable-swscale --disable-avdevice --disable-avfilter --disable-avformat --disable-d3d11va --disable-dxva2 --disable-vaapi --disable-vdpau --disable-videotoolbox --enable-decoder=flac --enable-asm --enable-x86asm --disable-cuda --disable-cuvid --enable-decoder=mp3"
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='vp8,vp9,mp3,flac,av1' --enable-parser='vp8,vp9' --disable-static --enable-shared --disable-autodetect --disable-iconv --enable-vaapi --enable-hwaccel='vp9_vaapi,vp8_vaapi,av1_vaapi' --enable-libdav1d"
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
-#define CONFIG_THIS_YEAR 2019
+#define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "gcc 6.3.0 (Ubuntu 6.3.0-12ubuntu2) 20170406"
+#define CC_IDENT "gcc 11 (Ubuntu 11.2.0-19ubuntu1)"
+#define OS_NAME linux
 #define av_restrict restrict
 #define EXTERN_PREFIX ""
-#define EXTERN_ASM
+#define EXTERN_ASM 
 #define BUILDSUF ""
 #define SLIBSUF ".so"
 #define HAVE_MMX2 HAVE_MMXEXT
@@ -22,12 +23,16 @@
 #define ARCH_AVR32_UC 0
 #define ARCH_BFIN 0
 #define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
 #define ARCH_M68K 0
 #define ARCH_MIPS 0
 #define ARCH_MIPS64 0
 #define ARCH_PARISC 0
 #define ARCH_PPC 0
 #define ARCH_PPC64 0
+#define ARCH_RISCV 0
 #define ARCH_S390 0
 #define ARCH_SH4 0
 #define ARCH_SPARC 0
@@ -58,6 +63,7 @@
 #define HAVE_AVX 1
 #define HAVE_AVX2 1
 #define HAVE_AVX512 1
+#define HAVE_AVX512ICL 1
 #define HAVE_FMA3 1
 #define HAVE_FMA4 1
 #define HAVE_MMX 1
@@ -80,10 +86,11 @@
 #define HAVE_MIPSDSP 0
 #define HAVE_MIPSDSPR2 0
 #define HAVE_MSA 0
-#define HAVE_MSA2 0
 #define HAVE_LOONGSON2 0
 #define HAVE_LOONGSON3 0
 #define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
 #define HAVE_ARMV5TE_EXTERNAL 0
 #define HAVE_ARMV6_EXTERNAL 0
 #define HAVE_ARMV6T2_EXTERNAL 0
@@ -104,6 +111,7 @@
 #define HAVE_AVX_EXTERNAL 1
 #define HAVE_AVX2_EXTERNAL 1
 #define HAVE_AVX512_EXTERNAL 1
+#define HAVE_AVX512ICL_EXTERNAL 1
 #define HAVE_FMA3_EXTERNAL 1
 #define HAVE_FMA4_EXTERNAL 1
 #define HAVE_MMX_EXTERNAL 1
@@ -126,10 +134,11 @@
 #define HAVE_MIPSDSP_EXTERNAL 0
 #define HAVE_MIPSDSPR2_EXTERNAL 0
 #define HAVE_MSA_EXTERNAL 0
-#define HAVE_MSA2_EXTERNAL 0
 #define HAVE_LOONGSON2_EXTERNAL 0
 #define HAVE_LOONGSON3_EXTERNAL 0
 #define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 0
 #define HAVE_ARMV6_INLINE 0
 #define HAVE_ARMV6T2_INLINE 0
@@ -150,6 +159,7 @@
 #define HAVE_AVX_INLINE 1
 #define HAVE_AVX2_INLINE 1
 #define HAVE_AVX512_INLINE 1
+#define HAVE_AVX512ICL_INLINE 1
 #define HAVE_FMA3_INLINE 1
 #define HAVE_FMA4_INLINE 1
 #define HAVE_MMX_INLINE 1
@@ -172,10 +182,11 @@
 #define HAVE_MIPSDSP_INLINE 0
 #define HAVE_MIPSDSPR2_INLINE 0
 #define HAVE_MSA_INLINE 0
-#define HAVE_MSA2_INLINE 0
 #define HAVE_LOONGSON2_INLINE 0
 #define HAVE_LOONGSON3_INLINE 0
 #define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
 #define HAVE_ALIGNED_STACK 1
 #define HAVE_FAST_64BIT 1
 #define HAVE_FAST_CLZ 1
@@ -191,8 +202,8 @@
 #define HAVE_RDTSC 0
 #define HAVE_SEM_TIMEDWAIT 1
 #define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
-#define HAVE_CABS 1
-#define HAVE_CEXP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
 #define HAVE_INLINE_ASM 1
 #define HAVE_SYMVER 1
 #define HAVE_X86ASM 1
@@ -216,7 +227,8 @@
 #define HAVE_ES2_GL_H 0
 #define HAVE_GSM_H 0
 #define HAVE_IO_H 0
-#define HAVE_LINUX_PERF_EVENT_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
 #define HAVE_MACHINE_IOCTL_BT848_H 0
 #define HAVE_MACHINE_IOCTL_METEOR_H 0
 #define HAVE_OPENCV2_CORE_CORE_C_H 0
@@ -268,7 +280,7 @@
 #define HAVE_DOS_PATHS 0
 #define HAVE_LIBC_MSVCRT 0
 #define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
-#define HAVE_SECTION_DATA_REL_RO 0
+#define HAVE_SECTION_DATA_REL_RO 1
 #define HAVE_THREADS 1
 #define HAVE_UWP 0
 #define HAVE_WINRT 0
@@ -279,12 +291,16 @@
 #define HAVE_COMMANDLINETOARGVW 0
 #define HAVE_FCNTL 1
 #define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_GETENV 1
 #define HAVE_GETHRTIME 0
 #define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
 #define HAVE_GETPROCESSAFFINITYMASK 0
 #define HAVE_GETPROCESSMEMORYINFO 0
 #define HAVE_GETPROCESSTIMES 0
 #define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
 #define HAVE_GETSYSTEMTIMEASFILETIME 0
 #define HAVE_GETTIMEOFDAY 1
 #define HAVE_GLOB 1
@@ -307,6 +323,7 @@
 #define HAVE_SECITEMIMPORT 0
 #define HAVE_SETCONSOLETEXTATTRIBUTE 0
 #define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
 #define HAVE_SETMODE 0
 #define HAVE_SETRLIMIT 1
 #define HAVE_SLEEP 0
@@ -347,7 +364,22 @@
 #define HAVE_XFORM_ASM 0
 #define HAVE_XMM_CLOBBERS 1
 #define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
 #define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 #define HAVE_SOCKLEN_T 1
 #define HAVE_STRUCT_ADDRINFO 1
 #define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -361,9 +393,11 @@
 #define HAVE_STRUCT_SOCKADDR_SA_LEN 0
 #define HAVE_STRUCT_SOCKADDR_STORAGE 1
 #define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
-#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 1
-#define HAVE_MAKEINFO 0
-#define HAVE_MAKEINFO_HTML 0
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 1
+#define HAVE_MAKEINFO_HTML 1
 #define HAVE_OPENCL_D3D11 0
 #define HAVE_OPENCL_DRM_ARM 0
 #define HAVE_OPENCL_DRM_BEIGNET 0
@@ -372,13 +406,15 @@
 #define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
 #define HAVE_PERL 1
 #define HAVE_POD2MAN 1
-#define HAVE_TEXI2HTML 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
 #define CONFIG_DOC 0
 #define CONFIG_HTMLPAGES 1
 #define CONFIG_MANPAGES 1
 #define CONFIG_PODPAGES 1
 #define CONFIG_TXTPAGES 1
-#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 #define CONFIG_AVIO_READING_EXAMPLE 1
 #define CONFIG_DECODE_AUDIO_EXAMPLE 1
 #define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -414,14 +450,12 @@
 #define CONFIG_LIBXVID 0
 #define CONFIG_DECKLINK 0
 #define CONFIG_LIBFDK_AAC 0
-#define CONFIG_OPENSSL 0
 #define CONFIG_LIBTLS 0
 #define CONFIG_GMP 0
 #define CONFIG_LIBARIBB24 0
 #define CONFIG_LIBLENSFUN 0
 #define CONFIG_LIBOPENCORE_AMRNB 0
 #define CONFIG_LIBOPENCORE_AMRWB 0
-#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVO_AMRWBENC 0
 #define CONFIG_MBEDTLS 0
 #define CONFIG_RKMPP 0
@@ -431,6 +465,7 @@
 #define CONFIG_GNUTLS 0
 #define CONFIG_JNI 0
 #define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
 #define CONFIG_LIBAOM 0
 #define CONFIG_LIBASS 0
 #define CONFIG_LIBBLURAY 0
@@ -438,18 +473,20 @@
 #define CONFIG_LIBCACA 0
 #define CONFIG_LIBCELT 0
 #define CONFIG_LIBCODEC2 0
-#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDAV1D 1
 #define CONFIG_LIBDC1394 0
 #define CONFIG_LIBDRM 0
 #define CONFIG_LIBFLITE 0
 #define CONFIG_LIBFONTCONFIG 0
 #define CONFIG_LIBFREETYPE 0
 #define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
 #define CONFIG_LIBGME 0
 #define CONFIG_LIBGSM 0
 #define CONFIG_LIBIEC61883 0
 #define CONFIG_LIBILBC 0
 #define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
 #define CONFIG_LIBKLVANC 0
 #define CONFIG_LIBKVAZAAR 0
 #define CONFIG_LIBMODPLUG 0
@@ -459,10 +496,16 @@
 #define CONFIG_LIBOPENH264 0
 #define CONFIG_LIBOPENJPEG 0
 #define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
 #define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
 #define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
 #define CONFIG_LIBRSVG 0
 #define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
 #define CONFIG_LIBSHINE 0
 #define CONFIG_LIBSMBCLIENT 0
 #define CONFIG_LIBSNAPPY 0
@@ -470,14 +513,16 @@
 #define CONFIG_LIBSPEEX 0
 #define CONFIG_LIBSRT 0
 #define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
 #define CONFIG_LIBTENSORFLOW 0
 #define CONFIG_LIBTESSERACT 0
 #define CONFIG_LIBTHEORA 0
 #define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
 #define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVORBIS 0
 #define CONFIG_LIBVPX 0
-#define CONFIG_LIBWAVPACK 0
 #define CONFIG_LIBWEBP 0
 #define CONFIG_LIBXML2 0
 #define CONFIG_LIBZIMG 0
@@ -487,25 +532,28 @@
 #define CONFIG_MEDIACODEC 0
 #define CONFIG_OPENAL 0
 #define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
 #define CONFIG_POCKETSPHINX 0
 #define CONFIG_VAPOURSYNTH 0
 #define CONFIG_ALSA 0
-#define CONFIG_APPKIT 1
-#define CONFIG_AVFOUNDATION 1
-#define CONFIG_BZLIB 1
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
 #define CONFIG_COREIMAGE 0
 #define CONFIG_ICONV 0
 #define CONFIG_LIBXCB 0
 #define CONFIG_LIBXCB_SHM 0
 #define CONFIG_LIBXCB_SHAPE 0
 #define CONFIG_LIBXCB_XFIXES 0
-#define CONFIG_LZMA 1
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
 #define CONFIG_SCHANNEL 0
 #define CONFIG_SDL2 0
 #define CONFIG_SECURETRANSPORT 0
 #define CONFIG_SNDIO 0
-#define CONFIG_XLIB 1
-#define CONFIG_ZLIB 1
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
 #define CONFIG_CUDA_NVCC 0
 #define CONFIG_CUDA_SDK 0
 #define CONFIG_LIBNPP 0
@@ -514,7 +562,7 @@
 #define CONFIG_OMX 0
 #define CONFIG_OPENCL 0
 #define CONFIG_AMF 0
-#define CONFIG_AUDIOTOOLBOX 1
+#define CONFIG_AUDIOTOOLBOX 0
 #define CONFIG_CRYSTALHD 0
 #define CONFIG_CUDA 0
 #define CONFIG_CUDA_LLVM 0
@@ -524,11 +572,10 @@
 #define CONFIG_FFNVCODEC 0
 #define CONFIG_NVDEC 0
 #define CONFIG_NVENC 0
-#define CONFIG_VAAPI 0
 #define CONFIG_VDPAU 0
 #define CONFIG_VIDEOTOOLBOX 0
-#define CONFIG_V4L2_M2M 1
-#define CONFIG_XVMC 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
 #define CONFIG_FTRAPV 0
 #define CONFIG_GRAY 0
 #define CONFIG_HARDCODED_TABLES 0
@@ -549,7 +596,6 @@
 #define CONFIG_AVFORMAT 0
 #define CONFIG_AVCODEC 1
 #define CONFIG_SWRESAMPLE 0
-#define CONFIG_AVRESAMPLE 0
 #define CONFIG_AVUTIL 1
 #define CONFIG_FFPLAY 0
 #define CONFIG_FFPROBE 0
@@ -561,27 +607,38 @@
 #define CONFIG_FAST_UNALIGNED 1
 #define CONFIG_FFT 1
 #define CONFIG_LSP 0
-#define CONFIG_LZO 0
 #define CONFIG_MDCT 0
 #define CONFIG_PIXELUTILS 0
 #define CONFIG_NETWORK 0
 #define CONFIG_RDFT 1
 #define CONFIG_AUTODETECT 0
 #define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
 #define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
 #define CONFIG_MEMORY_POISONING 0
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
 #define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
-#define CONFIG_BSFS 1
+#define CONFIG_BSFS 0
 #define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 1
 #define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
 #define CONFIG_AANDCTTABLES 0
 #define CONFIG_AC3DSP 0
 #define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
 #define CONFIG_AUDIO_FRAME_QUEUE 0
 #define CONFIG_AUDIODSP 0
 #define CONFIG_BLOCKDSP 0
@@ -594,8 +651,10 @@
 #define CONFIG_CBS_JPEG 0
 #define CONFIG_CBS_MPEG2 0
 #define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
 #define CONFIG_DIRAC_PARSE 0
 #define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
 #define CONFIG_DVPROFILE 0
 #define CONFIG_EXIF 0
 #define CONFIG_FAANDCT 1
@@ -621,6 +680,7 @@
 #define CONFIG_IDCTDSP 1
 #define CONFIG_IIRFILTER 0
 #define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
 #define CONFIG_INTRAX8 0
 #define CONFIG_ISO_MEDIA 0
 #define CONFIG_IVIDSP 0
@@ -637,7 +697,9 @@
 #define CONFIG_MPEGAUDIO 1
 #define CONFIG_MPEGAUDIODSP 1
 #define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
 #define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
 #define CONFIG_MPEGVIDEOENC 0
 #define CONFIG_MSS34DSP 0
 #define CONFIG_PIXBLOCKDSP 0
@@ -660,7 +722,6 @@
 #define CONFIG_TEXTUREDSP 0
 #define CONFIG_TEXTUREDSPENC 0
 #define CONFIG_TPELDSP 0
-#define CONFIG_VAAPI_1 0
 #define CONFIG_VAAPI_ENCODE 0
 #define CONFIG_VC1DSP 0
 #define CONFIG_VIDEODSP 1
@@ -669,14 +730,4 @@
 #define CONFIG_VP8DSP 1
 #define CONFIG_WMA_FREQS 0
 #define CONFIG_WMV2DSP 0
-#define CONFIG_NULL_BSF 1
-#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-#define CONFIG_VP8_DECODER 1
-#define CONFIG_VP9_DECODER 1
-#define CONFIG_AV1_DECODER 1
-#define CONFIG_FLAC_DECODER 1
-#define CONFIG_MP3_DECODER 1
-#define CONFIG_VP8_PARSER 1
-#define CONFIG_VP9_PARSER 1
-#define CONFIG_AV1_PARSER 1
 #endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_unix_aarch64.h b/media/ffvpx/config_unix_aarch64.h
--- a/media/ffvpx/config_unix_aarch64.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_unix_aarch64.h	2023-04-06 12:49:19.192546469 +0200
@@ -0,0 +1,735 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='vp8,vp9,mp3,flac,av1' --enable-parser='vp8,vp9' --disable-static --enable-shared --disable-autodetect --disable-iconv --as=clang --cc=clang"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2022
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "Debian clang version 11.0.1-2"
+#define OS_NAME linux
+#define av_restrict restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define BUILDSUF ""
+#define SLIBSUF ".so"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 1
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_RISCV 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 1
+#define HAVE_NEON 1
+#define HAVE_VFP 1
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 1
+#define HAVE_NEON_EXTERNAL 1
+#define HAVE_VFP_EXTERNAL 1
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 1
+#define HAVE_NEON_INLINE 1
+#define HAVE_VFP_INLINE 1
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
+#define HAVE_ALIGNED_STACK 1
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 1
+#define HAVE_FAST_CMOV 0
+#define HAVE_LOCAL_ALIGNED 0
+#define HAVE_SIMD_ALIGN_16 1
+#define HAVE_SIMD_ALIGN_32 0
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 1
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 1
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 1
+#define HAVE_ARPA_INET_H 1
+#define HAVE_ASM_TYPES_H 1
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 1
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VALGRIND_VALGRIND_H 0
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 1
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 1
+#define HAVE_GETENV 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 1
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 1
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_PTHREAD_CANCEL 1
+#define HAVE_SCHED_GETAFFINITY 1
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 1
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 0
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 0
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 1
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
+#define HAVE_STRUCT_IP_MREQ_SOURCE 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 1
+#define HAVE_STRUCT_POLLFD 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 0
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 0
+#define HAVE_ZLIB_GZIP 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 1
+#define CONFIG_PODPAGES 1
+#define CONFIG_TXTPAGES 0
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 0
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 0
+#define CONFIG_METADATA_EXAMPLE 0
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 0
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 1
+#define CONFIG_SMALL 0
+#define CONFIG_STATIC 0
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 1
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 1
+#define CONFIG_MACOS_KPERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 0
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 1
+#define CONFIG_CBS_AV1 1
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
+#define CONFIG_DIRAC_PARSE 0
+#define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 0
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 1
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 0
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 1
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 0
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 0
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 1
+#define CONFIG_VP3DSP 0
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 1
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_win32.asm b/media/ffvpx/config_win32.asm
--- a/media/ffvpx/config_win32.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_win32.asm	2023-04-06 12:49:19.192546469 +0200
@@ -7,12 +7,16 @@
 %define ARCH_AVR32_UC 0
 %define ARCH_BFIN 0
 %define ARCH_IA64 0
+%define ARCH_LOONGARCH 0
+%define ARCH_LOONGARCH32 0
+%define ARCH_LOONGARCH64 0
 %define ARCH_M68K 0
 %define ARCH_MIPS 0
 %define ARCH_MIPS64 0
 %define ARCH_PARISC 0
 %define ARCH_PPC 0
 %define ARCH_PPC64 0
+%define ARCH_RISCV 0
 %define ARCH_S390 0
 %define ARCH_SH4 0
 %define ARCH_SPARC 0
@@ -43,6 +47,7 @@
 %define HAVE_AVX 1
 %define HAVE_AVX2 1
 %define HAVE_AVX512 1
+%define HAVE_AVX512ICL 1
 %define HAVE_FMA3 1
 %define HAVE_FMA4 1
 %define HAVE_MMX 1
@@ -65,10 +70,11 @@
 %define HAVE_MIPSDSP 0
 %define HAVE_MIPSDSPR2 0
 %define HAVE_MSA 0
-%define HAVE_MSA2 0
 %define HAVE_LOONGSON2 0
 %define HAVE_LOONGSON3 0
 %define HAVE_MMI 0
+%define HAVE_LSX 0
+%define HAVE_LASX 0
 %define HAVE_ARMV5TE_EXTERNAL 0
 %define HAVE_ARMV6_EXTERNAL 0
 %define HAVE_ARMV6T2_EXTERNAL 0
@@ -89,6 +95,7 @@
 %define HAVE_AVX_EXTERNAL 1
 %define HAVE_AVX2_EXTERNAL 1
 %define HAVE_AVX512_EXTERNAL 1
+%define HAVE_AVX512ICL_EXTERNAL 0
 %define HAVE_FMA3_EXTERNAL 1
 %define HAVE_FMA4_EXTERNAL 1
 %define HAVE_MMX_EXTERNAL 1
@@ -111,10 +118,11 @@
 %define HAVE_MIPSDSP_EXTERNAL 0
 %define HAVE_MIPSDSPR2_EXTERNAL 0
 %define HAVE_MSA_EXTERNAL 0
-%define HAVE_MSA2_EXTERNAL 0
 %define HAVE_LOONGSON2_EXTERNAL 0
 %define HAVE_LOONGSON3_EXTERNAL 0
 %define HAVE_MMI_EXTERNAL 0
+%define HAVE_LSX_EXTERNAL 0
+%define HAVE_LASX_EXTERNAL 0
 %define HAVE_ARMV5TE_INLINE 0
 %define HAVE_ARMV6_INLINE 0
 %define HAVE_ARMV6T2_INLINE 0
@@ -135,6 +143,7 @@
 %define HAVE_AVX_INLINE 0
 %define HAVE_AVX2_INLINE 0
 %define HAVE_AVX512_INLINE 0
+%define HAVE_AVX512ICL_INLINE 0
 %define HAVE_FMA3_INLINE 0
 %define HAVE_FMA4_INLINE 0
 %define HAVE_MMX_INLINE 0
@@ -157,13 +166,14 @@
 %define HAVE_MIPSDSP_INLINE 0
 %define HAVE_MIPSDSPR2_INLINE 0
 %define HAVE_MSA_INLINE 0
-%define HAVE_MSA2_INLINE 0
 %define HAVE_LOONGSON2_INLINE 0
 %define HAVE_LOONGSON3_INLINE 0
 %define HAVE_MMI_INLINE 0
+%define HAVE_LSX_INLINE 0
+%define HAVE_LASX_INLINE 0
 %define HAVE_ALIGNED_STACK 0
 %define HAVE_FAST_64BIT 0
-%define HAVE_FAST_CLZ 0
+%define HAVE_FAST_CLZ 1
 %define HAVE_FAST_CMOV 0
 %define HAVE_LOCAL_ALIGNED 1
 %define HAVE_SIMD_ALIGN_16 1
@@ -201,6 +211,7 @@
 %define HAVE_ES2_GL_H 0
 %define HAVE_GSM_H 0
 %define HAVE_IO_H 1
+%define HAVE_LINUX_DMA_BUF_H 0
 %define HAVE_LINUX_PERF_EVENT_H 0
 %define HAVE_MACHINE_IOCTL_BT848_H 0
 %define HAVE_MACHINE_IOCTL_METEOR_H 0
@@ -264,12 +275,16 @@
 %define HAVE_COMMANDLINETOARGVW 1
 %define HAVE_FCNTL 0
 %define HAVE_GETADDRINFO 1
+%define HAVE_GETAUXVAL 0
+%define HAVE_GETENV 1
 %define HAVE_GETHRTIME 0
 %define HAVE_GETOPT 0
+%define HAVE_GETMODULEHANDLE 1
 %define HAVE_GETPROCESSAFFINITYMASK 1
 %define HAVE_GETPROCESSMEMORYINFO 1
 %define HAVE_GETPROCESSTIMES 1
 %define HAVE_GETRUSAGE 0
+%define HAVE_GETSTDHANDLE 1
 %define HAVE_GETSYSTEMTIMEASFILETIME 1
 %define HAVE_GETTIMEOFDAY 0
 %define HAVE_GLOB 0
@@ -292,6 +307,7 @@
 %define HAVE_SECITEMIMPORT 0
 %define HAVE_SETCONSOLETEXTATTRIBUTE 1
 %define HAVE_SETCONSOLECTRLHANDLER 1
+%define HAVE_SETDLLDIRECTORY 1
 %define HAVE_SETMODE 1
 %define HAVE_SETRLIMIT 0
 %define HAVE_SLEEP 1
@@ -325,14 +341,29 @@
 %define HAVE_INLINE_ASM_LABELS 0
 %define HAVE_INLINE_ASM_NONLOCAL_LABELS 0
 %define HAVE_PRAGMA_DEPRECATED 1
-%define HAVE_RSYNC_CONTIMEOUT 1
+%define HAVE_RSYNC_CONTIMEOUT 0
 %define HAVE_SYMVER_ASM_LABEL 0
 %define HAVE_SYMVER_GNU_ASM 0
 %define HAVE_VFP_ARGS 0
 %define HAVE_XFORM_ASM 0
 %define HAVE_XMM_CLOBBERS 0
 %define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+%define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+%define HAVE_KCMVIDEOCODECTYPE_VP9 0
 %define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+%define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 %define HAVE_SOCKLEN_T 1
 %define HAVE_STRUCT_ADDRINFO 1
 %define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -347,7 +378,9 @@
 %define HAVE_STRUCT_SOCKADDR_STORAGE 1
 %define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
 %define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
-%define HAVE_MAKEINFO 1
+%define HAVE_GZIP 1
+%define HAVE_LIBDRM_GETFB2 0
+%define HAVE_MAKEINFO 0
 %define HAVE_MAKEINFO_HTML 0
 %define HAVE_OPENCL_D3D11 0
 %define HAVE_OPENCL_DRM_ARM 0
@@ -358,12 +391,14 @@
 %define HAVE_PERL 1
 %define HAVE_POD2MAN 1
 %define HAVE_TEXI2HTML 0
+%define HAVE_XMLLINT 1
+%define HAVE_ZLIB_GZIP 0
 %define CONFIG_DOC 0
 %define CONFIG_HTMLPAGES 0
 %define CONFIG_MANPAGES 1
 %define CONFIG_PODPAGES 1
-%define CONFIG_TXTPAGES 1
-%define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+%define CONFIG_TXTPAGES 0
+%define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 %define CONFIG_AVIO_READING_EXAMPLE 1
 %define CONFIG_DECODE_AUDIO_EXAMPLE 1
 %define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -399,14 +434,12 @@
 %define CONFIG_LIBXVID 0
 %define CONFIG_DECKLINK 0
 %define CONFIG_LIBFDK_AAC 0
-%define CONFIG_OPENSSL 0
 %define CONFIG_LIBTLS 0
 %define CONFIG_GMP 0
 %define CONFIG_LIBARIBB24 0
 %define CONFIG_LIBLENSFUN 0
 %define CONFIG_LIBOPENCORE_AMRNB 0
 %define CONFIG_LIBOPENCORE_AMRWB 0
-%define CONFIG_LIBVMAF 0
 %define CONFIG_LIBVO_AMRWBENC 0
 %define CONFIG_MBEDTLS 0
 %define CONFIG_RKMPP 0
@@ -416,6 +449,7 @@
 %define CONFIG_GNUTLS 0
 %define CONFIG_JNI 0
 %define CONFIG_LADSPA 0
+%define CONFIG_LCMS2 0
 %define CONFIG_LIBAOM 0
 %define CONFIG_LIBASS 0
 %define CONFIG_LIBBLURAY 0
@@ -430,11 +464,13 @@
 %define CONFIG_LIBFONTCONFIG 0
 %define CONFIG_LIBFREETYPE 0
 %define CONFIG_LIBFRIBIDI 0
+%define CONFIG_LIBGLSLANG 0
 %define CONFIG_LIBGME 0
 %define CONFIG_LIBGSM 0
 %define CONFIG_LIBIEC61883 0
 %define CONFIG_LIBILBC 0
 %define CONFIG_LIBJACK 0
+%define CONFIG_LIBJXL 0
 %define CONFIG_LIBKLVANC 0
 %define CONFIG_LIBKVAZAAR 0
 %define CONFIG_LIBMODPLUG 0
@@ -444,10 +480,16 @@
 %define CONFIG_LIBOPENH264 0
 %define CONFIG_LIBOPENJPEG 0
 %define CONFIG_LIBOPENMPT 0
+%define CONFIG_LIBOPENVINO 0
 %define CONFIG_LIBOPUS 0
+%define CONFIG_LIBPLACEBO 0
 %define CONFIG_LIBPULSE 0
+%define CONFIG_LIBRABBITMQ 0
+%define CONFIG_LIBRAV1E 0
+%define CONFIG_LIBRIST 0
 %define CONFIG_LIBRSVG 0
 %define CONFIG_LIBRTMP 0
+%define CONFIG_LIBSHADERC 0
 %define CONFIG_LIBSHINE 0
 %define CONFIG_LIBSMBCLIENT 0
 %define CONFIG_LIBSNAPPY 0
@@ -455,14 +497,16 @@
 %define CONFIG_LIBSPEEX 0
 %define CONFIG_LIBSRT 0
 %define CONFIG_LIBSSH 0
+%define CONFIG_LIBSVTAV1 0
 %define CONFIG_LIBTENSORFLOW 0
 %define CONFIG_LIBTESSERACT 0
 %define CONFIG_LIBTHEORA 0
 %define CONFIG_LIBTWOLAME 0
+%define CONFIG_LIBUAVS3D 0
 %define CONFIG_LIBV4L2 0
+%define CONFIG_LIBVMAF 0
 %define CONFIG_LIBVORBIS 0
 %define CONFIG_LIBVPX 0
-%define CONFIG_LIBWAVPACK 0
 %define CONFIG_LIBWEBP 0
 %define CONFIG_LIBXML2 0
 %define CONFIG_LIBZIMG 0
@@ -472,6 +516,7 @@
 %define CONFIG_MEDIACODEC 0
 %define CONFIG_OPENAL 0
 %define CONFIG_OPENGL 0
+%define CONFIG_OPENSSL 0
 %define CONFIG_POCKETSPHINX 0
 %define CONFIG_VAPOURSYNTH 0
 %define CONFIG_ALSA 0
@@ -485,7 +530,9 @@
 %define CONFIG_LIBXCB_SHAPE 0
 %define CONFIG_LIBXCB_XFIXES 0
 %define CONFIG_LZMA 0
-%define CONFIG_SCHANNEL 1
+%define CONFIG_MEDIAFOUNDATION 0
+%define CONFIG_METAL 0
+%define CONFIG_SCHANNEL 0
 %define CONFIG_SDL2 0
 %define CONFIG_SECURETRANSPORT 0
 %define CONFIG_SNDIO 0
@@ -512,8 +559,8 @@
 %define CONFIG_VAAPI 0
 %define CONFIG_VDPAU 0
 %define CONFIG_VIDEOTOOLBOX 0
+%define CONFIG_VULKAN 0
 %define CONFIG_V4L2_M2M 0
-%define CONFIG_XVMC 0
 %define CONFIG_FTRAPV 0
 %define CONFIG_GRAY 0
 %define CONFIG_HARDCODED_TABLES 0
@@ -534,7 +581,6 @@
 %define CONFIG_AVFORMAT 0
 %define CONFIG_AVCODEC 1
 %define CONFIG_SWRESAMPLE 0
-%define CONFIG_AVRESAMPLE 0
 %define CONFIG_AVUTIL 1
 %define CONFIG_FFPLAY 0
 %define CONFIG_FFPROBE 0
@@ -546,27 +592,38 @@
 %define CONFIG_FAST_UNALIGNED 1
 %define CONFIG_FFT 1
 %define CONFIG_LSP 0
-%define CONFIG_LZO 0
 %define CONFIG_MDCT 0
 %define CONFIG_PIXELUTILS 0
 %define CONFIG_NETWORK 0
 %define CONFIG_RDFT 1
 %define CONFIG_AUTODETECT 0
 %define CONFIG_FONTCONFIG 0
+%define CONFIG_LARGE_TESTS 1
 %define CONFIG_LINUX_PERF 0
+%define CONFIG_MACOS_KPERF 0
 %define CONFIG_MEMORY_POISONING 0
 %define CONFIG_NEON_CLOBBER_TEST 0
 %define CONFIG_OSSFUZZ 0
 %define CONFIG_PIC 0
+%define CONFIG_PTX_COMPRESSION 0
 %define CONFIG_THUMB 0
 %define CONFIG_VALGRIND_BACKTRACE 0
 %define CONFIG_XMM_CLOBBER_TEST 0
-%define CONFIG_BSFS 1
+%define CONFIG_BSFS 0
 %define CONFIG_DECODERS 1
+%define CONFIG_ENCODERS 0
+%define CONFIG_HWACCELS 0
 %define CONFIG_PARSERS 1
+%define CONFIG_INDEVS 0
+%define CONFIG_OUTDEVS 0
+%define CONFIG_FILTERS 0
+%define CONFIG_DEMUXERS 0
+%define CONFIG_MUXERS 0
+%define CONFIG_PROTOCOLS 0
 %define CONFIG_AANDCTTABLES 0
 %define CONFIG_AC3DSP 0
 %define CONFIG_ADTS_HEADER 0
+%define CONFIG_ATSC_A53 0
 %define CONFIG_AUDIO_FRAME_QUEUE 0
 %define CONFIG_AUDIODSP 0
 %define CONFIG_BLOCKDSP 0
@@ -579,8 +636,10 @@
 %define CONFIG_CBS_JPEG 0
 %define CONFIG_CBS_MPEG2 0
 %define CONFIG_CBS_VP9 0
+%define CONFIG_DEFLATE_WRAPPER 0
 %define CONFIG_DIRAC_PARSE 0
 %define CONFIG_DNN 0
+%define CONFIG_DOVI_RPU 0
 %define CONFIG_DVPROFILE 0
 %define CONFIG_EXIF 0
 %define CONFIG_FAANDCT 1
@@ -606,6 +665,7 @@
 %define CONFIG_IDCTDSP 1
 %define CONFIG_IIRFILTER 0
 %define CONFIG_MDCT15 0
+%define CONFIG_INFLATE_WRAPPER 0
 %define CONFIG_INTRAX8 0
 %define CONFIG_ISO_MEDIA 0
 %define CONFIG_IVIDSP 0
@@ -622,7 +682,9 @@
 %define CONFIG_MPEGAUDIO 1
 %define CONFIG_MPEGAUDIODSP 1
 %define CONFIG_MPEGAUDIOHEADER 1
+%define CONFIG_MPEG4AUDIO 0
 %define CONFIG_MPEGVIDEO 0
+%define CONFIG_MPEGVIDEODEC 0
 %define CONFIG_MPEGVIDEOENC 0
 %define CONFIG_MSS34DSP 0
 %define CONFIG_PIXBLOCKDSP 0
@@ -654,11 +716,3 @@
 %define CONFIG_VP8DSP 1
 %define CONFIG_WMA_FREQS 0
 %define CONFIG_WMV2DSP 0
-%define CONFIG_NULL_BSF 1
-%define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-%define CONFIG_VP8_DECODER 1
-%define CONFIG_VP9_DECODER 1
-%define CONFIG_FLAC_DECODER 1
-%define CONFIG_MP3_DECODER 1
-%define CONFIG_VP8_PARSER 1
-%define CONFIG_VP9_PARSER 1
diff -Naur a/media/ffvpx/config_win32.h b/media/ffvpx/config_win32.h
--- a/media/ffvpx/config_win32.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_win32.h	2023-04-06 12:49:19.192546469 +0200
@@ -1,13 +1,14 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "--disable-everything --disable-protocols --disable-demuxers --disable-muxers --disable-filters --disable-programs --disable-doc --disable-parsers --enable-parser=vp8 --enable-parser=vp9 --enable-decoder=vp8 --enable-decoder=vp9 --disable-static --enable-shared --disable-debug --disable-sdl2 --disable-libxcb --disable-securetransport --disable-iconv --disable-swresample --disable-swscale --disable-avdevice --disable-avfilter --disable-avformat --disable-d3d11va --disable-dxva2 --disable-vaapi --disable-vdpau --disable-videotoolbox --enable-decoder=flac --enable-asm --enable-x86asm --disable-cuda --disable-cuvid --enable-decoder=mp3 --toolchain=msvc"
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='vp8,vp9,mp3,flac' --enable-parser='vp8,vp9' --disable-static --enable-shared --disable-autodetect --toolchain=msvc"
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
-#define CONFIG_THIS_YEAR 2019
+#define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "Microsoft (R) C/C++ Optimizing Compiler Version 19.24.28315 for x86"
-#define av_restrict __restrict
+#define CC_IDENT "Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30133 for x86"
+#define OS_NAME win32
+#define av_restrict restrict
 #define EXTERN_PREFIX "_"
 #define EXTERN_ASM _
 #define BUILDSUF ""
@@ -22,12 +23,16 @@
 #define ARCH_AVR32_UC 0
 #define ARCH_BFIN 0
 #define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
 #define ARCH_M68K 0
 #define ARCH_MIPS 0
 #define ARCH_MIPS64 0
 #define ARCH_PARISC 0
 #define ARCH_PPC 0
 #define ARCH_PPC64 0
+#define ARCH_RISCV 0
 #define ARCH_S390 0
 #define ARCH_SH4 0
 #define ARCH_SPARC 0
@@ -58,6 +63,7 @@
 #define HAVE_AVX 1
 #define HAVE_AVX2 1
 #define HAVE_AVX512 1
+#define HAVE_AVX512ICL 1
 #define HAVE_FMA3 1
 #define HAVE_FMA4 1
 #define HAVE_MMX 1
@@ -80,10 +86,11 @@
 #define HAVE_MIPSDSP 0
 #define HAVE_MIPSDSPR2 0
 #define HAVE_MSA 0
-#define HAVE_MSA2 0
 #define HAVE_LOONGSON2 0
 #define HAVE_LOONGSON3 0
 #define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
 #define HAVE_ARMV5TE_EXTERNAL 0
 #define HAVE_ARMV6_EXTERNAL 0
 #define HAVE_ARMV6T2_EXTERNAL 0
@@ -104,6 +111,7 @@
 #define HAVE_AVX_EXTERNAL 1
 #define HAVE_AVX2_EXTERNAL 1
 #define HAVE_AVX512_EXTERNAL 1
+#define HAVE_AVX512ICL_EXTERNAL 0
 #define HAVE_FMA3_EXTERNAL 1
 #define HAVE_FMA4_EXTERNAL 1
 #define HAVE_MMX_EXTERNAL 1
@@ -126,10 +134,11 @@
 #define HAVE_MIPSDSP_EXTERNAL 0
 #define HAVE_MIPSDSPR2_EXTERNAL 0
 #define HAVE_MSA_EXTERNAL 0
-#define HAVE_MSA2_EXTERNAL 0
 #define HAVE_LOONGSON2_EXTERNAL 0
 #define HAVE_LOONGSON3_EXTERNAL 0
 #define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 0
 #define HAVE_ARMV6_INLINE 0
 #define HAVE_ARMV6T2_INLINE 0
@@ -150,6 +159,7 @@
 #define HAVE_AVX_INLINE 0
 #define HAVE_AVX2_INLINE 0
 #define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
 #define HAVE_FMA3_INLINE 0
 #define HAVE_FMA4_INLINE 0
 #define HAVE_MMX_INLINE 0
@@ -172,13 +182,14 @@
 #define HAVE_MIPSDSP_INLINE 0
 #define HAVE_MIPSDSPR2_INLINE 0
 #define HAVE_MSA_INLINE 0
-#define HAVE_MSA2_INLINE 0
 #define HAVE_LOONGSON2_INLINE 0
 #define HAVE_LOONGSON3_INLINE 0
 #define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
 #define HAVE_ALIGNED_STACK 0
 #define HAVE_FAST_64BIT 0
-#define HAVE_FAST_CLZ 0
+#define HAVE_FAST_CLZ 1
 #define HAVE_FAST_CMOV 0
 #define HAVE_LOCAL_ALIGNED 1
 #define HAVE_SIMD_ALIGN_16 1
@@ -216,6 +227,7 @@
 #define HAVE_ES2_GL_H 0
 #define HAVE_GSM_H 0
 #define HAVE_IO_H 1
+#define HAVE_LINUX_DMA_BUF_H 0
 #define HAVE_LINUX_PERF_EVENT_H 0
 #define HAVE_MACHINE_IOCTL_BT848_H 0
 #define HAVE_MACHINE_IOCTL_METEOR_H 0
@@ -279,12 +291,16 @@
 #define HAVE_COMMANDLINETOARGVW 1
 #define HAVE_FCNTL 0
 #define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 0
+#define HAVE_GETENV 1
 #define HAVE_GETHRTIME 0
 #define HAVE_GETOPT 0
+#define HAVE_GETMODULEHANDLE 1
 #define HAVE_GETPROCESSAFFINITYMASK 1
 #define HAVE_GETPROCESSMEMORYINFO 1
 #define HAVE_GETPROCESSTIMES 1
 #define HAVE_GETRUSAGE 0
+#define HAVE_GETSTDHANDLE 1
 #define HAVE_GETSYSTEMTIMEASFILETIME 1
 #define HAVE_GETTIMEOFDAY 0
 #define HAVE_GLOB 0
@@ -307,6 +323,7 @@
 #define HAVE_SECITEMIMPORT 0
 #define HAVE_SETCONSOLETEXTATTRIBUTE 1
 #define HAVE_SETCONSOLECTRLHANDLER 1
+#define HAVE_SETDLLDIRECTORY 1
 #define HAVE_SETMODE 1
 #define HAVE_SETRLIMIT 0
 #define HAVE_SLEEP 1
@@ -340,14 +357,29 @@
 #define HAVE_INLINE_ASM_LABELS 0
 #define HAVE_INLINE_ASM_NONLOCAL_LABELS 0
 #define HAVE_PRAGMA_DEPRECATED 1
-#define HAVE_RSYNC_CONTIMEOUT 1
+#define HAVE_RSYNC_CONTIMEOUT 0
 #define HAVE_SYMVER_ASM_LABEL 0
 #define HAVE_SYMVER_GNU_ASM 0
 #define HAVE_VFP_ARGS 0
 #define HAVE_XFORM_ASM 0
 #define HAVE_XMM_CLOBBERS 0
 #define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
 #define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 #define HAVE_SOCKLEN_T 1
 #define HAVE_STRUCT_ADDRINFO 1
 #define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -362,7 +394,9 @@
 #define HAVE_STRUCT_SOCKADDR_STORAGE 1
 #define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
 #define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
-#define HAVE_MAKEINFO 1
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 0
 #define HAVE_MAKEINFO_HTML 0
 #define HAVE_OPENCL_D3D11 0
 #define HAVE_OPENCL_DRM_ARM 0
@@ -373,12 +407,14 @@
 #define HAVE_PERL 1
 #define HAVE_POD2MAN 1
 #define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
 #define CONFIG_DOC 0
 #define CONFIG_HTMLPAGES 0
 #define CONFIG_MANPAGES 1
 #define CONFIG_PODPAGES 1
-#define CONFIG_TXTPAGES 1
-#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+#define CONFIG_TXTPAGES 0
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 #define CONFIG_AVIO_READING_EXAMPLE 1
 #define CONFIG_DECODE_AUDIO_EXAMPLE 1
 #define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -414,14 +450,12 @@
 #define CONFIG_LIBXVID 0
 #define CONFIG_DECKLINK 0
 #define CONFIG_LIBFDK_AAC 0
-#define CONFIG_OPENSSL 0
 #define CONFIG_LIBTLS 0
 #define CONFIG_GMP 0
 #define CONFIG_LIBARIBB24 0
 #define CONFIG_LIBLENSFUN 0
 #define CONFIG_LIBOPENCORE_AMRNB 0
 #define CONFIG_LIBOPENCORE_AMRWB 0
-#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVO_AMRWBENC 0
 #define CONFIG_MBEDTLS 0
 #define CONFIG_RKMPP 0
@@ -431,6 +465,7 @@
 #define CONFIG_GNUTLS 0
 #define CONFIG_JNI 0
 #define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
 #define CONFIG_LIBAOM 0
 #define CONFIG_LIBASS 0
 #define CONFIG_LIBBLURAY 0
@@ -445,11 +480,13 @@
 #define CONFIG_LIBFONTCONFIG 0
 #define CONFIG_LIBFREETYPE 0
 #define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
 #define CONFIG_LIBGME 0
 #define CONFIG_LIBGSM 0
 #define CONFIG_LIBIEC61883 0
 #define CONFIG_LIBILBC 0
 #define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
 #define CONFIG_LIBKLVANC 0
 #define CONFIG_LIBKVAZAAR 0
 #define CONFIG_LIBMODPLUG 0
@@ -459,10 +496,16 @@
 #define CONFIG_LIBOPENH264 0
 #define CONFIG_LIBOPENJPEG 0
 #define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
 #define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
 #define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
 #define CONFIG_LIBRSVG 0
 #define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
 #define CONFIG_LIBSHINE 0
 #define CONFIG_LIBSMBCLIENT 0
 #define CONFIG_LIBSNAPPY 0
@@ -470,14 +513,16 @@
 #define CONFIG_LIBSPEEX 0
 #define CONFIG_LIBSRT 0
 #define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
 #define CONFIG_LIBTENSORFLOW 0
 #define CONFIG_LIBTESSERACT 0
 #define CONFIG_LIBTHEORA 0
 #define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
 #define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVORBIS 0
 #define CONFIG_LIBVPX 0
-#define CONFIG_LIBWAVPACK 0
 #define CONFIG_LIBWEBP 0
 #define CONFIG_LIBXML2 0
 #define CONFIG_LIBZIMG 0
@@ -487,6 +532,7 @@
 #define CONFIG_MEDIACODEC 0
 #define CONFIG_OPENAL 0
 #define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
 #define CONFIG_POCKETSPHINX 0
 #define CONFIG_VAPOURSYNTH 0
 #define CONFIG_ALSA 0
@@ -500,7 +546,9 @@
 #define CONFIG_LIBXCB_SHAPE 0
 #define CONFIG_LIBXCB_XFIXES 0
 #define CONFIG_LZMA 0
-#define CONFIG_SCHANNEL 1
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
 #define CONFIG_SDL2 0
 #define CONFIG_SECURETRANSPORT 0
 #define CONFIG_SNDIO 0
@@ -527,8 +575,8 @@
 #define CONFIG_VAAPI 0
 #define CONFIG_VDPAU 0
 #define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
 #define CONFIG_V4L2_M2M 0
-#define CONFIG_XVMC 0
 #define CONFIG_FTRAPV 0
 #define CONFIG_GRAY 0
 #define CONFIG_HARDCODED_TABLES 0
@@ -549,7 +597,6 @@
 #define CONFIG_AVFORMAT 0
 #define CONFIG_AVCODEC 1
 #define CONFIG_SWRESAMPLE 0
-#define CONFIG_AVRESAMPLE 0
 #define CONFIG_AVUTIL 1
 #define CONFIG_FFPLAY 0
 #define CONFIG_FFPROBE 0
@@ -561,27 +608,38 @@
 #define CONFIG_FAST_UNALIGNED 1
 #define CONFIG_FFT 1
 #define CONFIG_LSP 0
-#define CONFIG_LZO 0
 #define CONFIG_MDCT 0
 #define CONFIG_PIXELUTILS 0
 #define CONFIG_NETWORK 0
 #define CONFIG_RDFT 1
 #define CONFIG_AUTODETECT 0
 #define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
 #define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
 #define CONFIG_MEMORY_POISONING 0
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 0
+#define CONFIG_PTX_COMPRESSION 0
 #define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
-#define CONFIG_BSFS 1
+#define CONFIG_BSFS 0
 #define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
 #define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
 #define CONFIG_AANDCTTABLES 0
 #define CONFIG_AC3DSP 0
 #define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
 #define CONFIG_AUDIO_FRAME_QUEUE 0
 #define CONFIG_AUDIODSP 0
 #define CONFIG_BLOCKDSP 0
@@ -594,8 +652,10 @@
 #define CONFIG_CBS_JPEG 0
 #define CONFIG_CBS_MPEG2 0
 #define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
 #define CONFIG_DIRAC_PARSE 0
 #define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
 #define CONFIG_DVPROFILE 0
 #define CONFIG_EXIF 0
 #define CONFIG_FAANDCT 1
@@ -621,6 +681,7 @@
 #define CONFIG_IDCTDSP 1
 #define CONFIG_IIRFILTER 0
 #define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
 #define CONFIG_INTRAX8 0
 #define CONFIG_ISO_MEDIA 0
 #define CONFIG_IVIDSP 0
@@ -637,7 +698,9 @@
 #define CONFIG_MPEGAUDIO 1
 #define CONFIG_MPEGAUDIODSP 1
 #define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
 #define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
 #define CONFIG_MPEGVIDEOENC 0
 #define CONFIG_MSS34DSP 0
 #define CONFIG_PIXBLOCKDSP 0
@@ -669,12 +732,4 @@
 #define CONFIG_VP8DSP 1
 #define CONFIG_WMA_FREQS 0
 #define CONFIG_WMV2DSP 0
-#define CONFIG_NULL_BSF 1
-#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-#define CONFIG_VP8_DECODER 1
-#define CONFIG_VP9_DECODER 1
-#define CONFIG_FLAC_DECODER 1
-#define CONFIG_MP3_DECODER 1
-#define CONFIG_VP8_PARSER 1
-#define CONFIG_VP9_PARSER 1
 #endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_win64_aarch64.h b/media/ffvpx/config_win64_aarch64.h
--- a/media/ffvpx/config_win64_aarch64.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/config_win64_aarch64.h	2023-04-06 12:49:19.192546469 +0200
@@ -0,0 +1,680 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-parser='vp8,vp9' --enable-decoder='vp8,vp9,mp3,flac' --disable-static --enable-shared --disable-autodetect --toolchain=msvc --enable-cross-compile --target-os=win32 --arch=arm64"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2019
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "Microsoft (R) C/C++ Optimizing Compiler Version 19.24.28315 for ARM64"
+#define av_restrict __restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define BUILDSUF ""
+#define SLIBSUF ".dll"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 1
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 1
+#define HAVE_NEON 1
+#define HAVE_VFP 1
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_MSA2 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 1
+#define HAVE_NEON_EXTERNAL 1
+#define HAVE_VFP_EXTERNAL 1
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_MSA2_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 0
+#define HAVE_NEON_INLINE 0
+#define HAVE_VFP_INLINE 0
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_MSA2_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_ALIGNED_STACK 1
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 0
+#define HAVE_FAST_CMOV 0
+#define HAVE_LOCAL_ALIGNED 0
+#define HAVE_SIMD_ALIGN_16 1
+#define HAVE_SIMD_ALIGN_32 0
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 1
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 0
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 0
+#define HAVE_CABS 0
+#define HAVE_CEXP 0
+#define HAVE_INLINE_ASM 0
+#define HAVE_SYMVER 0
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 1
+#define HAVE_ARPA_INET_H 0
+#define HAVE_ASM_TYPES_H 0
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 1
+#define HAVE_DIRENT_H 0
+#define HAVE_DXGIDEBUG_H 1
+#define HAVE_DXVA_H 1
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 1
+#define HAVE_LINUX_PERF_EVENT_H 0
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 0
+#define HAVE_SYS_PARAM_H 0
+#define HAVE_SYS_RESOURCE_H 0
+#define HAVE_SYS_SELECT_H 0
+#define HAVE_SYS_SOUNDCARD_H 0
+#define HAVE_SYS_TIME_H 0
+#define HAVE_SYS_UN_H 0
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 0
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 0
+#define HAVE_VALGRIND_VALGRIND_H 0
+#define HAVE_WINDOWS_H 1
+#define HAVE_WINSOCK2_H 1
+#define HAVE_INTRINSICS_NEON 1
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 1
+#define HAVE_LIBC_MSVCRT 1
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 0
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 1
+#define HAVE_CLOCK_GETTIME 0
+#define HAVE_CLOSESOCKET 1
+#define HAVE_COMMANDLINETOARGVW 1
+#define HAVE_FCNTL 0
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 0
+#define HAVE_GETPROCESSAFFINITYMASK 1
+#define HAVE_GETPROCESSMEMORYINFO 1
+#define HAVE_GETPROCESSTIMES 1
+#define HAVE_GETRUSAGE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 1
+#define HAVE_GETTIMEOFDAY 0
+#define HAVE_GLOB 0
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 0
+#define HAVE_INET_ATON 0
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 1
+#define HAVE_LSTAT 0
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 1
+#define HAVE_MKSTEMP 0
+#define HAVE_MMAP 0
+#define HAVE_MPROTECT 0
+#define HAVE_NANOSLEEP 0
+#define HAVE_PEEKNAMEDPIPE 1
+#define HAVE_PTHREAD_CANCEL 0
+#define HAVE_SCHED_GETAFFINITY 0
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 1
+#define HAVE_SETCONSOLECTRLHANDLER 1
+#define HAVE_SETMODE 1
+#define HAVE_SETRLIMIT 0
+#define HAVE_SLEEP 1
+#define HAVE_STRERROR_R 0
+#define HAVE_SYSCONF 0
+#define HAVE_SYSCTL 0
+#define HAVE_USLEEP 0
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 1
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 1
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 0
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 1
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 1
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 0
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 0
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 0
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 1
+#define HAVE_SYMVER_ASM_LABEL 0
+#define HAVE_SYMVER_GNU_ASM 0
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 1
+#define HAVE_STRUCT_IP_MREQ_SOURCE 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 0
+#define HAVE_STRUCT_POLLFD 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 0
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_MAKEINFO 0
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 1
+#define CONFIG_PODPAGES 1
+#define CONFIG_TXTPAGES 0
+#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+#define CONFIG_AVIO_READING_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUXING_DECODING_EXAMPLE 0
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 0
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_AUDIO_EXAMPLE 0
+#define CONFIG_FILTERING_VIDEO_EXAMPLE 0
+#define CONFIG_HTTP_MULTICLIENT_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 0
+#define CONFIG_METADATA_EXAMPLE 0
+#define CONFIG_MUXING_EXAMPLE 0
+#define CONFIG_QSVDEC_EXAMPLE 0
+#define CONFIG_REMUXING_EXAMPLE 0
+#define CONFIG_RESAMPLING_AUDIO_EXAMPLE 0
+#define CONFIG_SCALING_VIDEO_EXAMPLE 0
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODING_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWAVPACK 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_XVMC 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 1
+#define CONFIG_SMALL 0
+#define CONFIG_STATIC 0
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 1
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_LZO 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LINUX_PERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_PARSERS 1
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 0
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 0
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DIRAC_PARSE 0
+#define CONFIG_DNN 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 1
+#define CONFIG_FAANIDCT 1
+#define CONFIG_FDCTDSP 1
+#define CONFIG_FLACDSP 1
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 0
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 0
+#define CONFIG_H264DSP 0
+#define CONFIG_H264PARSE 0
+#define CONFIG_H264PRED 1
+#define CONFIG_H264QPEL 0
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HPELDSP 0
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 1
+#define CONFIG_IIRFILTER 0
+#define CONFIG_MDCT15 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 0
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 0
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 0
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 0
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 1
+#define CONFIG_VP3DSP 0
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 1
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#define CONFIG_NULL_BSF 1
+#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP9_DECODER 1
+#define CONFIG_FLAC_DECODER 1
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_VP8_PARSER 1
+#define CONFIG_VP9_PARSER 1
+#endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/config_win64.asm b/media/ffvpx/config_win64.asm
--- a/media/ffvpx/config_win64.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_win64.asm	2023-04-06 12:49:19.192546469 +0200
@@ -7,12 +7,16 @@
 %define ARCH_AVR32_UC 0
 %define ARCH_BFIN 0
 %define ARCH_IA64 0
+%define ARCH_LOONGARCH 0
+%define ARCH_LOONGARCH32 0
+%define ARCH_LOONGARCH64 0
 %define ARCH_M68K 0
 %define ARCH_MIPS 0
 %define ARCH_MIPS64 0
 %define ARCH_PARISC 0
 %define ARCH_PPC 0
 %define ARCH_PPC64 0
+%define ARCH_RISCV 0
 %define ARCH_S390 0
 %define ARCH_SH4 0
 %define ARCH_SPARC 0
@@ -43,6 +47,7 @@
 %define HAVE_AVX 1
 %define HAVE_AVX2 1
 %define HAVE_AVX512 1
+%define HAVE_AVX512ICL 1
 %define HAVE_FMA3 1
 %define HAVE_FMA4 1
 %define HAVE_MMX 1
@@ -65,10 +70,11 @@
 %define HAVE_MIPSDSP 0
 %define HAVE_MIPSDSPR2 0
 %define HAVE_MSA 0
-%define HAVE_MSA2 0
 %define HAVE_LOONGSON2 0
 %define HAVE_LOONGSON3 0
 %define HAVE_MMI 0
+%define HAVE_LSX 0
+%define HAVE_LASX 0
 %define HAVE_ARMV5TE_EXTERNAL 0
 %define HAVE_ARMV6_EXTERNAL 0
 %define HAVE_ARMV6T2_EXTERNAL 0
@@ -89,6 +95,7 @@
 %define HAVE_AVX_EXTERNAL 1
 %define HAVE_AVX2_EXTERNAL 1
 %define HAVE_AVX512_EXTERNAL 1
+%define HAVE_AVX512ICL_EXTERNAL 1
 %define HAVE_FMA3_EXTERNAL 1
 %define HAVE_FMA4_EXTERNAL 1
 %define HAVE_MMX_EXTERNAL 1
@@ -111,10 +118,11 @@
 %define HAVE_MIPSDSP_EXTERNAL 0
 %define HAVE_MIPSDSPR2_EXTERNAL 0
 %define HAVE_MSA_EXTERNAL 0
-%define HAVE_MSA2_EXTERNAL 0
 %define HAVE_LOONGSON2_EXTERNAL 0
 %define HAVE_LOONGSON3_EXTERNAL 0
 %define HAVE_MMI_EXTERNAL 0
+%define HAVE_LSX_EXTERNAL 0
+%define HAVE_LASX_EXTERNAL 0
 %define HAVE_ARMV5TE_INLINE 0
 %define HAVE_ARMV6_INLINE 0
 %define HAVE_ARMV6T2_INLINE 0
@@ -135,6 +143,7 @@
 %define HAVE_AVX_INLINE 0
 %define HAVE_AVX2_INLINE 0
 %define HAVE_AVX512_INLINE 0
+%define HAVE_AVX512ICL_INLINE 0
 %define HAVE_FMA3_INLINE 0
 %define HAVE_FMA4_INLINE 0
 %define HAVE_MMX_INLINE 0
@@ -157,10 +166,11 @@
 %define HAVE_MIPSDSP_INLINE 0
 %define HAVE_MIPSDSPR2_INLINE 0
 %define HAVE_MSA_INLINE 0
-%define HAVE_MSA2_INLINE 0
 %define HAVE_LOONGSON2_INLINE 0
 %define HAVE_LOONGSON3_INLINE 0
 %define HAVE_MMI_INLINE 0
+%define HAVE_LSX_INLINE 0
+%define HAVE_LASX_INLINE 0
 %define HAVE_ALIGNED_STACK 1
 %define HAVE_FAST_64BIT 1
 %define HAVE_FAST_CLZ 1
@@ -201,6 +211,7 @@
 %define HAVE_ES2_GL_H 0
 %define HAVE_GSM_H 0
 %define HAVE_IO_H 1
+%define HAVE_LINUX_DMA_BUF_H 0
 %define HAVE_LINUX_PERF_EVENT_H 0
 %define HAVE_MACHINE_IOCTL_BT848_H 0
 %define HAVE_MACHINE_IOCTL_METEOR_H 0
@@ -264,12 +275,16 @@
 %define HAVE_COMMANDLINETOARGVW 1
 %define HAVE_FCNTL 0
 %define HAVE_GETADDRINFO 1
+%define HAVE_GETAUXVAL 0
+%define HAVE_GETENV 1
 %define HAVE_GETHRTIME 0
 %define HAVE_GETOPT 0
+%define HAVE_GETMODULEHANDLE 1
 %define HAVE_GETPROCESSAFFINITYMASK 1
 %define HAVE_GETPROCESSMEMORYINFO 1
 %define HAVE_GETPROCESSTIMES 1
 %define HAVE_GETRUSAGE 0
+%define HAVE_GETSTDHANDLE 1
 %define HAVE_GETSYSTEMTIMEASFILETIME 1
 %define HAVE_GETTIMEOFDAY 0
 %define HAVE_GLOB 0
@@ -292,6 +307,7 @@
 %define HAVE_SECITEMIMPORT 0
 %define HAVE_SETCONSOLETEXTATTRIBUTE 1
 %define HAVE_SETCONSOLECTRLHANDLER 1
+%define HAVE_SETDLLDIRECTORY 1
 %define HAVE_SETMODE 1
 %define HAVE_SETRLIMIT 0
 %define HAVE_SLEEP 1
@@ -325,14 +341,29 @@
 %define HAVE_INLINE_ASM_LABELS 0
 %define HAVE_INLINE_ASM_NONLOCAL_LABELS 0
 %define HAVE_PRAGMA_DEPRECATED 1
-%define HAVE_RSYNC_CONTIMEOUT 1
+%define HAVE_RSYNC_CONTIMEOUT 0
 %define HAVE_SYMVER_ASM_LABEL 0
 %define HAVE_SYMVER_GNU_ASM 0
 %define HAVE_VFP_ARGS 0
 %define HAVE_XFORM_ASM 0
 %define HAVE_XMM_CLOBBERS 0
 %define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+%define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+%define HAVE_KCMVIDEOCODECTYPE_VP9 0
 %define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+%define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+%define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+%define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 %define HAVE_SOCKLEN_T 1
 %define HAVE_STRUCT_ADDRINFO 1
 %define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -347,7 +378,9 @@
 %define HAVE_STRUCT_SOCKADDR_STORAGE 1
 %define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
 %define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
-%define HAVE_MAKEINFO 1
+%define HAVE_GZIP 1
+%define HAVE_LIBDRM_GETFB2 0
+%define HAVE_MAKEINFO 0
 %define HAVE_MAKEINFO_HTML 0
 %define HAVE_OPENCL_D3D11 0
 %define HAVE_OPENCL_DRM_ARM 0
@@ -358,12 +391,14 @@
 %define HAVE_PERL 1
 %define HAVE_POD2MAN 1
 %define HAVE_TEXI2HTML 0
+%define HAVE_XMLLINT 1
+%define HAVE_ZLIB_GZIP 0
 %define CONFIG_DOC 0
 %define CONFIG_HTMLPAGES 0
 %define CONFIG_MANPAGES 1
 %define CONFIG_PODPAGES 1
-%define CONFIG_TXTPAGES 1
-%define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+%define CONFIG_TXTPAGES 0
+%define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 %define CONFIG_AVIO_READING_EXAMPLE 1
 %define CONFIG_DECODE_AUDIO_EXAMPLE 1
 %define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -399,14 +434,12 @@
 %define CONFIG_LIBXVID 0
 %define CONFIG_DECKLINK 0
 %define CONFIG_LIBFDK_AAC 0
-%define CONFIG_OPENSSL 0
 %define CONFIG_LIBTLS 0
 %define CONFIG_GMP 0
 %define CONFIG_LIBARIBB24 0
 %define CONFIG_LIBLENSFUN 0
 %define CONFIG_LIBOPENCORE_AMRNB 0
 %define CONFIG_LIBOPENCORE_AMRWB 0
-%define CONFIG_LIBVMAF 0
 %define CONFIG_LIBVO_AMRWBENC 0
 %define CONFIG_MBEDTLS 0
 %define CONFIG_RKMPP 0
@@ -416,6 +449,7 @@
 %define CONFIG_GNUTLS 0
 %define CONFIG_JNI 0
 %define CONFIG_LADSPA 0
+%define CONFIG_LCMS2 0
 %define CONFIG_LIBAOM 0
 %define CONFIG_LIBASS 0
 %define CONFIG_LIBBLURAY 0
@@ -430,11 +464,13 @@
 %define CONFIG_LIBFONTCONFIG 0
 %define CONFIG_LIBFREETYPE 0
 %define CONFIG_LIBFRIBIDI 0
+%define CONFIG_LIBGLSLANG 0
 %define CONFIG_LIBGME 0
 %define CONFIG_LIBGSM 0
 %define CONFIG_LIBIEC61883 0
 %define CONFIG_LIBILBC 0
 %define CONFIG_LIBJACK 0
+%define CONFIG_LIBJXL 0
 %define CONFIG_LIBKLVANC 0
 %define CONFIG_LIBKVAZAAR 0
 %define CONFIG_LIBMODPLUG 0
@@ -444,10 +480,16 @@
 %define CONFIG_LIBOPENH264 0
 %define CONFIG_LIBOPENJPEG 0
 %define CONFIG_LIBOPENMPT 0
+%define CONFIG_LIBOPENVINO 0
 %define CONFIG_LIBOPUS 0
+%define CONFIG_LIBPLACEBO 0
 %define CONFIG_LIBPULSE 0
+%define CONFIG_LIBRABBITMQ 0
+%define CONFIG_LIBRAV1E 0
+%define CONFIG_LIBRIST 0
 %define CONFIG_LIBRSVG 0
 %define CONFIG_LIBRTMP 0
+%define CONFIG_LIBSHADERC 0
 %define CONFIG_LIBSHINE 0
 %define CONFIG_LIBSMBCLIENT 0
 %define CONFIG_LIBSNAPPY 0
@@ -455,14 +497,16 @@
 %define CONFIG_LIBSPEEX 0
 %define CONFIG_LIBSRT 0
 %define CONFIG_LIBSSH 0
+%define CONFIG_LIBSVTAV1 0
 %define CONFIG_LIBTENSORFLOW 0
 %define CONFIG_LIBTESSERACT 0
 %define CONFIG_LIBTHEORA 0
 %define CONFIG_LIBTWOLAME 0
+%define CONFIG_LIBUAVS3D 0
 %define CONFIG_LIBV4L2 0
+%define CONFIG_LIBVMAF 0
 %define CONFIG_LIBVORBIS 0
 %define CONFIG_LIBVPX 0
-%define CONFIG_LIBWAVPACK 0
 %define CONFIG_LIBWEBP 0
 %define CONFIG_LIBXML2 0
 %define CONFIG_LIBZIMG 0
@@ -472,6 +516,7 @@
 %define CONFIG_MEDIACODEC 0
 %define CONFIG_OPENAL 0
 %define CONFIG_OPENGL 0
+%define CONFIG_OPENSSL 0
 %define CONFIG_POCKETSPHINX 0
 %define CONFIG_VAPOURSYNTH 0
 %define CONFIG_ALSA 0
@@ -485,7 +530,9 @@
 %define CONFIG_LIBXCB_SHAPE 0
 %define CONFIG_LIBXCB_XFIXES 0
 %define CONFIG_LZMA 0
-%define CONFIG_SCHANNEL 1
+%define CONFIG_MEDIAFOUNDATION 0
+%define CONFIG_METAL 0
+%define CONFIG_SCHANNEL 0
 %define CONFIG_SDL2 0
 %define CONFIG_SECURETRANSPORT 0
 %define CONFIG_SNDIO 0
@@ -512,8 +559,8 @@
 %define CONFIG_VAAPI 0
 %define CONFIG_VDPAU 0
 %define CONFIG_VIDEOTOOLBOX 0
+%define CONFIG_VULKAN 0
 %define CONFIG_V4L2_M2M 0
-%define CONFIG_XVMC 0
 %define CONFIG_FTRAPV 0
 %define CONFIG_GRAY 0
 %define CONFIG_HARDCODED_TABLES 0
@@ -534,7 +581,6 @@
 %define CONFIG_AVFORMAT 0
 %define CONFIG_AVCODEC 1
 %define CONFIG_SWRESAMPLE 0
-%define CONFIG_AVRESAMPLE 0
 %define CONFIG_AVUTIL 1
 %define CONFIG_FFPLAY 0
 %define CONFIG_FFPROBE 0
@@ -546,27 +592,38 @@
 %define CONFIG_FAST_UNALIGNED 1
 %define CONFIG_FFT 1
 %define CONFIG_LSP 0
-%define CONFIG_LZO 0
 %define CONFIG_MDCT 0
 %define CONFIG_PIXELUTILS 0
 %define CONFIG_NETWORK 0
 %define CONFIG_RDFT 1
 %define CONFIG_AUTODETECT 0
 %define CONFIG_FONTCONFIG 0
+%define CONFIG_LARGE_TESTS 1
 %define CONFIG_LINUX_PERF 0
+%define CONFIG_MACOS_KPERF 0
 %define CONFIG_MEMORY_POISONING 0
 %define CONFIG_NEON_CLOBBER_TEST 0
 %define CONFIG_OSSFUZZ 0
 %define CONFIG_PIC 1
+%define CONFIG_PTX_COMPRESSION 0
 %define CONFIG_THUMB 0
 %define CONFIG_VALGRIND_BACKTRACE 0
 %define CONFIG_XMM_CLOBBER_TEST 0
-%define CONFIG_BSFS 1
+%define CONFIG_BSFS 0
 %define CONFIG_DECODERS 1
+%define CONFIG_ENCODERS 0
+%define CONFIG_HWACCELS 0
 %define CONFIG_PARSERS 1
+%define CONFIG_INDEVS 0
+%define CONFIG_OUTDEVS 0
+%define CONFIG_FILTERS 0
+%define CONFIG_DEMUXERS 0
+%define CONFIG_MUXERS 0
+%define CONFIG_PROTOCOLS 0
 %define CONFIG_AANDCTTABLES 0
 %define CONFIG_AC3DSP 0
 %define CONFIG_ADTS_HEADER 0
+%define CONFIG_ATSC_A53 0
 %define CONFIG_AUDIO_FRAME_QUEUE 0
 %define CONFIG_AUDIODSP 0
 %define CONFIG_BLOCKDSP 0
@@ -579,8 +636,10 @@
 %define CONFIG_CBS_JPEG 0
 %define CONFIG_CBS_MPEG2 0
 %define CONFIG_CBS_VP9 0
+%define CONFIG_DEFLATE_WRAPPER 0
 %define CONFIG_DIRAC_PARSE 0
 %define CONFIG_DNN 0
+%define CONFIG_DOVI_RPU 0
 %define CONFIG_DVPROFILE 0
 %define CONFIG_EXIF 0
 %define CONFIG_FAANDCT 1
@@ -606,6 +665,7 @@
 %define CONFIG_IDCTDSP 1
 %define CONFIG_IIRFILTER 0
 %define CONFIG_MDCT15 0
+%define CONFIG_INFLATE_WRAPPER 0
 %define CONFIG_INTRAX8 0
 %define CONFIG_ISO_MEDIA 0
 %define CONFIG_IVIDSP 0
@@ -622,7 +682,9 @@
 %define CONFIG_MPEGAUDIO 1
 %define CONFIG_MPEGAUDIODSP 1
 %define CONFIG_MPEGAUDIOHEADER 1
+%define CONFIG_MPEG4AUDIO 0
 %define CONFIG_MPEGVIDEO 0
+%define CONFIG_MPEGVIDEODEC 0
 %define CONFIG_MPEGVIDEOENC 0
 %define CONFIG_MSS34DSP 0
 %define CONFIG_PIXBLOCKDSP 0
@@ -654,11 +716,3 @@
 %define CONFIG_VP8DSP 1
 %define CONFIG_WMA_FREQS 0
 %define CONFIG_WMV2DSP 0
-%define CONFIG_NULL_BSF 1
-%define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-%define CONFIG_VP8_DECODER 1
-%define CONFIG_VP9_DECODER 1
-%define CONFIG_FLAC_DECODER 1
-%define CONFIG_MP3_DECODER 1
-%define CONFIG_VP8_PARSER 1
-%define CONFIG_VP9_PARSER 1
\ No newline at end of file
diff -Naur a/media/ffvpx/config_win64.h b/media/ffvpx/config_win64.h
--- a/media/ffvpx/config_win64.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/config_win64.h	2023-04-06 12:49:19.192546469 +0200
@@ -1,13 +1,14 @@
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "--disable-everything --disable-protocols --disable-demuxers --disable-muxers --disable-filters --disable-programs --disable-doc --disable-parsers --enable-parser=vp8 --enable-parser=vp9 --enable-decoder=vp8 --enable-decoder=vp9 --disable-static --enable-shared --disable-debug --disable-sdl2 --disable-libxcb --disable-securetransport --disable-iconv --disable-swresample --disable-swscale --disable-avdevice --disable-avfilter --disable-avformat --disable-d3d11va --disable-dxva2 --disable-vaapi --disable-vdpau --disable-videotoolbox --enable-decoder=flac --enable-asm --enable-x86asm --disable-cuda --disable-cuvid --enable-decoder=mp3 --toolchain=msvc"
+#define FFMPEG_CONFIGURATION "--disable-all --enable-avcodec --enable-decoder='vp8,vp9,mp3,flac' --enable-parser='vp8,vp9' --disable-static --enable-shared --disable-autodetect --enable-w32threads --toolchain=msvc"
 #define FFMPEG_LICENSE "LGPL version 2.1 or later"
-#define CONFIG_THIS_YEAR 2019
+#define CONFIG_THIS_YEAR 2022
 #define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
 #define AVCONV_DATADIR "/usr/local/share/ffmpeg"
-#define CC_IDENT "Microsoft (R) C/C++ Optimizing Compiler Version 19.24.28315 for x64"
-#define av_restrict __restrict
+#define CC_IDENT "Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30133 for x64"
+#define OS_NAME win32
+#define av_restrict restrict
 #define EXTERN_PREFIX ""
 #define EXTERN_ASM 
 #define BUILDSUF ""
@@ -22,12 +23,16 @@
 #define ARCH_AVR32_UC 0
 #define ARCH_BFIN 0
 #define ARCH_IA64 0
+#define ARCH_LOONGARCH 0
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 0
 #define ARCH_M68K 0
 #define ARCH_MIPS 0
 #define ARCH_MIPS64 0
 #define ARCH_PARISC 0
 #define ARCH_PPC 0
 #define ARCH_PPC64 0
+#define ARCH_RISCV 0
 #define ARCH_S390 0
 #define ARCH_SH4 0
 #define ARCH_SPARC 0
@@ -58,6 +63,7 @@
 #define HAVE_AVX 1
 #define HAVE_AVX2 1
 #define HAVE_AVX512 1
+#define HAVE_AVX512ICL 1
 #define HAVE_FMA3 1
 #define HAVE_FMA4 1
 #define HAVE_MMX 1
@@ -80,10 +86,11 @@
 #define HAVE_MIPSDSP 0
 #define HAVE_MIPSDSPR2 0
 #define HAVE_MSA 0
-#define HAVE_MSA2 0
 #define HAVE_LOONGSON2 0
 #define HAVE_LOONGSON3 0
 #define HAVE_MMI 0
+#define HAVE_LSX 0
+#define HAVE_LASX 0
 #define HAVE_ARMV5TE_EXTERNAL 0
 #define HAVE_ARMV6_EXTERNAL 0
 #define HAVE_ARMV6T2_EXTERNAL 0
@@ -104,6 +111,7 @@
 #define HAVE_AVX_EXTERNAL 1
 #define HAVE_AVX2_EXTERNAL 1
 #define HAVE_AVX512_EXTERNAL 1
+#define HAVE_AVX512ICL_EXTERNAL 1
 #define HAVE_FMA3_EXTERNAL 1
 #define HAVE_FMA4_EXTERNAL 1
 #define HAVE_MMX_EXTERNAL 1
@@ -126,10 +134,11 @@
 #define HAVE_MIPSDSP_EXTERNAL 0
 #define HAVE_MIPSDSPR2_EXTERNAL 0
 #define HAVE_MSA_EXTERNAL 0
-#define HAVE_MSA2_EXTERNAL 0
 #define HAVE_LOONGSON2_EXTERNAL 0
 #define HAVE_LOONGSON3_EXTERNAL 0
 #define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 0
 #define HAVE_ARMV6_INLINE 0
 #define HAVE_ARMV6T2_INLINE 0
@@ -150,6 +159,7 @@
 #define HAVE_AVX_INLINE 0
 #define HAVE_AVX2_INLINE 0
 #define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
 #define HAVE_FMA3_INLINE 0
 #define HAVE_FMA4_INLINE 0
 #define HAVE_MMX_INLINE 0
@@ -172,13 +182,14 @@
 #define HAVE_MIPSDSP_INLINE 0
 #define HAVE_MIPSDSPR2_INLINE 0
 #define HAVE_MSA_INLINE 0
-#define HAVE_MSA2_INLINE 0
 #define HAVE_LOONGSON2_INLINE 0
 #define HAVE_LOONGSON3_INLINE 0
 #define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
 #define HAVE_ALIGNED_STACK 1
 #define HAVE_FAST_64BIT 1
-#define HAVE_FAST_CLZ 0
+#define HAVE_FAST_CLZ 1
 #define HAVE_FAST_CMOV 1
 #define HAVE_LOCAL_ALIGNED 1
 #define HAVE_SIMD_ALIGN_16 1
@@ -216,6 +227,7 @@
 #define HAVE_ES2_GL_H 0
 #define HAVE_GSM_H 0
 #define HAVE_IO_H 1
+#define HAVE_LINUX_DMA_BUF_H 0
 #define HAVE_LINUX_PERF_EVENT_H 0
 #define HAVE_MACHINE_IOCTL_BT848_H 0
 #define HAVE_MACHINE_IOCTL_METEOR_H 0
@@ -279,12 +291,16 @@
 #define HAVE_COMMANDLINETOARGVW 1
 #define HAVE_FCNTL 0
 #define HAVE_GETADDRINFO 1
+#define HAVE_GETAUXVAL 0
+#define HAVE_GETENV 1
 #define HAVE_GETHRTIME 0
 #define HAVE_GETOPT 0
+#define HAVE_GETMODULEHANDLE 1
 #define HAVE_GETPROCESSAFFINITYMASK 1
 #define HAVE_GETPROCESSMEMORYINFO 1
 #define HAVE_GETPROCESSTIMES 1
 #define HAVE_GETRUSAGE 0
+#define HAVE_GETSTDHANDLE 1
 #define HAVE_GETSYSTEMTIMEASFILETIME 1
 #define HAVE_GETTIMEOFDAY 0
 #define HAVE_GLOB 0
@@ -307,6 +323,7 @@
 #define HAVE_SECITEMIMPORT 0
 #define HAVE_SETCONSOLETEXTATTRIBUTE 1
 #define HAVE_SETCONSOLECTRLHANDLER 1
+#define HAVE_SETDLLDIRECTORY 1
 #define HAVE_SETMODE 1
 #define HAVE_SETRLIMIT 0
 #define HAVE_SLEEP 1
@@ -340,14 +357,29 @@
 #define HAVE_INLINE_ASM_LABELS 0
 #define HAVE_INLINE_ASM_NONLOCAL_LABELS 0
 #define HAVE_PRAGMA_DEPRECATED 1
-#define HAVE_RSYNC_CONTIMEOUT 1
+#define HAVE_RSYNC_CONTIMEOUT 0
 #define HAVE_SYMVER_ASM_LABEL 0
 #define HAVE_SYMVER_GNU_ASM 0
 #define HAVE_VFP_ARGS 0
 #define HAVE_XFORM_ASM 0
 #define HAVE_XMM_CLOBBERS 0
 #define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
 #define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
 #define HAVE_SOCKLEN_T 1
 #define HAVE_STRUCT_ADDRINFO 1
 #define HAVE_STRUCT_GROUP_SOURCE_REQ 1
@@ -362,7 +394,9 @@
 #define HAVE_STRUCT_SOCKADDR_STORAGE 1
 #define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 0
 #define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
-#define HAVE_MAKEINFO 1
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 0
 #define HAVE_MAKEINFO_HTML 0
 #define HAVE_OPENCL_D3D11 0
 #define HAVE_OPENCL_DRM_ARM 0
@@ -373,12 +407,14 @@
 #define HAVE_PERL 1
 #define HAVE_POD2MAN 1
 #define HAVE_TEXI2HTML 0
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
 #define CONFIG_DOC 0
 #define CONFIG_HTMLPAGES 0
 #define CONFIG_MANPAGES 1
 #define CONFIG_PODPAGES 1
-#define CONFIG_TXTPAGES 1
-#define CONFIG_AVIO_DIR_CMD_EXAMPLE 1
+#define CONFIG_TXTPAGES 0
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
 #define CONFIG_AVIO_READING_EXAMPLE 1
 #define CONFIG_DECODE_AUDIO_EXAMPLE 1
 #define CONFIG_DECODE_VIDEO_EXAMPLE 1
@@ -414,14 +450,12 @@
 #define CONFIG_LIBXVID 0
 #define CONFIG_DECKLINK 0
 #define CONFIG_LIBFDK_AAC 0
-#define CONFIG_OPENSSL 0
 #define CONFIG_LIBTLS 0
 #define CONFIG_GMP 0
 #define CONFIG_LIBARIBB24 0
 #define CONFIG_LIBLENSFUN 0
 #define CONFIG_LIBOPENCORE_AMRNB 0
 #define CONFIG_LIBOPENCORE_AMRWB 0
-#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVO_AMRWBENC 0
 #define CONFIG_MBEDTLS 0
 #define CONFIG_RKMPP 0
@@ -431,6 +465,7 @@
 #define CONFIG_GNUTLS 0
 #define CONFIG_JNI 0
 #define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
 #define CONFIG_LIBAOM 0
 #define CONFIG_LIBASS 0
 #define CONFIG_LIBBLURAY 0
@@ -445,11 +480,13 @@
 #define CONFIG_LIBFONTCONFIG 0
 #define CONFIG_LIBFREETYPE 0
 #define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
 #define CONFIG_LIBGME 0
 #define CONFIG_LIBGSM 0
 #define CONFIG_LIBIEC61883 0
 #define CONFIG_LIBILBC 0
 #define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
 #define CONFIG_LIBKLVANC 0
 #define CONFIG_LIBKVAZAAR 0
 #define CONFIG_LIBMODPLUG 0
@@ -459,10 +496,16 @@
 #define CONFIG_LIBOPENH264 0
 #define CONFIG_LIBOPENJPEG 0
 #define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
 #define CONFIG_LIBOPUS 0
+#define CONFIG_LIBPLACEBO 0
 #define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
 #define CONFIG_LIBRSVG 0
 #define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
 #define CONFIG_LIBSHINE 0
 #define CONFIG_LIBSMBCLIENT 0
 #define CONFIG_LIBSNAPPY 0
@@ -470,14 +513,16 @@
 #define CONFIG_LIBSPEEX 0
 #define CONFIG_LIBSRT 0
 #define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
 #define CONFIG_LIBTENSORFLOW 0
 #define CONFIG_LIBTESSERACT 0
 #define CONFIG_LIBTHEORA 0
 #define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
 #define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
 #define CONFIG_LIBVORBIS 0
 #define CONFIG_LIBVPX 0
-#define CONFIG_LIBWAVPACK 0
 #define CONFIG_LIBWEBP 0
 #define CONFIG_LIBXML2 0
 #define CONFIG_LIBZIMG 0
@@ -487,6 +532,7 @@
 #define CONFIG_MEDIACODEC 0
 #define CONFIG_OPENAL 0
 #define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
 #define CONFIG_POCKETSPHINX 0
 #define CONFIG_VAPOURSYNTH 0
 #define CONFIG_ALSA 0
@@ -500,7 +546,9 @@
 #define CONFIG_LIBXCB_SHAPE 0
 #define CONFIG_LIBXCB_XFIXES 0
 #define CONFIG_LZMA 0
-#define CONFIG_SCHANNEL 1
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
 #define CONFIG_SDL2 0
 #define CONFIG_SECURETRANSPORT 0
 #define CONFIG_SNDIO 0
@@ -527,8 +575,8 @@
 #define CONFIG_VAAPI 0
 #define CONFIG_VDPAU 0
 #define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
 #define CONFIG_V4L2_M2M 0
-#define CONFIG_XVMC 0
 #define CONFIG_FTRAPV 0
 #define CONFIG_GRAY 0
 #define CONFIG_HARDCODED_TABLES 0
@@ -549,7 +597,6 @@
 #define CONFIG_AVFORMAT 0
 #define CONFIG_AVCODEC 1
 #define CONFIG_SWRESAMPLE 0
-#define CONFIG_AVRESAMPLE 0
 #define CONFIG_AVUTIL 1
 #define CONFIG_FFPLAY 0
 #define CONFIG_FFPROBE 0
@@ -561,27 +608,38 @@
 #define CONFIG_FAST_UNALIGNED 1
 #define CONFIG_FFT 1
 #define CONFIG_LSP 0
-#define CONFIG_LZO 0
 #define CONFIG_MDCT 0
 #define CONFIG_PIXELUTILS 0
 #define CONFIG_NETWORK 0
 #define CONFIG_RDFT 1
 #define CONFIG_AUTODETECT 0
 #define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
 #define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
 #define CONFIG_MEMORY_POISONING 0
 #define CONFIG_NEON_CLOBBER_TEST 0
 #define CONFIG_OSSFUZZ 0
 #define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
 #define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
-#define CONFIG_BSFS 1
+#define CONFIG_BSFS 0
 #define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
 #define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 0
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
 #define CONFIG_AANDCTTABLES 0
 #define CONFIG_AC3DSP 0
 #define CONFIG_ADTS_HEADER 0
+#define CONFIG_ATSC_A53 0
 #define CONFIG_AUDIO_FRAME_QUEUE 0
 #define CONFIG_AUDIODSP 0
 #define CONFIG_BLOCKDSP 0
@@ -594,8 +652,10 @@
 #define CONFIG_CBS_JPEG 0
 #define CONFIG_CBS_MPEG2 0
 #define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
 #define CONFIG_DIRAC_PARSE 0
 #define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
 #define CONFIG_DVPROFILE 0
 #define CONFIG_EXIF 0
 #define CONFIG_FAANDCT 1
@@ -621,6 +681,7 @@
 #define CONFIG_IDCTDSP 1
 #define CONFIG_IIRFILTER 0
 #define CONFIG_MDCT15 0
+#define CONFIG_INFLATE_WRAPPER 0
 #define CONFIG_INTRAX8 0
 #define CONFIG_ISO_MEDIA 0
 #define CONFIG_IVIDSP 0
@@ -637,7 +698,9 @@
 #define CONFIG_MPEGAUDIO 1
 #define CONFIG_MPEGAUDIODSP 1
 #define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 0
 #define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
 #define CONFIG_MPEGVIDEOENC 0
 #define CONFIG_MSS34DSP 0
 #define CONFIG_PIXBLOCKDSP 0
@@ -669,12 +732,4 @@
 #define CONFIG_VP8DSP 1
 #define CONFIG_WMA_FREQS 0
 #define CONFIG_WMV2DSP 0
-#define CONFIG_NULL_BSF 1
-#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 1
-#define CONFIG_VP8_DECODER 1
-#define CONFIG_VP9_DECODER 1
-#define CONFIG_FLAC_DECODER 1
-#define CONFIG_MP3_DECODER 1
-#define CONFIG_VP8_PARSER 1
-#define CONFIG_VP9_PARSER 1
 #endif /* FFMPEG_CONFIG_H */
diff -Naur a/media/ffvpx/defaults_disabled.asm b/media/ffvpx/defaults_disabled.asm
--- a/media/ffvpx/defaults_disabled.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/defaults_disabled.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,1836 +0,0 @@
-%define CONFIG_A64MULTI5_ENCODER 0
-%define CONFIG_A64MULTI_ENCODER 0
-%define CONFIG_A64_MUXER 0
-%define CONFIG_AAC_ADTSTOASC_BSF 0
-%define CONFIG_AAC_AT_DECODER 0
-%define CONFIG_AAC_AT_ENCODER 0
-%define CONFIG_AAC_DECODER 0
-%define CONFIG_AAC_DEMUXER 0
-%define CONFIG_AAC_ENCODER 0
-%define CONFIG_AAC_FIXED_DECODER 0
-%define CONFIG_AAC_LATM_DECODER 0
-%define CONFIG_AAC_LATM_PARSER 0
-%define CONFIG_AAC_PARSER 0
-%define CONFIG_AA_DEMUXER 0
-%define CONFIG_AASC_DECODER 0
-%define CONFIG_ABENCH_FILTER 0
-%define CONFIG_ABITSCOPE_FILTER 0
-%define CONFIG_AC3_AT_DECODER 0
-%define CONFIG_AC3_DECODER 0
-%define CONFIG_AC3_DEMUXER 0
-%define CONFIG_AC3_ENCODER 0
-%define CONFIG_AC3_FIXED_DECODER 0
-%define CONFIG_AC3_FIXED_ENCODER 0
-%define CONFIG_AC3_MUXER 0
-%define CONFIG_AC3_PARSER 0
-%define CONFIG_ACM_DEMUXER 0
-%define CONFIG_ACOMPRESSOR_FILTER 0
-%define CONFIG_ACONTRAST_FILTER 0
-%define CONFIG_ACOPY_FILTER 0
-%define CONFIG_ACROSSFADE_FILTER 0
-%define CONFIG_ACROSSOVER_FILTER 0
-%define CONFIG_ACRUSHER_FILTER 0
-%define CONFIG_ACT_DEMUXER 0
-%define CONFIG_ACUE_FILTER 0
-%define CONFIG_ADECLICK_FILTER 0
-%define CONFIG_ADECLIP_FILTER 0
-%define CONFIG_ADELAY_FILTER 0
-%define CONFIG_ADERIVATIVE_FILTER 0
-%define CONFIG_ADF_DEMUXER 0
-%define CONFIG_ADPCM_4XM_DECODER 0
-%define CONFIG_ADPCM_ADX_DECODER 0
-%define CONFIG_ADPCM_ADX_ENCODER 0
-%define CONFIG_ADPCM_AFC_DECODER 0
-%define CONFIG_ADPCM_AGM_DECODER 0
-%define CONFIG_ADPCM_AICA_DECODER 0
-%define CONFIG_ADPCM_CT_DECODER 0
-%define CONFIG_ADPCM_DTK_DECODER 0
-%define CONFIG_ADPCM_EA_DECODER 0
-%define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 0
-%define CONFIG_ADPCM_EA_R1_DECODER 0
-%define CONFIG_ADPCM_EA_R2_DECODER 0
-%define CONFIG_ADPCM_EA_R3_DECODER 0
-%define CONFIG_ADPCM_EA_XAS_DECODER 0
-%define CONFIG_ADPCM_G722_DECODER 0
-%define CONFIG_ADPCM_G722_ENCODER 0
-%define CONFIG_ADPCM_G726_DECODER 0
-%define CONFIG_ADPCM_G726_ENCODER 0
-%define CONFIG_ADPCM_G726LE_DECODER 0
-%define CONFIG_ADPCM_G726LE_ENCODER 0
-%define CONFIG_ADPCM_IMA_AMV_DECODER 0
-%define CONFIG_ADPCM_IMA_APC_DECODER 0
-%define CONFIG_ADPCM_IMA_DAT4_DECODER 0
-%define CONFIG_ADPCM_IMA_DK3_DECODER 0
-%define CONFIG_ADPCM_IMA_DK4_DECODER 0
-%define CONFIG_ADPCM_IMA_EA_EACS_DECODER 0
-%define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 0
-%define CONFIG_ADPCM_IMA_ISS_DECODER 0
-%define CONFIG_ADPCM_IMA_OKI_DECODER 0
-%define CONFIG_ADPCM_IMA_QT_AT_DECODER 0
-%define CONFIG_ADPCM_IMA_QT_DECODER 0
-%define CONFIG_ADPCM_IMA_QT_ENCODER 0
-%define CONFIG_ADPCM_IMA_RAD_DECODER 0
-%define CONFIG_ADPCM_IMA_SMJPEG_DECODER 0
-%define CONFIG_ADPCM_IMA_WAV_DECODER 0
-%define CONFIG_ADPCM_IMA_WAV_ENCODER 0
-%define CONFIG_ADPCM_IMA_WS_DECODER 0
-%define CONFIG_ADPCM_MS_DECODER 0
-%define CONFIG_ADPCM_MS_ENCODER 0
-%define CONFIG_ADPCM_MTAF_DECODER 0
-%define CONFIG_ADPCM_PSX_DECODER 0
-%define CONFIG_ADPCM_SBPRO_2_DECODER 0
-%define CONFIG_ADPCM_SBPRO_3_DECODER 0
-%define CONFIG_ADPCM_SBPRO_4_DECODER 0
-%define CONFIG_ADPCM_SWF_DECODER 0
-%define CONFIG_ADPCM_SWF_ENCODER 0
-%define CONFIG_ADPCM_THP_DECODER 0
-%define CONFIG_ADPCM_THP_LE_DECODER 0
-%define CONFIG_ADPCM_VIMA_DECODER 0
-%define CONFIG_ADPCM_XA_DECODER 0
-%define CONFIG_ADPCM_YAMAHA_DECODER 0
-%define CONFIG_ADPCM_YAMAHA_ENCODER 0
-%define CONFIG_ADP_DEMUXER 0
-%define CONFIG_ADRAWGRAPH_FILTER 0
-%define CONFIG_ADS_DEMUXER 0
-%define CONFIG_ADTS_MUXER 0
-%define CONFIG_ADX_DEMUXER 0
-%define CONFIG_ADX_MUXER 0
-%define CONFIG_ADX_PARSER 0
-%define CONFIG_AEA_DEMUXER 0
-%define CONFIG_AECHO_FILTER 0
-%define CONFIG_AEMPHASIS_FILTER 0
-%define CONFIG_AEVAL_FILTER 0
-%define CONFIG_AEVALSRC_FILTER 0
-%define CONFIG_AFADE_FILTER 0
-%define CONFIG_AFC_DEMUXER 0
-%define CONFIG_AFFTDN_FILTER 0
-%define CONFIG_AFFTFILT_FILTER 0
-%define CONFIG_AFIFO_FILTER 0
-%define CONFIG_AFIR_FILTER 0
-%define CONFIG_AFORMAT_FILTER 0
-%define CONFIG_AGATE_FILTER 0
-%define CONFIG_AGM_DECODER 0
-%define CONFIG_AGRAPHMONITOR_FILTER 0
-%define CONFIG_AHISTOGRAM_FILTER 0
-%define CONFIG_AIC_DECODER 0
-%define CONFIG_AIFF_DEMUXER 0
-%define CONFIG_AIFF_MUXER 0
-%define CONFIG_AIIR_FILTER 0
-%define CONFIG_AINTEGRAL_FILTER 0
-%define CONFIG_AINTERLEAVE_FILTER 0
-%define CONFIG_AIX_DEMUXER 0
-%define CONFIG_ALAC_AT_DECODER 0
-%define CONFIG_ALAC_AT_ENCODER 0
-%define CONFIG_ALAC_DECODER 0
-%define CONFIG_ALAC_ENCODER 0
-%define CONFIG_ALIAS_PIX_DECODER 0
-%define CONFIG_ALIAS_PIX_ENCODER 0
-%define CONFIG_ALIMITER_FILTER 0
-%define CONFIG_ALLPASS_FILTER 0
-%define CONFIG_ALLRGB_FILTER 0
-%define CONFIG_ALLYUV_FILTER 0
-%define CONFIG_ALOOP_FILTER 0
-%define CONFIG_ALPHAEXTRACT_FILTER 0
-%define CONFIG_ALPHAMERGE_FILTER 0
-%define CONFIG_ALSA_INDEV 0
-%define CONFIG_ALSA_OUTDEV 0
-%define CONFIG_ALS_DECODER 0
-%define CONFIG_AMERGE_FILTER 0
-%define CONFIG_AMETADATA_FILTER 0
-%define CONFIG_AMIX_FILTER 0
-%define CONFIG_AMOVIE_FILTER 0
-%define CONFIG_AMPLIFY_FILTER 0
-%define CONFIG_AMR_DEMUXER 0
-%define CONFIG_AMR_MUXER 0
-%define CONFIG_AMR_NB_AT_DECODER 0
-%define CONFIG_AMRNB_DECODER 0
-%define CONFIG_AMRNB_DEMUXER 0
-%define CONFIG_AMRWB_DECODER 0
-%define CONFIG_AMRWB_DEMUXER 0
-%define CONFIG_AMULTIPLY_FILTER 0
-%define CONFIG_AMV_DECODER 0
-%define CONFIG_AMV_ENCODER 0
-%define CONFIG_ANDROID_CAMERA_INDEV 0
-%define CONFIG_ANEQUALIZER_FILTER 0
-%define CONFIG_ANLMDN_FILTER 0
-%define CONFIG_ANM_DECODER 0
-%define CONFIG_ANM_DEMUXER 0
-%define CONFIG_ANOISESRC_FILTER 0
-%define CONFIG_ANSI_DECODER 0
-%define CONFIG_ANULL_FILTER 0
-%define CONFIG_ANULLSINK_FILTER 0
-%define CONFIG_ANULLSRC_FILTER 0
-%define CONFIG_APAD_FILTER 0
-%define CONFIG_APC_DEMUXER 0
-%define CONFIG_APE_DECODER 0
-%define CONFIG_APE_DEMUXER 0
-%define CONFIG_APERMS_FILTER 0
-%define CONFIG_APHASEMETER_FILTER 0
-%define CONFIG_APHASER_FILTER 0
-%define CONFIG_APNG_DECODER 0
-%define CONFIG_APNG_DEMUXER 0
-%define CONFIG_APNG_ENCODER 0
-%define CONFIG_APNG_MUXER 0
-%define CONFIG_APTX_DECODER 0
-%define CONFIG_APTX_DEMUXER 0
-%define CONFIG_APTX_ENCODER 0
-%define CONFIG_APTX_HD_DECODER 0
-%define CONFIG_APTX_HD_DEMUXER 0
-%define CONFIG_APTX_HD_ENCODER 0
-%define CONFIG_APTX_HD_MUXER 0
-%define CONFIG_APTX_MUXER 0
-%define CONFIG_APULSATOR_FILTER 0
-%define CONFIG_AQTITLE_DEMUXER 0
-%define CONFIG_ARBC_DECODER 0
-%define CONFIG_AREALTIME_FILTER 0
-%define CONFIG_ARESAMPLE_FILTER 0
-%define CONFIG_AREVERSE_FILTER 0
-%define CONFIG_ASELECT_FILTER 0
-%define CONFIG_ASENDCMD_FILTER 0
-%define CONFIG_ASETNSAMPLES_FILTER 0
-%define CONFIG_ASETPTS_FILTER 0
-%define CONFIG_ASETRATE_FILTER 0
-%define CONFIG_ASETTB_FILTER 0
-%define CONFIG_ASF_DEMUXER 0
-%define CONFIG_ASF_MUXER 0
-%define CONFIG_ASF_O_DEMUXER 0
-%define CONFIG_ASF_STREAM_MUXER 0
-%define CONFIG_ASHOWINFO_FILTER 0
-%define CONFIG_ASIDEDATA_FILTER 0
-%define CONFIG_ASOFTCLIP_FILTER 0
-%define CONFIG_ASPLIT_FILTER 0
-%define CONFIG_ASR_FILTER 0
-%define CONFIG_ASS_DECODER 0
-%define CONFIG_ASS_DEMUXER 0
-%define CONFIG_ASS_ENCODER 0
-%define CONFIG_ASS_FILTER 0
-%define CONFIG_ASS_MUXER 0
-%define CONFIG_ASTATS_FILTER 0
-%define CONFIG_AST_DEMUXER 0
-%define CONFIG_AST_MUXER 0
-%define CONFIG_ASTREAMSELECT_FILTER 0
-%define CONFIG_ASV1_DECODER 0
-%define CONFIG_ASV1_ENCODER 0
-%define CONFIG_ASV2_DECODER 0
-%define CONFIG_ASV2_ENCODER 0
-%define CONFIG_ASYNC_PROTOCOL 0
-%define CONFIG_ATADENOISE_FILTER 0
-%define CONFIG_ATEMPO_FILTER 0
-%define CONFIG_ATRAC1_DECODER 0
-%define CONFIG_ATRAC3AL_DECODER 0
-%define CONFIG_ATRAC3_DECODER 0
-%define CONFIG_ATRAC3PAL_DECODER 0
-%define CONFIG_ATRAC3P_DECODER 0
-%define CONFIG_ATRAC9_DECODER 0
-%define CONFIG_ATRIM_FILTER 0
-%define CONFIG_AU_DEMUXER 0
-%define CONFIG_AU_MUXER 0
-%define CONFIG_AURA2_DECODER 0
-%define CONFIG_AURA_DECODER 0
-%define CONFIG_AV1_FRAME_SPLIT_BSF 0
-%define CONFIG_AV1_METADATA_BSF 0
-%define CONFIG_AV1_PARSER 0
-%define CONFIG_AV1_D3D11VA_HWACCEL 0
-%define CONFIG_AV1_D3D11VA2_HWACCEL 0
-%define CONFIG_AV1_DXVA2_HWACCEL 0
-%define CONFIG_AV1_NVDEC_HWACCEL 0
-%define CONFIG_AV1_VAAPI_HWACCEL 0
-%define CONFIG_AVECTORSCOPE_FILTER 0
-%define CONFIG_AVFOUNDATION_INDEV 0
-%define CONFIG_AVGBLUR_FILTER 0
-%define CONFIG_AVGBLUR_OPENCL_FILTER 0
-%define CONFIG_AVI_DEMUXER 0
-%define CONFIG_AVI_MUXER 0
-%define CONFIG_AVISYNTH_DEMUXER 0
-%define CONFIG_AVM2_MUXER 0
-%define CONFIG_AVR_DEMUXER 0
-%define CONFIG_AVRN_DECODER 0
-%define CONFIG_AVRP_DECODER 0
-%define CONFIG_AVRP_ENCODER 0
-%define CONFIG_AVS2_DEMUXER 0
-%define CONFIG_AVS2_MUXER 0
-%define CONFIG_AVS2_PARSER 0
-%define CONFIG_AVS_DECODER 0
-%define CONFIG_AVS_DEMUXER 0
-%define CONFIG_AVUI_DECODER 0
-%define CONFIG_AVUI_ENCODER 0
-%define CONFIG_AYUV_DECODER 0
-%define CONFIG_AYUV_ENCODER 0
-%define CONFIG_AZMQ_FILTER 0
-%define CONFIG_BANDPASS_FILTER 0
-%define CONFIG_BANDREJECT_FILTER 0
-%define CONFIG_BASS_FILTER 0
-%define CONFIG_BBOX_FILTER 0
-%define CONFIG_BENCH_FILTER 0
-%define CONFIG_BETHSOFTVID_DECODER 0
-%define CONFIG_BETHSOFTVID_DEMUXER 0
-%define CONFIG_BFI_DECODER 0
-%define CONFIG_BFI_DEMUXER 0
-%define CONFIG_BFSTM_DEMUXER 0
-%define CONFIG_BINKAUDIO_DCT_DECODER 0
-%define CONFIG_BINKAUDIO_RDFT_DECODER 0
-%define CONFIG_BINK_DECODER 0
-%define CONFIG_BINK_DEMUXER 0
-%define CONFIG_BINTEXT_DECODER 0
-%define CONFIG_BINTEXT_DEMUXER 0
-%define CONFIG_BIQUAD_FILTER 0
-%define CONFIG_BIT_DEMUXER 0
-%define CONFIG_BIT_MUXER 0
-%define CONFIG_BITPACKED_DECODER 0
-%define CONFIG_BITPLANENOISE_FILTER 0
-%define CONFIG_BKTR_INDEV 0
-%define CONFIG_BLACKDETECT_FILTER 0
-%define CONFIG_BLACKFRAME_FILTER 0
-%define CONFIG_BLEND_FILTER 0
-%define CONFIG_BLURAY_PROTOCOL 0
-%define CONFIG_BM3D_FILTER 0
-%define CONFIG_BMP_DECODER 0
-%define CONFIG_BMP_ENCODER 0
-%define CONFIG_BMP_PARSER 0
-%define CONFIG_BMV_AUDIO_DECODER 0
-%define CONFIG_BMV_DEMUXER 0
-%define CONFIG_BMV_VIDEO_DECODER 0
-%define CONFIG_BOA_DEMUXER 0
-%define CONFIG_BOXBLUR_FILTER 0
-%define CONFIG_BOXBLUR_OPENCL_FILTER 0
-%define CONFIG_BRENDER_PIX_DECODER 0
-%define CONFIG_BRSTM_DEMUXER 0
-%define CONFIG_BS2B_FILTER 0
-%define CONFIG_BWDIF_FILTER 0
-%define CONFIG_C93_DECODER 0
-%define CONFIG_C93_DEMUXER 0
-%define CONFIG_CACA_OUTDEV 0
-%define CONFIG_CACHE_PROTOCOL 0
-%define CONFIG_CAF_DEMUXER 0
-%define CONFIG_CAF_MUXER 0
-%define CONFIG_CAVS_DECODER 0
-%define CONFIG_CAVSVIDEO_DEMUXER 0
-%define CONFIG_CAVSVIDEO_MUXER 0
-%define CONFIG_CAVSVIDEO_PARSER 0
-%define CONFIG_CCAPTION_DECODER 0
-%define CONFIG_CDG_DEMUXER 0
-%define CONFIG_CDGRAPHICS_DECODER 0
-%define CONFIG_CDXL_DECODER 0
-%define CONFIG_CDXL_DEMUXER 0
-%define CONFIG_CELLAUTO_FILTER 0
-%define CONFIG_CFHD_DECODER 0
-%define CONFIG_CHANNELMAP_FILTER 0
-%define CONFIG_CHANNELSPLIT_FILTER 0
-%define CONFIG_CHOMP_BSF 0
-%define CONFIG_CHORUS_FILTER 0
-%define CONFIG_CHROMAHOLD_FILTER 0
-%define CONFIG_CHROMAKEY_FILTER 0
-%define CONFIG_CHROMAPRINT_MUXER 0
-%define CONFIG_CHROMASHIFT_FILTER 0
-%define CONFIG_CIESCOPE_FILTER 0
-%define CONFIG_CINE_DEMUXER 0
-%define CONFIG_CINEPAK_DECODER 0
-%define CONFIG_CINEPAK_ENCODER 0
-%define CONFIG_CLEARVIDEO_DECODER 0
-%define CONFIG_CLJR_DECODER 0
-%define CONFIG_CLJR_ENCODER 0
-%define CONFIG_CLLC_DECODER 0
-%define CONFIG_CODEC2_DEMUXER 0
-%define CONFIG_CODEC2_MUXER 0
-%define CONFIG_CODEC2RAW_DEMUXER 0
-%define CONFIG_CODEC2RAW_MUXER 0
-%define CONFIG_CODECVIEW_FILTER 0
-%define CONFIG_COLORBALANCE_FILTER 0
-%define CONFIG_COLORCHANNELMIXER_FILTER 0
-%define CONFIG_COLOR_FILTER 0
-%define CONFIG_COLORHOLD_FILTER 0
-%define CONFIG_COLORKEY_FILTER 0
-%define CONFIG_COLORKEY_OPENCL_FILTER 0
-%define CONFIG_COLORLEVELS_FILTER 0
-%define CONFIG_COLORMATRIX_FILTER 0
-%define CONFIG_COLORSPACE_FILTER 0
-%define CONFIG_COMFORTNOISE_DECODER 0
-%define CONFIG_COMFORTNOISE_ENCODER 0
-%define CONFIG_COMPAND_FILTER 0
-%define CONFIG_COMPENSATIONDELAY_FILTER 0
-%define CONFIG_CONCAT_DEMUXER 0
-%define CONFIG_CONCAT_FILTER 0
-%define CONFIG_CONCAT_PROTOCOL 0
-%define CONFIG_CONVOLUTION_FILTER 0
-%define CONFIG_CONVOLUTION_OPENCL_FILTER 0
-%define CONFIG_CONVOLVE_FILTER 0
-%define CONFIG_COOK_DECODER 0
-%define CONFIG_COOK_PARSER 0
-%define CONFIG_COPY_FILTER 0
-%define CONFIG_COREIMAGE_FILTER 0
-%define CONFIG_COREIMAGESRC_FILTER 0
-%define CONFIG_COVER_RECT_FILTER 0
-%define CONFIG_CPIA_DECODER 0
-%define CONFIG_CRC_MUXER 0
-%define CONFIG_CROPDETECT_FILTER 0
-%define CONFIG_CROP_FILTER 0
-%define CONFIG_CROSSFEED_FILTER 0
-%define CONFIG_CRYPTO_PROTOCOL 0
-%define CONFIG_CRYSTALIZER_FILTER 0
-%define CONFIG_CSCD_DECODER 0
-%define CONFIG_CUE_FILTER 0
-%define CONFIG_CURVES_FILTER 0
-%define CONFIG_CYUV_DECODER 0
-%define CONFIG_DASH_DEMUXER 0
-%define CONFIG_DASH_MUXER 0
-%define CONFIG_DATA_DEMUXER 0
-%define CONFIG_DATA_MUXER 0
-%define CONFIG_DATA_PROTOCOL 0
-%define CONFIG_DATASCOPE_FILTER 0
-%define CONFIG_DAUD_DEMUXER 0
-%define CONFIG_DAUD_MUXER 0
-%define CONFIG_DCA_CORE_BSF 0
-%define CONFIG_DCA_DECODER 0
-%define CONFIG_DCA_ENCODER 0
-%define CONFIG_DCA_PARSER 0
-%define CONFIG_DCSHIFT_FILTER 0
-%define CONFIG_DCSTR_DEMUXER 0
-%define CONFIG_DCTDNOIZ_FILTER 0
-%define CONFIG_DDS_DECODER 0
-%define CONFIG_DEBAND_FILTER 0
-%define CONFIG_DEBLOCK_FILTER 0
-%define CONFIG_DECIMATE_FILTER 0
-%define CONFIG_DECKLINK_INDEV 0
-%define CONFIG_DECKLINK_OUTDEV 0
-%define CONFIG_DECONVOLVE_FILTER 0
-%define CONFIG_DEDOT_FILTER 0
-%define CONFIG_DEESSER_FILTER 0
-%define CONFIG_DEFLATE_FILTER 0
-%define CONFIG_DEFLICKER_FILTER 0
-%define CONFIG_DEINTERLACE_QSV_FILTER 0
-%define CONFIG_DEINTERLACE_VAAPI_FILTER 0
-%define CONFIG_DEJUDDER_FILTER 0
-%define CONFIG_DELOGO_FILTER 0
-%define CONFIG_DEMUXERS 0
-%define CONFIG_DENOISE_VAAPI_FILTER 0
-%define CONFIG_DERAIN_FILTER 0
-%define CONFIG_DESHAKE_FILTER 0
-%define CONFIG_DESPILL_FILTER 0
-%define CONFIG_DETELECINE_FILTER 0
-%define CONFIG_DFA_DECODER 0
-%define CONFIG_DFA_DEMUXER 0
-%define CONFIG_DHAV_DEMUXER 0
-%define CONFIG_DILATION_FILTER 0
-%define CONFIG_DILATION_OPENCL_FILTER 0
-%define CONFIG_DIRAC_DECODER 0
-%define CONFIG_DIRAC_DEMUXER 0
-%define CONFIG_DIRAC_MUXER 0
-%define CONFIG_DIRAC_PARSER 0
-%define CONFIG_DISPLACE_FILTER 0
-%define CONFIG_DNXHD_DECODER 0
-%define CONFIG_DNXHD_DEMUXER 0
-%define CONFIG_DNXHD_ENCODER 0
-%define CONFIG_DNXHD_MUXER 0
-%define CONFIG_DNXHD_PARSER 0
-%define CONFIG_DOLBY_E_DECODER 0
-%define CONFIG_DOUBLEWEAVE_FILTER 0
-%define CONFIG_DPX_DECODER 0
-%define CONFIG_DPX_ENCODER 0
-%define CONFIG_DPX_PARSER 0
-%define CONFIG_DRAWBOX_FILTER 0
-%define CONFIG_DRAWGRAPH_FILTER 0
-%define CONFIG_DRAWGRID_FILTER 0
-%define CONFIG_DRAWTEXT_FILTER 0
-%define CONFIG_DRMETER_FILTER 0
-%define CONFIG_DSD_LSBF_DECODER 0
-%define CONFIG_DSD_LSBF_PLANAR_DECODER 0
-%define CONFIG_DSD_MSBF_DECODER 0
-%define CONFIG_DSD_MSBF_PLANAR_DECODER 0
-%define CONFIG_DSF_DEMUXER 0
-%define CONFIG_DSHOW_INDEV 0
-%define CONFIG_DSICINAUDIO_DECODER 0
-%define CONFIG_DSICIN_DEMUXER 0
-%define CONFIG_DSICINVIDEO_DECODER 0
-%define CONFIG_DSS_DEMUXER 0
-%define CONFIG_DSS_SP_DECODER 0
-%define CONFIG_DST_DECODER 0
-%define CONFIG_DTS_DEMUXER 0
-%define CONFIG_DTSHD_DEMUXER 0
-%define CONFIG_DTS_MUXER 0
-%define CONFIG_DUMP_EXTRADATA_BSF 0
-%define CONFIG_DVAUDIO_DECODER 0
-%define CONFIG_DVAUDIO_PARSER 0
-%define CONFIG_DVBSUB_DECODER 0
-%define CONFIG_DVBSUB_DEMUXER 0
-%define CONFIG_DVBSUB_ENCODER 0
-%define CONFIG_DVBSUB_PARSER 0
-%define CONFIG_DVBTXT_DEMUXER 0
-%define CONFIG_DV_DEMUXER 0
-%define CONFIG_DVD_NAV_PARSER 0
-%define CONFIG_DVDSUB_DECODER 0
-%define CONFIG_DVDSUB_ENCODER 0
-%define CONFIG_DVDSUB_PARSER 0
-%define CONFIG_DV_MUXER 0
-%define CONFIG_DVVIDEO_DECODER 0
-%define CONFIG_DVVIDEO_ENCODER 0
-%define CONFIG_DXA_DECODER 0
-%define CONFIG_DXA_DEMUXER 0
-%define CONFIG_DXTORY_DECODER 0
-%define CONFIG_DXV_DECODER 0
-%define CONFIG_DYNAUDNORM_FILTER 0
-%define CONFIG_EAC3_AT_DECODER 0
-%define CONFIG_EAC3_CORE_BSF 0
-%define CONFIG_EAC3_DECODER 0
-%define CONFIG_EAC3_DEMUXER 0
-%define CONFIG_EAC3_ENCODER 0
-%define CONFIG_EAC3_MUXER 0
-%define CONFIG_EA_CDATA_DEMUXER 0
-%define CONFIG_EACMV_DECODER 0
-%define CONFIG_EA_DEMUXER 0
-%define CONFIG_EAMAD_DECODER 0
-%define CONFIG_EARWAX_FILTER 0
-%define CONFIG_EATGQ_DECODER 0
-%define CONFIG_EATGV_DECODER 0
-%define CONFIG_EATQI_DECODER 0
-%define CONFIG_EBUR128_FILTER 0
-%define CONFIG_EDGEDETECT_FILTER 0
-%define CONFIG_EIGHTBPS_DECODER 0
-%define CONFIG_EIGHTSVX_EXP_DECODER 0
-%define CONFIG_EIGHTSVX_FIB_DECODER 0
-%define CONFIG_ELBG_FILTER 0
-%define CONFIG_ENCODERS 0
-%define CONFIG_ENTROPY_FILTER 0
-%define CONFIG_EPAF_DEMUXER 0
-%define CONFIG_EQ_FILTER 0
-%define CONFIG_EQUALIZER_FILTER 0
-%define CONFIG_EROSION_FILTER 0
-%define CONFIG_EROSION_OPENCL_FILTER 0
-%define CONFIG_ESCAPE124_DECODER 0
-%define CONFIG_ESCAPE130_DECODER 0
-%define CONFIG_EVRC_DECODER 0
-%define CONFIG_EXR_DECODER 0
-%define CONFIG_EXTRACT_EXTRADATA_BSF 0
-%define CONFIG_EXTRACTPLANES_FILTER 0
-%define CONFIG_EXTRASTEREO_FILTER 0
-%define CONFIG_F4V_MUXER 0
-%define CONFIG_FADE_FILTER 0
-%define CONFIG_FBDEV_INDEV 0
-%define CONFIG_FBDEV_OUTDEV 0
-%define CONFIG_FFMETADATA_DEMUXER 0
-%define CONFIG_FFMETADATA_MUXER 0
-%define CONFIG_FFRTMPCRYPT_PROTOCOL 0
-%define CONFIG_FFRTMPHTTP_PROTOCOL 0
-%define CONFIG_FFTDNOIZ_FILTER 0
-%define CONFIG_FFTFILT_FILTER 0
-%define CONFIG_FFV1_DECODER 0
-%define CONFIG_FFV1_ENCODER 0
-%define CONFIG_FFVHUFF_DECODER 0
-%define CONFIG_FFVHUFF_ENCODER 0
-%define CONFIG_FFWAVESYNTH_DECODER 0
-%define CONFIG_FIC_DECODER 0
-%define CONFIG_FIELD_FILTER 0
-%define CONFIG_FIELDHINT_FILTER 0
-%define CONFIG_FIELDMATCH_FILTER 0
-%define CONFIG_FIELDORDER_FILTER 0
-%define CONFIG_FIFO_FILTER 0
-%define CONFIG_FIFO_MUXER 0
-%define CONFIG_FIFO_TEST_MUXER 0
-%define CONFIG_FILE_PROTOCOL 0
-%define CONFIG_FILLBORDERS_FILTER 0
-%define CONFIG_FILMSTRIP_DEMUXER 0
-%define CONFIG_FILMSTRIP_MUXER 0
-%define CONFIG_FILTERS 0
-%define CONFIG_FILTER_UNITS_BSF 0
-%define CONFIG_FIND_RECT_FILTER 0
-%define CONFIG_FIREQUALIZER_FILTER 0
-%define CONFIG_FITS_DECODER 0
-%define CONFIG_FITS_DEMUXER 0
-%define CONFIG_FITS_ENCODER 0
-%define CONFIG_FITS_MUXER 0
-%define CONFIG_FLAC_DEMUXER 0
-%define CONFIG_FLAC_ENCODER 0
-%define CONFIG_FLAC_MUXER 0
-%define CONFIG_FLAC_PARSER 0
-%define CONFIG_FLANGER_FILTER 0
-%define CONFIG_FLASHSV2_DECODER 0
-%define CONFIG_FLASHSV2_ENCODER 0
-%define CONFIG_FLASHSV_DECODER 0
-%define CONFIG_FLASHSV_ENCODER 0
-%define CONFIG_FLIC_DECODER 0
-%define CONFIG_FLIC_DEMUXER 0
-%define CONFIG_FLITE_FILTER 0
-%define CONFIG_FLOODFILL_FILTER 0
-%define CONFIG_FLV_DECODER 0
-%define CONFIG_FLV_DEMUXER 0
-%define CONFIG_FLV_ENCODER 0
-%define CONFIG_FLV_MUXER 0
-%define CONFIG_FMVC_DECODER 0
-%define CONFIG_FORMAT_FILTER 0
-%define CONFIG_FOURXM_DECODER 0
-%define CONFIG_FOURXM_DEMUXER 0
-%define CONFIG_FPS_FILTER 0
-%define CONFIG_FRAMECRC_MUXER 0
-%define CONFIG_FRAMEHASH_MUXER 0
-%define CONFIG_FRAMEMD5_MUXER 0
-%define CONFIG_FRAMEPACK_FILTER 0
-%define CONFIG_FRAMERATE_FILTER 0
-%define CONFIG_FRAMESTEP_FILTER 0
-%define CONFIG_FRAME_THREAD_ENCODER 0
-%define CONFIG_FRAPS_DECODER 0
-%define CONFIG_FREEZEDETECT_FILTER 0
-%define CONFIG_FREI0R_FILTER 0
-%define CONFIG_FREI0R_SRC_FILTER 0
-%define CONFIG_FRM_DEMUXER 0
-%define CONFIG_FRWU_DECODER 0
-%define CONFIG_FSB_DEMUXER 0
-%define CONFIG_FSPP_FILTER 0
-%define CONFIG_FTP_PROTOCOL 0
-%define CONFIG_G2M_DECODER 0
-%define CONFIG_G722_DEMUXER 0
-%define CONFIG_G722_MUXER 0
-%define CONFIG_G723_1_DECODER 0
-%define CONFIG_G723_1_DEMUXER 0
-%define CONFIG_G723_1_ENCODER 0
-%define CONFIG_G723_1_MUXER 0
-%define CONFIG_G723_1_PARSER 0
-%define CONFIG_G726_DEMUXER 0
-%define CONFIG_G726LE_DEMUXER 0
-%define CONFIG_G726LE_MUXER 0
-%define CONFIG_G726_MUXER 0
-%define CONFIG_G729_DECODER 0
-%define CONFIG_G729_DEMUXER 0
-%define CONFIG_G729_PARSER 0
-%define CONFIG_GBLUR_FILTER 0
-%define CONFIG_GDIGRAB_INDEV 0
-%define CONFIG_GDV_DECODER 0
-%define CONFIG_GDV_DEMUXER 0
-%define CONFIG_GENH_DEMUXER 0
-%define CONFIG_GEQ_FILTER 0
-%define CONFIG_GIF_DECODER 0
-%define CONFIG_GIF_DEMUXER 0
-%define CONFIG_GIF_ENCODER 0
-%define CONFIG_GIF_MUXER 0
-%define CONFIG_GIF_PARSER 0
-%define CONFIG_GOPHER_PROTOCOL 0
-%define CONFIG_GRADFUN_FILTER 0
-%define CONFIG_GRAPHMONITOR_FILTER 0
-%define CONFIG_GREMLIN_DPCM_DECODER 0
-%define CONFIG_GREYEDGE_FILTER 0
-%define CONFIG_GSM_DECODER 0
-%define CONFIG_GSM_DEMUXER 0
-%define CONFIG_GSM_MS_AT_DECODER 0
-%define CONFIG_GSM_MS_DECODER 0
-%define CONFIG_GSM_MUXER 0
-%define CONFIG_GSM_PARSER 0
-%define CONFIG_GXF_DEMUXER 0
-%define CONFIG_GXF_MUXER 0
-%define CONFIG_H261_DECODER 0
-%define CONFIG_H261_DEMUXER 0
-%define CONFIG_H261_ENCODER 0
-%define CONFIG_H261_MUXER 0
-%define CONFIG_H261_PARSER 0
-%define CONFIG_H263_DECODER 0
-%define CONFIG_H263_DEMUXER 0
-%define CONFIG_H263_ENCODER 0
-%define CONFIG_H263I_DECODER 0
-%define CONFIG_H263_MUXER 0
-%define CONFIG_H263_PARSER 0
-%define CONFIG_H263P_DECODER 0
-%define CONFIG_H263P_ENCODER 0
-%define CONFIG_H263_V4L2M2M_DECODER 0
-%define CONFIG_H263_V4L2M2M_ENCODER 0
-%define CONFIG_H263_VAAPI_HWACCEL 0
-%define CONFIG_H263_VIDEOTOOLBOX_HWACCEL 0
-%define CONFIG_H264_AMF_ENCODER 0
-%define CONFIG_H264_CRYSTALHD_DECODER 0
-%define CONFIG_H264_CUVID_DECODER 0
-%define CONFIG_H264_D3D11VA2_HWACCEL 0
-%define CONFIG_H264_D3D11VA_HWACCEL 0
-%define CONFIG_H264_DECODER 0
-%define CONFIG_H264_DEMUXER 0
-%define CONFIG_H264_DXVA2_HWACCEL 0
-%define CONFIG_H264_MEDIACODEC_DECODER 0
-%define CONFIG_H264_METADATA_BSF 0
-%define CONFIG_H264_MMAL_DECODER 0
-%define CONFIG_H264_MP4TOANNEXB_BSF 0
-%define CONFIG_H264_MUXER 0
-%define CONFIG_H264_NVDEC_HWACCEL 0
-%define CONFIG_H264_NVENC_ENCODER 0
-%define CONFIG_H264_OMX_ENCODER 0
-%define CONFIG_H264_PARSER 0
-%define CONFIG_H264_QSV_DECODER 0
-%define CONFIG_H264_QSV_ENCODER 0
-%define CONFIG_H264_REDUNDANT_PPS_BSF 0
-%define CONFIG_H264_RKMPP_DECODER 0
-%define CONFIG_H264_V4L2M2M_DECODER 0
-%define CONFIG_H264_V4L2M2M_ENCODER 0
-%define CONFIG_H264_VAAPI_ENCODER 0
-%define CONFIG_H264_VAAPI_HWACCEL 0
-%define CONFIG_H264_VDPAU_HWACCEL 0
-%define CONFIG_H264_VIDEOTOOLBOX_ENCODER 0
-%define CONFIG_H264_VIDEOTOOLBOX_HWACCEL 0
-%define CONFIG_HAAS_FILTER 0
-%define CONFIG_HALDCLUT_FILTER 0
-%define CONFIG_HALDCLUTSRC_FILTER 0
-%define CONFIG_HAP_DECODER 0
-%define CONFIG_HAP_ENCODER 0
-%define CONFIG_HAPQA_EXTRACT_BSF 0
-%define CONFIG_HASH_MUXER 0
-%define CONFIG_HCOM_DECODER 0
-%define CONFIG_HCOM_DEMUXER 0
-%define CONFIG_HDCD_FILTER 0
-%define CONFIG_HDS_MUXER 0
-%define CONFIG_HEADPHONE_FILTER 0
-%define CONFIG_HEVC_AMF_ENCODER 0
-%define CONFIG_HEVC_CUVID_DECODER 0
-%define CONFIG_HEVC_D3D11VA2_HWACCEL 0
-%define CONFIG_HEVC_D3D11VA_HWACCEL 0
-%define CONFIG_HEVC_DECODER 0
-%define CONFIG_HEVC_DEMUXER 0
-%define CONFIG_HEVC_DXVA2_HWACCEL 0
-%define CONFIG_HEVC_MEDIACODEC_DECODER 0
-%define CONFIG_HEVC_METADATA_BSF 0
-%define CONFIG_HEVC_MP4TOANNEXB_BSF 0
-%define CONFIG_HEVC_MUXER 0
-%define CONFIG_HEVC_NVDEC_HWACCEL 0
-%define CONFIG_HEVC_NVENC_ENCODER 0
-%define CONFIG_HEVC_PARSER 0
-%define CONFIG_HEVC_QSV_DECODER 0
-%define CONFIG_HEVC_QSV_ENCODER 0
-%define CONFIG_HEVC_RKMPP_DECODER 0
-%define CONFIG_HEVC_V4L2M2M_DECODER 0
-%define CONFIG_HEVC_V4L2M2M_ENCODER 0
-%define CONFIG_HEVC_VAAPI_ENCODER 0
-%define CONFIG_HEVC_VAAPI_HWACCEL 0
-%define CONFIG_HEVC_VDPAU_HWACCEL 0
-%define CONFIG_HEVC_VIDEOTOOLBOX_ENCODER 0
-%define CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL 0
-%define CONFIG_HFLIP_FILTER 0
-%define CONFIG_HIGHPASS_FILTER 0
-%define CONFIG_HIGHSHELF_FILTER 0
-%define CONFIG_HILBERT_FILTER 0
-%define CONFIG_HISTEQ_FILTER 0
-%define CONFIG_HISTOGRAM_FILTER 0
-%define CONFIG_HLS_DEMUXER 0
-%define CONFIG_HLS_MUXER 0
-%define CONFIG_HLS_PROTOCOL 0
-%define CONFIG_HNM4_VIDEO_DECODER 0
-%define CONFIG_HNM_DEMUXER 0
-%define CONFIG_HQDN3D_FILTER 0
-%define CONFIG_HQ_HQA_DECODER 0
-%define CONFIG_HQX_DECODER 0
-%define CONFIG_HQX_FILTER 0
-%define CONFIG_HSTACK_FILTER 0
-%define CONFIG_HTTP_PROTOCOL 0
-%define CONFIG_HTTPPROXY_PROTOCOL 0
-%define CONFIG_HTTPS_PROTOCOL 0
-%define CONFIG_HUE_FILTER 0
-%define CONFIG_HUFFYUV_DECODER 0
-%define CONFIG_HUFFYUV_ENCODER 0
-%define CONFIG_HWACCELS 0
-%define CONFIG_HWDOWNLOAD_FILTER 0
-%define CONFIG_HWMAP_FILTER 0
-%define CONFIG_HWUPLOAD_CUDA_FILTER 0
-%define CONFIG_HWUPLOAD_FILTER 0
-%define CONFIG_HYMT_DECODER 0
-%define CONFIG_HYSTERESIS_FILTER 0
-%define CONFIG_IAC_DECODER 0
-%define CONFIG_ICECAST_PROTOCOL 0
-%define CONFIG_ICO_DEMUXER 0
-%define CONFIG_ICO_MUXER 0
-%define CONFIG_IDCIN_DECODER 0
-%define CONFIG_IDCIN_DEMUXER 0
-%define CONFIG_IDET_FILTER 0
-%define CONFIG_IDF_DECODER 0
-%define CONFIG_IDF_DEMUXER 0
-%define CONFIG_IEC61883_INDEV 0
-%define CONFIG_IFF_DEMUXER 0
-%define CONFIG_IFF_ILBM_DECODER 0
-%define CONFIG_IFV_DEMUXER 0
-%define CONFIG_ILBC_AT_DECODER 0
-%define CONFIG_ILBC_AT_ENCODER 0
-%define CONFIG_ILBC_DECODER 0
-%define CONFIG_ILBC_DEMUXER 0
-%define CONFIG_ILBC_MUXER 0
-%define CONFIG_IL_FILTER 0
-%define CONFIG_IMAGE2_ALIAS_PIX_DEMUXER 0
-%define CONFIG_IMAGE2_BRENDER_PIX_DEMUXER 0
-%define CONFIG_IMAGE2_DEMUXER 0
-%define CONFIG_IMAGE2_MUXER 0
-%define CONFIG_IMAGE2PIPE_DEMUXER 0
-%define CONFIG_IMAGE2PIPE_MUXER 0
-%define CONFIG_IMAGE_BMP_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_DDS_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_DPX_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_EXR_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_GIF_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_J2K_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_JPEG_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PAM_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PBM_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PCX_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PGM_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PGMYUV_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PICTOR_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PNG_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PPM_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_PSD_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_QDRAW_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_SGI_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_SUNRAST_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_SVG_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_TIFF_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_WEBP_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_XPM_PIPE_DEMUXER 0
-%define CONFIG_IMAGE_XWD_PIPE_DEMUXER 0
-%define CONFIG_IMC_DECODER 0
-%define CONFIG_IMM4_DECODER 0
-%define CONFIG_IMX_DUMP_HEADER_BSF 0
-%define CONFIG_INDEO2_DECODER 0
-%define CONFIG_INDEO3_DECODER 0
-%define CONFIG_INDEO4_DECODER 0
-%define CONFIG_INDEO5_DECODER 0
-%define CONFIG_INDEVS 0
-%define CONFIG_INFLATE_FILTER 0
-%define CONFIG_INGENIENT_DEMUXER 0
-%define CONFIG_INTERLACE_FILTER 0
-%define CONFIG_INTERLEAVE_FILTER 0
-%define CONFIG_INTERPLAY_ACM_DECODER 0
-%define CONFIG_INTERPLAY_DPCM_DECODER 0
-%define CONFIG_INTERPLAY_VIDEO_DECODER 0
-%define CONFIG_IPMOVIE_DEMUXER 0
-%define CONFIG_IPOD_MUXER 0
-%define CONFIG_IRCAM_DEMUXER 0
-%define CONFIG_IRCAM_MUXER 0
-%define CONFIG_ISMV_MUXER 0
-%define CONFIG_ISS_DEMUXER 0
-%define CONFIG_IV8_DEMUXER 0
-%define CONFIG_IVF_DEMUXER 0
-%define CONFIG_IVF_MUXER 0
-%define CONFIG_IVR_DEMUXER 0
-%define CONFIG_JACK_INDEV 0
-%define CONFIG_JACOSUB_DECODER 0
-%define CONFIG_JACOSUB_DEMUXER 0
-%define CONFIG_JACOSUB_MUXER 0
-%define CONFIG_JOIN_FILTER 0
-%define CONFIG_JPEG2000_DECODER 0
-%define CONFIG_JPEG2000_ENCODER 0
-%define CONFIG_JPEGLS_DECODER 0
-%define CONFIG_JPEGLS_ENCODER 0
-%define CONFIG_JV_DECODER 0
-%define CONFIG_JV_DEMUXER 0
-%define CONFIG_KERNDEINT_FILTER 0
-%define CONFIG_KGV1_DECODER 0
-%define CONFIG_KMSGRAB_INDEV 0
-%define CONFIG_KMVC_DECODER 0
-%define CONFIG_KUX_DEMUXER 0
-%define CONFIG_LADSPA_FILTER 0
-%define CONFIG_LAGARITH_DECODER 0
-%define CONFIG_LAGFUN_FILTER 0
-%define CONFIG_LATM_MUXER 0
-%define CONFIG_LAVFI_INDEV 0
-%define CONFIG_LENSCORRECTION_FILTER 0
-%define CONFIG_LENSFUN_FILTER 0
-%define CONFIG_LIBAOM_AV1_DECODER 0
-%define CONFIG_LIBAOM_AV1_ENCODER 0
-%define CONFIG_LIBARIBB24_DECODER 0
-%define CONFIG_LIBCDIO_INDEV 0
-%define CONFIG_LIBCELT_DECODER 0
-%define CONFIG_LIBCODEC2_DECODER 0
-%define CONFIG_LIBCODEC2_ENCODER 0
-%define CONFIG_LIBDAV1D_DECODER 0
-%define CONFIG_LIBDAVS2_DECODER 0
-%define CONFIG_LIBDC1394_INDEV 0
-%define CONFIG_LIBFDK_AAC_DECODER 0
-%define CONFIG_LIBFDK_AAC_ENCODER 0
-%define CONFIG_LIBGME_DEMUXER 0
-%define CONFIG_LIBGSM_DECODER 0
-%define CONFIG_LIBGSM_ENCODER 0
-%define CONFIG_LIBGSM_MS_DECODER 0
-%define CONFIG_LIBGSM_MS_ENCODER 0
-%define CONFIG_LIBILBC_DECODER 0
-%define CONFIG_LIBILBC_ENCODER 0
-%define CONFIG_LIBKVAZAAR_ENCODER 0
-%define CONFIG_LIBMODPLUG_DEMUXER 0
-%define CONFIG_LIBMP3LAME_ENCODER 0
-%define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
-%define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
-%define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
-%define CONFIG_LIBOPENH264_DECODER 0
-%define CONFIG_LIBOPENH264_ENCODER 0
-%define CONFIG_LIBOPENJPEG_DECODER 0
-%define CONFIG_LIBOPENJPEG_ENCODER 0
-%define CONFIG_LIBOPENMPT_DEMUXER 0
-%define CONFIG_LIBOPUS_DECODER 0
-%define CONFIG_LIBOPUS_ENCODER 0
-%define CONFIG_LIBRSVG_DECODER 0
-%define CONFIG_LIBRTMPE_PROTOCOL 0
-%define CONFIG_LIBRTMP_PROTOCOL 0
-%define CONFIG_LIBRTMPS_PROTOCOL 0
-%define CONFIG_LIBRTMPTE_PROTOCOL 0
-%define CONFIG_LIBRTMPT_PROTOCOL 0
-%define CONFIG_LIBSHINE_ENCODER 0
-%define CONFIG_LIBSMBCLIENT_PROTOCOL 0
-%define CONFIG_LIBSPEEX_DECODER 0
-%define CONFIG_LIBSPEEX_ENCODER 0
-%define CONFIG_LIBSRT_PROTOCOL 0
-%define CONFIG_LIBSSH_PROTOCOL 0
-%define CONFIG_LIBTHEORA_ENCODER 0
-%define CONFIG_LIBTWOLAME_ENCODER 0
-%define CONFIG_LIBVMAF_FILTER 0
-%define CONFIG_LIBVO_AMRWBENC_ENCODER 0
-%define CONFIG_LIBVORBIS_DECODER 0
-%define CONFIG_LIBVORBIS_ENCODER 0
-%define CONFIG_LIBVPX_VP8_DECODER 0
-%define CONFIG_LIBVPX_VP8_ENCODER 0
-%define CONFIG_LIBVPX_VP9_DECODER 0
-%define CONFIG_LIBVPX_VP9_ENCODER 0
-%define CONFIG_LIBWAVPACK_ENCODER 0
-%define CONFIG_LIBWEBP_ANIM_ENCODER 0
-%define CONFIG_LIBWEBP_ENCODER 0
-%define CONFIG_LIBX262_ENCODER 0
-%define CONFIG_LIBX264_ENCODER 0
-%define CONFIG_LIBX264RGB_ENCODER 0
-%define CONFIG_LIBX265_ENCODER 0
-%define CONFIG_LIBXAVS2_ENCODER 0
-%define CONFIG_LIBXAVS_ENCODER 0
-%define CONFIG_LIBXVID_ENCODER 0
-%define CONFIG_LIBZVBI_TELETEXT_DECODER 0
-%define CONFIG_LIFE_FILTER 0
-%define CONFIG_LIMITER_FILTER 0
-%define CONFIG_LIVE_FLV_DEMUXER 0
-%define CONFIG_LJPEG_ENCODER 0
-%define CONFIG_LMLM4_DEMUXER 0
-%define CONFIG_LOAS_DEMUXER 0
-%define CONFIG_LOCO_DECODER 0
-%define CONFIG_LOOP_FILTER 0
-%define CONFIG_LOUDNORM_FILTER 0
-%define CONFIG_LOWPASS_FILTER 0
-%define CONFIG_LOWSHELF_FILTER 0
-%define CONFIG_LRC_DEMUXER 0
-%define CONFIG_LRC_MUXER 0
-%define CONFIG_LSCR_DECODER 0
-%define CONFIG_LUMAKEY_FILTER 0
-%define CONFIG_LUT1D_FILTER 0
-%define CONFIG_LUT2_FILTER 0
-%define CONFIG_LUT3D_FILTER 0
-%define CONFIG_LUT_FILTER 0
-%define CONFIG_LUTRGB_FILTER 0
-%define CONFIG_LUTYUV_FILTER 0
-%define CONFIG_LV2_FILTER 0
-%define CONFIG_LVF_DEMUXER 0
-%define CONFIG_LXF_DEMUXER 0
-%define CONFIG_M101_DECODER 0
-%define CONFIG_M4V_DEMUXER 0
-%define CONFIG_M4V_MUXER 0
-%define CONFIG_MACE3_DECODER 0
-%define CONFIG_MACE6_DECODER 0
-%define CONFIG_MAGICYUV_DECODER 0
-%define CONFIG_MAGICYUV_ENCODER 0
-%define CONFIG_MANDELBROT_FILTER 0
-%define CONFIG_MASKEDCLAMP_FILTER 0
-%define CONFIG_MASKEDMERGE_FILTER 0
-%define CONFIG_MASKFUN_FILTER 0
-%define CONFIG_MATROSKA_AUDIO_MUXER 0
-%define CONFIG_MATROSKA_DEMUXER 0
-%define CONFIG_MATROSKA_MUXER 0
-%define CONFIG_MCDEINT_FILTER 0
-%define CONFIG_MCOMPAND_FILTER 0
-%define CONFIG_MD5_MUXER 0
-%define CONFIG_MD5_PROTOCOL 0
-%define CONFIG_MDEC_DECODER 0
-%define CONFIG_MERGEPLANES_FILTER 0
-%define CONFIG_MESTIMATE_FILTER 0
-%define CONFIG_METADATA_FILTER 0
-%define CONFIG_METASOUND_DECODER 0
-%define CONFIG_MGSTS_DEMUXER 0
-%define CONFIG_MICRODVD_DECODER 0
-%define CONFIG_MICRODVD_DEMUXER 0
-%define CONFIG_MICRODVD_MUXER 0
-%define CONFIG_MIDEQUALIZER_FILTER 0
-%define CONFIG_MIMIC_DECODER 0
-%define CONFIG_MINTERPOLATE_FILTER 0
-%define CONFIG_MIX_FILTER 0
-%define CONFIG_MJPEG_2000_DEMUXER 0
-%define CONFIG_MJPEG2JPEG_BSF 0
-%define CONFIG_MJPEGA_DUMP_HEADER_BSF 0
-%define CONFIG_MJPEGB_DECODER 0
-%define CONFIG_MJPEG_CUVID_DECODER 0
-%define CONFIG_MJPEG_DECODER 0
-%define CONFIG_MJPEG_DEMUXER 0
-%define CONFIG_MJPEG_ENCODER 0
-%define CONFIG_MJPEG_MUXER 0
-%define CONFIG_MJPEG_NVDEC_HWACCEL 0
-%define CONFIG_MJPEG_PARSER 0
-%define CONFIG_MJPEG_QSV_ENCODER 0
-%define CONFIG_MJPEG_VAAPI_ENCODER 0
-%define CONFIG_MJPEG_VAAPI_HWACCEL 0
-%define CONFIG_MKVTIMESTAMP_V2_MUXER 0
-%define CONFIG_MLP_DECODER 0
-%define CONFIG_MLP_DEMUXER 0
-%define CONFIG_MLP_ENCODER 0
-%define CONFIG_MLP_MUXER 0
-%define CONFIG_MLP_PARSER 0
-%define CONFIG_MLV_DEMUXER 0
-%define CONFIG_MM_DEMUXER 0
-%define CONFIG_MMF_DEMUXER 0
-%define CONFIG_MMF_MUXER 0
-%define CONFIG_MMSH_PROTOCOL 0
-%define CONFIG_MMST_PROTOCOL 0
-%define CONFIG_MMVIDEO_DECODER 0
-%define CONFIG_MOTIONPIXELS_DECODER 0
-%define CONFIG_MOV2TEXTSUB_BSF 0
-%define CONFIG_MOV_DEMUXER 0
-%define CONFIG_MOVIE_FILTER 0
-%define CONFIG_MOV_MUXER 0
-%define CONFIG_MOVTEXT_DECODER 0
-%define CONFIG_MOVTEXT_ENCODER 0
-%define CONFIG_MP1_AT_DECODER 0
-%define CONFIG_MP1_DECODER 0
-%define CONFIG_MP1FLOAT_DECODER 0
-%define CONFIG_MP2_AT_DECODER 0
-%define CONFIG_MP2_DECODER 0
-%define CONFIG_MP2_ENCODER 0
-%define CONFIG_MP2FIXED_ENCODER 0
-%define CONFIG_MP2FLOAT_DECODER 0
-%define CONFIG_MP2_MUXER 0
-%define CONFIG_MP3ADU_DECODER 0
-%define CONFIG_MP3ADUFLOAT_DECODER 0
-%define CONFIG_MP3_AT_DECODER 0
-%define CONFIG_MP3_DEMUXER 0
-%define CONFIG_MP3FLOAT_DECODER 0
-%define CONFIG_MP3_HEADER_DECOMPRESS_BSF 0
-%define CONFIG_MP3_MUXER 0
-%define CONFIG_MP3ON4_DECODER 0
-%define CONFIG_MP3ON4FLOAT_DECODER 0
-%define CONFIG_MP4_MUXER 0
-%define CONFIG_MPC7_DECODER 0
-%define CONFIG_MPC8_DECODER 0
-%define CONFIG_MPC8_DEMUXER 0
-%define CONFIG_MPC_DEMUXER 0
-%define CONFIG_MPDECIMATE_FILTER 0
-%define CONFIG_MPEG1_CUVID_DECODER 0
-%define CONFIG_MPEG1_NVDEC_HWACCEL 0
-%define CONFIG_MPEG1SYSTEM_MUXER 0
-%define CONFIG_MPEG1_V4L2M2M_DECODER 0
-%define CONFIG_MPEG1VCD_MUXER 0
-%define CONFIG_MPEG1_VDPAU_HWACCEL 0
-%define CONFIG_MPEG1VIDEO_DECODER 0
-%define CONFIG_MPEG1VIDEO_ENCODER 0
-%define CONFIG_MPEG1VIDEO_MUXER 0
-%define CONFIG_MPEG1_VIDEOTOOLBOX_HWACCEL 0
-%define CONFIG_MPEG1_XVMC_HWACCEL 0
-%define CONFIG_MPEG2_CRYSTALHD_DECODER 0
-%define CONFIG_MPEG2_CUVID_DECODER 0
-%define CONFIG_MPEG2_D3D11VA2_HWACCEL 0
-%define CONFIG_MPEG2_D3D11VA_HWACCEL 0
-%define CONFIG_MPEG2DVD_MUXER 0
-%define CONFIG_MPEG2_DXVA2_HWACCEL 0
-%define CONFIG_MPEG2_MEDIACODEC_DECODER 0
-%define CONFIG_MPEG2_METADATA_BSF 0
-%define CONFIG_MPEG2_MMAL_DECODER 0
-%define CONFIG_MPEG2_NVDEC_HWACCEL 0
-%define CONFIG_MPEG2_QSV_DECODER 0
-%define CONFIG_MPEG2_QSV_ENCODER 0
-%define CONFIG_MPEG2SVCD_MUXER 0
-%define CONFIG_MPEG2_V4L2M2M_DECODER 0
-%define CONFIG_MPEG2_VAAPI_ENCODER 0
-%define CONFIG_MPEG2_VAAPI_HWACCEL 0
-%define CONFIG_MPEG2_VDPAU_HWACCEL 0
-%define CONFIG_MPEG2VIDEO_DECODER 0
-%define CONFIG_MPEG2VIDEO_ENCODER 0
-%define CONFIG_MPEG2VIDEO_MUXER 0
-%define CONFIG_MPEG2_VIDEOTOOLBOX_HWACCEL 0
-%define CONFIG_MPEG2VOB_MUXER 0
-%define CONFIG_MPEG2_XVMC_HWACCEL 0
-%define CONFIG_MPEG4_CRYSTALHD_DECODER 0
-%define CONFIG_MPEG4_CUVID_DECODER 0
-%define CONFIG_MPEG4_DECODER 0
-%define CONFIG_MPEG4_ENCODER 0
-%define CONFIG_MPEG4_MEDIACODEC_DECODER 0
-%define CONFIG_MPEG4_MMAL_DECODER 0
-%define CONFIG_MPEG4_NVDEC_HWACCEL 0
-%define CONFIG_MPEG4_UNPACK_BFRAMES_BSF 0
-%define CONFIG_MPEG4_V4L2M2M_DECODER 0
-%define CONFIG_MPEG4_V4L2M2M_ENCODER 0
-%define CONFIG_MPEG4_VAAPI_HWACCEL 0
-%define CONFIG_MPEG4_VDPAU_HWACCEL 0
-%define CONFIG_MPEG4VIDEO_PARSER 0
-%define CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL 0
-%define CONFIG_MPEGAUDIO_PARSER 0
-%define CONFIG_MPEGPS_DEMUXER 0
-%define CONFIG_MPEGTS_DEMUXER 0
-%define CONFIG_MPEGTS_MUXER 0
-%define CONFIG_MPEGTSRAW_DEMUXER 0
-%define CONFIG_MPEGVIDEO_DECODER 0
-%define CONFIG_MPEGVIDEO_DEMUXER 0
-%define CONFIG_MPEGVIDEO_PARSER 0
-%define CONFIG_MPJPEG_DEMUXER 0
-%define CONFIG_MPJPEG_MUXER 0
-%define CONFIG_MPL2_DECODER 0
-%define CONFIG_MPL2_DEMUXER 0
-%define CONFIG_MPSUB_DEMUXER 0
-%define CONFIG_MPTESTSRC_FILTER 0
-%define CONFIG_MSA1_DECODER 0
-%define CONFIG_MSCC_DECODER 0
-%define CONFIG_MSF_DEMUXER 0
-%define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
-%define CONFIG_MSMPEG4V1_DECODER 0
-%define CONFIG_MSMPEG4V2_DECODER 0
-%define CONFIG_MSMPEG4V2_ENCODER 0
-%define CONFIG_MSMPEG4V3_DECODER 0
-%define CONFIG_MSMPEG4V3_ENCODER 0
-%define CONFIG_MSNWC_TCP_DEMUXER 0
-%define CONFIG_MSRLE_DECODER 0
-%define CONFIG_MSS1_DECODER 0
-%define CONFIG_MSS2_DECODER 0
-%define CONFIG_MSVIDEO1_DECODER 0
-%define CONFIG_MSVIDEO1_ENCODER 0
-%define CONFIG_MSZH_DECODER 0
-%define CONFIG_MTAF_DEMUXER 0
-%define CONFIG_MTS2_DECODER 0
-%define CONFIG_MTV_DEMUXER 0
-%define CONFIG_MUSX_DEMUXER 0
-%define CONFIG_MUXERS 0
-%define CONFIG_MVC1_DECODER 0
-%define CONFIG_MVC2_DECODER 0
-%define CONFIG_MV_DEMUXER 0
-%define CONFIG_MVI_DEMUXER 0
-%define CONFIG_MWSC_DECODER 0
-%define CONFIG_MXF_D10_MUXER 0
-%define CONFIG_MXF_DEMUXER 0
-%define CONFIG_MXF_MUXER 0
-%define CONFIG_MXF_OPATOM_MUXER 0
-%define CONFIG_MXG_DEMUXER 0
-%define CONFIG_MXPEG_DECODER 0
-%define CONFIG_NC_DEMUXER 0
-%define CONFIG_NEGATE_FILTER 0
-%define CONFIG_NELLYMOSER_DECODER 0
-%define CONFIG_NELLYMOSER_ENCODER 0
-%define CONFIG_NISTSPHERE_DEMUXER 0
-%define CONFIG_NLMEANS_FILTER 0
-%define CONFIG_NLMEANS_OPENCL_FILTER 0
-%define CONFIG_NNEDI_FILTER 0
-%define CONFIG_NOFORMAT_FILTER 0
-%define CONFIG_NOISE_BSF 0
-%define CONFIG_NOISE_FILTER 0
-%define CONFIG_NORMALIZE_FILTER 0
-%define CONFIG_NSP_DEMUXER 0
-%define CONFIG_NSV_DEMUXER 0
-%define CONFIG_NULL_FILTER 0
-%define CONFIG_NULL_MUXER 0
-%define CONFIG_NULLSINK_FILTER 0
-%define CONFIG_NULLSRC_FILTER 0
-%define CONFIG_NUT_DEMUXER 0
-%define CONFIG_NUT_MUXER 0
-%define CONFIG_NUV_DECODER 0
-%define CONFIG_NUV_DEMUXER 0
-%define CONFIG_NVENC_ENCODER 0
-%define CONFIG_NVENC_H264_ENCODER 0
-%define CONFIG_NVENC_HEVC_ENCODER 0
-%define CONFIG_OCR_FILTER 0
-%define CONFIG_OCV_FILTER 0
-%define CONFIG_OGA_MUXER 0
-%define CONFIG_OGG_DEMUXER 0
-%define CONFIG_OGG_MUXER 0
-%define CONFIG_OGV_MUXER 0
-%define CONFIG_OMA_DEMUXER 0
-%define CONFIG_OMA_MUXER 0
-%define CONFIG_ON2AVC_DECODER 0
-%define CONFIG_OPENAL_INDEV 0
-%define CONFIG_OPENCLSRC_FILTER 0
-%define CONFIG_OPENGL_OUTDEV 0
-%define CONFIG_OPUS_DECODER 0
-%define CONFIG_OPUS_ENCODER 0
-%define CONFIG_OPUS_MUXER 0
-%define CONFIG_OPUS_PARSER 0
-%define CONFIG_OSCILLOSCOPE_FILTER 0
-%define CONFIG_OSS_INDEV 0
-%define CONFIG_OSS_OUTDEV 0
-%define CONFIG_OUTDEVS 0
-%define CONFIG_OVERLAY_FILTER 0
-%define CONFIG_OVERLAY_OPENCL_FILTER 0
-%define CONFIG_OVERLAY_QSV_FILTER 0
-%define CONFIG_OWDENOISE_FILTER 0
-%define CONFIG_PAD_FILTER 0
-%define CONFIG_PAF_AUDIO_DECODER 0
-%define CONFIG_PAF_DEMUXER 0
-%define CONFIG_PAF_VIDEO_DECODER 0
-%define CONFIG_PAL100BARS_FILTER 0
-%define CONFIG_PAL75BARS_FILTER 0
-%define CONFIG_PALETTEGEN_FILTER 0
-%define CONFIG_PALETTEUSE_FILTER 0
-%define CONFIG_PAM_DECODER 0
-%define CONFIG_PAM_ENCODER 0
-%define CONFIG_PAN_FILTER 0
-%define CONFIG_PBM_DECODER 0
-%define CONFIG_PBM_ENCODER 0
-%define CONFIG_PCM_ALAW_AT_DECODER 0
-%define CONFIG_PCM_ALAW_AT_ENCODER 0
-%define CONFIG_PCM_ALAW_DECODER 0
-%define CONFIG_PCM_ALAW_DEMUXER 0
-%define CONFIG_PCM_ALAW_ENCODER 0
-%define CONFIG_PCM_ALAW_MUXER 0
-%define CONFIG_PCM_BLURAY_DECODER 0
-%define CONFIG_PCM_DVD_DECODER 0
-%define CONFIG_PCM_DVD_ENCODER 0
-%define CONFIG_PCM_F16LE_DECODER 0
-%define CONFIG_PCM_F24LE_DECODER 0
-%define CONFIG_PCM_F32BE_DECODER 0
-%define CONFIG_PCM_F32BE_DEMUXER 0
-%define CONFIG_PCM_F32BE_ENCODER 0
-%define CONFIG_PCM_F32BE_MUXER 0
-%define CONFIG_PCM_F32LE_DECODER 0
-%define CONFIG_PCM_F32LE_DEMUXER 0
-%define CONFIG_PCM_F32LE_ENCODER 0
-%define CONFIG_PCM_F32LE_MUXER 0
-%define CONFIG_PCM_F64BE_DECODER 0
-%define CONFIG_PCM_F64BE_DEMUXER 0
-%define CONFIG_PCM_F64BE_ENCODER 0
-%define CONFIG_PCM_F64BE_MUXER 0
-%define CONFIG_PCM_F64LE_DECODER 0
-%define CONFIG_PCM_F64LE_DEMUXER 0
-%define CONFIG_PCM_F64LE_ENCODER 0
-%define CONFIG_PCM_F64LE_MUXER 0
-%define CONFIG_PCM_LXF_DECODER 0
-%define CONFIG_PCM_MULAW_AT_DECODER 0
-%define CONFIG_PCM_MULAW_AT_ENCODER 0
-%define CONFIG_PCM_MULAW_DECODER 0
-%define CONFIG_PCM_MULAW_DEMUXER 0
-%define CONFIG_PCM_MULAW_ENCODER 0
-%define CONFIG_PCM_MULAW_MUXER 0
-%define CONFIG_PCM_S16BE_DECODER 0
-%define CONFIG_PCM_S16BE_DEMUXER 0
-%define CONFIG_PCM_S16BE_ENCODER 0
-%define CONFIG_PCM_S16BE_MUXER 0
-%define CONFIG_PCM_S16BE_PLANAR_DECODER 0
-%define CONFIG_PCM_S16BE_PLANAR_ENCODER 0
-%define CONFIG_PCM_S16LE_DECODER 0
-%define CONFIG_PCM_S16LE_DEMUXER 0
-%define CONFIG_PCM_S16LE_ENCODER 0
-%define CONFIG_PCM_S16LE_MUXER 0
-%define CONFIG_PCM_S16LE_PLANAR_DECODER 0
-%define CONFIG_PCM_S16LE_PLANAR_ENCODER 0
-%define CONFIG_PCM_S24BE_DECODER 0
-%define CONFIG_PCM_S24BE_DEMUXER 0
-%define CONFIG_PCM_S24BE_ENCODER 0
-%define CONFIG_PCM_S24BE_MUXER 0
-%define CONFIG_PCM_S24DAUD_DECODER 0
-%define CONFIG_PCM_S24DAUD_ENCODER 0
-%define CONFIG_PCM_S24LE_DECODER 0
-%define CONFIG_PCM_S24LE_DEMUXER 0
-%define CONFIG_PCM_S24LE_ENCODER 0
-%define CONFIG_PCM_S24LE_MUXER 0
-%define CONFIG_PCM_S24LE_PLANAR_DECODER 0
-%define CONFIG_PCM_S24LE_PLANAR_ENCODER 0
-%define CONFIG_PCM_S32BE_DECODER 0
-%define CONFIG_PCM_S32BE_DEMUXER 0
-%define CONFIG_PCM_S32BE_ENCODER 0
-%define CONFIG_PCM_S32BE_MUXER 0
-%define CONFIG_PCM_S32LE_DECODER 0
-%define CONFIG_PCM_S32LE_DEMUXER 0
-%define CONFIG_PCM_S32LE_ENCODER 0
-%define CONFIG_PCM_S32LE_MUXER 0
-%define CONFIG_PCM_S32LE_PLANAR_DECODER 0
-%define CONFIG_PCM_S32LE_PLANAR_ENCODER 0
-%define CONFIG_PCM_S64BE_DECODER 0
-%define CONFIG_PCM_S64BE_ENCODER 0
-%define CONFIG_PCM_S64LE_DECODER 0
-%define CONFIG_PCM_S64LE_ENCODER 0
-%define CONFIG_PCM_S8_DECODER 0
-%define CONFIG_PCM_S8_DEMUXER 0
-%define CONFIG_PCM_S8_ENCODER 0
-%define CONFIG_PCM_S8_MUXER 0
-%define CONFIG_PCM_S8_PLANAR_DECODER 0
-%define CONFIG_PCM_S8_PLANAR_ENCODER 0
-%define CONFIG_PCM_U16BE_DECODER 0
-%define CONFIG_PCM_U16BE_DEMUXER 0
-%define CONFIG_PCM_U16BE_ENCODER 0
-%define CONFIG_PCM_U16BE_MUXER 0
-%define CONFIG_PCM_U16LE_DECODER 0
-%define CONFIG_PCM_U16LE_DEMUXER 0
-%define CONFIG_PCM_U16LE_ENCODER 0
-%define CONFIG_PCM_U16LE_MUXER 0
-%define CONFIG_PCM_U24BE_DECODER 0
-%define CONFIG_PCM_U24BE_DEMUXER 0
-%define CONFIG_PCM_U24BE_ENCODER 0
-%define CONFIG_PCM_U24BE_MUXER 0
-%define CONFIG_PCM_U24LE_DECODER 0
-%define CONFIG_PCM_U24LE_DEMUXER 0
-%define CONFIG_PCM_U24LE_ENCODER 0
-%define CONFIG_PCM_U24LE_MUXER 0
-%define CONFIG_PCM_U32BE_DECODER 0
-%define CONFIG_PCM_U32BE_DEMUXER 0
-%define CONFIG_PCM_U32BE_ENCODER 0
-%define CONFIG_PCM_U32BE_MUXER 0
-%define CONFIG_PCM_U32LE_DECODER 0
-%define CONFIG_PCM_U32LE_DEMUXER 0
-%define CONFIG_PCM_U32LE_ENCODER 0
-%define CONFIG_PCM_U32LE_MUXER 0
-%define CONFIG_PCM_U8_DECODER 0
-%define CONFIG_PCM_U8_DEMUXER 0
-%define CONFIG_PCM_U8_ENCODER 0
-%define CONFIG_PCM_U8_MUXER 0
-%define CONFIG_PCM_VIDC_DECODER 0
-%define CONFIG_PCM_VIDC_DEMUXER 0
-%define CONFIG_PCM_VIDC_ENCODER 0
-%define CONFIG_PCM_VIDC_MUXER 0
-%define CONFIG_PCM_ZORK_DECODER 0
-%define CONFIG_PCX_DECODER 0
-%define CONFIG_PCX_ENCODER 0
-%define CONFIG_PERMS_FILTER 0
-%define CONFIG_PERSPECTIVE_FILTER 0
-%define CONFIG_PGM_DECODER 0
-%define CONFIG_PGM_ENCODER 0
-%define CONFIG_PGMYUV_DECODER 0
-%define CONFIG_PGMYUV_ENCODER 0
-%define CONFIG_PGSSUB_DECODER 0
-%define CONFIG_PHASE_FILTER 0
-%define CONFIG_PICTOR_DECODER 0
-%define CONFIG_PIPE_PROTOCOL 0
-%define CONFIG_PIXDESCTEST_FILTER 0
-%define CONFIG_PIXLET_DECODER 0
-%define CONFIG_PIXSCOPE_FILTER 0
-%define CONFIG_PJS_DECODER 0
-%define CONFIG_PJS_DEMUXER 0
-%define CONFIG_PMP_DEMUXER 0
-%define CONFIG_PNG_DECODER 0
-%define CONFIG_PNG_ENCODER 0
-%define CONFIG_PNG_PARSER 0
-%define CONFIG_PNM_PARSER 0
-%define CONFIG_PP7_FILTER 0
-%define CONFIG_PP_FILTER 0
-%define CONFIG_PPM_DECODER 0
-%define CONFIG_PPM_ENCODER 0
-%define CONFIG_PREMULTIPLY_FILTER 0
-%define CONFIG_PREWITT_FILTER 0
-%define CONFIG_PREWITT_OPENCL_FILTER 0
-%define CONFIG_PROCAMP_VAAPI_FILTER 0
-%define CONFIG_PROGRAM_OPENCL_FILTER 0
-%define CONFIG_PROMPEG_PROTOCOL 0
-%define CONFIG_PRORES_AW_ENCODER 0
-%define CONFIG_PRORES_DECODER 0
-%define CONFIG_PRORES_ENCODER 0
-%define CONFIG_PRORES_KS_ENCODER 0
-%define CONFIG_PRORES_METADATA_BSF 0
-%define CONFIG_PROSUMER_DECODER 0
-%define CONFIG_PROTOCOLS 0
-%define CONFIG_PSD_DECODER 0
-%define CONFIG_PSEUDOCOLOR_FILTER 0
-%define CONFIG_PSNR_FILTER 0
-%define CONFIG_PSP_MUXER 0
-%define CONFIG_PTX_DECODER 0
-%define CONFIG_PULLUP_FILTER 0
-%define CONFIG_PULSE_INDEV 0
-%define CONFIG_PULSE_OUTDEV 0
-%define CONFIG_PVA_DEMUXER 0
-%define CONFIG_PVF_DEMUXER 0
-%define CONFIG_QCELP_DECODER 0
-%define CONFIG_QCP_DEMUXER 0
-%define CONFIG_QDM2_AT_DECODER 0
-%define CONFIG_QDM2_DECODER 0
-%define CONFIG_QDMC_AT_DECODER 0
-%define CONFIG_QDMC_DECODER 0
-%define CONFIG_QDRAW_DECODER 0
-%define CONFIG_QPEG_DECODER 0
-%define CONFIG_QP_FILTER 0
-%define CONFIG_QTRLE_DECODER 0
-%define CONFIG_QTRLE_ENCODER 0
-%define CONFIG_R10K_DECODER 0
-%define CONFIG_R10K_ENCODER 0
-%define CONFIG_R210_DECODER 0
-%define CONFIG_R210_ENCODER 0
-%define CONFIG_R3D_DEMUXER 0
-%define CONFIG_RA_144_DECODER 0
-%define CONFIG_RA_144_ENCODER 0
-%define CONFIG_RA_288_DECODER 0
-%define CONFIG_RALF_DECODER 0
-%define CONFIG_RANDOM_FILTER 0
-%define CONFIG_RASC_DECODER 0
-%define CONFIG_RAWVIDEO_DECODER 0
-%define CONFIG_RAWVIDEO_DEMUXER 0
-%define CONFIG_RAWVIDEO_ENCODER 0
-%define CONFIG_RAWVIDEO_MUXER 0
-%define CONFIG_READEIA608_FILTER 0
-%define CONFIG_READVITC_FILTER 0
-%define CONFIG_REALTEXT_DECODER 0
-%define CONFIG_REALTEXT_DEMUXER 0
-%define CONFIG_REALTIME_FILTER 0
-%define CONFIG_REDSPARK_DEMUXER 0
-%define CONFIG_REMAP_FILTER 0
-%define CONFIG_REMOVE_EXTRADATA_BSF 0
-%define CONFIG_REMOVEGRAIN_FILTER 0
-%define CONFIG_REMOVELOGO_FILTER 0
-%define CONFIG_REPEATFIELDS_FILTER 0
-%define CONFIG_REPLAYGAIN_FILTER 0
-%define CONFIG_RESAMPLE_FILTER 0
-%define CONFIG_REVERSE_FILTER 0
-%define CONFIG_RGBASHIFT_FILTER 0
-%define CONFIG_RGBTESTSRC_FILTER 0
-%define CONFIG_RL2_DECODER 0
-%define CONFIG_RL2_DEMUXER 0
-%define CONFIG_RM_DEMUXER 0
-%define CONFIG_RM_MUXER 0
-%define CONFIG_ROBERTS_FILTER 0
-%define CONFIG_ROBERTS_OPENCL_FILTER 0
-%define CONFIG_ROQ_DECODER 0
-%define CONFIG_ROQ_DEMUXER 0
-%define CONFIG_ROQ_DPCM_DECODER 0
-%define CONFIG_ROQ_DPCM_ENCODER 0
-%define CONFIG_ROQ_ENCODER 0
-%define CONFIG_ROQ_MUXER 0
-%define CONFIG_ROTATE_FILTER 0
-%define CONFIG_RPL_DEMUXER 0
-%define CONFIG_RPZA_DECODER 0
-%define CONFIG_RSCC_DECODER 0
-%define CONFIG_RSD_DEMUXER 0
-%define CONFIG_RSO_DEMUXER 0
-%define CONFIG_RSO_MUXER 0
-%define CONFIG_RTMPE_PROTOCOL 0
-%define CONFIG_RTMP_PROTOCOL 0
-%define CONFIG_RTMPS_PROTOCOL 0
-%define CONFIG_RTMPTE_PROTOCOL 0
-%define CONFIG_RTMPT_PROTOCOL 0
-%define CONFIG_RTMPTS_PROTOCOL 0
-%define CONFIG_RTP_DEMUXER 0
-%define CONFIG_RTP_MPEGTS_MUXER 0
-%define CONFIG_RTP_MUXER 0
-%define CONFIG_RTP_PROTOCOL 0
-%define CONFIG_RTSP_DEMUXER 0
-%define CONFIG_RTSP_MUXER 0
-%define CONFIG_RUBBERBAND_FILTER 0
-%define CONFIG_RV10_DECODER 0
-%define CONFIG_RV10_ENCODER 0
-%define CONFIG_RV20_DECODER 0
-%define CONFIG_RV20_ENCODER 0
-%define CONFIG_RV30_DECODER 0
-%define CONFIG_RV30_PARSER 0
-%define CONFIG_RV40_DECODER 0
-%define CONFIG_RV40_PARSER 0
-%define CONFIG_S302M_DECODER 0
-%define CONFIG_S302M_ENCODER 0
-%define CONFIG_S337M_DEMUXER 0
-%define CONFIG_SAB_FILTER 0
-%define CONFIG_SAMI_DECODER 0
-%define CONFIG_SAMI_DEMUXER 0
-%define CONFIG_SANM_DECODER 0
-%define CONFIG_SAP_DEMUXER 0
-%define CONFIG_SAP_MUXER 0
-%define CONFIG_SBC_DECODER 0
-%define CONFIG_SBC_DEMUXER 0
-%define CONFIG_SBC_ENCODER 0
-%define CONFIG_SBC_MUXER 0
-%define CONFIG_SBC_PARSER 0
-%define CONFIG_SBG_DEMUXER 0
-%define CONFIG_SCALE2REF_FILTER 0
-%define CONFIG_SCALE_CUDA_FILTER 0
-%define CONFIG_SCALE_FILTER 0
-%define CONFIG_SCALE_NPP_FILTER 0
-%define CONFIG_SCALE_QSV_FILTER 0
-%define CONFIG_SCALE_VAAPI_FILTER 0
-%define CONFIG_SCC_DEMUXER 0
-%define CONFIG_SCC_MUXER 0
-%define CONFIG_SCPR_DECODER 0
-%define CONFIG_SCREENPRESSO_DECODER 0
-%define CONFIG_SCTP_PROTOCOL 0
-%define CONFIG_SDL2_OUTDEV 0
-%define CONFIG_SDP_DEMUXER 0
-%define CONFIG_SDR2_DEMUXER 0
-%define CONFIG_SDS_DEMUXER 0
-%define CONFIG_SDX2_DPCM_DECODER 0
-%define CONFIG_SDX_DEMUXER 0
-%define CONFIG_SEGAFILM_DEMUXER 0
-%define CONFIG_SEGAFILM_MUXER 0
-%define CONFIG_SEGMENT_MUXER 0
-%define CONFIG_SELECT_FILTER 0
-%define CONFIG_SELECTIVECOLOR_FILTER 0
-%define CONFIG_SENDCMD_FILTER 0
-%define CONFIG_SEPARATEFIELDS_FILTER 0
-%define CONFIG_SER_DEMUXER 0
-%define CONFIG_SETDAR_FILTER 0
-%define CONFIG_SETFIELD_FILTER 0
-%define CONFIG_SETPARAMS_FILTER 0
-%define CONFIG_SETPTS_FILTER 0
-%define CONFIG_SETRANGE_FILTER 0
-%define CONFIG_SETSAR_FILTER 0
-%define CONFIG_SETTB_FILTER 0
-%define CONFIG_SGI_DECODER 0
-%define CONFIG_SGI_ENCODER 0
-%define CONFIG_SGIRLE_DECODER 0
-%define CONFIG_SHARPNESS_VAAPI_FILTER 0
-%define CONFIG_SHEERVIDEO_DECODER 0
-%define CONFIG_SHORTEN_DECODER 0
-%define CONFIG_SHORTEN_DEMUXER 0
-%define CONFIG_SHOWCQT_FILTER 0
-%define CONFIG_SHOWFREQS_FILTER 0
-%define CONFIG_SHOWINFO_FILTER 0
-%define CONFIG_SHOWPALETTE_FILTER 0
-%define CONFIG_SHOWSPATIAL_FILTER 0
-%define CONFIG_SHOWSPECTRUM_FILTER 0
-%define CONFIG_SHOWSPECTRUMPIC_FILTER 0
-%define CONFIG_SHOWVOLUME_FILTER 0
-%define CONFIG_SHOWWAVES_FILTER 0
-%define CONFIG_SHOWWAVESPIC_FILTER 0
-%define CONFIG_SHUFFLEFRAMES_FILTER 0
-%define CONFIG_SHUFFLEPLANES_FILTER 0
-%define CONFIG_SIDECHAINCOMPRESS_FILTER 0
-%define CONFIG_SIDECHAINGATE_FILTER 0
-%define CONFIG_SIDEDATA_FILTER 0
-%define CONFIG_SIFF_DEMUXER 0
-%define CONFIG_SIGNALSTATS_FILTER 0
-%define CONFIG_SIGNATURE_FILTER 0
-%define CONFIG_SILENCEDETECT_FILTER 0
-%define CONFIG_SILENCEREMOVE_FILTER 0
-%define CONFIG_SINC_FILTER 0
-%define CONFIG_SINE_FILTER 0
-%define CONFIG_SINGLEJPEG_MUXER 0
-%define CONFIG_SIPR_DECODER 0
-%define CONFIG_SIPR_PARSER 0
-%define CONFIG_SLN_DEMUXER 0
-%define CONFIG_SMACKAUD_DECODER 0
-%define CONFIG_SMACKER_DECODER 0
-%define CONFIG_SMACKER_DEMUXER 0
-%define CONFIG_SMARTBLUR_FILTER 0
-%define CONFIG_SMC_DECODER 0
-%define CONFIG_SMJPEG_DEMUXER 0
-%define CONFIG_SMJPEG_MUXER 0
-%define CONFIG_SMOOTHSTREAMING_MUXER 0
-%define CONFIG_SMPTEBARS_FILTER 0
-%define CONFIG_SMPTEHDBARS_FILTER 0
-%define CONFIG_SMUSH_DEMUXER 0
-%define CONFIG_SMVJPEG_DECODER 0
-%define CONFIG_SNDIO_INDEV 0
-%define CONFIG_SNDIO_OUTDEV 0
-%define CONFIG_SNOW_DECODER 0
-%define CONFIG_SNOW_ENCODER 0
-%define CONFIG_SOBEL_FILTER 0
-%define CONFIG_SOBEL_OPENCL_FILTER 0
-%define CONFIG_SOFALIZER_FILTER 0
-%define CONFIG_SOL_DEMUXER 0
-%define CONFIG_SOL_DPCM_DECODER 0
-%define CONFIG_SONIC_DECODER 0
-%define CONFIG_SONIC_ENCODER 0
-%define CONFIG_SONIC_LS_ENCODER 0
-%define CONFIG_SOX_DEMUXER 0
-%define CONFIG_SOX_MUXER 0
-%define CONFIG_SP5X_DECODER 0
-%define CONFIG_SPDIF_DEMUXER 0
-%define CONFIG_SPDIF_MUXER 0
-%define CONFIG_SPECTRUMSYNTH_FILTER 0
-%define CONFIG_SPEEDHQ_DECODER 0
-%define CONFIG_SPLIT_FILTER 0
-%define CONFIG_SPP_FILTER 0
-%define CONFIG_SPX_MUXER 0
-%define CONFIG_SR_FILTER 0
-%define CONFIG_SRGC_DECODER 0
-%define CONFIG_SRT_DECODER 0
-%define CONFIG_SRT_DEMUXER 0
-%define CONFIG_SRT_ENCODER 0
-%define CONFIG_SRT_MUXER 0
-%define CONFIG_SRTP_PROTOCOL 0
-%define CONFIG_SSA_DECODER 0
-%define CONFIG_SSA_ENCODER 0
-%define CONFIG_SSIM_FILTER 0
-%define CONFIG_STEREO3D_FILTER 0
-%define CONFIG_STEREOTOOLS_FILTER 0
-%define CONFIG_STEREOWIDEN_FILTER 0
-%define CONFIG_STL_DECODER 0
-%define CONFIG_STL_DEMUXER 0
-%define CONFIG_STR_DEMUXER 0
-%define CONFIG_STREAM_SEGMENT_MUXER 0
-%define CONFIG_STREAMSELECT_FILTER 0
-%define CONFIG_SUBFILE_PROTOCOL 0
-%define CONFIG_SUBRIP_DECODER 0
-%define CONFIG_SUBRIP_ENCODER 0
-%define CONFIG_SUBTITLES_FILTER 0
-%define CONFIG_SUBVIEWER1_DECODER 0
-%define CONFIG_SUBVIEWER1_DEMUXER 0
-%define CONFIG_SUBVIEWER_DECODER 0
-%define CONFIG_SUBVIEWER_DEMUXER 0
-%define CONFIG_SUNRAST_DECODER 0
-%define CONFIG_SUNRAST_ENCODER 0
-%define CONFIG_SUP_DEMUXER 0
-%define CONFIG_SUPER2XSAI_FILTER 0
-%define CONFIG_SUPEREQUALIZER_FILTER 0
-%define CONFIG_SUP_MUXER 0
-%define CONFIG_SURROUND_FILTER 0
-%define CONFIG_SVAG_DEMUXER 0
-%define CONFIG_SVQ1_DECODER 0
-%define CONFIG_SVQ1_ENCODER 0
-%define CONFIG_SVQ3_DECODER 0
-%define CONFIG_SWAPRECT_FILTER 0
-%define CONFIG_SWAPUV_FILTER 0
-%define CONFIG_SWF_DEMUXER 0
-%define CONFIG_SWF_MUXER 0
-%define CONFIG_TAK_DECODER 0
-%define CONFIG_TAK_DEMUXER 0
-%define CONFIG_TAK_PARSER 0
-%define CONFIG_TARGA_DECODER 0
-%define CONFIG_TARGA_ENCODER 0
-%define CONFIG_TARGA_Y216_DECODER 0
-%define CONFIG_TBLEND_FILTER 0
-%define CONFIG_TCP_PROTOCOL 0
-%define CONFIG_TDSC_DECODER 0
-%define CONFIG_TEDCAPTIONS_DEMUXER 0
-%define CONFIG_TEE_MUXER 0
-%define CONFIG_TEE_PROTOCOL 0
-%define CONFIG_TELECINE_FILTER 0
-%define CONFIG_TESTSRC2_FILTER 0
-%define CONFIG_TESTSRC_FILTER 0
-%define CONFIG_TEXT2MOVSUB_BSF 0
-%define CONFIG_TEXT_DECODER 0
-%define CONFIG_TEXT_ENCODER 0
-%define CONFIG_TG2_MUXER 0
-%define CONFIG_TGP_MUXER 0
-%define CONFIG_THEORA_DECODER 0
-%define CONFIG_THP_DECODER 0
-%define CONFIG_THP_DEMUXER 0
-%define CONFIG_THREEDOSTR_DEMUXER 0
-%define CONFIG_THRESHOLD_FILTER 0
-%define CONFIG_THUMBNAIL_CUDA_FILTER 0
-%define CONFIG_THUMBNAIL_FILTER 0
-%define CONFIG_TIERTEXSEQ_DEMUXER 0
-%define CONFIG_TIERTEXSEQVIDEO_DECODER 0
-%define CONFIG_TIFF_DECODER 0
-%define CONFIG_TIFF_ENCODER 0
-%define CONFIG_TILE_FILTER 0
-%define CONFIG_TINTERLACE_FILTER 0
-%define CONFIG_TLS_PROTOCOL 0
-%define CONFIG_TLUT2_FILTER 0
-%define CONFIG_TMIX_FILTER 0
-%define CONFIG_TMV_DECODER 0
-%define CONFIG_TMV_DEMUXER 0
-%define CONFIG_TONEMAP_FILTER 0
-%define CONFIG_TONEMAP_OPENCL_FILTER 0
-%define CONFIG_TPAD_FILTER 0
-%define CONFIG_TRACE_HEADERS_BSF 0
-%define CONFIG_TRANSPOSE_FILTER 0
-%define CONFIG_TRANSPOSE_NPP_FILTER 0
-%define CONFIG_TRANSPOSE_OPENCL_FILTER 0
-%define CONFIG_TRANSPOSE_VAAPI_FILTER 0
-%define CONFIG_TREBLE_FILTER 0
-%define CONFIG_TREMOLO_FILTER 0
-%define CONFIG_TRIM_FILTER 0
-%define CONFIG_TRUEHD_CORE_BSF 0
-%define CONFIG_TRUEHD_DECODER 0
-%define CONFIG_TRUEHD_DEMUXER 0
-%define CONFIG_TRUEHD_ENCODER 0
-%define CONFIG_TRUEHD_MUXER 0
-%define CONFIG_TRUEMOTION1_DECODER 0
-%define CONFIG_TRUEMOTION2_DECODER 0
-%define CONFIG_TRUEMOTION2RT_DECODER 0
-%define CONFIG_TRUESPEECH_DECODER 0
-%define CONFIG_TSCC2_DECODER 0
-%define CONFIG_TSCC_DECODER 0
-%define CONFIG_TTA_DECODER 0
-%define CONFIG_TTA_DEMUXER 0
-%define CONFIG_TTA_ENCODER 0
-%define CONFIG_TTA_MUXER 0
-%define CONFIG_TTY_DEMUXER 0
-%define CONFIG_TWINVQ_DECODER 0
-%define CONFIG_TXD_DECODER 0
-%define CONFIG_TXD_DEMUXER 0
-%define CONFIG_TY_DEMUXER 0
-%define CONFIG_UDPLITE_PROTOCOL 0
-%define CONFIG_UDP_PROTOCOL 0
-%define CONFIG_ULTI_DECODER 0
-%define CONFIG_UNCODEDFRAMECRC_MUXER 0
-%define CONFIG_UNIX_PROTOCOL 0
-%define CONFIG_UNPREMULTIPLY_FILTER 0
-%define CONFIG_UNSHARP_FILTER 0
-%define CONFIG_UNSHARP_OPENCL_FILTER 0
-%define CONFIG_USPP_FILTER 0
-%define CONFIG_UTVIDEO_DECODER 0
-%define CONFIG_UTVIDEO_ENCODER 0
-%define CONFIG_V210_DECODER 0
-%define CONFIG_V210_DEMUXER 0
-%define CONFIG_V210_ENCODER 0
-%define CONFIG_V210X_DECODER 0
-%define CONFIG_V210X_DEMUXER 0
-%define CONFIG_V308_DECODER 0
-%define CONFIG_V308_ENCODER 0
-%define CONFIG_V408_DECODER 0
-%define CONFIG_V408_ENCODER 0
-%define CONFIG_V410_DECODER 0
-%define CONFIG_V410_ENCODER 0
-%define CONFIG_V4L2_INDEV 0
-%define CONFIG_V4L2_OUTDEV 0
-%define CONFIG_VAG_DEMUXER 0
-%define CONFIG_VAGUEDENOISER_FILTER 0
-%define CONFIG_VAPOURSYNTH_DEMUXER 0
-%define CONFIG_VB_DECODER 0
-%define CONFIG_VBLE_DECODER 0
-%define CONFIG_VC1_CRYSTALHD_DECODER 0
-%define CONFIG_VC1_CUVID_DECODER 0
-%define CONFIG_VC1_D3D11VA2_HWACCEL 0
-%define CONFIG_VC1_D3D11VA_HWACCEL 0
-%define CONFIG_VC1_DECODER 0
-%define CONFIG_VC1_DEMUXER 0
-%define CONFIG_VC1_DXVA2_HWACCEL 0
-%define CONFIG_VC1IMAGE_DECODER 0
-%define CONFIG_VC1_MMAL_DECODER 0
-%define CONFIG_VC1_MUXER 0
-%define CONFIG_VC1_NVDEC_HWACCEL 0
-%define CONFIG_VC1_PARSER 0
-%define CONFIG_VC1_QSV_DECODER 0
-%define CONFIG_VC1T_DEMUXER 0
-%define CONFIG_VC1T_MUXER 0
-%define CONFIG_VC1_V4L2M2M_DECODER 0
-%define CONFIG_VC1_VAAPI_HWACCEL 0
-%define CONFIG_VC1_VDPAU_HWACCEL 0
-%define CONFIG_VC2_ENCODER 0
-%define CONFIG_VCR1_DECODER 0
-%define CONFIG_VECTORSCOPE_FILTER 0
-%define CONFIG_VFLIP_FILTER 0
-%define CONFIG_VFRDET_FILTER 0
-%define CONFIG_VFWCAP_INDEV 0
-%define CONFIG_VIBRANCE_FILTER 0
-%define CONFIG_VIBRATO_FILTER 0
-%define CONFIG_VIDSTABDETECT_FILTER 0
-%define CONFIG_VIDSTABTRANSFORM_FILTER 0
-%define CONFIG_VIGNETTE_FILTER 0
-%define CONFIG_VIVIDAS_DEMUXER 0
-%define CONFIG_VIVO_DEMUXER 0
-%define CONFIG_VMAFMOTION_FILTER 0
-%define CONFIG_VMDAUDIO_DECODER 0
-%define CONFIG_VMD_DEMUXER 0
-%define CONFIG_VMDVIDEO_DECODER 0
-%define CONFIG_VMNC_DECODER 0
-%define CONFIG_VOBSUB_DEMUXER 0
-%define CONFIG_VOC_DEMUXER 0
-%define CONFIG_VOC_MUXER 0
-%define CONFIG_VOLUMEDETECT_FILTER 0
-%define CONFIG_VOLUME_FILTER 0
-%define CONFIG_VORBIS_DECODER 0
-%define CONFIG_VORBIS_ENCODER 0
-%define CONFIG_VORBIS_PARSER 0
-%define CONFIG_VP3_DECODER 0
-%define CONFIG_VP3_PARSER 0
-%define CONFIG_VP4_DECODER 0
-%define CONFIG_VP5_DECODER 0
-%define CONFIG_VP6A_DECODER 0
-%define CONFIG_VP6_DECODER 0
-%define CONFIG_VP6F_DECODER 0
-%define CONFIG_VP7_DECODER 0
-%define CONFIG_VP8_CUVID_DECODER 0
-%define CONFIG_VP8_MEDIACODEC_DECODER 0
-%define CONFIG_VP8_NVDEC_HWACCEL 0
-%define CONFIG_VP8_QSV_DECODER 0
-%define CONFIG_VP8_RKMPP_DECODER 0
-%define CONFIG_VP8_V4L2M2M_DECODER 0
-%define CONFIG_VP8_V4L2M2M_ENCODER 0
-%define CONFIG_VP8_VAAPI_ENCODER 0
-%define CONFIG_VP8_VAAPI_HWACCEL 0
-%define CONFIG_VP9_CUVID_DECODER 0
-%define CONFIG_VP9_D3D11VA2_HWACCEL 0
-%define CONFIG_VP9_D3D11VA_HWACCEL 0
-%define CONFIG_VP9_DXVA2_HWACCEL 0
-%define CONFIG_VP9_MEDIACODEC_DECODER 0
-%define CONFIG_VP9_METADATA_BSF 0
-%define CONFIG_VP9_NVDEC_HWACCEL 0
-%define CONFIG_VP9_RAW_REORDER_BSF 0
-%define CONFIG_VP9_RKMPP_DECODER 0
-%define CONFIG_VP9_SUPERFRAME_BSF 0
-%define CONFIG_VP9_V4L2M2M_DECODER 0
-%define CONFIG_VP9_VAAPI_ENCODER 0
-%define CONFIG_VP9_VAAPI_HWACCEL 0
-%define CONFIG_VP9_VDPAU_HWACCEL 0
-%define CONFIG_VPK_DEMUXER 0
-%define CONFIG_VPLAYER_DECODER 0
-%define CONFIG_VPLAYER_DEMUXER 0
-%define CONFIG_VPP_QSV_FILTER 0
-%define CONFIG_VQA_DECODER 0
-%define CONFIG_VQF_DEMUXER 0
-%define CONFIG_VSTACK_FILTER 0
-%define CONFIG_W3FDIF_FILTER 0
-%define CONFIG_W64_DEMUXER 0
-%define CONFIG_W64_MUXER 0
-%define CONFIG_WAV_DEMUXER 0
-%define CONFIG_WAVEFORM_FILTER 0
-%define CONFIG_WAV_MUXER 0
-%define CONFIG_WAVPACK_DECODER 0
-%define CONFIG_WAVPACK_ENCODER 0
-%define CONFIG_WC3_DEMUXER 0
-%define CONFIG_WCMV_DECODER 0
-%define CONFIG_WEAVE_FILTER 0
-%define CONFIG_WEBM_CHUNK_MUXER 0
-%define CONFIG_WEBM_DASH_MANIFEST_DEMUXER 0
-%define CONFIG_WEBM_DASH_MANIFEST_MUXER 0
-%define CONFIG_WEBM_MUXER 0
-%define CONFIG_WEBP_DECODER 0
-%define CONFIG_WEBP_MUXER 0
-%define CONFIG_WEBVTT_DECODER 0
-%define CONFIG_WEBVTT_DEMUXER 0
-%define CONFIG_WEBVTT_ENCODER 0
-%define CONFIG_WEBVTT_MUXER 0
-%define CONFIG_WMALOSSLESS_DECODER 0
-%define CONFIG_WMAPRO_DECODER 0
-%define CONFIG_WMAV1_DECODER 0
-%define CONFIG_WMAV1_ENCODER 0
-%define CONFIG_WMAV2_DECODER 0
-%define CONFIG_WMAV2_ENCODER 0
-%define CONFIG_WMAVOICE_DECODER 0
-%define CONFIG_WMV1_DECODER 0
-%define CONFIG_WMV1_ENCODER 0
-%define CONFIG_WMV2_DECODER 0
-%define CONFIG_WMV2_ENCODER 0
-%define CONFIG_WMV3_CRYSTALHD_DECODER 0
-%define CONFIG_WMV3_D3D11VA2_HWACCEL 0
-%define CONFIG_WMV3_D3D11VA_HWACCEL 0
-%define CONFIG_WMV3_DECODER 0
-%define CONFIG_WMV3_DXVA2_HWACCEL 0
-%define CONFIG_WMV3IMAGE_DECODER 0
-%define CONFIG_WMV3_NVDEC_HWACCEL 0
-%define CONFIG_WMV3_VAAPI_HWACCEL 0
-%define CONFIG_WMV3_VDPAU_HWACCEL 0
-%define CONFIG_WNV1_DECODER 0
-%define CONFIG_WRAPPED_AVFRAME_DECODER 0
-%define CONFIG_WRAPPED_AVFRAME_ENCODER 0
-%define CONFIG_WSAUD_DEMUXER 0
-%define CONFIG_WSD_DEMUXER 0
-%define CONFIG_WS_SND1_DECODER 0
-%define CONFIG_WSVQA_DEMUXER 0
-%define CONFIG_WTV_DEMUXER 0
-%define CONFIG_WTV_MUXER 0
-%define CONFIG_WV_DEMUXER 0
-%define CONFIG_WVE_DEMUXER 0
-%define CONFIG_WV_MUXER 0
-%define CONFIG_XA_DEMUXER 0
-%define CONFIG_XAN_DPCM_DECODER 0
-%define CONFIG_XAN_WC3_DECODER 0
-%define CONFIG_XAN_WC4_DECODER 0
-%define CONFIG_XBIN_DECODER 0
-%define CONFIG_XBIN_DEMUXER 0
-%define CONFIG_XBM_DECODER 0
-%define CONFIG_XBM_ENCODER 0
-%define CONFIG_XBR_FILTER 0
-%define CONFIG_XCBGRAB_INDEV 0
-%define CONFIG_XFACE_DECODER 0
-%define CONFIG_XFACE_ENCODER 0
-%define CONFIG_XL_DECODER 0
-%define CONFIG_XMA1_DECODER 0
-%define CONFIG_XMA2_DECODER 0
-%define CONFIG_XMA_PARSER 0
-%define CONFIG_XMEDIAN_FILTER 0
-%define CONFIG_XMV_DEMUXER 0
-%define CONFIG_XPM_DECODER 0
-%define CONFIG_XSTACK_FILTER 0
-%define CONFIG_XSUB_DECODER 0
-%define CONFIG_XSUB_ENCODER 0
-%define CONFIG_XVAG_DEMUXER 0
-%define CONFIG_XV_OUTDEV 0
-%define CONFIG_XWD_DECODER 0
-%define CONFIG_XWD_ENCODER 0
-%define CONFIG_XWMA_DEMUXER 0
-%define CONFIG_Y41P_DECODER 0
-%define CONFIG_Y41P_ENCODER 0
-%define CONFIG_YADIF_CUDA_FILTER 0
-%define CONFIG_YADIF_FILTER 0
-%define CONFIG_YLC_DECODER 0
-%define CONFIG_YOP_DECODER 0
-%define CONFIG_YOP_DEMUXER 0
-%define CONFIG_YUV4_DECODER 0
-%define CONFIG_YUV4_ENCODER 0
-%define CONFIG_YUV4MPEGPIPE_DEMUXER 0
-%define CONFIG_YUV4MPEGPIPE_MUXER 0
-%define CONFIG_YUVTESTSRC_FILTER 0
-%define CONFIG_ZERO12V_DECODER 0
-%define CONFIG_ZEROCODEC_DECODER 0
-%define CONFIG_ZLIB_DECODER 0
-%define CONFIG_ZLIB_ENCODER 0
-%define CONFIG_ZMBV_DECODER 0
-%define CONFIG_ZMBV_ENCODER 0
-%define CONFIG_ZMQ_FILTER 0
-%define CONFIG_ZOOMPAN_FILTER 0
-%define CONFIG_ZSCALE_FILTER 0
diff -Naur a/media/ffvpx/defaults_disabled.h b/media/ffvpx/defaults_disabled.h
--- a/media/ffvpx/defaults_disabled.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/defaults_disabled.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1837 +0,0 @@
-#define CONFIG_A64MULTI5_ENCODER 0
-#define CONFIG_A64MULTI_ENCODER 0
-#define CONFIG_A64_MUXER 0
-#define CONFIG_AAC_ADTSTOASC_BSF 0
-#define CONFIG_AAC_AT_DECODER 0
-#define CONFIG_AAC_AT_ENCODER 0
-#define CONFIG_AAC_DECODER 0
-#define CONFIG_AAC_DEMUXER 0
-#define CONFIG_AAC_ENCODER 0
-#define CONFIG_AAC_FIXED_DECODER 0
-#define CONFIG_AAC_LATM_DECODER 0
-#define CONFIG_AAC_LATM_PARSER 0
-#define CONFIG_AAC_PARSER 0
-#define CONFIG_AA_DEMUXER 0
-#define CONFIG_AASC_DECODER 0
-#define CONFIG_ABENCH_FILTER 0
-#define CONFIG_ABITSCOPE_FILTER 0
-#define CONFIG_AC3_AT_DECODER 0
-#define CONFIG_AC3_DECODER 0
-#define CONFIG_AC3_DEMUXER 0
-#define CONFIG_AC3_ENCODER 0
-#define CONFIG_AC3_FIXED_DECODER 0
-#define CONFIG_AC3_FIXED_ENCODER 0
-#define CONFIG_AC3_MUXER 0
-#define CONFIG_AC3_PARSER 0
-#define CONFIG_ACM_DEMUXER 0
-#define CONFIG_ACOMPRESSOR_FILTER 0
-#define CONFIG_ACONTRAST_FILTER 0
-#define CONFIG_ACOPY_FILTER 0
-#define CONFIG_ACROSSFADE_FILTER 0
-#define CONFIG_ACROSSOVER_FILTER 0
-#define CONFIG_ACRUSHER_FILTER 0
-#define CONFIG_ACT_DEMUXER 0
-#define CONFIG_ACUE_FILTER 0
-#define CONFIG_ADECLICK_FILTER 0
-#define CONFIG_ADECLIP_FILTER 0
-#define CONFIG_ADELAY_FILTER 0
-#define CONFIG_ADERIVATIVE_FILTER 0
-#define CONFIG_ADF_DEMUXER 0
-#define CONFIG_ADPCM_4XM_DECODER 0
-#define CONFIG_ADPCM_ADX_DECODER 0
-#define CONFIG_ADPCM_ADX_ENCODER 0
-#define CONFIG_ADPCM_AFC_DECODER 0
-#define CONFIG_ADPCM_AGM_DECODER 0
-#define CONFIG_ADPCM_AICA_DECODER 0
-#define CONFIG_ADPCM_CT_DECODER 0
-#define CONFIG_ADPCM_DTK_DECODER 0
-#define CONFIG_ADPCM_EA_DECODER 0
-#define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 0
-#define CONFIG_ADPCM_EA_R1_DECODER 0
-#define CONFIG_ADPCM_EA_R2_DECODER 0
-#define CONFIG_ADPCM_EA_R3_DECODER 0
-#define CONFIG_ADPCM_EA_XAS_DECODER 0
-#define CONFIG_ADPCM_G722_DECODER 0
-#define CONFIG_ADPCM_G722_ENCODER 0
-#define CONFIG_ADPCM_G726_DECODER 0
-#define CONFIG_ADPCM_G726_ENCODER 0
-#define CONFIG_ADPCM_G726LE_DECODER 0
-#define CONFIG_ADPCM_G726LE_ENCODER 0
-#define CONFIG_ADPCM_IMA_AMV_DECODER 0
-#define CONFIG_ADPCM_IMA_APC_DECODER 0
-#define CONFIG_ADPCM_IMA_DAT4_DECODER 0
-#define CONFIG_ADPCM_IMA_DK3_DECODER 0
-#define CONFIG_ADPCM_IMA_DK4_DECODER 0
-#define CONFIG_ADPCM_IMA_EA_EACS_DECODER 0
-#define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 0
-#define CONFIG_ADPCM_IMA_ISS_DECODER 0
-#define CONFIG_ADPCM_IMA_OKI_DECODER 0
-#define CONFIG_ADPCM_IMA_QT_AT_DECODER 0
-#define CONFIG_ADPCM_IMA_QT_DECODER 0
-#define CONFIG_ADPCM_IMA_QT_ENCODER 0
-#define CONFIG_ADPCM_IMA_RAD_DECODER 0
-#define CONFIG_ADPCM_IMA_SMJPEG_DECODER 0
-#define CONFIG_ADPCM_IMA_WAV_DECODER 0
-#define CONFIG_ADPCM_IMA_WAV_ENCODER 0
-#define CONFIG_ADPCM_IMA_WS_DECODER 0
-#define CONFIG_ADPCM_MS_DECODER 0
-#define CONFIG_ADPCM_MS_ENCODER 0
-#define CONFIG_ADPCM_MTAF_DECODER 0
-#define CONFIG_ADPCM_PSX_DECODER 0
-#define CONFIG_ADPCM_SBPRO_2_DECODER 0
-#define CONFIG_ADPCM_SBPRO_3_DECODER 0
-#define CONFIG_ADPCM_SBPRO_4_DECODER 0
-#define CONFIG_ADPCM_SWF_DECODER 0
-#define CONFIG_ADPCM_SWF_ENCODER 0
-#define CONFIG_ADPCM_THP_DECODER 0
-#define CONFIG_ADPCM_THP_LE_DECODER 0
-#define CONFIG_ADPCM_VIMA_DECODER 0
-#define CONFIG_ADPCM_XA_DECODER 0
-#define CONFIG_ADPCM_YAMAHA_DECODER 0
-#define CONFIG_ADPCM_YAMAHA_ENCODER 0
-#define CONFIG_ADP_DEMUXER 0
-#define CONFIG_ADRAWGRAPH_FILTER 0
-#define CONFIG_ADS_DEMUXER 0
-#define CONFIG_ADTS_MUXER 0
-#define CONFIG_ADX_DEMUXER 0
-#define CONFIG_ADX_MUXER 0
-#define CONFIG_ADX_PARSER 0
-#define CONFIG_AEA_DEMUXER 0
-#define CONFIG_AECHO_FILTER 0
-#define CONFIG_AEMPHASIS_FILTER 0
-#define CONFIG_AEVAL_FILTER 0
-#define CONFIG_AEVALSRC_FILTER 0
-#define CONFIG_AFADE_FILTER 0
-#define CONFIG_AFC_DEMUXER 0
-#define CONFIG_AFFTDN_FILTER 0
-#define CONFIG_AFFTFILT_FILTER 0
-#define CONFIG_AFIFO_FILTER 0
-#define CONFIG_AFIR_FILTER 0
-#define CONFIG_AFORMAT_FILTER 0
-#define CONFIG_AGATE_FILTER 0
-#define CONFIG_AGM_DECODER 0
-#define CONFIG_AGRAPHMONITOR_FILTER 0
-#define CONFIG_AHISTOGRAM_FILTER 0
-#define CONFIG_AIC_DECODER 0
-#define CONFIG_AIFF_DEMUXER 0
-#define CONFIG_AIFF_MUXER 0
-#define CONFIG_AIIR_FILTER 0
-#define CONFIG_AINTEGRAL_FILTER 0
-#define CONFIG_AINTERLEAVE_FILTER 0
-#define CONFIG_AIX_DEMUXER 0
-#define CONFIG_ALAC_AT_DECODER 0
-#define CONFIG_ALAC_AT_ENCODER 0
-#define CONFIG_ALAC_DECODER 0
-#define CONFIG_ALAC_ENCODER 0
-#define CONFIG_ALIAS_PIX_DECODER 0
-#define CONFIG_ALIAS_PIX_ENCODER 0
-#define CONFIG_ALIMITER_FILTER 0
-#define CONFIG_ALLPASS_FILTER 0
-#define CONFIG_ALLRGB_FILTER 0
-#define CONFIG_ALLYUV_FILTER 0
-#define CONFIG_ALOOP_FILTER 0
-#define CONFIG_ALPHAEXTRACT_FILTER 0
-#define CONFIG_ALPHAMERGE_FILTER 0
-#define CONFIG_ALSA_INDEV 0
-#define CONFIG_ALSA_OUTDEV 0
-#define CONFIG_ALS_DECODER 0
-#define CONFIG_AMERGE_FILTER 0
-#define CONFIG_AMETADATA_FILTER 0
-#define CONFIG_AMIX_FILTER 0
-#define CONFIG_AMOVIE_FILTER 0
-#define CONFIG_AMPLIFY_FILTER 0
-#define CONFIG_AMR_DEMUXER 0
-#define CONFIG_AMR_MUXER 0
-#define CONFIG_AMR_NB_AT_DECODER 0
-#define CONFIG_AMRNB_DECODER 0
-#define CONFIG_AMRNB_DEMUXER 0
-#define CONFIG_AMRWB_DECODER 0
-#define CONFIG_AMRWB_DEMUXER 0
-#define CONFIG_AMULTIPLY_FILTER 0
-#define CONFIG_AMV_DECODER 0
-#define CONFIG_AMV_ENCODER 0
-#define CONFIG_ANDROID_CAMERA_INDEV 0
-#define CONFIG_ANEQUALIZER_FILTER 0
-#define CONFIG_ANLMDN_FILTER 0
-#define CONFIG_ANM_DECODER 0
-#define CONFIG_ANM_DEMUXER 0
-#define CONFIG_ANOISESRC_FILTER 0
-#define CONFIG_ANSI_DECODER 0
-#define CONFIG_ANULL_FILTER 0
-#define CONFIG_ANULLSINK_FILTER 0
-#define CONFIG_ANULLSRC_FILTER 0
-#define CONFIG_APAD_FILTER 0
-#define CONFIG_APC_DEMUXER 0
-#define CONFIG_APE_DECODER 0
-#define CONFIG_APE_DEMUXER 0
-#define CONFIG_APERMS_FILTER 0
-#define CONFIG_APHASEMETER_FILTER 0
-#define CONFIG_APHASER_FILTER 0
-#define CONFIG_APNG_DECODER 0
-#define CONFIG_APNG_DEMUXER 0
-#define CONFIG_APNG_ENCODER 0
-#define CONFIG_APNG_MUXER 0
-#define CONFIG_APTX_DECODER 0
-#define CONFIG_APTX_DEMUXER 0
-#define CONFIG_APTX_ENCODER 0
-#define CONFIG_APTX_HD_DECODER 0
-#define CONFIG_APTX_HD_DEMUXER 0
-#define CONFIG_APTX_HD_ENCODER 0
-#define CONFIG_APTX_HD_MUXER 0
-#define CONFIG_APTX_MUXER 0
-#define CONFIG_APULSATOR_FILTER 0
-#define CONFIG_AQTITLE_DEMUXER 0
-#define CONFIG_ARBC_DECODER 0
-#define CONFIG_AREALTIME_FILTER 0
-#define CONFIG_ARESAMPLE_FILTER 0
-#define CONFIG_AREVERSE_FILTER 0
-#define CONFIG_ASELECT_FILTER 0
-#define CONFIG_ASENDCMD_FILTER 0
-#define CONFIG_ASETNSAMPLES_FILTER 0
-#define CONFIG_ASETPTS_FILTER 0
-#define CONFIG_ASETRATE_FILTER 0
-#define CONFIG_ASETTB_FILTER 0
-#define CONFIG_ASF_DEMUXER 0
-#define CONFIG_ASF_MUXER 0
-#define CONFIG_ASF_O_DEMUXER 0
-#define CONFIG_ASF_STREAM_MUXER 0
-#define CONFIG_ASHOWINFO_FILTER 0
-#define CONFIG_ASIDEDATA_FILTER 0
-#define CONFIG_ASOFTCLIP_FILTER 0
-#define CONFIG_ASPLIT_FILTER 0
-#define CONFIG_ASR_FILTER 0
-#define CONFIG_ASS_DECODER 0
-#define CONFIG_ASS_DEMUXER 0
-#define CONFIG_ASS_ENCODER 0
-#define CONFIG_ASS_FILTER 0
-#define CONFIG_ASS_MUXER 0
-#define CONFIG_ASTATS_FILTER 0
-#define CONFIG_AST_DEMUXER 0
-#define CONFIG_AST_MUXER 0
-#define CONFIG_ASTREAMSELECT_FILTER 0
-#define CONFIG_ASV1_DECODER 0
-#define CONFIG_ASV1_ENCODER 0
-#define CONFIG_ASV2_DECODER 0
-#define CONFIG_ASV2_ENCODER 0
-#define CONFIG_ASYNC_PROTOCOL 0
-#define CONFIG_ATADENOISE_FILTER 0
-#define CONFIG_ATEMPO_FILTER 0
-#define CONFIG_ATRAC1_DECODER 0
-#define CONFIG_ATRAC3AL_DECODER 0
-#define CONFIG_ATRAC3_DECODER 0
-#define CONFIG_ATRAC3PAL_DECODER 0
-#define CONFIG_ATRAC3P_DECODER 0
-#define CONFIG_ATRAC9_DECODER 0
-#define CONFIG_ATRIM_FILTER 0
-#define CONFIG_AU_DEMUXER 0
-#define CONFIG_AU_MUXER 0
-#define CONFIG_AURA2_DECODER 0
-#define CONFIG_AURA_DECODER 0
-#define CONFIG_AV1_FRAME_SPLIT_BSF 0
-#define CONFIG_AV1_METADATA_BSF 0
-#define CONFIG_AV1_PARSER 0
-#define CONFIG_AV1_DECODER 0
-#define CONFIG_AV1_D3D11VA_HWACCEL 0
-#define CONFIG_AV1_D3D11VA2_HWACCEL 0
-#define CONFIG_AV1_DXVA2_HWACCEL 0
-#define CONFIG_AV1_NVDEC_HWACCEL 0
-#define CONFIG_AV1_VAAPI_HWACCEL 0
-#define CONFIG_AVECTORSCOPE_FILTER 0
-#define CONFIG_AVFOUNDATION_INDEV 0
-#define CONFIG_AVGBLUR_FILTER 0
-#define CONFIG_AVGBLUR_OPENCL_FILTER 0
-#define CONFIG_AVI_DEMUXER 0
-#define CONFIG_AVI_MUXER 0
-#define CONFIG_AVISYNTH_DEMUXER 0
-#define CONFIG_AVM2_MUXER 0
-#define CONFIG_AVR_DEMUXER 0
-#define CONFIG_AVRN_DECODER 0
-#define CONFIG_AVRP_DECODER 0
-#define CONFIG_AVRP_ENCODER 0
-#define CONFIG_AVS2_DEMUXER 0
-#define CONFIG_AVS2_MUXER 0
-#define CONFIG_AVS2_PARSER 0
-#define CONFIG_AVS_DECODER 0
-#define CONFIG_AVS_DEMUXER 0
-#define CONFIG_AVUI_DECODER 0
-#define CONFIG_AVUI_ENCODER 0
-#define CONFIG_AYUV_DECODER 0
-#define CONFIG_AYUV_ENCODER 0
-#define CONFIG_AZMQ_FILTER 0
-#define CONFIG_BANDPASS_FILTER 0
-#define CONFIG_BANDREJECT_FILTER 0
-#define CONFIG_BASS_FILTER 0
-#define CONFIG_BBOX_FILTER 0
-#define CONFIG_BENCH_FILTER 0
-#define CONFIG_BETHSOFTVID_DECODER 0
-#define CONFIG_BETHSOFTVID_DEMUXER 0
-#define CONFIG_BFI_DECODER 0
-#define CONFIG_BFI_DEMUXER 0
-#define CONFIG_BFSTM_DEMUXER 0
-#define CONFIG_BINKAUDIO_DCT_DECODER 0
-#define CONFIG_BINKAUDIO_RDFT_DECODER 0
-#define CONFIG_BINK_DECODER 0
-#define CONFIG_BINK_DEMUXER 0
-#define CONFIG_BINTEXT_DECODER 0
-#define CONFIG_BINTEXT_DEMUXER 0
-#define CONFIG_BIQUAD_FILTER 0
-#define CONFIG_BIT_DEMUXER 0
-#define CONFIG_BIT_MUXER 0
-#define CONFIG_BITPACKED_DECODER 0
-#define CONFIG_BITPLANENOISE_FILTER 0
-#define CONFIG_BKTR_INDEV 0
-#define CONFIG_BLACKDETECT_FILTER 0
-#define CONFIG_BLACKFRAME_FILTER 0
-#define CONFIG_BLEND_FILTER 0
-#define CONFIG_BLURAY_PROTOCOL 0
-#define CONFIG_BM3D_FILTER 0
-#define CONFIG_BMP_DECODER 0
-#define CONFIG_BMP_ENCODER 0
-#define CONFIG_BMP_PARSER 0
-#define CONFIG_BMV_AUDIO_DECODER 0
-#define CONFIG_BMV_DEMUXER 0
-#define CONFIG_BMV_VIDEO_DECODER 0
-#define CONFIG_BOA_DEMUXER 0
-#define CONFIG_BOXBLUR_FILTER 0
-#define CONFIG_BOXBLUR_OPENCL_FILTER 0
-#define CONFIG_BRENDER_PIX_DECODER 0
-#define CONFIG_BRSTM_DEMUXER 0
-#define CONFIG_BS2B_FILTER 0
-#define CONFIG_BWDIF_FILTER 0
-#define CONFIG_C93_DECODER 0
-#define CONFIG_C93_DEMUXER 0
-#define CONFIG_CACA_OUTDEV 0
-#define CONFIG_CACHE_PROTOCOL 0
-#define CONFIG_CAF_DEMUXER 0
-#define CONFIG_CAF_MUXER 0
-#define CONFIG_CAVS_DECODER 0
-#define CONFIG_CAVSVIDEO_DEMUXER 0
-#define CONFIG_CAVSVIDEO_MUXER 0
-#define CONFIG_CAVSVIDEO_PARSER 0
-#define CONFIG_CCAPTION_DECODER 0
-#define CONFIG_CDG_DEMUXER 0
-#define CONFIG_CDGRAPHICS_DECODER 0
-#define CONFIG_CDXL_DECODER 0
-#define CONFIG_CDXL_DEMUXER 0
-#define CONFIG_CELLAUTO_FILTER 0
-#define CONFIG_CFHD_DECODER 0
-#define CONFIG_CHANNELMAP_FILTER 0
-#define CONFIG_CHANNELSPLIT_FILTER 0
-#define CONFIG_CHOMP_BSF 0
-#define CONFIG_CHORUS_FILTER 0
-#define CONFIG_CHROMAHOLD_FILTER 0
-#define CONFIG_CHROMAKEY_FILTER 0
-#define CONFIG_CHROMAPRINT_MUXER 0
-#define CONFIG_CHROMASHIFT_FILTER 0
-#define CONFIG_CIESCOPE_FILTER 0
-#define CONFIG_CINE_DEMUXER 0
-#define CONFIG_CINEPAK_DECODER 0
-#define CONFIG_CINEPAK_ENCODER 0
-#define CONFIG_CLEARVIDEO_DECODER 0
-#define CONFIG_CLJR_DECODER 0
-#define CONFIG_CLJR_ENCODER 0
-#define CONFIG_CLLC_DECODER 0
-#define CONFIG_CODEC2_DEMUXER 0
-#define CONFIG_CODEC2_MUXER 0
-#define CONFIG_CODEC2RAW_DEMUXER 0
-#define CONFIG_CODEC2RAW_MUXER 0
-#define CONFIG_CODECVIEW_FILTER 0
-#define CONFIG_COLORBALANCE_FILTER 0
-#define CONFIG_COLORCHANNELMIXER_FILTER 0
-#define CONFIG_COLOR_FILTER 0
-#define CONFIG_COLORHOLD_FILTER 0
-#define CONFIG_COLORKEY_FILTER 0
-#define CONFIG_COLORKEY_OPENCL_FILTER 0
-#define CONFIG_COLORLEVELS_FILTER 0
-#define CONFIG_COLORMATRIX_FILTER 0
-#define CONFIG_COLORSPACE_FILTER 0
-#define CONFIG_COMFORTNOISE_DECODER 0
-#define CONFIG_COMFORTNOISE_ENCODER 0
-#define CONFIG_COMPAND_FILTER 0
-#define CONFIG_COMPENSATIONDELAY_FILTER 0
-#define CONFIG_CONCAT_DEMUXER 0
-#define CONFIG_CONCAT_FILTER 0
-#define CONFIG_CONCAT_PROTOCOL 0
-#define CONFIG_CONVOLUTION_FILTER 0
-#define CONFIG_CONVOLUTION_OPENCL_FILTER 0
-#define CONFIG_CONVOLVE_FILTER 0
-#define CONFIG_COOK_DECODER 0
-#define CONFIG_COOK_PARSER 0
-#define CONFIG_COPY_FILTER 0
-#define CONFIG_COREIMAGE_FILTER 0
-#define CONFIG_COREIMAGESRC_FILTER 0
-#define CONFIG_COVER_RECT_FILTER 0
-#define CONFIG_CPIA_DECODER 0
-#define CONFIG_CRC_MUXER 0
-#define CONFIG_CROPDETECT_FILTER 0
-#define CONFIG_CROP_FILTER 0
-#define CONFIG_CROSSFEED_FILTER 0
-#define CONFIG_CRYPTO_PROTOCOL 0
-#define CONFIG_CRYSTALIZER_FILTER 0
-#define CONFIG_CSCD_DECODER 0
-#define CONFIG_CUE_FILTER 0
-#define CONFIG_CURVES_FILTER 0
-#define CONFIG_CYUV_DECODER 0
-#define CONFIG_DASH_DEMUXER 0
-#define CONFIG_DASH_MUXER 0
-#define CONFIG_DATA_DEMUXER 0
-#define CONFIG_DATA_MUXER 0
-#define CONFIG_DATA_PROTOCOL 0
-#define CONFIG_DATASCOPE_FILTER 0
-#define CONFIG_DAUD_DEMUXER 0
-#define CONFIG_DAUD_MUXER 0
-#define CONFIG_DCA_CORE_BSF 0
-#define CONFIG_DCA_DECODER 0
-#define CONFIG_DCA_ENCODER 0
-#define CONFIG_DCA_PARSER 0
-#define CONFIG_DCSHIFT_FILTER 0
-#define CONFIG_DCSTR_DEMUXER 0
-#define CONFIG_DCTDNOIZ_FILTER 0
-#define CONFIG_DDS_DECODER 0
-#define CONFIG_DEBAND_FILTER 0
-#define CONFIG_DEBLOCK_FILTER 0
-#define CONFIG_DECIMATE_FILTER 0
-#define CONFIG_DECKLINK_INDEV 0
-#define CONFIG_DECKLINK_OUTDEV 0
-#define CONFIG_DECONVOLVE_FILTER 0
-#define CONFIG_DEDOT_FILTER 0
-#define CONFIG_DEESSER_FILTER 0
-#define CONFIG_DEFLATE_FILTER 0
-#define CONFIG_DEFLICKER_FILTER 0
-#define CONFIG_DEINTERLACE_QSV_FILTER 0
-#define CONFIG_DEINTERLACE_VAAPI_FILTER 0
-#define CONFIG_DEJUDDER_FILTER 0
-#define CONFIG_DELOGO_FILTER 0
-#define CONFIG_DEMUXERS 0
-#define CONFIG_DENOISE_VAAPI_FILTER 0
-#define CONFIG_DERAIN_FILTER 0
-#define CONFIG_DESHAKE_FILTER 0
-#define CONFIG_DESPILL_FILTER 0
-#define CONFIG_DETELECINE_FILTER 0
-#define CONFIG_DFA_DECODER 0
-#define CONFIG_DFA_DEMUXER 0
-#define CONFIG_DHAV_DEMUXER 0
-#define CONFIG_DILATION_FILTER 0
-#define CONFIG_DILATION_OPENCL_FILTER 0
-#define CONFIG_DIRAC_DECODER 0
-#define CONFIG_DIRAC_DEMUXER 0
-#define CONFIG_DIRAC_MUXER 0
-#define CONFIG_DIRAC_PARSER 0
-#define CONFIG_DISPLACE_FILTER 0
-#define CONFIG_DNXHD_DECODER 0
-#define CONFIG_DNXHD_DEMUXER 0
-#define CONFIG_DNXHD_ENCODER 0
-#define CONFIG_DNXHD_MUXER 0
-#define CONFIG_DNXHD_PARSER 0
-#define CONFIG_DOLBY_E_DECODER 0
-#define CONFIG_DOUBLEWEAVE_FILTER 0
-#define CONFIG_DPX_DECODER 0
-#define CONFIG_DPX_ENCODER 0
-#define CONFIG_DPX_PARSER 0
-#define CONFIG_DRAWBOX_FILTER 0
-#define CONFIG_DRAWGRAPH_FILTER 0
-#define CONFIG_DRAWGRID_FILTER 0
-#define CONFIG_DRAWTEXT_FILTER 0
-#define CONFIG_DRMETER_FILTER 0
-#define CONFIG_DSD_LSBF_DECODER 0
-#define CONFIG_DSD_LSBF_PLANAR_DECODER 0
-#define CONFIG_DSD_MSBF_DECODER 0
-#define CONFIG_DSD_MSBF_PLANAR_DECODER 0
-#define CONFIG_DSF_DEMUXER 0
-#define CONFIG_DSHOW_INDEV 0
-#define CONFIG_DSICINAUDIO_DECODER 0
-#define CONFIG_DSICIN_DEMUXER 0
-#define CONFIG_DSICINVIDEO_DECODER 0
-#define CONFIG_DSS_DEMUXER 0
-#define CONFIG_DSS_SP_DECODER 0
-#define CONFIG_DST_DECODER 0
-#define CONFIG_DTS_DEMUXER 0
-#define CONFIG_DTSHD_DEMUXER 0
-#define CONFIG_DTS_MUXER 0
-#define CONFIG_DUMP_EXTRADATA_BSF 0
-#define CONFIG_DVAUDIO_DECODER 0
-#define CONFIG_DVAUDIO_PARSER 0
-#define CONFIG_DVBSUB_DECODER 0
-#define CONFIG_DVBSUB_DEMUXER 0
-#define CONFIG_DVBSUB_ENCODER 0
-#define CONFIG_DVBSUB_PARSER 0
-#define CONFIG_DVBTXT_DEMUXER 0
-#define CONFIG_DV_DEMUXER 0
-#define CONFIG_DVD_NAV_PARSER 0
-#define CONFIG_DVDSUB_DECODER 0
-#define CONFIG_DVDSUB_ENCODER 0
-#define CONFIG_DVDSUB_PARSER 0
-#define CONFIG_DV_MUXER 0
-#define CONFIG_DVVIDEO_DECODER 0
-#define CONFIG_DVVIDEO_ENCODER 0
-#define CONFIG_DXA_DECODER 0
-#define CONFIG_DXA_DEMUXER 0
-#define CONFIG_DXTORY_DECODER 0
-#define CONFIG_DXV_DECODER 0
-#define CONFIG_DYNAUDNORM_FILTER 0
-#define CONFIG_EAC3_AT_DECODER 0
-#define CONFIG_EAC3_CORE_BSF 0
-#define CONFIG_EAC3_DECODER 0
-#define CONFIG_EAC3_DEMUXER 0
-#define CONFIG_EAC3_ENCODER 0
-#define CONFIG_EAC3_MUXER 0
-#define CONFIG_EA_CDATA_DEMUXER 0
-#define CONFIG_EACMV_DECODER 0
-#define CONFIG_EA_DEMUXER 0
-#define CONFIG_EAMAD_DECODER 0
-#define CONFIG_EARWAX_FILTER 0
-#define CONFIG_EATGQ_DECODER 0
-#define CONFIG_EATGV_DECODER 0
-#define CONFIG_EATQI_DECODER 0
-#define CONFIG_EBUR128_FILTER 0
-#define CONFIG_EDGEDETECT_FILTER 0
-#define CONFIG_EIGHTBPS_DECODER 0
-#define CONFIG_EIGHTSVX_EXP_DECODER 0
-#define CONFIG_EIGHTSVX_FIB_DECODER 0
-#define CONFIG_ELBG_FILTER 0
-#define CONFIG_ENCODERS 0
-#define CONFIG_ENTROPY_FILTER 0
-#define CONFIG_EPAF_DEMUXER 0
-#define CONFIG_EQ_FILTER 0
-#define CONFIG_EQUALIZER_FILTER 0
-#define CONFIG_EROSION_FILTER 0
-#define CONFIG_EROSION_OPENCL_FILTER 0
-#define CONFIG_ESCAPE124_DECODER 0
-#define CONFIG_ESCAPE130_DECODER 0
-#define CONFIG_EVRC_DECODER 0
-#define CONFIG_EXR_DECODER 0
-#define CONFIG_EXTRACT_EXTRADATA_BSF 0
-#define CONFIG_EXTRACTPLANES_FILTER 0
-#define CONFIG_EXTRASTEREO_FILTER 0
-#define CONFIG_F4V_MUXER 0
-#define CONFIG_FADE_FILTER 0
-#define CONFIG_FBDEV_INDEV 0
-#define CONFIG_FBDEV_OUTDEV 0
-#define CONFIG_FFMETADATA_DEMUXER 0
-#define CONFIG_FFMETADATA_MUXER 0
-#define CONFIG_FFRTMPCRYPT_PROTOCOL 0
-#define CONFIG_FFRTMPHTTP_PROTOCOL 0
-#define CONFIG_FFTDNOIZ_FILTER 0
-#define CONFIG_FFTFILT_FILTER 0
-#define CONFIG_FFV1_DECODER 0
-#define CONFIG_FFV1_ENCODER 0
-#define CONFIG_FFVHUFF_DECODER 0
-#define CONFIG_FFVHUFF_ENCODER 0
-#define CONFIG_FFWAVESYNTH_DECODER 0
-#define CONFIG_FIC_DECODER 0
-#define CONFIG_FIELD_FILTER 0
-#define CONFIG_FIELDHINT_FILTER 0
-#define CONFIG_FIELDMATCH_FILTER 0
-#define CONFIG_FIELDORDER_FILTER 0
-#define CONFIG_FIFO_FILTER 0
-#define CONFIG_FIFO_MUXER 0
-#define CONFIG_FIFO_TEST_MUXER 0
-#define CONFIG_FILE_PROTOCOL 0
-#define CONFIG_FILLBORDERS_FILTER 0
-#define CONFIG_FILMSTRIP_DEMUXER 0
-#define CONFIG_FILMSTRIP_MUXER 0
-#define CONFIG_FILTERS 0
-#define CONFIG_FILTER_UNITS_BSF 0
-#define CONFIG_FIND_RECT_FILTER 0
-#define CONFIG_FIREQUALIZER_FILTER 0
-#define CONFIG_FITS_DECODER 0
-#define CONFIG_FITS_DEMUXER 0
-#define CONFIG_FITS_ENCODER 0
-#define CONFIG_FITS_MUXER 0
-#define CONFIG_FLAC_DEMUXER 0
-#define CONFIG_FLAC_ENCODER 0
-#define CONFIG_FLAC_MUXER 0
-#define CONFIG_FLAC_PARSER 0
-#define CONFIG_FLANGER_FILTER 0
-#define CONFIG_FLASHSV2_DECODER 0
-#define CONFIG_FLASHSV2_ENCODER 0
-#define CONFIG_FLASHSV_DECODER 0
-#define CONFIG_FLASHSV_ENCODER 0
-#define CONFIG_FLIC_DECODER 0
-#define CONFIG_FLIC_DEMUXER 0
-#define CONFIG_FLITE_FILTER 0
-#define CONFIG_FLOODFILL_FILTER 0
-#define CONFIG_FLV_DECODER 0
-#define CONFIG_FLV_DEMUXER 0
-#define CONFIG_FLV_ENCODER 0
-#define CONFIG_FLV_MUXER 0
-#define CONFIG_FMVC_DECODER 0
-#define CONFIG_FORMAT_FILTER 0
-#define CONFIG_FOURXM_DECODER 0
-#define CONFIG_FOURXM_DEMUXER 0
-#define CONFIG_FPS_FILTER 0
-#define CONFIG_FRAMECRC_MUXER 0
-#define CONFIG_FRAMEHASH_MUXER 0
-#define CONFIG_FRAMEMD5_MUXER 0
-#define CONFIG_FRAMEPACK_FILTER 0
-#define CONFIG_FRAMERATE_FILTER 0
-#define CONFIG_FRAMESTEP_FILTER 0
-#define CONFIG_FRAME_THREAD_ENCODER 0
-#define CONFIG_FRAPS_DECODER 0
-#define CONFIG_FREEZEDETECT_FILTER 0
-#define CONFIG_FREI0R_FILTER 0
-#define CONFIG_FREI0R_SRC_FILTER 0
-#define CONFIG_FRM_DEMUXER 0
-#define CONFIG_FRWU_DECODER 0
-#define CONFIG_FSB_DEMUXER 0
-#define CONFIG_FSPP_FILTER 0
-#define CONFIG_FTP_PROTOCOL 0
-#define CONFIG_G2M_DECODER 0
-#define CONFIG_G722_DEMUXER 0
-#define CONFIG_G722_MUXER 0
-#define CONFIG_G723_1_DECODER 0
-#define CONFIG_G723_1_DEMUXER 0
-#define CONFIG_G723_1_ENCODER 0
-#define CONFIG_G723_1_MUXER 0
-#define CONFIG_G723_1_PARSER 0
-#define CONFIG_G726_DEMUXER 0
-#define CONFIG_G726LE_DEMUXER 0
-#define CONFIG_G726LE_MUXER 0
-#define CONFIG_G726_MUXER 0
-#define CONFIG_G729_DECODER 0
-#define CONFIG_G729_DEMUXER 0
-#define CONFIG_G729_PARSER 0
-#define CONFIG_GBLUR_FILTER 0
-#define CONFIG_GDIGRAB_INDEV 0
-#define CONFIG_GDV_DECODER 0
-#define CONFIG_GDV_DEMUXER 0
-#define CONFIG_GENH_DEMUXER 0
-#define CONFIG_GEQ_FILTER 0
-#define CONFIG_GIF_DECODER 0
-#define CONFIG_GIF_DEMUXER 0
-#define CONFIG_GIF_ENCODER 0
-#define CONFIG_GIF_MUXER 0
-#define CONFIG_GIF_PARSER 0
-#define CONFIG_GOPHER_PROTOCOL 0
-#define CONFIG_GRADFUN_FILTER 0
-#define CONFIG_GRAPHMONITOR_FILTER 0
-#define CONFIG_GREMLIN_DPCM_DECODER 0
-#define CONFIG_GREYEDGE_FILTER 0
-#define CONFIG_GSM_DECODER 0
-#define CONFIG_GSM_DEMUXER 0
-#define CONFIG_GSM_MS_AT_DECODER 0
-#define CONFIG_GSM_MS_DECODER 0
-#define CONFIG_GSM_MUXER 0
-#define CONFIG_GSM_PARSER 0
-#define CONFIG_GXF_DEMUXER 0
-#define CONFIG_GXF_MUXER 0
-#define CONFIG_H261_DECODER 0
-#define CONFIG_H261_DEMUXER 0
-#define CONFIG_H261_ENCODER 0
-#define CONFIG_H261_MUXER 0
-#define CONFIG_H261_PARSER 0
-#define CONFIG_H263_DECODER 0
-#define CONFIG_H263_DEMUXER 0
-#define CONFIG_H263_ENCODER 0
-#define CONFIG_H263I_DECODER 0
-#define CONFIG_H263_MUXER 0
-#define CONFIG_H263_PARSER 0
-#define CONFIG_H263P_DECODER 0
-#define CONFIG_H263P_ENCODER 0
-#define CONFIG_H263_V4L2M2M_DECODER 0
-#define CONFIG_H263_V4L2M2M_ENCODER 0
-#define CONFIG_H263_VAAPI_HWACCEL 0
-#define CONFIG_H263_VIDEOTOOLBOX_HWACCEL 0
-#define CONFIG_H264_AMF_ENCODER 0
-#define CONFIG_H264_CRYSTALHD_DECODER 0
-#define CONFIG_H264_CUVID_DECODER 0
-#define CONFIG_H264_D3D11VA2_HWACCEL 0
-#define CONFIG_H264_D3D11VA_HWACCEL 0
-#define CONFIG_H264_DECODER 0
-#define CONFIG_H264_DEMUXER 0
-#define CONFIG_H264_DXVA2_HWACCEL 0
-#define CONFIG_H264_MEDIACODEC_DECODER 0
-#define CONFIG_H264_METADATA_BSF 0
-#define CONFIG_H264_MMAL_DECODER 0
-#define CONFIG_H264_MP4TOANNEXB_BSF 0
-#define CONFIG_H264_MUXER 0
-#define CONFIG_H264_NVDEC_HWACCEL 0
-#define CONFIG_H264_NVENC_ENCODER 0
-#define CONFIG_H264_OMX_ENCODER 0
-#define CONFIG_H264_PARSER 0
-#define CONFIG_H264_QSV_DECODER 0
-#define CONFIG_H264_QSV_ENCODER 0
-#define CONFIG_H264_REDUNDANT_PPS_BSF 0
-#define CONFIG_H264_RKMPP_DECODER 0
-#define CONFIG_H264_V4L2M2M_DECODER 0
-#define CONFIG_H264_V4L2M2M_ENCODER 0
-#define CONFIG_H264_VAAPI_ENCODER 0
-#define CONFIG_H264_VAAPI_HWACCEL 0
-#define CONFIG_H264_VDPAU_HWACCEL 0
-#define CONFIG_H264_VIDEOTOOLBOX_ENCODER 0
-#define CONFIG_H264_VIDEOTOOLBOX_HWACCEL 0
-#define CONFIG_HAAS_FILTER 0
-#define CONFIG_HALDCLUT_FILTER 0
-#define CONFIG_HALDCLUTSRC_FILTER 0
-#define CONFIG_HAP_DECODER 0
-#define CONFIG_HAP_ENCODER 0
-#define CONFIG_HAPQA_EXTRACT_BSF 0
-#define CONFIG_HASH_MUXER 0
-#define CONFIG_HCOM_DECODER 0
-#define CONFIG_HCOM_DEMUXER 0
-#define CONFIG_HDCD_FILTER 0
-#define CONFIG_HDS_MUXER 0
-#define CONFIG_HEADPHONE_FILTER 0
-#define CONFIG_HEVC_AMF_ENCODER 0
-#define CONFIG_HEVC_CUVID_DECODER 0
-#define CONFIG_HEVC_D3D11VA2_HWACCEL 0
-#define CONFIG_HEVC_D3D11VA_HWACCEL 0
-#define CONFIG_HEVC_DECODER 0
-#define CONFIG_HEVC_DEMUXER 0
-#define CONFIG_HEVC_DXVA2_HWACCEL 0
-#define CONFIG_HEVC_MEDIACODEC_DECODER 0
-#define CONFIG_HEVC_METADATA_BSF 0
-#define CONFIG_HEVC_MP4TOANNEXB_BSF 0
-#define CONFIG_HEVC_MUXER 0
-#define CONFIG_HEVC_NVDEC_HWACCEL 0
-#define CONFIG_HEVC_NVENC_ENCODER 0
-#define CONFIG_HEVC_PARSER 0
-#define CONFIG_HEVC_QSV_DECODER 0
-#define CONFIG_HEVC_QSV_ENCODER 0
-#define CONFIG_HEVC_RKMPP_DECODER 0
-#define CONFIG_HEVC_V4L2M2M_DECODER 0
-#define CONFIG_HEVC_V4L2M2M_ENCODER 0
-#define CONFIG_HEVC_VAAPI_ENCODER 0
-#define CONFIG_HEVC_VAAPI_HWACCEL 0
-#define CONFIG_HEVC_VDPAU_HWACCEL 0
-#define CONFIG_HEVC_VIDEOTOOLBOX_ENCODER 0
-#define CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL 0
-#define CONFIG_HFLIP_FILTER 0
-#define CONFIG_HIGHPASS_FILTER 0
-#define CONFIG_HIGHSHELF_FILTER 0
-#define CONFIG_HILBERT_FILTER 0
-#define CONFIG_HISTEQ_FILTER 0
-#define CONFIG_HISTOGRAM_FILTER 0
-#define CONFIG_HLS_DEMUXER 0
-#define CONFIG_HLS_MUXER 0
-#define CONFIG_HLS_PROTOCOL 0
-#define CONFIG_HNM4_VIDEO_DECODER 0
-#define CONFIG_HNM_DEMUXER 0
-#define CONFIG_HQDN3D_FILTER 0
-#define CONFIG_HQ_HQA_DECODER 0
-#define CONFIG_HQX_DECODER 0
-#define CONFIG_HQX_FILTER 0
-#define CONFIG_HSTACK_FILTER 0
-#define CONFIG_HTTP_PROTOCOL 0
-#define CONFIG_HTTPPROXY_PROTOCOL 0
-#define CONFIG_HTTPS_PROTOCOL 0
-#define CONFIG_HUE_FILTER 0
-#define CONFIG_HUFFYUV_DECODER 0
-#define CONFIG_HUFFYUV_ENCODER 0
-#define CONFIG_HWACCELS 0
-#define CONFIG_HWDOWNLOAD_FILTER 0
-#define CONFIG_HWMAP_FILTER 0
-#define CONFIG_HWUPLOAD_CUDA_FILTER 0
-#define CONFIG_HWUPLOAD_FILTER 0
-#define CONFIG_HYMT_DECODER 0
-#define CONFIG_HYSTERESIS_FILTER 0
-#define CONFIG_IAC_DECODER 0
-#define CONFIG_ICECAST_PROTOCOL 0
-#define CONFIG_ICO_DEMUXER 0
-#define CONFIG_ICO_MUXER 0
-#define CONFIG_IDCIN_DECODER 0
-#define CONFIG_IDCIN_DEMUXER 0
-#define CONFIG_IDET_FILTER 0
-#define CONFIG_IDF_DECODER 0
-#define CONFIG_IDF_DEMUXER 0
-#define CONFIG_IEC61883_INDEV 0
-#define CONFIG_IFF_DEMUXER 0
-#define CONFIG_IFF_ILBM_DECODER 0
-#define CONFIG_IFV_DEMUXER 0
-#define CONFIG_ILBC_AT_DECODER 0
-#define CONFIG_ILBC_AT_ENCODER 0
-#define CONFIG_ILBC_DECODER 0
-#define CONFIG_ILBC_DEMUXER 0
-#define CONFIG_ILBC_MUXER 0
-#define CONFIG_IL_FILTER 0
-#define CONFIG_IMAGE2_ALIAS_PIX_DEMUXER 0
-#define CONFIG_IMAGE2_BRENDER_PIX_DEMUXER 0
-#define CONFIG_IMAGE2_DEMUXER 0
-#define CONFIG_IMAGE2_MUXER 0
-#define CONFIG_IMAGE2PIPE_DEMUXER 0
-#define CONFIG_IMAGE2PIPE_MUXER 0
-#define CONFIG_IMAGE_BMP_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_DDS_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_DPX_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_EXR_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_GIF_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_J2K_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_JPEG_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PAM_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PBM_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PCX_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PGM_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PGMYUV_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PICTOR_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PNG_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PPM_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_PSD_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_QDRAW_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_SGI_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_SUNRAST_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_SVG_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_TIFF_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_WEBP_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_XPM_PIPE_DEMUXER 0
-#define CONFIG_IMAGE_XWD_PIPE_DEMUXER 0
-#define CONFIG_IMC_DECODER 0
-#define CONFIG_IMM4_DECODER 0
-#define CONFIG_IMX_DUMP_HEADER_BSF 0
-#define CONFIG_INDEO2_DECODER 0
-#define CONFIG_INDEO3_DECODER 0
-#define CONFIG_INDEO4_DECODER 0
-#define CONFIG_INDEO5_DECODER 0
-#define CONFIG_INDEVS 0
-#define CONFIG_INFLATE_FILTER 0
-#define CONFIG_INGENIENT_DEMUXER 0
-#define CONFIG_INTERLACE_FILTER 0
-#define CONFIG_INTERLEAVE_FILTER 0
-#define CONFIG_INTERPLAY_ACM_DECODER 0
-#define CONFIG_INTERPLAY_DPCM_DECODER 0
-#define CONFIG_INTERPLAY_VIDEO_DECODER 0
-#define CONFIG_IPMOVIE_DEMUXER 0
-#define CONFIG_IPOD_MUXER 0
-#define CONFIG_IRCAM_DEMUXER 0
-#define CONFIG_IRCAM_MUXER 0
-#define CONFIG_ISMV_MUXER 0
-#define CONFIG_ISS_DEMUXER 0
-#define CONFIG_IV8_DEMUXER 0
-#define CONFIG_IVF_DEMUXER 0
-#define CONFIG_IVF_MUXER 0
-#define CONFIG_IVR_DEMUXER 0
-#define CONFIG_JACK_INDEV 0
-#define CONFIG_JACOSUB_DECODER 0
-#define CONFIG_JACOSUB_DEMUXER 0
-#define CONFIG_JACOSUB_MUXER 0
-#define CONFIG_JOIN_FILTER 0
-#define CONFIG_JPEG2000_DECODER 0
-#define CONFIG_JPEG2000_ENCODER 0
-#define CONFIG_JPEGLS_DECODER 0
-#define CONFIG_JPEGLS_ENCODER 0
-#define CONFIG_JV_DECODER 0
-#define CONFIG_JV_DEMUXER 0
-#define CONFIG_KERNDEINT_FILTER 0
-#define CONFIG_KGV1_DECODER 0
-#define CONFIG_KMSGRAB_INDEV 0
-#define CONFIG_KMVC_DECODER 0
-#define CONFIG_KUX_DEMUXER 0
-#define CONFIG_LADSPA_FILTER 0
-#define CONFIG_LAGARITH_DECODER 0
-#define CONFIG_LAGFUN_FILTER 0
-#define CONFIG_LATM_MUXER 0
-#define CONFIG_LAVFI_INDEV 0
-#define CONFIG_LENSCORRECTION_FILTER 0
-#define CONFIG_LENSFUN_FILTER 0
-#define CONFIG_LIBAOM_AV1_DECODER 0
-#define CONFIG_LIBAOM_AV1_ENCODER 0
-#define CONFIG_LIBARIBB24_DECODER 0
-#define CONFIG_LIBCDIO_INDEV 0
-#define CONFIG_LIBCELT_DECODER 0
-#define CONFIG_LIBCODEC2_DECODER 0
-#define CONFIG_LIBCODEC2_ENCODER 0
-#define CONFIG_LIBDAV1D_DECODER 0
-#define CONFIG_LIBDAVS2_DECODER 0
-#define CONFIG_LIBDC1394_INDEV 0
-#define CONFIG_LIBFDK_AAC_DECODER 0
-#define CONFIG_LIBFDK_AAC_ENCODER 0
-#define CONFIG_LIBGME_DEMUXER 0
-#define CONFIG_LIBGSM_DECODER 0
-#define CONFIG_LIBGSM_ENCODER 0
-#define CONFIG_LIBGSM_MS_DECODER 0
-#define CONFIG_LIBGSM_MS_ENCODER 0
-#define CONFIG_LIBILBC_DECODER 0
-#define CONFIG_LIBILBC_ENCODER 0
-#define CONFIG_LIBKVAZAAR_ENCODER 0
-#define CONFIG_LIBMODPLUG_DEMUXER 0
-#define CONFIG_LIBMP3LAME_ENCODER 0
-#define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
-#define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
-#define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
-#define CONFIG_LIBOPENH264_DECODER 0
-#define CONFIG_LIBOPENH264_ENCODER 0
-#define CONFIG_LIBOPENJPEG_DECODER 0
-#define CONFIG_LIBOPENJPEG_ENCODER 0
-#define CONFIG_LIBOPENMPT_DEMUXER 0
-#define CONFIG_LIBOPUS_DECODER 0
-#define CONFIG_LIBOPUS_ENCODER 0
-#define CONFIG_LIBRSVG_DECODER 0
-#define CONFIG_LIBRTMPE_PROTOCOL 0
-#define CONFIG_LIBRTMP_PROTOCOL 0
-#define CONFIG_LIBRTMPS_PROTOCOL 0
-#define CONFIG_LIBRTMPTE_PROTOCOL 0
-#define CONFIG_LIBRTMPT_PROTOCOL 0
-#define CONFIG_LIBSHINE_ENCODER 0
-#define CONFIG_LIBSMBCLIENT_PROTOCOL 0
-#define CONFIG_LIBSPEEX_DECODER 0
-#define CONFIG_LIBSPEEX_ENCODER 0
-#define CONFIG_LIBSRT_PROTOCOL 0
-#define CONFIG_LIBSSH_PROTOCOL 0
-#define CONFIG_LIBTHEORA_ENCODER 0
-#define CONFIG_LIBTWOLAME_ENCODER 0
-#define CONFIG_LIBVMAF_FILTER 0
-#define CONFIG_LIBVO_AMRWBENC_ENCODER 0
-#define CONFIG_LIBVORBIS_DECODER 0
-#define CONFIG_LIBVORBIS_ENCODER 0
-#define CONFIG_LIBVPX_VP8_DECODER 0
-#define CONFIG_LIBVPX_VP8_ENCODER 0
-#define CONFIG_LIBVPX_VP9_DECODER 0
-#define CONFIG_LIBVPX_VP9_ENCODER 0
-#define CONFIG_LIBWAVPACK_ENCODER 0
-#define CONFIG_LIBWEBP_ANIM_ENCODER 0
-#define CONFIG_LIBWEBP_ENCODER 0
-#define CONFIG_LIBX262_ENCODER 0
-#define CONFIG_LIBX264_ENCODER 0
-#define CONFIG_LIBX264RGB_ENCODER 0
-#define CONFIG_LIBX265_ENCODER 0
-#define CONFIG_LIBXAVS2_ENCODER 0
-#define CONFIG_LIBXAVS_ENCODER 0
-#define CONFIG_LIBXVID_ENCODER 0
-#define CONFIG_LIBZVBI_TELETEXT_DECODER 0
-#define CONFIG_LIFE_FILTER 0
-#define CONFIG_LIMITER_FILTER 0
-#define CONFIG_LIVE_FLV_DEMUXER 0
-#define CONFIG_LJPEG_ENCODER 0
-#define CONFIG_LMLM4_DEMUXER 0
-#define CONFIG_LOAS_DEMUXER 0
-#define CONFIG_LOCO_DECODER 0
-#define CONFIG_LOOP_FILTER 0
-#define CONFIG_LOUDNORM_FILTER 0
-#define CONFIG_LOWPASS_FILTER 0
-#define CONFIG_LOWSHELF_FILTER 0
-#define CONFIG_LRC_DEMUXER 0
-#define CONFIG_LRC_MUXER 0
-#define CONFIG_LSCR_DECODER 0
-#define CONFIG_LUMAKEY_FILTER 0
-#define CONFIG_LUT1D_FILTER 0
-#define CONFIG_LUT2_FILTER 0
-#define CONFIG_LUT3D_FILTER 0
-#define CONFIG_LUT_FILTER 0
-#define CONFIG_LUTRGB_FILTER 0
-#define CONFIG_LUTYUV_FILTER 0
-#define CONFIG_LV2_FILTER 0
-#define CONFIG_LVF_DEMUXER 0
-#define CONFIG_LXF_DEMUXER 0
-#define CONFIG_M101_DECODER 0
-#define CONFIG_M4V_DEMUXER 0
-#define CONFIG_M4V_MUXER 0
-#define CONFIG_MACE3_DECODER 0
-#define CONFIG_MACE6_DECODER 0
-#define CONFIG_MAGICYUV_DECODER 0
-#define CONFIG_MAGICYUV_ENCODER 0
-#define CONFIG_MANDELBROT_FILTER 0
-#define CONFIG_MASKEDCLAMP_FILTER 0
-#define CONFIG_MASKEDMERGE_FILTER 0
-#define CONFIG_MASKFUN_FILTER 0
-#define CONFIG_MATROSKA_AUDIO_MUXER 0
-#define CONFIG_MATROSKA_DEMUXER 0
-#define CONFIG_MATROSKA_MUXER 0
-#define CONFIG_MCDEINT_FILTER 0
-#define CONFIG_MCOMPAND_FILTER 0
-#define CONFIG_MD5_MUXER 0
-#define CONFIG_MD5_PROTOCOL 0
-#define CONFIG_MDEC_DECODER 0
-#define CONFIG_MERGEPLANES_FILTER 0
-#define CONFIG_MESTIMATE_FILTER 0
-#define CONFIG_METADATA_FILTER 0
-#define CONFIG_METASOUND_DECODER 0
-#define CONFIG_MGSTS_DEMUXER 0
-#define CONFIG_MICRODVD_DECODER 0
-#define CONFIG_MICRODVD_DEMUXER 0
-#define CONFIG_MICRODVD_MUXER 0
-#define CONFIG_MIDEQUALIZER_FILTER 0
-#define CONFIG_MIMIC_DECODER 0
-#define CONFIG_MINTERPOLATE_FILTER 0
-#define CONFIG_MIX_FILTER 0
-#define CONFIG_MJPEG_2000_DEMUXER 0
-#define CONFIG_MJPEG2JPEG_BSF 0
-#define CONFIG_MJPEGA_DUMP_HEADER_BSF 0
-#define CONFIG_MJPEGB_DECODER 0
-#define CONFIG_MJPEG_CUVID_DECODER 0
-#define CONFIG_MJPEG_DECODER 0
-#define CONFIG_MJPEG_DEMUXER 0
-#define CONFIG_MJPEG_ENCODER 0
-#define CONFIG_MJPEG_MUXER 0
-#define CONFIG_MJPEG_NVDEC_HWACCEL 0
-#define CONFIG_MJPEG_PARSER 0
-#define CONFIG_MJPEG_QSV_ENCODER 0
-#define CONFIG_MJPEG_VAAPI_ENCODER 0
-#define CONFIG_MJPEG_VAAPI_HWACCEL 0
-#define CONFIG_MKVTIMESTAMP_V2_MUXER 0
-#define CONFIG_MLP_DECODER 0
-#define CONFIG_MLP_DEMUXER 0
-#define CONFIG_MLP_ENCODER 0
-#define CONFIG_MLP_MUXER 0
-#define CONFIG_MLP_PARSER 0
-#define CONFIG_MLV_DEMUXER 0
-#define CONFIG_MM_DEMUXER 0
-#define CONFIG_MMF_DEMUXER 0
-#define CONFIG_MMF_MUXER 0
-#define CONFIG_MMSH_PROTOCOL 0
-#define CONFIG_MMST_PROTOCOL 0
-#define CONFIG_MMVIDEO_DECODER 0
-#define CONFIG_MOTIONPIXELS_DECODER 0
-#define CONFIG_MOV2TEXTSUB_BSF 0
-#define CONFIG_MOV_DEMUXER 0
-#define CONFIG_MOVIE_FILTER 0
-#define CONFIG_MOV_MUXER 0
-#define CONFIG_MOVTEXT_DECODER 0
-#define CONFIG_MOVTEXT_ENCODER 0
-#define CONFIG_MP1_AT_DECODER 0
-#define CONFIG_MP1_DECODER 0
-#define CONFIG_MP1FLOAT_DECODER 0
-#define CONFIG_MP2_AT_DECODER 0
-#define CONFIG_MP2_DECODER 0
-#define CONFIG_MP2_ENCODER 0
-#define CONFIG_MP2FIXED_ENCODER 0
-#define CONFIG_MP2FLOAT_DECODER 0
-#define CONFIG_MP2_MUXER 0
-#define CONFIG_MP3ADU_DECODER 0
-#define CONFIG_MP3ADUFLOAT_DECODER 0
-#define CONFIG_MP3_AT_DECODER 0
-#define CONFIG_MP3_DEMUXER 0
-#define CONFIG_MP3FLOAT_DECODER 0
-#define CONFIG_MP3_HEADER_DECOMPRESS_BSF 0
-#define CONFIG_MP3_MUXER 0
-#define CONFIG_MP3ON4_DECODER 0
-#define CONFIG_MP3ON4FLOAT_DECODER 0
-#define CONFIG_MP4_MUXER 0
-#define CONFIG_MPC7_DECODER 0
-#define CONFIG_MPC8_DECODER 0
-#define CONFIG_MPC8_DEMUXER 0
-#define CONFIG_MPC_DEMUXER 0
-#define CONFIG_MPDECIMATE_FILTER 0
-#define CONFIG_MPEG1_CUVID_DECODER 0
-#define CONFIG_MPEG1_NVDEC_HWACCEL 0
-#define CONFIG_MPEG1SYSTEM_MUXER 0
-#define CONFIG_MPEG1_V4L2M2M_DECODER 0
-#define CONFIG_MPEG1VCD_MUXER 0
-#define CONFIG_MPEG1_VDPAU_HWACCEL 0
-#define CONFIG_MPEG1VIDEO_DECODER 0
-#define CONFIG_MPEG1VIDEO_ENCODER 0
-#define CONFIG_MPEG1VIDEO_MUXER 0
-#define CONFIG_MPEG1_VIDEOTOOLBOX_HWACCEL 0
-#define CONFIG_MPEG1_XVMC_HWACCEL 0
-#define CONFIG_MPEG2_CRYSTALHD_DECODER 0
-#define CONFIG_MPEG2_CUVID_DECODER 0
-#define CONFIG_MPEG2_D3D11VA2_HWACCEL 0
-#define CONFIG_MPEG2_D3D11VA_HWACCEL 0
-#define CONFIG_MPEG2DVD_MUXER 0
-#define CONFIG_MPEG2_DXVA2_HWACCEL 0
-#define CONFIG_MPEG2_MEDIACODEC_DECODER 0
-#define CONFIG_MPEG2_METADATA_BSF 0
-#define CONFIG_MPEG2_MMAL_DECODER 0
-#define CONFIG_MPEG2_NVDEC_HWACCEL 0
-#define CONFIG_MPEG2_QSV_DECODER 0
-#define CONFIG_MPEG2_QSV_ENCODER 0
-#define CONFIG_MPEG2SVCD_MUXER 0
-#define CONFIG_MPEG2_V4L2M2M_DECODER 0
-#define CONFIG_MPEG2_VAAPI_ENCODER 0
-#define CONFIG_MPEG2_VAAPI_HWACCEL 0
-#define CONFIG_MPEG2_VDPAU_HWACCEL 0
-#define CONFIG_MPEG2VIDEO_DECODER 0
-#define CONFIG_MPEG2VIDEO_ENCODER 0
-#define CONFIG_MPEG2VIDEO_MUXER 0
-#define CONFIG_MPEG2_VIDEOTOOLBOX_HWACCEL 0
-#define CONFIG_MPEG2VOB_MUXER 0
-#define CONFIG_MPEG2_XVMC_HWACCEL 0
-#define CONFIG_MPEG4_CRYSTALHD_DECODER 0
-#define CONFIG_MPEG4_CUVID_DECODER 0
-#define CONFIG_MPEG4_DECODER 0
-#define CONFIG_MPEG4_ENCODER 0
-#define CONFIG_MPEG4_MEDIACODEC_DECODER 0
-#define CONFIG_MPEG4_MMAL_DECODER 0
-#define CONFIG_MPEG4_NVDEC_HWACCEL 0
-#define CONFIG_MPEG4_UNPACK_BFRAMES_BSF 0
-#define CONFIG_MPEG4_V4L2M2M_DECODER 0
-#define CONFIG_MPEG4_V4L2M2M_ENCODER 0
-#define CONFIG_MPEG4_VAAPI_HWACCEL 0
-#define CONFIG_MPEG4_VDPAU_HWACCEL 0
-#define CONFIG_MPEG4VIDEO_PARSER 0
-#define CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL 0
-#define CONFIG_MPEGAUDIO_PARSER 0
-#define CONFIG_MPEGPS_DEMUXER 0
-#define CONFIG_MPEGTS_DEMUXER 0
-#define CONFIG_MPEGTS_MUXER 0
-#define CONFIG_MPEGTSRAW_DEMUXER 0
-#define CONFIG_MPEGVIDEO_DECODER 0
-#define CONFIG_MPEGVIDEO_DEMUXER 0
-#define CONFIG_MPEGVIDEO_PARSER 0
-#define CONFIG_MPJPEG_DEMUXER 0
-#define CONFIG_MPJPEG_MUXER 0
-#define CONFIG_MPL2_DECODER 0
-#define CONFIG_MPL2_DEMUXER 0
-#define CONFIG_MPSUB_DEMUXER 0
-#define CONFIG_MPTESTSRC_FILTER 0
-#define CONFIG_MSA1_DECODER 0
-#define CONFIG_MSCC_DECODER 0
-#define CONFIG_MSF_DEMUXER 0
-#define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
-#define CONFIG_MSMPEG4V1_DECODER 0
-#define CONFIG_MSMPEG4V2_DECODER 0
-#define CONFIG_MSMPEG4V2_ENCODER 0
-#define CONFIG_MSMPEG4V3_DECODER 0
-#define CONFIG_MSMPEG4V3_ENCODER 0
-#define CONFIG_MSNWC_TCP_DEMUXER 0
-#define CONFIG_MSRLE_DECODER 0
-#define CONFIG_MSS1_DECODER 0
-#define CONFIG_MSS2_DECODER 0
-#define CONFIG_MSVIDEO1_DECODER 0
-#define CONFIG_MSVIDEO1_ENCODER 0
-#define CONFIG_MSZH_DECODER 0
-#define CONFIG_MTAF_DEMUXER 0
-#define CONFIG_MTS2_DECODER 0
-#define CONFIG_MTV_DEMUXER 0
-#define CONFIG_MUSX_DEMUXER 0
-#define CONFIG_MUXERS 0
-#define CONFIG_MVC1_DECODER 0
-#define CONFIG_MVC2_DECODER 0
-#define CONFIG_MV_DEMUXER 0
-#define CONFIG_MVI_DEMUXER 0
-#define CONFIG_MWSC_DECODER 0
-#define CONFIG_MXF_D10_MUXER 0
-#define CONFIG_MXF_DEMUXER 0
-#define CONFIG_MXF_MUXER 0
-#define CONFIG_MXF_OPATOM_MUXER 0
-#define CONFIG_MXG_DEMUXER 0
-#define CONFIG_MXPEG_DECODER 0
-#define CONFIG_NC_DEMUXER 0
-#define CONFIG_NEGATE_FILTER 0
-#define CONFIG_NELLYMOSER_DECODER 0
-#define CONFIG_NELLYMOSER_ENCODER 0
-#define CONFIG_NISTSPHERE_DEMUXER 0
-#define CONFIG_NLMEANS_FILTER 0
-#define CONFIG_NLMEANS_OPENCL_FILTER 0
-#define CONFIG_NNEDI_FILTER 0
-#define CONFIG_NOFORMAT_FILTER 0
-#define CONFIG_NOISE_BSF 0
-#define CONFIG_NOISE_FILTER 0
-#define CONFIG_NORMALIZE_FILTER 0
-#define CONFIG_NSP_DEMUXER 0
-#define CONFIG_NSV_DEMUXER 0
-#define CONFIG_NULL_FILTER 0
-#define CONFIG_NULL_MUXER 0
-#define CONFIG_NULLSINK_FILTER 0
-#define CONFIG_NULLSRC_FILTER 0
-#define CONFIG_NUT_DEMUXER 0
-#define CONFIG_NUT_MUXER 0
-#define CONFIG_NUV_DECODER 0
-#define CONFIG_NUV_DEMUXER 0
-#define CONFIG_NVENC_ENCODER 0
-#define CONFIG_NVENC_H264_ENCODER 0
-#define CONFIG_NVENC_HEVC_ENCODER 0
-#define CONFIG_OCR_FILTER 0
-#define CONFIG_OCV_FILTER 0
-#define CONFIG_OGA_MUXER 0
-#define CONFIG_OGG_DEMUXER 0
-#define CONFIG_OGG_MUXER 0
-#define CONFIG_OGV_MUXER 0
-#define CONFIG_OMA_DEMUXER 0
-#define CONFIG_OMA_MUXER 0
-#define CONFIG_ON2AVC_DECODER 0
-#define CONFIG_OPENAL_INDEV 0
-#define CONFIG_OPENCLSRC_FILTER 0
-#define CONFIG_OPENGL_OUTDEV 0
-#define CONFIG_OPUS_DECODER 0
-#define CONFIG_OPUS_ENCODER 0
-#define CONFIG_OPUS_MUXER 0
-#define CONFIG_OPUS_PARSER 0
-#define CONFIG_OSCILLOSCOPE_FILTER 0
-#define CONFIG_OSS_INDEV 0
-#define CONFIG_OSS_OUTDEV 0
-#define CONFIG_OUTDEVS 0
-#define CONFIG_OVERLAY_FILTER 0
-#define CONFIG_OVERLAY_OPENCL_FILTER 0
-#define CONFIG_OVERLAY_QSV_FILTER 0
-#define CONFIG_OWDENOISE_FILTER 0
-#define CONFIG_PAD_FILTER 0
-#define CONFIG_PAF_AUDIO_DECODER 0
-#define CONFIG_PAF_DEMUXER 0
-#define CONFIG_PAF_VIDEO_DECODER 0
-#define CONFIG_PAL100BARS_FILTER 0
-#define CONFIG_PAL75BARS_FILTER 0
-#define CONFIG_PALETTEGEN_FILTER 0
-#define CONFIG_PALETTEUSE_FILTER 0
-#define CONFIG_PAM_DECODER 0
-#define CONFIG_PAM_ENCODER 0
-#define CONFIG_PAN_FILTER 0
-#define CONFIG_PBM_DECODER 0
-#define CONFIG_PBM_ENCODER 0
-#define CONFIG_PCM_ALAW_AT_DECODER 0
-#define CONFIG_PCM_ALAW_AT_ENCODER 0
-#define CONFIG_PCM_ALAW_DECODER 0
-#define CONFIG_PCM_ALAW_DEMUXER 0
-#define CONFIG_PCM_ALAW_ENCODER 0
-#define CONFIG_PCM_ALAW_MUXER 0
-#define CONFIG_PCM_BLURAY_DECODER 0
-#define CONFIG_PCM_DVD_DECODER 0
-#define CONFIG_PCM_DVD_ENCODER 0
-#define CONFIG_PCM_F16LE_DECODER 0
-#define CONFIG_PCM_F24LE_DECODER 0
-#define CONFIG_PCM_F32BE_DECODER 0
-#define CONFIG_PCM_F32BE_DEMUXER 0
-#define CONFIG_PCM_F32BE_ENCODER 0
-#define CONFIG_PCM_F32BE_MUXER 0
-#define CONFIG_PCM_F32LE_DECODER 0
-#define CONFIG_PCM_F32LE_DEMUXER 0
-#define CONFIG_PCM_F32LE_ENCODER 0
-#define CONFIG_PCM_F32LE_MUXER 0
-#define CONFIG_PCM_F64BE_DECODER 0
-#define CONFIG_PCM_F64BE_DEMUXER 0
-#define CONFIG_PCM_F64BE_ENCODER 0
-#define CONFIG_PCM_F64BE_MUXER 0
-#define CONFIG_PCM_F64LE_DECODER 0
-#define CONFIG_PCM_F64LE_DEMUXER 0
-#define CONFIG_PCM_F64LE_ENCODER 0
-#define CONFIG_PCM_F64LE_MUXER 0
-#define CONFIG_PCM_LXF_DECODER 0
-#define CONFIG_PCM_MULAW_AT_DECODER 0
-#define CONFIG_PCM_MULAW_AT_ENCODER 0
-#define CONFIG_PCM_MULAW_DECODER 0
-#define CONFIG_PCM_MULAW_DEMUXER 0
-#define CONFIG_PCM_MULAW_ENCODER 0
-#define CONFIG_PCM_MULAW_MUXER 0
-#define CONFIG_PCM_S16BE_DECODER 0
-#define CONFIG_PCM_S16BE_DEMUXER 0
-#define CONFIG_PCM_S16BE_ENCODER 0
-#define CONFIG_PCM_S16BE_MUXER 0
-#define CONFIG_PCM_S16BE_PLANAR_DECODER 0
-#define CONFIG_PCM_S16BE_PLANAR_ENCODER 0
-#define CONFIG_PCM_S16LE_DECODER 0
-#define CONFIG_PCM_S16LE_DEMUXER 0
-#define CONFIG_PCM_S16LE_ENCODER 0
-#define CONFIG_PCM_S16LE_MUXER 0
-#define CONFIG_PCM_S16LE_PLANAR_DECODER 0
-#define CONFIG_PCM_S16LE_PLANAR_ENCODER 0
-#define CONFIG_PCM_S24BE_DECODER 0
-#define CONFIG_PCM_S24BE_DEMUXER 0
-#define CONFIG_PCM_S24BE_ENCODER 0
-#define CONFIG_PCM_S24BE_MUXER 0
-#define CONFIG_PCM_S24DAUD_DECODER 0
-#define CONFIG_PCM_S24DAUD_ENCODER 0
-#define CONFIG_PCM_S24LE_DECODER 0
-#define CONFIG_PCM_S24LE_DEMUXER 0
-#define CONFIG_PCM_S24LE_ENCODER 0
-#define CONFIG_PCM_S24LE_MUXER 0
-#define CONFIG_PCM_S24LE_PLANAR_DECODER 0
-#define CONFIG_PCM_S24LE_PLANAR_ENCODER 0
-#define CONFIG_PCM_S32BE_DECODER 0
-#define CONFIG_PCM_S32BE_DEMUXER 0
-#define CONFIG_PCM_S32BE_ENCODER 0
-#define CONFIG_PCM_S32BE_MUXER 0
-#define CONFIG_PCM_S32LE_DECODER 0
-#define CONFIG_PCM_S32LE_DEMUXER 0
-#define CONFIG_PCM_S32LE_ENCODER 0
-#define CONFIG_PCM_S32LE_MUXER 0
-#define CONFIG_PCM_S32LE_PLANAR_DECODER 0
-#define CONFIG_PCM_S32LE_PLANAR_ENCODER 0
-#define CONFIG_PCM_S64BE_DECODER 0
-#define CONFIG_PCM_S64BE_ENCODER 0
-#define CONFIG_PCM_S64LE_DECODER 0
-#define CONFIG_PCM_S64LE_ENCODER 0
-#define CONFIG_PCM_S8_DECODER 0
-#define CONFIG_PCM_S8_DEMUXER 0
-#define CONFIG_PCM_S8_ENCODER 0
-#define CONFIG_PCM_S8_MUXER 0
-#define CONFIG_PCM_S8_PLANAR_DECODER 0
-#define CONFIG_PCM_S8_PLANAR_ENCODER 0
-#define CONFIG_PCM_U16BE_DECODER 0
-#define CONFIG_PCM_U16BE_DEMUXER 0
-#define CONFIG_PCM_U16BE_ENCODER 0
-#define CONFIG_PCM_U16BE_MUXER 0
-#define CONFIG_PCM_U16LE_DECODER 0
-#define CONFIG_PCM_U16LE_DEMUXER 0
-#define CONFIG_PCM_U16LE_ENCODER 0
-#define CONFIG_PCM_U16LE_MUXER 0
-#define CONFIG_PCM_U24BE_DECODER 0
-#define CONFIG_PCM_U24BE_DEMUXER 0
-#define CONFIG_PCM_U24BE_ENCODER 0
-#define CONFIG_PCM_U24BE_MUXER 0
-#define CONFIG_PCM_U24LE_DECODER 0
-#define CONFIG_PCM_U24LE_DEMUXER 0
-#define CONFIG_PCM_U24LE_ENCODER 0
-#define CONFIG_PCM_U24LE_MUXER 0
-#define CONFIG_PCM_U32BE_DECODER 0
-#define CONFIG_PCM_U32BE_DEMUXER 0
-#define CONFIG_PCM_U32BE_ENCODER 0
-#define CONFIG_PCM_U32BE_MUXER 0
-#define CONFIG_PCM_U32LE_DECODER 0
-#define CONFIG_PCM_U32LE_DEMUXER 0
-#define CONFIG_PCM_U32LE_ENCODER 0
-#define CONFIG_PCM_U32LE_MUXER 0
-#define CONFIG_PCM_U8_DECODER 0
-#define CONFIG_PCM_U8_DEMUXER 0
-#define CONFIG_PCM_U8_ENCODER 0
-#define CONFIG_PCM_U8_MUXER 0
-#define CONFIG_PCM_VIDC_DECODER 0
-#define CONFIG_PCM_VIDC_DEMUXER 0
-#define CONFIG_PCM_VIDC_ENCODER 0
-#define CONFIG_PCM_VIDC_MUXER 0
-#define CONFIG_PCM_ZORK_DECODER 0
-#define CONFIG_PCX_DECODER 0
-#define CONFIG_PCX_ENCODER 0
-#define CONFIG_PERMS_FILTER 0
-#define CONFIG_PERSPECTIVE_FILTER 0
-#define CONFIG_PGM_DECODER 0
-#define CONFIG_PGM_ENCODER 0
-#define CONFIG_PGMYUV_DECODER 0
-#define CONFIG_PGMYUV_ENCODER 0
-#define CONFIG_PGSSUB_DECODER 0
-#define CONFIG_PHASE_FILTER 0
-#define CONFIG_PICTOR_DECODER 0
-#define CONFIG_PIPE_PROTOCOL 0
-#define CONFIG_PIXDESCTEST_FILTER 0
-#define CONFIG_PIXLET_DECODER 0
-#define CONFIG_PIXSCOPE_FILTER 0
-#define CONFIG_PJS_DECODER 0
-#define CONFIG_PJS_DEMUXER 0
-#define CONFIG_PMP_DEMUXER 0
-#define CONFIG_PNG_DECODER 0
-#define CONFIG_PNG_ENCODER 0
-#define CONFIG_PNG_PARSER 0
-#define CONFIG_PNM_PARSER 0
-#define CONFIG_PP7_FILTER 0
-#define CONFIG_PP_FILTER 0
-#define CONFIG_PPM_DECODER 0
-#define CONFIG_PPM_ENCODER 0
-#define CONFIG_PREMULTIPLY_FILTER 0
-#define CONFIG_PREWITT_FILTER 0
-#define CONFIG_PREWITT_OPENCL_FILTER 0
-#define CONFIG_PROCAMP_VAAPI_FILTER 0
-#define CONFIG_PROGRAM_OPENCL_FILTER 0
-#define CONFIG_PROMPEG_PROTOCOL 0
-#define CONFIG_PRORES_AW_ENCODER 0
-#define CONFIG_PRORES_DECODER 0
-#define CONFIG_PRORES_ENCODER 0
-#define CONFIG_PRORES_KS_ENCODER 0
-#define CONFIG_PRORES_METADATA_BSF 0
-#define CONFIG_PROSUMER_DECODER 0
-#define CONFIG_PROTOCOLS 0
-#define CONFIG_PSD_DECODER 0
-#define CONFIG_PSEUDOCOLOR_FILTER 0
-#define CONFIG_PSNR_FILTER 0
-#define CONFIG_PSP_MUXER 0
-#define CONFIG_PTX_DECODER 0
-#define CONFIG_PULLUP_FILTER 0
-#define CONFIG_PULSE_INDEV 0
-#define CONFIG_PULSE_OUTDEV 0
-#define CONFIG_PVA_DEMUXER 0
-#define CONFIG_PVF_DEMUXER 0
-#define CONFIG_QCELP_DECODER 0
-#define CONFIG_QCP_DEMUXER 0
-#define CONFIG_QDM2_AT_DECODER 0
-#define CONFIG_QDM2_DECODER 0
-#define CONFIG_QDMC_AT_DECODER 0
-#define CONFIG_QDMC_DECODER 0
-#define CONFIG_QDRAW_DECODER 0
-#define CONFIG_QPEG_DECODER 0
-#define CONFIG_QP_FILTER 0
-#define CONFIG_QTRLE_DECODER 0
-#define CONFIG_QTRLE_ENCODER 0
-#define CONFIG_R10K_DECODER 0
-#define CONFIG_R10K_ENCODER 0
-#define CONFIG_R210_DECODER 0
-#define CONFIG_R210_ENCODER 0
-#define CONFIG_R3D_DEMUXER 0
-#define CONFIG_RA_144_DECODER 0
-#define CONFIG_RA_144_ENCODER 0
-#define CONFIG_RA_288_DECODER 0
-#define CONFIG_RALF_DECODER 0
-#define CONFIG_RANDOM_FILTER 0
-#define CONFIG_RASC_DECODER 0
-#define CONFIG_RAWVIDEO_DECODER 0
-#define CONFIG_RAWVIDEO_DEMUXER 0
-#define CONFIG_RAWVIDEO_ENCODER 0
-#define CONFIG_RAWVIDEO_MUXER 0
-#define CONFIG_READEIA608_FILTER 0
-#define CONFIG_READVITC_FILTER 0
-#define CONFIG_REALTEXT_DECODER 0
-#define CONFIG_REALTEXT_DEMUXER 0
-#define CONFIG_REALTIME_FILTER 0
-#define CONFIG_REDSPARK_DEMUXER 0
-#define CONFIG_REMAP_FILTER 0
-#define CONFIG_REMOVE_EXTRADATA_BSF 0
-#define CONFIG_REMOVEGRAIN_FILTER 0
-#define CONFIG_REMOVELOGO_FILTER 0
-#define CONFIG_REPEATFIELDS_FILTER 0
-#define CONFIG_REPLAYGAIN_FILTER 0
-#define CONFIG_RESAMPLE_FILTER 0
-#define CONFIG_REVERSE_FILTER 0
-#define CONFIG_RGBASHIFT_FILTER 0
-#define CONFIG_RGBTESTSRC_FILTER 0
-#define CONFIG_RL2_DECODER 0
-#define CONFIG_RL2_DEMUXER 0
-#define CONFIG_RM_DEMUXER 0
-#define CONFIG_RM_MUXER 0
-#define CONFIG_ROBERTS_FILTER 0
-#define CONFIG_ROBERTS_OPENCL_FILTER 0
-#define CONFIG_ROQ_DECODER 0
-#define CONFIG_ROQ_DEMUXER 0
-#define CONFIG_ROQ_DPCM_DECODER 0
-#define CONFIG_ROQ_DPCM_ENCODER 0
-#define CONFIG_ROQ_ENCODER 0
-#define CONFIG_ROQ_MUXER 0
-#define CONFIG_ROTATE_FILTER 0
-#define CONFIG_RPL_DEMUXER 0
-#define CONFIG_RPZA_DECODER 0
-#define CONFIG_RSCC_DECODER 0
-#define CONFIG_RSD_DEMUXER 0
-#define CONFIG_RSO_DEMUXER 0
-#define CONFIG_RSO_MUXER 0
-#define CONFIG_RTMPE_PROTOCOL 0
-#define CONFIG_RTMP_PROTOCOL 0
-#define CONFIG_RTMPS_PROTOCOL 0
-#define CONFIG_RTMPTE_PROTOCOL 0
-#define CONFIG_RTMPT_PROTOCOL 0
-#define CONFIG_RTMPTS_PROTOCOL 0
-#define CONFIG_RTP_DEMUXER 0
-#define CONFIG_RTP_MPEGTS_MUXER 0
-#define CONFIG_RTP_MUXER 0
-#define CONFIG_RTP_PROTOCOL 0
-#define CONFIG_RTSP_DEMUXER 0
-#define CONFIG_RTSP_MUXER 0
-#define CONFIG_RUBBERBAND_FILTER 0
-#define CONFIG_RV10_DECODER 0
-#define CONFIG_RV10_ENCODER 0
-#define CONFIG_RV20_DECODER 0
-#define CONFIG_RV20_ENCODER 0
-#define CONFIG_RV30_DECODER 0
-#define CONFIG_RV30_PARSER 0
-#define CONFIG_RV40_DECODER 0
-#define CONFIG_RV40_PARSER 0
-#define CONFIG_S302M_DECODER 0
-#define CONFIG_S302M_ENCODER 0
-#define CONFIG_S337M_DEMUXER 0
-#define CONFIG_SAB_FILTER 0
-#define CONFIG_SAMI_DECODER 0
-#define CONFIG_SAMI_DEMUXER 0
-#define CONFIG_SANM_DECODER 0
-#define CONFIG_SAP_DEMUXER 0
-#define CONFIG_SAP_MUXER 0
-#define CONFIG_SBC_DECODER 0
-#define CONFIG_SBC_DEMUXER 0
-#define CONFIG_SBC_ENCODER 0
-#define CONFIG_SBC_MUXER 0
-#define CONFIG_SBC_PARSER 0
-#define CONFIG_SBG_DEMUXER 0
-#define CONFIG_SCALE2REF_FILTER 0
-#define CONFIG_SCALE_CUDA_FILTER 0
-#define CONFIG_SCALE_FILTER 0
-#define CONFIG_SCALE_NPP_FILTER 0
-#define CONFIG_SCALE_QSV_FILTER 0
-#define CONFIG_SCALE_VAAPI_FILTER 0
-#define CONFIG_SCC_DEMUXER 0
-#define CONFIG_SCC_MUXER 0
-#define CONFIG_SCPR_DECODER 0
-#define CONFIG_SCREENPRESSO_DECODER 0
-#define CONFIG_SCTP_PROTOCOL 0
-#define CONFIG_SDL2_OUTDEV 0
-#define CONFIG_SDP_DEMUXER 0
-#define CONFIG_SDR2_DEMUXER 0
-#define CONFIG_SDS_DEMUXER 0
-#define CONFIG_SDX2_DPCM_DECODER 0
-#define CONFIG_SDX_DEMUXER 0
-#define CONFIG_SEGAFILM_DEMUXER 0
-#define CONFIG_SEGAFILM_MUXER 0
-#define CONFIG_SEGMENT_MUXER 0
-#define CONFIG_SELECT_FILTER 0
-#define CONFIG_SELECTIVECOLOR_FILTER 0
-#define CONFIG_SENDCMD_FILTER 0
-#define CONFIG_SEPARATEFIELDS_FILTER 0
-#define CONFIG_SER_DEMUXER 0
-#define CONFIG_SETDAR_FILTER 0
-#define CONFIG_SETFIELD_FILTER 0
-#define CONFIG_SETPARAMS_FILTER 0
-#define CONFIG_SETPTS_FILTER 0
-#define CONFIG_SETRANGE_FILTER 0
-#define CONFIG_SETSAR_FILTER 0
-#define CONFIG_SETTB_FILTER 0
-#define CONFIG_SGI_DECODER 0
-#define CONFIG_SGI_ENCODER 0
-#define CONFIG_SGIRLE_DECODER 0
-#define CONFIG_SHARPNESS_VAAPI_FILTER 0
-#define CONFIG_SHEERVIDEO_DECODER 0
-#define CONFIG_SHORTEN_DECODER 0
-#define CONFIG_SHORTEN_DEMUXER 0
-#define CONFIG_SHOWCQT_FILTER 0
-#define CONFIG_SHOWFREQS_FILTER 0
-#define CONFIG_SHOWINFO_FILTER 0
-#define CONFIG_SHOWPALETTE_FILTER 0
-#define CONFIG_SHOWSPATIAL_FILTER 0
-#define CONFIG_SHOWSPECTRUM_FILTER 0
-#define CONFIG_SHOWSPECTRUMPIC_FILTER 0
-#define CONFIG_SHOWVOLUME_FILTER 0
-#define CONFIG_SHOWWAVES_FILTER 0
-#define CONFIG_SHOWWAVESPIC_FILTER 0
-#define CONFIG_SHUFFLEFRAMES_FILTER 0
-#define CONFIG_SHUFFLEPLANES_FILTER 0
-#define CONFIG_SIDECHAINCOMPRESS_FILTER 0
-#define CONFIG_SIDECHAINGATE_FILTER 0
-#define CONFIG_SIDEDATA_FILTER 0
-#define CONFIG_SIFF_DEMUXER 0
-#define CONFIG_SIGNALSTATS_FILTER 0
-#define CONFIG_SIGNATURE_FILTER 0
-#define CONFIG_SILENCEDETECT_FILTER 0
-#define CONFIG_SILENCEREMOVE_FILTER 0
-#define CONFIG_SINC_FILTER 0
-#define CONFIG_SINE_FILTER 0
-#define CONFIG_SINGLEJPEG_MUXER 0
-#define CONFIG_SIPR_DECODER 0
-#define CONFIG_SIPR_PARSER 0
-#define CONFIG_SLN_DEMUXER 0
-#define CONFIG_SMACKAUD_DECODER 0
-#define CONFIG_SMACKER_DECODER 0
-#define CONFIG_SMACKER_DEMUXER 0
-#define CONFIG_SMARTBLUR_FILTER 0
-#define CONFIG_SMC_DECODER 0
-#define CONFIG_SMJPEG_DEMUXER 0
-#define CONFIG_SMJPEG_MUXER 0
-#define CONFIG_SMOOTHSTREAMING_MUXER 0
-#define CONFIG_SMPTEBARS_FILTER 0
-#define CONFIG_SMPTEHDBARS_FILTER 0
-#define CONFIG_SMUSH_DEMUXER 0
-#define CONFIG_SMVJPEG_DECODER 0
-#define CONFIG_SNDIO_INDEV 0
-#define CONFIG_SNDIO_OUTDEV 0
-#define CONFIG_SNOW_DECODER 0
-#define CONFIG_SNOW_ENCODER 0
-#define CONFIG_SOBEL_FILTER 0
-#define CONFIG_SOBEL_OPENCL_FILTER 0
-#define CONFIG_SOFALIZER_FILTER 0
-#define CONFIG_SOL_DEMUXER 0
-#define CONFIG_SOL_DPCM_DECODER 0
-#define CONFIG_SONIC_DECODER 0
-#define CONFIG_SONIC_ENCODER 0
-#define CONFIG_SONIC_LS_ENCODER 0
-#define CONFIG_SOX_DEMUXER 0
-#define CONFIG_SOX_MUXER 0
-#define CONFIG_SP5X_DECODER 0
-#define CONFIG_SPDIF_DEMUXER 0
-#define CONFIG_SPDIF_MUXER 0
-#define CONFIG_SPECTRUMSYNTH_FILTER 0
-#define CONFIG_SPEEDHQ_DECODER 0
-#define CONFIG_SPLIT_FILTER 0
-#define CONFIG_SPP_FILTER 0
-#define CONFIG_SPX_MUXER 0
-#define CONFIG_SR_FILTER 0
-#define CONFIG_SRGC_DECODER 0
-#define CONFIG_SRT_DECODER 0
-#define CONFIG_SRT_DEMUXER 0
-#define CONFIG_SRT_ENCODER 0
-#define CONFIG_SRT_MUXER 0
-#define CONFIG_SRTP_PROTOCOL 0
-#define CONFIG_SSA_DECODER 0
-#define CONFIG_SSA_ENCODER 0
-#define CONFIG_SSIM_FILTER 0
-#define CONFIG_STEREO3D_FILTER 0
-#define CONFIG_STEREOTOOLS_FILTER 0
-#define CONFIG_STEREOWIDEN_FILTER 0
-#define CONFIG_STL_DECODER 0
-#define CONFIG_STL_DEMUXER 0
-#define CONFIG_STR_DEMUXER 0
-#define CONFIG_STREAM_SEGMENT_MUXER 0
-#define CONFIG_STREAMSELECT_FILTER 0
-#define CONFIG_SUBFILE_PROTOCOL 0
-#define CONFIG_SUBRIP_DECODER 0
-#define CONFIG_SUBRIP_ENCODER 0
-#define CONFIG_SUBTITLES_FILTER 0
-#define CONFIG_SUBVIEWER1_DECODER 0
-#define CONFIG_SUBVIEWER1_DEMUXER 0
-#define CONFIG_SUBVIEWER_DECODER 0
-#define CONFIG_SUBVIEWER_DEMUXER 0
-#define CONFIG_SUNRAST_DECODER 0
-#define CONFIG_SUNRAST_ENCODER 0
-#define CONFIG_SUP_DEMUXER 0
-#define CONFIG_SUPER2XSAI_FILTER 0
-#define CONFIG_SUPEREQUALIZER_FILTER 0
-#define CONFIG_SUP_MUXER 0
-#define CONFIG_SURROUND_FILTER 0
-#define CONFIG_SVAG_DEMUXER 0
-#define CONFIG_SVQ1_DECODER 0
-#define CONFIG_SVQ1_ENCODER 0
-#define CONFIG_SVQ3_DECODER 0
-#define CONFIG_SWAPRECT_FILTER 0
-#define CONFIG_SWAPUV_FILTER 0
-#define CONFIG_SWF_DEMUXER 0
-#define CONFIG_SWF_MUXER 0
-#define CONFIG_TAK_DECODER 0
-#define CONFIG_TAK_DEMUXER 0
-#define CONFIG_TAK_PARSER 0
-#define CONFIG_TARGA_DECODER 0
-#define CONFIG_TARGA_ENCODER 0
-#define CONFIG_TARGA_Y216_DECODER 0
-#define CONFIG_TBLEND_FILTER 0
-#define CONFIG_TCP_PROTOCOL 0
-#define CONFIG_TDSC_DECODER 0
-#define CONFIG_TEDCAPTIONS_DEMUXER 0
-#define CONFIG_TEE_MUXER 0
-#define CONFIG_TEE_PROTOCOL 0
-#define CONFIG_TELECINE_FILTER 0
-#define CONFIG_TESTSRC2_FILTER 0
-#define CONFIG_TESTSRC_FILTER 0
-#define CONFIG_TEXT2MOVSUB_BSF 0
-#define CONFIG_TEXT_DECODER 0
-#define CONFIG_TEXT_ENCODER 0
-#define CONFIG_TG2_MUXER 0
-#define CONFIG_TGP_MUXER 0
-#define CONFIG_THEORA_DECODER 0
-#define CONFIG_THP_DECODER 0
-#define CONFIG_THP_DEMUXER 0
-#define CONFIG_THREEDOSTR_DEMUXER 0
-#define CONFIG_THRESHOLD_FILTER 0
-#define CONFIG_THUMBNAIL_CUDA_FILTER 0
-#define CONFIG_THUMBNAIL_FILTER 0
-#define CONFIG_TIERTEXSEQ_DEMUXER 0
-#define CONFIG_TIERTEXSEQVIDEO_DECODER 0
-#define CONFIG_TIFF_DECODER 0
-#define CONFIG_TIFF_ENCODER 0
-#define CONFIG_TILE_FILTER 0
-#define CONFIG_TINTERLACE_FILTER 0
-#define CONFIG_TLS_PROTOCOL 0
-#define CONFIG_TLUT2_FILTER 0
-#define CONFIG_TMIX_FILTER 0
-#define CONFIG_TMV_DECODER 0
-#define CONFIG_TMV_DEMUXER 0
-#define CONFIG_TONEMAP_FILTER 0
-#define CONFIG_TONEMAP_OPENCL_FILTER 0
-#define CONFIG_TPAD_FILTER 0
-#define CONFIG_TRACE_HEADERS_BSF 0
-#define CONFIG_TRANSPOSE_FILTER 0
-#define CONFIG_TRANSPOSE_NPP_FILTER 0
-#define CONFIG_TRANSPOSE_OPENCL_FILTER 0
-#define CONFIG_TRANSPOSE_VAAPI_FILTER 0
-#define CONFIG_TREBLE_FILTER 0
-#define CONFIG_TREMOLO_FILTER 0
-#define CONFIG_TRIM_FILTER 0
-#define CONFIG_TRUEHD_CORE_BSF 0
-#define CONFIG_TRUEHD_DECODER 0
-#define CONFIG_TRUEHD_DEMUXER 0
-#define CONFIG_TRUEHD_ENCODER 0
-#define CONFIG_TRUEHD_MUXER 0
-#define CONFIG_TRUEMOTION1_DECODER 0
-#define CONFIG_TRUEMOTION2_DECODER 0
-#define CONFIG_TRUEMOTION2RT_DECODER 0
-#define CONFIG_TRUESPEECH_DECODER 0
-#define CONFIG_TSCC2_DECODER 0
-#define CONFIG_TSCC_DECODER 0
-#define CONFIG_TTA_DECODER 0
-#define CONFIG_TTA_DEMUXER 0
-#define CONFIG_TTA_ENCODER 0
-#define CONFIG_TTA_MUXER 0
-#define CONFIG_TTY_DEMUXER 0
-#define CONFIG_TWINVQ_DECODER 0
-#define CONFIG_TXD_DECODER 0
-#define CONFIG_TXD_DEMUXER 0
-#define CONFIG_TY_DEMUXER 0
-#define CONFIG_UDPLITE_PROTOCOL 0
-#define CONFIG_UDP_PROTOCOL 0
-#define CONFIG_ULTI_DECODER 0
-#define CONFIG_UNCODEDFRAMECRC_MUXER 0
-#define CONFIG_UNIX_PROTOCOL 0
-#define CONFIG_UNPREMULTIPLY_FILTER 0
-#define CONFIG_UNSHARP_FILTER 0
-#define CONFIG_UNSHARP_OPENCL_FILTER 0
-#define CONFIG_USPP_FILTER 0
-#define CONFIG_UTVIDEO_DECODER 0
-#define CONFIG_UTVIDEO_ENCODER 0
-#define CONFIG_V210_DECODER 0
-#define CONFIG_V210_DEMUXER 0
-#define CONFIG_V210_ENCODER 0
-#define CONFIG_V210X_DECODER 0
-#define CONFIG_V210X_DEMUXER 0
-#define CONFIG_V308_DECODER 0
-#define CONFIG_V308_ENCODER 0
-#define CONFIG_V408_DECODER 0
-#define CONFIG_V408_ENCODER 0
-#define CONFIG_V410_DECODER 0
-#define CONFIG_V410_ENCODER 0
-#define CONFIG_V4L2_INDEV 0
-#define CONFIG_V4L2_OUTDEV 0
-#define CONFIG_VAG_DEMUXER 0
-#define CONFIG_VAGUEDENOISER_FILTER 0
-#define CONFIG_VAPOURSYNTH_DEMUXER 0
-#define CONFIG_VB_DECODER 0
-#define CONFIG_VBLE_DECODER 0
-#define CONFIG_VC1_CRYSTALHD_DECODER 0
-#define CONFIG_VC1_CUVID_DECODER 0
-#define CONFIG_VC1_D3D11VA2_HWACCEL 0
-#define CONFIG_VC1_D3D11VA_HWACCEL 0
-#define CONFIG_VC1_DECODER 0
-#define CONFIG_VC1_DEMUXER 0
-#define CONFIG_VC1_DXVA2_HWACCEL 0
-#define CONFIG_VC1IMAGE_DECODER 0
-#define CONFIG_VC1_MMAL_DECODER 0
-#define CONFIG_VC1_MUXER 0
-#define CONFIG_VC1_NVDEC_HWACCEL 0
-#define CONFIG_VC1_PARSER 0
-#define CONFIG_VC1_QSV_DECODER 0
-#define CONFIG_VC1T_DEMUXER 0
-#define CONFIG_VC1T_MUXER 0
-#define CONFIG_VC1_V4L2M2M_DECODER 0
-#define CONFIG_VC1_VAAPI_HWACCEL 0
-#define CONFIG_VC1_VDPAU_HWACCEL 0
-#define CONFIG_VC2_ENCODER 0
-#define CONFIG_VCR1_DECODER 0
-#define CONFIG_VECTORSCOPE_FILTER 0
-#define CONFIG_VFLIP_FILTER 0
-#define CONFIG_VFRDET_FILTER 0
-#define CONFIG_VFWCAP_INDEV 0
-#define CONFIG_VIBRANCE_FILTER 0
-#define CONFIG_VIBRATO_FILTER 0
-#define CONFIG_VIDSTABDETECT_FILTER 0
-#define CONFIG_VIDSTABTRANSFORM_FILTER 0
-#define CONFIG_VIGNETTE_FILTER 0
-#define CONFIG_VIVIDAS_DEMUXER 0
-#define CONFIG_VIVO_DEMUXER 0
-#define CONFIG_VMAFMOTION_FILTER 0
-#define CONFIG_VMDAUDIO_DECODER 0
-#define CONFIG_VMD_DEMUXER 0
-#define CONFIG_VMDVIDEO_DECODER 0
-#define CONFIG_VMNC_DECODER 0
-#define CONFIG_VOBSUB_DEMUXER 0
-#define CONFIG_VOC_DEMUXER 0
-#define CONFIG_VOC_MUXER 0
-#define CONFIG_VOLUMEDETECT_FILTER 0
-#define CONFIG_VOLUME_FILTER 0
-#define CONFIG_VORBIS_DECODER 0
-#define CONFIG_VORBIS_ENCODER 0
-#define CONFIG_VORBIS_PARSER 0
-#define CONFIG_VP3_DECODER 0
-#define CONFIG_VP3_PARSER 0
-#define CONFIG_VP4_DECODER 0
-#define CONFIG_VP5_DECODER 0
-#define CONFIG_VP6A_DECODER 0
-#define CONFIG_VP6_DECODER 0
-#define CONFIG_VP6F_DECODER 0
-#define CONFIG_VP7_DECODER 0
-#define CONFIG_VP8_CUVID_DECODER 0
-#define CONFIG_VP8_MEDIACODEC_DECODER 0
-#define CONFIG_VP8_NVDEC_HWACCEL 0
-#define CONFIG_VP8_QSV_DECODER 0
-#define CONFIG_VP8_RKMPP_DECODER 0
-#define CONFIG_VP8_V4L2M2M_DECODER 0
-#define CONFIG_VP8_V4L2M2M_ENCODER 0
-#define CONFIG_VP8_VAAPI_ENCODER 0
-#define CONFIG_VP8_VAAPI_HWACCEL 0
-#define CONFIG_VP9_CUVID_DECODER 0
-#define CONFIG_VP9_D3D11VA2_HWACCEL 0
-#define CONFIG_VP9_D3D11VA_HWACCEL 0
-#define CONFIG_VP9_DXVA2_HWACCEL 0
-#define CONFIG_VP9_MEDIACODEC_DECODER 0
-#define CONFIG_VP9_METADATA_BSF 0
-#define CONFIG_VP9_NVDEC_HWACCEL 0
-#define CONFIG_VP9_RAW_REORDER_BSF 0
-#define CONFIG_VP9_RKMPP_DECODER 0
-#define CONFIG_VP9_SUPERFRAME_BSF 0
-#define CONFIG_VP9_V4L2M2M_DECODER 0
-#define CONFIG_VP9_VAAPI_ENCODER 0
-#define CONFIG_VP9_VAAPI_HWACCEL 0
-#define CONFIG_VP9_VDPAU_HWACCEL 0
-#define CONFIG_VPK_DEMUXER 0
-#define CONFIG_VPLAYER_DECODER 0
-#define CONFIG_VPLAYER_DEMUXER 0
-#define CONFIG_VPP_QSV_FILTER 0
-#define CONFIG_VQA_DECODER 0
-#define CONFIG_VQF_DEMUXER 0
-#define CONFIG_VSTACK_FILTER 0
-#define CONFIG_W3FDIF_FILTER 0
-#define CONFIG_W64_DEMUXER 0
-#define CONFIG_W64_MUXER 0
-#define CONFIG_WAV_DEMUXER 0
-#define CONFIG_WAVEFORM_FILTER 0
-#define CONFIG_WAV_MUXER 0
-#define CONFIG_WAVPACK_DECODER 0
-#define CONFIG_WAVPACK_ENCODER 0
-#define CONFIG_WC3_DEMUXER 0
-#define CONFIG_WCMV_DECODER 0
-#define CONFIG_WEAVE_FILTER 0
-#define CONFIG_WEBM_CHUNK_MUXER 0
-#define CONFIG_WEBM_DASH_MANIFEST_DEMUXER 0
-#define CONFIG_WEBM_DASH_MANIFEST_MUXER 0
-#define CONFIG_WEBM_MUXER 0
-#define CONFIG_WEBP_DECODER 0
-#define CONFIG_WEBP_MUXER 0
-#define CONFIG_WEBVTT_DECODER 0
-#define CONFIG_WEBVTT_DEMUXER 0
-#define CONFIG_WEBVTT_ENCODER 0
-#define CONFIG_WEBVTT_MUXER 0
-#define CONFIG_WMALOSSLESS_DECODER 0
-#define CONFIG_WMAPRO_DECODER 0
-#define CONFIG_WMAV1_DECODER 0
-#define CONFIG_WMAV1_ENCODER 0
-#define CONFIG_WMAV2_DECODER 0
-#define CONFIG_WMAV2_ENCODER 0
-#define CONFIG_WMAVOICE_DECODER 0
-#define CONFIG_WMV1_DECODER 0
-#define CONFIG_WMV1_ENCODER 0
-#define CONFIG_WMV2_DECODER 0
-#define CONFIG_WMV2_ENCODER 0
-#define CONFIG_WMV3_CRYSTALHD_DECODER 0
-#define CONFIG_WMV3_D3D11VA2_HWACCEL 0
-#define CONFIG_WMV3_D3D11VA_HWACCEL 0
-#define CONFIG_WMV3_DECODER 0
-#define CONFIG_WMV3_DXVA2_HWACCEL 0
-#define CONFIG_WMV3IMAGE_DECODER 0
-#define CONFIG_WMV3_NVDEC_HWACCEL 0
-#define CONFIG_WMV3_VAAPI_HWACCEL 0
-#define CONFIG_WMV3_VDPAU_HWACCEL 0
-#define CONFIG_WNV1_DECODER 0
-#define CONFIG_WRAPPED_AVFRAME_DECODER 0
-#define CONFIG_WRAPPED_AVFRAME_ENCODER 0
-#define CONFIG_WSAUD_DEMUXER 0
-#define CONFIG_WSD_DEMUXER 0
-#define CONFIG_WS_SND1_DECODER 0
-#define CONFIG_WSVQA_DEMUXER 0
-#define CONFIG_WTV_DEMUXER 0
-#define CONFIG_WTV_MUXER 0
-#define CONFIG_WV_DEMUXER 0
-#define CONFIG_WVE_DEMUXER 0
-#define CONFIG_WV_MUXER 0
-#define CONFIG_XA_DEMUXER 0
-#define CONFIG_XAN_DPCM_DECODER 0
-#define CONFIG_XAN_WC3_DECODER 0
-#define CONFIG_XAN_WC4_DECODER 0
-#define CONFIG_XBIN_DECODER 0
-#define CONFIG_XBIN_DEMUXER 0
-#define CONFIG_XBM_DECODER 0
-#define CONFIG_XBM_ENCODER 0
-#define CONFIG_XBR_FILTER 0
-#define CONFIG_XCBGRAB_INDEV 0
-#define CONFIG_XFACE_DECODER 0
-#define CONFIG_XFACE_ENCODER 0
-#define CONFIG_XL_DECODER 0
-#define CONFIG_XMA1_DECODER 0
-#define CONFIG_XMA2_DECODER 0
-#define CONFIG_XMA_PARSER 0
-#define CONFIG_XMEDIAN_FILTER 0
-#define CONFIG_XMV_DEMUXER 0
-#define CONFIG_XPM_DECODER 0
-#define CONFIG_XSTACK_FILTER 0
-#define CONFIG_XSUB_DECODER 0
-#define CONFIG_XSUB_ENCODER 0
-#define CONFIG_XVAG_DEMUXER 0
-#define CONFIG_XV_OUTDEV 0
-#define CONFIG_XWD_DECODER 0
-#define CONFIG_XWD_ENCODER 0
-#define CONFIG_XWMA_DEMUXER 0
-#define CONFIG_Y41P_DECODER 0
-#define CONFIG_Y41P_ENCODER 0
-#define CONFIG_YADIF_CUDA_FILTER 0
-#define CONFIG_YADIF_FILTER 0
-#define CONFIG_YLC_DECODER 0
-#define CONFIG_YOP_DECODER 0
-#define CONFIG_YOP_DEMUXER 0
-#define CONFIG_YUV4_DECODER 0
-#define CONFIG_YUV4_ENCODER 0
-#define CONFIG_YUV4MPEGPIPE_DEMUXER 0
-#define CONFIG_YUV4MPEGPIPE_MUXER 0
-#define CONFIG_YUVTESTSRC_FILTER 0
-#define CONFIG_ZERO12V_DECODER 0
-#define CONFIG_ZEROCODEC_DECODER 0
-#define CONFIG_ZLIB_DECODER 0
-#define CONFIG_ZLIB_ENCODER 0
-#define CONFIG_ZMBV_DECODER 0
-#define CONFIG_ZMBV_ENCODER 0
-#define CONFIG_ZMQ_FILTER 0
-#define CONFIG_ZOOMPAN_FILTER 0
-#define CONFIG_ZSCALE_FILTER 0
diff -Naur a/media/ffvpx/libavcodec/aarch64/fft_init_aarch64.c b/media/ffvpx/libavcodec/aarch64/fft_init_aarch64.c
--- a/media/ffvpx/libavcodec/aarch64/fft_init_aarch64.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/fft_init_aarch64.c	2023-04-06 12:50:06.969470973 +0200
@@ -38,8 +38,10 @@
     int cpu_flags = av_get_cpu_flags();
 
     if (have_neon(cpu_flags)) {
-        s->fft_permute  = ff_fft_permute_neon;
-        s->fft_calc     = ff_fft_calc_neon;
+        if (s->nbits < 17) {
+            s->fft_permute = ff_fft_permute_neon;
+            s->fft_calc    = ff_fft_calc_neon;
+        }
 #if CONFIG_MDCT
         s->imdct_calc   = ff_imdct_calc_neon;
         s->imdct_half   = ff_imdct_half_neon;
diff -Naur a/media/ffvpx/libavcodec/aarch64/fft_neon.S b/media/ffvpx/libavcodec/aarch64/fft_neon.S
--- a/media/ffvpx/libavcodec/aarch64/fft_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/fft_neon.S	2023-04-06 12:50:06.969470973 +0200
@@ -36,6 +36,7 @@
 
 
 function fft4_neon
+        AARCH64_VALID_JUMP_TARGET
         ld1             {v0.2s,v1.2s,v2.2s,v3.2s}, [x0]
 
         fadd            v4.2s,  v0.2s,  v1.2s   // r0+r1,i0+i1
@@ -58,6 +59,7 @@
 endfunc
 
 function fft8_neon
+        AARCH64_VALID_JUMP_TARGET
         mov             x1,  x0
         ld1             {v0.2s, v1.2s, v2.2s, v3.2s},  [x0], #32
         ld1             {v16.2s,v17.2s,v18.2s,v19.2s}, [x0]
@@ -108,6 +110,7 @@
 endfunc
 
 function fft16_neon
+        AARCH64_VALID_JUMP_TARGET
         mov             x1,  x0
         ld1             {v0.2s, v1.2s, v2.2s, v3.2s},  [x0], #32
         ld1             {v16.2s,v17.2s,v18.2s,v19.2s}, [x0], #32
@@ -337,8 +340,9 @@
 
 .macro  def_fft n, n2, n4
 function fft\n\()_neon, align=6
-        sub             sp,  sp,  #16
-        stp             x28, x30, [sp]
+        AARCH64_VALID_JUMP_TARGET
+        AARCH64_SIGN_LINK_REGISTER
+        stp             x28, x30, [sp, #-16]!
         add             x28, x0,  #\n4*2*8
         bl              fft\n2\()_neon
         mov             x0,  x28
@@ -347,6 +351,7 @@
         bl              fft\n4\()_neon
         sub             x0,  x28, #\n4*2*8
         ldp             x28, x30, [sp], #16
+        AARCH64_VALIDATE_LINK_REGISTER
         movrel          x4,  X(ff_cos_\n)
         mov             x2,  #\n4>>1
         b               fft_pass_neon
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264chroma_init_aarch64.c b/media/ffvpx/libavcodec/aarch64/h264chroma_init_aarch64.c
--- a/media/ffvpx/libavcodec/aarch64/h264chroma_init_aarch64.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264chroma_init_aarch64.c	2023-04-06 12:50:06.969470973 +0200
@@ -28,18 +28,18 @@
 
 #include "config.h"
 
-void ff_put_h264_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_h264_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_h264_chroma_mc2_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc2_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
-void ff_avg_h264_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_h264_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_h264_chroma_mc2_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc2_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
 av_cold void ff_h264chroma_init_aarch64(H264ChromaContext *c, int bit_depth)
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264cmc_neon.S b/media/ffvpx/libavcodec/aarch64/h264cmc_neon.S
--- a/media/ffvpx/libavcodec/aarch64/h264cmc_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264cmc_neon.S	2023-04-06 12:50:06.969470973 +0200
@@ -19,9 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config_components.h"
+
 #include "libavutil/aarch64/asm.S"
 
-/* chroma_mc8(uint8_t *dst, uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
+/* chroma_mc8(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
 .macro  h264_chroma_mc8 type, codec=h264
 function ff_\type\()_\codec\()_chroma_mc8_neon, export=1
   .ifc \type,avg
@@ -191,7 +193,7 @@
 endfunc
 .endm
 
-/* chroma_mc4(uint8_t *dst, uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
+/* chroma_mc4(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
 .macro  h264_chroma_mc4 type, codec=h264
 function ff_\type\()_\codec\()_chroma_mc4_neon, export=1
   .ifc \type,avg
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264dsp_init_aarch64.c b/media/ffvpx/libavcodec/aarch64/h264dsp_init_aarch64.c
--- a/media/ffvpx/libavcodec/aarch64/h264dsp_init_aarch64.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264dsp_init_aarch64.c	2023-04-06 12:49:40.248394688 +0200
@@ -69,19 +69,42 @@
 void ff_h264_idct_dc_add_neon(uint8_t *dst, int16_t *block, int stride);
 void ff_h264_idct_add16_neon(uint8_t *dst, const int *block_offset,
                              int16_t *block, int stride,
-                             const uint8_t nnzc[6*8]);
+                             const uint8_t nnzc[5 * 8]);
 void ff_h264_idct_add16intra_neon(uint8_t *dst, const int *block_offset,
                                   int16_t *block, int stride,
-                                  const uint8_t nnzc[6*8]);
+                                  const uint8_t nnzc[5 * 8]);
 void ff_h264_idct_add8_neon(uint8_t **dest, const int *block_offset,
                             int16_t *block, int stride,
-                            const uint8_t nnzc[6*8]);
+                            const uint8_t nnzc[15 * 8]);
 
 void ff_h264_idct8_add_neon(uint8_t *dst, int16_t *block, int stride);
 void ff_h264_idct8_dc_add_neon(uint8_t *dst, int16_t *block, int stride);
 void ff_h264_idct8_add4_neon(uint8_t *dst, const int *block_offset,
                              int16_t *block, int stride,
-                             const uint8_t nnzc[6*8]);
+                             const uint8_t nnzc[5 * 8]);
+
+void ff_h264_v_loop_filter_luma_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                        int beta, int8_t *tc0);
+void ff_h264_h_loop_filter_luma_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                        int beta, int8_t *tc0);
+void ff_h264_v_loop_filter_luma_intra_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                              int beta);
+void ff_h264_h_loop_filter_luma_intra_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                              int beta);
+void ff_h264_v_loop_filter_chroma_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                          int beta, int8_t *tc0);
+void ff_h264_h_loop_filter_chroma_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                          int beta, int8_t *tc0);
+void ff_h264_h_loop_filter_chroma422_neon_10(uint8_t *pix, ptrdiff_t stride, int alpha,
+                                             int beta, int8_t *tc0);
+void ff_h264_v_loop_filter_chroma_intra_neon_10(uint8_t *pix, ptrdiff_t stride,
+                                                int alpha, int beta);
+void ff_h264_h_loop_filter_chroma_intra_neon_10(uint8_t *pix, ptrdiff_t stride,
+                                                int alpha, int beta);
+void ff_h264_h_loop_filter_chroma422_intra_neon_10(uint8_t *pix, ptrdiff_t stride,
+                                                   int alpha, int beta);
+void ff_h264_h_loop_filter_chroma_mbaff_intra_neon_10(uint8_t *pix, ptrdiff_t stride,
+                                                      int alpha, int beta);
 
 av_cold void ff_h264dsp_init_aarch64(H264DSPContext *c, const int bit_depth,
                                      const int chroma_format_idc)
@@ -125,5 +148,19 @@
         c->h264_idct8_add       = ff_h264_idct8_add_neon;
         c->h264_idct8_dc_add    = ff_h264_idct8_dc_add_neon;
         c->h264_idct8_add4      = ff_h264_idct8_add4_neon;
+    } else if (have_neon(cpu_flags) && bit_depth == 10) {
+        c->h264_v_loop_filter_chroma = ff_h264_v_loop_filter_chroma_neon_10;
+        c->h264_v_loop_filter_chroma_intra = ff_h264_v_loop_filter_chroma_intra_neon_10;
+
+        if (chroma_format_idc <= 1) {
+            c->h264_h_loop_filter_chroma = ff_h264_h_loop_filter_chroma_neon_10;
+            c->h264_h_loop_filter_chroma_intra = ff_h264_h_loop_filter_chroma_intra_neon_10;
+            c->h264_h_loop_filter_chroma_mbaff_intra = ff_h264_h_loop_filter_chroma_mbaff_intra_neon_10;
+        } else {
+            c->h264_h_loop_filter_chroma = ff_h264_h_loop_filter_chroma422_neon_10;
+            c->h264_h_loop_filter_chroma_mbaff = ff_h264_h_loop_filter_chroma_neon_10;
+            c->h264_h_loop_filter_chroma_intra = ff_h264_h_loop_filter_chroma422_intra_neon_10;
+            c->h264_h_loop_filter_chroma_mbaff_intra = ff_h264_h_loop_filter_chroma_intra_neon_10;
+        }
     }
 }
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264dsp_neon.S b/media/ffvpx/libavcodec/aarch64/h264dsp_neon.S
--- a/media/ffvpx/libavcodec/aarch64/h264dsp_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264dsp_neon.S	2023-04-06 12:49:40.248394688 +0200
@@ -110,7 +110,6 @@
 
 function ff_h264_v_loop_filter_luma_neon, export=1
         h264_loop_filter_start
-        sxtw            x1,  w1
 
         ld1             {v0.16B},  [x0], x1
         ld1             {v2.16B},  [x0], x1
@@ -134,7 +133,6 @@
 
 function ff_h264_h_loop_filter_luma_neon, export=1
         h264_loop_filter_start
-        sxtw            x1,  w1
 
         sub             x0,  x0,  #4
         ld1             {v6.8B},  [x0], x1
@@ -184,199 +182,198 @@
 
 
 .macro h264_loop_filter_start_intra
-    orr             w4,  w2,  w3
-    cbnz            w4,  1f
-    ret
+        orr             w4,  w2,  w3
+        cbnz            w4,  1f
+        ret
 1:
-    sxtw            x1,  w1
-    dup             v30.16b, w2                // alpha
-    dup             v31.16b, w3                // beta
+        dup             v30.16b, w2                // alpha
+        dup             v31.16b, w3                // beta
 .endm
 
 .macro h264_loop_filter_luma_intra
-    uabd            v16.16b, v7.16b,  v0.16b        // abs(p0 - q0)
-    uabd            v17.16b, v6.16b,  v7.16b        // abs(p1 - p0)
-    uabd            v18.16b, v1.16b,  v0.16b        // abs(q1 - q0)
-    cmhi            v19.16b, v30.16b, v16.16b       // < alpha
-    cmhi            v17.16b, v31.16b, v17.16b       // < beta
-    cmhi            v18.16b, v31.16b, v18.16b       // < beta
-
-    movi            v29.16b, #2
-    ushr            v30.16b, v30.16b, #2            // alpha >> 2
-    add             v30.16b, v30.16b, v29.16b       // (alpha >> 2) + 2
-    cmhi            v16.16b, v30.16b, v16.16b       // < (alpha >> 2) + 2
-
-    and             v19.16b, v19.16b, v17.16b
-    and             v19.16b, v19.16b, v18.16b
-    shrn            v20.8b,  v19.8h,  #4
-    mov             x4, v20.d[0]
-    cbz             x4, 9f
-
-    ushll           v20.8h,  v6.8b,   #1
-    ushll           v22.8h,  v1.8b,   #1
-    ushll2          v21.8h,  v6.16b,  #1
-    ushll2          v23.8h,  v1.16b,  #1
-    uaddw           v20.8h,  v20.8h,  v7.8b
-    uaddw           v22.8h,  v22.8h,  v0.8b
-    uaddw2          v21.8h,  v21.8h,  v7.16b
-    uaddw2          v23.8h,  v23.8h,  v0.16b
-    uaddw           v20.8h,  v20.8h,  v1.8b
-    uaddw           v22.8h,  v22.8h,  v6.8b
-    uaddw2          v21.8h,  v21.8h,  v1.16b
-    uaddw2          v23.8h,  v23.8h,  v6.16b
-
-    rshrn           v24.8b,  v20.8h,  #2 // p0'_1
-    rshrn           v25.8b,  v22.8h,  #2 // q0'_1
-    rshrn2          v24.16b, v21.8h,  #2 // p0'_1
-    rshrn2          v25.16b, v23.8h,  #2 // q0'_1
-
-    uabd            v17.16b, v5.16b,  v7.16b        // abs(p2 - p0)
-    uabd            v18.16b, v2.16b,  v0.16b        // abs(q2 - q0)
-    cmhi            v17.16b, v31.16b, v17.16b       // < beta
-    cmhi            v18.16b, v31.16b, v18.16b       // < beta
-
-    and             v17.16b, v16.16b, v17.16b  // if_2 && if_3
-    and             v18.16b, v16.16b, v18.16b  // if_2 && if_4
-
-    not             v30.16b, v17.16b
-    not             v31.16b, v18.16b
-
-    and             v30.16b, v30.16b, v19.16b  // if_1 && !(if_2 && if_3)
-    and             v31.16b, v31.16b, v19.16b  // if_1 && !(if_2 && if_4)
-
-    and             v17.16b, v19.16b, v17.16b  // if_1 && if_2 && if_3
-    and             v18.16b, v19.16b, v18.16b  // if_1 && if_2 && if_4
-
-    //calc            p, v7, v6, v5, v4, v17, v7, v6, v5, v4
-    uaddl           v26.8h,  v5.8b,   v7.8b
-    uaddl2          v27.8h,  v5.16b,  v7.16b
-    uaddw           v26.8h,  v26.8h,  v0.8b
-    uaddw2          v27.8h,  v27.8h,  v0.16b
-    add             v20.8h,  v20.8h,  v26.8h
-    add             v21.8h,  v21.8h,  v27.8h
-    uaddw           v20.8h,  v20.8h,  v0.8b
-    uaddw2          v21.8h,  v21.8h,  v0.16b
-    rshrn           v20.8b,  v20.8h,  #3 // p0'_2
-    rshrn2          v20.16b, v21.8h,  #3 // p0'_2
-    uaddw           v26.8h,  v26.8h,  v6.8b
-    uaddw2          v27.8h,  v27.8h,  v6.16b
-    rshrn           v21.8b,  v26.8h,  #2 // p1'_2
-    rshrn2          v21.16b, v27.8h,  #2 // p1'_2
-    uaddl           v28.8h,  v4.8b,   v5.8b
-    uaddl2          v29.8h,  v4.16b,  v5.16b
-    shl             v28.8h,  v28.8h,  #1
-    shl             v29.8h,  v29.8h,  #1
-    add             v28.8h,  v28.8h,  v26.8h
-    add             v29.8h,  v29.8h,  v27.8h
-    rshrn           v19.8b,  v28.8h,  #3 // p2'_2
-    rshrn2          v19.16b, v29.8h,  #3 // p2'_2
-
-    //calc            q, v0, v1, v2, v3, v18, v0, v1, v2, v3
-    uaddl           v26.8h,  v2.8b,   v0.8b
-    uaddl2          v27.8h,  v2.16b,  v0.16b
-    uaddw           v26.8h,  v26.8h,  v7.8b
-    uaddw2          v27.8h,  v27.8h,  v7.16b
-    add             v22.8h,  v22.8h,  v26.8h
-    add             v23.8h,  v23.8h,  v27.8h
-    uaddw           v22.8h,  v22.8h,  v7.8b
-    uaddw2          v23.8h,  v23.8h,  v7.16b
-    rshrn           v22.8b,  v22.8h,  #3 // q0'_2
-    rshrn2          v22.16b, v23.8h,  #3 // q0'_2
-    uaddw           v26.8h,  v26.8h,  v1.8b
-    uaddw2          v27.8h,  v27.8h,  v1.16b
-    rshrn           v23.8b,  v26.8h,  #2 // q1'_2
-    rshrn2          v23.16b, v27.8h,  #2 // q1'_2
-    uaddl           v28.8h,  v2.8b,   v3.8b
-    uaddl2          v29.8h,  v2.16b,  v3.16b
-    shl             v28.8h,  v28.8h,  #1
-    shl             v29.8h,  v29.8h,  #1
-    add             v28.8h,  v28.8h,  v26.8h
-    add             v29.8h,  v29.8h,  v27.8h
-    rshrn           v26.8b,  v28.8h,  #3 // q2'_2
-    rshrn2          v26.16b, v29.8h,  #3 // q2'_2
-
-    bit             v7.16b,  v24.16b, v30.16b  // p0'_1
-    bit             v0.16b,  v25.16b, v31.16b  // q0'_1
-    bit             v7.16b, v20.16b,  v17.16b  // p0'_2
-    bit             v6.16b, v21.16b,  v17.16b  // p1'_2
-    bit             v5.16b, v19.16b,  v17.16b  // p2'_2
-    bit             v0.16b, v22.16b,  v18.16b  // q0'_2
-    bit             v1.16b, v23.16b,  v18.16b  // q1'_2
-    bit             v2.16b, v26.16b,  v18.16b  // q2'_2
+        uabd            v16.16b, v7.16b,  v0.16b        // abs(p0 - q0)
+        uabd            v17.16b, v6.16b,  v7.16b        // abs(p1 - p0)
+        uabd            v18.16b, v1.16b,  v0.16b        // abs(q1 - q0)
+        cmhi            v19.16b, v30.16b, v16.16b       // < alpha
+        cmhi            v17.16b, v31.16b, v17.16b       // < beta
+        cmhi            v18.16b, v31.16b, v18.16b       // < beta
+
+        movi            v29.16b, #2
+        ushr            v30.16b, v30.16b, #2            // alpha >> 2
+        add             v30.16b, v30.16b, v29.16b       // (alpha >> 2) + 2
+        cmhi            v16.16b, v30.16b, v16.16b       // < (alpha >> 2) + 2
+
+        and             v19.16b, v19.16b, v17.16b
+        and             v19.16b, v19.16b, v18.16b
+        shrn            v20.8b,  v19.8h,  #4
+        mov             x4, v20.d[0]
+        cbz             x4, 9f
+
+        ushll           v20.8h,  v6.8b,   #1
+        ushll           v22.8h,  v1.8b,   #1
+        ushll2          v21.8h,  v6.16b,  #1
+        ushll2          v23.8h,  v1.16b,  #1
+        uaddw           v20.8h,  v20.8h,  v7.8b
+        uaddw           v22.8h,  v22.8h,  v0.8b
+        uaddw2          v21.8h,  v21.8h,  v7.16b
+        uaddw2          v23.8h,  v23.8h,  v0.16b
+        uaddw           v20.8h,  v20.8h,  v1.8b
+        uaddw           v22.8h,  v22.8h,  v6.8b
+        uaddw2          v21.8h,  v21.8h,  v1.16b
+        uaddw2          v23.8h,  v23.8h,  v6.16b
+
+        rshrn           v24.8b,  v20.8h,  #2 // p0'_1
+        rshrn           v25.8b,  v22.8h,  #2 // q0'_1
+        rshrn2          v24.16b, v21.8h,  #2 // p0'_1
+        rshrn2          v25.16b, v23.8h,  #2 // q0'_1
+
+        uabd            v17.16b, v5.16b,  v7.16b        // abs(p2 - p0)
+        uabd            v18.16b, v2.16b,  v0.16b        // abs(q2 - q0)
+        cmhi            v17.16b, v31.16b, v17.16b       // < beta
+        cmhi            v18.16b, v31.16b, v18.16b       // < beta
+
+        and             v17.16b, v16.16b, v17.16b  // if_2 && if_3
+        and             v18.16b, v16.16b, v18.16b  // if_2 && if_4
+
+        not             v30.16b, v17.16b
+        not             v31.16b, v18.16b
+
+        and             v30.16b, v30.16b, v19.16b  // if_1 && !(if_2 && if_3)
+        and             v31.16b, v31.16b, v19.16b  // if_1 && !(if_2 && if_4)
+
+        and             v17.16b, v19.16b, v17.16b  // if_1 && if_2 && if_3
+        and             v18.16b, v19.16b, v18.16b  // if_1 && if_2 && if_4
+
+        //calc            p, v7, v6, v5, v4, v17, v7, v6, v5, v4
+        uaddl           v26.8h,  v5.8b,   v7.8b
+        uaddl2          v27.8h,  v5.16b,  v7.16b
+        uaddw           v26.8h,  v26.8h,  v0.8b
+        uaddw2          v27.8h,  v27.8h,  v0.16b
+        add             v20.8h,  v20.8h,  v26.8h
+        add             v21.8h,  v21.8h,  v27.8h
+        uaddw           v20.8h,  v20.8h,  v0.8b
+        uaddw2          v21.8h,  v21.8h,  v0.16b
+        rshrn           v20.8b,  v20.8h,  #3 // p0'_2
+        rshrn2          v20.16b, v21.8h,  #3 // p0'_2
+        uaddw           v26.8h,  v26.8h,  v6.8b
+        uaddw2          v27.8h,  v27.8h,  v6.16b
+        rshrn           v21.8b,  v26.8h,  #2 // p1'_2
+        rshrn2          v21.16b, v27.8h,  #2 // p1'_2
+        uaddl           v28.8h,  v4.8b,   v5.8b
+        uaddl2          v29.8h,  v4.16b,  v5.16b
+        shl             v28.8h,  v28.8h,  #1
+        shl             v29.8h,  v29.8h,  #1
+        add             v28.8h,  v28.8h,  v26.8h
+        add             v29.8h,  v29.8h,  v27.8h
+        rshrn           v19.8b,  v28.8h,  #3 // p2'_2
+        rshrn2          v19.16b, v29.8h,  #3 // p2'_2
+
+        //calc            q, v0, v1, v2, v3, v18, v0, v1, v2, v3
+        uaddl           v26.8h,  v2.8b,   v0.8b
+        uaddl2          v27.8h,  v2.16b,  v0.16b
+        uaddw           v26.8h,  v26.8h,  v7.8b
+        uaddw2          v27.8h,  v27.8h,  v7.16b
+        add             v22.8h,  v22.8h,  v26.8h
+        add             v23.8h,  v23.8h,  v27.8h
+        uaddw           v22.8h,  v22.8h,  v7.8b
+        uaddw2          v23.8h,  v23.8h,  v7.16b
+        rshrn           v22.8b,  v22.8h,  #3 // q0'_2
+        rshrn2          v22.16b, v23.8h,  #3 // q0'_2
+        uaddw           v26.8h,  v26.8h,  v1.8b
+        uaddw2          v27.8h,  v27.8h,  v1.16b
+        rshrn           v23.8b,  v26.8h,  #2 // q1'_2
+        rshrn2          v23.16b, v27.8h,  #2 // q1'_2
+        uaddl           v28.8h,  v2.8b,   v3.8b
+        uaddl2          v29.8h,  v2.16b,  v3.16b
+        shl             v28.8h,  v28.8h,  #1
+        shl             v29.8h,  v29.8h,  #1
+        add             v28.8h,  v28.8h,  v26.8h
+        add             v29.8h,  v29.8h,  v27.8h
+        rshrn           v26.8b,  v28.8h,  #3 // q2'_2
+        rshrn2          v26.16b, v29.8h,  #3 // q2'_2
+
+        bit             v7.16b,  v24.16b, v30.16b  // p0'_1
+        bit             v0.16b,  v25.16b, v31.16b  // q0'_1
+        bit             v7.16b,  v20.16b, v17.16b  // p0'_2
+        bit             v6.16b,  v21.16b, v17.16b  // p1'_2
+        bit             v5.16b,  v19.16b, v17.16b  // p2'_2
+        bit             v0.16b,  v22.16b, v18.16b  // q0'_2
+        bit             v1.16b,  v23.16b, v18.16b  // q1'_2
+        bit             v2.16b,  v26.16b, v18.16b  // q2'_2
 .endm
 
 function ff_h264_v_loop_filter_luma_intra_neon, export=1
-    h264_loop_filter_start_intra
+        h264_loop_filter_start_intra
+
+        ld1             {v0.16b},  [x0], x1 // q0
+        ld1             {v1.16b},  [x0], x1 // q1
+        ld1             {v2.16b},  [x0], x1 // q2
+        ld1             {v3.16b},  [x0], x1 // q3
+        sub             x0,  x0,  x1, lsl #3
+        ld1             {v4.16b},  [x0], x1 // p3
+        ld1             {v5.16b},  [x0], x1 // p2
+        ld1             {v6.16b},  [x0], x1 // p1
+        ld1             {v7.16b},  [x0]     // p0
 
-    ld1             {v0.16b},  [x0], x1 // q0
-    ld1             {v1.16b},  [x0], x1 // q1
-    ld1             {v2.16b},  [x0], x1 // q2
-    ld1             {v3.16b},  [x0], x1 // q3
-    sub             x0,  x0,  x1, lsl #3
-    ld1             {v4.16b},  [x0], x1 // p3
-    ld1             {v5.16b},  [x0], x1 // p2
-    ld1             {v6.16b},  [x0], x1 // p1
-    ld1             {v7.16b},  [x0]     // p0
-
-    h264_loop_filter_luma_intra
-
-    sub             x0,  x0,  x1, lsl #1
-    st1             {v5.16b}, [x0], x1  // p2
-    st1             {v6.16b}, [x0], x1  // p1
-    st1             {v7.16b}, [x0], x1  // p0
-    st1             {v0.16b}, [x0], x1  // q0
-    st1             {v1.16b}, [x0], x1  // q1
-    st1             {v2.16b}, [x0]      // q2
+        h264_loop_filter_luma_intra
+
+        sub             x0,  x0,  x1, lsl #1
+        st1             {v5.16b}, [x0], x1  // p2
+        st1             {v6.16b}, [x0], x1  // p1
+        st1             {v7.16b}, [x0], x1  // p0
+        st1             {v0.16b}, [x0], x1  // q0
+        st1             {v1.16b}, [x0], x1  // q1
+        st1             {v2.16b}, [x0]      // q2
 9:
-    ret
+        ret
 endfunc
 
 function ff_h264_h_loop_filter_luma_intra_neon, export=1
-    h264_loop_filter_start_intra
+        h264_loop_filter_start_intra
+
+        sub             x0,  x0,  #4
+        ld1             {v4.8b},  [x0], x1
+        ld1             {v5.8b},  [x0], x1
+        ld1             {v6.8b},  [x0], x1
+        ld1             {v7.8b},  [x0], x1
+        ld1             {v0.8b},  [x0], x1
+        ld1             {v1.8b},  [x0], x1
+        ld1             {v2.8b},  [x0], x1
+        ld1             {v3.8b},  [x0], x1
+        ld1             {v4.d}[1],  [x0], x1
+        ld1             {v5.d}[1],  [x0], x1
+        ld1             {v6.d}[1],  [x0], x1
+        ld1             {v7.d}[1],  [x0], x1
+        ld1             {v0.d}[1],  [x0], x1
+        ld1             {v1.d}[1],  [x0], x1
+        ld1             {v2.d}[1],  [x0], x1
+        ld1             {v3.d}[1],  [x0], x1
+
+        transpose_8x16B v4, v5, v6, v7, v0, v1, v2, v3, v21, v23
+
+        h264_loop_filter_luma_intra
 
-    sub             x0,  x0,  #4
-    ld1             {v4.8b},  [x0], x1
-    ld1             {v5.8b},  [x0], x1
-    ld1             {v6.8b},  [x0], x1
-    ld1             {v7.8b},  [x0], x1
-    ld1             {v0.8b},  [x0], x1
-    ld1             {v1.8b},  [x0], x1
-    ld1             {v2.8b},  [x0], x1
-    ld1             {v3.8b},  [x0], x1
-    ld1             {v4.d}[1],  [x0], x1
-    ld1             {v5.d}[1],  [x0], x1
-    ld1             {v6.d}[1],  [x0], x1
-    ld1             {v7.d}[1],  [x0], x1
-    ld1             {v0.d}[1],  [x0], x1
-    ld1             {v1.d}[1],  [x0], x1
-    ld1             {v2.d}[1],  [x0], x1
-    ld1             {v3.d}[1],  [x0], x1
-
-    transpose_8x16B v4, v5, v6, v7, v0, v1, v2, v3, v21, v23
-
-    h264_loop_filter_luma_intra
-
-    transpose_8x16B v4, v5, v6, v7, v0, v1, v2, v3, v21, v23
-
-    sub             x0,  x0,  x1, lsl #4
-    st1             {v4.8b},  [x0], x1
-    st1             {v5.8b},  [x0], x1
-    st1             {v6.8b},  [x0], x1
-    st1             {v7.8b},  [x0], x1
-    st1             {v0.8b},  [x0], x1
-    st1             {v1.8b},  [x0], x1
-    st1             {v2.8b},  [x0], x1
-    st1             {v3.8b},  [x0], x1
-    st1             {v4.d}[1],  [x0], x1
-    st1             {v5.d}[1],  [x0], x1
-    st1             {v6.d}[1],  [x0], x1
-    st1             {v7.d}[1],  [x0], x1
-    st1             {v0.d}[1],  [x0], x1
-    st1             {v1.d}[1],  [x0], x1
-    st1             {v2.d}[1],  [x0], x1
-    st1             {v3.d}[1],  [x0], x1
+        transpose_8x16B v4, v5, v6, v7, v0, v1, v2, v3, v21, v23
+
+        sub             x0,  x0,  x1, lsl #4
+        st1             {v4.8b},  [x0], x1
+        st1             {v5.8b},  [x0], x1
+        st1             {v6.8b},  [x0], x1
+        st1             {v7.8b},  [x0], x1
+        st1             {v0.8b},  [x0], x1
+        st1             {v1.8b},  [x0], x1
+        st1             {v2.8b},  [x0], x1
+        st1             {v3.8b},  [x0], x1
+        st1             {v4.d}[1],  [x0], x1
+        st1             {v5.d}[1],  [x0], x1
+        st1             {v6.d}[1],  [x0], x1
+        st1             {v7.d}[1],  [x0], x1
+        st1             {v0.d}[1],  [x0], x1
+        st1             {v1.d}[1],  [x0], x1
+        st1             {v2.d}[1],  [x0], x1
+        st1             {v3.d}[1],  [x0], x1
 9:
-    ret
+        ret
 endfunc
 
 .macro  h264_loop_filter_chroma
@@ -414,7 +411,6 @@
 
 function ff_h264_v_loop_filter_chroma_neon, export=1
         h264_loop_filter_start
-        sxtw            x1,  w1
 
         sub             x0,  x0,  x1, lsl #1
         ld1             {v18.8B}, [x0], x1
@@ -433,7 +429,6 @@
 
 function ff_h264_h_loop_filter_chroma_neon, export=1
         h264_loop_filter_start
-        sxtw            x1,  w1
 
         sub             x0,  x0,  #2
 h_loop_filter_chroma420:
@@ -466,7 +461,6 @@
 endfunc
 
 function ff_h264_h_loop_filter_chroma422_neon, export=1
-        sxtw            x1,  w1
         h264_loop_filter_start
         add             x5,  x0,  x1
         sub             x0,  x0,  #2
@@ -480,113 +474,113 @@
 endfunc
 
 .macro h264_loop_filter_chroma_intra
-    uabd            v26.8b, v16.8b, v17.8b  // abs(p0 - q0)
-    uabd            v27.8b, v18.8b, v16.8b  // abs(p1 - p0)
-    uabd            v28.8b, v19.8b, v17.8b  // abs(q1 - q0)
-    cmhi            v26.8b, v30.8b, v26.8b  // < alpha
-    cmhi            v27.8b, v31.8b, v27.8b  // < beta
-    cmhi            v28.8b, v31.8b, v28.8b  // < beta
-    and             v26.8b, v26.8b, v27.8b
-    and             v26.8b, v26.8b, v28.8b
-    mov             x2, v26.d[0]
-
-    ushll           v4.8h,   v18.8b,  #1
-    ushll           v6.8h,   v19.8b,  #1
-    cbz             x2, 9f
-    uaddl           v20.8h,  v16.8b,  v19.8b
-    uaddl           v22.8h,  v17.8b,  v18.8b
-    add             v20.8h,  v20.8h,  v4.8h
-    add             v22.8h,  v22.8h,  v6.8h
-    uqrshrn         v24.8b,  v20.8h,  #2
-    uqrshrn         v25.8b,  v22.8h,  #2
-    bit             v16.8b, v24.8b, v26.8b
-    bit             v17.8b, v25.8b, v26.8b
+        uabd            v26.8b,  v16.8b,  v17.8b  // abs(p0 - q0)
+        uabd            v27.8b,  v18.8b,  v16.8b  // abs(p1 - p0)
+        uabd            v28.8b,  v19.8b,  v17.8b  // abs(q1 - q0)
+        cmhi            v26.8b,  v30.8b,  v26.8b  // < alpha
+        cmhi            v27.8b,  v31.8b,  v27.8b  // < beta
+        cmhi            v28.8b,  v31.8b,  v28.8b  // < beta
+        and             v26.8b,  v26.8b,  v27.8b
+        and             v26.8b,  v26.8b,  v28.8b
+        mov             x2, v26.d[0]
+
+        ushll           v4.8h,   v18.8b,  #1
+        ushll           v6.8h,   v19.8b,  #1
+        cbz             x2, 9f
+        uaddl           v20.8h,  v16.8b,  v19.8b
+        uaddl           v22.8h,  v17.8b,  v18.8b
+        add             v20.8h,  v20.8h,  v4.8h
+        add             v22.8h,  v22.8h,  v6.8h
+        uqrshrn         v24.8b,  v20.8h,  #2
+        uqrshrn         v25.8b,  v22.8h,  #2
+        bit             v16.8b,  v24.8b,  v26.8b
+        bit             v17.8b,  v25.8b,  v26.8b
 .endm
 
 function ff_h264_v_loop_filter_chroma_intra_neon, export=1
-    h264_loop_filter_start_intra
+        h264_loop_filter_start_intra
 
-    sub             x0,  x0,  x1, lsl #1
-    ld1             {v18.8b}, [x0], x1
-    ld1             {v16.8b}, [x0], x1
-    ld1             {v17.8b}, [x0], x1
-    ld1             {v19.8b}, [x0]
+        sub             x0,  x0,  x1, lsl #1
+        ld1             {v18.8b}, [x0], x1
+        ld1             {v16.8b}, [x0], x1
+        ld1             {v17.8b}, [x0], x1
+        ld1             {v19.8b}, [x0]
 
-    h264_loop_filter_chroma_intra
+        h264_loop_filter_chroma_intra
 
-    sub             x0,  x0,  x1, lsl #1
-    st1             {v16.8b}, [x0], x1
-    st1             {v17.8b}, [x0], x1
+        sub             x0,  x0,  x1, lsl #1
+        st1             {v16.8b}, [x0], x1
+        st1             {v17.8b}, [x0], x1
 
 9:
-    ret
+        ret
 endfunc
 
 function ff_h264_h_loop_filter_chroma_mbaff_intra_neon, export=1
-    h264_loop_filter_start_intra
-
-    sub             x4,  x0,  #2
-    sub             x0,  x0,  #1
-    ld1             {v18.8b}, [x4], x1
-    ld1             {v16.8b}, [x4], x1
-    ld1             {v17.8b}, [x4], x1
-    ld1             {v19.8b}, [x4], x1
-
-    transpose_4x8B v18, v16, v17, v19, v26, v27, v28, v29
-
-    h264_loop_filter_chroma_intra
+        h264_loop_filter_start_intra
 
-    st2             {v16.b,v17.b}[0], [x0], x1
-    st2             {v16.b,v17.b}[1], [x0], x1
-    st2             {v16.b,v17.b}[2], [x0], x1
-    st2             {v16.b,v17.b}[3], [x0], x1
+        sub             x4,  x0,  #2
+        sub             x0,  x0,  #1
+        ld1             {v18.8b}, [x4], x1
+        ld1             {v16.8b}, [x4], x1
+        ld1             {v17.8b}, [x4], x1
+        ld1             {v19.8b}, [x4], x1
+
+        transpose_4x8B v18, v16, v17, v19, v26, v27, v28, v29
+
+        h264_loop_filter_chroma_intra
+
+        st2             {v16.b,v17.b}[0], [x0], x1
+        st2             {v16.b,v17.b}[1], [x0], x1
+        st2             {v16.b,v17.b}[2], [x0], x1
+        st2             {v16.b,v17.b}[3], [x0], x1
 
 9:
-    ret
+        ret
 endfunc
 
 function ff_h264_h_loop_filter_chroma_intra_neon, export=1
-    h264_loop_filter_start_intra
+        h264_loop_filter_start_intra
 
-    sub             x4,  x0,  #2
-    sub             x0,  x0,  #1
+        sub             x4,  x0,  #2
+        sub             x0,  x0,  #1
 h_loop_filter_chroma420_intra:
-    ld1             {v18.8b}, [x4], x1
-    ld1             {v16.8b}, [x4], x1
-    ld1             {v17.8b}, [x4], x1
-    ld1             {v19.8b}, [x4], x1
-    ld1             {v18.s}[1], [x4], x1
-    ld1             {v16.s}[1], [x4], x1
-    ld1             {v17.s}[1], [x4], x1
-    ld1             {v19.s}[1], [x4], x1
-
-    transpose_4x8B v18, v16, v17, v19, v26, v27, v28, v29
-
-    h264_loop_filter_chroma_intra
-
-    st2             {v16.b,v17.b}[0], [x0], x1
-    st2             {v16.b,v17.b}[1], [x0], x1
-    st2             {v16.b,v17.b}[2], [x0], x1
-    st2             {v16.b,v17.b}[3], [x0], x1
-    st2             {v16.b,v17.b}[4], [x0], x1
-    st2             {v16.b,v17.b}[5], [x0], x1
-    st2             {v16.b,v17.b}[6], [x0], x1
-    st2             {v16.b,v17.b}[7], [x0], x1
+        ld1             {v18.8b}, [x4], x1
+        ld1             {v16.8b}, [x4], x1
+        ld1             {v17.8b}, [x4], x1
+        ld1             {v19.8b}, [x4], x1
+        ld1             {v18.s}[1], [x4], x1
+        ld1             {v16.s}[1], [x4], x1
+        ld1             {v17.s}[1], [x4], x1
+        ld1             {v19.s}[1], [x4], x1
+
+        transpose_4x8B v18, v16, v17, v19, v26, v27, v28, v29
+
+        h264_loop_filter_chroma_intra
+
+        st2             {v16.b,v17.b}[0], [x0], x1
+        st2             {v16.b,v17.b}[1], [x0], x1
+        st2             {v16.b,v17.b}[2], [x0], x1
+        st2             {v16.b,v17.b}[3], [x0], x1
+        st2             {v16.b,v17.b}[4], [x0], x1
+        st2             {v16.b,v17.b}[5], [x0], x1
+        st2             {v16.b,v17.b}[6], [x0], x1
+        st2             {v16.b,v17.b}[7], [x0], x1
 
 9:
-    ret
+        ret
 endfunc
 
 function ff_h264_h_loop_filter_chroma422_intra_neon, export=1
-    h264_loop_filter_start_intra
-    sub             x4,  x0,  #2
-    add             x5,  x0,  x1, lsl #3
-    sub             x0,  x0,  #1
-    mov             x7,  x30
-    bl              h_loop_filter_chroma420_intra
-    sub             x0,  x5,  #1
-    mov             x30, x7
-    b               h_loop_filter_chroma420_intra
+        h264_loop_filter_start_intra
+        sub             x4,  x0,  #2
+        add             x5,  x0,  x1, lsl #3
+        sub             x0,  x0,  #1
+        mov             x7,  x30
+        bl              h_loop_filter_chroma420_intra
+        sub             x0,  x5,  #1
+        mov             x30, x7
+        b               h_loop_filter_chroma420_intra
 endfunc
 
 .macro  biweight_16     macs, macd
@@ -691,7 +685,6 @@
 
 .macro  biweight_func   w
 function ff_biweight_h264_pixels_\w\()_neon, export=1
-        sxtw            x2,  w2
         lsr             w8,  w5,  #31
         add             w7,  w7,  #1
         eor             w8,  w8,  w6,  lsr #30
@@ -800,7 +793,6 @@
 
 .macro  weight_func     w
 function ff_weight_h264_pixels_\w\()_neon, export=1
-        sxtw            x1,  w1
         cmp             w3,  #1
         mov             w6,  #1
         lsl             w5,  w5,  w3
@@ -827,3 +819,258 @@
         weight_func     16
         weight_func     8
         weight_func     4
+
+.macro  h264_loop_filter_start_10
+        cmp             w2,  #0
+        ldr             w6,  [x4]
+        ccmp            w3,  #0,  #0,  ne
+        lsl             w2,  w2,  #2
+        mov             v24.S[0], w6
+        lsl             w3,  w3,  #2
+        and             w8,  w6,  w6,  lsl #16
+        b.eq            1f
+        ands            w8,  w8,  w8,  lsl #8
+        b.ge            2f
+1:
+        ret
+2:
+.endm
+
+.macro h264_loop_filter_start_intra_10
+        orr             w4,  w2,  w3
+        cbnz            w4,  1f
+        ret
+1:
+        lsl             w2,  w2,  #2
+        lsl             w3,  w3,  #2
+        dup             v30.8h,   w2              // alpha
+        dup             v31.8h,   w3              // beta
+.endm
+
+.macro  h264_loop_filter_chroma_10
+        dup             v22.8h,  w2               // alpha
+        dup             v23.8h,  w3               // beta
+        uxtl            v24.8h,  v24.8b           // tc0
+
+        uabd            v26.8h,  v16.8h,  v0.8h   // abs(p0 - q0)
+        uabd            v28.8h,  v18.8h,  v16.8h  // abs(p1 - p0)
+        uabd            v30.8h,  v2.8h,   v0.8h   // abs(q1 - q0)
+        cmhi            v26.8h,  v22.8h,  v26.8h  // < alpha
+        cmhi            v28.8h,  v23.8h,  v28.8h  // < beta
+        cmhi            v30.8h,  v23.8h,  v30.8h  // < beta
+
+        and             v26.16b, v26.16b, v28.16b
+        mov             v4.16b,  v0.16b
+        sub             v4.8h,   v4.8h,   v16.8h
+        and             v26.16b, v26.16b, v30.16b
+        shl             v4.8h,   v4.8h,   #2
+        mov             x8, v26.d[0]
+        mov             x9, v26.d[1]
+        sli             v24.8h,  v24.8h,  #8
+        uxtl            v24.8h,  v24.8b
+        add             v4.8h,   v4.8h,   v18.8h
+        adds            x8,  x8,  x9
+        shl             v24.8h,  v24.8h,  #2
+
+        b.eq            9f
+
+        movi            v31.8h, #3                // (tc0 - 1) << (BIT_DEPTH - 8)) + 1
+        uqsub           v24.8h,  v24.8h,  v31.8h
+        sub             v4.8h,   v4.8h,   v2.8h
+        srshr           v4.8h,   v4.8h,   #3
+        smin            v4.8h,   v4.8h,   v24.8h
+        neg             v25.8h,  v24.8h
+        smax            v4.8h,   v4.8h,   v25.8h
+        and             v4.16b,  v4.16b,  v26.16b
+        add             v16.8h,  v16.8h,  v4.8h
+        sub             v0.8h,   v0.8h,   v4.8h
+
+        mvni            v4.8h,   #0xFC, lsl #8    // 1023 for clipping
+        movi            v5.8h,   #0
+        smin            v0.8h,   v0.8h,   v4.8h
+        smin            v16.8h,  v16.8h,  v4.8h
+        smax            v0.8h,   v0.8h,   v5.8h
+        smax            v16.8h,  v16.8h,  v5.8h
+.endm
+
+function ff_h264_v_loop_filter_chroma_neon_10, export=1
+        h264_loop_filter_start_10
+
+        mov             x10,  x0
+        sub             x0,  x0,  x1, lsl #1
+        ld1             {v18.8h}, [x0 ], x1
+        ld1             {v0.8h},  [x10], x1
+        ld1             {v16.8h}, [x0 ], x1
+        ld1             {v2.8h},  [x10]
+
+        h264_loop_filter_chroma_10
+
+        sub             x0,  x10,  x1, lsl #1
+        st1             {v16.8h}, [x0], x1
+        st1             {v0.8h},  [x0], x1
+9:
+        ret
+endfunc
+
+function ff_h264_h_loop_filter_chroma_neon_10, export=1
+        h264_loop_filter_start_10
+
+        sub             x0,  x0,  #4 // access the 2nd left pixel
+h_loop_filter_chroma420_10:
+        add             x10,  x0,  x1,  lsl #2
+        ld1             {v18.d}[0], [x0 ], x1
+        ld1             {v18.d}[1], [x10], x1
+        ld1             {v16.d}[0], [x0 ], x1
+        ld1             {v16.d}[1], [x10], x1
+        ld1             {v0.d}[0],  [x0 ], x1
+        ld1             {v0.d}[1],  [x10], x1
+        ld1             {v2.d}[0],  [x0 ], x1
+        ld1             {v2.d}[1],  [x10], x1
+
+        transpose_4x8H  v18, v16, v0, v2, v28, v29, v30, v31
+
+        h264_loop_filter_chroma_10
+
+        transpose_4x8H  v18, v16, v0, v2, v28, v29, v30, v31
+
+        sub             x0,  x10,  x1, lsl #3
+        st1             {v18.d}[0], [x0], x1
+        st1             {v16.d}[0], [x0], x1
+        st1             {v0.d}[0],  [x0], x1
+        st1             {v2.d}[0],  [x0], x1
+        st1             {v18.d}[1], [x0], x1
+        st1             {v16.d}[1], [x0], x1
+        st1             {v0.d}[1],  [x0], x1
+        st1             {v2.d}[1],  [x0], x1
+9:
+        ret
+endfunc
+
+function ff_h264_h_loop_filter_chroma422_neon_10, export=1
+        h264_loop_filter_start_10
+        add             x5,  x0,  x1
+        sub             x0,  x0,  #4
+        add             x1,  x1,  x1
+        mov             x7,  x30
+        bl              h_loop_filter_chroma420_10
+        mov             x30, x7
+        sub             x0,  x5,  #4
+        mov             v24.s[0], w6
+        b               h_loop_filter_chroma420_10
+endfunc
+
+.macro h264_loop_filter_chroma_intra_10
+        uabd            v26.8h,  v16.8h,  v17.8h  // abs(p0 - q0)
+        uabd            v27.8h,  v18.8h,  v16.8h  // abs(p1 - p0)
+        uabd            v28.8h,  v19.8h,  v17.8h  // abs(q1 - q0)
+        cmhi            v26.8h,  v30.8h,  v26.8h  // < alpha
+        cmhi            v27.8h,  v31.8h,  v27.8h  // < beta
+        cmhi            v28.8h,  v31.8h,  v28.8h  // < beta
+        and             v26.16b, v26.16b, v27.16b
+        and             v26.16b, v26.16b, v28.16b
+        mov             x2, v26.d[0]
+        mov             x3, v26.d[1]
+
+        shl             v4.8h,  v18.8h,  #1
+        shl             v6.8h,  v19.8h,  #1
+
+        adds            x2,  x2,  x3
+        b.eq            9f
+
+        add             v20.8h,  v16.8h,  v19.8h
+        add             v22.8h,  v17.8h,  v18.8h
+        add             v20.8h,  v20.8h,  v4.8h
+        add             v22.8h,  v22.8h,  v6.8h
+        urshr           v24.8h,  v20.8h,  #2
+        urshr           v25.8h,  v22.8h,  #2
+        bit             v16.16b, v24.16b, v26.16b
+        bit             v17.16b, v25.16b, v26.16b
+.endm
+
+function ff_h264_v_loop_filter_chroma_intra_neon_10, export=1
+        h264_loop_filter_start_intra_10
+        mov             x9,  x0
+        sub             x0,  x0,  x1, lsl #1
+        ld1             {v18.8h}, [x0], x1
+        ld1             {v17.8h}, [x9], x1
+        ld1             {v16.8h}, [x0], x1
+        ld1             {v19.8h}, [x9]
+
+        h264_loop_filter_chroma_intra_10
+
+        sub             x0,  x9,  x1, lsl #1
+        st1             {v16.8h}, [x0], x1
+        st1             {v17.8h}, [x0], x1
+
+9:
+        ret
+endfunc
+
+function ff_h264_h_loop_filter_chroma_mbaff_intra_neon_10, export=1
+        h264_loop_filter_start_intra_10
+
+        sub             x4,  x0,  #4
+        sub             x0,  x0,  #2
+        add             x9,  x4,  x1, lsl #1
+        ld1             {v18.8h}, [x4], x1
+        ld1             {v17.8h}, [x9], x1
+        ld1             {v16.8h}, [x4], x1
+        ld1             {v19.8h}, [x9], x1
+
+        transpose_4x8H v18, v16, v17, v19, v26, v27, v28, v29
+
+        h264_loop_filter_chroma_intra_10
+
+        st2             {v16.h,v17.h}[0], [x0], x1
+        st2             {v16.h,v17.h}[1], [x0], x1
+        st2             {v16.h,v17.h}[2], [x0], x1
+        st2             {v16.h,v17.h}[3], [x0], x1
+
+9:
+        ret
+endfunc
+
+function ff_h264_h_loop_filter_chroma_intra_neon_10, export=1
+        h264_loop_filter_start_intra_10
+        sub             x4,  x0,  #4
+        sub             x0,  x0,  #2
+h_loop_filter_chroma420_intra_10:
+        add             x9,  x4,  x1, lsl #2
+        ld1             {v18.4h},   [x4], x1
+        ld1             {v18.d}[1], [x9], x1
+        ld1             {v16.4h},   [x4], x1
+        ld1             {v16.d}[1], [x9], x1
+        ld1             {v17.4h},   [x4], x1
+        ld1             {v17.d}[1], [x9], x1
+        ld1             {v19.4h},   [x4], x1
+        ld1             {v19.d}[1], [x9], x1
+
+        transpose_4x8H v18, v16, v17, v19, v26, v27, v28, v29
+
+        h264_loop_filter_chroma_intra_10
+
+        st2             {v16.h,v17.h}[0], [x0], x1
+        st2             {v16.h,v17.h}[1], [x0], x1
+        st2             {v16.h,v17.h}[2], [x0], x1
+        st2             {v16.h,v17.h}[3], [x0], x1
+        st2             {v16.h,v17.h}[4], [x0], x1
+        st2             {v16.h,v17.h}[5], [x0], x1
+        st2             {v16.h,v17.h}[6], [x0], x1
+        st2             {v16.h,v17.h}[7], [x0], x1
+
+9:
+        ret
+endfunc
+
+function ff_h264_h_loop_filter_chroma422_intra_neon_10, export=1
+        h264_loop_filter_start_intra_10
+        sub             x4,  x0,  #4
+        add             x5,  x0,  x1, lsl #3
+        sub             x0,  x0,  #2
+        mov             x7,  x30
+        bl              h_loop_filter_chroma420_intra_10
+        mov             x4,  x9
+        sub             x0,  x5,  #2
+        mov             x30, x7
+        b               h_loop_filter_chroma420_intra_10
+endfunc
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264idct_neon.S b/media/ffvpx/libavcodec/aarch64/h264idct_neon.S
--- a/media/ffvpx/libavcodec/aarch64/h264idct_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264idct_neon.S	2023-04-06 12:50:06.969470973 +0200
@@ -24,6 +24,7 @@
 
 function ff_h264_idct_add_neon, export=1
 .L_ff_h264_idct_add_neon:
+        AARCH64_VALID_CALL_TARGET
         ld1             {v0.4H, v1.4H, v2.4H, v3.4H},  [x1]
         sxtw            x2,     w2
         movi            v30.8H, #0
@@ -79,6 +80,7 @@
 
 function ff_h264_idct_dc_add_neon, export=1
 .L_ff_h264_idct_dc_add_neon:
+        AARCH64_VALID_CALL_TARGET
         sxtw            x2,  w2
         mov             w3,       #0
         ld1r            {v2.8H},  [x1]
@@ -155,8 +157,7 @@
 endfunc
 
 function ff_h264_idct_add8_neon, export=1
-        sub             sp,  sp, #0x40
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-0x40]!
         mov             x12, x30
         ldp             x6,  x15, [x0]          // dest[0], dest[1]
         add             x5,  x1,  #16*4         // block_offset
@@ -185,8 +186,7 @@
         csel            x6,  x15, x6,  eq
         cmp             x10, #20
         b.lt            1b
-        ldp             x19, x20, [sp]
-        add             sp,  sp,  #0x40
+        ldp             x19, x20, [sp], #0x40
         ret             x12
 endfunc
 
@@ -266,6 +266,7 @@
 
 function ff_h264_idct8_add_neon, export=1
 .L_ff_h264_idct8_add_neon:
+        AARCH64_VALID_CALL_TARGET
         movi            v19.8H,   #0
         sxtw            x2,       w2
         ld1             {v24.8H, v25.8H}, [x1]
@@ -330,6 +331,7 @@
 
 function ff_h264_idct8_dc_add_neon, export=1
 .L_ff_h264_idct8_dc_add_neon:
+        AARCH64_VALID_CALL_TARGET
         mov             w3,       #0
         sxtw            x2,       w2
         ld1r            {v31.8H}, [x1]
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264pred_init.c b/media/ffvpx/libavcodec/aarch64/h264pred_init.c
--- a/media/ffvpx/libavcodec/aarch64/h264pred_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264pred_init.c	2023-04-06 12:49:40.249394729 +0200
@@ -45,42 +45,84 @@
 void ff_pred8x8_l00_dc_neon(uint8_t *src, ptrdiff_t stride);
 void ff_pred8x8_0l0_dc_neon(uint8_t *src, ptrdiff_t stride);
 
+void ff_pred16x16_vert_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred16x16_hor_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred16x16_plane_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred16x16_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred16x16_top_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+
+void ff_pred8x8_vert_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_hor_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_plane_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_128_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_left_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_top_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_l0t_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_0lt_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_l00_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+void ff_pred8x8_0l0_dc_neon_10(uint8_t *src, ptrdiff_t stride);
+
 static av_cold void h264_pred_init_neon(H264PredContext *h, int codec_id,
                                         const int bit_depth,
                                         const int chroma_format_idc)
 {
-    const int high_depth = bit_depth > 8;
-
-    if (high_depth)
-        return;
-
-    if (chroma_format_idc <= 1) {
-        h->pred8x8[VERT_PRED8x8     ] = ff_pred8x8_vert_neon;
-        h->pred8x8[HOR_PRED8x8      ] = ff_pred8x8_hor_neon;
-        if (codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8)
-            h->pred8x8[PLANE_PRED8x8] = ff_pred8x8_plane_neon;
-        h->pred8x8[DC_128_PRED8x8   ] = ff_pred8x8_128_dc_neon;
-        if (codec_id != AV_CODEC_ID_RV40 && codec_id != AV_CODEC_ID_VP7 &&
-            codec_id != AV_CODEC_ID_VP8) {
-            h->pred8x8[DC_PRED8x8     ] = ff_pred8x8_dc_neon;
-            h->pred8x8[LEFT_DC_PRED8x8] = ff_pred8x8_left_dc_neon;
-            h->pred8x8[TOP_DC_PRED8x8 ] = ff_pred8x8_top_dc_neon;
-            h->pred8x8[ALZHEIMER_DC_L0T_PRED8x8] = ff_pred8x8_l0t_dc_neon;
-            h->pred8x8[ALZHEIMER_DC_0LT_PRED8x8] = ff_pred8x8_0lt_dc_neon;
-            h->pred8x8[ALZHEIMER_DC_L00_PRED8x8] = ff_pred8x8_l00_dc_neon;
-            h->pred8x8[ALZHEIMER_DC_0L0_PRED8x8] = ff_pred8x8_0l0_dc_neon;
+    if (bit_depth == 8) {
+        if (chroma_format_idc <= 1) {
+            h->pred8x8[VERT_PRED8x8     ] = ff_pred8x8_vert_neon;
+            h->pred8x8[HOR_PRED8x8      ] = ff_pred8x8_hor_neon;
+            if (codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8)
+                h->pred8x8[PLANE_PRED8x8] = ff_pred8x8_plane_neon;
+            h->pred8x8[DC_128_PRED8x8   ] = ff_pred8x8_128_dc_neon;
+            if (codec_id != AV_CODEC_ID_RV40 && codec_id != AV_CODEC_ID_VP7 &&
+                codec_id != AV_CODEC_ID_VP8) {
+                h->pred8x8[DC_PRED8x8     ] = ff_pred8x8_dc_neon;
+                h->pred8x8[LEFT_DC_PRED8x8] = ff_pred8x8_left_dc_neon;
+                h->pred8x8[TOP_DC_PRED8x8 ] = ff_pred8x8_top_dc_neon;
+                h->pred8x8[ALZHEIMER_DC_L0T_PRED8x8] = ff_pred8x8_l0t_dc_neon;
+                h->pred8x8[ALZHEIMER_DC_0LT_PRED8x8] = ff_pred8x8_0lt_dc_neon;
+                h->pred8x8[ALZHEIMER_DC_L00_PRED8x8] = ff_pred8x8_l00_dc_neon;
+                h->pred8x8[ALZHEIMER_DC_0L0_PRED8x8] = ff_pred8x8_0l0_dc_neon;
+            }
         }
+
+        h->pred16x16[DC_PRED8x8     ] = ff_pred16x16_dc_neon;
+        h->pred16x16[VERT_PRED8x8   ] = ff_pred16x16_vert_neon;
+        h->pred16x16[HOR_PRED8x8    ] = ff_pred16x16_hor_neon;
+        h->pred16x16[LEFT_DC_PRED8x8] = ff_pred16x16_left_dc_neon;
+        h->pred16x16[TOP_DC_PRED8x8 ] = ff_pred16x16_top_dc_neon;
+        h->pred16x16[DC_128_PRED8x8 ] = ff_pred16x16_128_dc_neon;
+        if (codec_id != AV_CODEC_ID_SVQ3 && codec_id != AV_CODEC_ID_RV40 &&
+            codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8)
+            h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_neon;
     }
+    if (bit_depth == 10) {
+        if (chroma_format_idc <= 1) {
+            h->pred8x8[VERT_PRED8x8     ] = ff_pred8x8_vert_neon_10;
+            h->pred8x8[HOR_PRED8x8      ] = ff_pred8x8_hor_neon_10;
+            if (codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8)
+                h->pred8x8[PLANE_PRED8x8] = ff_pred8x8_plane_neon_10;
+            h->pred8x8[DC_128_PRED8x8   ] = ff_pred8x8_128_dc_neon_10;
+            if (codec_id != AV_CODEC_ID_RV40 && codec_id != AV_CODEC_ID_VP7 &&
+                codec_id != AV_CODEC_ID_VP8) {
+                h->pred8x8[DC_PRED8x8     ] = ff_pred8x8_dc_neon_10;
+                h->pred8x8[LEFT_DC_PRED8x8] = ff_pred8x8_left_dc_neon_10;
+                h->pred8x8[TOP_DC_PRED8x8 ] = ff_pred8x8_top_dc_neon_10;
+                h->pred8x8[ALZHEIMER_DC_L0T_PRED8x8] = ff_pred8x8_l0t_dc_neon_10;
+                h->pred8x8[ALZHEIMER_DC_0LT_PRED8x8] = ff_pred8x8_0lt_dc_neon_10;
+                h->pred8x8[ALZHEIMER_DC_L00_PRED8x8] = ff_pred8x8_l00_dc_neon_10;
+                h->pred8x8[ALZHEIMER_DC_0L0_PRED8x8] = ff_pred8x8_0l0_dc_neon_10;
+            }
+        }
 
-    h->pred16x16[DC_PRED8x8     ] = ff_pred16x16_dc_neon;
-    h->pred16x16[VERT_PRED8x8   ] = ff_pred16x16_vert_neon;
-    h->pred16x16[HOR_PRED8x8    ] = ff_pred16x16_hor_neon;
-    h->pred16x16[LEFT_DC_PRED8x8] = ff_pred16x16_left_dc_neon;
-    h->pred16x16[TOP_DC_PRED8x8 ] = ff_pred16x16_top_dc_neon;
-    h->pred16x16[DC_128_PRED8x8 ] = ff_pred16x16_128_dc_neon;
-    if (codec_id != AV_CODEC_ID_SVQ3 && codec_id != AV_CODEC_ID_RV40 &&
-        codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8)
-        h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_neon;
+        h->pred16x16[DC_PRED8x8     ] = ff_pred16x16_dc_neon_10;
+        h->pred16x16[VERT_PRED8x8   ] = ff_pred16x16_vert_neon_10;
+        h->pred16x16[HOR_PRED8x8    ] = ff_pred16x16_hor_neon_10;
+        h->pred16x16[TOP_DC_PRED8x8 ] = ff_pred16x16_top_dc_neon_10;
+        if (codec_id != AV_CODEC_ID_SVQ3 && codec_id != AV_CODEC_ID_RV40 &&
+            codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8)
+            h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_neon_10;
+    }
 }
 
 av_cold void ff_h264_pred_init_aarch64(H264PredContext *h, int codec_id,
diff -Naur a/media/ffvpx/libavcodec/aarch64/h264pred_neon.S b/media/ffvpx/libavcodec/aarch64/h264pred_neon.S
--- a/media/ffvpx/libavcodec/aarch64/h264pred_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/h264pred_neon.S	2023-04-06 12:49:40.249394729 +0200
@@ -81,8 +81,8 @@
 .L_pred16x16_dc_end:
         mov             w3,  #8
 6:      st1             {v0.16b}, [x0], x1
-        st1             {v0.16b}, [x0], x1
         subs            w3,  w3,  #1
+        st1             {v0.16b}, [x0], x1
         b.ne            6b
         ret
 endfunc
@@ -91,8 +91,8 @@
         sub             x2,  x0,  #1
         mov             w3,  #16
 1:      ld1r            {v0.16b}, [x2], x1
-        st1             {v0.16b}, [x0], x1
         subs            w3,  w3,  #1
+        st1             {v0.16b}, [x0], x1
         b.ne            1b
         ret
 endfunc
@@ -102,9 +102,9 @@
         add             x1,  x1,  x1
         ld1             {v0.16b}, [x2], x1
         mov             w3,  #8
-1:      st1             {v0.16b}, [x0], x1
+1:      subs            w3,  w3,  #1
+        st1             {v0.16b}, [x0], x1
         st1             {v0.16b}, [x2], x1
-        subs            w3,  w3,  #1
         b.ne            1b
         ret
 endfunc
@@ -158,8 +158,8 @@
         add             v1.8h,  v1.8h,  v2.8h
         sqshrun2        v0.16b, v1.8h,  #5
         add             v1.8h,  v1.8h,  v3.8h
-        st1             {v0.16b}, [x0], x1
         subs            w3,  w3,  #1
+        st1             {v0.16b}, [x0], x1
         b.ne            1b
         ret
 endfunc
@@ -175,8 +175,8 @@
         sub             x2,  x0,  #1
         mov             w3,  #8
 1:      ld1r            {v0.8b},  [x2], x1
-        st1             {v0.8b},  [x0], x1
         subs            w3,  w3,  #1
+        st1             {v0.8b},  [x0], x1
         b.ne            1b
         ret
 endfunc
@@ -186,9 +186,9 @@
         lsl             x1,  x1,  #1
         ld1             {v0.8b},  [x2], x1
         mov             w3,  #4
-1:      st1             {v0.8b},  [x0], x1
+1:      subs            w3,  w3,  #1
+        st1             {v0.8b},  [x0], x1
         st1             {v0.8b},  [x2], x1
-        subs            w3,  w3,  #1
         b.ne            1b
         ret
 endfunc
@@ -232,9 +232,9 @@
         mov             w3,  #8
 1:
         sqshrun         v0.8b,  v1.8h,  #5
+        subs            w3,  w3,  #1
         add             v1.8h,  v1.8h,  v2.8h
         st1             {v0.8b},  [x0], x1
-        subs            w3,  w3,  #1
         b.ne            1b
         ret
 endfunc
@@ -290,9 +290,9 @@
 .L_pred8x8_dc_end:
         mov             w3,  #4
         add             x2,  x0,  x1,  lsl #2
-6:      st1             {v0.8b},  [x0], x1
+6:      subs            w3,  w3,  #1
+        st1             {v0.8b},  [x0], x1
         st1             {v1.8b},  [x2], x1
-        subs            w3,  w3,  #1
         b.ne            6b
         ret
 endfunc
@@ -359,3 +359,407 @@
         dup             v1.8b,  v1.b[0]
         b               .L_pred8x8_dc_end
 endfunc
+
+.macro ldcol.16  rd,  rs,  rt,  n=4,  hi=0
+.if \n >= 4 && \hi == 0
+        ld1             {\rd\().h}[0],  [\rs], \rt
+        ld1             {\rd\().h}[1],  [\rs], \rt
+        ld1             {\rd\().h}[2],  [\rs], \rt
+        ld1             {\rd\().h}[3],  [\rs], \rt
+.endif
+.if \n == 8 || \hi == 1
+        ld1             {\rd\().h}[4],  [\rs], \rt
+        ld1             {\rd\().h}[5],  [\rs], \rt
+        ld1             {\rd\().h}[6],  [\rs], \rt
+        ld1             {\rd\().h}[7],  [\rs], \rt
+.endif
+.endm
+
+// slower than C
+/*
+function ff_pred16x16_128_dc_neon_10, export=1
+        movi            v0.8h, #2, lsl #8 // 512, 1 << (bit_depth - 1)
+
+        b               .L_pred16x16_dc_10_end
+endfunc
+*/
+
+function ff_pred16x16_top_dc_neon_10, export=1
+        sub             x2,  x0,  x1
+
+        ld1             {v0.8h, v1.8h}, [x2]
+
+        add             v0.8h, v0.8h, v1.8h
+        addv            h0, v0.8h
+
+        urshr           v0.4h,  v0.4h,  #4
+        dup             v0.8h, v0.h[0]
+        b               .L_pred16x16_dc_10_end
+endfunc
+
+// slower than C
+/*
+function ff_pred16x16_left_dc_neon_10, export=1
+        sub             x2,  x0,  #2 // access to the "left" column
+        ldcol.16        v0,  x2,  x1,  8
+        ldcol.16        v1,  x2,  x1,  8 // load "left" column
+
+        add             v0.8h, v0.8h, v1.8h
+        addv            h0,  v0.8h
+
+        urshr           v0.4h,  v0.4h,  #4
+        dup             v0.8h, v0.h[0]
+        b               .L_pred16x16_dc_10_end
+endfunc
+*/
+
+function ff_pred16x16_dc_neon_10, export=1
+        sub             x2,  x0,  x1 // access to the "top" row
+        sub             x3,  x0,  #2 // access to the "left" column
+
+        ld1             {v0.8h, v1.8h}, [x2]
+        ldcol.16        v2,  x3,  x1,  8
+        ldcol.16        v3,  x3,  x1,  8 // load pixels in "top" row and "left" col
+
+        add             v0.8h, v0.8h, v1.8h
+        add             v2.8h, v2.8h, v3.8h
+        add             v0.8h, v0.8h, v2.8h
+        addv            h0, v0.8h
+
+        urshr           v0.4h,  v0.4h,  #5
+        dup             v0.8h,  v0.h[0]
+.L_pred16x16_dc_10_end:
+        mov             v1.16b,  v0.16b
+        mov             w3,  #8
+6:      st1             {v0.8h, v1.8h}, [x0], x1
+        subs            w3,  w3,  #1
+        st1             {v0.8h, v1.8h}, [x0], x1
+        b.ne            6b
+        ret
+endfunc
+
+function ff_pred16x16_hor_neon_10, export=1
+        sub             x2,  x0,  #2
+        add             x3,  x0,  #16
+
+        mov             w4,  #16
+1:      ld1r            {v0.8h},  [x2],  x1
+        subs            w4,  w4,  #1
+        st1             {v0.8h},  [x0],  x1
+        st1             {v0.8h},  [x3],  x1
+        b.ne            1b
+        ret
+endfunc
+
+function ff_pred16x16_vert_neon_10, export=1
+        sub             x2,  x0,  x1
+        add             x1,  x1,  x1
+
+        ld1             {v0.8h, v1.8h},  [x2],  x1
+
+        mov             w3,  #8
+1:      subs            w3,  w3,  #1
+        st1             {v0.8h, v1.8h},  [x0],  x1
+        st1             {v0.8h, v1.8h},  [x2],  x1
+
+        b.ne            1b
+        ret
+endfunc
+
+function ff_pred16x16_plane_neon_10, export=1
+        sub             x3,  x0,  x1
+        movrel          x4,  p16weight
+        add             x2,  x3,  #16
+        sub             x3,  x3,  #2
+        ld1             {v0.8h},  [x3]
+        ld1             {v2.8h},  [x2], x1
+        ldcol.16        v1,  x3,  x1, 8
+        add             x3,  x3,  x1
+        ldcol.16        v3,  x3,  x1, 8
+
+        rev64           v16.8h,  v0.8h
+        rev64           v17.8h,  v1.8h
+        ext             v0.16b, v16.16b, v16.16b, #8
+        ext             v1.16b, v17.16b, v17.16b, #8
+
+        add             v7.8h,  v2.8h,  v3.8h
+        sub             v2.8h,  v2.8h,  v0.8h
+        sub             v3.8h,  v3.8h,  v1.8h
+        ld1             {v0.8h},     [x4]
+        mul             v2.8h,  v2.8h,  v0.8h
+        mul             v3.8h,  v3.8h,  v0.8h
+        addp            v2.8h,  v2.8h,  v3.8h
+        addp            v2.8h,  v2.8h,  v2.8h
+        addp            v2.4h,  v2.4h,  v2.4h
+        sshll           v3.4s,  v2.4h,  #2
+        saddw           v2.4s,  v3.4s,  v2.4h
+        rshrn           v4.4h,  v2.4s,  #6
+        trn2            v5.4h,  v4.4h,  v4.4h
+        add             v2.4h,  v4.4h,  v5.4h
+        shl             v3.4h,  v2.4h,  #3
+        ext             v7.16b, v7.16b, v7.16b, #14
+        sub             v3.4h,  v3.4h,  v2.4h   // 7 * (b + c)
+        add             v7.4h,  v7.4h,  v0.4h
+        shl             v2.4h,  v7.4h,  #4
+        ssubl           v2.4s,  v2.4h,  v3.4h
+        shl             v3.4h,  v4.4h,  #4
+        ext             v0.16b, v0.16b, v0.16b, #14
+        ssubl           v6.4s,  v5.4h,  v3.4h
+
+        mov             v0.h[0],  wzr
+        mul             v0.8h,  v0.8h,  v4.h[0]
+        dup             v16.4s, v2.s[0]
+        dup             v17.4s, v2.s[0]
+        dup             v2.8h,  v4.h[0]
+        dup             v3.4s,  v6.s[0]
+        shl             v2.8h,  v2.8h,  #3
+        saddw           v16.4s, v16.4s, v0.4h
+        saddw2          v17.4s, v17.4s, v0.8h
+        saddw           v3.4s,  v3.4s,  v2.4h
+
+        mov             w3,      #16
+        mvni            v4.8h,   #0xFC, lsl #8 // 1023 for clipping
+1:
+        sqshrun         v0.4h,  v16.4s, #5
+        sqshrun2        v0.8h,  v17.4s, #5
+        saddw           v16.4s, v16.4s, v2.4h
+        saddw           v17.4s, v17.4s, v2.4h
+        sqshrun         v1.4h,  v16.4s, #5
+        sqshrun2        v1.8h,  v17.4s, #5
+        add             v16.4s, v16.4s, v3.4s
+        add             v17.4s, v17.4s, v3.4s
+
+        subs            w3,  w3,  #1
+
+        smin            v0.8h,  v0.8h,  v4.8h
+        smin            v1.8h,  v1.8h,  v4.8h
+
+        st1             {v0.8h, v1.8h}, [x0], x1
+        b.ne            1b
+        ret
+endfunc
+
+function ff_pred8x8_hor_neon_10, export=1
+        sub             x2,  x0,  #2
+        mov             w3,  #8
+
+1:      ld1r            {v0.8h},  [x2], x1
+        subs            w3,  w3,  #1
+        st1             {v0.8h},  [x0], x1
+        b.ne            1b
+        ret
+endfunc
+
+function ff_pred8x8_vert_neon_10, export=1
+        sub             x2,  x0,  x1
+        lsl             x1,  x1,  #1
+
+        ld1             {v0.8h},  [x2], x1
+        mov             w3,  #4
+1:      subs            w3,  w3,  #1
+        st1             {v0.8h},  [x0], x1
+        st1             {v0.8h},  [x2], x1
+        b.ne            1b
+        ret
+endfunc
+
+function ff_pred8x8_plane_neon_10, export=1
+        sub             x3,  x0,  x1
+        movrel          x4,  p8weight
+        movrel          x5,  p16weight
+        add             x2,  x3,  #8
+        sub             x3,  x3,  #2
+        ld1             {v0.d}[0],  [x3]
+        ld1             {v2.d}[0],  [x2], x1
+        ldcol.16        v0,  x3,  x1,  hi=1
+        add             x3,  x3,  x1
+        ldcol.16        v3,  x3,  x1,  4
+        add             v7.8h,  v2.8h,  v3.8h
+        rev64           v0.8h,  v0.8h
+        trn1            v2.2d,  v2.2d,  v3.2d
+        sub             v2.8h,  v2.8h,  v0.8h
+        ld1             {v6.8h},  [x4]
+        mul             v2.8h,  v2.8h,  v6.8h
+        ld1             {v0.8h},  [x5]
+        saddlp          v2.4s,  v2.8h
+        addp            v2.4s,  v2.4s,  v2.4s
+        shl             v3.4s,  v2.4s,  #4
+        add             v2.4s,  v3.4s,  v2.4s
+        rshrn           v5.4h,  v2.4s,  #5
+        addp            v2.4h,  v5.4h,  v5.4h
+        shl             v3.4h,  v2.4h,  #1
+        add             v3.4h,  v3.4h,  v2.4h
+        rev64           v7.4h,  v7.4h
+        add             v7.4h,  v7.4h,  v0.4h
+        shl             v2.4h,  v7.4h,  #4
+        ssubl           v2.4s,  v2.4h,  v3.4h
+        ext             v0.16b, v0.16b, v0.16b, #14
+        mov             v0.h[0],  wzr
+        mul             v0.8h,  v0.8h,  v5.h[0]
+        dup             v1.4s,  v2.s[0]
+        dup             v2.4s,  v2.s[0]
+        dup             v3.8h,  v5.h[1]
+        saddw           v1.4s,  v1.4s,  v0.4h
+        saddw2          v2.4s,  v2.4s,  v0.8h
+        mov             w3,  #8
+        mvni            v4.8h,  #0xFC,  lsl #8 // 1023 for clipping
+1:
+        sqshrun         v0.4h,  v1.4s,  #5
+        sqshrun2        v0.8h,  v2.4s,  #5
+
+        saddw           v1.4s,  v1.4s,  v3.4h
+        saddw           v2.4s,  v2.4s,  v3.4h
+
+        subs            w3,  w3,  #1
+
+        smin            v0.8h,  v0.8h,  v4.8h
+
+        st1             {v0.8h},  [x0],  x1
+        b.ne            1b
+        ret
+endfunc
+
+function ff_pred8x8_128_dc_neon_10, export=1
+        movi            v0.8h,  #2, lsl #8      // 512, 1 << (bit_depth - 1)
+        movi            v1.8h,  #2, lsl #8
+        b               .L_pred8x8_dc_10_end
+endfunc
+
+function ff_pred8x8_top_dc_neon_10, export=1
+        sub             x2,  x0,  x1
+        ld1             {v0.8h},  [x2]
+
+        addp            v0.8h,  v0.8h,  v0.8h
+        addp            v0.4h,  v0.4h,  v0.4h
+        zip1            v0.4h,  v0.4h,  v0.4h
+        urshr           v2.4h,  v0.4h,  #2
+        zip1            v0.8h,  v2.8h,  v2.8h
+        zip1            v1.8h,  v2.8h,  v2.8h
+        b               .L_pred8x8_dc_10_end
+endfunc
+
+function ff_pred8x8_left_dc_neon_10, export=1
+        sub             x2,  x0,  #2
+        ldcol.16        v0,  x2,  x1,  8
+
+        addp            v0.8h,  v0.8h,  v0.8h
+        addp            v0.4h,  v0.4h,  v0.4h
+        urshr           v2.4h,  v0.4h,  #2
+        dup             v1.8h,  v2.h[1]
+        dup             v0.8h,  v2.h[0]
+        b               .L_pred8x8_dc_10_end
+endfunc
+
+function ff_pred8x8_dc_neon_10, export=1
+        sub             x2,  x0,  x1
+        sub             x3,  x0,  #2
+
+        ld1             {v0.8h}, [x2]
+        ldcol.16        v1,  x3,  x1, 8
+
+        addp            v0.8h,  v0.8h, v0.8h
+        addp            v1.8h,  v1.8h, v1.8h
+        trn1            v2.2s,  v0.2s,  v1.2s
+        trn2            v3.2s,  v0.2s,  v1.2s
+        addp            v4.4h,  v2.4h,  v3.4h
+        addp            v5.4h,  v4.4h,  v4.4h
+        urshr           v6.4h,  v5.4h,  #3
+        urshr           v7.4h,  v4.4h,  #2
+        dup             v0.8h,  v6.h[0]
+        dup             v2.8h,  v7.h[2]
+        dup             v1.8h,  v7.h[3]
+        dup             v3.8h,  v6.h[1]
+        zip1            v0.2d,  v0.2d,  v2.2d
+        zip1            v1.2d,  v1.2d,  v3.2d
+.L_pred8x8_dc_10_end:
+        mov             w3,  #4
+        add             x2,  x0,  x1,  lsl #2
+
+6:      st1             {v0.8h},  [x0], x1
+        subs            w3,  w3,  #1
+        st1             {v1.8h},  [x2], x1
+        b.ne            6b
+        ret
+endfunc
+
+function ff_pred8x8_l0t_dc_neon_10, export=1
+        sub             x2,  x0,  x1
+        sub             x3,  x0,  #2
+
+        ld1             {v0.8h},  [x2]
+        ldcol.16        v1,  x3,  x1, 4
+
+        addp            v0.8h,  v0.8h,  v0.8h
+        addp            v1.4h,  v1.4h,  v1.4h
+        addp            v0.4h,  v0.4h,  v0.4h
+        addp            v1.4h,  v1.4h,  v1.4h
+        add             v1.4h,  v1.4h,  v0.4h
+
+        urshr           v2.4h,  v0.4h,  #2
+        urshr           v3.4h,  v1.4h,  #3      // the pred4x4 part
+
+        dup             v4.4h,  v3.h[0]
+        dup             v5.4h,  v2.h[0]
+        dup             v6.4h,  v2.h[1]
+
+        zip1            v0.2d,  v4.2d,  v6.2d
+        zip1            v1.2d,  v5.2d,  v6.2d
+        b               .L_pred8x8_dc_10_end
+endfunc
+
+function ff_pred8x8_l00_dc_neon_10, export=1
+        sub             x2,  x0,  #2
+
+        ldcol.16        v0,  x2,  x1,  4
+
+        addp            v0.4h,  v0.4h,  v0.4h
+        addp            v0.4h,  v0.4h,  v0.4h
+        urshr           v0.4h,  v0.4h,  #2
+
+        movi            v1.8h,  #2, lsl #8      // 512
+        dup             v0.8h,  v0.h[0]
+        b               .L_pred8x8_dc_10_end
+endfunc
+
+function ff_pred8x8_0lt_dc_neon_10, export=1
+        add             x3,  x0,  x1,  lsl #2
+        sub             x2,  x0,  x1
+        sub             x3,  x3,  #2
+
+        ld1             {v0.8h},  [x2]
+        ldcol.16        v1,  x3,  x1,  hi=1
+
+        addp            v0.8h,  v0.8h,  v0.8h
+        addp            v1.8h,  v1.8h,  v1.8h
+        addp            v0.4h,  v0.4h,  v0.4h
+        addp            v1.4h,  v1.4h,  v1.4h
+        zip1            v0.2s,  v0.2s,  v1.2s
+        add             v1.4h,  v0.4h,  v1.4h
+
+        urshr           v2.4h,  v0.4h,  #2
+        urshr           v3.4h,  v1.4h,  #3
+
+        dup             v4.4h,  v2.h[0]
+        dup             v5.4h,  v2.h[3]
+        dup             v6.4h,  v2.h[1]
+        dup             v7.4h,  v3.h[1]
+
+        zip1            v0.2d,  v4.2d,  v6.2d
+        zip1            v1.2d,  v5.2d,  v7.2d
+        b               .L_pred8x8_dc_10_end
+endfunc
+
+function ff_pred8x8_0l0_dc_neon_10, export=1
+        add             x2,  x0,  x1,  lsl #2
+        sub             x2,  x2,  #2
+
+        ldcol.16        v1,  x2,  x1,  4
+
+        addp            v2.8h,  v1.8h,  v1.8h
+        addp            v2.4h,  v2.4h,  v2.4h
+        urshr           v1.4h,  v2.4h,  #2
+
+        movi            v0.8h,  #2,  lsl #8     // 512
+        dup             v1.8h,  v1.h[0]
+        b               .L_pred8x8_dc_10_end
+endfunc
diff -Naur a/media/ffvpx/libavcodec/aarch64/idctdsp_init_aarch64.c b/media/ffvpx/libavcodec/aarch64/idctdsp_init_aarch64.c
--- a/media/ffvpx/libavcodec/aarch64/idctdsp_init_aarch64.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/idctdsp_init_aarch64.c	2023-04-06 12:49:40.249394729 +0200
@@ -27,19 +27,29 @@
 #include "libavcodec/idctdsp.h"
 #include "idct.h"
 
+void ff_put_pixels_clamped_neon(const int16_t *, uint8_t *, ptrdiff_t);
+void ff_put_signed_pixels_clamped_neon(const int16_t *, uint8_t *, ptrdiff_t);
+void ff_add_pixels_clamped_neon(const int16_t *, uint8_t *, ptrdiff_t);
+
 av_cold void ff_idctdsp_init_aarch64(IDCTDSPContext *c, AVCodecContext *avctx,
                                      unsigned high_bit_depth)
 {
     int cpu_flags = av_get_cpu_flags();
 
-    if (have_neon(cpu_flags) && !avctx->lowres && !high_bit_depth) {
-        if (avctx->idct_algo == FF_IDCT_AUTO ||
-            avctx->idct_algo == FF_IDCT_SIMPLEAUTO ||
-            avctx->idct_algo == FF_IDCT_SIMPLENEON) {
-            c->idct_put  = ff_simple_idct_put_neon;
-            c->idct_add  = ff_simple_idct_add_neon;
-            c->idct      = ff_simple_idct_neon;
-            c->perm_type = FF_IDCT_PERM_PARTTRANS;
+    if (have_neon(cpu_flags)) {
+        if (!avctx->lowres && !high_bit_depth) {
+            if (avctx->idct_algo == FF_IDCT_AUTO ||
+                avctx->idct_algo == FF_IDCT_SIMPLEAUTO ||
+                avctx->idct_algo == FF_IDCT_SIMPLENEON) {
+                c->idct_put  = ff_simple_idct_put_neon;
+                c->idct_add  = ff_simple_idct_add_neon;
+                c->idct      = ff_simple_idct_neon;
+                c->perm_type = FF_IDCT_PERM_PARTTRANS;
+            }
         }
+
+        c->add_pixels_clamped        = ff_add_pixels_clamped_neon;
+        c->put_pixels_clamped        = ff_put_pixels_clamped_neon;
+        c->put_signed_pixels_clamped = ff_put_signed_pixels_clamped_neon;
     }
 }
diff -Naur a/media/ffvpx/libavcodec/aarch64/idctdsp_neon.S b/media/ffvpx/libavcodec/aarch64/idctdsp_neon.S
--- a/media/ffvpx/libavcodec/aarch64/idctdsp_neon.S	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/idctdsp_neon.S	2023-04-06 12:49:40.249394729 +0200
@@ -0,0 +1,130 @@
+/*
+ * IDCT AArch64 NEON optimisations
+ *
+ * Copyright (c) 2022 Ben Avison <bavison@riscosopen.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/aarch64/asm.S"
+
+// Clamp 16-bit signed block coefficients to unsigned 8-bit
+// On entry:
+//   x0 -> array of 64x 16-bit coefficients
+//   x1 -> 8-bit results
+//   x2 = row stride for results, bytes
+function ff_put_pixels_clamped_neon, export=1
+        ld1             {v0.16b, v1.16b, v2.16b, v3.16b}, [x0], #64
+        ld1             {v4.16b, v5.16b, v6.16b, v7.16b}, [x0]
+        sqxtun          v0.8b, v0.8h
+        sqxtun          v1.8b, v1.8h
+        sqxtun          v2.8b, v2.8h
+        sqxtun          v3.8b, v3.8h
+        sqxtun          v4.8b, v4.8h
+        st1             {v0.8b}, [x1], x2
+        sqxtun          v0.8b, v5.8h
+        st1             {v1.8b}, [x1], x2
+        sqxtun          v1.8b, v6.8h
+        st1             {v2.8b}, [x1], x2
+        sqxtun          v2.8b, v7.8h
+        st1             {v3.8b}, [x1], x2
+        st1             {v4.8b}, [x1], x2
+        st1             {v0.8b}, [x1], x2
+        st1             {v1.8b}, [x1], x2
+        st1             {v2.8b}, [x1]
+        ret
+endfunc
+
+// Clamp 16-bit signed block coefficients to signed 8-bit (biased by 128)
+// On entry:
+//   x0 -> array of 64x 16-bit coefficients
+//   x1 -> 8-bit results
+//   x2 = row stride for results, bytes
+function ff_put_signed_pixels_clamped_neon, export=1
+        ld1             {v0.16b, v1.16b, v2.16b, v3.16b}, [x0], #64
+        movi            v4.8b, #128
+        ld1             {v16.16b, v17.16b, v18.16b, v19.16b}, [x0]
+        sqxtn           v0.8b, v0.8h
+        sqxtn           v1.8b, v1.8h
+        sqxtn           v2.8b, v2.8h
+        sqxtn           v3.8b, v3.8h
+        sqxtn           v5.8b, v16.8h
+        add             v0.8b, v0.8b, v4.8b
+        sqxtn           v6.8b, v17.8h
+        add             v1.8b, v1.8b, v4.8b
+        sqxtn           v7.8b, v18.8h
+        add             v2.8b, v2.8b, v4.8b
+        sqxtn           v16.8b, v19.8h
+        add             v3.8b, v3.8b, v4.8b
+        st1             {v0.8b}, [x1], x2
+        add             v0.8b, v5.8b, v4.8b
+        st1             {v1.8b}, [x1], x2
+        add             v1.8b, v6.8b, v4.8b
+        st1             {v2.8b}, [x1], x2
+        add             v2.8b, v7.8b, v4.8b
+        st1             {v3.8b}, [x1], x2
+        add             v3.8b, v16.8b, v4.8b
+        st1             {v0.8b}, [x1], x2
+        st1             {v1.8b}, [x1], x2
+        st1             {v2.8b}, [x1], x2
+        st1             {v3.8b}, [x1]
+        ret
+endfunc
+
+// Add 16-bit signed block coefficients to unsigned 8-bit
+// On entry:
+//   x0 -> array of 64x 16-bit coefficients
+//   x1 -> 8-bit input and results
+//   x2 = row stride for 8-bit input and results, bytes
+function ff_add_pixels_clamped_neon, export=1
+        ld1             {v0.16b, v1.16b, v2.16b, v3.16b}, [x0], #64
+        mov             x3, x1
+        ld1             {v4.8b}, [x1], x2
+        ld1             {v5.8b}, [x1], x2
+        ld1             {v6.8b}, [x1], x2
+        ld1             {v7.8b}, [x1], x2
+        ld1             {v16.16b, v17.16b, v18.16b, v19.16b}, [x0]
+        uaddw           v0.8h, v0.8h, v4.8b
+        uaddw           v1.8h, v1.8h, v5.8b
+        uaddw           v2.8h, v2.8h, v6.8b
+        ld1             {v4.8b}, [x1], x2
+        uaddw           v3.8h, v3.8h, v7.8b
+        ld1             {v5.8b}, [x1], x2
+        sqxtun          v0.8b, v0.8h
+        ld1             {v6.8b}, [x1], x2
+        sqxtun          v1.8b, v1.8h
+        ld1             {v7.8b}, [x1]
+        sqxtun          v2.8b, v2.8h
+        sqxtun          v3.8b, v3.8h
+        uaddw           v4.8h, v16.8h, v4.8b
+        st1             {v0.8b}, [x3], x2
+        uaddw           v0.8h, v17.8h, v5.8b
+        st1             {v1.8b}, [x3], x2
+        uaddw           v1.8h, v18.8h, v6.8b
+        st1             {v2.8b}, [x3], x2
+        uaddw           v2.8h, v19.8h, v7.8b
+        sqxtun          v4.8b, v4.8h
+        sqxtun          v0.8b, v0.8h
+        st1             {v3.8b}, [x3], x2
+        sqxtun          v1.8b, v1.8h
+        sqxtun          v2.8b, v2.8h
+        st1             {v4.8b}, [x3], x2
+        st1             {v0.8b}, [x3], x2
+        st1             {v1.8b}, [x3], x2
+        st1             {v2.8b}, [x3]
+        ret
+endfunc
diff -Naur a/media/ffvpx/libavcodec/aarch64/idct.h b/media/ffvpx/libavcodec/aarch64/idct.h
--- a/media/ffvpx/libavcodec/aarch64/idct.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/idct.h	2023-04-06 12:49:40.249394729 +0200
@@ -19,6 +19,7 @@
 #ifndef AVCODEC_AARCH64_IDCT_H
 #define AVCODEC_AARCH64_IDCT_H
 
+#include <stddef.h>
 #include <stdint.h>
 
 void ff_simple_idct_neon(int16_t *data);
diff -Naur a/media/ffvpx/libavcodec/aarch64/mdct_neon.S b/media/ffvpx/libavcodec/aarch64/mdct_neon.S
--- a/media/ffvpx/libavcodec/aarch64/mdct_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/mdct_neon.S	2023-04-06 12:50:06.969470973 +0200
@@ -23,8 +23,8 @@
 #include "libavutil/aarch64/asm.S"
 
 function ff_imdct_half_neon, export=1
-        sub             sp,  sp,  #32
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-32]!
+        AARCH64_SIGN_LINK_REGISTER
         str             x30, [sp, #16]
         mov             x12, #1
         ldr             w14, [x0, #28]          // mdct_bits
@@ -119,16 +119,16 @@
         st2             {v4.2s,v5.2s},  [x0]
         st2             {v6.2s,v7.2s},  [x8]
 
-        ldp             x19, x20, [sp]
         ldr             x30, [sp, #16]
-        add             sp,  sp,  #32
+        AARCH64_VALIDATE_LINK_REGISTER
+        ldp             x19, x20, [sp], #32
 
         ret
 endfunc
 
 function ff_imdct_calc_neon, export=1
-        sub             sp,  sp,  #32
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-32]!
+        AARCH64_SIGN_LINK_REGISTER
         str             x30, [sp, #16]
         ldr             w3,  [x0, #28]          // mdct_bits
         mov             x19, #1
@@ -160,16 +160,17 @@
         subs            x19, x19,  #16
         b.gt            1b
 
-        ldp             x19, x20, [sp], #16
-        ldr             x30, [sp], #16
+        ldr             x30, [sp, #16]
+        AARCH64_VALIDATE_LINK_REGISTER
+        ldp             x19, x20, [sp], #32
 
         ret
 endfunc
 
 
 function ff_mdct_calc_neon, export=1
-        sub             sp,  sp,  #32
-        stp             x19, x20, [sp]
+        stp             x19, x20, [sp, #-32]!
+        AARCH64_SIGN_LINK_REGISTER
         str             x30, [sp, #16]
 
         mov             x12, #1
@@ -317,7 +318,9 @@
         st2             {v4.2s,v5.2s},  [x0]
         st2             {v6.2s,v7.2s},  [x8]
 
-        ldp             x19, x20, [sp], #16
-        ldr             x30, [sp], #16
+        ldr             x30, [sp, #16]
+        AARCH64_VALIDATE_LINK_REGISTER
+        ldp             x19, x20, [sp], #32
+
         ret
 endfunc
diff -Naur a/media/ffvpx/libavcodec/aarch64/moz.build b/media/ffvpx/libavcodec/aarch64/moz.build
--- a/media/ffvpx/libavcodec/aarch64/moz.build	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/moz.build	2023-04-06 12:49:40.249394729 +0200
@@ -4,47 +4,55 @@
 ## License, v. 2.0. If a copy of the MPL was not distributed with this
 ## file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-SOURCES += [
-    'h264chroma_init_aarch64.c',
-    'h264cmc_neon.S',
-    'h264dsp_init_aarch64.c',
-    'h264dsp_neon.S',
-    'h264idct_neon.S',
-    'h264pred_init.c',
-    'h264pred_neon.S',
-    'hpeldsp_init_aarch64.c',
-    'hpeldsp_neon.S',
-    'idctdsp_init_aarch64.c',
-    'mdct_neon.S',
-    'mpegaudiodsp_init.c',
-    'mpegaudiodsp_neon.S',
-    'neon.S',
-    'simple_idct_neon.S',
-    'videodsp.S',
-    'videodsp_init.c',
-    'vp8dsp_init_aarch64.c',
-    'vp8dsp_neon.S',
-    'vp9dsp_init_10bpp_aarch64.c',
-    'vp9dsp_init_12bpp_aarch64.c',
-    'vp9dsp_init_aarch64.c',
-    'vp9itxfm_16bpp_neon.S',
-    'vp9itxfm_neon.S',
-    'vp9lpf_16bpp_neon.S',
-    'vp9lpf_neon.S',
-    'vp9mc_16bpp_neon.S',
-    'vp9mc_aarch64.S',
-    'vp9mc_neon.S',
-]
-
-if CONFIG['OS_ARCH'] == 'WINNT':
-    USE_INTEGRATED_CLANGCL_AS = True
-    DEFINES['EXTERN_ASM'] = ''
-
-if CONFIG['MOZ_LIBAV_FFT']:
+if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
     SOURCES += [
         'fft_init_aarch64.c',
         'fft_neon.S',
+        'h264chroma_init_aarch64.c',
+        'h264cmc_neon.S',
+        'h264dsp_init_aarch64.c',
+        'h264dsp_neon.S',
+        'h264idct_neon.S',
+        'h264pred_init.c',
+        'h264pred_neon.S',
+        'hpeldsp_init_aarch64.c',
+        'hpeldsp_neon.S',
+        'idctdsp_init_aarch64.c',
+        'idctdsp_neon.S',
+        'mdct_neon.S',
+        'mpegaudiodsp_init.c',
+        'mpegaudiodsp_neon.S',
+        'neon.S',
+        'simple_idct_neon.S',
+        'videodsp.S',
+        'videodsp_init.c',
+        'vp8dsp_init_aarch64.c',
+        'vp8dsp_neon.S',
+        'vp9dsp_init_10bpp_aarch64.c',
+        'vp9dsp_init_12bpp_aarch64.c',
+        'vp9dsp_init_aarch64.c',
+        'vp9itxfm_16bpp_neon.S',
+        'vp9itxfm_neon.S',
+        'vp9lpf_16bpp_neon.S',
+        'vp9lpf_neon.S',
+        'vp9mc_16bpp_neon.S',
+        'vp9mc_aarch64.S',
+        'vp9mc_neon.S',
     ]
+else:
+    SOURCES += [
+        'fft_init_aarch64.c',
+        'fft_neon.S',
+        'idctdsp_init_aarch64.c',
+        'idctdsp_neon.S',
+        'mpegaudiodsp_init.c',
+        'mpegaudiodsp_neon.S',
+        'simple_idct_neon.S',
+    ]
+
+if CONFIG['OS_ARCH'] == 'WINNT':
+    USE_INTEGRATED_CLANGCL_AS = True
+    DEFINES['EXTERN_ASM'] = ''
 
 FINAL_LIBRARY = 'mozavcodec'
 
diff -Naur a/media/ffvpx/libavcodec/aarch64/neon.S b/media/ffvpx/libavcodec/aarch64/neon.S
--- a/media/ffvpx/libavcodec/aarch64/neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/neon.S	2023-04-06 12:49:40.249394729 +0200
@@ -109,12 +109,25 @@
         trn2            \r5\().4H,  \r0\().4H,  \r1\().4H
         trn1            \r6\().4H,  \r2\().4H,  \r3\().4H
         trn2            \r7\().4H,  \r2\().4H,  \r3\().4H
+
         trn1            \r0\().2S,  \r4\().2S,  \r6\().2S
         trn2            \r2\().2S,  \r4\().2S,  \r6\().2S
         trn1            \r1\().2S,  \r5\().2S,  \r7\().2S
         trn2            \r3\().2S,  \r5\().2S,  \r7\().2S
 .endm
 
+.macro transpose_4x8H r0, r1, r2, r3, t4, t5, t6, t7
+        trn1            \t4\().8H,  \r0\().8H,  \r1\().8H
+        trn2            \t5\().8H,  \r0\().8H,  \r1\().8H
+        trn1            \t6\().8H,  \r2\().8H,  \r3\().8H
+        trn2            \t7\().8H,  \r2\().8H,  \r3\().8H
+
+        trn1            \r0\().4S,  \t4\().4S,  \t6\().4S
+        trn2            \r2\().4S,  \t4\().4S,  \t6\().4S
+        trn1            \r1\().4S,  \t5\().4S,  \t7\().4S
+        trn2            \r3\().4S,  \t5\().4S,  \t7\().4S
+.endm
+
 .macro  transpose_8x8H  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9
         trn1            \r8\().8H,  \r0\().8H,  \r1\().8H
         trn2            \r9\().8H,  \r0\().8H,  \r1\().8H
diff -Naur a/media/ffvpx/libavcodec/aarch64/simple_idct_neon.S b/media/ffvpx/libavcodec/aarch64/simple_idct_neon.S
--- a/media/ffvpx/libavcodec/aarch64/simple_idct_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/simple_idct_neon.S	2023-04-06 12:49:40.249394729 +0200
@@ -58,7 +58,7 @@
 .endm
 
 .macro idct_end
-        br              x10
+        ret             x10
 .endm
 
 .macro smull1 a, b, c
diff -Naur a/media/ffvpx/libavcodec/aarch64/vc1dsp_init_aarch64.c b/media/ffvpx/libavcodec/aarch64/vc1dsp_init_aarch64.c
--- a/media/ffvpx/libavcodec/aarch64/vc1dsp_init_aarch64.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/vc1dsp_init_aarch64.c	2023-04-06 12:50:06.969470973 +0200
@@ -21,27 +21,121 @@
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
 #include "libavutil/aarch64/cpu.h"
+#include "libavutil/intreadwrite.h"
 #include "libavcodec/vc1dsp.h"
 
 #include "config.h"
 
-void ff_put_vc1_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_vc1_inv_trans_8x8_neon(int16_t *block);
+void ff_vc1_inv_trans_8x4_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+void ff_vc1_inv_trans_4x8_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+void ff_vc1_inv_trans_4x4_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+
+void ff_vc1_inv_trans_8x8_dc_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+void ff_vc1_inv_trans_8x4_dc_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+void ff_vc1_inv_trans_4x8_dc_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+void ff_vc1_inv_trans_4x4_dc_neon(uint8_t *dest, ptrdiff_t stride, int16_t *block);
+
+void ff_vc1_v_loop_filter4_neon(uint8_t *src, ptrdiff_t stride, int pq);
+void ff_vc1_h_loop_filter4_neon(uint8_t *src, ptrdiff_t stride, int pq);
+void ff_vc1_v_loop_filter8_neon(uint8_t *src, ptrdiff_t stride, int pq);
+void ff_vc1_h_loop_filter8_neon(uint8_t *src, ptrdiff_t stride, int pq);
+void ff_vc1_v_loop_filter16_neon(uint8_t *src, ptrdiff_t stride, int pq);
+void ff_vc1_h_loop_filter16_neon(uint8_t *src, ptrdiff_t stride, int pq);
+
+void ff_put_vc1_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_avg_vc1_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_vc1_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_put_vc1_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_vc1_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_avg_vc1_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_vc1_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
 
+int ff_vc1_unescape_buffer_helper_neon(const uint8_t *src, int size, uint8_t *dst);
+
+static int vc1_unescape_buffer_neon(const uint8_t *src, int size, uint8_t *dst)
+{
+    /* Dealing with starting and stopping, and removing escape bytes, are
+     * comparatively less time-sensitive, so are more clearly expressed using
+     * a C wrapper around the assembly inner loop. Note that we assume a
+     * little-endian machine that supports unaligned loads. */
+    int dsize = 0;
+    while (size >= 4)
+    {
+        int found = 0;
+        while (!found && (((uintptr_t) dst) & 7) && size >= 4)
+        {
+            found = (AV_RL32(src) &~ 0x03000000) == 0x00030000;
+            if (!found)
+            {
+                *dst++ = *src++;
+                --size;
+                ++dsize;
+            }
+        }
+        if (!found)
+        {
+            int skip = size - ff_vc1_unescape_buffer_helper_neon(src, size, dst);
+            dst += skip;
+            src += skip;
+            size -= skip;
+            dsize += skip;
+            while (!found && size >= 4)
+            {
+                found = (AV_RL32(src) &~ 0x03000000) == 0x00030000;
+                if (!found)
+                {
+                    *dst++ = *src++;
+                    --size;
+                    ++dsize;
+                }
+            }
+        }
+        if (found)
+        {
+            *dst++ = *src++;
+            *dst++ = *src++;
+            ++src;
+            size -= 3;
+            dsize += 2;
+        }
+    }
+    while (size > 0)
+    {
+        *dst++ = *src++;
+        --size;
+        ++dsize;
+    }
+    return dsize;
+}
+
 av_cold void ff_vc1dsp_init_aarch64(VC1DSPContext *dsp)
 {
     int cpu_flags = av_get_cpu_flags();
 
     if (have_neon(cpu_flags)) {
+        dsp->vc1_inv_trans_8x8 = ff_vc1_inv_trans_8x8_neon;
+        dsp->vc1_inv_trans_8x4 = ff_vc1_inv_trans_8x4_neon;
+        dsp->vc1_inv_trans_4x8 = ff_vc1_inv_trans_4x8_neon;
+        dsp->vc1_inv_trans_4x4 = ff_vc1_inv_trans_4x4_neon;
+        dsp->vc1_inv_trans_8x8_dc = ff_vc1_inv_trans_8x8_dc_neon;
+        dsp->vc1_inv_trans_8x4_dc = ff_vc1_inv_trans_8x4_dc_neon;
+        dsp->vc1_inv_trans_4x8_dc = ff_vc1_inv_trans_4x8_dc_neon;
+        dsp->vc1_inv_trans_4x4_dc = ff_vc1_inv_trans_4x4_dc_neon;
+
+        dsp->vc1_v_loop_filter4  = ff_vc1_v_loop_filter4_neon;
+        dsp->vc1_h_loop_filter4  = ff_vc1_h_loop_filter4_neon;
+        dsp->vc1_v_loop_filter8  = ff_vc1_v_loop_filter8_neon;
+        dsp->vc1_h_loop_filter8  = ff_vc1_h_loop_filter8_neon;
+        dsp->vc1_v_loop_filter16 = ff_vc1_v_loop_filter16_neon;
+        dsp->vc1_h_loop_filter16 = ff_vc1_h_loop_filter16_neon;
+
         dsp->put_no_rnd_vc1_chroma_pixels_tab[0] = ff_put_vc1_chroma_mc8_neon;
         dsp->avg_no_rnd_vc1_chroma_pixels_tab[0] = ff_avg_vc1_chroma_mc8_neon;
         dsp->put_no_rnd_vc1_chroma_pixels_tab[1] = ff_put_vc1_chroma_mc4_neon;
         dsp->avg_no_rnd_vc1_chroma_pixels_tab[1] = ff_avg_vc1_chroma_mc4_neon;
+
+        dsp->vc1_unescape_buffer = vc1_unescape_buffer_neon;
     }
 }
diff -Naur a/media/ffvpx/libavcodec/aarch64/videodsp_init.c b/media/ffvpx/libavcodec/aarch64/videodsp_init.c
--- a/media/ffvpx/libavcodec/aarch64/videodsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/videodsp_init.c	2023-04-06 12:50:06.969470973 +0200
@@ -21,7 +21,7 @@
 #include "libavutil/aarch64/cpu.h"
 #include "libavcodec/videodsp.h"
 
-void ff_prefetch_aarch64(uint8_t *mem, ptrdiff_t stride, int h);
+void ff_prefetch_aarch64(const uint8_t *mem, ptrdiff_t stride, int h);
 
 av_cold void ff_videodsp_init_aarch64(VideoDSPContext *ctx, int bpc)
 {
diff -Naur a/media/ffvpx/libavcodec/aarch64/videodsp.S b/media/ffvpx/libavcodec/aarch64/videodsp.S
--- a/media/ffvpx/libavcodec/aarch64/videodsp.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/videodsp.S	2023-04-06 12:49:40.249394729 +0200
@@ -19,10 +19,11 @@
 #include "libavutil/aarch64/asm.S"
 
 function ff_prefetch_aarch64, export=1
+1:
         subs            w2,  w2,  #2
         prfm            pldl1strm, [x0]
         prfm            pldl1strm, [x0,  x1]
         add             x0,  x0,  x1,  lsl #1
-        b.gt            X(ff_prefetch_aarch64)
+        b.gt            1b
         ret
 endfunc
diff -Naur a/media/ffvpx/libavcodec/aarch64/vp8dsp.h b/media/ffvpx/libavcodec/aarch64/vp8dsp.h
--- a/media/ffvpx/libavcodec/aarch64/vp8dsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/vp8dsp.h	2023-04-06 12:50:06.969470973 +0200
@@ -53,7 +53,7 @@
 
 #define VP8_MC(n, opt)                                                  \
     void ff_put_vp8_##n##_##opt(uint8_t *dst, ptrdiff_t dststride,      \
-                                uint8_t *src, ptrdiff_t srcstride,      \
+                                const uint8_t *src, ptrdiff_t srcstride,\
                                 int h, int x, int y)
 
 #define VP8_EPEL(w, opt)                        \
diff -Naur a/media/ffvpx/libavcodec/aarch64/vp9itxfm_16bpp_neon.S b/media/ffvpx/libavcodec/aarch64/vp9itxfm_16bpp_neon.S
--- a/media/ffvpx/libavcodec/aarch64/vp9itxfm_16bpp_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/vp9itxfm_16bpp_neon.S	2023-04-06 12:49:40.249394729 +0200
@@ -1040,7 +1040,7 @@
 .irp i, 16, 20, 24, 28, 17, 21, 25, 29, 18, 22, 26, 30, 19, 23, 27, 31
         store           \i,  x0,  #16
 .endr
-        br              x14
+        ret             x14
 1:
         // Special case: For the last input column (x1 == 12),
         // which would be stored as the last row in the temp buffer,
@@ -1068,7 +1068,7 @@
         mov             v29.16b, v17.16b
         mov             v30.16b, v18.16b
         mov             v31.16b, v19.16b
-        br              x14
+        ret             x14
 endfunc
 
 // Read a vertical 4x16 slice out of a 16x16 matrix, do a transform on it,
@@ -1098,7 +1098,7 @@
         load_add_store  v16.4s, v17.4s, v18.4s, v19.4s, v20.4s, v21.4s, v22.4s, v23.4s
         load_add_store  v24.4s, v25.4s, v26.4s, v27.4s, v28.4s, v29.4s, v30.4s, v31.4s
 
-        br              x14
+        ret             x14
 endfunc
 .endm
 
@@ -1208,7 +1208,7 @@
         ldp             d12, d13, [sp], 0x10
         ldp             d14, d15, [sp], 0x10
 .endif
-        br              x15
+        ret             x15
 endfunc
 
 function ff_vp9_\txfm1\()_\txfm2\()_16x16_add_10_neon, export=1
@@ -1264,7 +1264,7 @@
         st1             {v23.4s},  [x0], #16
         st1             {v27.4s},  [x0], #16
         st1             {v31.4s},  [x0], #16
-        br              x14
+        ret             x14
 endfunc
 
 function idct16_1d_4x16_pass2_quarter_neon
@@ -1286,7 +1286,7 @@
         load_add_store  v16.4s, v17.4s, v18.4s, v19.4s, v20.4s, v21.4s, v22.4s, v23.4s
         load_add_store  v24.4s, v25.4s, v26.4s, v27.4s, v28.4s, v29.4s, v30.4s, v31.4s
 
-        br              x14
+        ret             x14
 endfunc
 
 function idct16_1d_4x16_pass1_half_neon
@@ -1313,7 +1313,7 @@
 .irp i, 16, 20, 24, 28, 17, 21, 25, 29, 18, 22, 26, 30, 19, 23, 27, 31
         store           \i,  x0,  #16
 .endr
-        br              x14
+        ret             x14
 1:
         // Special case: For the second input column (r1 == 4),
         // which would be stored as the second row in the temp buffer,
@@ -1341,7 +1341,7 @@
         mov             v21.16b, v17.16b
         mov             v22.16b, v18.16b
         mov             v23.16b, v19.16b
-        br              x14
+        ret             x14
 endfunc
 
 function idct16_1d_4x16_pass2_half_neon
@@ -1364,7 +1364,7 @@
         load_add_store  v16.4s, v17.4s, v18.4s, v19.4s, v20.4s, v21.4s, v22.4s, v23.4s
         load_add_store  v24.4s, v25.4s, v26.4s, v27.4s, v28.4s, v29.4s, v30.4s, v31.4s
 
-        br              x14
+        ret             x14
 endfunc
 
 .macro idct16_partial size
@@ -1390,7 +1390,7 @@
 
         add             sp,  sp,  #1024
         ldp             d8,  d9,  [sp], 0x10
-        br              x15
+        ret             x15
 endfunc
 .endm
 
@@ -1729,7 +1729,7 @@
         store_rev       v29.4s, v25.4s, v21.4s, v17.4s, v29.16b, v25.16b
         store_rev       v28.4s, v24.4s, v20.4s, v16.4s, v28.16b, v24.16b
 .purgem store_rev
-        br              x14
+        ret             x14
 endfunc
 
 // This is mostly the same as 4x32_pass1, but without the transpose,
@@ -1849,7 +1849,7 @@
         load_acc_store  v24.4s, v25.4s, v26.4s, v27.4s, 1
         load_acc_store  v28.4s, v29.4s, v30.4s, v31.4s, 1
 .purgem load_acc_store
-        br              x14
+        ret             x14
 endfunc
 .endm
 
@@ -1943,7 +1943,7 @@
         ldp             d10, d11, [sp], 0x10
         ldp             d8,  d9,  [sp], 0x10
 
-        br              x15
+        ret             x15
 endfunc
 
 function ff_vp9_idct_idct_32x32_add_10_neon, export=1
@@ -2009,7 +2009,7 @@
         ldp             d10, d11, [sp], 0x10
         ldp             d8,  d9,  [sp], 0x10
 
-        br              x15
+        ret             x15
 endfunc
 .endm
 
diff -Naur a/media/ffvpx/libavcodec/aarch64/vp9itxfm_neon.S b/media/ffvpx/libavcodec/aarch64/vp9itxfm_neon.S
--- a/media/ffvpx/libavcodec/aarch64/vp9itxfm_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/vp9itxfm_neon.S	2023-04-06 12:50:06.970471013 +0200
@@ -787,7 +787,7 @@
 .irp i, 16, 24, 17, 25, 18, 26, 19, 27, 20, 28, 21, 29, 22, 30, 23, 31
         store           \i,  x0,  #16
 .endr
-        br              x14
+        ret             x14
 1:
         // Special case: For the last input column (x1 == 8),
         // which would be stored as the last row in the temp buffer,
@@ -806,7 +806,7 @@
         mov             v29.16b, v21.16b
         mov             v30.16b, v22.16b
         mov             v31.16b, v23.16b
-        br              x14
+        ret             x14
 endfunc
 
 // Read a vertical 8x16 slice out of a 16x16 matrix, do a transform on it,
@@ -834,7 +834,7 @@
         load_add_store  v16.8h, v17.8h, v18.8h, v19.8h, v20.8h, v21.8h, v22.8h, v23.8h, v16.8b, v17.8b
         load_add_store  v24.8h, v25.8h, v26.8h, v27.8h, v28.8h, v29.8h, v30.8h, v31.8h, v16.8b, v17.8b
 
-        br              x14
+        ret             x14
 endfunc
 .endm
 
@@ -850,10 +850,10 @@
         mov             x15, x30
         // iadst16 requires clobbering v8-v15, but idct16 doesn't need to.
 .ifnc \txfm1\()_\txfm2,idct_idct
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
 .endif
 
         sub             sp,  sp,  #512
@@ -920,12 +920,12 @@
 
         add             sp,  sp,  #512
 .ifnc \txfm1\()_\txfm2,idct_idct
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
 .endif
-        br              x15
+        ret             x15
 endfunc
 .endm
 
@@ -960,7 +960,7 @@
 .irp i, 24, 25, 26, 27
         store           \i,  x0,  x9
 .endr
-        br              x14
+        ret             x14
 endfunc
 
 function idct16_1d_8x16_pass2_quarter_neon
@@ -978,7 +978,7 @@
         load_add_store  v16.8h, v17.8h, v18.8h, v19.8h, v20.8h, v21.8h, v22.8h, v23.8h, v16.8b, v17.8b
         load_add_store  v24.8h, v25.8h, v26.8h, v27.8h, v28.8h, v29.8h, v30.8h, v31.8h, v16.8b, v17.8b
 
-        br              x14
+        ret             x14
 endfunc
 
 function idct16_1d_8x16_pass1_half_neon
@@ -1003,7 +1003,7 @@
 .irp i, 24, 25, 26, 27, 28, 29, 30, 31
         store           \i,  x0,  x9
 .endr
-        br              x14
+        ret             x14
 endfunc
 
 function idct16_1d_8x16_pass2_half_neon
@@ -1021,7 +1021,7 @@
         load_add_store  v16.8h, v17.8h, v18.8h, v19.8h, v20.8h, v21.8h, v22.8h, v23.8h, v16.8b, v17.8b
         load_add_store  v24.8h, v25.8h, v26.8h, v27.8h, v28.8h, v29.8h, v30.8h, v31.8h, v16.8b, v17.8b
 
-        br              x14
+        ret             x14
 endfunc
 
 .macro idct16_partial size
@@ -1038,7 +1038,7 @@
 .endr
 
         add             sp,  sp,  #512
-        br              x15
+        ret             x15
 endfunc
 .endm
 
@@ -1349,7 +1349,7 @@
         store_rev       v25.8h, v17.8h
         store_rev       v24.8h, v16.8h
 .purgem store_rev
-        br              x14
+        ret             x14
 endfunc
 
 // This is mostly the same as 8x32_pass1, but without the transpose,
@@ -1466,7 +1466,7 @@
         load_acc_store  v24.8h, v25.8h, v26.8h, v27.8h, 1
         load_acc_store  v28.8h, v29.8h, v30.8h, v31.8h, 1
 .purgem load_acc_store
-        br              x14
+        ret             x14
 endfunc
 .endm
 
@@ -1486,8 +1486,8 @@
 
         mov             x15, x30
 
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x20]!
+        stp             d10, d11, [sp, #0x10]
 
         sub             sp,  sp,  #2048
 
@@ -1544,10 +1544,10 @@
 
         add             sp,  sp,  #2048
 
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d8,  d9,  [sp], #0x20
 
-        br              x15
+        ret             x15
 endfunc
 
 .macro idct32_partial size
@@ -1569,10 +1569,10 @@
 
         add             sp,  sp,  #2048
 
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d8,  d9,  [sp], #0x20
 
-        br              x15
+        ret             x15
 endfunc
 .endm
 
diff -Naur a/media/ffvpx/libavcodec/aarch64/vp9lpf_16bpp_neon.S b/media/ffvpx/libavcodec/aarch64/vp9lpf_16bpp_neon.S
--- a/media/ffvpx/libavcodec/aarch64/vp9lpf_16bpp_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/vp9lpf_16bpp_neon.S	2023-04-06 12:50:06.970471013 +0200
@@ -22,18 +22,6 @@
 #include "neon.S"
 
 
-.macro transpose_4x8H r0, r1, r2, r3, t4, t5, t6, t7
-        trn1            \t4\().8h,  \r0\().8h,  \r1\().8h
-        trn2            \t5\().8h,  \r0\().8h,  \r1\().8h
-        trn1            \t6\().8h,  \r2\().8h,  \r3\().8h
-        trn2            \t7\().8h,  \r2\().8h,  \r3\().8h
-
-        trn1            \r0\().4s,  \t4\().4s,  \t6\().4s
-        trn2            \r2\().4s,  \t4\().4s,  \t6\().4s
-        trn1            \r1\().4s,  \t5\().4s,  \t7\().4s
-        trn2            \r3\().4s,  \t5\().4s,  \t7\().4s
-.endm
-
 // The input to and output from this macro is in the registers v16-v31,
 // and v0-v7 are used as scratch registers.
 // p7 = v16 .. p3 = v20, p0 = v23, q0 = v24, q3 = v27, q7 = v31
@@ -69,7 +57,7 @@
         mov             x12, v4.d[1]
         adds            x11, x11, x12
         b.ne            1f
-        br              x10
+        ret             x10
 1:
 
 .if \wd >= 8
@@ -205,7 +193,7 @@
         b.eq            6f
 .else
         b.ne            1f
-        br              x13
+        ret             x13
 1:
 .endif
 
@@ -264,7 +252,7 @@
         b.ne            1f
         // If no pixels needed flat8in nor flat8out, jump to a
         // writeout of the inner 4 pixels
-        br              x14
+        ret             x14
 1:
 
         mov             x11, v7.d[0]
@@ -272,7 +260,7 @@
         adds            x11, x11, x12
         b.ne            1f
         // If no pixels need flat8out, jump to a writeout of the inner 6 pixels
-        br              x15
+        ret             x15
 
 1:
         // flat8out
@@ -429,10 +417,10 @@
 function ff_\func\()_\bpp\()_neon, export=1
 .if \push
         mov             x16, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
 .endif
         lsl             w2,  w2,  #\bpp - 8
         lsl             w3,  w3,  #\bpp - 8
@@ -442,11 +430,11 @@
         mov             x7,  #((1 << \bpp) - 1)
 .if \push
         bl              \func\()_16_neon
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x16
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x16
 .else
         b               \func\()_16_neon
 .endif
@@ -462,10 +450,10 @@
 function ff_\func\()_\suffix\()_\bpp\()_neon, export=1
         mov             x16, x30
 .if \push
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
 .endif
         lsl             w2,  w2,  #\bpp - 8
         lsl             w3,  w3,  #\bpp - 8
@@ -481,12 +469,12 @@
 .endif
         bl              \func\()_\int_suffix\()_16_neon
 .if \push
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], 0x40
 .endif
-        br              x16
+        ret             x16
 endfunc
 .endm
 
@@ -520,7 +508,7 @@
         lsl             w3,  w14, #\bpp - 8
         lsl             w4,  w15, #\bpp - 8
         bl              vp9_loop_filter_\dir\()_\wd2\()_8_16_neon
-        br              x16
+        ret             x16
 endfunc
 .endm
 
@@ -553,7 +541,7 @@
         st1             {v25.8h}, [x0], x1
         sub             x0,  x0,  x1, lsl #1
 
-        br              x10
+        ret             x10
 endfunc
 
 bpp_frontends vp9_loop_filter_v_4_8
@@ -601,7 +589,7 @@
         sub             x0,  x0,  x1, lsl #3
         add             x0,  x0,  #4
 
-        br              x10
+        ret             x10
 endfunc
 
 bpp_frontends vp9_loop_filter_h_4_8
@@ -632,7 +620,7 @@
         sub             x0,  x0,  x1, lsl #1
         sub             x0,  x0,  x1
 
-        br              x10
+        ret             x10
 6:
         sub             x9,  x0,  x1, lsl #1
         st1             {v22.8h}, [x9], x1
@@ -640,7 +628,7 @@
         st1             {v23.8h}, [x9], x1
         st1             {v25.8h}, [x0], x1
         sub             x0,  x0,  x1, lsl #1
-        br              x10
+        ret             x10
 endfunc
 
 bpp_frontends vp9_loop_filter_v_8_8
@@ -683,7 +671,7 @@
         sub             x0,  x0,  x1, lsl #3
         add             x0,  x0,  #8
 
-        br              x10
+        ret             x10
 6:
         // If we didn't need to do the flat8in part, we use the same writeback
         // as in loop_filter_h_4_8.
@@ -700,7 +688,7 @@
         st1             {v25.d}[1], [x0], x1
         sub             x0,  x0,  x1, lsl #3
         add             x0,  x0,  #4
-        br              x10
+        ret             x10
 endfunc
 
 bpp_frontends vp9_loop_filter_h_8_8
@@ -755,7 +743,7 @@
         sub             x0,  x0,  x1, lsl #3
         add             x0,  x0,  x1
 
-        br              x10
+        ret             x10
 8:
         add             x9,  x9,  x1, lsl #2
         // If we didn't do the flat8out part, the output is left in the
@@ -768,7 +756,7 @@
         st1             {v26.8h}, [x0], x1
         sub             x0,  x0,  x1, lsl #1
         sub             x0,  x0,  x1
-        br              x10
+        ret             x10
 7:
         sub             x9,  x0,  x1, lsl #1
         st1             {v22.8h}, [x9], x1
@@ -776,7 +764,7 @@
         st1             {v23.8h}, [x9], x1
         st1             {v25.8h}, [x0], x1
         sub             x0,  x0,  x1, lsl #1
-        br              x10
+        ret             x10
 endfunc
 
 bpp_frontends vp9_loop_filter_v_16_8, push=1
@@ -833,7 +821,7 @@
         st1             {v31.8h}, [x0], x1
         sub             x0,  x0,  x1, lsl #3
 
-        br              x10
+        ret             x10
 8:
         // The same writeback as in loop_filter_h_8_8
         sub             x9,  x0,  #8
@@ -850,7 +838,7 @@
         st1             {v27.8h}, [x0], x1
         sub             x0,  x0,  x1, lsl #3
         add             x0,  x0,  #8
-        br              x10
+        ret             x10
 7:
         // The same writeback as in loop_filter_h_4_8
         sub             x9,  x0,  #4
@@ -866,7 +854,7 @@
         st1             {v25.d}[1], [x0], x1
         sub             x0,  x0,  x1, lsl #3
         add             x0,  x0,  #4
-        br              x10
+        ret             x10
 endfunc
 
 bpp_frontends vp9_loop_filter_h_16_8, push=1
diff -Naur a/media/ffvpx/libavcodec/aarch64/vp9lpf_neon.S b/media/ffvpx/libavcodec/aarch64/vp9lpf_neon.S
--- a/media/ffvpx/libavcodec/aarch64/vp9lpf_neon.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/aarch64/vp9lpf_neon.S	2023-04-06 12:50:06.970471013 +0200
@@ -399,7 +399,7 @@
 .endif
         // If no pixels needed flat8in nor flat8out, jump to a
         // writeout of the inner 4 pixels
-        br              x14
+        ret             x14
 1:
 
         mov             x5,  v7.d[0]
@@ -411,7 +411,7 @@
         cbnz            x5,  1f
 .endif
         // If no pixels need flat8out, jump to a writeout of the inner 6 pixels
-        br              x15
+        ret             x15
 
 1:
         // flat8out
@@ -532,54 +532,54 @@
         loop_filter     4,  .8b,  0,    v16, v17, v18, v19, v28, v29, v30, v31
         ret
 9:
-        br              x10
+        ret             x10
 endfunc
 
 function vp9_loop_filter_4_16b_mix_44
         loop_filter     4,  .16b, 44,   v16, v17, v18, v19, v28, v29, v30, v31
         ret
 9:
-        br              x10
+        ret             x10
 endfunc
 
 function vp9_loop_filter_8
         loop_filter     8,  .8b,  0,    v16, v17, v18, v19, v28, v29, v30, v31
         ret
 6:
-        br              x13
+        ret             x13
 9:
-        br              x10
+        ret             x10
 endfunc
 
 function vp9_loop_filter_8_16b_mix
         loop_filter     8,  .16b, 88,   v16, v17, v18, v19, v28, v29, v30, v31
         ret
 6:
-        br              x13
+        ret             x13
 9:
-        br              x10
+        ret             x10
 endfunc
 
 function vp9_loop_filter_16
         loop_filter     16, .8b,  0,    v8,  v9,  v10, v11, v12, v13, v14, v15
         ret
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x10
 endfunc
 
 function vp9_loop_filter_16_16b
         loop_filter     16, .16b, 0,    v8,  v9,  v10, v11, v12, v13, v14, v15
         ret
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x10
 endfunc
 
 .macro loop_filter_4
@@ -648,7 +648,7 @@
         st1             {v23.8b}, [x9], x1
         st1             {v25.8b}, [x0], x1
 
-        br              x10
+        ret             x10
 endfunc
 
 function ff_vp9_loop_filter_v_44_16_neon, export=1
@@ -672,7 +672,7 @@
         st1             {v23.16b}, [x9], x1
         st1             {v25.16b}, [x0], x1
 
-        br              x10
+        ret             x10
 endfunc
 
 function ff_vp9_loop_filter_h_4_8_neon, export=1
@@ -714,7 +714,7 @@
         st1             {v25.s}[0], [x9], x1
         st1             {v25.s}[1], [x0], x1
 
-        br              x10
+        ret             x10
 endfunc
 
 function ff_vp9_loop_filter_h_44_16_neon, export=1
@@ -766,7 +766,7 @@
         st1             {v25.s}[1], [x9], x1
         st1             {v25.s}[3], [x0], x1
 
-        br              x10
+        ret             x10
 endfunc
 
 function ff_vp9_loop_filter_v_8_8_neon, export=1
@@ -793,14 +793,14 @@
         st1             {v23.8b}, [x9], x1
         st1             {v26.8b}, [x0], x1
 
-        br              x10
+        ret             x10
 6:
         sub             x9,  x0,  x1, lsl #1
         st1             {v22.8b}, [x9], x1
         st1             {v24.8b}, [x0], x1
         st1             {v23.8b}, [x9], x1
         st1             {v25.8b}, [x0], x1
-        br              x10
+        ret             x10
 endfunc
 
 .macro mix_v_16 mix
@@ -828,14 +828,14 @@
         st1             {v23.16b}, [x9], x1
         st1             {v26.16b}, [x0], x1
 
-        br              x10
+        ret             x10
 6:
         sub             x9,  x0,  x1, lsl #1
         st1             {v22.16b}, [x9], x1
         st1             {v24.16b}, [x0], x1
         st1             {v23.16b}, [x9], x1
         st1             {v25.16b}, [x0], x1
-        br              x10
+        ret             x10
 endfunc
 .endm
 
@@ -876,7 +876,7 @@
         st1             {v23.8b}, [x9], x1
         st1             {v27.8b}, [x0], x1
 
-        br              x10
+        ret             x10
 6:
         // If we didn't need to do the flat8in part, we use the same writeback
         // as in loop_filter_h_4_8.
@@ -891,7 +891,7 @@
         st1             {v24.s}[1], [x0], x1
         st1             {v25.s}[0], [x9], x1
         st1             {v25.s}[1], [x0], x1
-        br              x10
+        ret             x10
 endfunc
 
 .macro mix_h_16 mix
@@ -942,7 +942,7 @@
         st1             {v27.8b},   [x9], x1
         st1             {v27.d}[1], [x0], x1
 
-        br              x10
+        ret             x10
 6:
         add             x9,  x9,  #2
         add             x0,  x0,  #2
@@ -963,7 +963,7 @@
         st1             {v24.s}[3], [x0], x1
         st1             {v25.s}[1], [x9], x1
         st1             {v25.s}[3], [x0], x1
-        br              x10
+        ret             x10
 endfunc
 .endm
 
@@ -973,10 +973,10 @@
 
 function ff_vp9_loop_filter_v_16_8_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  x1, lsl #3
         ld1             {v16.8b}, [x9], x1 // p7
         ld1             {v24.8b}, [x0], x1 // q0
@@ -1018,11 +1018,11 @@
         st1             {v9.8b},  [x9], x1
         st1             {v17.8b}, [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x10
 8:
         add             x9,  x9,  x1, lsl #2
         // If we didn't do the flat8out part, the output is left in the
@@ -1045,10 +1045,10 @@
 
 function ff_vp9_loop_filter_v_16_16_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  x1, lsl #3
         ld1             {v16.16b}, [x9], x1 // p7
         ld1             {v24.16b}, [x0], x1 // q0
@@ -1087,11 +1087,11 @@
         st1             {v9.16b},  [x9], x1
         st1             {v17.16b}, [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x10
 8:
         add             x9,  x9,  x1, lsl #2
         st1             {v21.16b}, [x9], x1
@@ -1112,10 +1112,10 @@
 
 function ff_vp9_loop_filter_h_16_8_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  #8
         ld1             {v16.8b}, [x9], x1
         ld1             {v24.8b}, [x0], x1
@@ -1164,11 +1164,11 @@
         st1             {v9.8b},  [x9], x1
         st1             {v31.8b}, [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x10
 8:
         // The same writeback as in loop_filter_h_8_8
         sub             x9,  x0,  #4
@@ -1202,10 +1202,10 @@
 
 function ff_vp9_loop_filter_h_16_16_neon, export=1
         mov             x10, x30
-        stp             d14, d15, [sp, #-0x10]!
-        stp             d12, d13, [sp, #-0x10]!
-        stp             d10, d11, [sp, #-0x10]!
-        stp             d8,  d9,  [sp, #-0x10]!
+        stp             d8,  d9,  [sp, #-0x40]!
+        stp             d14, d15, [sp, #0x30]
+        stp             d12, d13, [sp, #0x20]
+        stp             d10, d11, [sp, #0x10]
         sub             x9,  x0,  #8
         ld1             {v16.8b},   [x9], x1
         ld1             {v24.8b},   [x0], x1
@@ -1283,11 +1283,11 @@
         st1             {v9.d}[1],  [x9], x1
         st1             {v31.d}[1], [x0], x1
 9:
-        ldp             d8,  d9,  [sp], 0x10
-        ldp             d10, d11, [sp], 0x10
-        ldp             d12, d13, [sp], 0x10
-        ldp             d14, d15, [sp], 0x10
-        br              x10
+        ldp             d10, d11, [sp, #0x10]
+        ldp             d12, d13, [sp, #0x20]
+        ldp             d14, d15, [sp, #0x30]
+        ldp             d8,  d9,  [sp], #0x40
+        ret             x10
 8:
         sub             x9,  x0,  #4
         add             x0,  x9,  x1, lsl #3
diff -Naur a/media/ffvpx/libavcodec/allcodecs.c b/media/ffvpx/libavcodec/allcodecs.c
--- a/media/ffvpx/libavcodec/allcodecs.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/allcodecs.c	2023-04-06 12:50:24.490176462 +0200
@@ -24,821 +24,877 @@
  * Provide registration of all codecs, parsers and bitstream filters for libavcodec.
  */
 
+#include <stdint.h>
+#include <string.h>
+
 #include "config.h"
+#include "config_components.h"
 #include "libavutil/thread.h"
-#include "avcodec.h"
-#include "version.h"
-
-extern AVCodec ff_a64multi_encoder;
-extern AVCodec ff_a64multi5_encoder;
-extern AVCodec ff_aasc_decoder;
-extern AVCodec ff_aic_decoder;
-extern AVCodec ff_alias_pix_encoder;
-extern AVCodec ff_alias_pix_decoder;
-extern AVCodec ff_agm_decoder;
-extern AVCodec ff_amv_encoder;
-extern AVCodec ff_amv_decoder;
-extern AVCodec ff_anm_decoder;
-extern AVCodec ff_ansi_decoder;
-extern AVCodec ff_apng_encoder;
-extern AVCodec ff_apng_decoder;
-extern AVCodec ff_arbc_decoder;
-extern AVCodec ff_argo_decoder;
-extern AVCodec ff_asv1_encoder;
-extern AVCodec ff_asv1_decoder;
-extern AVCodec ff_asv2_encoder;
-extern AVCodec ff_asv2_decoder;
-extern AVCodec ff_aura_decoder;
-extern AVCodec ff_aura2_decoder;
-extern AVCodec ff_avrp_encoder;
-extern AVCodec ff_avrp_decoder;
-extern AVCodec ff_avrn_decoder;
-extern AVCodec ff_avs_decoder;
-extern AVCodec ff_avui_encoder;
-extern AVCodec ff_avui_decoder;
-extern AVCodec ff_ayuv_encoder;
-extern AVCodec ff_ayuv_decoder;
-extern AVCodec ff_bethsoftvid_decoder;
-extern AVCodec ff_bfi_decoder;
-extern AVCodec ff_bink_decoder;
-extern AVCodec ff_bitpacked_decoder;
-extern AVCodec ff_bmp_encoder;
-extern AVCodec ff_bmp_decoder;
-extern AVCodec ff_bmv_video_decoder;
-extern AVCodec ff_brender_pix_decoder;
-extern AVCodec ff_c93_decoder;
-extern AVCodec ff_cavs_decoder;
-extern AVCodec ff_cdgraphics_decoder;
-extern AVCodec ff_cdtoons_decoder;
-extern AVCodec ff_cdxl_decoder;
-extern AVCodec ff_cfhd_encoder;
-extern AVCodec ff_cfhd_decoder;
-extern AVCodec ff_cinepak_encoder;
-extern AVCodec ff_cinepak_decoder;
-extern AVCodec ff_clearvideo_decoder;
-extern AVCodec ff_cljr_encoder;
-extern AVCodec ff_cljr_decoder;
-extern AVCodec ff_cllc_decoder;
-extern AVCodec ff_comfortnoise_encoder;
-extern AVCodec ff_comfortnoise_decoder;
-extern AVCodec ff_cpia_decoder;
-extern AVCodec ff_cri_decoder;
-extern AVCodec ff_cscd_decoder;
-extern AVCodec ff_cyuv_decoder;
-extern AVCodec ff_dds_decoder;
-extern AVCodec ff_dfa_decoder;
-extern AVCodec ff_dirac_decoder;
-extern AVCodec ff_dnxhd_encoder;
-extern AVCodec ff_dnxhd_decoder;
-extern AVCodec ff_dpx_encoder;
-extern AVCodec ff_dpx_decoder;
-extern AVCodec ff_dsicinvideo_decoder;
-extern AVCodec ff_dvaudio_decoder;
-extern AVCodec ff_dvvideo_encoder;
-extern AVCodec ff_dvvideo_decoder;
-extern AVCodec ff_dxa_decoder;
-extern AVCodec ff_dxtory_decoder;
-extern AVCodec ff_dxv_decoder;
-extern AVCodec ff_eacmv_decoder;
-extern AVCodec ff_eamad_decoder;
-extern AVCodec ff_eatgq_decoder;
-extern AVCodec ff_eatgv_decoder;
-extern AVCodec ff_eatqi_decoder;
-extern AVCodec ff_eightbps_decoder;
-extern AVCodec ff_eightsvx_exp_decoder;
-extern AVCodec ff_eightsvx_fib_decoder;
-extern AVCodec ff_escape124_decoder;
-extern AVCodec ff_escape130_decoder;
-extern AVCodec ff_exr_encoder;
-extern AVCodec ff_exr_decoder;
-extern AVCodec ff_ffv1_encoder;
-extern AVCodec ff_ffv1_decoder;
-extern AVCodec ff_ffvhuff_encoder;
-extern AVCodec ff_ffvhuff_decoder;
-extern AVCodec ff_fic_decoder;
-extern AVCodec ff_fits_encoder;
-extern AVCodec ff_fits_decoder;
-extern AVCodec ff_flashsv_encoder;
-extern AVCodec ff_flashsv_decoder;
-extern AVCodec ff_flashsv2_encoder;
-extern AVCodec ff_flashsv2_decoder;
-extern AVCodec ff_flic_decoder;
-extern AVCodec ff_flv_encoder;
-extern AVCodec ff_flv_decoder;
-extern AVCodec ff_fmvc_decoder;
-extern AVCodec ff_fourxm_decoder;
-extern AVCodec ff_fraps_decoder;
-extern AVCodec ff_frwu_decoder;
-extern AVCodec ff_g2m_decoder;
-extern AVCodec ff_gdv_decoder;
-extern AVCodec ff_gif_encoder;
-extern AVCodec ff_gif_decoder;
-extern AVCodec ff_h261_encoder;
-extern AVCodec ff_h261_decoder;
-extern AVCodec ff_h263_encoder;
-extern AVCodec ff_h263_decoder;
-extern AVCodec ff_h263i_decoder;
-extern AVCodec ff_h263p_encoder;
-extern AVCodec ff_h263p_decoder;
-extern AVCodec ff_h263_v4l2m2m_decoder;
-extern AVCodec ff_h264_decoder;
-extern AVCodec ff_h264_crystalhd_decoder;
-extern AVCodec ff_h264_v4l2m2m_decoder;
-extern AVCodec ff_h264_mediacodec_decoder;
-extern AVCodec ff_h264_mmal_decoder;
-extern AVCodec ff_h264_qsv_decoder;
-extern AVCodec ff_h264_rkmpp_decoder;
-extern AVCodec ff_hap_encoder;
-extern AVCodec ff_hap_decoder;
-extern AVCodec ff_hevc_decoder;
-extern AVCodec ff_hevc_qsv_decoder;
-extern AVCodec ff_hevc_rkmpp_decoder;
-extern AVCodec ff_hevc_v4l2m2m_decoder;
-extern AVCodec ff_hnm4_video_decoder;
-extern AVCodec ff_hq_hqa_decoder;
-extern AVCodec ff_hqx_decoder;
-extern AVCodec ff_huffyuv_encoder;
-extern AVCodec ff_huffyuv_decoder;
-extern AVCodec ff_hymt_decoder;
-extern AVCodec ff_idcin_decoder;
-extern AVCodec ff_iff_ilbm_decoder;
-extern AVCodec ff_imm4_decoder;
-extern AVCodec ff_imm5_decoder;
-extern AVCodec ff_indeo2_decoder;
-extern AVCodec ff_indeo3_decoder;
-extern AVCodec ff_indeo4_decoder;
-extern AVCodec ff_indeo5_decoder;
-extern AVCodec ff_interplay_video_decoder;
-extern AVCodec ff_ipu_decoder;
-extern AVCodec ff_jpeg2000_encoder;
-extern AVCodec ff_jpeg2000_decoder;
-extern AVCodec ff_jpegls_encoder;
-extern AVCodec ff_jpegls_decoder;
-extern AVCodec ff_jv_decoder;
-extern AVCodec ff_kgv1_decoder;
-extern AVCodec ff_kmvc_decoder;
-extern AVCodec ff_lagarith_decoder;
-extern AVCodec ff_ljpeg_encoder;
-extern AVCodec ff_loco_decoder;
-extern AVCodec ff_lscr_decoder;
-extern AVCodec ff_m101_decoder;
-extern AVCodec ff_magicyuv_encoder;
-extern AVCodec ff_magicyuv_decoder;
-extern AVCodec ff_mdec_decoder;
-extern AVCodec ff_mimic_decoder;
-extern AVCodec ff_mjpeg_encoder;
-extern AVCodec ff_mjpeg_decoder;
-extern AVCodec ff_mjpegb_decoder;
-extern AVCodec ff_mmvideo_decoder;
-extern AVCodec ff_mobiclip_decoder;
-extern AVCodec ff_motionpixels_decoder;
-extern AVCodec ff_mpeg1video_encoder;
-extern AVCodec ff_mpeg1video_decoder;
-extern AVCodec ff_mpeg2video_encoder;
-extern AVCodec ff_mpeg2video_decoder;
-extern AVCodec ff_mpeg4_encoder;
-extern AVCodec ff_mpeg4_decoder;
-extern AVCodec ff_mpeg4_crystalhd_decoder;
-extern AVCodec ff_mpeg4_v4l2m2m_decoder;
-extern AVCodec ff_mpeg4_mmal_decoder;
-extern AVCodec ff_mpegvideo_decoder;
-extern AVCodec ff_mpeg1_v4l2m2m_decoder;
-extern AVCodec ff_mpeg2_mmal_decoder;
-extern AVCodec ff_mpeg2_crystalhd_decoder;
-extern AVCodec ff_mpeg2_v4l2m2m_decoder;
-extern AVCodec ff_mpeg2_qsv_decoder;
-extern AVCodec ff_mpeg2_mediacodec_decoder;
-extern AVCodec ff_msa1_decoder;
-extern AVCodec ff_mscc_decoder;
-extern AVCodec ff_msmpeg4v1_decoder;
-extern AVCodec ff_msmpeg4v2_encoder;
-extern AVCodec ff_msmpeg4v2_decoder;
-extern AVCodec ff_msmpeg4v3_encoder;
-extern AVCodec ff_msmpeg4v3_decoder;
-extern AVCodec ff_msmpeg4_crystalhd_decoder;
-extern AVCodec ff_msp2_decoder;
-extern AVCodec ff_msrle_decoder;
-extern AVCodec ff_mss1_decoder;
-extern AVCodec ff_mss2_decoder;
-extern AVCodec ff_msvideo1_encoder;
-extern AVCodec ff_msvideo1_decoder;
-extern AVCodec ff_mszh_decoder;
-extern AVCodec ff_mts2_decoder;
-extern AVCodec ff_mv30_decoder;
-extern AVCodec ff_mvc1_decoder;
-extern AVCodec ff_mvc2_decoder;
-extern AVCodec ff_mvdv_decoder;
-extern AVCodec ff_mvha_decoder;
-extern AVCodec ff_mwsc_decoder;
-extern AVCodec ff_mxpeg_decoder;
-extern AVCodec ff_notchlc_decoder;
-extern AVCodec ff_nuv_decoder;
-extern AVCodec ff_paf_video_decoder;
-extern AVCodec ff_pam_encoder;
-extern AVCodec ff_pam_decoder;
-extern AVCodec ff_pbm_encoder;
-extern AVCodec ff_pbm_decoder;
-extern AVCodec ff_pcx_encoder;
-extern AVCodec ff_pcx_decoder;
-extern AVCodec ff_pfm_encoder;
-extern AVCodec ff_pfm_decoder;
-extern AVCodec ff_pgm_encoder;
-extern AVCodec ff_pgm_decoder;
-extern AVCodec ff_pgmyuv_encoder;
-extern AVCodec ff_pgmyuv_decoder;
-extern AVCodec ff_pgx_decoder;
-extern AVCodec ff_photocd_decoder;
-extern AVCodec ff_pictor_decoder;
-extern AVCodec ff_pixlet_decoder;
-extern AVCodec ff_png_encoder;
-extern AVCodec ff_png_decoder;
-extern AVCodec ff_ppm_encoder;
-extern AVCodec ff_ppm_decoder;
-extern AVCodec ff_prores_encoder;
-extern AVCodec ff_prores_decoder;
-extern AVCodec ff_prores_aw_encoder;
-extern AVCodec ff_prores_ks_encoder;
-extern AVCodec ff_prosumer_decoder;
-extern AVCodec ff_psd_decoder;
-extern AVCodec ff_ptx_decoder;
-extern AVCodec ff_qdraw_decoder;
-extern AVCodec ff_qpeg_decoder;
-extern AVCodec ff_qtrle_encoder;
-extern AVCodec ff_qtrle_decoder;
-extern AVCodec ff_r10k_encoder;
-extern AVCodec ff_r10k_decoder;
-extern AVCodec ff_r210_encoder;
-extern AVCodec ff_r210_decoder;
-extern AVCodec ff_rasc_decoder;
-extern AVCodec ff_rawvideo_encoder;
-extern AVCodec ff_rawvideo_decoder;
-extern AVCodec ff_rl2_decoder;
-extern AVCodec ff_roq_encoder;
-extern AVCodec ff_roq_decoder;
-extern AVCodec ff_rpza_encoder;
-extern AVCodec ff_rpza_decoder;
-extern AVCodec ff_rscc_decoder;
-extern AVCodec ff_rv10_encoder;
-extern AVCodec ff_rv10_decoder;
-extern AVCodec ff_rv20_encoder;
-extern AVCodec ff_rv20_decoder;
-extern AVCodec ff_rv30_decoder;
-extern AVCodec ff_rv40_decoder;
-extern AVCodec ff_s302m_encoder;
-extern AVCodec ff_s302m_decoder;
-extern AVCodec ff_sanm_decoder;
-extern AVCodec ff_scpr_decoder;
-extern AVCodec ff_screenpresso_decoder;
-extern AVCodec ff_sga_decoder;
-extern AVCodec ff_sgi_encoder;
-extern AVCodec ff_sgi_decoder;
-extern AVCodec ff_sgirle_decoder;
-extern AVCodec ff_sheervideo_decoder;
-extern AVCodec ff_simbiosis_imx_decoder;
-extern AVCodec ff_smacker_decoder;
-extern AVCodec ff_smc_decoder;
-extern AVCodec ff_smvjpeg_decoder;
-extern AVCodec ff_snow_encoder;
-extern AVCodec ff_snow_decoder;
-extern AVCodec ff_sp5x_decoder;
-extern AVCodec ff_speedhq_decoder;
-extern AVCodec ff_speedhq_encoder;
-extern AVCodec ff_srgc_decoder;
-extern AVCodec ff_sunrast_encoder;
-extern AVCodec ff_sunrast_decoder;
-extern AVCodec ff_svq1_encoder;
-extern AVCodec ff_svq1_decoder;
-extern AVCodec ff_svq3_decoder;
-extern AVCodec ff_targa_encoder;
-extern AVCodec ff_targa_decoder;
-extern AVCodec ff_targa_y216_decoder;
-extern AVCodec ff_tdsc_decoder;
-extern AVCodec ff_theora_decoder;
-extern AVCodec ff_thp_decoder;
-extern AVCodec ff_tiertexseqvideo_decoder;
-extern AVCodec ff_tiff_encoder;
-extern AVCodec ff_tiff_decoder;
-extern AVCodec ff_tmv_decoder;
-extern AVCodec ff_truemotion1_decoder;
-extern AVCodec ff_truemotion2_decoder;
-extern AVCodec ff_truemotion2rt_decoder;
-extern AVCodec ff_tscc_decoder;
-extern AVCodec ff_tscc2_decoder;
-extern AVCodec ff_txd_decoder;
-extern AVCodec ff_ulti_decoder;
-extern AVCodec ff_utvideo_encoder;
-extern AVCodec ff_utvideo_decoder;
-extern AVCodec ff_v210_encoder;
-extern AVCodec ff_v210_decoder;
-extern AVCodec ff_v210x_decoder;
-extern AVCodec ff_v308_encoder;
-extern AVCodec ff_v308_decoder;
-extern AVCodec ff_v408_encoder;
-extern AVCodec ff_v408_decoder;
-extern AVCodec ff_v410_encoder;
-extern AVCodec ff_v410_decoder;
-extern AVCodec ff_vb_decoder;
-extern AVCodec ff_vble_decoder;
-extern AVCodec ff_vc1_decoder;
-extern AVCodec ff_vc1_crystalhd_decoder;
-extern AVCodec ff_vc1image_decoder;
-extern AVCodec ff_vc1_mmal_decoder;
-extern AVCodec ff_vc1_qsv_decoder;
-extern AVCodec ff_vc1_v4l2m2m_decoder;
-extern AVCodec ff_vc2_encoder;
-extern AVCodec ff_vcr1_decoder;
-extern AVCodec ff_vmdvideo_decoder;
-extern AVCodec ff_vmnc_decoder;
-extern AVCodec ff_vp3_decoder;
-extern AVCodec ff_vp4_decoder;
-extern AVCodec ff_vp5_decoder;
-extern AVCodec ff_vp6_decoder;
-extern AVCodec ff_vp6a_decoder;
-extern AVCodec ff_vp6f_decoder;
-extern AVCodec ff_vp7_decoder;
-extern AVCodec ff_vp8_decoder;
-extern AVCodec ff_vp8_rkmpp_decoder;
-extern AVCodec ff_vp8_v4l2m2m_decoder;
-extern AVCodec ff_vp9_decoder;
-extern AVCodec ff_vp9_rkmpp_decoder;
-extern AVCodec ff_vp9_v4l2m2m_decoder;
-extern AVCodec ff_vqa_decoder;
-extern AVCodec ff_webp_decoder;
-extern AVCodec ff_wcmv_decoder;
-extern AVCodec ff_wrapped_avframe_encoder;
-extern AVCodec ff_wrapped_avframe_decoder;
-extern AVCodec ff_wmv1_encoder;
-extern AVCodec ff_wmv1_decoder;
-extern AVCodec ff_wmv2_encoder;
-extern AVCodec ff_wmv2_decoder;
-extern AVCodec ff_wmv3_decoder;
-extern AVCodec ff_wmv3_crystalhd_decoder;
-extern AVCodec ff_wmv3image_decoder;
-extern AVCodec ff_wnv1_decoder;
-extern AVCodec ff_xan_wc3_decoder;
-extern AVCodec ff_xan_wc4_decoder;
-extern AVCodec ff_xbm_encoder;
-extern AVCodec ff_xbm_decoder;
-extern AVCodec ff_xface_encoder;
-extern AVCodec ff_xface_decoder;
-extern AVCodec ff_xl_decoder;
-extern AVCodec ff_xpm_decoder;
-extern AVCodec ff_xwd_encoder;
-extern AVCodec ff_xwd_decoder;
-extern AVCodec ff_y41p_encoder;
-extern AVCodec ff_y41p_decoder;
-extern AVCodec ff_ylc_decoder;
-extern AVCodec ff_yop_decoder;
-extern AVCodec ff_yuv4_encoder;
-extern AVCodec ff_yuv4_decoder;
-extern AVCodec ff_zero12v_decoder;
-extern AVCodec ff_zerocodec_decoder;
-extern AVCodec ff_zlib_encoder;
-extern AVCodec ff_zlib_decoder;
-extern AVCodec ff_zmbv_encoder;
-extern AVCodec ff_zmbv_decoder;
+#include "codec.h"
+#include "codec_id.h"
+#include "codec_internal.h"
+
+extern const FFCodec ff_a64multi_encoder;
+extern const FFCodec ff_a64multi5_encoder;
+extern const FFCodec ff_aasc_decoder;
+extern const FFCodec ff_aic_decoder;
+extern const FFCodec ff_alias_pix_encoder;
+extern const FFCodec ff_alias_pix_decoder;
+extern const FFCodec ff_agm_decoder;
+extern const FFCodec ff_amv_encoder;
+extern const FFCodec ff_amv_decoder;
+extern const FFCodec ff_anm_decoder;
+extern const FFCodec ff_ansi_decoder;
+extern const FFCodec ff_apng_encoder;
+extern const FFCodec ff_apng_decoder;
+extern const FFCodec ff_arbc_decoder;
+extern const FFCodec ff_argo_decoder;
+extern const FFCodec ff_asv1_encoder;
+extern const FFCodec ff_asv1_decoder;
+extern const FFCodec ff_asv2_encoder;
+extern const FFCodec ff_asv2_decoder;
+extern const FFCodec ff_aura_decoder;
+extern const FFCodec ff_aura2_decoder;
+extern const FFCodec ff_avrp_encoder;
+extern const FFCodec ff_avrp_decoder;
+extern const FFCodec ff_avrn_decoder;
+extern const FFCodec ff_avs_decoder;
+extern const FFCodec ff_avui_encoder;
+extern const FFCodec ff_avui_decoder;
+#if FF_API_AYUV_CODECID
+extern const FFCodec ff_ayuv_encoder;
+extern const FFCodec ff_ayuv_decoder;
+#endif
+extern const FFCodec ff_bethsoftvid_decoder;
+extern const FFCodec ff_bfi_decoder;
+extern const FFCodec ff_bink_decoder;
+extern const FFCodec ff_bitpacked_decoder;
+extern const FFCodec ff_bitpacked_encoder;
+extern const FFCodec ff_bmp_encoder;
+extern const FFCodec ff_bmp_decoder;
+extern const FFCodec ff_bmv_video_decoder;
+extern const FFCodec ff_brender_pix_decoder;
+extern const FFCodec ff_c93_decoder;
+extern const FFCodec ff_cavs_decoder;
+extern const FFCodec ff_cdgraphics_decoder;
+extern const FFCodec ff_cdtoons_decoder;
+extern const FFCodec ff_cdxl_decoder;
+extern const FFCodec ff_cfhd_encoder;
+extern const FFCodec ff_cfhd_decoder;
+extern const FFCodec ff_cinepak_encoder;
+extern const FFCodec ff_cinepak_decoder;
+extern const FFCodec ff_clearvideo_decoder;
+extern const FFCodec ff_cljr_encoder;
+extern const FFCodec ff_cljr_decoder;
+extern const FFCodec ff_cllc_decoder;
+extern const FFCodec ff_comfortnoise_encoder;
+extern const FFCodec ff_comfortnoise_decoder;
+extern const FFCodec ff_cpia_decoder;
+extern const FFCodec ff_cri_decoder;
+extern const FFCodec ff_cscd_decoder;
+extern const FFCodec ff_cyuv_decoder;
+extern const FFCodec ff_dds_decoder;
+extern const FFCodec ff_dfa_decoder;
+extern const FFCodec ff_dirac_decoder;
+extern const FFCodec ff_dnxhd_encoder;
+extern const FFCodec ff_dnxhd_decoder;
+extern const FFCodec ff_dpx_encoder;
+extern const FFCodec ff_dpx_decoder;
+extern const FFCodec ff_dsicinvideo_decoder;
+extern const FFCodec ff_dvaudio_decoder;
+extern const FFCodec ff_dvvideo_encoder;
+extern const FFCodec ff_dvvideo_decoder;
+extern const FFCodec ff_dxa_decoder;
+extern const FFCodec ff_dxtory_decoder;
+extern const FFCodec ff_dxv_decoder;
+extern const FFCodec ff_eacmv_decoder;
+extern const FFCodec ff_eamad_decoder;
+extern const FFCodec ff_eatgq_decoder;
+extern const FFCodec ff_eatgv_decoder;
+extern const FFCodec ff_eatqi_decoder;
+extern const FFCodec ff_eightbps_decoder;
+extern const FFCodec ff_eightsvx_exp_decoder;
+extern const FFCodec ff_eightsvx_fib_decoder;
+extern const FFCodec ff_escape124_decoder;
+extern const FFCodec ff_escape130_decoder;
+extern const FFCodec ff_exr_encoder;
+extern const FFCodec ff_exr_decoder;
+extern const FFCodec ff_ffv1_encoder;
+extern const FFCodec ff_ffv1_decoder;
+extern const FFCodec ff_ffvhuff_encoder;
+extern const FFCodec ff_ffvhuff_decoder;
+extern const FFCodec ff_fic_decoder;
+extern const FFCodec ff_fits_encoder;
+extern const FFCodec ff_fits_decoder;
+extern const FFCodec ff_flashsv_encoder;
+extern const FFCodec ff_flashsv_decoder;
+extern const FFCodec ff_flashsv2_encoder;
+extern const FFCodec ff_flashsv2_decoder;
+extern const FFCodec ff_flic_decoder;
+extern const FFCodec ff_flv_encoder;
+extern const FFCodec ff_flv_decoder;
+extern const FFCodec ff_fmvc_decoder;
+extern const FFCodec ff_fourxm_decoder;
+extern const FFCodec ff_fraps_decoder;
+extern const FFCodec ff_frwu_decoder;
+extern const FFCodec ff_g2m_decoder;
+extern const FFCodec ff_gdv_decoder;
+extern const FFCodec ff_gem_decoder;
+extern const FFCodec ff_gif_encoder;
+extern const FFCodec ff_gif_decoder;
+extern const FFCodec ff_h261_encoder;
+extern const FFCodec ff_h261_decoder;
+extern const FFCodec ff_h263_encoder;
+extern const FFCodec ff_h263_decoder;
+extern const FFCodec ff_h263i_decoder;
+extern const FFCodec ff_h263p_encoder;
+extern const FFCodec ff_h263p_decoder;
+extern const FFCodec ff_h263_v4l2m2m_decoder;
+extern const FFCodec ff_h264_decoder;
+extern const FFCodec ff_h264_crystalhd_decoder;
+extern const FFCodec ff_h264_v4l2m2m_decoder;
+extern const FFCodec ff_h264_mediacodec_decoder;
+extern const FFCodec ff_h264_mediacodec_encoder;
+extern const FFCodec ff_h264_mmal_decoder;
+extern const FFCodec ff_h264_qsv_decoder;
+extern const FFCodec ff_h264_rkmpp_decoder;
+extern const FFCodec ff_hap_encoder;
+extern const FFCodec ff_hap_decoder;
+extern const FFCodec ff_hevc_decoder;
+extern const FFCodec ff_hevc_qsv_decoder;
+extern const FFCodec ff_hevc_rkmpp_decoder;
+extern const FFCodec ff_hevc_v4l2m2m_decoder;
+extern const FFCodec ff_hnm4_video_decoder;
+extern const FFCodec ff_hq_hqa_decoder;
+extern const FFCodec ff_hqx_decoder;
+extern const FFCodec ff_huffyuv_encoder;
+extern const FFCodec ff_huffyuv_decoder;
+extern const FFCodec ff_hymt_decoder;
+extern const FFCodec ff_idcin_decoder;
+extern const FFCodec ff_iff_ilbm_decoder;
+extern const FFCodec ff_imm4_decoder;
+extern const FFCodec ff_imm5_decoder;
+extern const FFCodec ff_indeo2_decoder;
+extern const FFCodec ff_indeo3_decoder;
+extern const FFCodec ff_indeo4_decoder;
+extern const FFCodec ff_indeo5_decoder;
+extern const FFCodec ff_interplay_video_decoder;
+extern const FFCodec ff_ipu_decoder;
+extern const FFCodec ff_jpeg2000_encoder;
+extern const FFCodec ff_jpeg2000_decoder;
+extern const FFCodec ff_jpegls_encoder;
+extern const FFCodec ff_jpegls_decoder;
+extern const FFCodec ff_jv_decoder;
+extern const FFCodec ff_kgv1_decoder;
+extern const FFCodec ff_kmvc_decoder;
+extern const FFCodec ff_lagarith_decoder;
+extern const FFCodec ff_ljpeg_encoder;
+extern const FFCodec ff_loco_decoder;
+extern const FFCodec ff_lscr_decoder;
+extern const FFCodec ff_m101_decoder;
+extern const FFCodec ff_magicyuv_encoder;
+extern const FFCodec ff_magicyuv_decoder;
+extern const FFCodec ff_mdec_decoder;
+extern const FFCodec ff_media100_decoder;
+extern const FFCodec ff_mimic_decoder;
+extern const FFCodec ff_mjpeg_encoder;
+extern const FFCodec ff_mjpeg_decoder;
+extern const FFCodec ff_mjpegb_decoder;
+extern const FFCodec ff_mmvideo_decoder;
+extern const FFCodec ff_mobiclip_decoder;
+extern const FFCodec ff_motionpixels_decoder;
+extern const FFCodec ff_mpeg1video_encoder;
+extern const FFCodec ff_mpeg1video_decoder;
+extern const FFCodec ff_mpeg2video_encoder;
+extern const FFCodec ff_mpeg2video_decoder;
+extern const FFCodec ff_mpeg4_encoder;
+extern const FFCodec ff_mpeg4_decoder;
+extern const FFCodec ff_mpeg4_crystalhd_decoder;
+extern const FFCodec ff_mpeg4_v4l2m2m_decoder;
+extern const FFCodec ff_mpeg4_mmal_decoder;
+extern const FFCodec ff_mpegvideo_decoder;
+extern const FFCodec ff_mpeg1_v4l2m2m_decoder;
+extern const FFCodec ff_mpeg2_mmal_decoder;
+extern const FFCodec ff_mpeg2_crystalhd_decoder;
+extern const FFCodec ff_mpeg2_v4l2m2m_decoder;
+extern const FFCodec ff_mpeg2_qsv_decoder;
+extern const FFCodec ff_mpeg2_mediacodec_decoder;
+extern const FFCodec ff_msa1_decoder;
+extern const FFCodec ff_mscc_decoder;
+extern const FFCodec ff_msmpeg4v1_decoder;
+extern const FFCodec ff_msmpeg4v2_encoder;
+extern const FFCodec ff_msmpeg4v2_decoder;
+extern const FFCodec ff_msmpeg4v3_encoder;
+extern const FFCodec ff_msmpeg4v3_decoder;
+extern const FFCodec ff_msmpeg4_crystalhd_decoder;
+extern const FFCodec ff_msp2_decoder;
+extern const FFCodec ff_msrle_decoder;
+extern const FFCodec ff_mss1_decoder;
+extern const FFCodec ff_mss2_decoder;
+extern const FFCodec ff_msvideo1_encoder;
+extern const FFCodec ff_msvideo1_decoder;
+extern const FFCodec ff_mszh_decoder;
+extern const FFCodec ff_mts2_decoder;
+extern const FFCodec ff_mv30_decoder;
+extern const FFCodec ff_mvc1_decoder;
+extern const FFCodec ff_mvc2_decoder;
+extern const FFCodec ff_mvdv_decoder;
+extern const FFCodec ff_mvha_decoder;
+extern const FFCodec ff_mwsc_decoder;
+extern const FFCodec ff_mxpeg_decoder;
+extern const FFCodec ff_notchlc_decoder;
+extern const FFCodec ff_nuv_decoder;
+extern const FFCodec ff_paf_video_decoder;
+extern const FFCodec ff_pam_encoder;
+extern const FFCodec ff_pam_decoder;
+extern const FFCodec ff_pbm_encoder;
+extern const FFCodec ff_pbm_decoder;
+extern const FFCodec ff_pcx_encoder;
+extern const FFCodec ff_pcx_decoder;
+extern const FFCodec ff_pfm_encoder;
+extern const FFCodec ff_pfm_decoder;
+extern const FFCodec ff_pgm_encoder;
+extern const FFCodec ff_pgm_decoder;
+extern const FFCodec ff_pgmyuv_encoder;
+extern const FFCodec ff_pgmyuv_decoder;
+extern const FFCodec ff_pgx_decoder;
+extern const FFCodec ff_phm_encoder;
+extern const FFCodec ff_phm_decoder;
+extern const FFCodec ff_photocd_decoder;
+extern const FFCodec ff_pictor_decoder;
+extern const FFCodec ff_pixlet_decoder;
+extern const FFCodec ff_png_encoder;
+extern const FFCodec ff_png_decoder;
+extern const FFCodec ff_ppm_encoder;
+extern const FFCodec ff_ppm_decoder;
+extern const FFCodec ff_prores_encoder;
+extern const FFCodec ff_prores_decoder;
+extern const FFCodec ff_prores_aw_encoder;
+extern const FFCodec ff_prores_ks_encoder;
+extern const FFCodec ff_prosumer_decoder;
+extern const FFCodec ff_psd_decoder;
+extern const FFCodec ff_ptx_decoder;
+extern const FFCodec ff_qdraw_decoder;
+extern const FFCodec ff_qoi_encoder;
+extern const FFCodec ff_qoi_decoder;
+extern const FFCodec ff_qpeg_decoder;
+extern const FFCodec ff_qtrle_encoder;
+extern const FFCodec ff_qtrle_decoder;
+extern const FFCodec ff_r10k_encoder;
+extern const FFCodec ff_r10k_decoder;
+extern const FFCodec ff_r210_encoder;
+extern const FFCodec ff_r210_decoder;
+extern const FFCodec ff_rasc_decoder;
+extern const FFCodec ff_rawvideo_encoder;
+extern const FFCodec ff_rawvideo_decoder;
+extern const FFCodec ff_rka_decoder;
+extern const FFCodec ff_rl2_decoder;
+extern const FFCodec ff_roq_encoder;
+extern const FFCodec ff_roq_decoder;
+extern const FFCodec ff_rpza_encoder;
+extern const FFCodec ff_rpza_decoder;
+extern const FFCodec ff_rscc_decoder;
+extern const FFCodec ff_rv10_encoder;
+extern const FFCodec ff_rv10_decoder;
+extern const FFCodec ff_rv20_encoder;
+extern const FFCodec ff_rv20_decoder;
+extern const FFCodec ff_rv30_decoder;
+extern const FFCodec ff_rv40_decoder;
+extern const FFCodec ff_s302m_encoder;
+extern const FFCodec ff_s302m_decoder;
+extern const FFCodec ff_sanm_decoder;
+extern const FFCodec ff_scpr_decoder;
+extern const FFCodec ff_screenpresso_decoder;
+extern const FFCodec ff_sga_decoder;
+extern const FFCodec ff_sgi_encoder;
+extern const FFCodec ff_sgi_decoder;
+extern const FFCodec ff_sgirle_decoder;
+extern const FFCodec ff_sheervideo_decoder;
+extern const FFCodec ff_simbiosis_imx_decoder;
+extern const FFCodec ff_smacker_decoder;
+extern const FFCodec ff_smc_encoder;
+extern const FFCodec ff_smc_decoder;
+extern const FFCodec ff_smvjpeg_decoder;
+extern const FFCodec ff_snow_encoder;
+extern const FFCodec ff_snow_decoder;
+extern const FFCodec ff_sp5x_decoder;
+extern const FFCodec ff_speedhq_decoder;
+extern const FFCodec ff_speedhq_encoder;
+extern const FFCodec ff_speex_decoder;
+extern const FFCodec ff_srgc_decoder;
+extern const FFCodec ff_sunrast_encoder;
+extern const FFCodec ff_sunrast_decoder;
+extern const FFCodec ff_svq1_encoder;
+extern const FFCodec ff_svq1_decoder;
+extern const FFCodec ff_svq3_decoder;
+extern const FFCodec ff_targa_encoder;
+extern const FFCodec ff_targa_decoder;
+extern const FFCodec ff_targa_y216_decoder;
+extern const FFCodec ff_tdsc_decoder;
+extern const FFCodec ff_theora_decoder;
+extern const FFCodec ff_thp_decoder;
+extern const FFCodec ff_tiertexseqvideo_decoder;
+extern const FFCodec ff_tiff_encoder;
+extern const FFCodec ff_tiff_decoder;
+extern const FFCodec ff_tmv_decoder;
+extern const FFCodec ff_truemotion1_decoder;
+extern const FFCodec ff_truemotion2_decoder;
+extern const FFCodec ff_truemotion2rt_decoder;
+extern const FFCodec ff_tscc_decoder;
+extern const FFCodec ff_tscc2_decoder;
+extern const FFCodec ff_txd_decoder;
+extern const FFCodec ff_ulti_decoder;
+extern const FFCodec ff_utvideo_encoder;
+extern const FFCodec ff_utvideo_decoder;
+extern const FFCodec ff_v210_encoder;
+extern const FFCodec ff_v210_decoder;
+extern const FFCodec ff_v210x_decoder;
+extern const FFCodec ff_v308_encoder;
+extern const FFCodec ff_v308_decoder;
+extern const FFCodec ff_v408_encoder;
+extern const FFCodec ff_v408_decoder;
+extern const FFCodec ff_v410_encoder;
+extern const FFCodec ff_v410_decoder;
+extern const FFCodec ff_vb_decoder;
+extern const FFCodec ff_vbn_encoder;
+extern const FFCodec ff_vbn_decoder;
+extern const FFCodec ff_vble_decoder;
+extern const FFCodec ff_vc1_decoder;
+extern const FFCodec ff_vc1_crystalhd_decoder;
+extern const FFCodec ff_vc1image_decoder;
+extern const FFCodec ff_vc1_mmal_decoder;
+extern const FFCodec ff_vc1_qsv_decoder;
+extern const FFCodec ff_vc1_v4l2m2m_decoder;
+extern const FFCodec ff_vc2_encoder;
+extern const FFCodec ff_vcr1_decoder;
+extern const FFCodec ff_vmdvideo_decoder;
+extern const FFCodec ff_vmnc_decoder;
+extern const FFCodec ff_vp3_decoder;
+extern const FFCodec ff_vp4_decoder;
+extern const FFCodec ff_vp5_decoder;
+extern const FFCodec ff_vp6_decoder;
+extern const FFCodec ff_vp6a_decoder;
+extern const FFCodec ff_vp6f_decoder;
+extern const FFCodec ff_vp7_decoder;
+extern const FFCodec ff_vp8_decoder;
+extern const FFCodec ff_vp8_rkmpp_decoder;
+extern const FFCodec ff_vp8_v4l2m2m_decoder;
+extern const FFCodec ff_vp9_decoder;
+extern const FFCodec ff_vp9_rkmpp_decoder;
+extern const FFCodec ff_vp9_v4l2m2m_decoder;
+extern const FFCodec ff_vqa_decoder;
+extern const FFCodec ff_vqc_decoder;
+extern const FFCodec ff_wbmp_decoder;
+extern const FFCodec ff_wbmp_encoder;
+extern const FFCodec ff_webp_decoder;
+extern const FFCodec ff_wcmv_decoder;
+extern const FFCodec ff_wrapped_avframe_encoder;
+extern const FFCodec ff_wrapped_avframe_decoder;
+extern const FFCodec ff_wmv1_encoder;
+extern const FFCodec ff_wmv1_decoder;
+extern const FFCodec ff_wmv2_encoder;
+extern const FFCodec ff_wmv2_decoder;
+extern const FFCodec ff_wmv3_decoder;
+extern const FFCodec ff_wmv3_crystalhd_decoder;
+extern const FFCodec ff_wmv3image_decoder;
+extern const FFCodec ff_wnv1_decoder;
+extern const FFCodec ff_xan_wc3_decoder;
+extern const FFCodec ff_xan_wc4_decoder;
+extern const FFCodec ff_xbm_encoder;
+extern const FFCodec ff_xbm_decoder;
+extern const FFCodec ff_xface_encoder;
+extern const FFCodec ff_xface_decoder;
+extern const FFCodec ff_xl_decoder;
+extern const FFCodec ff_xpm_decoder;
+extern const FFCodec ff_xwd_encoder;
+extern const FFCodec ff_xwd_decoder;
+extern const FFCodec ff_y41p_encoder;
+extern const FFCodec ff_y41p_decoder;
+extern const FFCodec ff_ylc_decoder;
+extern const FFCodec ff_yop_decoder;
+extern const FFCodec ff_yuv4_encoder;
+extern const FFCodec ff_yuv4_decoder;
+extern const FFCodec ff_zero12v_decoder;
+extern const FFCodec ff_zerocodec_decoder;
+extern const FFCodec ff_zlib_encoder;
+extern const FFCodec ff_zlib_decoder;
+extern const FFCodec ff_zmbv_encoder;
+extern const FFCodec ff_zmbv_decoder;
 
 /* audio codecs */
-extern AVCodec ff_aac_encoder;
-extern AVCodec ff_aac_decoder;
-extern AVCodec ff_aac_fixed_decoder;
-extern AVCodec ff_aac_latm_decoder;
-extern AVCodec ff_ac3_encoder;
-extern AVCodec ff_ac3_decoder;
-extern AVCodec ff_ac3_fixed_encoder;
-extern AVCodec ff_ac3_fixed_decoder;
-extern AVCodec ff_acelp_kelvin_decoder;
-extern AVCodec ff_alac_encoder;
-extern AVCodec ff_alac_decoder;
-extern AVCodec ff_als_decoder;
-extern AVCodec ff_amrnb_decoder;
-extern AVCodec ff_amrwb_decoder;
-extern AVCodec ff_ape_decoder;
-extern AVCodec ff_aptx_encoder;
-extern AVCodec ff_aptx_decoder;
-extern AVCodec ff_aptx_hd_encoder;
-extern AVCodec ff_aptx_hd_decoder;
-extern AVCodec ff_atrac1_decoder;
-extern AVCodec ff_atrac3_decoder;
-extern AVCodec ff_atrac3al_decoder;
-extern AVCodec ff_atrac3p_decoder;
-extern AVCodec ff_atrac3pal_decoder;
-extern AVCodec ff_atrac9_decoder;
-extern AVCodec ff_binkaudio_dct_decoder;
-extern AVCodec ff_binkaudio_rdft_decoder;
-extern AVCodec ff_bmv_audio_decoder;
-extern AVCodec ff_cook_decoder;
-extern AVCodec ff_dca_encoder;
-extern AVCodec ff_dca_decoder;
-extern AVCodec ff_dolby_e_decoder;
-extern AVCodec ff_dsd_lsbf_decoder;
-extern AVCodec ff_dsd_msbf_decoder;
-extern AVCodec ff_dsd_lsbf_planar_decoder;
-extern AVCodec ff_dsd_msbf_planar_decoder;
-extern AVCodec ff_dsicinaudio_decoder;
-extern AVCodec ff_dss_sp_decoder;
-extern AVCodec ff_dst_decoder;
-extern AVCodec ff_eac3_encoder;
-extern AVCodec ff_eac3_decoder;
-extern AVCodec ff_evrc_decoder;
-extern AVCodec ff_fastaudio_decoder;
-extern AVCodec ff_ffwavesynth_decoder;
-extern AVCodec ff_flac_encoder;
-extern AVCodec ff_flac_decoder;
-extern AVCodec ff_g723_1_encoder;
-extern AVCodec ff_g723_1_decoder;
-extern AVCodec ff_g729_decoder;
-extern AVCodec ff_gsm_decoder;
-extern AVCodec ff_gsm_ms_decoder;
-extern AVCodec ff_hca_decoder;
-extern AVCodec ff_hcom_decoder;
-extern AVCodec ff_iac_decoder;
-extern AVCodec ff_ilbc_decoder;
-extern AVCodec ff_imc_decoder;
-extern AVCodec ff_interplay_acm_decoder;
-extern AVCodec ff_mace3_decoder;
-extern AVCodec ff_mace6_decoder;
-extern AVCodec ff_metasound_decoder;
-extern AVCodec ff_mlp_encoder;
-extern AVCodec ff_mlp_decoder;
-extern AVCodec ff_mp1_decoder;
-extern AVCodec ff_mp1float_decoder;
-extern AVCodec ff_mp2_encoder;
-extern AVCodec ff_mp2_decoder;
-extern AVCodec ff_mp2float_decoder;
-extern AVCodec ff_mp2fixed_encoder;
-extern AVCodec ff_mp3float_decoder;
-extern AVCodec ff_mp3_decoder;
-extern AVCodec ff_mp3adufloat_decoder;
-extern AVCodec ff_mp3adu_decoder;
-extern AVCodec ff_mp3on4float_decoder;
-extern AVCodec ff_mp3on4_decoder;
-extern AVCodec ff_mpc7_decoder;
-extern AVCodec ff_mpc8_decoder;
-extern AVCodec ff_nellymoser_encoder;
-extern AVCodec ff_nellymoser_decoder;
-extern AVCodec ff_on2avc_decoder;
-extern AVCodec ff_opus_encoder;
-extern AVCodec ff_opus_decoder;
-extern AVCodec ff_paf_audio_decoder;
-extern AVCodec ff_qcelp_decoder;
-extern AVCodec ff_qdm2_decoder;
-extern AVCodec ff_qdmc_decoder;
-extern AVCodec ff_ra_144_encoder;
-extern AVCodec ff_ra_144_decoder;
-extern AVCodec ff_ra_288_decoder;
-extern AVCodec ff_ralf_decoder;
-extern AVCodec ff_sbc_encoder;
-extern AVCodec ff_sbc_decoder;
-extern AVCodec ff_shorten_decoder;
-extern AVCodec ff_sipr_decoder;
-extern AVCodec ff_siren_decoder;
-extern AVCodec ff_smackaud_decoder;
-extern AVCodec ff_sonic_encoder;
-extern AVCodec ff_sonic_decoder;
-extern AVCodec ff_sonic_ls_encoder;
-extern AVCodec ff_tak_decoder;
-extern AVCodec ff_truehd_encoder;
-extern AVCodec ff_truehd_decoder;
-extern AVCodec ff_truespeech_decoder;
-extern AVCodec ff_tta_encoder;
-extern AVCodec ff_tta_decoder;
-extern AVCodec ff_twinvq_decoder;
-extern AVCodec ff_vmdaudio_decoder;
-extern AVCodec ff_vorbis_encoder;
-extern AVCodec ff_vorbis_decoder;
-extern AVCodec ff_wavpack_encoder;
-extern AVCodec ff_wavpack_decoder;
-extern AVCodec ff_wmalossless_decoder;
-extern AVCodec ff_wmapro_decoder;
-extern AVCodec ff_wmav1_encoder;
-extern AVCodec ff_wmav1_decoder;
-extern AVCodec ff_wmav2_encoder;
-extern AVCodec ff_wmav2_decoder;
-extern AVCodec ff_wmavoice_decoder;
-extern AVCodec ff_ws_snd1_decoder;
-extern AVCodec ff_xma1_decoder;
-extern AVCodec ff_xma2_decoder;
+extern const FFCodec ff_aac_encoder;
+extern const FFCodec ff_aac_decoder;
+extern const FFCodec ff_aac_fixed_decoder;
+extern const FFCodec ff_aac_latm_decoder;
+extern const FFCodec ff_ac3_encoder;
+extern const FFCodec ff_ac3_decoder;
+extern const FFCodec ff_ac3_fixed_encoder;
+extern const FFCodec ff_ac3_fixed_decoder;
+extern const FFCodec ff_acelp_kelvin_decoder;
+extern const FFCodec ff_alac_encoder;
+extern const FFCodec ff_alac_decoder;
+extern const FFCodec ff_als_decoder;
+extern const FFCodec ff_amrnb_decoder;
+extern const FFCodec ff_amrwb_decoder;
+extern const FFCodec ff_apac_decoder;
+extern const FFCodec ff_ape_decoder;
+extern const FFCodec ff_aptx_encoder;
+extern const FFCodec ff_aptx_decoder;
+extern const FFCodec ff_aptx_hd_encoder;
+extern const FFCodec ff_aptx_hd_decoder;
+extern const FFCodec ff_atrac1_decoder;
+extern const FFCodec ff_atrac3_decoder;
+extern const FFCodec ff_atrac3al_decoder;
+extern const FFCodec ff_atrac3p_decoder;
+extern const FFCodec ff_atrac3pal_decoder;
+extern const FFCodec ff_atrac9_decoder;
+extern const FFCodec ff_binkaudio_dct_decoder;
+extern const FFCodec ff_binkaudio_rdft_decoder;
+extern const FFCodec ff_bmv_audio_decoder;
+extern const FFCodec ff_bonk_decoder;
+extern const FFCodec ff_cook_decoder;
+extern const FFCodec ff_dca_encoder;
+extern const FFCodec ff_dca_decoder;
+extern const FFCodec ff_dfpwm_encoder;
+extern const FFCodec ff_dfpwm_decoder;
+extern const FFCodec ff_dolby_e_decoder;
+extern const FFCodec ff_dsd_lsbf_decoder;
+extern const FFCodec ff_dsd_msbf_decoder;
+extern const FFCodec ff_dsd_lsbf_planar_decoder;
+extern const FFCodec ff_dsd_msbf_planar_decoder;
+extern const FFCodec ff_dsicinaudio_decoder;
+extern const FFCodec ff_dss_sp_decoder;
+extern const FFCodec ff_dst_decoder;
+extern const FFCodec ff_eac3_encoder;
+extern const FFCodec ff_eac3_decoder;
+extern const FFCodec ff_evrc_decoder;
+extern const FFCodec ff_fastaudio_decoder;
+extern const FFCodec ff_ffwavesynth_decoder;
+extern const FFCodec ff_flac_encoder;
+extern const FFCodec ff_flac_decoder;
+extern const FFCodec ff_ftr_decoder;
+extern const FFCodec ff_g723_1_encoder;
+extern const FFCodec ff_g723_1_decoder;
+extern const FFCodec ff_g729_decoder;
+extern const FFCodec ff_gsm_decoder;
+extern const FFCodec ff_gsm_ms_decoder;
+extern const FFCodec ff_hca_decoder;
+extern const FFCodec ff_hcom_decoder;
+extern const FFCodec ff_hdr_encoder;
+extern const FFCodec ff_hdr_decoder;
+extern const FFCodec ff_iac_decoder;
+extern const FFCodec ff_ilbc_decoder;
+extern const FFCodec ff_imc_decoder;
+extern const FFCodec ff_interplay_acm_decoder;
+extern const FFCodec ff_mace3_decoder;
+extern const FFCodec ff_mace6_decoder;
+extern const FFCodec ff_metasound_decoder;
+extern const FFCodec ff_misc4_decoder;
+extern const FFCodec ff_mlp_encoder;
+extern const FFCodec ff_mlp_decoder;
+extern const FFCodec ff_mp1_decoder;
+extern const FFCodec ff_mp1float_decoder;
+extern const FFCodec ff_mp2_encoder;
+extern const FFCodec ff_mp2_decoder;
+extern const FFCodec ff_mp2float_decoder;
+extern const FFCodec ff_mp2fixed_encoder;
+extern const FFCodec ff_mp3float_decoder;
+extern const FFCodec ff_mp3_decoder;
+extern const FFCodec ff_mp3adufloat_decoder;
+extern const FFCodec ff_mp3adu_decoder;
+extern const FFCodec ff_mp3on4float_decoder;
+extern const FFCodec ff_mp3on4_decoder;
+extern const FFCodec ff_mpc7_decoder;
+extern const FFCodec ff_mpc8_decoder;
+extern const FFCodec ff_msnsiren_decoder;
+extern const FFCodec ff_nellymoser_encoder;
+extern const FFCodec ff_nellymoser_decoder;
+extern const FFCodec ff_on2avc_decoder;
+extern const FFCodec ff_opus_encoder;
+extern const FFCodec ff_opus_decoder;
+extern const FFCodec ff_paf_audio_decoder;
+extern const FFCodec ff_qcelp_decoder;
+extern const FFCodec ff_qdm2_decoder;
+extern const FFCodec ff_qdmc_decoder;
+extern const FFCodec ff_ra_144_encoder;
+extern const FFCodec ff_ra_144_decoder;
+extern const FFCodec ff_ra_288_decoder;
+extern const FFCodec ff_ralf_decoder;
+extern const FFCodec ff_sbc_encoder;
+extern const FFCodec ff_sbc_decoder;
+extern const FFCodec ff_shorten_decoder;
+extern const FFCodec ff_sipr_decoder;
+extern const FFCodec ff_siren_decoder;
+extern const FFCodec ff_smackaud_decoder;
+extern const FFCodec ff_sonic_encoder;
+extern const FFCodec ff_sonic_decoder;
+extern const FFCodec ff_sonic_ls_encoder;
+extern const FFCodec ff_tak_decoder;
+extern const FFCodec ff_truehd_encoder;
+extern const FFCodec ff_truehd_decoder;
+extern const FFCodec ff_truespeech_decoder;
+extern const FFCodec ff_tta_encoder;
+extern const FFCodec ff_tta_decoder;
+extern const FFCodec ff_twinvq_decoder;
+extern const FFCodec ff_vmdaudio_decoder;
+extern const FFCodec ff_vorbis_encoder;
+extern const FFCodec ff_vorbis_decoder;
+extern const FFCodec ff_wavarc_decoder;
+extern const FFCodec ff_wavpack_encoder;
+extern const FFCodec ff_wavpack_decoder;
+extern const FFCodec ff_wmalossless_decoder;
+extern const FFCodec ff_wmapro_decoder;
+extern const FFCodec ff_wmav1_encoder;
+extern const FFCodec ff_wmav1_decoder;
+extern const FFCodec ff_wmav2_encoder;
+extern const FFCodec ff_wmav2_decoder;
+extern const FFCodec ff_wmavoice_decoder;
+extern const FFCodec ff_ws_snd1_decoder;
+extern const FFCodec ff_xma1_decoder;
+extern const FFCodec ff_xma2_decoder;
 
 /* PCM codecs */
-extern AVCodec ff_pcm_alaw_encoder;
-extern AVCodec ff_pcm_alaw_decoder;
-extern AVCodec ff_pcm_bluray_decoder;
-extern AVCodec ff_pcm_dvd_encoder;
-extern AVCodec ff_pcm_dvd_decoder;
-extern AVCodec ff_pcm_f16le_decoder;
-extern AVCodec ff_pcm_f24le_decoder;
-extern AVCodec ff_pcm_f32be_encoder;
-extern AVCodec ff_pcm_f32be_decoder;
-extern AVCodec ff_pcm_f32le_encoder;
-extern AVCodec ff_pcm_f32le_decoder;
-extern AVCodec ff_pcm_f64be_encoder;
-extern AVCodec ff_pcm_f64be_decoder;
-extern AVCodec ff_pcm_f64le_encoder;
-extern AVCodec ff_pcm_f64le_decoder;
-extern AVCodec ff_pcm_lxf_decoder;
-extern AVCodec ff_pcm_mulaw_encoder;
-extern AVCodec ff_pcm_mulaw_decoder;
-extern AVCodec ff_pcm_s8_encoder;
-extern AVCodec ff_pcm_s8_decoder;
-extern AVCodec ff_pcm_s8_planar_encoder;
-extern AVCodec ff_pcm_s8_planar_decoder;
-extern AVCodec ff_pcm_s16be_encoder;
-extern AVCodec ff_pcm_s16be_decoder;
-extern AVCodec ff_pcm_s16be_planar_encoder;
-extern AVCodec ff_pcm_s16be_planar_decoder;
-extern AVCodec ff_pcm_s16le_encoder;
-extern AVCodec ff_pcm_s16le_decoder;
-extern AVCodec ff_pcm_s16le_planar_encoder;
-extern AVCodec ff_pcm_s16le_planar_decoder;
-extern AVCodec ff_pcm_s24be_encoder;
-extern AVCodec ff_pcm_s24be_decoder;
-extern AVCodec ff_pcm_s24daud_encoder;
-extern AVCodec ff_pcm_s24daud_decoder;
-extern AVCodec ff_pcm_s24le_encoder;
-extern AVCodec ff_pcm_s24le_decoder;
-extern AVCodec ff_pcm_s24le_planar_encoder;
-extern AVCodec ff_pcm_s24le_planar_decoder;
-extern AVCodec ff_pcm_s32be_encoder;
-extern AVCodec ff_pcm_s32be_decoder;
-extern AVCodec ff_pcm_s32le_encoder;
-extern AVCodec ff_pcm_s32le_decoder;
-extern AVCodec ff_pcm_s32le_planar_encoder;
-extern AVCodec ff_pcm_s32le_planar_decoder;
-extern AVCodec ff_pcm_s64be_encoder;
-extern AVCodec ff_pcm_s64be_decoder;
-extern AVCodec ff_pcm_s64le_encoder;
-extern AVCodec ff_pcm_s64le_decoder;
-extern AVCodec ff_pcm_sga_decoder;
-extern AVCodec ff_pcm_u8_encoder;
-extern AVCodec ff_pcm_u8_decoder;
-extern AVCodec ff_pcm_u16be_encoder;
-extern AVCodec ff_pcm_u16be_decoder;
-extern AVCodec ff_pcm_u16le_encoder;
-extern AVCodec ff_pcm_u16le_decoder;
-extern AVCodec ff_pcm_u24be_encoder;
-extern AVCodec ff_pcm_u24be_decoder;
-extern AVCodec ff_pcm_u24le_encoder;
-extern AVCodec ff_pcm_u24le_decoder;
-extern AVCodec ff_pcm_u32be_encoder;
-extern AVCodec ff_pcm_u32be_decoder;
-extern AVCodec ff_pcm_u32le_encoder;
-extern AVCodec ff_pcm_u32le_decoder;
-extern AVCodec ff_pcm_vidc_encoder;
-extern AVCodec ff_pcm_vidc_decoder;
+extern const FFCodec ff_pcm_alaw_encoder;
+extern const FFCodec ff_pcm_alaw_decoder;
+extern const FFCodec ff_pcm_bluray_encoder;
+extern const FFCodec ff_pcm_bluray_decoder;
+extern const FFCodec ff_pcm_dvd_encoder;
+extern const FFCodec ff_pcm_dvd_decoder;
+extern const FFCodec ff_pcm_f16le_decoder;
+extern const FFCodec ff_pcm_f24le_decoder;
+extern const FFCodec ff_pcm_f32be_encoder;
+extern const FFCodec ff_pcm_f32be_decoder;
+extern const FFCodec ff_pcm_f32le_encoder;
+extern const FFCodec ff_pcm_f32le_decoder;
+extern const FFCodec ff_pcm_f64be_encoder;
+extern const FFCodec ff_pcm_f64be_decoder;
+extern const FFCodec ff_pcm_f64le_encoder;
+extern const FFCodec ff_pcm_f64le_decoder;
+extern const FFCodec ff_pcm_lxf_decoder;
+extern const FFCodec ff_pcm_mulaw_encoder;
+extern const FFCodec ff_pcm_mulaw_decoder;
+extern const FFCodec ff_pcm_s8_encoder;
+extern const FFCodec ff_pcm_s8_decoder;
+extern const FFCodec ff_pcm_s8_planar_encoder;
+extern const FFCodec ff_pcm_s8_planar_decoder;
+extern const FFCodec ff_pcm_s16be_encoder;
+extern const FFCodec ff_pcm_s16be_decoder;
+extern const FFCodec ff_pcm_s16be_planar_encoder;
+extern const FFCodec ff_pcm_s16be_planar_decoder;
+extern const FFCodec ff_pcm_s16le_encoder;
+extern const FFCodec ff_pcm_s16le_decoder;
+extern const FFCodec ff_pcm_s16le_planar_encoder;
+extern const FFCodec ff_pcm_s16le_planar_decoder;
+extern const FFCodec ff_pcm_s24be_encoder;
+extern const FFCodec ff_pcm_s24be_decoder;
+extern const FFCodec ff_pcm_s24daud_encoder;
+extern const FFCodec ff_pcm_s24daud_decoder;
+extern const FFCodec ff_pcm_s24le_encoder;
+extern const FFCodec ff_pcm_s24le_decoder;
+extern const FFCodec ff_pcm_s24le_planar_encoder;
+extern const FFCodec ff_pcm_s24le_planar_decoder;
+extern const FFCodec ff_pcm_s32be_encoder;
+extern const FFCodec ff_pcm_s32be_decoder;
+extern const FFCodec ff_pcm_s32le_encoder;
+extern const FFCodec ff_pcm_s32le_decoder;
+extern const FFCodec ff_pcm_s32le_planar_encoder;
+extern const FFCodec ff_pcm_s32le_planar_decoder;
+extern const FFCodec ff_pcm_s64be_encoder;
+extern const FFCodec ff_pcm_s64be_decoder;
+extern const FFCodec ff_pcm_s64le_encoder;
+extern const FFCodec ff_pcm_s64le_decoder;
+extern const FFCodec ff_pcm_sga_decoder;
+extern const FFCodec ff_pcm_u8_encoder;
+extern const FFCodec ff_pcm_u8_decoder;
+extern const FFCodec ff_pcm_u16be_encoder;
+extern const FFCodec ff_pcm_u16be_decoder;
+extern const FFCodec ff_pcm_u16le_encoder;
+extern const FFCodec ff_pcm_u16le_decoder;
+extern const FFCodec ff_pcm_u24be_encoder;
+extern const FFCodec ff_pcm_u24be_decoder;
+extern const FFCodec ff_pcm_u24le_encoder;
+extern const FFCodec ff_pcm_u24le_decoder;
+extern const FFCodec ff_pcm_u32be_encoder;
+extern const FFCodec ff_pcm_u32be_decoder;
+extern const FFCodec ff_pcm_u32le_encoder;
+extern const FFCodec ff_pcm_u32le_decoder;
+extern const FFCodec ff_pcm_vidc_encoder;
+extern const FFCodec ff_pcm_vidc_decoder;
 
 /* DPCM codecs */
-extern AVCodec ff_derf_dpcm_decoder;
-extern AVCodec ff_gremlin_dpcm_decoder;
-extern AVCodec ff_interplay_dpcm_decoder;
-extern AVCodec ff_roq_dpcm_encoder;
-extern AVCodec ff_roq_dpcm_decoder;
-extern AVCodec ff_sdx2_dpcm_decoder;
-extern AVCodec ff_sol_dpcm_decoder;
-extern AVCodec ff_xan_dpcm_decoder;
+extern const FFCodec ff_cbd2_dpcm_decoder;
+extern const FFCodec ff_derf_dpcm_decoder;
+extern const FFCodec ff_gremlin_dpcm_decoder;
+extern const FFCodec ff_interplay_dpcm_decoder;
+extern const FFCodec ff_roq_dpcm_encoder;
+extern const FFCodec ff_roq_dpcm_decoder;
+extern const FFCodec ff_sdx2_dpcm_decoder;
+extern const FFCodec ff_sol_dpcm_decoder;
+extern const FFCodec ff_xan_dpcm_decoder;
+extern const FFCodec ff_wady_dpcm_decoder;
 
 /* ADPCM codecs */
-extern AVCodec ff_adpcm_4xm_decoder;
-extern AVCodec ff_adpcm_adx_encoder;
-extern AVCodec ff_adpcm_adx_decoder;
-extern AVCodec ff_adpcm_afc_decoder;
-extern AVCodec ff_adpcm_agm_decoder;
-extern AVCodec ff_adpcm_aica_decoder;
-extern AVCodec ff_adpcm_argo_decoder;
-extern AVCodec ff_adpcm_argo_encoder;
-extern AVCodec ff_adpcm_ct_decoder;
-extern AVCodec ff_adpcm_dtk_decoder;
-extern AVCodec ff_adpcm_ea_decoder;
-extern AVCodec ff_adpcm_ea_maxis_xa_decoder;
-extern AVCodec ff_adpcm_ea_r1_decoder;
-extern AVCodec ff_adpcm_ea_r2_decoder;
-extern AVCodec ff_adpcm_ea_r3_decoder;
-extern AVCodec ff_adpcm_ea_xas_decoder;
-extern AVCodec ff_adpcm_g722_encoder;
-extern AVCodec ff_adpcm_g722_decoder;
-extern AVCodec ff_adpcm_g726_encoder;
-extern AVCodec ff_adpcm_g726_decoder;
-extern AVCodec ff_adpcm_g726le_encoder;
-extern AVCodec ff_adpcm_g726le_decoder;
-extern AVCodec ff_adpcm_ima_amv_decoder;
-extern AVCodec ff_adpcm_ima_amv_encoder;
-extern AVCodec ff_adpcm_ima_alp_decoder;
-extern AVCodec ff_adpcm_ima_alp_encoder;
-extern AVCodec ff_adpcm_ima_apc_decoder;
-extern AVCodec ff_adpcm_ima_apm_decoder;
-extern AVCodec ff_adpcm_ima_apm_encoder;
-extern AVCodec ff_adpcm_ima_cunning_decoder;
-extern AVCodec ff_adpcm_ima_dat4_decoder;
-extern AVCodec ff_adpcm_ima_dk3_decoder;
-extern AVCodec ff_adpcm_ima_dk4_decoder;
-extern AVCodec ff_adpcm_ima_ea_eacs_decoder;
-extern AVCodec ff_adpcm_ima_ea_sead_decoder;
-extern AVCodec ff_adpcm_ima_iss_decoder;
-extern AVCodec ff_adpcm_ima_moflex_decoder;
-extern AVCodec ff_adpcm_ima_mtf_decoder;
-extern AVCodec ff_adpcm_ima_oki_decoder;
-extern AVCodec ff_adpcm_ima_qt_encoder;
-extern AVCodec ff_adpcm_ima_qt_decoder;
-extern AVCodec ff_adpcm_ima_rad_decoder;
-extern AVCodec ff_adpcm_ima_ssi_decoder;
-extern AVCodec ff_adpcm_ima_ssi_encoder;
-extern AVCodec ff_adpcm_ima_smjpeg_decoder;
-extern AVCodec ff_adpcm_ima_wav_encoder;
-extern AVCodec ff_adpcm_ima_wav_decoder;
-extern AVCodec ff_adpcm_ima_ws_decoder;
-extern AVCodec ff_adpcm_ms_encoder;
-extern AVCodec ff_adpcm_ms_decoder;
-extern AVCodec ff_adpcm_mtaf_decoder;
-extern AVCodec ff_adpcm_psx_decoder;
-extern AVCodec ff_adpcm_sbpro_2_decoder;
-extern AVCodec ff_adpcm_sbpro_3_decoder;
-extern AVCodec ff_adpcm_sbpro_4_decoder;
-extern AVCodec ff_adpcm_swf_encoder;
-extern AVCodec ff_adpcm_swf_decoder;
-extern AVCodec ff_adpcm_thp_decoder;
-extern AVCodec ff_adpcm_thp_le_decoder;
-extern AVCodec ff_adpcm_vima_decoder;
-extern AVCodec ff_adpcm_xa_decoder;
-extern AVCodec ff_adpcm_yamaha_encoder;
-extern AVCodec ff_adpcm_yamaha_decoder;
-extern AVCodec ff_adpcm_zork_decoder;
+extern const FFCodec ff_adpcm_4xm_decoder;
+extern const FFCodec ff_adpcm_adx_encoder;
+extern const FFCodec ff_adpcm_adx_decoder;
+extern const FFCodec ff_adpcm_afc_decoder;
+extern const FFCodec ff_adpcm_agm_decoder;
+extern const FFCodec ff_adpcm_aica_decoder;
+extern const FFCodec ff_adpcm_argo_decoder;
+extern const FFCodec ff_adpcm_argo_encoder;
+extern const FFCodec ff_adpcm_ct_decoder;
+extern const FFCodec ff_adpcm_dtk_decoder;
+extern const FFCodec ff_adpcm_ea_decoder;
+extern const FFCodec ff_adpcm_ea_maxis_xa_decoder;
+extern const FFCodec ff_adpcm_ea_r1_decoder;
+extern const FFCodec ff_adpcm_ea_r2_decoder;
+extern const FFCodec ff_adpcm_ea_r3_decoder;
+extern const FFCodec ff_adpcm_ea_xas_decoder;
+extern const FFCodec ff_adpcm_g722_encoder;
+extern const FFCodec ff_adpcm_g722_decoder;
+extern const FFCodec ff_adpcm_g726_encoder;
+extern const FFCodec ff_adpcm_g726_decoder;
+extern const FFCodec ff_adpcm_g726le_encoder;
+extern const FFCodec ff_adpcm_g726le_decoder;
+extern const FFCodec ff_adpcm_ima_acorn_decoder;
+extern const FFCodec ff_adpcm_ima_amv_decoder;
+extern const FFCodec ff_adpcm_ima_amv_encoder;
+extern const FFCodec ff_adpcm_ima_alp_decoder;
+extern const FFCodec ff_adpcm_ima_alp_encoder;
+extern const FFCodec ff_adpcm_ima_apc_decoder;
+extern const FFCodec ff_adpcm_ima_apm_decoder;
+extern const FFCodec ff_adpcm_ima_apm_encoder;
+extern const FFCodec ff_adpcm_ima_cunning_decoder;
+extern const FFCodec ff_adpcm_ima_dat4_decoder;
+extern const FFCodec ff_adpcm_ima_dk3_decoder;
+extern const FFCodec ff_adpcm_ima_dk4_decoder;
+extern const FFCodec ff_adpcm_ima_ea_eacs_decoder;
+extern const FFCodec ff_adpcm_ima_ea_sead_decoder;
+extern const FFCodec ff_adpcm_ima_iss_decoder;
+extern const FFCodec ff_adpcm_ima_moflex_decoder;
+extern const FFCodec ff_adpcm_ima_mtf_decoder;
+extern const FFCodec ff_adpcm_ima_oki_decoder;
+extern const FFCodec ff_adpcm_ima_qt_encoder;
+extern const FFCodec ff_adpcm_ima_qt_decoder;
+extern const FFCodec ff_adpcm_ima_rad_decoder;
+extern const FFCodec ff_adpcm_ima_ssi_decoder;
+extern const FFCodec ff_adpcm_ima_ssi_encoder;
+extern const FFCodec ff_adpcm_ima_smjpeg_decoder;
+extern const FFCodec ff_adpcm_ima_wav_encoder;
+extern const FFCodec ff_adpcm_ima_wav_decoder;
+extern const FFCodec ff_adpcm_ima_ws_encoder;
+extern const FFCodec ff_adpcm_ima_ws_decoder;
+extern const FFCodec ff_adpcm_ms_encoder;
+extern const FFCodec ff_adpcm_ms_decoder;
+extern const FFCodec ff_adpcm_mtaf_decoder;
+extern const FFCodec ff_adpcm_psx_decoder;
+extern const FFCodec ff_adpcm_sbpro_2_decoder;
+extern const FFCodec ff_adpcm_sbpro_3_decoder;
+extern const FFCodec ff_adpcm_sbpro_4_decoder;
+extern const FFCodec ff_adpcm_swf_encoder;
+extern const FFCodec ff_adpcm_swf_decoder;
+extern const FFCodec ff_adpcm_thp_decoder;
+extern const FFCodec ff_adpcm_thp_le_decoder;
+extern const FFCodec ff_adpcm_vima_decoder;
+extern const FFCodec ff_adpcm_xa_decoder;
+extern const FFCodec ff_adpcm_xmd_decoder;
+extern const FFCodec ff_adpcm_yamaha_encoder;
+extern const FFCodec ff_adpcm_yamaha_decoder;
+extern const FFCodec ff_adpcm_zork_decoder;
 
 /* subtitles */
-extern AVCodec ff_ssa_encoder;
-extern AVCodec ff_ssa_decoder;
-extern AVCodec ff_ass_encoder;
-extern AVCodec ff_ass_decoder;
-extern AVCodec ff_ccaption_decoder;
-extern AVCodec ff_dvbsub_encoder;
-extern AVCodec ff_dvbsub_decoder;
-extern AVCodec ff_dvdsub_encoder;
-extern AVCodec ff_dvdsub_decoder;
-extern AVCodec ff_jacosub_decoder;
-extern AVCodec ff_microdvd_decoder;
-extern AVCodec ff_movtext_encoder;
-extern AVCodec ff_movtext_decoder;
-extern AVCodec ff_mpl2_decoder;
-extern AVCodec ff_pgssub_decoder;
-extern AVCodec ff_pjs_decoder;
-extern AVCodec ff_realtext_decoder;
-extern AVCodec ff_sami_decoder;
-extern AVCodec ff_srt_encoder;
-extern AVCodec ff_srt_decoder;
-extern AVCodec ff_stl_decoder;
-extern AVCodec ff_subrip_encoder;
-extern AVCodec ff_subrip_decoder;
-extern AVCodec ff_subviewer_decoder;
-extern AVCodec ff_subviewer1_decoder;
-extern AVCodec ff_text_encoder;
-extern AVCodec ff_text_decoder;
-extern AVCodec ff_ttml_encoder;
-extern AVCodec ff_vplayer_decoder;
-extern AVCodec ff_webvtt_encoder;
-extern AVCodec ff_webvtt_decoder;
-extern AVCodec ff_xsub_encoder;
-extern AVCodec ff_xsub_decoder;
+extern const FFCodec ff_ssa_encoder;
+extern const FFCodec ff_ssa_decoder;
+extern const FFCodec ff_ass_encoder;
+extern const FFCodec ff_ass_decoder;
+extern const FFCodec ff_ccaption_decoder;
+extern const FFCodec ff_dvbsub_encoder;
+extern const FFCodec ff_dvbsub_decoder;
+extern const FFCodec ff_dvdsub_encoder;
+extern const FFCodec ff_dvdsub_decoder;
+extern const FFCodec ff_jacosub_decoder;
+extern const FFCodec ff_microdvd_decoder;
+extern const FFCodec ff_movtext_encoder;
+extern const FFCodec ff_movtext_decoder;
+extern const FFCodec ff_mpl2_decoder;
+extern const FFCodec ff_pgssub_decoder;
+extern const FFCodec ff_pjs_decoder;
+extern const FFCodec ff_realtext_decoder;
+extern const FFCodec ff_sami_decoder;
+extern const FFCodec ff_srt_encoder;
+extern const FFCodec ff_srt_decoder;
+extern const FFCodec ff_stl_decoder;
+extern const FFCodec ff_subrip_encoder;
+extern const FFCodec ff_subrip_decoder;
+extern const FFCodec ff_subviewer_decoder;
+extern const FFCodec ff_subviewer1_decoder;
+extern const FFCodec ff_text_encoder;
+extern const FFCodec ff_text_decoder;
+extern const FFCodec ff_ttml_encoder;
+extern const FFCodec ff_vplayer_decoder;
+extern const FFCodec ff_webvtt_encoder;
+extern const FFCodec ff_webvtt_decoder;
+extern const FFCodec ff_xsub_encoder;
+extern const FFCodec ff_xsub_decoder;
 
 /* external libraries */
-extern AVCodec ff_aac_at_encoder;
-extern AVCodec ff_aac_at_decoder;
-extern AVCodec ff_ac3_at_decoder;
-extern AVCodec ff_adpcm_ima_qt_at_decoder;
-extern AVCodec ff_alac_at_encoder;
-extern AVCodec ff_alac_at_decoder;
-extern AVCodec ff_amr_nb_at_decoder;
-extern AVCodec ff_eac3_at_decoder;
-extern AVCodec ff_gsm_ms_at_decoder;
-extern AVCodec ff_ilbc_at_encoder;
-extern AVCodec ff_ilbc_at_decoder;
-extern AVCodec ff_mp1_at_decoder;
-extern AVCodec ff_mp2_at_decoder;
-extern AVCodec ff_mp3_at_decoder;
-extern AVCodec ff_pcm_alaw_at_encoder;
-extern AVCodec ff_pcm_alaw_at_decoder;
-extern AVCodec ff_pcm_mulaw_at_encoder;
-extern AVCodec ff_pcm_mulaw_at_decoder;
-extern AVCodec ff_qdmc_at_decoder;
-extern AVCodec ff_qdm2_at_decoder;
-extern AVCodec ff_libaom_av1_encoder;
-extern AVCodec ff_libaribb24_decoder;
-extern AVCodec ff_libcelt_decoder;
-extern AVCodec ff_libcodec2_encoder;
-extern AVCodec ff_libcodec2_decoder;
-extern AVCodec ff_libdav1d_decoder;
-extern AVCodec ff_libdavs2_decoder;
-extern AVCodec ff_libfdk_aac_encoder;
-extern AVCodec ff_libfdk_aac_decoder;
-extern AVCodec ff_libgsm_encoder;
-extern AVCodec ff_libgsm_decoder;
-extern AVCodec ff_libgsm_ms_encoder;
-extern AVCodec ff_libgsm_ms_decoder;
-extern AVCodec ff_libilbc_encoder;
-extern AVCodec ff_libilbc_decoder;
-extern AVCodec ff_libmp3lame_encoder;
-extern AVCodec ff_libopencore_amrnb_encoder;
-extern AVCodec ff_libopencore_amrnb_decoder;
-extern AVCodec ff_libopencore_amrwb_decoder;
-extern AVCodec ff_libopenjpeg_encoder;
-extern AVCodec ff_libopenjpeg_decoder;
-extern AVCodec ff_libopus_encoder;
-extern AVCodec ff_libopus_decoder;
-extern AVCodec ff_librav1e_encoder;
-extern AVCodec ff_librsvg_decoder;
-extern AVCodec ff_libshine_encoder;
-extern AVCodec ff_libspeex_encoder;
-extern AVCodec ff_libspeex_decoder;
-extern AVCodec ff_libsvtav1_encoder;
-extern AVCodec ff_libtheora_encoder;
-extern AVCodec ff_libtwolame_encoder;
-extern AVCodec ff_libuavs3d_decoder;
-extern AVCodec ff_libvo_amrwbenc_encoder;
-extern AVCodec ff_libvorbis_encoder;
-extern AVCodec ff_libvorbis_decoder;
-extern AVCodec ff_libvpx_vp8_encoder;
-extern AVCodec ff_libvpx_vp8_decoder;
-extern AVCodec ff_libvpx_vp9_encoder;
-extern AVCodec ff_libvpx_vp9_decoder;
+extern const FFCodec ff_aac_at_encoder;
+extern const FFCodec ff_aac_at_decoder;
+extern const FFCodec ff_ac3_at_decoder;
+extern const FFCodec ff_adpcm_ima_qt_at_decoder;
+extern const FFCodec ff_alac_at_encoder;
+extern const FFCodec ff_alac_at_decoder;
+extern const FFCodec ff_amr_nb_at_decoder;
+extern const FFCodec ff_eac3_at_decoder;
+extern const FFCodec ff_gsm_ms_at_decoder;
+extern const FFCodec ff_ilbc_at_encoder;
+extern const FFCodec ff_ilbc_at_decoder;
+extern const FFCodec ff_mp1_at_decoder;
+extern const FFCodec ff_mp2_at_decoder;
+extern const FFCodec ff_mp3_at_decoder;
+extern const FFCodec ff_pcm_alaw_at_encoder;
+extern const FFCodec ff_pcm_alaw_at_decoder;
+extern const FFCodec ff_pcm_mulaw_at_encoder;
+extern const FFCodec ff_pcm_mulaw_at_decoder;
+extern const FFCodec ff_qdmc_at_decoder;
+extern const FFCodec ff_qdm2_at_decoder;
+extern FFCodec ff_libaom_av1_encoder;
+extern const FFCodec ff_libaribb24_decoder;
+extern const FFCodec ff_libcelt_decoder;
+extern const FFCodec ff_libcodec2_encoder;
+extern const FFCodec ff_libcodec2_decoder;
+extern const FFCodec ff_libdav1d_decoder;
+extern const FFCodec ff_libdavs2_decoder;
+extern const FFCodec ff_libfdk_aac_encoder;
+extern const FFCodec ff_libfdk_aac_decoder;
+extern const FFCodec ff_libgsm_encoder;
+extern const FFCodec ff_libgsm_decoder;
+extern const FFCodec ff_libgsm_ms_encoder;
+extern const FFCodec ff_libgsm_ms_decoder;
+extern const FFCodec ff_libilbc_encoder;
+extern const FFCodec ff_libilbc_decoder;
+extern const FFCodec ff_libjxl_decoder;
+extern const FFCodec ff_libjxl_encoder;
+extern const FFCodec ff_libmp3lame_encoder;
+extern const FFCodec ff_libopencore_amrnb_encoder;
+extern const FFCodec ff_libopencore_amrnb_decoder;
+extern const FFCodec ff_libopencore_amrwb_decoder;
+extern const FFCodec ff_libopenjpeg_encoder;
+extern const FFCodec ff_libopenjpeg_decoder;
+extern const FFCodec ff_libopus_encoder;
+extern const FFCodec ff_libopus_decoder;
+extern const FFCodec ff_librav1e_encoder;
+extern const FFCodec ff_librsvg_decoder;
+extern const FFCodec ff_libshine_encoder;
+extern const FFCodec ff_libspeex_encoder;
+extern const FFCodec ff_libspeex_decoder;
+extern const FFCodec ff_libsvtav1_encoder;
+extern const FFCodec ff_libtheora_encoder;
+extern const FFCodec ff_libtwolame_encoder;
+extern const FFCodec ff_libuavs3d_decoder;
+extern const FFCodec ff_libvo_amrwbenc_encoder;
+extern const FFCodec ff_libvorbis_encoder;
+extern const FFCodec ff_libvorbis_decoder;
+extern const FFCodec ff_libvpx_vp8_encoder;
+extern const FFCodec ff_libvpx_vp8_decoder;
+extern FFCodec ff_libvpx_vp9_encoder;
+extern FFCodec ff_libvpx_vp9_decoder;
 /* preferred over libwebp */
-extern AVCodec ff_libwebp_anim_encoder;
-extern AVCodec ff_libwebp_encoder;
-extern AVCodec ff_libx262_encoder;
-extern AVCodec ff_libx264_encoder;
-extern AVCodec ff_libx264rgb_encoder;
-extern AVCodec ff_libx265_encoder;
-extern AVCodec ff_libxavs_encoder;
-extern AVCodec ff_libxavs2_encoder;
-extern AVCodec ff_libxvid_encoder;
-extern AVCodec ff_libzvbi_teletext_decoder;
+extern const FFCodec ff_libwebp_anim_encoder;
+extern const FFCodec ff_libwebp_encoder;
+extern const FFCodec ff_libx262_encoder;
+#if CONFIG_LIBX264_ENCODER
+#include <x264.h>
+#if X264_BUILD < 153
+#define LIBX264_CONST
+#else
+#define LIBX264_CONST const
+#endif
+extern LIBX264_CONST FFCodec ff_libx264_encoder;
+#endif
+extern const FFCodec ff_libx264rgb_encoder;
+extern FFCodec ff_libx265_encoder;
+extern const FFCodec ff_libxavs_encoder;
+extern const FFCodec ff_libxavs2_encoder;
+extern const FFCodec ff_libxvid_encoder;
+extern const FFCodec ff_libzvbi_teletext_decoder;
 
 /* text */
-extern AVCodec ff_bintext_decoder;
-extern AVCodec ff_xbin_decoder;
-extern AVCodec ff_idf_decoder;
+extern const FFCodec ff_bintext_decoder;
+extern const FFCodec ff_xbin_decoder;
+extern const FFCodec ff_idf_decoder;
 
 /* external libraries, that shouldn't be used by default if one of the
  * above is available */
-extern AVCodec ff_aac_mf_encoder;
-extern AVCodec ff_ac3_mf_encoder;
-extern AVCodec ff_h263_v4l2m2m_encoder;
-extern AVCodec ff_libaom_av1_decoder;
+extern const FFCodec ff_aac_mf_encoder;
+extern const FFCodec ff_ac3_mf_encoder;
+extern const FFCodec ff_h263_v4l2m2m_encoder;
+extern const FFCodec ff_libaom_av1_decoder;
 /* hwaccel hooks only, so prefer external decoders */
-extern AVCodec ff_av1_decoder;
-extern AVCodec ff_av1_cuvid_decoder;
-extern AVCodec ff_av1_qsv_decoder;
-extern AVCodec ff_libopenh264_encoder;
-extern AVCodec ff_libopenh264_decoder;
-extern AVCodec ff_h264_amf_encoder;
-extern AVCodec ff_h264_cuvid_decoder;
-extern AVCodec ff_h264_mf_encoder;
-extern AVCodec ff_h264_nvenc_encoder;
-extern AVCodec ff_h264_omx_encoder;
-extern AVCodec ff_h264_qsv_encoder;
-extern AVCodec ff_h264_v4l2m2m_encoder;
-extern AVCodec ff_h264_vaapi_encoder;
-extern AVCodec ff_h264_videotoolbox_encoder;
-#if FF_API_NVENC_OLD_NAME
-extern AVCodec ff_nvenc_encoder;
-extern AVCodec ff_nvenc_h264_encoder;
-extern AVCodec ff_nvenc_hevc_encoder;
-#endif
-extern AVCodec ff_hevc_amf_encoder;
-extern AVCodec ff_hevc_cuvid_decoder;
-extern AVCodec ff_hevc_mediacodec_decoder;
-extern AVCodec ff_hevc_mf_encoder;
-extern AVCodec ff_hevc_nvenc_encoder;
-extern AVCodec ff_hevc_qsv_encoder;
-extern AVCodec ff_hevc_v4l2m2m_encoder;
-extern AVCodec ff_hevc_vaapi_encoder;
-extern AVCodec ff_hevc_videotoolbox_encoder;
-extern AVCodec ff_libkvazaar_encoder;
-extern AVCodec ff_mjpeg_cuvid_decoder;
-extern AVCodec ff_mjpeg_qsv_encoder;
-extern AVCodec ff_mjpeg_qsv_decoder;
-extern AVCodec ff_mjpeg_vaapi_encoder;
-extern AVCodec ff_mp3_mf_encoder;
-extern AVCodec ff_mpeg1_cuvid_decoder;
-extern AVCodec ff_mpeg2_cuvid_decoder;
-extern AVCodec ff_mpeg2_qsv_encoder;
-extern AVCodec ff_mpeg2_vaapi_encoder;
-extern AVCodec ff_mpeg4_cuvid_decoder;
-extern AVCodec ff_mpeg4_mediacodec_decoder;
-extern AVCodec ff_mpeg4_omx_encoder;
-extern AVCodec ff_mpeg4_v4l2m2m_encoder;
-extern AVCodec ff_vc1_cuvid_decoder;
-extern AVCodec ff_vp8_cuvid_decoder;
-extern AVCodec ff_vp8_mediacodec_decoder;
-extern AVCodec ff_vp8_qsv_decoder;
-extern AVCodec ff_vp8_v4l2m2m_encoder;
-extern AVCodec ff_vp8_vaapi_encoder;
-extern AVCodec ff_vp9_cuvid_decoder;
-extern AVCodec ff_vp9_mediacodec_decoder;
-extern AVCodec ff_vp9_qsv_decoder;
-extern AVCodec ff_vp9_vaapi_encoder;
-extern AVCodec ff_vp9_qsv_encoder;
+extern const FFCodec ff_av1_decoder;
+extern const FFCodec ff_av1_cuvid_decoder;
+extern const FFCodec ff_av1_mediacodec_decoder;
+extern const FFCodec ff_av1_nvenc_encoder;
+extern const FFCodec ff_av1_qsv_decoder;
+extern const FFCodec ff_av1_qsv_encoder;
+extern const FFCodec ff_av1_amf_encoder;
+extern const FFCodec ff_libopenh264_encoder;
+extern const FFCodec ff_libopenh264_decoder;
+extern const FFCodec ff_h264_amf_encoder;
+extern const FFCodec ff_h264_cuvid_decoder;
+extern const FFCodec ff_h264_mf_encoder;
+extern const FFCodec ff_h264_nvenc_encoder;
+extern const FFCodec ff_h264_omx_encoder;
+extern const FFCodec ff_h264_qsv_encoder;
+extern const FFCodec ff_h264_v4l2m2m_encoder;
+extern const FFCodec ff_h264_vaapi_encoder;
+extern const FFCodec ff_h264_videotoolbox_encoder;
+extern const FFCodec ff_hevc_amf_encoder;
+extern const FFCodec ff_hevc_cuvid_decoder;
+extern const FFCodec ff_hevc_mediacodec_decoder;
+extern const FFCodec ff_hevc_mediacodec_encoder;
+extern const FFCodec ff_hevc_mf_encoder;
+extern const FFCodec ff_hevc_nvenc_encoder;
+extern const FFCodec ff_hevc_qsv_encoder;
+extern const FFCodec ff_hevc_v4l2m2m_encoder;
+extern const FFCodec ff_hevc_vaapi_encoder;
+extern const FFCodec ff_hevc_videotoolbox_encoder;
+extern const FFCodec ff_libkvazaar_encoder;
+extern const FFCodec ff_mjpeg_cuvid_decoder;
+extern const FFCodec ff_mjpeg_qsv_encoder;
+extern const FFCodec ff_mjpeg_qsv_decoder;
+extern const FFCodec ff_mjpeg_vaapi_encoder;
+extern const FFCodec ff_mp3_mf_encoder;
+extern const FFCodec ff_mpeg1_cuvid_decoder;
+extern const FFCodec ff_mpeg2_cuvid_decoder;
+extern const FFCodec ff_mpeg2_qsv_encoder;
+extern const FFCodec ff_mpeg2_vaapi_encoder;
+extern const FFCodec ff_mpeg4_cuvid_decoder;
+extern const FFCodec ff_mpeg4_mediacodec_decoder;
+extern const FFCodec ff_mpeg4_omx_encoder;
+extern const FFCodec ff_mpeg4_v4l2m2m_encoder;
+extern const FFCodec ff_prores_videotoolbox_encoder;
+extern const FFCodec ff_vc1_cuvid_decoder;
+extern const FFCodec ff_vp8_cuvid_decoder;
+extern const FFCodec ff_vp8_mediacodec_decoder;
+extern const FFCodec ff_vp8_qsv_decoder;
+extern const FFCodec ff_vp8_v4l2m2m_encoder;
+extern const FFCodec ff_vp8_vaapi_encoder;
+extern const FFCodec ff_vp9_cuvid_decoder;
+extern const FFCodec ff_vp9_mediacodec_decoder;
+extern const FFCodec ff_vp9_qsv_decoder;
+extern const FFCodec ff_vp9_vaapi_encoder;
+extern const FFCodec ff_vp9_qsv_encoder;
+
+// null codecs
+extern const FFCodec ff_vnull_decoder;
+extern const FFCodec ff_vnull_encoder;
+extern const FFCodec ff_anull_decoder;
+extern const FFCodec ff_anull_encoder;
 
 // The iterate API is not usable with ossfuzz due to the excessive size of binaries created
 #if CONFIG_OSSFUZZ
-AVCodec * codec_list[] = {
+const FFCodec * codec_list[] = {
     NULL,
     NULL,
     NULL
@@ -852,62 +908,24 @@
 {
     for (int i = 0; codec_list[i]; i++) {
         if (codec_list[i]->init_static_data)
-            codec_list[i]->init_static_data((AVCodec*)codec_list[i]);
+            codec_list[i]->init_static_data((FFCodec*)codec_list[i]);
     }
 }
 
 const AVCodec *av_codec_iterate(void **opaque)
 {
     uintptr_t i = (uintptr_t)*opaque;
-    const AVCodec *c = codec_list[i];
+    const FFCodec *c = codec_list[i];
 
     ff_thread_once(&av_codec_static_init, av_codec_init_static);
 
-    if (c)
+    if (c) {
         *opaque = (void*)(i + 1);
-
-    return c;
-}
-
-#if FF_API_NEXT
-FF_DISABLE_DEPRECATION_WARNINGS
-static AVOnce av_codec_next_init = AV_ONCE_INIT;
-
-static void av_codec_init_next(void)
-{
-    AVCodec *prev = NULL, *p;
-    void *i = 0;
-    while ((p = (AVCodec*)av_codec_iterate(&i))) {
-        if (prev)
-            prev->next = p;
-        prev = p;
+        return &c->p;
     }
+    return NULL;
 }
 
-
-
-av_cold void avcodec_register(AVCodec *codec)
-{
-    ff_thread_once(&av_codec_next_init, av_codec_init_next);
-}
-
-AVCodec *av_codec_next(const AVCodec *c)
-{
-    ff_thread_once(&av_codec_next_init, av_codec_init_next);
-
-    if (c)
-        return c->next;
-    else
-        return (AVCodec*)codec_list[0];
-}
-
-void avcodec_register_all(void)
-{
-    ff_thread_once(&av_codec_next_init, av_codec_init_next);
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 static enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)
 {
     switch(id){
@@ -917,7 +935,7 @@
     }
 }
 
-static AVCodec *find_codec(enum AVCodecID id, int (*x)(const AVCodec *))
+static const AVCodec *find_codec(enum AVCodecID id, int (*x)(const AVCodec *))
 {
     const AVCodec *p, *experimental = NULL;
     void *i = 0;
@@ -931,24 +949,24 @@
             if (p->capabilities & AV_CODEC_CAP_EXPERIMENTAL && !experimental) {
                 experimental = p;
             } else
-                return (AVCodec*)p;
+                return p;
         }
     }
 
-    return (AVCodec*)experimental;
+    return experimental;
 }
 
-AVCodec *avcodec_find_encoder(enum AVCodecID id)
+const AVCodec *avcodec_find_encoder(enum AVCodecID id)
 {
     return find_codec(id, av_codec_is_encoder);
 }
 
-AVCodec *avcodec_find_decoder(enum AVCodecID id)
+const AVCodec *avcodec_find_decoder(enum AVCodecID id)
 {
     return find_codec(id, av_codec_is_decoder);
 }
 
-static AVCodec *find_codec_by_name(const char *name, int (*x)(const AVCodec *))
+static const AVCodec *find_codec_by_name(const char *name, int (*x)(const AVCodec *))
 {
     void *i = 0;
     const AVCodec *p;
@@ -960,18 +978,18 @@
         if (!x(p))
             continue;
         if (strcmp(name, p->name) == 0)
-            return (AVCodec*)p;
+            return p;
     }
 
     return NULL;
 }
 
-AVCodec *avcodec_find_encoder_by_name(const char *name)
+const AVCodec *avcodec_find_encoder_by_name(const char *name)
 {
     return find_codec_by_name(name, av_codec_is_encoder);
 }
 
-AVCodec *avcodec_find_decoder_by_name(const char *name)
+const AVCodec *avcodec_find_decoder_by_name(const char *name)
 {
     return find_codec_by_name(name, av_codec_is_decoder);
 }
diff -Naur a/media/ffvpx/libavcodec/arm/fft_init_arm.c b/media/ffvpx/libavcodec/arm/fft_init_arm.c
--- a/media/ffvpx/libavcodec/arm/fft_init_arm.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/arm/fft_init_arm.c	2023-04-06 12:50:06.970471013 +0200
@@ -48,8 +48,10 @@
 
     if (have_neon(cpu_flags)) {
 #if CONFIG_FFT
-        s->fft_permute  = ff_fft_permute_neon;
-        s->fft_calc     = ff_fft_calc_neon;
+        if (s->nbits < 17) {
+            s->fft_permute = ff_fft_permute_neon;
+            s->fft_calc    = ff_fft_calc_neon;
+        }
 #endif
 #if CONFIG_MDCT
         s->imdct_calc   = ff_imdct_calc_neon;
diff -Naur a/media/ffvpx/libavcodec/arm/flacdsp_init_arm.c b/media/ffvpx/libavcodec/arm/flacdsp_init_arm.c
--- a/media/ffvpx/libavcodec/arm/flacdsp_init_arm.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/arm/flacdsp_init_arm.c	2023-04-06 12:50:06.970471013 +0200
@@ -18,15 +18,13 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "libavutil/attributes.h"
 #include "libavcodec/flacdsp.h"
-#include "config.h"
 
 void ff_flac_lpc_16_arm(int32_t *samples, const int coeffs[32], int order,
                         int qlevel, int len);
 
-av_cold void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels,
-                                 int bps)
+av_cold void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels)
 {
-    if (CONFIG_FLAC_DECODER)
-        c->lpc16 = ff_flac_lpc_16_arm;
+    c->lpc16 = ff_flac_lpc_16_arm;
 }
diff -Naur a/media/ffvpx/libavcodec/atsc_a53.c b/media/ffvpx/libavcodec/atsc_a53.c
--- a/media/ffvpx/libavcodec/atsc_a53.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/atsc_a53.c	2023-04-06 12:49:40.250394769 +0200
@@ -73,7 +73,7 @@
     int ret, cc_count;
 
     if (size < 3)
-        return AVERROR(EINVAL);
+        return AVERROR_INVALIDDATA;
 
     ret = init_get_bits8(&gb, data, size);
     if (ret < 0)
@@ -95,12 +95,12 @@
 
     /* 3 bytes per CC plus one byte marker_bits at the end */
     if (cc_count * 3 >= (get_bits_left(&gb) >> 3))
-        return AVERROR(EINVAL);
+        return AVERROR_INVALIDDATA;
 
     new_size = (old_size + cc_count * 3);
 
     if (new_size > INT_MAX)
-        return AVERROR(EINVAL);
+        return AVERROR_INVALIDDATA;
 
     /* Allow merging of the cc data from two fields. */
     ret = av_buffer_realloc(pbuf, new_size);
diff -Naur a/media/ffvpx/libavcodec/av1dec.c b/media/ffvpx/libavcodec/av1dec.c
--- a/media/ffvpx/libavcodec/av1dec.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/av1dec.c	2023-04-06 12:50:24.490176462 +0200
@@ -18,15 +18,47 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config_components.h"
+
 #include "libavutil/film_grain_params.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
 #include "av1dec.h"
 #include "bytestream.h"
+#include "codec_internal.h"
+#include "decode.h"
 #include "hwconfig.h"
-#include "internal.h"
 #include "profiles.h"
+#include "thread.h"
+
+/**< same with Div_Lut defined in spec 7.11.3.7 */
+static const uint16_t div_lut[AV1_DIV_LUT_NUM] = {
+  16384, 16320, 16257, 16194, 16132, 16070, 16009, 15948, 15888, 15828, 15768,
+  15709, 15650, 15592, 15534, 15477, 15420, 15364, 15308, 15252, 15197, 15142,
+  15087, 15033, 14980, 14926, 14873, 14821, 14769, 14717, 14665, 14614, 14564,
+  14513, 14463, 14413, 14364, 14315, 14266, 14218, 14170, 14122, 14075, 14028,
+  13981, 13935, 13888, 13843, 13797, 13752, 13707, 13662, 13618, 13574, 13530,
+  13487, 13443, 13400, 13358, 13315, 13273, 13231, 13190, 13148, 13107, 13066,
+  13026, 12985, 12945, 12906, 12866, 12827, 12788, 12749, 12710, 12672, 12633,
+  12596, 12558, 12520, 12483, 12446, 12409, 12373, 12336, 12300, 12264, 12228,
+  12193, 12157, 12122, 12087, 12053, 12018, 11984, 11950, 11916, 11882, 11848,
+  11815, 11782, 11749, 11716, 11683, 11651, 11619, 11586, 11555, 11523, 11491,
+  11460, 11429, 11398, 11367, 11336, 11305, 11275, 11245, 11215, 11185, 11155,
+  11125, 11096, 11067, 11038, 11009, 10980, 10951, 10923, 10894, 10866, 10838,
+  10810, 10782, 10755, 10727, 10700, 10673, 10645, 10618, 10592, 10565, 10538,
+  10512, 10486, 10460, 10434, 10408, 10382, 10356, 10331, 10305, 10280, 10255,
+  10230, 10205, 10180, 10156, 10131, 10107, 10082, 10058, 10034, 10010, 9986,
+  9963,  9939,  9916,  9892,  9869,  9846,  9823,  9800,  9777,  9754,  9732,
+  9709,  9687,  9664,  9642,  9620,  9598,  9576,  9554,  9533,  9511,  9489,
+  9468,  9447,  9425,  9404,  9383,  9362,  9341,  9321,  9300,  9279,  9259,
+  9239,  9218,  9198,  9178,  9158,  9138,  9118,  9098,  9079,  9059,  9039,
+  9020,  9001,  8981,  8962,  8943,  8924,  8905,  8886,  8867,  8849,  8830,
+  8812,  8793,  8775,  8756,  8738,  8720,  8702,  8684,  8666,  8648,  8630,
+  8613,  8595,  8577,  8560,  8542,  8525,  8508,  8490,  8473,  8456,  8439,
+  8422,  8405,  8389,  8372,  8355,  8339,  8322,  8306,  8289,  8273,  8257,
+  8240,  8224,  8208,  8192
+};
 
 static uint32_t inverse_recenter(int r, uint32_t v)
 {
@@ -97,8 +129,72 @@
                                        -mx, mx + 1, r) << prec_diff) + round;
 }
 
+static uint64_t round_two(uint64_t x, uint16_t n)
+{
+    if (n == 0)
+        return x;
+    return ((x + ((uint64_t)1 << (n - 1))) >> n);
+}
+
+static int64_t round_two_signed(int64_t x, uint16_t n)
+{
+    return ((x<0) ? -((int64_t)round_two(-x, n)) : (int64_t)round_two(x, n));
+}
+
 /**
-* update gm type/params, since cbs already implemented part of this funcation,
+ * Resolve divisor process.
+ * see spec 7.11.3.7
+ */
+static int16_t resolve_divisor(uint32_t d, uint16_t *shift)
+{
+    int32_t e, f;
+
+    *shift = av_log2(d);
+    e = d - (1 << (*shift));
+    if (*shift > AV1_DIV_LUT_BITS)
+        f = round_two(e, *shift - AV1_DIV_LUT_BITS);
+    else
+        f = e << (AV1_DIV_LUT_BITS - (*shift));
+
+    *shift += AV1_DIV_LUT_PREC_BITS;
+
+    return div_lut[f];
+}
+
+/**
+ * check if global motion params is valid.
+ * see spec 7.11.3.6
+ */
+static uint8_t get_shear_params_valid(AV1DecContext *s, int idx)
+{
+    int16_t alpha, beta, gamma, delta, divf, divs;
+    int64_t v, w;
+    int32_t *param = &s->cur_frame.gm_params[idx][0];
+    if (param[2] < 0)
+        return 0;
+
+    alpha = av_clip_int16(param[2] - (1 << AV1_WARPEDMODEL_PREC_BITS));
+    beta  = av_clip_int16(param[3]);
+    divf  = resolve_divisor(abs(param[2]), &divs);
+    v     = (int64_t)param[4] * (1 << AV1_WARPEDMODEL_PREC_BITS);
+    w     = (int64_t)param[3] * param[4];
+    gamma = av_clip_int16((int)round_two_signed((v * divf), divs));
+    delta = av_clip_int16(param[5] - (int)round_two_signed((w * divf), divs) - (1 << AV1_WARPEDMODEL_PREC_BITS));
+
+    alpha = round_two_signed(alpha, AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
+    beta  = round_two_signed(beta,  AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
+    gamma = round_two_signed(gamma, AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
+    delta = round_two_signed(delta, AV1_WARP_PARAM_REDUCE_BITS) << AV1_WARP_PARAM_REDUCE_BITS;
+
+    if ((4 * abs(alpha) + 7 * abs(beta)) >= (1 << AV1_WARPEDMODEL_PREC_BITS) ||
+        (4 * abs(gamma) + 4 * abs(delta)) >= (1 << AV1_WARPEDMODEL_PREC_BITS))
+        return 0;
+
+    return 1;
+}
+
+/**
+* update gm type/params, since cbs already implemented part of this function,
 * so we don't need to full implement spec.
 */
 static void global_motion_params(AV1DecContext *s)
@@ -144,6 +240,9 @@
             read_global_param(s, type, ref, 0);
             read_global_param(s, type, ref, 1);
         }
+        if (type <= AV1_WARP_MODEL_AFFINE) {
+            s->cur_frame.gm_invalid[ref] = !get_shear_params_valid(s, ref);
+        }
     }
 }
 
@@ -342,7 +441,8 @@
 #define HWACCEL_MAX (CONFIG_AV1_DXVA2_HWACCEL + \
                      CONFIG_AV1_D3D11VA_HWACCEL * 2 + \
                      CONFIG_AV1_NVDEC_HWACCEL + \
-                     CONFIG_AV1_VAAPI_HWACCEL)
+                     CONFIG_AV1_VAAPI_HWACCEL + \
+                     CONFIG_AV1_VDPAU_HWACCEL)
     enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmtp = pix_fmts;
 
     if (seq->seq_profile == 2 && seq->color_config.high_bitdepth)
@@ -404,9 +504,8 @@
 
     if (pix_fmt == AV_PIX_FMT_NONE)
         return -1;
-    s->pix_fmt = pix_fmt;
 
-    switch (s->pix_fmt) {
+    switch (pix_fmt) {
     case AV_PIX_FMT_YUV420P:
 #if CONFIG_AV1_DXVA2_HWACCEL
         *fmtp++ = AV_PIX_FMT_DXVA2_VLD;
@@ -421,6 +520,9 @@
 #if CONFIG_AV1_VAAPI_HWACCEL
         *fmtp++ = AV_PIX_FMT_VAAPI;
 #endif
+#if CONFIG_AV1_VDPAU_HWACCEL
+        *fmtp++ = AV_PIX_FMT_VDPAU;
+#endif
         break;
     case AV_PIX_FMT_YUV420P10:
 #if CONFIG_AV1_DXVA2_HWACCEL
@@ -436,6 +538,9 @@
 #if CONFIG_AV1_VAAPI_HWACCEL
         *fmtp++ = AV_PIX_FMT_VAAPI;
 #endif
+#if CONFIG_AV1_VDPAU_HWACCEL
+        *fmtp++ = AV_PIX_FMT_VDPAU;
+#endif
         break;
     case AV_PIX_FMT_GRAY8:
 #if CONFIG_AV1_NVDEC_HWACCEL
@@ -449,7 +554,7 @@
         break;
     }
 
-    *fmtp++ = s->pix_fmt;
+    *fmtp++ = pix_fmt;
     *fmtp = AV_PIX_FMT_NONE;
 
     ret = ff_thread_get_format(avctx, pix_fmts);
@@ -462,11 +567,12 @@
      * implemented in the future, need remove this check.
      */
     if (!avctx->hwaccel) {
-        av_log(avctx, AV_LOG_ERROR, "Your platform doesn't suppport"
+        av_log(avctx, AV_LOG_ERROR, "Your platform doesn't support"
                " hardware accelerated AV1 decoding.\n");
         return AVERROR(ENOSYS);
     }
 
+    s->pix_fmt = pix_fmt;
     avctx->pix_fmt = ret;
 
     return 0;
@@ -474,7 +580,7 @@
 
 static void av1_frame_unref(AVCodecContext *avctx, AV1Frame *f)
 {
-    ff_thread_release_buffer(avctx, &f->tf);
+    ff_thread_release_buffer(avctx, f->f);
     av_buffer_unref(&f->hwaccel_priv_buf);
     f->hwaccel_picture_private = NULL;
     av_buffer_unref(&f->header_ref);
@@ -490,16 +596,19 @@
 {
     int ret;
 
-    ret = ff_thread_ref_frame(&dst->tf, &src->tf);
+    ret = av_buffer_replace(&dst->header_ref, src->header_ref);
     if (ret < 0)
         return ret;
 
-    dst->header_ref = av_buffer_ref(src->header_ref);
-    if (!dst->header_ref)
-        goto fail;
-
     dst->raw_frame_header = src->raw_frame_header;
 
+    if (!src->f->buf[0])
+        return 0;
+
+    ret = av_frame_ref(dst->f, src->f);
+    if (ret < 0)
+        goto fail;
+
     if (src->hwaccel_picture_private) {
         dst->hwaccel_priv_buf = av_buffer_ref(src->hwaccel_priv_buf);
         if (!dst->hwaccel_priv_buf)
@@ -509,6 +618,9 @@
 
     dst->spatial_id = src->spatial_id;
     dst->temporal_id = src->temporal_id;
+    memcpy(dst->gm_invalid,
+           src->gm_invalid,
+           AV1_NUM_REF_FRAMES * sizeof(uint8_t));
     memcpy(dst->gm_type,
            src->gm_type,
            AV1_NUM_REF_FRAMES * sizeof(uint8_t));
@@ -536,10 +648,10 @@
 
     for (int i = 0; i < FF_ARRAY_ELEMS(s->ref); i++) {
         av1_frame_unref(avctx, &s->ref[i]);
-        av_frame_free(&s->ref[i].tf.f);
+        av_frame_free(&s->ref[i].f);
     }
     av1_frame_unref(avctx, &s->cur_frame);
-    av_frame_free(&s->cur_frame.tf.f);
+    av_frame_free(&s->cur_frame.f);
 
     av_buffer_unref(&s->seq_ref);
     av_buffer_unref(&s->header_ref);
@@ -575,6 +687,11 @@
         break;
     }
 
+    if (seq->film_grain_params_present)
+        avctx->properties |= FF_CODEC_PROPERTY_FILM_GRAIN;
+    else
+        avctx->properties &= ~FF_CODEC_PROPERTY_FILM_GRAIN;
+
     if (avctx->width != width || avctx->height != height) {
         int ret = ff_set_dimensions(avctx, width, height);
         if (ret < 0)
@@ -635,16 +752,16 @@
     s->pix_fmt = AV_PIX_FMT_NONE;
 
     for (int i = 0; i < FF_ARRAY_ELEMS(s->ref); i++) {
-        s->ref[i].tf.f = av_frame_alloc();
-        if (!s->ref[i].tf.f) {
+        s->ref[i].f = av_frame_alloc();
+        if (!s->ref[i].f) {
             av_log(avctx, AV_LOG_ERROR,
                    "Failed to allocate reference frame buffer %d.\n", i);
             return AVERROR(ENOMEM);
         }
     }
 
-    s->cur_frame.tf.f = av_frame_alloc();
-    if (!s->cur_frame.tf.f) {
+    s->cur_frame.f = av_frame_alloc();
+    if (!s->cur_frame.f) {
         av_log(avctx, AV_LOG_ERROR,
                "Failed to allocate current frame buffer.\n");
         return AVERROR(ENOMEM);
@@ -697,16 +814,10 @@
         return ret;
     }
 
-    f->header_ref = av_buffer_ref(s->header_ref);
-    if (!f->header_ref)
-        return AVERROR(ENOMEM);
-
-    f->raw_frame_header = s->raw_frame_header;
-
-    if ((ret = ff_thread_get_buffer(avctx, &f->tf, AV_GET_BUFFER_FLAG_REF)) < 0)
+    if ((ret = ff_thread_get_buffer(avctx, f->f, AV_GET_BUFFER_FLAG_REF)) < 0)
         goto fail;
 
-    frame = f->tf.f;
+    frame = f->f;
     frame->key_frame = header->frame_type == AV1_FRAME_KEY;
 
     switch (header->frame_type) {
@@ -805,7 +916,7 @@
                             const AVPacket *pkt, int *got_frame)
 {
     AV1DecContext *s = avctx->priv_data;
-    const AVFrame *srcframe = s->cur_frame.tf.f;
+    const AVFrame *srcframe = s->cur_frame.f;
     int ret;
 
     // TODO: all layers
@@ -842,8 +953,7 @@
 
     for (int i = 0; i < AV1_NUM_REF_FRAMES; i++) {
         if (header->refresh_frame_flags & (1 << i)) {
-            if (s->ref[i].tf.f->buf[0])
-                av1_frame_unref(avctx, &s->ref[i]);
+            av1_frame_unref(avctx, &s->ref[i]);
             if ((ret = av1_frame_ref(avctx, &s->ref[i], &s->cur_frame)) < 0) {
                 av_log(avctx, AV_LOG_ERROR,
                        "Failed to update frame %d in reference list\n", i);
@@ -859,19 +969,32 @@
     AV1DecContext *s = avctx->priv_data;
     int ret;
 
-    if (s->cur_frame.tf.f->buf[0])
-        av1_frame_unref(avctx, &s->cur_frame);
+    av1_frame_unref(avctx, &s->cur_frame);
 
-    ret = av1_frame_alloc(avctx, &s->cur_frame);
+    s->cur_frame.header_ref = av_buffer_ref(s->header_ref);
+    if (!s->cur_frame.header_ref)
+        return AVERROR(ENOMEM);
+
+    s->cur_frame.raw_frame_header = s->raw_frame_header;
+
+    ret = init_tile_data(s);
     if (ret < 0) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Failed to allocate space for current frame.\n");
+        av_log(avctx, AV_LOG_ERROR, "Failed to init tile data.\n");
         return ret;
     }
 
-    ret = init_tile_data(s);
+    if ((avctx->skip_frame >= AVDISCARD_NONINTRA &&
+            (s->raw_frame_header->frame_type != AV1_FRAME_KEY &&
+             s->raw_frame_header->frame_type != AV1_FRAME_INTRA_ONLY)) ||
+        (avctx->skip_frame >= AVDISCARD_NONKEY   &&
+             s->raw_frame_header->frame_type != AV1_FRAME_KEY) ||
+        avctx->skip_frame >= AVDISCARD_ALL)
+        return 0;
+
+    ret = av1_frame_alloc(avctx, &s->cur_frame);
     if (ret < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to init tile data.\n");
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to allocate space for current frame.\n");
         return ret;
     }
 
@@ -883,7 +1006,7 @@
     return ret;
 }
 
-static int av1_decode_frame(AVCodecContext *avctx, void *frame,
+static int av1_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                             int *got_frame, AVPacket *pkt)
 {
     AV1DecContext *s = avctx->priv_data;
@@ -974,8 +1097,7 @@
                 s->raw_frame_header = &obu->obu.frame_header;
 
             if (s->raw_frame_header->show_existing_frame) {
-                if (s->cur_frame.tf.f->buf[0])
-                    av1_frame_unref(avctx, &s->cur_frame);
+                av1_frame_unref(avctx, &s->cur_frame);
 
                 ret = av1_frame_ref(avctx, &s->cur_frame,
                                     &s->ref[s->raw_frame_header->frame_to_show_map_idx]);
@@ -990,9 +1112,11 @@
                     goto end;
                 }
 
-                ret = set_output_frame(avctx, frame, pkt, got_frame);
-                if (ret < 0)
-                    av_log(avctx, AV_LOG_ERROR, "Set output frame error.\n");
+                if (s->cur_frame.f->buf[0]) {
+                    ret = set_output_frame(avctx, frame, pkt, got_frame);
+                    if (ret < 0)
+                        av_log(avctx, AV_LOG_ERROR, "Set output frame error.\n");
+                }
 
                 s->raw_frame_header = NULL;
 
@@ -1008,7 +1132,7 @@
             s->cur_frame.spatial_id  = header->spatial_id;
             s->cur_frame.temporal_id = header->temporal_id;
 
-            if (avctx->hwaccel) {
+            if (avctx->hwaccel && s->cur_frame.f->buf[0]) {
                 ret = avctx->hwaccel->start_frame(avctx, unit->data,
                                                   unit->data_size);
                 if (ret < 0) {
@@ -1035,7 +1159,7 @@
             if (ret < 0)
                 goto end;
 
-            if (avctx->hwaccel) {
+            if (avctx->hwaccel && s->cur_frame.f->buf[0]) {
                 ret = avctx->hwaccel->decode_slice(avctx,
                                                    raw_tile_group->tile_data.data,
                                                    raw_tile_group->tile_data.data_size);
@@ -1058,7 +1182,7 @@
         }
 
         if (raw_tile_group && (s->tile_num == raw_tile_group->tg_end + 1)) {
-            if (avctx->hwaccel) {
+            if (avctx->hwaccel && s->cur_frame.f->buf[0]) {
                 ret = avctx->hwaccel->end_frame(avctx);
                 if (ret < 0) {
                     av_log(avctx, AV_LOG_ERROR, "HW accel end frame fail.\n");
@@ -1072,7 +1196,7 @@
                 goto end;
             }
 
-            if (s->raw_frame_header->show_frame) {
+            if (s->raw_frame_header->show_frame && s->cur_frame.f->buf[0]) {
                 ret = set_output_frame(avctx, frame, pkt, got_frame);
                 if (ret < 0) {
                     av_log(avctx, AV_LOG_ERROR, "Set output frame error\n");
@@ -1121,22 +1245,22 @@
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
-AVCodec ff_av1_decoder = {
-    .name                  = "av1",
-    .long_name             = NULL_IF_CONFIG_SMALL("Alliance for Open Media AV1"),
-    .type                  = AVMEDIA_TYPE_VIDEO,
-    .id                    = AV_CODEC_ID_AV1,
+const FFCodec ff_av1_decoder = {
+    .p.name                = "av1",
+    CODEC_LONG_NAME("Alliance for Open Media AV1"),
+    .p.type                = AVMEDIA_TYPE_VIDEO,
+    .p.id                  = AV_CODEC_ID_AV1,
     .priv_data_size        = sizeof(AV1DecContext),
     .init                  = av1_decode_init,
     .close                 = av1_decode_free,
-    .decode                = av1_decode_frame,
-    .capabilities          = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_AVOID_PROBING,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_INIT_CLEANUP |
+    FF_CODEC_DECODE_CB(av1_decode_frame),
+    .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_AVOID_PROBING,
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
                              FF_CODEC_CAP_SETS_PKT_DTS,
     .flush                 = av1_decode_flush,
-    .profiles              = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
-    .priv_class            = &av1_class,
+    .p.profiles            = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
+    .p.priv_class          = &av1_class,
+    .bsfs                  = "av1_frame_split",
     .hw_configs            = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_AV1_DXVA2_HWACCEL
         HWACCEL_DXVA2(av1),
@@ -1153,6 +1277,10 @@
 #if CONFIG_AV1_VAAPI_HWACCEL
         HWACCEL_VAAPI(av1),
 #endif
+#if CONFIG_AV1_VDPAU_HWACCEL
+        HWACCEL_VDPAU(av1),
+#endif
+
         NULL
     },
 };
diff -Naur a/media/ffvpx/libavcodec/av1dec.h b/media/ffvpx/libavcodec/av1dec.h
--- a/media/ffvpx/libavcodec/av1dec.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/av1dec.h	2023-04-06 12:49:40.250394769 +0200
@@ -24,14 +24,14 @@
 #include <stdint.h>
 
 #include "libavutil/buffer.h"
+#include "libavutil/frame.h"
 #include "libavutil/pixfmt.h"
 #include "avcodec.h"
 #include "cbs.h"
 #include "cbs_av1.h"
-#include "thread.h"
 
 typedef struct AV1Frame {
-    ThreadFrame tf;
+    AVFrame *f;
 
     AVBufferRef *hwaccel_priv_buf;
     void *hwaccel_picture_private;
@@ -42,6 +42,7 @@
     int temporal_id;
     int spatial_id;
 
+    uint8_t gm_invalid[AV1_NUM_REF_FRAMES];
     uint8_t gm_type[AV1_NUM_REF_FRAMES];
     int32_t gm_params[AV1_NUM_REF_FRAMES][6];
 
diff -Naur a/media/ffvpx/libavcodec/av1.h b/media/ffvpx/libavcodec/av1.h
--- a/media/ffvpx/libavcodec/av1.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/av1.h	2023-04-06 12:50:06.970471013 +0200
@@ -114,6 +114,13 @@
     AV1_WARP_MODEL_TRANSLATION = 1,
     AV1_WARP_MODEL_ROTZOOM     = 2,
     AV1_WARP_MODEL_AFFINE      = 3,
+    AV1_WARP_PARAM_REDUCE_BITS = 6,
+
+    AV1_DIV_LUT_BITS      = 8,
+    AV1_DIV_LUT_PREC_BITS = 14,
+    AV1_DIV_LUT_NUM       = 257,
+
+    AV1_MAX_LOOP_FILTER = 63,
 };
 
 
@@ -168,4 +175,10 @@
     AV1_RESTORE_SWITCHABLE = 3,
 };
 
+// Sequence Headers are actually unbounded because one can use
+// an arbitrary number of leading zeroes when encoding via uvlc.
+// The following estimate is based around using the lowest number
+// of bits for uvlc encoding.
+#define AV1_SANE_SEQUENCE_HEADER_MAX_BITS           3138
+
 #endif /* AVCODEC_AV1_H */
diff -Naur a/media/ffvpx/libavcodec/av1_parse.h b/media/ffvpx/libavcodec/av1_parse.h
--- a/media/ffvpx/libavcodec/av1_parse.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/av1_parse.h	2023-04-06 12:49:40.250394769 +0200
@@ -21,10 +21,14 @@
 #ifndef AVCODEC_AV1_PARSE_H
 #define AVCODEC_AV1_PARSE_H
 
+#include <limits.h>
 #include <stdint.h>
 
+#include "libavutil/error.h"
+#include "libavutil/intmath.h"
+#include "libavutil/macros.h"
+
 #include "av1.h"
-#include "avcodec.h"
 #include "get_bits.h"
 
 // OBU header fields + max leb128 length
diff -Naur a/media/ffvpx/libavcodec/av1_parser.c b/media/ffvpx/libavcodec/av1_parser.c
--- a/media/ffvpx/libavcodec/av1_parser.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/av1_parser.c	2023-04-06 12:50:24.490176462 +0200
@@ -20,10 +20,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "av1_parse.h"
+#include "libavutil/avassert.h"
 #include "cbs.h"
 #include "cbs_av1.h"
-#include "internal.h"
 #include "parser.h"
 
 typedef struct AV1ParseContext {
@@ -56,9 +55,9 @@
 {
     AV1ParseContext *s = ctx->priv_data;
     CodedBitstreamFragment *td = &s->temporal_unit;
-    CodedBitstreamAV1Context *av1 = s->cbc->priv_data;
-    AV1RawSequenceHeader *seq;
-    AV1RawColorConfig *color;
+    const CodedBitstreamAV1Context *av1 = s->cbc->priv_data;
+    const AV1RawSequenceHeader *seq;
+    const AV1RawColorConfig *color;
     int ret;
 
     *out_data = data;
@@ -96,9 +95,9 @@
     color = &seq->color_config;
 
     for (int i = 0; i < td->nb_units; i++) {
-        CodedBitstreamUnit *unit = &td->units[i];
-        AV1RawOBU *obu = unit->content;
-        AV1RawFrameHeader *frame;
+        const CodedBitstreamUnit *unit = &td->units[i];
+        const AV1RawOBU *obu = unit->content;
+        const AV1RawFrameHeader *frame;
 
         if (unit->type == AV1_OBU_FRAME)
             frame = &obu->obu.frame.header;
@@ -163,8 +162,11 @@
     avctx->color_trc = (enum AVColorTransferCharacteristic) color->transfer_characteristics;
     avctx->color_range = color->color_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;
 
-    if (avctx->framerate.num)
-        avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
+    if (seq->timing_info_present_flag) {
+        const AV1RawTimingInfo *timing = &seq->timing_info;
+        av_reduce(&avctx->framerate.den, &avctx->framerate.num,
+                  timing->num_units_in_display_tick, timing->time_scale, INT_MAX);
+    }
 
 end:
     ff_cbs_fragment_reset(td);
@@ -205,33 +207,10 @@
     ff_cbs_close(&s->cbc);
 }
 
-static int av1_parser_split(AVCodecContext *avctx,
-                            const uint8_t *buf, int buf_size)
-{
-    AV1OBU obu;
-    const uint8_t *ptr = buf, *end = buf + buf_size;
-
-    while (ptr < end) {
-        int len = ff_av1_extract_obu(&obu, ptr, buf_size, avctx);
-        if (len < 0)
-            break;
-
-        if (obu.type == AV1_OBU_FRAME_HEADER ||
-            obu.type == AV1_OBU_FRAME) {
-            return ptr - buf;
-        }
-        ptr      += len;
-        buf_size -= len;
-    }
-
-    return 0;
-}
-
-AVCodecParser ff_av1_parser = {
+const AVCodecParser ff_av1_parser = {
     .codec_ids      = { AV_CODEC_ID_AV1 },
     .priv_data_size = sizeof(AV1ParseContext),
     .parser_init    = av1_parser_init,
     .parser_close   = av1_parser_close,
     .parser_parse   = av1_parser_parse,
-    .split          = av1_parser_split,
 };
diff -Naur a/media/ffvpx/libavcodec/avcodec.c b/media/ffvpx/libavcodec/avcodec.c
--- a/media/ffvpx/libavcodec/avcodec.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/avcodec.c	2023-04-06 12:50:24.490176462 +0200
@@ -26,43 +26,21 @@
 #include "config.h"
 #include "libavutil/avassert.h"
 #include "libavutil/avstring.h"
+#include "libavutil/bprint.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/fifo.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/mem.h"
 #include "libavutil/opt.h"
 #include "libavutil/thread.h"
 #include "avcodec.h"
+#include "bsf.h"
+#include "codec_internal.h"
 #include "decode.h"
 #include "encode.h"
 #include "frame_thread_encoder.h"
 #include "internal.h"
 #include "thread.h"
-#if CONFIG_ICONV
-# include <iconv.h>
-#endif
-
-#include "libavutil/ffversion.h"
-const char av_codec_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
-
-unsigned avcodec_version(void)
-{
-    av_assert0(AV_CODEC_ID_PCM_S8_PLANAR==65563);
-    av_assert0(AV_CODEC_ID_ADPCM_G722==69660);
-    av_assert0(AV_CODEC_ID_SRT==94216);
-    av_assert0(LIBAVCODEC_VERSION_MICRO >= 100);
-
-    return LIBAVCODEC_VERSION_INT;
-}
-
-const char *avcodec_configuration(void)
-{
-    return FFMPEG_CONFIGURATION;
-}
-
-const char *avcodec_license(void)
-{
-#define LICENSE_PREFIX "libavcodec license: "
-    return &LICENSE_PREFIX FFMPEG_LICENSE[sizeof(LICENSE_PREFIX) - 1];
-}
 
 int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size)
 {
@@ -92,25 +70,18 @@
 
 static AVMutex codec_mutex = AV_MUTEX_INITIALIZER;
 
-static void lock_avcodec(const AVCodec *codec)
+static void lock_avcodec(const FFCodec *codec)
 {
-    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)
+    if (codec->caps_internal & FF_CODEC_CAP_NOT_INIT_THREADSAFE && codec->init)
         ff_mutex_lock(&codec_mutex);
 }
 
-static void unlock_avcodec(const AVCodec *codec)
+static void unlock_avcodec(const FFCodec *codec)
 {
-    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)
+    if (codec->caps_internal & FF_CODEC_CAP_NOT_INIT_THREADSAFE && codec->init)
         ff_mutex_unlock(&codec_mutex);
 }
 
-#if FF_API_LOCKMGR
-int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))
-{
-    return 0;
-}
-#endif
-
 static int64_t get_bit_rate(AVCodecContext *ctx)
 {
     int64_t bit_rate;
@@ -126,7 +97,7 @@
     case AVMEDIA_TYPE_AUDIO:
         bits_per_sample = av_get_bits_per_sample(ctx->codec_id);
         if (bits_per_sample) {
-            bit_rate = ctx->sample_rate * (int64_t)ctx->channels;
+            bit_rate = ctx->sample_rate * (int64_t)ctx->ch_layout.nb_channels;
             if (bit_rate > INT64_MAX / bits_per_sample) {
                 bit_rate = 0;
             } else
@@ -144,9 +115,8 @@
 int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
 {
     int ret = 0;
-    int codec_init_ok = 0;
-    AVDictionary *tmp = NULL;
     AVCodecInternal *avci;
+    const FFCodec *codec2;
 
     if (avcodec_is_open(avctx))
         return 0;
@@ -162,14 +132,20 @@
     }
     if (!codec)
         codec = avctx->codec;
+    codec2 = ffcodec(codec);
 
-    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)
+    if ((avctx->codec_type != AVMEDIA_TYPE_UNKNOWN && avctx->codec_type != codec->type) ||
+        (avctx->codec_id   != AV_CODEC_ID_NONE     && avctx->codec_id   != codec->id)) {
+        av_log(avctx, AV_LOG_ERROR, "Codec type or id mismatches\n");
         return AVERROR(EINVAL);
+    }
 
-    if (options)
-        av_dict_copy(&tmp, *options, 0);
+    avctx->codec_type = codec->type;
+    avctx->codec_id   = codec->id;
+    avctx->codec      = codec;
 
-    lock_avcodec(codec);
+    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)
+        return AVERROR(EINVAL);
 
     avci = av_mallocz(sizeof(*avci));
     if (!avci) {
@@ -178,33 +154,16 @@
     }
     avctx->internal = avci;
 
-#if FF_API_OLD_ENCDEC
-    avci->to_free = av_frame_alloc();
-    avci->compat_decode_frame = av_frame_alloc();
-    avci->compat_encode_packet = av_packet_alloc();
-    if (!avci->to_free || !avci->compat_decode_frame || !avci->compat_encode_packet) {
-        ret = AVERROR(ENOMEM);
-        goto free_and_end;
-    }
-#endif
     avci->buffer_frame = av_frame_alloc();
     avci->buffer_pkt = av_packet_alloc();
-    avci->es.in_frame = av_frame_alloc();
-    avci->ds.in_pkt = av_packet_alloc();
-    avci->last_pkt_props = av_packet_alloc();
-    avci->pkt_props = av_fifo_alloc(sizeof(*avci->last_pkt_props));
-    if (!avci->buffer_frame || !avci->buffer_pkt          ||
-        !avci->es.in_frame  || !avci->ds.in_pkt           ||
-        !avci->last_pkt_props || !avci->pkt_props) {
+    if (!avci->buffer_frame || !avci->buffer_pkt) {
         ret = AVERROR(ENOMEM);
         goto free_and_end;
     }
 
-    avci->skip_samples_multiplier = 1;
-
-    if (codec->priv_data_size > 0) {
+    if (codec2->priv_data_size > 0) {
         if (!avctx->priv_data) {
-            avctx->priv_data = av_mallocz(codec->priv_data_size);
+            avctx->priv_data = av_mallocz(codec2->priv_data_size);
             if (!avctx->priv_data) {
                 ret = AVERROR(ENOMEM);
                 goto free_and_end;
@@ -214,12 +173,12 @@
                 av_opt_set_defaults(avctx->priv_data);
             }
         }
-        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)
+        if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, options)) < 0)
             goto free_and_end;
     } else {
         avctx->priv_data = NULL;
     }
-    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)
+    if ((ret = av_opt_set_dict(avctx, options)) < 0)
         goto free_and_end;
 
     if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {
@@ -256,44 +215,63 @@
         }
     }
 
-    if (avctx->channels > FF_SANE_NB_CHANNELS || avctx->channels < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Too many or invalid channels: %d\n", avctx->channels);
+    if (avctx->sample_rate < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid sample rate: %d\n", avctx->sample_rate);
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
-    if (av_codec_is_decoder(codec) &&
-        codec->type == AVMEDIA_TYPE_AUDIO &&
-        !(codec->capabilities & AV_CODEC_CAP_CHANNEL_CONF) &&
-        avctx->channels == 0) {
-        av_log(avctx, AV_LOG_ERROR, "Decoder requires channel count but channels not set\n");
+    if (avctx->block_align < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid block align: %d\n", avctx->block_align);
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
 
-    if (avctx->sample_rate < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid sample rate: %d\n", avctx->sample_rate);
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+    /* compat wrapper for old-style callers */
+    if (avctx->channel_layout && !avctx->channels)
+        avctx->channels = av_popcount64(avctx->channel_layout);
+
+    if ((avctx->channels && avctx->ch_layout.nb_channels != avctx->channels) ||
+        (avctx->channel_layout && (avctx->ch_layout.order != AV_CHANNEL_ORDER_NATIVE ||
+                                   avctx->ch_layout.u.mask != avctx->channel_layout))) {
+        av_channel_layout_uninit(&avctx->ch_layout);
+        if (avctx->channel_layout) {
+            av_channel_layout_from_mask(&avctx->ch_layout, avctx->channel_layout);
+        } else {
+            avctx->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+        }
+        avctx->ch_layout.nb_channels = avctx->channels;
+    }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+    /* AV_CODEC_CAP_CHANNEL_CONF is a decoder-only flag; so the code below
+     * in particular checks that nb_channels is set for all audio encoders. */
+    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && !avctx->ch_layout.nb_channels
+        && !(codec->capabilities & AV_CODEC_CAP_CHANNEL_CONF)) {
+        av_log(avctx, AV_LOG_ERROR, "%s requires channel layout to be set\n",
+               av_codec_is_decoder(codec) ? "Decoder" : "Encoder");
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
-    if (avctx->block_align < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid block align: %d\n", avctx->block_align);
+    if (avctx->ch_layout.nb_channels && !av_channel_layout_check(&avctx->ch_layout)) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid channel layout\n");
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
-
-    avctx->codec = codec;
-    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&
-        avctx->codec_id == AV_CODEC_ID_NONE) {
-        avctx->codec_type = codec->type;
-        avctx->codec_id   = codec->id;
-    }
-    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type
-                                         && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {
-        av_log(avctx, AV_LOG_ERROR, "Codec type or id mismatches\n");
+    if (avctx->ch_layout.nb_channels > FF_SANE_NB_CHANNELS) {
+        av_log(avctx, AV_LOG_ERROR, "Too many channels: %d\n", avctx->ch_layout.nb_channels);
         ret = AVERROR(EINVAL);
         goto free_and_end;
     }
-    avctx->frame_number = 0;
+
+    avctx->frame_num = 0;
+#if FF_API_AVCTX_FRAME_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->frame_number = avctx->frame_num;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);
 
     if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
@@ -325,35 +303,30 @@
     if (ret < 0)
         goto free_and_end;
 
-    if (!HAVE_THREADS)
-        av_log(avctx, AV_LOG_WARNING, "Warning: not compiled with thread support, using thread emulation\n");
-
-    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {
-        unlock_avcodec(codec); //we will instantiate a few encoders thus kick the counter to prevent false detection of a problem
-        ret = ff_frame_thread_encoder_init(avctx, options ? *options : NULL);
-        lock_avcodec(codec);
-        if (ret < 0)
-            goto free_and_end;
-    }
-
-    if (HAVE_THREADS
-        && !(avci->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {
+    if (HAVE_THREADS && !avci->frame_thread_encoder) {
+        /* Frame-threaded decoders call FFCodec.init for their child contexts. */
+        lock_avcodec(codec2);
         ret = ff_thread_init(avctx);
+        unlock_avcodec(codec2);
         if (ret < 0) {
             goto free_and_end;
         }
     }
-    if (!HAVE_THREADS && !(codec->caps_internal & FF_CODEC_CAP_AUTO_THREADS))
+    if (!HAVE_THREADS && !(codec2->caps_internal & FF_CODEC_CAP_AUTO_THREADS))
         avctx->thread_count = 1;
 
-    if (   avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME)
-        || avci->frame_thread_encoder)) {
-        ret = avctx->codec->init(avctx);
-        if (ret < 0) {
-            codec_init_ok = -1;
-            goto free_and_end;
+    if (!(avctx->active_thread_type & FF_THREAD_FRAME) ||
+        avci->frame_thread_encoder) {
+        if (codec2->init) {
+            lock_avcodec(codec2);
+            ret = codec2->init(avctx);
+            unlock_avcodec(codec2);
+            if (ret < 0) {
+                avci->needs_close = codec2->caps_internal & FF_CODEC_CAP_INIT_CLEANUP;
+                goto free_and_end;
+            }
         }
-        codec_init_ok = 1;
+        avci->needs_close = 1;
     }
 
     ret=0;
@@ -361,23 +334,19 @@
     if (av_codec_is_decoder(avctx->codec)) {
         if (!avctx->bit_rate)
             avctx->bit_rate = get_bit_rate(avctx);
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        /* update the deprecated fields for old-style callers */
+        avctx->channels = avctx->ch_layout.nb_channels;
+        avctx->channel_layout = avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
+                                avctx->ch_layout.u.mask : 0;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
         /* validate channel layout from the decoder */
-        if (avctx->channel_layout) {
-            int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
-            if (!avctx->channels)
-                avctx->channels = channels;
-            else if (channels != avctx->channels) {
-                char buf[512];
-                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
-                av_log(avctx, AV_LOG_WARNING,
-                       "Channel layout '%s' with %d channels does not match specified number of channels %d: "
-                       "ignoring specified channel layout\n",
-                       buf, channels, avctx->channels);
-                avctx->channel_layout = 0;
-            }
-        }
-        if (avctx->channels && avctx->channels < 0 ||
-            avctx->channels > FF_SANE_NB_CHANNELS) {
+        if ((avctx->ch_layout.nb_channels && !av_channel_layout_check(&avctx->ch_layout)) ||
+            avctx->ch_layout.nb_channels > FF_SANE_NB_CHANNELS) {
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
@@ -385,106 +354,15 @@
             ret = AVERROR(EINVAL);
             goto free_and_end;
         }
-        if (avctx->sub_charenc) {
-            if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {
-                av_log(avctx, AV_LOG_ERROR, "Character encoding is only "
-                       "supported with subtitles codecs\n");
-                ret = AVERROR(EINVAL);
-                goto free_and_end;
-            } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {
-                av_log(avctx, AV_LOG_WARNING, "Codec '%s' is bitmap-based, "
-                       "subtitles character encoding will be ignored\n",
-                       avctx->codec_descriptor->name);
-                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;
-            } else {
-                /* input character encoding is set for a text based subtitle
-                 * codec at this point */
-                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)
-                    avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;
-
-                if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {
-#if CONFIG_ICONV
-                    iconv_t cd = iconv_open("UTF-8", avctx->sub_charenc);
-                    if (cd == (iconv_t)-1) {
-                        ret = AVERROR(errno);
-                        av_log(avctx, AV_LOG_ERROR, "Unable to open iconv context "
-                               "with input character encoding \"%s\"\n", avctx->sub_charenc);
-                        goto free_and_end;
-                    }
-                    iconv_close(cd);
-#else
-                    av_log(avctx, AV_LOG_ERROR, "Character encoding subtitles "
-                           "conversion needs a libavcodec built with iconv support "
-                           "for this codec\n");
-                    ret = AVERROR(ENOSYS);
-                    goto free_and_end;
-#endif
-                }
-            }
-        }
-
-#if FF_API_AVCTX_TIMEBASE
-        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)
-            avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
-#endif
     }
-    if (codec->priv_data_size > 0 && avctx->priv_data && codec->priv_class) {
+    if (codec->priv_class)
         av_assert0(*(const AVClass **)avctx->priv_data == codec->priv_class);
-    }
 
 end:
-    unlock_avcodec(codec);
-    if (options) {
-        av_dict_free(options);
-        *options = tmp;
-    }
 
     return ret;
 free_and_end:
-    if (avctx->codec && avctx->codec->close &&
-        (codec_init_ok > 0 || (codec_init_ok < 0 &&
-         avctx->codec->caps_internal & FF_CODEC_CAP_INIT_CLEANUP)))
-        avctx->codec->close(avctx);
-
-    if (HAVE_THREADS && avci->thread_ctx)
-        ff_thread_free(avctx);
-
-    if (codec->priv_class && avctx->priv_data)
-        av_opt_free(avctx->priv_data);
-    av_opt_free(avctx);
-
-    if (av_codec_is_encoder(avctx->codec)) {
-#if FF_API_CODED_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-        av_frame_free(&avctx->coded_frame);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-        av_freep(&avctx->extradata);
-        avctx->extradata_size = 0;
-    }
-
-    av_dict_free(&tmp);
-    av_freep(&avctx->priv_data);
-    av_freep(&avctx->subtitle_header);
-
-#if FF_API_OLD_ENCDEC
-    av_frame_free(&avci->to_free);
-    av_frame_free(&avci->compat_decode_frame);
-    av_packet_free(&avci->compat_encode_packet);
-#endif
-    av_frame_free(&avci->buffer_frame);
-    av_packet_free(&avci->buffer_pkt);
-    av_packet_free(&avci->last_pkt_props);
-    av_fifo_freep(&avci->pkt_props);
-
-    av_packet_free(&avci->ds.in_pkt);
-    av_frame_free(&avci->es.in_frame);
-    av_bsf_free(&avci->bsf);
-
-    av_buffer_unref(&avci->pool);
-    av_freep(&avci);
-    avctx->internal = NULL;
-    avctx->codec = NULL;
+    avcodec_close(avctx);
     goto end;
 }
 
@@ -502,50 +380,30 @@
                    "that doesn't support it\n");
             return;
         }
+        if (avci->in_frame)
+            av_frame_unref(avci->in_frame);
+        if (avci->recon_frame)
+            av_frame_unref(avci->recon_frame);
+    } else {
+        av_packet_unref(avci->last_pkt_props);
+        av_packet_unref(avci->in_pkt);
 
-        // We haven't implemented flushing for frame-threaded encoders.
-        av_assert0(!(caps & AV_CODEC_CAP_FRAME_THREADS));
+        avctx->pts_correction_last_pts =
+        avctx->pts_correction_last_dts = INT64_MIN;
+
+        av_bsf_flush(avci->bsf);
     }
 
     avci->draining      = 0;
     avci->draining_done = 0;
     avci->nb_draining_errors = 0;
     av_frame_unref(avci->buffer_frame);
-#if FF_API_OLD_ENCDEC
-    av_frame_unref(avci->compat_decode_frame);
-    av_packet_unref(avci->compat_encode_packet);
-#endif
     av_packet_unref(avci->buffer_pkt);
 
-    av_packet_unref(avci->last_pkt_props);
-    while (av_fifo_size(avci->pkt_props) >= sizeof(*avci->last_pkt_props)) {
-        av_fifo_generic_read(avci->pkt_props,
-                             avci->last_pkt_props, sizeof(*avci->last_pkt_props),
-                             NULL);
-        av_packet_unref(avci->last_pkt_props);
-    }
-    av_fifo_reset(avci->pkt_props);
-
-    av_frame_unref(avci->es.in_frame);
-    av_packet_unref(avci->ds.in_pkt);
-
     if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
         ff_thread_flush(avctx);
-    else if (avctx->codec->flush)
-        avctx->codec->flush(avctx);
-
-    avctx->pts_correction_last_pts =
-    avctx->pts_correction_last_dts = INT64_MIN;
-
-    if (av_codec_is_decoder(avctx->codec))
-        av_bsf_flush(avci->bsf);
-
-#if FF_API_OLD_ENCDEC
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (!avctx->refcounted_frames)
-        av_frame_unref(avci->to_free);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
+    else if (ffcodec(avctx->codec)->flush)
+        ffcodec(avctx->codec)->flush(avctx);
 }
 
 void avsubtitle_free(AVSubtitle *sub)
@@ -553,12 +411,15 @@
     int i;
 
     for (i = 0; i < sub->num_rects; i++) {
-        av_freep(&sub->rects[i]->data[0]);
-        av_freep(&sub->rects[i]->data[1]);
-        av_freep(&sub->rects[i]->data[2]);
-        av_freep(&sub->rects[i]->data[3]);
-        av_freep(&sub->rects[i]->text);
-        av_freep(&sub->rects[i]->ass);
+        AVSubtitleRect *const rect = sub->rects[i];
+
+        av_freep(&rect->data[0]);
+        av_freep(&rect->data[1]);
+        av_freep(&rect->data[2]);
+        av_freep(&rect->data[3]);
+        av_freep(&rect->text);
+        av_freep(&rect->ass);
+
         av_freep(&sub->rects[i]);
     }
 
@@ -575,45 +436,39 @@
         return 0;
 
     if (avcodec_is_open(avctx)) {
+        AVCodecInternal *avci = avctx->internal;
+
         if (CONFIG_FRAME_THREAD_ENCODER &&
-            avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {
+            avci->frame_thread_encoder && avctx->thread_count > 1) {
             ff_frame_thread_encoder_free(avctx);
         }
-        if (HAVE_THREADS && avctx->internal->thread_ctx)
+        if (HAVE_THREADS && avci->thread_ctx)
             ff_thread_free(avctx);
-        if (avctx->codec && avctx->codec->close)
-            avctx->codec->close(avctx);
-        avctx->internal->byte_buffer_size = 0;
-        av_freep(&avctx->internal->byte_buffer);
-#if FF_API_OLD_ENCDEC
-        av_frame_free(&avctx->internal->to_free);
-        av_frame_free(&avctx->internal->compat_decode_frame);
-        av_packet_free(&avctx->internal->compat_encode_packet);
-#endif
-        av_frame_free(&avctx->internal->buffer_frame);
-        av_packet_free(&avctx->internal->buffer_pkt);
-        av_packet_unref(avctx->internal->last_pkt_props);
-        while (av_fifo_size(avctx->internal->pkt_props) >=
-               sizeof(*avctx->internal->last_pkt_props)) {
-            av_fifo_generic_read(avctx->internal->pkt_props,
-                                 avctx->internal->last_pkt_props,
-                                 sizeof(*avctx->internal->last_pkt_props),
-                                 NULL);
-            av_packet_unref(avctx->internal->last_pkt_props);
-        }
-        av_packet_free(&avctx->internal->last_pkt_props);
-        av_fifo_freep(&avctx->internal->pkt_props);
-
-        av_packet_free(&avctx->internal->ds.in_pkt);
-        av_frame_free(&avctx->internal->es.in_frame);
+        if (avci->needs_close && ffcodec(avctx->codec)->close)
+            ffcodec(avctx->codec)->close(avctx);
+        avci->byte_buffer_size = 0;
+        av_freep(&avci->byte_buffer);
+        av_frame_free(&avci->buffer_frame);
+        av_packet_free(&avci->buffer_pkt);
+        av_packet_free(&avci->last_pkt_props);
+
+        av_packet_free(&avci->in_pkt);
+        av_frame_free(&avci->in_frame);
+        av_frame_free(&avci->recon_frame);
 
-        av_buffer_unref(&avctx->internal->pool);
+        av_buffer_unref(&avci->pool);
 
         if (avctx->hwaccel && avctx->hwaccel->uninit)
             avctx->hwaccel->uninit(avctx);
-        av_freep(&avctx->internal->hwaccel_priv_data);
+        av_freep(&avci->hwaccel_priv_data);
+
+        av_bsf_free(&avci->bsf);
+
+        av_channel_layout_uninit(&avci->initial_ch_layout);
 
-        av_bsf_free(&avctx->internal->bsf);
+#if CONFIG_LCMS2
+        ff_icc_context_uninit(&avci->icc);
+#endif
 
         av_freep(&avctx->internal);
     }
@@ -632,12 +487,10 @@
     av_freep(&avctx->priv_data);
     if (av_codec_is_encoder(avctx->codec)) {
         av_freep(&avctx->extradata);
-#if FF_API_CODED_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-        av_frame_free(&avctx->coded_frame);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-    }
+        avctx->extradata_size = 0;
+    } else if (av_codec_is_decoder(avctx->codec))
+        av_freep(&avctx->subtitle_header);
+
     avctx->codec = NULL;
     avctx->active_thread_type = 0;
 
@@ -654,6 +507,7 @@
     const char *codec_type;
     const char *codec_name;
     const char *profile = NULL;
+    AVBPrint bprint;
     int64_t bitrate;
     int new_line = 0;
     AVRational display_aspect_ratio;
@@ -662,46 +516,54 @@
 
     if (!buf || buf_size <= 0)
         return;
+    av_bprint_init_for_buffer(&bprint, buf, buf_size);
     codec_type = av_get_media_type_string(enc->codec_type);
     codec_name = avcodec_get_name(enc->codec_id);
     profile = avcodec_profile_name(enc->codec_id, enc->profile);
 
-    snprintf(buf, buf_size, "%s: %s", codec_type ? codec_type : "unknown",
-             codec_name);
+    av_bprintf(&bprint, "%s: %s", codec_type ? codec_type : "unknown",
+               codec_name);
     buf[0] ^= 'a' ^ 'A'; /* first letter in uppercase */
 
     if (enc->codec && strcmp(enc->codec->name, codec_name))
-        snprintf(buf + strlen(buf), buf_size - strlen(buf), " (%s)", enc->codec->name);
+        av_bprintf(&bprint, " (%s)", enc->codec->name);
 
     if (profile)
-        snprintf(buf + strlen(buf), buf_size - strlen(buf), " (%s)", profile);
+        av_bprintf(&bprint, " (%s)", profile);
     if (   enc->codec_type == AVMEDIA_TYPE_VIDEO
         && av_log_get_level() >= AV_LOG_VERBOSE
         && enc->refs)
-        snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                 ", %d reference frame%s",
-                 enc->refs, enc->refs > 1 ? "s" : "");
+        av_bprintf(&bprint, ", %d reference frame%s",
+                   enc->refs, enc->refs > 1 ? "s" : "");
 
     if (enc->codec_tag)
-        snprintf(buf + strlen(buf), buf_size - strlen(buf), " (%s / 0x%04X)",
-                 av_fourcc2str(enc->codec_tag), enc->codec_tag);
+        av_bprintf(&bprint, " (%s / 0x%04X)",
+                   av_fourcc2str(enc->codec_tag), enc->codec_tag);
 
     switch (enc->codec_type) {
     case AVMEDIA_TYPE_VIDEO:
         {
-            char detail[256] = "(";
+            unsigned len;
 
-            av_strlcat(buf, separator, buf_size);
+            av_bprintf(&bprint, "%s%s", separator,
+                       enc->pix_fmt == AV_PIX_FMT_NONE ? "none" :
+                       unknown_if_null(av_get_pix_fmt_name(enc->pix_fmt)));
+
+            av_bprint_chars(&bprint, '(', 1);
+            len = bprint.len;
+
+            /* The following check ensures that '(' has been written
+             * and therefore allows us to erase it if it turns out
+             * to be unnecessary. */
+            if (!av_bprint_is_complete(&bprint))
+                return;
 
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     "%s", enc->pix_fmt == AV_PIX_FMT_NONE ? "none" :
-                     unknown_if_null(av_get_pix_fmt_name(enc->pix_fmt)));
             if (enc->bits_per_raw_sample && enc->pix_fmt != AV_PIX_FMT_NONE &&
                 enc->bits_per_raw_sample < av_pix_fmt_desc_get(enc->pix_fmt)->comp[0].depth)
-                av_strlcatf(detail, sizeof(detail), "%d bpc, ", enc->bits_per_raw_sample);
+                av_bprintf(&bprint, "%d bpc, ", enc->bits_per_raw_sample);
             if (enc->color_range != AVCOL_RANGE_UNSPECIFIED &&
                 (str = av_color_range_name(enc->color_range)))
-                av_strlcatf(detail, sizeof(detail), "%s, ", str);
+                av_bprintf(&bprint, "%s, ", str);
 
             if (enc->colorspace != AVCOL_SPC_UNSPECIFIED ||
                 enc->color_primaries != AVCOL_PRI_UNSPECIFIED ||
@@ -711,10 +573,9 @@
                 const char *trc = unknown_if_null(av_color_transfer_name(enc->color_trc));
                 if (strcmp(col, pri) || strcmp(col, trc)) {
                     new_line = 1;
-                    av_strlcatf(detail, sizeof(detail), "%s/%s/%s, ",
-                                col, pri, trc);
+                    av_bprintf(&bprint, "%s/%s/%s, ", col, pri, trc);
                 } else
-                    av_strlcatf(detail, sizeof(detail), "%s, ", col);
+                    av_bprintf(&bprint, "%s, ", col);
             }
 
             if (enc->field_order != AV_FIELD_UNKNOWN) {
@@ -728,120 +589,115 @@
                 else if (enc->field_order == AV_FIELD_BT)
                     field_order = "bottom coded first (swapped)";
 
-                av_strlcatf(detail, sizeof(detail), "%s, ", field_order);
+                av_bprintf(&bprint, "%s, ", field_order);
             }
 
             if (av_log_get_level() >= AV_LOG_VERBOSE &&
                 enc->chroma_sample_location != AVCHROMA_LOC_UNSPECIFIED &&
                 (str = av_chroma_location_name(enc->chroma_sample_location)))
-                av_strlcatf(detail, sizeof(detail), "%s, ", str);
+                av_bprintf(&bprint, "%s, ", str);
 
-            if (strlen(detail) > 1) {
-                detail[strlen(detail) - 2] = 0;
-                av_strlcatf(buf, buf_size, "%s)", detail);
+            if (len == bprint.len) {
+                bprint.str[len - 1] = '\0';
+                bprint.len--;
+            } else {
+                if (bprint.len - 2 < bprint.size) {
+                    /* Erase the last ", " */
+                    bprint.len -= 2;
+                    bprint.str[bprint.len] = '\0';
+                }
+                av_bprint_chars(&bprint, ')', 1);
             }
         }
 
         if (enc->width) {
-            av_strlcat(buf, new_line ? separator : ", ", buf_size);
-
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     "%dx%d",
-                     enc->width, enc->height);
+            av_bprintf(&bprint, "%s%dx%d", new_line ? separator : ", ",
+                       enc->width, enc->height);
 
             if (av_log_get_level() >= AV_LOG_VERBOSE &&
                 (enc->width != enc->coded_width ||
                  enc->height != enc->coded_height))
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         " (%dx%d)", enc->coded_width, enc->coded_height);
+                av_bprintf(&bprint, " (%dx%d)",
+                           enc->coded_width, enc->coded_height);
 
             if (enc->sample_aspect_ratio.num) {
                 av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,
                           enc->width * (int64_t)enc->sample_aspect_ratio.num,
                           enc->height * (int64_t)enc->sample_aspect_ratio.den,
                           1024 * 1024);
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         " [SAR %d:%d DAR %d:%d]",
+                av_bprintf(&bprint, " [SAR %d:%d DAR %d:%d]",
                          enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,
                          display_aspect_ratio.num, display_aspect_ratio.den);
             }
             if (av_log_get_level() >= AV_LOG_DEBUG) {
                 int g = av_gcd(enc->time_base.num, enc->time_base.den);
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         ", %d/%d",
-                         enc->time_base.num / g, enc->time_base.den / g);
+                av_bprintf(&bprint, ", %d/%d",
+                           enc->time_base.num / g, enc->time_base.den / g);
             }
         }
         if (encode) {
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     ", q=%d-%d", enc->qmin, enc->qmax);
+            av_bprintf(&bprint, ", q=%d-%d", enc->qmin, enc->qmax);
         } else {
             if (enc->properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS)
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         ", Closed Captions");
+                av_bprintf(&bprint, ", Closed Captions");
+            if (enc->properties & FF_CODEC_PROPERTY_FILM_GRAIN)
+                av_bprintf(&bprint, ", Film Grain");
             if (enc->properties & FF_CODEC_PROPERTY_LOSSLESS)
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         ", lossless");
+                av_bprintf(&bprint, ", lossless");
         }
         break;
     case AVMEDIA_TYPE_AUDIO:
-        av_strlcat(buf, separator, buf_size);
+        av_bprintf(&bprint, "%s", separator);
 
         if (enc->sample_rate) {
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     "%d Hz, ", enc->sample_rate);
+            av_bprintf(&bprint, "%d Hz, ", enc->sample_rate);
+        }
+        {
+            char buf[512];
+            int ret = av_channel_layout_describe(&enc->ch_layout, buf, sizeof(buf));
+            if (ret >= 0)
+                av_bprintf(&bprint, "%s", buf);
         }
-        av_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);
         if (enc->sample_fmt != AV_SAMPLE_FMT_NONE &&
             (str = av_get_sample_fmt_name(enc->sample_fmt))) {
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     ", %s", str);
+            av_bprintf(&bprint, ", %s", str);
         }
         if (   enc->bits_per_raw_sample > 0
             && enc->bits_per_raw_sample != av_get_bytes_per_sample(enc->sample_fmt) * 8)
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     " (%d bit)", enc->bits_per_raw_sample);
+            av_bprintf(&bprint, " (%d bit)", enc->bits_per_raw_sample);
         if (av_log_get_level() >= AV_LOG_VERBOSE) {
             if (enc->initial_padding)
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         ", delay %d", enc->initial_padding);
+                av_bprintf(&bprint, ", delay %d", enc->initial_padding);
             if (enc->trailing_padding)
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         ", padding %d", enc->trailing_padding);
+                av_bprintf(&bprint, ", padding %d", enc->trailing_padding);
         }
         break;
     case AVMEDIA_TYPE_DATA:
         if (av_log_get_level() >= AV_LOG_DEBUG) {
             int g = av_gcd(enc->time_base.num, enc->time_base.den);
             if (g)
-                snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                         ", %d/%d",
-                         enc->time_base.num / g, enc->time_base.den / g);
+                av_bprintf(&bprint, ", %d/%d",
+                           enc->time_base.num / g, enc->time_base.den / g);
         }
         break;
     case AVMEDIA_TYPE_SUBTITLE:
         if (enc->width)
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     ", %dx%d", enc->width, enc->height);
+            av_bprintf(&bprint, ", %dx%d", enc->width, enc->height);
         break;
     default:
         return;
     }
     if (encode) {
         if (enc->flags & AV_CODEC_FLAG_PASS1)
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     ", pass 1");
+            av_bprintf(&bprint, ", pass 1");
         if (enc->flags & AV_CODEC_FLAG_PASS2)
-            snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                     ", pass 2");
+            av_bprintf(&bprint, ", pass 2");
     }
     bitrate = get_bit_rate(enc);
     if (bitrate != 0) {
-        snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                 ", %"PRId64" kb/s", bitrate / 1000);
+        av_bprintf(&bprint, ", %"PRId64" kb/s", bitrate / 1000);
     } else if (enc->rc_max_rate > 0) {
-        snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                 ", max. %"PRId64" kb/s", enc->rc_max_rate / 1000);
+        av_bprintf(&bprint, ", max. %"PRId64" kb/s", enc->rc_max_rate / 1000);
     }
 }
 
@@ -849,3 +705,12 @@
 {
     return !!s->internal;
 }
+
+int attribute_align_arg avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    av_frame_unref(frame);
+
+    if (av_codec_is_decoder(avctx->codec))
+        return ff_decode_receive_frame(avctx, frame);
+    return ff_encode_receive_frame(avctx, frame);
+}
diff -Naur a/media/ffvpx/libavcodec/avcodec.h b/media/ffvpx/libavcodec/avcodec.h
--- a/media/ffvpx/libavcodec/avcodec.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/avcodec.h	2023-04-06 12:50:24.491176503 +0200
@@ -27,27 +27,29 @@
  * Libavcodec external API header
  */
 
-#include <errno.h>
 #include "libavutil/samplefmt.h"
 #include "libavutil/attributes.h"
 #include "libavutil/avutil.h"
 #include "libavutil/buffer.h"
-#include "libavutil/cpu.h"
-#include "libavutil/channel_layout.h"
 #include "libavutil/dict.h"
 #include "libavutil/frame.h"
-#include "libavutil/hwcontext.h"
 #include "libavutil/log.h"
 #include "libavutil/pixfmt.h"
 #include "libavutil/rational.h"
 
-#include "bsf.h"
 #include "codec.h"
 #include "codec_desc.h"
 #include "codec_par.h"
 #include "codec_id.h"
+#include "defs.h"
 #include "packet.h"
+#include "version_major.h"
+#ifndef HAVE_AV_CONFIG_H
+/* When included as part of the ffmpeg build, only include the major version
+ * to avoid unnecessary rebuilds. When included externally, keep including
+ * the full version information. */
 #include "version.h"
+#endif
 
 /**
  * @defgroup libavc libavcodec
@@ -155,29 +157,6 @@
  * at least will not fail with AVERROR(EAGAIN). In general, no codec will
  * permit unlimited buffering of input or output.
  *
- * This API replaces the following legacy functions:
- * - avcodec_decode_video2() and avcodec_decode_audio4():
- *   Use avcodec_send_packet() to feed input to the decoder, then use
- *   avcodec_receive_frame() to receive decoded frames after each packet.
- *   Unlike with the old video decoding API, multiple frames might result from
- *   a packet. For audio, splitting the input packet into frames by partially
- *   decoding packets becomes transparent to the API user. You never need to
- *   feed an AVPacket to the API twice (unless it is rejected with AVERROR(EAGAIN) - then
- *   no data was read from the packet).
- *   Additionally, sending a flush/draining packet is required only once.
- * - avcodec_encode_video2()/avcodec_encode_audio2():
- *   Use avcodec_send_frame() to feed input to the encoder, then use
- *   avcodec_receive_packet() to receive encoded packets.
- *   Providing user-allocated buffers for avcodec_receive_packet() is not
- *   possible.
- * - The new API does not handle subtitles yet.
- *
- * Mixing new and old function calls on the same AVCodecContext is not allowed,
- * and will result in undefined behavior.
- *
- * Some codecs might require using the new API; using the old API will return
- * an error when calling it. All codecs support the new API.
- *
  * A codec is not allowed to return AVERROR(EAGAIN) for both sending and receiving. This
  * would be an invalid state, which could put the codec user into an endless
  * loop. The API has no concept of time either: it cannot happen that trying to
@@ -205,16 +184,6 @@
  */
 
 /**
- * @ingroup lavc_decoding
- * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
- * This is mainly needed because some optimized bitstream readers read
- * 32 or 64 bit at once and could read over the end.<br>
- * Note: If the first 23 bits of the additional bytes are not 0, then damaged
- * MPEG bitstreams could cause overread and segfault.
- */
-#define AV_INPUT_BUFFER_PADDING_SIZE 64
-
-/**
  * @ingroup lavc_encoding
  * minimum encoding buffer size
  * Used to avoid some checks during header writing.
@@ -222,34 +191,6 @@
 #define AV_INPUT_BUFFER_MIN_SIZE 16384
 
 /**
- * @ingroup lavc_decoding
- */
-enum AVDiscard{
-    /* We leave some space between them for extensions (drop some
-     * keyframes for intra-only or drop just some bidir frames). */
-    AVDISCARD_NONE    =-16, ///< discard nothing
-    AVDISCARD_DEFAULT =  0, ///< discard useless packets like 0 size packets in avi
-    AVDISCARD_NONREF  =  8, ///< discard all non reference
-    AVDISCARD_BIDIR   = 16, ///< discard all bidirectional frames
-    AVDISCARD_NONINTRA= 24, ///< discard all non intra frames
-    AVDISCARD_NONKEY  = 32, ///< discard all frames except keyframes
-    AVDISCARD_ALL     = 48, ///< discard all
-};
-
-enum AVAudioServiceType {
-    AV_AUDIO_SERVICE_TYPE_MAIN              = 0,
-    AV_AUDIO_SERVICE_TYPE_EFFECTS           = 1,
-    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
-    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED  = 3,
-    AV_AUDIO_SERVICE_TYPE_DIALOGUE          = 4,
-    AV_AUDIO_SERVICE_TYPE_COMMENTARY        = 5,
-    AV_AUDIO_SERVICE_TYPE_EMERGENCY         = 6,
-    AV_AUDIO_SERVICE_TYPE_VOICE_OVER        = 7,
-    AV_AUDIO_SERVICE_TYPE_KARAOKE           = 8,
-    AV_AUDIO_SERVICE_TYPE_NB                   , ///< Not part of ABI
-};
-
-/**
  * @ingroup lavc_encoding
  */
 typedef struct RcOverride{
@@ -291,6 +232,58 @@
  */
 #define AV_CODEC_FLAG_DROPCHANGED     (1 <<  5)
 /**
+ * Request the encoder to output reconstructed frames, i.e.\ frames that would
+ * be produced by decoding the encoded bistream. These frames may be retrieved
+ * by calling avcodec_receive_frame() immediately after a successful call to
+ * avcodec_receive_packet().
+ *
+ * Should only be used with encoders flagged with the
+ * @ref AV_CODEC_CAP_ENCODER_RECON_FRAME capability.
+ */
+#define AV_CODEC_FLAG_RECON_FRAME     (1 <<  6)
+/**
+ * @par decoding
+ * Request the decoder to propagate each packets AVPacket.opaque and
+ * AVPacket.opaque_ref to its corresponding output AVFrame.
+ *
+ * @par encoding:
+ * Request the encoder to propagate each frame's AVFrame.opaque and
+ * AVFrame.opaque_ref values to its corresponding output AVPacket.
+ *
+ * @par
+ * May only be set on encoders that have the
+ * @ref AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability flag.
+ *
+ * @note
+ * While in typical cases one input frame produces exactly one output packet
+ * (perhaps after a delay), in general the mapping of frames to packets is
+ * M-to-N, so
+ * - Any number of input frames may be associated with any given output packet.
+ *   This includes zero - e.g. some encoders may output packets that carry only
+ *   metadata about the whole stream.
+ * - A given input frame may be associated with any number of output packets.
+ *   Again this includes zero - e.g. some encoders may drop frames under certain
+ *   conditions.
+ * .
+ * This implies that when using this flag, the caller must NOT assume that
+ * - a given input frame's opaques will necessarily appear on some output packet;
+ * - every output packet will have some non-NULL opaque value.
+ * .
+ * When an output packet contains multiple frames, the opaque values will be
+ * taken from the first of those.
+ *
+ * @note
+ * The converse holds for decoders, with frames and packets switched.
+ */
+#define AV_CODEC_FLAG_COPY_OPAQUE     (1 <<  7)
+/**
+ * Signal to the encoder that the values of AVFrame.duration are valid and
+ * should be used (typically for transferring them to output packets).
+ *
+ * If this flag is not set, frame durations are ignored.
+ */
+#define AV_CODEC_FLAG_FRAME_DURATION  (1 <<  8)
+/**
  * Use internal 2pass ratecontrol in first pass mode.
  */
 #define AV_CODEC_FLAG_PASS1           (1 <<  9)
@@ -311,11 +304,6 @@
  */
 #define AV_CODEC_FLAG_PSNR            (1 << 15)
 /**
- * Input bitstream might be truncated at a random location
- * instead of only at frame boundaries.
- */
-#define AV_CODEC_FLAG_TRUNCATED       (1 << 16)
-/**
  * Use interlaced DCT.
  */
 #define AV_CODEC_FLAG_INTERLACED_DCT  (1 << 18)
@@ -356,11 +344,6 @@
 #define AV_CODEC_FLAG2_LOCAL_HEADER   (1 <<  3)
 
 /**
- * timecode is in drop frame format. DEPRECATED!!!!
- */
-#define AV_CODEC_FLAG2_DROP_FRAME_TIMECODE (1 << 13)
-
-/**
  * Input bitstream might be truncated at a packet boundaries
  * instead of only at frame boundaries.
  */
@@ -386,13 +369,12 @@
  * Do not reset ASS ReadOrder field on flush (subtitles decoding)
  */
 #define AV_CODEC_FLAG2_RO_FLUSH_NOOP  (1 << 30)
-
-/* Unsupported options :
- *              Syntax Arithmetic coding (SAC)
- *              Reference Picture Selection
- *              Independent Segment Decoding */
-/* /Fx */
-/* codec capabilities */
+/**
+ * Generate/parse ICC profiles on encode/decode, as appropriate for the type of
+ * file. No effect on codecs which cannot contain embedded ICC profiles, or
+ * when compiled without support for lcms2.
+ */
+#define AV_CODEC_FLAG2_ICC_PROFILES   (1U << 31)
 
 /* Exported side data.
    These flags can be passed in AVCodecContext.export_side_data before initialization.
@@ -417,98 +399,6 @@
 #define AV_CODEC_EXPORT_DATA_FILM_GRAIN (1 << 3)
 
 /**
- * Pan Scan area.
- * This specifies the area which should be displayed.
- * Note there may be multiple such areas for one frame.
- */
-typedef struct AVPanScan {
-    /**
-     * id
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
-    int id;
-
-    /**
-     * width and height in 1/16 pel
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
-    int width;
-    int height;
-
-    /**
-     * position of the top left corner in 1/16 pel for up to 3 fields/frames
-     * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
-     */
-    int16_t position[3][2];
-} AVPanScan;
-
-/**
- * This structure describes the bitrate properties of an encoded bitstream. It
- * roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
- * parameters for H.264/HEVC.
- */
-typedef struct AVCPBProperties {
-    /**
-     * Maximum bitrate of the stream, in bits per second.
-     * Zero if unknown or unspecified.
-     */
-#if FF_API_UNSANITIZED_BITRATES
-    int max_bitrate;
-#else
-    int64_t max_bitrate;
-#endif
-    /**
-     * Minimum bitrate of the stream, in bits per second.
-     * Zero if unknown or unspecified.
-     */
-#if FF_API_UNSANITIZED_BITRATES
-    int min_bitrate;
-#else
-    int64_t min_bitrate;
-#endif
-    /**
-     * Average bitrate of the stream, in bits per second.
-     * Zero if unknown or unspecified.
-     */
-#if FF_API_UNSANITIZED_BITRATES
-    int avg_bitrate;
-#else
-    int64_t avg_bitrate;
-#endif
-
-    /**
-     * The size of the buffer to which the ratecontrol is applied, in bits.
-     * Zero if unknown or unspecified.
-     */
-    int buffer_size;
-
-    /**
-     * The delay between the time the packet this structure is associated with
-     * is received and the time when it should be decoded, in periods of a 27MHz
-     * clock.
-     *
-     * UINT64_MAX when unknown or unspecified.
-     */
-    uint64_t vbv_delay;
-} AVCPBProperties;
-
-/**
- * This structure supplies correlation between a packet timestamp and a wall clock
- * production time. The definition follows the Producer Reference Time ('prft')
- * as defined in ISO/IEC 14496-12
- */
-typedef struct AVProducerReferenceTime {
-    /**
-     * A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime()).
-     */
-    int64_t wallclock;
-    int flags;
-} AVProducerReferenceTime;
-
-/**
  * The decoder will keep a reference to the frame and may reuse it later.
  */
 #define AV_GET_BUFFER_FLAG_REF (1 << 0)
@@ -653,8 +543,7 @@
      * (fixed_vop_rate == 0 implies that it is different from the framerate)
      *
      * - encoding: MUST be set by user.
-     * - decoding: the use of this field for decoding is deprecated.
-     *             Use framerate instead.
+     * - decoding: unused.
      */
     AVRational time_base;
 
@@ -697,7 +586,7 @@
      * picture width / height.
      *
      * @note Those fields may not match the values of the last
-     * AVFrame output by avcodec_decode_video2 due frame
+     * AVFrame output by avcodec_receive_frame() due frame
      * reordering.
      *
      * - encoding: MUST be set by user.
@@ -773,17 +662,29 @@
                             int y, int type, int height);
 
     /**
-     * callback to negotiate the pixelFormat
-     * @param fmt is the list of formats which are supported by the codec,
-     * it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
-     * The first is always the native one.
-     * @note The callback may be called again immediately if initialization for
-     * the selected (hardware-accelerated) pixel format failed.
-     * @warning Behavior is undefined if the callback returns a value not
-     * in the fmt list of formats.
-     * @return the chosen format
-     * - encoding: unused
-     * - decoding: Set by user, if not set the native format will be chosen.
+     * Callback to negotiate the pixel format. Decoding only, may be set by the
+     * caller before avcodec_open2().
+     *
+     * Called by some decoders to select the pixel format that will be used for
+     * the output frames. This is mainly used to set up hardware acceleration,
+     * then the provided format list contains the corresponding hwaccel pixel
+     * formats alongside the "software" one. The software pixel format may also
+     * be retrieved from \ref sw_pix_fmt.
+     *
+     * This callback will be called when the coded frame properties (such as
+     * resolution, pixel format, etc.) change and more than one output format is
+     * supported for those new properties. If a hardware pixel format is chosen
+     * and initialization for it fails, the callback may be called again
+     * immediately.
+     *
+     * This callback may be called from different threads if the decoder is
+     * multi-threaded, but not from more than one thread simultaneously.
+     *
+     * @param fmt list of formats which may be used in the current
+     *            configuration, terminated by AV_PIX_FMT_NONE.
+     * @warning Behavior is undefined if the callback returns a value other
+     *          than one of the formats in fmt or AV_PIX_FMT_NONE.
+     * @return the chosen format or AV_PIX_FMT_NONE
      */
     enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
 
@@ -804,12 +705,6 @@
      */
     float b_quant_factor;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int b_frame_strategy;
-#endif
-
     /**
      * qscale offset between IP and B-frames
      * - encoding: Set by user.
@@ -825,12 +720,6 @@
      */
     int has_b_frames;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int mpeg_quant;
-#endif
-
     /**
      * qscale factor between P- and I-frames
      * If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
@@ -889,15 +778,6 @@
      */
     int slice_count;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-     int prediction_method;
-#define FF_PRED_LEFT   0
-#define FF_PRED_PLANE  1
-#define FF_PRED_MEDIAN 2
-#endif
-
     /**
      * slice offsets in the frame in bytes
      * - encoding: Set/allocated by libavcodec.
@@ -970,12 +850,6 @@
      */
     int last_predictor_count;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int pre_me;
-#endif
-
     /**
      * motion estimation prepass comparison function
      * - encoding: Set by user.
@@ -1044,16 +918,6 @@
      */
     uint16_t *inter_matrix;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int scenechange_threshold;
-
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int noise_reduction;
-#endif
-
     /**
      * precision of the intra DC coefficient - 8
      * - encoding: Set by user.
@@ -1089,26 +953,12 @@
      */
     int mb_lmax;
 
-#if FF_API_PRIVATE_OPT
-    /**
-     * @deprecated use encoder private options instead
-     */
-    attribute_deprecated
-    int me_penalty_compensation;
-#endif
-
     /**
      * - encoding: Set by user.
      * - decoding: unused
      */
     int bidir_refine;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int brd_scale;
-#endif
-
     /**
      * minimum GOP size
      * - encoding: Set by user.
@@ -1123,12 +973,6 @@
      */
     int refs;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int chromaoffset;
-#endif
-
     /**
      * Note: Value depends upon the compare function used for fullpel ME.
      * - encoding: Set by user.
@@ -1136,12 +980,6 @@
      */
     int mv0_threshold;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int b_sensitivity;
-#endif
-
     /**
      * Chromaticity coordinates of the source primaries.
      * - encoding: Set by user
@@ -1194,7 +1032,15 @@
 
     /* audio only */
     int sample_rate; ///< samples per second
-    int channels;    ///< number of audio channels
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+    /**
+     * number of audio channels
+     * @deprecated use ch_layout.nb_channels
+     */
+    attribute_deprecated
+    int channels;
+#endif
 
     /**
      * audio sample format
@@ -1215,6 +1061,7 @@
      */
     int frame_size;
 
+#if FF_API_AVCTX_FRAME_NUMBER
     /**
      * Frame counter, set by libavcodec.
      *
@@ -1223,8 +1070,11 @@
      *
      *   @note the counter is not incremented if encoding/decoding resulted in
      *   an error.
+     *   @deprecated use frame_num instead
      */
+    attribute_deprecated
     int frame_number;
+#endif
 
     /**
      * number of bytes per packet if constant and known or 0
@@ -1239,19 +1089,25 @@
      */
     int cutoff;
 
+#if FF_API_OLD_CHANNEL_LAYOUT
     /**
      * Audio channel layout.
      * - encoding: set by user.
      * - decoding: set by user, may be overwritten by libavcodec.
+     * @deprecated use ch_layout
      */
+    attribute_deprecated
     uint64_t channel_layout;
 
     /**
      * Request decoder to use this channel layout if it can (0 for default)
      * - encoding: unused
      * - decoding: Set by user.
+     * @deprecated use "downmix" codec private option
      */
+    attribute_deprecated
     uint64_t request_channel_layout;
+#endif
 
     /**
      * Type of service that the audio stream conveys.
@@ -1350,24 +1206,6 @@
      */
     int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);
 
-#if FF_API_OLD_ENCDEC
-    /**
-     * If non-zero, the decoded audio and video frames returned from
-     * avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
-     * and are valid indefinitely. The caller must free them with
-     * av_frame_unref() when they are not needed anymore.
-     * Otherwise, the decoded frames must not be freed by the caller and are
-     * only valid until the next decode call.
-     *
-     * This is always automatically enabled if avcodec_receive_frame() is used.
-     *
-     * - encoding: unused
-     * - decoding: set by the caller before avcodec_open2().
-     */
-    attribute_deprecated
-    int refcounted_frames;
-#endif
-
     /* - encoding parameters */
     float qcompress;  ///< amount of qscale change between easy & hard scenes (0.0-1.0)
     float qblur;      ///< amount of qscale smoothing over time (0.0-1.0)
@@ -1443,42 +1281,6 @@
      */
     int rc_initial_buffer_occupancy;
 
-#if FF_API_CODER_TYPE
-#define FF_CODER_TYPE_VLC       0
-#define FF_CODER_TYPE_AC        1
-#define FF_CODER_TYPE_RAW       2
-#define FF_CODER_TYPE_RLE       3
-    /**
-     * @deprecated use encoder private options instead
-     */
-    attribute_deprecated
-    int coder_type;
-#endif /* FF_API_CODER_TYPE */
-
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int context_model;
-#endif
-
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int frame_skip_threshold;
-
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int frame_skip_factor;
-
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int frame_skip_exp;
-
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int frame_skip_cmp;
-#endif /* FF_API_PRIVATE_OPT */
-
     /**
      * trellis RD quantization
      * - encoding: Set by user.
@@ -1486,69 +1288,6 @@
      */
     int trellis;
 
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int min_prediction_order;
-
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int max_prediction_order;
-
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int64_t timecode_frame_start;
-#endif
-
-#if FF_API_RTP_CALLBACK
-    /**
-     * @deprecated unused
-     */
-    /* The RTP callback: This function is called    */
-    /* every time the encoder has a packet to send. */
-    /* It depends on the encoder if the data starts */
-    /* with a Start Code (it should). H.263 does.   */
-    /* mb_nb contains the number of macroblocks     */
-    /* encoded in the RTP payload.                  */
-    attribute_deprecated
-    void (*rtp_callback)(struct AVCodecContext *avctx, void *data, int size, int mb_nb);
-#endif
-
-#if FF_API_PRIVATE_OPT
-    /** @deprecated use encoder private options instead */
-    attribute_deprecated
-    int rtp_payload_size;   /* The size of the RTP payload: the coder will  */
-                            /* do its best to deliver a chunk with size     */
-                            /* below rtp_payload_size, the chunk will start */
-                            /* with a start code on some codecs like H.263. */
-                            /* This doesn't take account of any particular  */
-                            /* headers inside the transmitted RTP payload.  */
-#endif
-
-#if FF_API_STAT_BITS
-    /* statistics, used for 2-pass encoding */
-    attribute_deprecated
-    int mv_bits;
-    attribute_deprecated
-    int header_bits;
-    attribute_deprecated
-    int i_tex_bits;
-    attribute_deprecated
-    int p_tex_bits;
-    attribute_deprecated
-    int i_count;
-    attribute_deprecated
-    int p_count;
-    attribute_deprecated
-    int skip_count;
-    attribute_deprecated
-    int misc_bits;
-
-    /** @deprecated this field is unused */
-    attribute_deprecated
-    int frame_bits;
-#endif
-
     /**
      * pass1 encoding statistics output buffer
      * - encoding: Set by libavcodec.
@@ -1597,13 +1336,9 @@
      * unofficial and experimental (that is, they always try to decode things
      * when they can) unless they are explicitly asked to behave stupidly
      * (=strictly conform to the specs)
+     * This may only be set to one of the FF_COMPLIANCE_* values in defs.h.
      */
     int strict_std_compliance;
-#define FF_COMPLIANCE_VERY_STRICT   2 ///< Strictly conform to an older more strict version of the spec or reference software.
-#define FF_COMPLIANCE_STRICT        1 ///< Strictly conform to all the things in the spec no matter what consequences.
-#define FF_COMPLIANCE_NORMAL        0
-#define FF_COMPLIANCE_UNOFFICIAL   -1 ///< Allow unofficial extensions
-#define FF_COMPLIANCE_EXPERIMENTAL -2 ///< Allow nonstandardized experimental things.
 
     /**
      * error concealment flags
@@ -1639,28 +1374,14 @@
 
     /**
      * Error recognition; may misdetect some more or less valid parts as errors.
+     * This is a bitfield of the AV_EF_* values defined in defs.h.
+     *
      * - encoding: Set by user.
      * - decoding: Set by user.
      */
     int err_recognition;
 
-/**
- * Verify checksums embedded in the bitstream (could be of either encoded or
- * decoded data, depending on the codec) and print an error message on mismatch.
- * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
- * decoder returning an error.
- */
-#define AV_EF_CRCCHECK  (1<<0)
-#define AV_EF_BITSTREAM (1<<1)          ///< detect bitstream specification deviations
-#define AV_EF_BUFFER    (1<<2)          ///< detect improper bitstream length
-#define AV_EF_EXPLODE   (1<<3)          ///< abort decoding on minor error detection
-
-#define AV_EF_IGNORE_ERR (1<<15)        ///< ignore errors and continue
-#define AV_EF_CAREFUL    (1<<16)        ///< consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors
-#define AV_EF_COMPLIANT  (1<<17)        ///< consider all spec non compliances as errors
-#define AV_EF_AGGRESSIVE (1<<18)        ///< consider things that a sane encoder should not do as an error
-
-
+#if FF_API_REORDERED_OPAQUE
     /**
      * opaque 64-bit number (generally a PTS) that will be reordered and
      * output in AVFrame.reordered_opaque
@@ -1669,8 +1390,12 @@
      *             supported by encoders with the
      *             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.
      * - decoding: Set by user.
+     *
+     * @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead
      */
+    attribute_deprecated
     int64_t reordered_opaque;
+#endif
 
     /**
      * Hardware accelerator in use
@@ -1680,14 +1405,26 @@
     const struct AVHWAccel *hwaccel;
 
     /**
-     * Hardware accelerator context.
-     * For some hardware accelerators, a global context needs to be
-     * provided by the user. In that case, this holds display-dependent
-     * data FFmpeg cannot instantiate itself. Please refer to the
-     * FFmpeg HW accelerator documentation to know how to fill this
-     * is. e.g. for VA API, this is a struct vaapi_context.
-     * - encoding: unused
-     * - decoding: Set by user
+     * Legacy hardware accelerator context.
+     *
+     * For some hardware acceleration methods, the caller may use this field to
+     * signal hwaccel-specific data to the codec. The struct pointed to by this
+     * pointer is hwaccel-dependent and defined in the respective header. Please
+     * refer to the FFmpeg HW accelerator documentation to know how to fill
+     * this.
+     *
+     * In most cases this field is optional - the necessary information may also
+     * be provided to libavcodec through @ref hw_frames_ctx or @ref
+     * hw_device_ctx (see avcodec_get_hw_config()). However, in some cases it
+     * may be the only method of signalling some (optional) information.
+     *
+     * The struct and its contents are owned by the caller.
+     *
+     * - encoding: May be set by the caller before avcodec_open2(). Must remain
+     *             valid until avcodec_free_context().
+     * - decoding: May be set by the caller in the get_format() callback.
+     *             Must remain valid until the next get_format() call,
+     *             or avcodec_free_context() (whichever comes first).
      */
     void *hwaccel_context;
 
@@ -1729,7 +1466,10 @@
 #define FF_IDCT_SIMPLEARMV6   17
 #define FF_IDCT_FAAN          20
 #define FF_IDCT_SIMPLENEON    22
-#define FF_IDCT_NONE          24 /* Used by XvMC to extract IDCT coefficients with FF_IDCT_PERM_NONE */
+#if FF_API_IDCT_NONE
+// formerly used by xvmc
+#define FF_IDCT_NONE          24
+#endif
 #define FF_IDCT_SIMPLEAUTO    128
 
     /**
@@ -1753,17 +1493,6 @@
      */
      int lowres;
 
-#if FF_API_CODED_FRAME
-    /**
-     * the picture in the bitstream
-     * - encoding: Set by libavcodec.
-     * - decoding: unused
-     *
-     * @deprecated use the quality factor packet side data instead
-     */
-    attribute_deprecated AVFrame *coded_frame;
-#endif
-
     /**
      * thread count
      * is used to decide how many independent tasks should be passed to execute()
@@ -1791,27 +1520,6 @@
      */
     int active_thread_type;
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-    /**
-     * Set by the client if its custom get_buffer() callback can be called
-     * synchronously from another thread, which allows faster multithreaded decoding.
-     * draw_horiz_band() will be called from other threads regardless of this setting.
-     * Ignored if the default get_buffer() is used.
-     * - encoding: Set by user.
-     * - decoding: Set by user.
-     *
-     * @deprecated the custom get_buffer2() callback should always be
-     *   thread-safe. Thread-unsafe get_buffer2() implementations will be
-     *   invalid starting with LIBAVCODEC_VERSION_MAJOR=60; in other words,
-     *   libavcodec will behave as if this field was always set to 1.
-     *   Callers that want to be forward compatible with future libavcodec
-     *   versions should wrap access to this field in
-     *     #if LIBAVCODEC_VERSION_MAJOR < 60
-     */
-    attribute_deprecated
-    int thread_safe_callbacks;
-#endif
-
     /**
      * The codec may call this to execute several independent things.
      * It will return only after finishing all tasks.
@@ -1828,7 +1536,6 @@
      * It will return only after finishing all tasks.
      * The user may replace this with some multithreaded implementation,
      * the default implementation will execute the parts serially.
-     * Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
      * @param c context passed also to func
      * @param count the number of things to execute
      * @param arg2 argument passed unchanged to func
@@ -1947,6 +1654,7 @@
 #define FF_PROFILE_HEVC_MAIN_10                     2
 #define FF_PROFILE_HEVC_MAIN_STILL_PICTURE          3
 #define FF_PROFILE_HEVC_REXT                        4
+#define FF_PROFILE_HEVC_SCC                         9
 
 #define FF_PROFILE_VVC_MAIN_10                      1
 #define FF_PROFILE_VVC_MAIN_10_444                 33
@@ -2016,34 +1724,6 @@
     uint8_t *subtitle_header;
     int subtitle_header_size;
 
-#if FF_API_VBV_DELAY
-    /**
-     * VBV delay coded in the last frame (in periods of a 27 MHz clock).
-     * Used for compliant TS muxing.
-     * - encoding: Set by libavcodec.
-     * - decoding: unused.
-     * @deprecated this value is now exported as a part of
-     * AV_PKT_DATA_CPB_PROPERTIES packet side data
-     */
-    attribute_deprecated
-    uint64_t vbv_delay;
-#endif
-
-#if FF_API_SIDEDATA_ONLY_PKT
-    /**
-     * Encoding only and set by default. Allow encoders to output packets
-     * that do not contain any encoded data, only side data.
-     *
-     * Some encoders need to output such packets, e.g. to update some stream
-     * parameters at the end of encoding.
-     *
-     * @deprecated this field disables the default behaviour and
-     *             it is kept only for compatibility.
-     */
-    attribute_deprecated
-    int side_data_only_packets;
-#endif
-
     /**
      * Audio only. The number of "priming" samples (padding) inserted by the
      * encoder at the beginning of the audio. I.e. this number of leading
@@ -2141,17 +1821,6 @@
      */
     int seek_preroll;
 
-#if FF_API_DEBUG_MV
-    /**
-     * @deprecated unused
-     */
-    attribute_deprecated
-    int debug_mv;
-#define FF_DEBUG_VIS_MV_P_FOR  0x00000001 //visualize forward predicted MVs of P frames
-#define FF_DEBUG_VIS_MV_B_FOR  0x00000002 //visualize forward predicted MVs of B frames
-#define FF_DEBUG_VIS_MV_B_BACK 0x00000004 //visualize backward predicted MVs of B frames
-#endif
-
     /**
      * custom intra quantization matrix
      * - encoding: Set by user, can be NULL.
@@ -2183,6 +1852,7 @@
     unsigned properties;
 #define FF_CODEC_PROPERTY_LOSSLESS        0x00000001
 #define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 0x00000002
+#define FF_CODEC_PROPERTY_FILM_GRAIN      0x00000004
 
     /**
      * Additional data associated with the entire coded stream.
@@ -2218,17 +1888,6 @@
     AVBufferRef *hw_frames_ctx;
 
     /**
-     * Control the form of AVSubtitle.rects[N]->ass
-     * - decoding: set by user
-     * - encoding: unused
-     */
-    int sub_text_format;
-#define FF_SUB_TEXT_FMT_ASS              0
-#if FF_API_ASS_TIMING
-#define FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS 1
-#endif
-
-    /**
      * Audio only. The amount of padding (in samples) appended by the encoder to
      * the end of the audio. I.e. this number of decoded samples must be
      * discarded by the caller from the end of the stream to get the original
@@ -2355,6 +2014,10 @@
      * This callback must use the above value to calculate the required buffer size,
      * which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes.
      *
+     * In some specific cases, the encoder may not use the entire buffer allocated by this
+     * callback. This will be reflected in the size value in the packet once returned by
+     * avcodec_receive_packet().
+     *
      * This callback must fill the following fields in the packet:
      * - data: alignment requirements for AVPacket apply, if any. Some architectures and
      *   encoders may benefit from having aligned data.
@@ -2382,50 +2045,26 @@
      * - decoding: unused
      */
     int (*get_encode_buffer)(struct AVCodecContext *s, AVPacket *pkt, int flags);
-} AVCodecContext;
-
-#if FF_API_CODEC_GET_SET
-/**
- * Accessors for some AVCodecContext fields. These used to be provided for ABI
- * compatibility, and do not need to be used anymore.
- */
-attribute_deprecated
-AVRational av_codec_get_pkt_timebase         (const AVCodecContext *avctx);
-attribute_deprecated
-void       av_codec_set_pkt_timebase         (AVCodecContext *avctx, AVRational val);
-
-attribute_deprecated
-const AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *avctx);
-attribute_deprecated
-void                     av_codec_set_codec_descriptor(AVCodecContext *avctx, const AVCodecDescriptor *desc);
-
-attribute_deprecated
-unsigned av_codec_get_codec_properties(const AVCodecContext *avctx);
-
-attribute_deprecated
-int  av_codec_get_lowres(const AVCodecContext *avctx);
-attribute_deprecated
-void av_codec_set_lowres(AVCodecContext *avctx, int val);
-
-attribute_deprecated
-int  av_codec_get_seek_preroll(const AVCodecContext *avctx);
-attribute_deprecated
-void av_codec_set_seek_preroll(AVCodecContext *avctx, int val);
-
-attribute_deprecated
-uint16_t *av_codec_get_chroma_intra_matrix(const AVCodecContext *avctx);
-attribute_deprecated
-void av_codec_set_chroma_intra_matrix(AVCodecContext *avctx, uint16_t *val);
-#endif
 
-struct AVSubtitle;
-
-#if FF_API_CODEC_GET_SET
-attribute_deprecated
-int av_codec_get_max_lowres(const AVCodec *codec);
-#endif
+    /**
+     * Audio channel layout.
+     * - encoding: must be set by the caller, to one of AVCodec.ch_layouts.
+     * - decoding: may be set by the caller if known e.g. from the container.
+     *             The decoder can then override during decoding as needed.
+     */
+    AVChannelLayout ch_layout;
 
-struct MpegEncContext;
+    /**
+     * Frame counter, set by libavcodec.
+     *
+     * - decoding: total number of frames returned from the decoder so far.
+     * - encoding: total number of frames passed to the encoder so far.
+     *
+     *   @note the counter is not incremented if encoding/decoding resulted in
+     *   an error.
+     */
+    int64_t frame_num;
+} AVCodecContext;
 
 /**
  * @defgroup lavc_hwaccel AVHWAccel
@@ -2518,7 +2157,6 @@
      *
      * Meaningful slice information (codec specific) is guaranteed to
      * be parsed at this point. This function is mandatory.
-     * The only exception is XvMC, that works on MB level.
      *
      * @param avctx the codec context
      * @param buf the slice data buffer base
@@ -2548,17 +2186,6 @@
     int frame_priv_data_size;
 
     /**
-     * Called for every Macroblock in a slice.
-     *
-     * XvMC uses it to replace the ff_mpv_reconstruct_mb().
-     * Instead of decoding to raw picture, MB parameters are
-     * stored in an array provided by the video driver.
-     *
-     * @param s the mpeg context
-     */
-    void (*decode_mb)(struct MpegEncContext *s);
-
-    /**
      * Initialize the hwaccel private data.
      *
      * This will be called from ff_get_format(), after hwaccel and
@@ -2634,35 +2261,24 @@
 #define AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH (1 << 2)
 
 /**
- * @}
- */
-
-#if FF_API_AVPICTURE
-/**
- * @defgroup lavc_picture AVPicture
- *
- * Functions for working with AVPicture
- * @{
- */
-
-/**
- * Picture data structure.
- *
- * Up to four components can be stored into it, the last component is
- * alpha.
- * @deprecated use AVFrame or imgutils functions instead
+ * Some hardware decoders (namely nvdec) can either output direct decoder
+ * surfaces, or make an on-device copy and return said copy.
+ * There is a hard limit on how many decoder surfaces there can be, and it
+ * cannot be accurately guessed ahead of time.
+ * For some processing chains, this can be okay, but others will run into the
+ * limit and in turn produce very confusing errors that require fine tuning of
+ * more or less obscure options by the user, or in extreme cases cannot be
+ * resolved at all without inserting an avfilter that forces a copy.
+ *
+ * Thus, the hwaccel will by default make a copy for safety and resilience.
+ * If a users really wants to minimize the amount of copies, they can set this
+ * flag and ensure their processing chain does not exhaust the surface pool.
  */
-typedef struct AVPicture {
-    attribute_deprecated
-    uint8_t *data[AV_NUM_DATA_POINTERS];    ///< pointers to the image data planes
-    attribute_deprecated
-    int linesize[AV_NUM_DATA_POINTERS];     ///< number of bytes per line
-} AVPicture;
+#define AV_HWACCEL_FLAG_UNSAFE_OUTPUT (1 << 3)
 
 /**
  * @}
  */
-#endif
 
 enum AVSubtitleType {
     SUBTITLE_NONE,
@@ -2691,13 +2307,6 @@
     int h;         ///< height           of pict, undefined when pict is not set
     int nb_colors; ///< number of colors in pict, undefined when pict is not set
 
-#if FF_API_AVPICTURE
-    /**
-     * @deprecated unused
-     */
-    attribute_deprecated
-    AVPicture pict;
-#endif
     /**
      * data+linesize for the bitmap of this subtitle.
      * Can be set for text/ass as well once they are rendered.
@@ -2728,16 +2337,6 @@
     int64_t pts;    ///< Same as packet pts, in AV_TIME_BASE
 } AVSubtitle;
 
-#if FF_API_NEXT
-/**
- * If c is NULL, returns the first registered codec,
- * if c is non-NULL, returns the next registered codec after c,
- * or NULL if c is the last one.
- */
-attribute_deprecated
-AVCodec *av_codec_next(const AVCodec *c);
-#endif
-
 /**
  * Return the LIBAVCODEC_VERSION_INT constant.
  */
@@ -2753,20 +2352,6 @@
  */
 const char *avcodec_license(void);
 
-#if FF_API_NEXT
-/**
- * @deprecated Calling this function is unnecessary.
- */
-attribute_deprecated
-void avcodec_register(AVCodec *codec);
-
-/**
- * @deprecated Calling this function is unnecessary.
- */
-attribute_deprecated
-void avcodec_register_all(void);
-#endif
-
 /**
  * Allocate an AVCodecContext and set its fields to default values. The
  * resulting struct should be freed with avcodec_free_context().
@@ -2788,15 +2373,6 @@
  */
 void avcodec_free_context(AVCodecContext **avctx);
 
-#if FF_API_GET_CONTEXT_DEFAULTS
-/**
- * @deprecated This function should not be used, as closing and opening a codec
- * context multiple time is not supported. A new codec context should be
- * allocated for each new use.
- */
-int avcodec_get_context_defaults3(AVCodecContext *s, const AVCodec *codec);
-#endif
-
 /**
  * Get the AVClass for AVCodecContext. It can be used in combination with
  * AV_OPT_SEARCH_FAKE_OBJ for examining options.
@@ -2805,14 +2381,6 @@
  */
 const AVClass *avcodec_get_class(void);
 
-#if FF_API_GET_FRAME_CLASS
-/**
- * @deprecated This function should not be used.
- */
-attribute_deprecated
-const AVClass *avcodec_get_frame_class(void);
-#endif
-
 /**
  * Get the AVClass for AVSubtitleRect. It can be used in combination with
  * AV_OPT_SEARCH_FAKE_OBJ for examining options.
@@ -2821,28 +2389,6 @@
  */
 const AVClass *avcodec_get_subtitle_rect_class(void);
 
-#if FF_API_COPY_CONTEXT
-/**
- * Copy the settings of the source AVCodecContext into the destination
- * AVCodecContext. The resulting destination codec context will be
- * unopened, i.e. you are required to call avcodec_open2() before you
- * can use this AVCodecContext to decode/encode video/audio data.
- *
- * @param dest target codec context, should be initialized with
- *             avcodec_alloc_context3(NULL), but otherwise uninitialized
- * @param src source codec context
- * @return AVERROR() on error (e.g. memory allocation error), 0 on success
- *
- * @deprecated The semantics of this function are ill-defined and it should not
- * be used. If you need to transfer the stream parameters from one codec context
- * to another, use an intermediate AVCodecParameters instance and the
- * avcodec_parameters_from_context() / avcodec_parameters_to_context()
- * functions.
- */
-attribute_deprecated
-int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src);
-#endif
-
 /**
  * Fill the parameters struct based on the values from the supplied codec
  * context. Any allocated fields in par are freed and replaced with duplicates
@@ -2872,8 +2418,6 @@
  * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
  * retrieving a codec.
  *
- * @warning This function is not thread safe!
- *
  * @note Always call this function before using decoding routines (such as
  * @ref avcodec_receive_frame()).
  *
@@ -2967,6 +2511,7 @@
 void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                                int linesize_align[AV_NUM_DATA_POINTERS]);
 
+#ifdef FF_API_AVCODEC_CHROMA_POS
 /**
  * Converts AVChromaLocation to swscale x/y chroma position.
  *
@@ -2975,7 +2520,9 @@
  *
  * @param xpos  horizontal chroma sample position
  * @param ypos  vertical   chroma sample position
+ * @deprecated Use av_chroma_location_enum_to_pos() instead.
  */
+ attribute_deprecated
 int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
 
 /**
@@ -2986,116 +2533,10 @@
  *
  * @param xpos  horizontal chroma sample position
  * @param ypos  vertical   chroma sample position
+ * @deprecated Use av_chroma_location_pos_to_enum() instead.
  */
+ attribute_deprecated
 enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);
-
-#if FF_API_OLD_ENCDEC
-/**
- * Decode the audio frame of size avpkt->size from avpkt->data into frame.
- *
- * Some decoders may support multiple frames in a single AVPacket. Such
- * decoders would then just decode the first frame and the return value would be
- * less than the packet size. In this case, avcodec_decode_audio4 has to be
- * called again with an AVPacket containing the remaining data in order to
- * decode the second frame, etc...  Even if no frames are returned, the packet
- * needs to be fed to the decoder with remaining data until it is completely
- * consumed or an error occurs.
- *
- * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
- * and output. This means that for some packets they will not immediately
- * produce decoded output and need to be flushed at the end of decoding to get
- * all the decoded data. Flushing is done by calling this function with packets
- * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
- * returning samples. It is safe to flush even those decoders that are not
- * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
- *
- * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
- *          larger than the actual read bytes because some optimized bitstream
- *          readers read 32 or 64 bits at once and could read over the end.
- *
- * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
- * before packets may be fed to the decoder.
- *
- * @param      avctx the codec context
- * @param[out] frame The AVFrame in which to store decoded audio samples.
- *                   The decoder will allocate a buffer for the decoded frame by
- *                   calling the AVCodecContext.get_buffer2() callback.
- *                   When AVCodecContext.refcounted_frames is set to 1, the frame is
- *                   reference counted and the returned reference belongs to the
- *                   caller. The caller must release the frame using av_frame_unref()
- *                   when the frame is no longer needed. The caller may safely write
- *                   to the frame if av_frame_is_writable() returns 1.
- *                   When AVCodecContext.refcounted_frames is set to 0, the returned
- *                   reference belongs to the decoder and is valid only until the
- *                   next call to this function or until closing or flushing the
- *                   decoder. The caller may not write to it.
- * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
- *                           non-zero. Note that this field being set to zero
- *                           does not mean that an error has occurred. For
- *                           decoders with AV_CODEC_CAP_DELAY set, no given decode
- *                           call is guaranteed to produce a frame.
- * @param[in]  avpkt The input AVPacket containing the input buffer.
- *                   At least avpkt->data and avpkt->size should be set. Some
- *                   decoders might also require additional fields to be set.
- * @return A negative error code is returned if an error occurred during
- *         decoding, otherwise the number of bytes consumed from the input
- *         AVPacket is returned.
- *
-* @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
- */
-attribute_deprecated
-int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,
-                          int *got_frame_ptr, const AVPacket *avpkt);
-
-/**
- * Decode the video frame of size avpkt->size from avpkt->data into picture.
- * Some decoders may support multiple frames in a single AVPacket, such
- * decoders would then just decode the first frame.
- *
- * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
- * the actual read bytes because some optimized bitstream readers read 32 or 64
- * bits at once and could read over the end.
- *
- * @warning The end of the input buffer buf should be set to 0 to ensure that
- * no overreading happens for damaged MPEG streams.
- *
- * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
- * between input and output, these need to be fed with avpkt->data=NULL,
- * avpkt->size=0 at the end to return the remaining frames.
- *
- * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
- * before packets may be fed to the decoder.
- *
- * @param avctx the codec context
- * @param[out] picture The AVFrame in which the decoded video frame will be stored.
- *             Use av_frame_alloc() to get an AVFrame. The codec will
- *             allocate memory for the actual bitmap by calling the
- *             AVCodecContext.get_buffer2() callback.
- *             When AVCodecContext.refcounted_frames is set to 1, the frame is
- *             reference counted and the returned reference belongs to the
- *             caller. The caller must release the frame using av_frame_unref()
- *             when the frame is no longer needed. The caller may safely write
- *             to the frame if av_frame_is_writable() returns 1.
- *             When AVCodecContext.refcounted_frames is set to 0, the returned
- *             reference belongs to the decoder and is valid only until the
- *             next call to this function or until closing or flushing the
- *             decoder. The caller may not write to it.
- *
- * @param[in] avpkt The input AVPacket containing the input buffer.
- *            You can create such packet with av_init_packet() and by then setting
- *            data and size, some decoders might in addition need other fields like
- *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
- *            fields possible.
- * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
- * @return On error a negative value is returned, otherwise the number of bytes
- * used or zero if no frame could be decompressed.
- *
- * @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
- */
-attribute_deprecated
-int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
-                         int *got_picture_ptr,
-                         const AVPacket *avpkt);
 #endif
 
 /**
@@ -3126,8 +2567,7 @@
  * @param[in] avpkt The input AVPacket containing the input buffer.
  */
 int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
-                            int *got_sub_ptr,
-                            AVPacket *avpkt);
+                             int *got_sub_ptr, const AVPacket *avpkt);
 
 /**
  * Supply raw packet data as input to a decoder.
@@ -3141,10 +2581,6 @@
  *          larger than the actual read bytes because some optimized bitstream
  *          readers read 32 or 64 bits at once and could read over the end.
  *
- * @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
- *          on the same AVCodecContext. It will return unexpected results now
- *          or in future libavcodec versions.
- *
  * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  *       before packets may be fed to the decoder.
  *
@@ -3167,40 +2603,41 @@
  *                  still has frames buffered, it will return them after sending
  *                  a flush packet.
  *
- * @return 0 on success, otherwise negative error code:
- *      AVERROR(EAGAIN):   input is not accepted in the current state - user
- *                         must read output with avcodec_receive_frame() (once
- *                         all output is read, the packet should be resent, and
- *                         the call will not fail with EAGAIN).
- *      AVERROR_EOF:       the decoder has been flushed, and no new packets can
- *                         be sent to it (also returned if more than 1 flush
- *                         packet is sent)
- *      AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
- *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
- *      other errors: legitimate decoding errors
+ * @retval 0                 success
+ * @retval AVERROR(EAGAIN)   input is not accepted in the current state - user
+ *                           must read output with avcodec_receive_frame() (once
+ *                           all output is read, the packet should be resent,
+ *                           and the call will not fail with EAGAIN).
+ * @retval AVERROR_EOF       the decoder has been flushed, and no new packets can be
+ *                           sent to it (also returned if more than 1 flush
+ *                           packet is sent)
+ * @retval AVERROR(EINVAL)   codec not opened, it is an encoder, or requires flush
+ * @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
+ * @retval "another negative error code" legitimate decoding errors
  */
 int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);
 
 /**
- * Return decoded output data from a decoder.
+ * Return decoded output data from a decoder or encoder (when the
+ * AV_CODEC_FLAG_RECON_FRAME flag is used).
  *
  * @param avctx codec context
  * @param frame This will be set to a reference-counted video or audio
  *              frame (depending on the decoder type) allocated by the
- *              decoder. Note that the function will always call
+ *              codec. Note that the function will always call
  *              av_frame_unref(frame) before doing anything else.
  *
- * @return
- *      0:                 success, a frame was returned
- *      AVERROR(EAGAIN):   output is not available in this state - user must try
- *                         to send new input
- *      AVERROR_EOF:       the decoder has been fully flushed, and there will be
- *                         no more output frames
- *      AVERROR(EINVAL):   codec not opened, or it is an encoder
- *      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters
- *                               with respect to first decoded frame. Applicable
- *                               when flag AV_CODEC_FLAG_DROPCHANGED is set.
- *      other negative values: legitimate decoding errors
+ * @retval 0                success, a frame was returned
+ * @retval AVERROR(EAGAIN)  output is not available in this state - user must
+ *                          try to send new input
+ * @retval AVERROR_EOF      the codec has been fully flushed, and there will be
+ *                          no more output frames
+ * @retval AVERROR(EINVAL)  codec not opened, or it is an encoder without the
+ *                          AV_CODEC_FLAG_RECON_FRAME flag enabled
+ * @retval AVERROR_INPUT_CHANGED current decoded frame has changed parameters with
+ *                          respect to first decoded frame. Applicable when flag
+ *                          AV_CODEC_FLAG_DROPCHANGED is set.
+ * @retval "other negative error code" legitimate decoding errors
  */
 int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);
 
@@ -3227,17 +2664,16 @@
  *                  If it is not set, frame->nb_samples must be equal to
  *                  avctx->frame_size for all frames except the last.
  *                  The final frame may be smaller than avctx->frame_size.
- * @return 0 on success, otherwise negative error code:
- *      AVERROR(EAGAIN):   input is not accepted in the current state - user
- *                         must read output with avcodec_receive_packet() (once
- *                         all output is read, the packet should be resent, and
- *                         the call will not fail with EAGAIN).
- *      AVERROR_EOF:       the encoder has been flushed, and no new frames can
- *                         be sent to it
- *      AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
- *                         decoder, or requires flush
- *      AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
- *      other errors: legitimate encoding errors
+ * @retval 0                 success
+ * @retval AVERROR(EAGAIN)   input is not accepted in the current state - user must
+ *                           read output with avcodec_receive_packet() (once all
+ *                           output is read, the packet should be resent, and the
+ *                           call will not fail with EAGAIN).
+ * @retval AVERROR_EOF       the encoder has been flushed, and no new frames can
+ *                           be sent to it
+ * @retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires flush
+ * @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
+ * @retval "another negative error code" legitimate encoding errors
  */
 int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame);
 
@@ -3248,13 +2684,13 @@
  * @param avpkt This will be set to a reference-counted packet allocated by the
  *              encoder. Note that the function will always call
  *              av_packet_unref(avpkt) before doing anything else.
- * @return 0 on success, otherwise negative error code:
- *      AVERROR(EAGAIN):   output is not available in the current state - user
- *                         must try to send input
- *      AVERROR_EOF:       the encoder has been fully flushed, and there will be
- *                         no more output packets
- *      AVERROR(EINVAL):   codec not opened, or it is a decoder
- *      other errors: legitimate encoding errors
+ * @retval 0               success
+ * @retval AVERROR(EAGAIN) output is not available in the current state - user must
+ *                         try to send input
+ * @retval AVERROR_EOF     the encoder has been fully flushed, and there will be no
+ *                         more output packets
+ * @retval AVERROR(EINVAL) codec not opened, or it is a decoder
+ * @retval "another negative error code" legitimate encoding errors
  */
 int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);
 
@@ -3368,15 +2804,15 @@
  */
 
 enum AVPictureStructure {
-    AV_PICTURE_STRUCTURE_UNKNOWN,      //< unknown
-    AV_PICTURE_STRUCTURE_TOP_FIELD,    //< coded as top field
-    AV_PICTURE_STRUCTURE_BOTTOM_FIELD, //< coded as bottom field
-    AV_PICTURE_STRUCTURE_FRAME,        //< coded as frame
+    AV_PICTURE_STRUCTURE_UNKNOWN,      ///< unknown
+    AV_PICTURE_STRUCTURE_TOP_FIELD,    ///< coded as top field
+    AV_PICTURE_STRUCTURE_BOTTOM_FIELD, ///< coded as bottom field
+    AV_PICTURE_STRUCTURE_FRAME,        ///< coded as frame
 };
 
 typedef struct AVCodecParserContext {
     void *priv_data;
-    struct AVCodecParser *parser;
+    const struct AVCodecParser *parser;
     int64_t frame_offset; /* offset of the current frame */
     int64_t cur_offset; /* current offset
                            (incremented by each av_parser_parse()) */
@@ -3425,14 +2861,6 @@
      */
     int key_frame;
 
-#if FF_API_CONVERGENCE_DURATION
-    /**
-     * @deprecated unused
-     */
-    attribute_deprecated
-    int64_t convergence_duration;
-#endif
-
     // Timestamp generation support:
     /**
      * Synchronization point for start of timestamp generation.
@@ -3542,7 +2970,7 @@
 } AVCodecParserContext;
 
 typedef struct AVCodecParser {
-    int codec_ids[5]; /* several codec IDs are permitted */
+    int codec_ids[7]; /* several codec IDs are permitted */
     int priv_data_size;
     int (*parser_init)(AVCodecParserContext *s);
     /* This callback never returns an error, a negative value means that
@@ -3553,10 +2981,6 @@
                         const uint8_t *buf, int buf_size);
     void (*parser_close)(AVCodecParserContext *s);
     int (*split)(AVCodecContext *avctx, const uint8_t *buf, int buf_size);
-#if FF_API_NEXT
-    attribute_deprecated
-    struct AVCodecParser *next;
-#endif
 } AVCodecParser;
 
 /**
@@ -3570,13 +2994,6 @@
  */
 const AVCodecParser *av_parser_iterate(void **opaque);
 
-#if FF_API_NEXT
-attribute_deprecated
-AVCodecParser *av_parser_next(const AVCodecParser *c);
-
-attribute_deprecated
-void av_register_codec_parser(AVCodecParser *parser);
-#endif
 AVCodecParserContext *av_parser_init(int codec_id);
 
 /**
@@ -3617,18 +3034,6 @@
                      int64_t pts, int64_t dts,
                      int64_t pos);
 
-#if FF_API_PARSER_CHANGE
-/**
- * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
- * @deprecated Use dump_extradata, remove_extra or extract_extradata
- *             bitstream filters instead.
- */
-attribute_deprecated
-int av_parser_change(AVCodecParserContext *s,
-                     AVCodecContext *avctx,
-                     uint8_t **poutbuf, int *poutbuf_size,
-                     const uint8_t *buf, int buf_size, int keyframe);
-#endif
 void av_parser_close(AVCodecParserContext *s);
 
 /**
@@ -3641,95 +3046,6 @@
  * @{
  */
 
-#if FF_API_OLD_ENCDEC
-/**
- * Encode a frame of audio.
- *
- * Takes input samples from frame and writes the next output packet, if
- * available, to avpkt. The output packet does not necessarily contain data for
- * the most recent frame, as encoders can delay, split, and combine input frames
- * internally as needed.
- *
- * @param avctx     codec context
- * @param avpkt     output AVPacket.
- *                  The user can supply an output buffer by setting
- *                  avpkt->data and avpkt->size prior to calling the
- *                  function, but if the size of the user-provided data is not
- *                  large enough, encoding will fail. If avpkt->data and
- *                  avpkt->size are set, avpkt->destruct must also be set. All
- *                  other AVPacket fields will be reset by the encoder using
- *                  av_init_packet(). If avpkt->data is NULL, the encoder will
- *                  allocate it. The encoder will set avpkt->size to the size
- *                  of the output packet.
- *
- *                  If this function fails or produces no output, avpkt will be
- *                  freed using av_packet_unref().
- * @param[in] frame AVFrame containing the raw audio data to be encoded.
- *                  May be NULL when flushing an encoder that has the
- *                  AV_CODEC_CAP_DELAY capability set.
- *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
- *                  can have any number of samples.
- *                  If it is not set, frame->nb_samples must be equal to
- *                  avctx->frame_size for all frames except the last.
- *                  The final frame may be smaller than avctx->frame_size.
- * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
- *                            output packet is non-empty, and to 0 if it is
- *                            empty. If the function returns an error, the
- *                            packet can be assumed to be invalid, and the
- *                            value of got_packet_ptr is undefined and should
- *                            not be used.
- * @return          0 on success, negative error code on failure
- *
- * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead.
- *             If allowed and required, set AVCodecContext.get_encode_buffer to
- *             a custom function to pass user supplied output buffers.
- */
-attribute_deprecated
-int avcodec_encode_audio2(AVCodecContext *avctx, AVPacket *avpkt,
-                          const AVFrame *frame, int *got_packet_ptr);
-
-/**
- * Encode a frame of video.
- *
- * Takes input raw video data from frame and writes the next output packet, if
- * available, to avpkt. The output packet does not necessarily contain data for
- * the most recent frame, as encoders can delay and reorder input frames
- * internally as needed.
- *
- * @param avctx     codec context
- * @param avpkt     output AVPacket.
- *                  The user can supply an output buffer by setting
- *                  avpkt->data and avpkt->size prior to calling the
- *                  function, but if the size of the user-provided data is not
- *                  large enough, encoding will fail. All other AVPacket fields
- *                  will be reset by the encoder using av_init_packet(). If
- *                  avpkt->data is NULL, the encoder will allocate it.
- *                  The encoder will set avpkt->size to the size of the
- *                  output packet. The returned data (if any) belongs to the
- *                  caller, he is responsible for freeing it.
- *
- *                  If this function fails or produces no output, avpkt will be
- *                  freed using av_packet_unref().
- * @param[in] frame AVFrame containing the raw video data to be encoded.
- *                  May be NULL when flushing an encoder that has the
- *                  AV_CODEC_CAP_DELAY capability set.
- * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
- *                            output packet is non-empty, and to 0 if it is
- *                            empty. If the function returns an error, the
- *                            packet can be assumed to be invalid, and the
- *                            value of got_packet_ptr is undefined and should
- *                            not be used.
- * @return          0 on success, negative error code on failure
- *
- * @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead.
- *             If allowed and required, set AVCodecContext.get_encode_buffer to
- *             a custom function to pass user supplied output buffers.
- */
-attribute_deprecated
-int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt,
-                          const AVFrame *frame, int *got_packet_ptr);
-#endif
-
 int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
                             const AVSubtitle *sub);
 
@@ -3738,71 +3054,6 @@
  * @}
  */
 
-#if FF_API_AVPICTURE
-/**
- * @addtogroup lavc_picture
- * @{
- */
-
-/**
- * @deprecated unused
- */
-attribute_deprecated
-int avpicture_alloc(AVPicture *picture, enum AVPixelFormat pix_fmt, int width, int height);
-
-/**
- * @deprecated unused
- */
-attribute_deprecated
-void avpicture_free(AVPicture *picture);
-
-/**
- * @deprecated use av_image_fill_arrays() instead.
- */
-attribute_deprecated
-int avpicture_fill(AVPicture *picture, const uint8_t *ptr,
-                   enum AVPixelFormat pix_fmt, int width, int height);
-
-/**
- * @deprecated use av_image_copy_to_buffer() instead.
- */
-attribute_deprecated
-int avpicture_layout(const AVPicture *src, enum AVPixelFormat pix_fmt,
-                     int width, int height,
-                     unsigned char *dest, int dest_size);
-
-/**
- * @deprecated use av_image_get_buffer_size() instead.
- */
-attribute_deprecated
-int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height);
-
-/**
- * @deprecated av_image_copy() instead.
- */
-attribute_deprecated
-void av_picture_copy(AVPicture *dst, const AVPicture *src,
-                     enum AVPixelFormat pix_fmt, int width, int height);
-
-/**
- * @deprecated unused
- */
-attribute_deprecated
-int av_picture_crop(AVPicture *dst, const AVPicture *src,
-                    enum AVPixelFormat pix_fmt, int top_band, int left_band);
-
-/**
- * @deprecated unused
- */
-attribute_deprecated
-int av_picture_pad(AVPicture *dst, const AVPicture *src, int height, int width, enum AVPixelFormat pix_fmt,
-            int padtop, int padbottom, int padleft, int padright, int *color);
-
-/**
- * @}
- */
-#endif
-
 /**
  * @defgroup lavc_misc Utility functions
  * @ingroup libavc
@@ -3819,15 +3070,6 @@
  * @{
  */
 
-#if FF_API_GETCHROMA
-/**
- * @deprecated Use av_pix_fmt_get_chroma_sub_sample
- */
-
-attribute_deprecated
-void avcodec_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift);
-#endif
-
 /**
  * Return a value representing the fourCC code associated to the
  * pixel format pix_fmt, or 0 if no associated fourCC code can be
@@ -3856,71 +3098,14 @@
                                             enum AVPixelFormat src_pix_fmt,
                                             int has_alpha, int *loss_ptr);
 
-#if FF_API_AVCODEC_PIX_FMT
-/**
- * @deprecated see av_get_pix_fmt_loss()
- */
-attribute_deprecated
-int avcodec_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt,
-                             int has_alpha);
-/**
- * @deprecated see av_find_best_pix_fmt_of_2()
- */
-attribute_deprecated
-enum AVPixelFormat avcodec_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                            enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
-
-attribute_deprecated
-enum AVPixelFormat avcodec_find_best_pix_fmt2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                            enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
-#endif
-
 enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
 
 /**
  * @}
  */
 
-#if FF_API_TAG_STRING
-/**
- * Put a string representing the codec tag codec_tag in buf.
- *
- * @param buf       buffer to place codec tag in
- * @param buf_size size in bytes of buf
- * @param codec_tag codec tag to assign
- * @return the length of the string that would have been generated if
- * enough space had been available, excluding the trailing null
- *
- * @deprecated see av_fourcc_make_string() and av_fourcc2str().
- */
-attribute_deprecated
-size_t av_get_codec_tag_string(char *buf, size_t buf_size, unsigned int codec_tag);
-#endif
-
 void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode);
 
-/**
- * Return a name for the specified profile, if available.
- *
- * @param codec the codec that is searched for the given profile
- * @param profile the profile value for which a name is requested
- * @return A name for the profile if found, NULL otherwise.
- */
-const char *av_get_profile_name(const AVCodec *codec, int profile);
-
-/**
- * Return a name for the specified profile, if available.
- *
- * @param codec_id the ID of the codec to which the requested profile belongs
- * @param profile the profile value for which a name is requested
- * @return A name for the profile if found, NULL otherwise.
- *
- * @note unlike av_get_profile_name(), which searches a list of profiles
- *       supported by a specific decoder or encoder implementation, this
- *       function searches the list of profiles from the AVCodecDescriptor
- */
-const char *avcodec_profile_name(enum AVCodecID codec_id, int profile);
-
 int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2),void *arg, int *ret, int count, int size);
 int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int, int),void *arg, int *ret, int count);
 //FIXME func typedef
@@ -3956,11 +3141,8 @@
  * Reset the internal codec state / flush internal buffers. Should be called
  * e.g. when seeking or when switching to a different stream.
  *
- * @note for decoders, when refcounted frames are not used
- * (i.e. avctx->refcounted_frames is 0), this invalidates the frames previously
- * returned from the decoder. When refcounted frames are used, the decoder just
- * releases any references it might keep internally, but the caller's reference
- * remains valid.
+ * @note for decoders, this function just releases any references the decoder
+ * might keep internally, but the caller's references remain valid.
  *
  * @note for encoders, this function will only do something if the encoder
  * declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder
@@ -3972,32 +3154,6 @@
 void avcodec_flush_buffers(AVCodecContext *avctx);
 
 /**
- * Return codec bits per sample.
- *
- * @param[in] codec_id the codec
- * @return Number of bits per sample or zero if unknown for the given codec.
- */
-int av_get_bits_per_sample(enum AVCodecID codec_id);
-
-/**
- * Return the PCM codec associated with a sample format.
- * @param be  endianness, 0 for little, 1 for big,
- *            -1 (or anything else) for native
- * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
- */
-enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be);
-
-/**
- * Return codec bits per sample.
- * Only return non-zero if the bits per sample is exactly correct, not an
- * approximation.
- *
- * @param[in] codec_id the codec
- * @return Number of bits per sample or zero if unknown for the given codec.
- */
-int av_get_exact_bits_per_sample(enum AVCodecID codec_id);
-
-/**
  * Return audio frame duration.
  *
  * @param avctx        codec context
@@ -4007,69 +3163,6 @@
  */
 int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes);
 
-/**
- * This function is the same as av_get_audio_frame_duration(), except it works
- * with AVCodecParameters instead of an AVCodecContext.
- */
-int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes);
-
-#if FF_API_OLD_BSF
-typedef struct AVBitStreamFilterContext {
-    void *priv_data;
-    const struct AVBitStreamFilter *filter;
-    AVCodecParserContext *parser;
-    struct AVBitStreamFilterContext *next;
-    /**
-     * Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
-     * Not for access by library users.
-     */
-    char *args;
-} AVBitStreamFilterContext;
-
-/**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use the new bitstream filtering API (using AVBSFContext).
- */
-attribute_deprecated
-void av_register_bitstream_filter(AVBitStreamFilter *bsf);
-/**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()
- * from the new bitstream filtering API (using AVBSFContext).
- */
-attribute_deprecated
-AVBitStreamFilterContext *av_bitstream_filter_init(const char *name);
-/**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the
- * new bitstream filtering API (using AVBSFContext).
- */
-attribute_deprecated
-int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
-                               AVCodecContext *avctx, const char *args,
-                               uint8_t **poutbuf, int *poutbuf_size,
-                               const uint8_t *buf, int buf_size, int keyframe);
-/**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_free() from the new bitstream filtering API (using
- * AVBSFContext).
- */
-attribute_deprecated
-void av_bitstream_filter_close(AVBitStreamFilterContext *bsf);
-/**
- * @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
- * is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using
- * AVBSFContext).
- */
-attribute_deprecated
-const AVBitStreamFilter *av_bitstream_filter_next(const AVBitStreamFilter *f);
-#endif
-
-#if FF_API_NEXT
-attribute_deprecated
-const AVBitStreamFilter *av_bsf_next(void **opaque);
-#endif
-
 /* memory */
 
 /**
@@ -4088,96 +3181,12 @@
 void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size);
 
 /**
- * Encode extradata length to a buffer. Used by xiph codecs.
- *
- * @param s buffer to write to; must be at least (v/255+1) bytes long
- * @param v size of extradata in bytes
- * @return number of bytes written to the buffer.
- */
-unsigned int av_xiphlacing(unsigned char *s, unsigned int v);
-
-#if FF_API_USER_VISIBLE_AVHWACCEL
-/**
- * Register the hardware accelerator hwaccel.
- *
- * @deprecated  This function doesn't do anything.
- */
-attribute_deprecated
-void av_register_hwaccel(AVHWAccel *hwaccel);
-
-/**
- * If hwaccel is NULL, returns the first registered hardware accelerator,
- * if hwaccel is non-NULL, returns the next registered hardware accelerator
- * after hwaccel, or NULL if hwaccel is the last one.
- *
- * @deprecated  AVHWaccel structures contain no user-serviceable parts, so
- *              this function should not be used.
- */
-attribute_deprecated
-AVHWAccel *av_hwaccel_next(const AVHWAccel *hwaccel);
-#endif
-
-#if FF_API_LOCKMGR
-/**
- * Lock operation used by lockmgr
- *
- * @deprecated Deprecated together with av_lockmgr_register().
- */
-enum AVLockOp {
-  AV_LOCK_CREATE,  ///< Create a mutex
-  AV_LOCK_OBTAIN,  ///< Lock the mutex
-  AV_LOCK_RELEASE, ///< Unlock the mutex
-  AV_LOCK_DESTROY, ///< Free mutex resources
-};
-
-/**
- * Register a user provided lock manager supporting the operations
- * specified by AVLockOp. The "mutex" argument to the function points
- * to a (void *) where the lockmgr should store/get a pointer to a user
- * allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
- * value left by the last call for all other ops. If the lock manager is
- * unable to perform the op then it should leave the mutex in the same
- * state as when it was called and return a non-zero value. However,
- * when called with AV_LOCK_DESTROY the mutex will always be assumed to
- * have been successfully destroyed. If av_lockmgr_register succeeds
- * it will return a non-negative value, if it fails it will return a
- * negative value and destroy all mutex and unregister all callbacks.
- * av_lockmgr_register is not thread-safe, it must be called from a
- * single thread before any calls which make use of locking are used.
- *
- * @param cb User defined callback. av_lockmgr_register invokes calls
- *           to this callback and the previously registered callback.
- *           The callback will be used to create more than one mutex
- *           each of which must be backed by its own underlying locking
- *           mechanism (i.e. do not use a single static object to
- *           implement your lock manager). If cb is set to NULL the
- *           lockmgr will be unregistered.
- *
- * @deprecated This function does nothing, and always returns 0. Be sure to
- *             build with thread support to get basic thread safety.
- */
-attribute_deprecated
-int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op));
-#endif
-
-/**
  * @return a positive value if s is open (i.e. avcodec_open2() was called on it
  * with no corresponding avcodec_close()), 0 otherwise.
  */
 int avcodec_is_open(AVCodecContext *s);
 
 /**
- * Allocate a CPB properties structure and initialize its fields to default
- * values.
- *
- * @param size if non-NULL, the size of the allocated struct will be written
- *             here. This is useful for embedding it in side data.
- *
- * @return the newly allocated struct or NULL on failure
- */
-AVCPBProperties *av_cpb_properties_alloc(size_t *size);
-
-/**
  * @}
  */
 
diff -Naur a/media/ffvpx/libavcodec/avcodec.symbols b/media/ffvpx/libavcodec/avcodec.symbols
--- a/media/ffvpx/libavcodec/avcodec.symbols	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/avcodec.symbols	2023-04-06 12:50:28.394333574 +0200
@@ -1,47 +1,26 @@
 av_codec_ffversion
-av_codec_get_chroma_intra_matrix
-av_codec_get_codec_descriptor
-av_codec_get_codec_properties
-av_codec_get_lowres
-av_codec_get_max_lowres
-av_codec_get_pkt_timebase
-av_codec_get_seek_preroll
 av_codec_is_decoder
 av_codec_is_encoder
 av_codec_iterate
-av_codec_next
-av_codec_set_chroma_intra_matrix
-av_codec_set_codec_descriptor
-av_codec_set_lowres
-av_codec_set_pkt_timebase
-av_codec_set_seek_preroll
-av_copy_packet
-av_copy_packet_side_data
-av_dup_packet
 av_fast_padded_malloc
 av_fast_padded_mallocz
-av_free_packet
 av_get_audio_frame_duration
 av_get_bits_per_sample
-av_get_codec_tag_string
 av_get_exact_bits_per_sample
 av_get_pcm_codec
 av_get_profile_name
 av_grow_packet
-av_hwaccel_next
 av_hwdevice_ctx_init
 av_hwdevice_ctx_alloc
 av_hwdevice_ctx_create_derived
 av_hwframe_transfer_get_formats
 av_hwframe_ctx_alloc
 av_init_packet
-av_lockmgr_register
 av_new_packet
 av_packet_copy_props
 av_packet_free_side_data
 av_packet_from_data
 av_packet_get_side_data
-av_packet_merge_side_data
 av_packet_move_ref
 av_packet_new_side_data
 av_packet_pack_dictionary
@@ -49,21 +28,16 @@
 av_packet_rescale_ts
 av_packet_shrink_side_data
 av_packet_side_data_name
-av_packet_split_side_data
 av_packet_unpack_dictionary
 av_packet_unref
-av_parser_change
 av_parser_close
 av_parser_init
-av_parser_next
 av_parser_parse2
 #ifdef MOZ_LIBAV_FFT
 av_rdft_calc
 av_rdft_end
 av_rdft_init
 #endif
-av_register_codec_parser
-av_register_hwaccel
 av_shrink_packet
 av_vorbis_parse_frame
 av_vorbis_parse_frame_flags
@@ -77,10 +51,7 @@
 avcodec_chroma_pos_to_enum
 avcodec_close
 avcodec_configuration
-avcodec_copy_context
-avcodec_decode_audio4
 avcodec_decode_subtitle2
-avcodec_decode_video2
 avcodec_default_execute
 avcodec_default_execute2
 avcodec_default_get_buffer2
@@ -97,8 +68,6 @@
 avcodec_flush_buffers
 avcodec_free_context
 avcodec_get_class
-avcodec_get_context_defaults3
-avcodec_get_frame_class
 avcodec_get_hw_config
 avcodec_get_name
 avcodec_get_subtitle_rect_class
@@ -106,10 +75,12 @@
 avcodec_is_open
 avcodec_license
 avcodec_open2
-avcodec_register
-avcodec_register_all
 avcodec_string
 avcodec_version
 avsubtitle_free
 avcodec_send_packet
 avcodec_receive_frame
+ff_init_vlc_from_lengths
+ff_init_vlc_sparse
+ff_mpa_freq_tab
+ff_mpa_bitrate_tab
diff -Naur a/media/ffvpx/libavcodec/avpacket.c b/media/ffvpx/libavcodec/avpacket.c
--- a/media/ffvpx/libavcodec/avpacket.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/avpacket.c	2023-04-06 12:50:24.491176503 +0200
@@ -22,13 +22,12 @@
 #include <string.h>
 
 #include "libavutil/avassert.h"
-#include "libavutil/common.h"
-#include "libavutil/internal.h"
+#include "libavutil/intreadwrite.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/mem.h"
+#include "libavutil/rational.h"
 
-#include "bytestream.h"
-#include "internal.h"
+#include "defs.h"
 #include "packet.h"
 #include "packet_internal.h"
 
@@ -39,16 +38,14 @@
     pkt->dts                  = AV_NOPTS_VALUE;
     pkt->pos                  = -1;
     pkt->duration             = 0;
-#if FF_API_CONVERGENCE_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-    pkt->convergence_duration = 0;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     pkt->flags                = 0;
     pkt->stream_index         = 0;
     pkt->buf                  = NULL;
     pkt->side_data            = NULL;
     pkt->side_data_elems      = 0;
+    pkt->opaque               = NULL;
+    pkt->opaque_ref           = NULL;
+    pkt->time_base            = av_make_q(0, 1);
 }
 #endif
 
@@ -59,11 +56,12 @@
     pkt->pts             = AV_NOPTS_VALUE;
     pkt->dts             = AV_NOPTS_VALUE;
     pkt->pos             = -1;
+    pkt->time_base       = av_make_q(0, 1);
 }
 
 AVPacket *av_packet_alloc(void)
 {
-    AVPacket *pkt = av_mallocz(sizeof(AVPacket));
+    AVPacket *pkt = av_malloc(sizeof(AVPacket));
     if (!pkt)
         return pkt;
 
@@ -142,7 +140,14 @@
 
         if (new_size + data_offset > pkt->buf->size ||
             !av_buffer_is_writable(pkt->buf)) {
-            int ret = av_buffer_realloc(&pkt->buf, new_size + data_offset);
+            int ret;
+
+            // allocate slightly more than requested to avoid excessive
+            // reallocations
+            if (new_size + data_offset < INT_MAX - new_size/16)
+                new_size += new_size/16;
+
+            ret = av_buffer_realloc(&pkt->buf, new_size + data_offset);
             if (ret < 0) {
                 pkt->data = old_data;
                 return ret;
@@ -179,108 +184,6 @@
     return 0;
 }
 
-#if FF_API_AVPACKET_OLD_API
-FF_DISABLE_DEPRECATION_WARNINGS
-#define ALLOC_MALLOC(data, size) data = av_malloc(size)
-#define ALLOC_BUF(data, size)                \
-do {                                         \
-    av_buffer_realloc(&pkt->buf, size);      \
-    data = pkt->buf ? pkt->buf->data : NULL; \
-} while (0)
-
-#define DUP_DATA(dst, src, size, padding, ALLOC)                        \
-    do {                                                                \
-        void *data;                                                     \
-        if (padding) {                                                  \
-            if ((unsigned)(size) >                                      \
-                (unsigned)(size) + AV_INPUT_BUFFER_PADDING_SIZE)        \
-                goto failed_alloc;                                      \
-            ALLOC(data, size + AV_INPUT_BUFFER_PADDING_SIZE);           \
-        } else {                                                        \
-            ALLOC(data, size);                                          \
-        }                                                               \
-        if (!data)                                                      \
-            goto failed_alloc;                                          \
-        memcpy(data, src, size);                                        \
-        if (padding)                                                    \
-            memset((uint8_t *)data + size, 0,                           \
-                   AV_INPUT_BUFFER_PADDING_SIZE);                       \
-        dst = data;                                                     \
-    } while (0)
-
-/* Makes duplicates of data, side_data, but does not copy any other fields */
-static int copy_packet_data(AVPacket *pkt, const AVPacket *src, int dup)
-{
-    pkt->data      = NULL;
-    pkt->side_data = NULL;
-    pkt->side_data_elems = 0;
-    if (pkt->buf) {
-        AVBufferRef *ref = av_buffer_ref(src->buf);
-        if (!ref)
-            return AVERROR(ENOMEM);
-        pkt->buf  = ref;
-        pkt->data = ref->data;
-    } else {
-        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);
-    }
-    if (src->side_data_elems && dup) {
-        pkt->side_data = src->side_data;
-        pkt->side_data_elems = src->side_data_elems;
-    }
-    if (src->side_data_elems && !dup) {
-        return av_copy_packet_side_data(pkt, src);
-    }
-    return 0;
-
-failed_alloc:
-    av_packet_unref(pkt);
-    return AVERROR(ENOMEM);
-}
-
-int av_copy_packet_side_data(AVPacket *pkt, const AVPacket *src)
-{
-    if (src->side_data_elems) {
-        int i;
-        DUP_DATA(pkt->side_data, src->side_data,
-                src->side_data_elems * sizeof(*src->side_data), 0, ALLOC_MALLOC);
-        if (src != pkt) {
-            memset(pkt->side_data, 0,
-                   src->side_data_elems * sizeof(*src->side_data));
-        }
-        for (i = 0; i < src->side_data_elems; i++) {
-            DUP_DATA(pkt->side_data[i].data, src->side_data[i].data,
-                    src->side_data[i].size, 1, ALLOC_MALLOC);
-            pkt->side_data[i].size = src->side_data[i].size;
-            pkt->side_data[i].type = src->side_data[i].type;
-        }
-    }
-    pkt->side_data_elems = src->side_data_elems;
-    return 0;
-
-failed_alloc:
-    av_packet_unref(pkt);
-    return AVERROR(ENOMEM);
-}
-
-int av_dup_packet(AVPacket *pkt)
-{
-    AVPacket tmp_pkt;
-
-    if (!pkt->buf && pkt->data) {
-        tmp_pkt = *pkt;
-        return copy_packet_data(pkt, &tmp_pkt, 1);
-    }
-    return 0;
-}
-
-int av_copy_packet(AVPacket *dst, const AVPacket *src)
-{
-    *dst = *src;
-    return copy_packet_data(dst, src, 0);
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 void av_packet_free_side_data(AVPacket *pkt)
 {
     int i;
@@ -290,22 +193,6 @@
     pkt->side_data_elems = 0;
 }
 
-#if FF_API_AVPACKET_OLD_API
-FF_DISABLE_DEPRECATION_WARNINGS
-void av_free_packet(AVPacket *pkt)
-{
-    if (pkt) {
-        if (pkt->buf)
-            av_buffer_unref(&pkt->buf);
-        pkt->data            = NULL;
-        pkt->size            = 0;
-
-        av_packet_free_side_data(pkt);
-    }
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
                             uint8_t *data, size_t size)
 {
@@ -341,16 +228,12 @@
 
 
 uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                                 buffer_size_t size)
+                                 size_t size)
 {
     int ret;
     uint8_t *data;
 
-#if FF_API_BUFFER_SIZE_T
-    if ((unsigned)size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE)
-#else
     if (size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE)
-#endif
         return NULL;
     data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
     if (!data)
@@ -366,7 +249,7 @@
 }
 
 uint8_t *av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type,
-                                 buffer_size_t *size)
+                                 size_t *size)
 {
     int i;
 
@@ -416,102 +299,12 @@
     case AV_PKT_DATA_ICC_PROFILE:                return "ICC Profile";
     case AV_PKT_DATA_DOVI_CONF:                  return "DOVI configuration record";
     case AV_PKT_DATA_S12M_TIMECODE:              return "SMPTE ST 12-1:2014 timecode";
+    case AV_PKT_DATA_DYNAMIC_HDR10_PLUS:         return "HDR10+ Dynamic Metadata (SMPTE 2094-40)";
     }
     return NULL;
 }
 
-#if FF_API_MERGE_SD_API
-
-#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL
-
-int av_packet_merge_side_data(AVPacket *pkt){
-    if(pkt->side_data_elems){
-        AVBufferRef *buf;
-        int i;
-        uint8_t *p;
-        uint64_t size= pkt->size + 8LL + AV_INPUT_BUFFER_PADDING_SIZE;
-        AVPacket old= *pkt;
-        for (i=0; i<old.side_data_elems; i++) {
-            size += old.side_data[i].size + 5LL;
-        }
-        if (size > INT_MAX)
-            return AVERROR(EINVAL);
-        buf = av_buffer_alloc(size);
-        if (!buf)
-            return AVERROR(ENOMEM);
-        pkt->buf = buf;
-        pkt->data = p = buf->data;
-        pkt->size = size - AV_INPUT_BUFFER_PADDING_SIZE;
-        bytestream_put_buffer(&p, old.data, old.size);
-        for (i=old.side_data_elems-1; i>=0; i--) {
-            bytestream_put_buffer(&p, old.side_data[i].data, old.side_data[i].size);
-            bytestream_put_be32(&p, old.side_data[i].size);
-            *p++ = old.side_data[i].type | ((i==old.side_data_elems-1)*128);
-        }
-        bytestream_put_be64(&p, FF_MERGE_MARKER);
-        av_assert0(p-pkt->data == pkt->size);
-        memset(p, 0, AV_INPUT_BUFFER_PADDING_SIZE);
-        av_packet_unref(&old);
-        pkt->side_data_elems = 0;
-        pkt->side_data = NULL;
-        return 1;
-    }
-    return 0;
-}
-
-int av_packet_split_side_data(AVPacket *pkt){
-    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){
-        int i;
-        unsigned int size;
-        uint8_t *p;
-
-        p = pkt->data + pkt->size - 8 - 5;
-        for (i=1; ; i++){
-            size = AV_RB32(p);
-            if (size>INT_MAX - 5 || p - pkt->data < size)
-                return 0;
-            if (p[4]&128)
-                break;
-            if (p - pkt->data < size + 5)
-                return 0;
-            p-= size+5;
-        }
-
-        if (i > AV_PKT_DATA_NB)
-            return AVERROR(ERANGE);
-
-        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));
-        if (!pkt->side_data)
-            return AVERROR(ENOMEM);
-
-        p= pkt->data + pkt->size - 8 - 5;
-        for (i=0; ; i++){
-            size= AV_RB32(p);
-            av_assert0(size<=INT_MAX - 5 && p - pkt->data >= size);
-            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
-            pkt->side_data[i].size = size;
-            pkt->side_data[i].type = p[4]&127;
-            if (!pkt->side_data[i].data)
-                return AVERROR(ENOMEM);
-            memcpy(pkt->side_data[i].data, p-size, size);
-            pkt->size -= size + 5;
-            if(p[4]&128)
-                break;
-            p-= size+5;
-        }
-        pkt->size -= 8;
-        pkt->side_data_elems = i+1;
-        return 1;
-    }
-    return 0;
-}
-#endif
-
-#if FF_API_BUFFER_SIZE_T
-uint8_t *av_packet_pack_dictionary(AVDictionary *dict, int *size)
-#else
 uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size)
-#endif
 {
     uint8_t *data = NULL;
     *size = 0;
@@ -523,18 +316,14 @@
         const AVDictionaryEntry *t = NULL;
         size_t total_length = 0;
 
-        while ((t = av_dict_get(dict, "", t, AV_DICT_IGNORE_SUFFIX))) {
+        while ((t = av_dict_iterate(dict, t))) {
             for (int i = 0; i < 2; i++) {
                 const char  *str = i ? t->value : t->key;
                 const size_t len = strlen(str) + 1;
 
                 if (pass)
                     memcpy(data + total_length, str, len);
-#if FF_API_BUFFER_SIZE_T
-                else if (len > INT_MAX - total_length)
-#else
                 else if (len > SIZE_MAX - total_length)
-#endif
                     return NULL;
                 total_length += len;
             }
@@ -550,12 +339,8 @@
     return data;
 }
 
-#if FF_API_BUFFER_SIZE_T
-int av_packet_unpack_dictionary(const uint8_t *data, int size, AVDictionary **dict)
-#else
 int av_packet_unpack_dictionary(const uint8_t *data, size_t size,
                                 AVDictionary **dict)
-#endif
 {
     const uint8_t *end;
     int ret;
@@ -582,7 +367,7 @@
 }
 
 int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                               buffer_size_t size)
+                               size_t size)
 {
     int i;
 
@@ -599,29 +384,32 @@
 
 int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
 {
-    int i;
+    int i, ret;
 
     dst->pts                  = src->pts;
     dst->dts                  = src->dts;
     dst->pos                  = src->pos;
     dst->duration             = src->duration;
-#if FF_API_CONVERGENCE_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->convergence_duration = src->convergence_duration;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     dst->flags                = src->flags;
     dst->stream_index         = src->stream_index;
-
+    dst->opaque               = src->opaque;
+    dst->time_base            = src->time_base;
+    dst->opaque_ref           = NULL;
     dst->side_data            = NULL;
     dst->side_data_elems      = 0;
+
+    ret = av_buffer_replace(&dst->opaque_ref, src->opaque_ref);
+    if (ret < 0)
+        return ret;
+
     for (i = 0; i < src->side_data_elems; i++) {
         enum AVPacketSideDataType type = src->side_data[i].type;
-        buffer_size_t size = src->side_data[i].size;
+        size_t size = src->side_data[i].size;
         uint8_t *src_data = src->side_data[i].data;
         uint8_t *dst_data = av_packet_new_side_data(dst, type, size);
 
         if (!dst_data) {
+            av_buffer_unref(&dst->opaque_ref);
             av_packet_free_side_data(dst);
             return AVERROR(ENOMEM);
         }
@@ -634,6 +422,7 @@
 void av_packet_unref(AVPacket *pkt)
 {
     av_packet_free_side_data(pkt);
+    av_buffer_unref(&pkt->opaque_ref);
     av_buffer_unref(&pkt->buf);
     get_packet_defaults(pkt);
 }
@@ -742,27 +531,21 @@
         pkt->dts = av_rescale_q(pkt->dts, src_tb, dst_tb);
     if (pkt->duration > 0)
         pkt->duration = av_rescale_q(pkt->duration, src_tb, dst_tb);
-#if FF_API_CONVERGENCE_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (pkt->convergence_duration > 0)
-        pkt->convergence_duration = av_rescale_q(pkt->convergence_duration, src_tb, dst_tb);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 }
 
-int avpriv_packet_list_put(PacketList **packet_buffer,
-                           PacketList **plast_pktl,
+int avpriv_packet_list_put(PacketList *packet_buffer,
                            AVPacket      *pkt,
                            int (*copy)(AVPacket *dst, const AVPacket *src),
                            int flags)
 {
-    PacketList *pktl = av_mallocz(sizeof(PacketList));
+    PacketListEntry *pktl = av_malloc(sizeof(*pktl));
     int ret;
 
     if (!pktl)
         return AVERROR(ENOMEM);
 
     if (copy) {
+        get_packet_defaults(&pktl->pkt);
         ret = copy(&pktl->pkt, pkt);
         if (ret < 0) {
             av_free(pktl);
@@ -777,50 +560,49 @@
         av_packet_move_ref(&pktl->pkt, pkt);
     }
 
-    if (*packet_buffer)
-        (*plast_pktl)->next = pktl;
+    pktl->next = NULL;
+
+    if (packet_buffer->head)
+        packet_buffer->tail->next = pktl;
     else
-        *packet_buffer = pktl;
+        packet_buffer->head = pktl;
 
     /* Add the packet in the buffered packet list. */
-    *plast_pktl = pktl;
+    packet_buffer->tail = pktl;
     return 0;
 }
 
-int avpriv_packet_list_get(PacketList **pkt_buffer,
-                           PacketList **pkt_buffer_end,
+int avpriv_packet_list_get(PacketList *pkt_buffer,
                            AVPacket      *pkt)
 {
-    PacketList *pktl;
-    if (!*pkt_buffer)
+    PacketListEntry *pktl = pkt_buffer->head;
+    if (!pktl)
         return AVERROR(EAGAIN);
-    pktl        = *pkt_buffer;
     *pkt        = pktl->pkt;
-    *pkt_buffer = pktl->next;
-    if (!pktl->next)
-        *pkt_buffer_end = NULL;
+    pkt_buffer->head = pktl->next;
+    if (!pkt_buffer->head)
+        pkt_buffer->tail = NULL;
     av_freep(&pktl);
     return 0;
 }
 
-void avpriv_packet_list_free(PacketList **pkt_buf, PacketList **pkt_buf_end)
+void avpriv_packet_list_free(PacketList *pkt_buf)
 {
-    PacketList *tmp = *pkt_buf;
+    PacketListEntry *tmp = pkt_buf->head;
 
     while (tmp) {
-        PacketList *pktl = tmp;
+        PacketListEntry *pktl = tmp;
         tmp = pktl->next;
         av_packet_unref(&pktl->pkt);
         av_freep(&pktl);
     }
-    *pkt_buf     = NULL;
-    *pkt_buf_end = NULL;
+    pkt_buf->head = pkt_buf->tail = NULL;
 }
 
 int ff_side_data_set_encoder_stats(AVPacket *pkt, int quality, int64_t *error, int error_count, int pict_type)
 {
     uint8_t *side_data;
-    buffer_size_t side_data_size;
+    size_t side_data_size;
     int i;
 
     side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_STATS, &side_data_size);
@@ -846,7 +628,7 @@
 {
     AVProducerReferenceTime *prft;
     uint8_t *side_data;
-    buffer_size_t side_data_size;
+    size_t side_data_size;
 
     side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_PRFT, &side_data_size);
     if (!side_data) {
diff -Naur a/media/ffvpx/libavcodec/bitstream.c b/media/ffvpx/libavcodec/bitstream.c
--- a/media/ffvpx/libavcodec/bitstream.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bitstream.c	2023-04-06 12:49:40.251394809 +0200
@@ -28,33 +28,13 @@
  * bitstream api.
  */
 
+#include <stdint.h>
+#include <string.h>
+
+#include "config.h"
 #include "libavutil/avassert.h"
-#include "libavutil/qsort.h"
-#include "avcodec.h"
-#include "internal.h"
-#include "mathops.h"
+#include "libavutil/intreadwrite.h"
 #include "put_bits.h"
-#include "vlc.h"
-
-const uint8_t ff_log2_run[41]={
- 0, 0, 0, 0, 1, 1, 1, 1,
- 2, 2, 2, 2, 3, 3, 3, 3,
- 4, 4, 5, 5, 6, 6, 7, 7,
- 8, 9,10,11,12,13,14,15,
-16,17,18,19,20,21,22,23,
-24,
-};
-
-#if FF_API_AVPRIV_PUT_BITS
-void avpriv_align_put_bits(PutBitContext *s)
-{
-    align_put_bits(s);
-}
-void avpriv_copy_bits(PutBitContext *pb, const uint8_t *src, int length)
-{
-    ff_copy_bits(pb, src, length);
-}
-#endif
 
 void ff_put_string(PutBitContext *pb, const char *string, int terminate_string)
 {
@@ -90,345 +70,3 @@
 
     put_bits(pb, bits, AV_RB16(src + 2 * words) >> (16 - bits));
 }
-
-/* VLC decoding */
-
-#define GET_DATA(v, table, i, wrap, size)                   \
-{                                                           \
-    const uint8_t *ptr = (const uint8_t *)table + i * wrap; \
-    switch(size) {                                          \
-    case 1:                                                 \
-        v = *(const uint8_t *)ptr;                          \
-        break;                                              \
-    case 2:                                                 \
-        v = *(const uint16_t *)ptr;                         \
-        break;                                              \
-    case 4:                                                 \
-    default:                                                \
-        av_assert1(size == 4);                              \
-        v = *(const uint32_t *)ptr;                         \
-        break;                                              \
-    }                                                       \
-}
-
-
-static int alloc_table(VLC *vlc, int size, int use_static)
-{
-    int index = vlc->table_size;
-
-    vlc->table_size += size;
-    if (vlc->table_size > vlc->table_allocated) {
-        if (use_static)
-            abort(); // cannot do anything, init_vlc() is used with too little memory
-        vlc->table_allocated += (1 << vlc->bits);
-        vlc->table = av_realloc_f(vlc->table, vlc->table_allocated, sizeof(VLC_TYPE) * 2);
-        if (!vlc->table) {
-            vlc->table_allocated = 0;
-            vlc->table_size = 0;
-            return AVERROR(ENOMEM);
-        }
-        memset(vlc->table + vlc->table_allocated - (1 << vlc->bits), 0, sizeof(VLC_TYPE) * 2 << vlc->bits);
-    }
-    return index;
-}
-
-#define LOCALBUF_ELEMS 1500 // the maximum currently needed is 1296 by rv34
-
-typedef struct VLCcode {
-    uint8_t bits;
-    VLC_TYPE symbol;
-    /** codeword, with the first bit-to-be-read in the msb
-     * (even if intended for a little-endian bitstream reader) */
-    uint32_t code;
-} VLCcode;
-
-static int vlc_common_init(VLC *vlc_arg, int nb_bits, int nb_codes,
-                           VLC **vlc, VLC *localvlc, VLCcode **buf,
-                           int flags)
-{
-    *vlc = vlc_arg;
-    (*vlc)->bits = nb_bits;
-    if (flags & INIT_VLC_USE_NEW_STATIC) {
-        av_assert0(nb_codes <= LOCALBUF_ELEMS);
-        *localvlc = *vlc_arg;
-        *vlc = localvlc;
-        (*vlc)->table_size = 0;
-    } else {
-        (*vlc)->table           = NULL;
-        (*vlc)->table_allocated = 0;
-        (*vlc)->table_size      = 0;
-    }
-    if (nb_codes > LOCALBUF_ELEMS) {
-        *buf = av_malloc_array(nb_codes, sizeof(VLCcode));
-        if (!*buf)
-            return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
-static int compare_vlcspec(const void *a, const void *b)
-{
-    const VLCcode *sa = a, *sb = b;
-    return (sa->code >> 1) - (sb->code >> 1);
-}
-/**
- * Build VLC decoding tables suitable for use with get_vlc().
- *
- * @param vlc            the context to be initialized
- *
- * @param table_nb_bits  max length of vlc codes to store directly in this table
- *                       (Longer codes are delegated to subtables.)
- *
- * @param nb_codes       number of elements in codes[]
- *
- * @param codes          descriptions of the vlc codes
- *                       These must be ordered such that codes going into the same subtable are contiguous.
- *                       Sorting by VLCcode.code is sufficient, though not necessary.
- */
-static int build_table(VLC *vlc, int table_nb_bits, int nb_codes,
-                       VLCcode *codes, int flags)
-{
-    int table_size, table_index, index, code_prefix, symbol, subtable_bits;
-    int i, j, k, n, nb, inc;
-    uint32_t code;
-    volatile VLC_TYPE (* volatile table)[2]; // the double volatile is needed to prevent an internal compiler error in gcc 4.2
-
-    if (table_nb_bits > 30)
-       return AVERROR(EINVAL);
-    table_size = 1 << table_nb_bits;
-    table_index = alloc_table(vlc, table_size, flags & INIT_VLC_USE_NEW_STATIC);
-    ff_dlog(NULL, "new table index=%d size=%d\n", table_index, table_size);
-    if (table_index < 0)
-        return table_index;
-    table = (volatile VLC_TYPE (*)[2])&vlc->table[table_index];
-
-    /* first pass: map codes and compute auxiliary table sizes */
-    for (i = 0; i < nb_codes; i++) {
-        n      = codes[i].bits;
-        code   = codes[i].code;
-        symbol = codes[i].symbol;
-        ff_dlog(NULL, "i=%d n=%d code=0x%"PRIx32"\n", i, n, code);
-        if (n <= table_nb_bits) {
-            /* no need to add another table */
-            j = code >> (32 - table_nb_bits);
-            nb = 1 << (table_nb_bits - n);
-            inc = 1;
-            if (flags & INIT_VLC_OUTPUT_LE) {
-                j = bitswap_32(code);
-                inc = 1 << n;
-            }
-            for (k = 0; k < nb; k++) {
-                int bits = table[j][1];
-                int oldsym  = table[j][0];
-                ff_dlog(NULL, "%4x: code=%d n=%d\n", j, i, n);
-                if ((bits || oldsym) && (bits != n || oldsym != symbol)) {
-                    av_log(NULL, AV_LOG_ERROR, "incorrect codes\n");
-                    return AVERROR_INVALIDDATA;
-                }
-                table[j][1] = n; //bits
-                table[j][0] = symbol;
-                j += inc;
-            }
-        } else {
-            /* fill auxiliary table recursively */
-            n -= table_nb_bits;
-            code_prefix = code >> (32 - table_nb_bits);
-            subtable_bits = n;
-            codes[i].bits = n;
-            codes[i].code = code << table_nb_bits;
-            for (k = i+1; k < nb_codes; k++) {
-                n = codes[k].bits - table_nb_bits;
-                if (n <= 0)
-                    break;
-                code = codes[k].code;
-                if (code >> (32 - table_nb_bits) != code_prefix)
-                    break;
-                codes[k].bits = n;
-                codes[k].code = code << table_nb_bits;
-                subtable_bits = FFMAX(subtable_bits, n);
-            }
-            subtable_bits = FFMIN(subtable_bits, table_nb_bits);
-            j = (flags & INIT_VLC_OUTPUT_LE) ? bitswap_32(code_prefix) >> (32 - table_nb_bits) : code_prefix;
-            table[j][1] = -subtable_bits;
-            ff_dlog(NULL, "%4x: n=%d (subtable)\n",
-                    j, codes[i].bits + table_nb_bits);
-            index = build_table(vlc, subtable_bits, k-i, codes+i, flags);
-            if (index < 0)
-                return index;
-            /* note: realloc has been done, so reload tables */
-            table = (volatile VLC_TYPE (*)[2])&vlc->table[table_index];
-            table[j][0] = index; //code
-            if (table[j][0] != index) {
-                avpriv_request_sample(NULL, "strange codes");
-                return AVERROR_PATCHWELCOME;
-            }
-            i = k-1;
-        }
-    }
-
-    for (i = 0; i < table_size; i++) {
-        if (table[i][1] == 0) //bits
-            table[i][0] = -1; //codes
-    }
-
-    return table_index;
-}
-
-static int vlc_common_end(VLC *vlc, int nb_bits, int nb_codes, VLCcode *codes,
-                          int flags, VLC *vlc_arg, VLCcode localbuf[LOCALBUF_ELEMS])
-{
-    int ret = build_table(vlc, nb_bits, nb_codes, codes, flags);
-
-    if (flags & INIT_VLC_USE_NEW_STATIC) {
-        if (vlc->table_size != vlc->table_allocated &&
-            !(flags & (INIT_VLC_STATIC_OVERLONG & ~INIT_VLC_USE_NEW_STATIC)))
-            av_log(NULL, AV_LOG_ERROR, "needed %d had %d\n", vlc->table_size, vlc->table_allocated);
-        av_assert0(ret >= 0);
-        *vlc_arg = *vlc;
-    } else {
-        if (codes != localbuf)
-            av_free(codes);
-        if (ret < 0) {
-            av_freep(&vlc->table);
-            return ret;
-        }
-    }
-    return 0;
-}
-
-/* Build VLC decoding tables suitable for use with get_vlc().
-
-   'nb_bits' sets the decoding table size (2^nb_bits) entries. The
-   bigger it is, the faster is the decoding. But it should not be too
-   big to save memory and L1 cache. '9' is a good compromise.
-
-   'nb_codes' : number of vlcs codes
-
-   'bits' : table which gives the size (in bits) of each vlc code.
-
-   'codes' : table which gives the bit pattern of of each vlc code.
-
-   'symbols' : table which gives the values to be returned from get_vlc().
-
-   'xxx_wrap' : give the number of bytes between each entry of the
-   'bits' or 'codes' tables.
-
-   'xxx_size' : gives the number of bytes of each entry of the 'bits'
-   or 'codes' tables. Currently 1,2 and 4 are supported.
-
-   'wrap' and 'size' make it possible to use any memory configuration and types
-   (byte/word/long) to store the 'bits', 'codes', and 'symbols' tables.
-*/
-int ff_init_vlc_sparse(VLC *vlc_arg, int nb_bits, int nb_codes,
-                       const void *bits, int bits_wrap, int bits_size,
-                       const void *codes, int codes_wrap, int codes_size,
-                       const void *symbols, int symbols_wrap, int symbols_size,
-                       int flags)
-{
-    VLCcode localbuf[LOCALBUF_ELEMS], *buf = localbuf;
-    int i, j, ret;
-    VLC localvlc, *vlc;
-
-    ret = vlc_common_init(vlc_arg, nb_bits, nb_codes, &vlc, &localvlc,
-                          &buf, flags);
-    if (ret < 0)
-        return ret;
-
-    av_assert0(symbols_size <= 2 || !symbols);
-    j = 0;
-#define COPY(condition)\
-    for (i = 0; i < nb_codes; i++) {                                        \
-        unsigned len;                                                       \
-        GET_DATA(len, bits, i, bits_wrap, bits_size);                       \
-        if (!(condition))                                                   \
-            continue;                                                       \
-        if (len > 3*nb_bits || len > 32) {                                  \
-            av_log(NULL, AV_LOG_ERROR, "Too long VLC (%u) in init_vlc\n", len);\
-            if (buf != localbuf)                                            \
-                av_free(buf);                                               \
-            return AVERROR(EINVAL);                                         \
-        }                                                                   \
-        buf[j].bits = len;                                                  \
-        GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);            \
-        if (buf[j].code >= (1LL<<buf[j].bits)) {                            \
-            av_log(NULL, AV_LOG_ERROR, "Invalid code %"PRIx32" for %d in "  \
-                   "init_vlc\n", buf[j].code, i);                           \
-            if (buf != localbuf)                                            \
-                av_free(buf);                                               \
-            return AVERROR(EINVAL);                                         \
-        }                                                                   \
-        if (flags & INIT_VLC_INPUT_LE)                                      \
-            buf[j].code = bitswap_32(buf[j].code);                          \
-        else                                                                \
-            buf[j].code <<= 32 - buf[j].bits;                               \
-        if (symbols)                                                        \
-            GET_DATA(buf[j].symbol, symbols, i, symbols_wrap, symbols_size) \
-        else                                                                \
-            buf[j].symbol = i;                                              \
-        j++;                                                                \
-    }
-    COPY(len > nb_bits);
-    // qsort is the slowest part of init_vlc, and could probably be improved or avoided
-    AV_QSORT(buf, j, struct VLCcode, compare_vlcspec);
-    COPY(len && len <= nb_bits);
-    nb_codes = j;
-
-    return vlc_common_end(vlc, nb_bits, nb_codes, buf,
-                          flags, vlc_arg, localbuf);
-}
-
-int ff_init_vlc_from_lengths(VLC *vlc_arg, int nb_bits, int nb_codes,
-                             const int8_t *lens, int lens_wrap,
-                             const void *symbols, int symbols_wrap, int symbols_size,
-                             int offset, int flags, void *logctx)
-{
-    VLCcode localbuf[LOCALBUF_ELEMS], *buf = localbuf;
-    VLC localvlc, *vlc;
-    uint64_t code;
-    int ret, j, len_max = FFMIN(32, 3 * nb_bits);
-
-    ret = vlc_common_init(vlc_arg, nb_bits, nb_codes, &vlc, &localvlc,
-                          &buf, flags);
-    if (ret < 0)
-        return ret;
-
-    j = code = 0;
-    for (int i = 0; i < nb_codes; i++, lens += lens_wrap) {
-        int len = *lens;
-        if (len > 0) {
-            unsigned sym;
-
-            buf[j].bits = len;
-            if (symbols)
-                GET_DATA(sym, symbols, i, symbols_wrap, symbols_size)
-            else
-                sym = i;
-            buf[j].symbol = sym + offset;
-            buf[j++].code = code;
-        } else if (len <  0) {
-            len = -len;
-        } else
-            continue;
-        if (len > len_max || code & ((1U << (32 - len)) - 1)) {
-            av_log(logctx, AV_LOG_ERROR, "Invalid VLC (length %u)\n", len);
-            goto fail;
-        }
-        code += 1U << (32 - len);
-        if (code > UINT32_MAX + 1ULL) {
-            av_log(logctx, AV_LOG_ERROR, "Overdetermined VLC tree\n");
-            goto fail;
-        }
-    }
-    return vlc_common_end(vlc, nb_bits, j, buf,
-                          flags, vlc_arg, localbuf);
-fail:
-    if (buf != localbuf)
-        av_free(buf);
-    return AVERROR_INVALIDDATA;
-}
-
-void ff_free_vlc(VLC *vlc)
-{
-    av_freep(&vlc->table);
-}
diff -Naur a/media/ffvpx/libavcodec/bitstream_filter.c b/media/ffvpx/libavcodec/bitstream_filter.c
--- a/media/ffvpx/libavcodec/bitstream_filter.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bitstream_filter.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,185 +0,0 @@
-/*
- * copyright (c) 2006 Michael Niedermayer <michaelni@gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <string.h>
-
-#include "avcodec.h"
-#include "libavutil/internal.h"
-#include "libavutil/mem.h"
-#include "libavutil/opt.h"
-
-#if FF_API_OLD_BSF
-FF_DISABLE_DEPRECATION_WARNINGS
-
-const AVBitStreamFilter *av_bitstream_filter_next(const AVBitStreamFilter *f)
-{
-    const AVBitStreamFilter *filter = NULL;
-    void *opaque = NULL;
-
-    while (filter != f)
-        filter = av_bsf_iterate(&opaque);
-
-    return av_bsf_iterate(&opaque);
-}
-
-void av_register_bitstream_filter(AVBitStreamFilter *bsf)
-{
-}
-
-typedef struct BSFCompatContext {
-    AVBSFContext *ctx;
-    int extradata_updated;
-} BSFCompatContext;
-
-AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)
-{
-    AVBitStreamFilterContext *ctx = NULL;
-    BSFCompatContext         *priv = NULL;
-    const AVBitStreamFilter *bsf;
-
-    bsf = av_bsf_get_by_name(name);
-    if (!bsf)
-        return NULL;
-
-    ctx = av_mallocz(sizeof(*ctx));
-    if (!ctx)
-        return NULL;
-
-    priv = av_mallocz(sizeof(*priv));
-    if (!priv)
-        goto fail;
-
-
-    ctx->filter    = bsf;
-    ctx->priv_data = priv;
-
-    return ctx;
-
-fail:
-    if (priv)
-        av_bsf_free(&priv->ctx);
-    av_freep(&priv);
-    av_freep(&ctx);
-    return NULL;
-}
-
-void av_bitstream_filter_close(AVBitStreamFilterContext *bsfc)
-{
-    BSFCompatContext *priv;
-
-    if (!bsfc)
-        return;
-
-    priv = bsfc->priv_data;
-
-    av_bsf_free(&priv->ctx);
-    av_freep(&bsfc->priv_data);
-    av_free(bsfc);
-}
-
-int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
-                               AVCodecContext *avctx, const char *args,
-                               uint8_t **poutbuf, int *poutbuf_size,
-                               const uint8_t *buf, int buf_size, int keyframe)
-{
-    BSFCompatContext *priv = bsfc->priv_data;
-    AVPacket pkt = { 0 };
-    int ret;
-
-    if (!priv->ctx) {
-        ret = av_bsf_alloc(bsfc->filter, &priv->ctx);
-        if (ret < 0)
-            return ret;
-
-        ret = avcodec_parameters_from_context(priv->ctx->par_in, avctx);
-        if (ret < 0)
-            return ret;
-
-        priv->ctx->time_base_in = avctx->time_base;
-
-        if (bsfc->args && bsfc->filter->priv_class) {
-            const AVOption *opt = av_opt_next(priv->ctx->priv_data, NULL);
-            const char * shorthand[2] = {NULL};
-
-            if (opt)
-                shorthand[0] = opt->name;
-
-            ret = av_opt_set_from_string(priv->ctx->priv_data, bsfc->args, shorthand, "=", ":");
-            if (ret < 0)
-                return ret;
-        }
-
-        ret = av_bsf_init(priv->ctx);
-        if (ret < 0)
-            return ret;
-    }
-
-    pkt.data = (uint8_t *)buf;
-    pkt.size = buf_size;
-
-    ret = av_bsf_send_packet(priv->ctx, &pkt);
-    if (ret < 0)
-        return ret;
-
-    *poutbuf      = NULL;
-    *poutbuf_size = 0;
-
-    ret = av_bsf_receive_packet(priv->ctx, &pkt);
-    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
-        return 0;
-    else if (ret < 0)
-        return ret;
-
-    *poutbuf = av_malloc(pkt.size + AV_INPUT_BUFFER_PADDING_SIZE);
-    if (!*poutbuf) {
-        av_packet_unref(&pkt);
-        return AVERROR(ENOMEM);
-    }
-
-    *poutbuf_size = pkt.size;
-    memcpy(*poutbuf, pkt.data, pkt.size);
-
-    av_packet_unref(&pkt);
-
-    /* drain all the remaining packets we cannot return */
-    while (ret >= 0) {
-        ret = av_bsf_receive_packet(priv->ctx, &pkt);
-        av_packet_unref(&pkt);
-    }
-
-    if (!priv->extradata_updated) {
-        /* update extradata in avctx from the output codec parameters */
-        if (priv->ctx->par_out->extradata_size && (!args || !strstr(args, "private_spspps_buf"))) {
-            av_freep(&avctx->extradata);
-            avctx->extradata_size = 0;
-            avctx->extradata = av_mallocz(priv->ctx->par_out->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
-            if (!avctx->extradata)
-                return AVERROR(ENOMEM);
-            memcpy(avctx->extradata, priv->ctx->par_out->extradata, priv->ctx->par_out->extradata_size);
-            avctx->extradata_size = priv->ctx->par_out->extradata_size;
-        }
-
-        priv->extradata_updated = 1;
-    }
-
-    return 1;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
diff -Naur a/media/ffvpx/libavcodec/bitstream_filters.c b/media/ffvpx/libavcodec/bitstream_filters.c
--- a/media/ffvpx/libavcodec/bitstream_filters.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bitstream_filters.c	2023-04-06 12:50:24.491176503 +0200
@@ -16,70 +16,69 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config.h"
+#include <stdint.h>
+#include <string.h>
 
-#include "libavutil/common.h"
 #include "libavutil/log.h"
 
-#include "avcodec.h"
+#include "bsf.h"
 #include "bsf_internal.h"
 
-extern const AVBitStreamFilter ff_aac_adtstoasc_bsf;
-extern const AVBitStreamFilter ff_av1_frame_merge_bsf;
-extern const AVBitStreamFilter ff_av1_frame_split_bsf;
-extern const AVBitStreamFilter ff_av1_metadata_bsf;
-extern const AVBitStreamFilter ff_chomp_bsf;
-extern const AVBitStreamFilter ff_dump_extradata_bsf;
-extern const AVBitStreamFilter ff_dca_core_bsf;
-extern const AVBitStreamFilter ff_eac3_core_bsf;
-extern const AVBitStreamFilter ff_extract_extradata_bsf;
-extern const AVBitStreamFilter ff_filter_units_bsf;
-extern const AVBitStreamFilter ff_h264_metadata_bsf;
-extern const AVBitStreamFilter ff_h264_mp4toannexb_bsf;
-extern const AVBitStreamFilter ff_h264_redundant_pps_bsf;
-extern const AVBitStreamFilter ff_hapqa_extract_bsf;
-extern const AVBitStreamFilter ff_hevc_metadata_bsf;
-extern const AVBitStreamFilter ff_hevc_mp4toannexb_bsf;
-extern const AVBitStreamFilter ff_imx_dump_header_bsf;
-extern const AVBitStreamFilter ff_mjpeg2jpeg_bsf;
-extern const AVBitStreamFilter ff_mjpega_dump_header_bsf;
-extern const AVBitStreamFilter ff_mp3_header_decompress_bsf;
-extern const AVBitStreamFilter ff_mpeg2_metadata_bsf;
-extern const AVBitStreamFilter ff_mpeg4_unpack_bframes_bsf;
-extern const AVBitStreamFilter ff_mov2textsub_bsf;
-extern const AVBitStreamFilter ff_noise_bsf;
-extern const AVBitStreamFilter ff_null_bsf;
-extern const AVBitStreamFilter ff_opus_metadata_bsf;
-extern const AVBitStreamFilter ff_pcm_rechunk_bsf;
-extern const AVBitStreamFilter ff_prores_metadata_bsf;
-extern const AVBitStreamFilter ff_remove_extradata_bsf;
-extern const AVBitStreamFilter ff_setts_bsf;
-extern const AVBitStreamFilter ff_text2movsub_bsf;
-extern const AVBitStreamFilter ff_trace_headers_bsf;
-extern const AVBitStreamFilter ff_truehd_core_bsf;
-extern const AVBitStreamFilter ff_vp9_metadata_bsf;
-extern const AVBitStreamFilter ff_vp9_raw_reorder_bsf;
-extern const AVBitStreamFilter ff_vp9_superframe_bsf;
-extern const AVBitStreamFilter ff_vp9_superframe_split_bsf;
+extern const FFBitStreamFilter ff_aac_adtstoasc_bsf;
+extern const FFBitStreamFilter ff_av1_frame_merge_bsf;
+extern const FFBitStreamFilter ff_av1_frame_split_bsf;
+extern const FFBitStreamFilter ff_av1_metadata_bsf;
+extern const FFBitStreamFilter ff_chomp_bsf;
+extern const FFBitStreamFilter ff_dump_extradata_bsf;
+extern const FFBitStreamFilter ff_dca_core_bsf;
+extern const FFBitStreamFilter ff_dts2pts_bsf;
+extern const FFBitStreamFilter ff_dv_error_marker_bsf;
+extern const FFBitStreamFilter ff_eac3_core_bsf;
+extern const FFBitStreamFilter ff_extract_extradata_bsf;
+extern const FFBitStreamFilter ff_filter_units_bsf;
+extern const FFBitStreamFilter ff_h264_metadata_bsf;
+extern const FFBitStreamFilter ff_h264_mp4toannexb_bsf;
+extern const FFBitStreamFilter ff_h264_redundant_pps_bsf;
+extern const FFBitStreamFilter ff_hapqa_extract_bsf;
+extern const FFBitStreamFilter ff_hevc_metadata_bsf;
+extern const FFBitStreamFilter ff_hevc_mp4toannexb_bsf;
+extern const FFBitStreamFilter ff_imx_dump_header_bsf;
+extern const FFBitStreamFilter ff_media100_to_mjpegb_bsf;
+extern const FFBitStreamFilter ff_mjpeg2jpeg_bsf;
+extern const FFBitStreamFilter ff_mjpega_dump_header_bsf;
+extern const FFBitStreamFilter ff_mp3_header_decompress_bsf;
+extern const FFBitStreamFilter ff_mpeg2_metadata_bsf;
+extern const FFBitStreamFilter ff_mpeg4_unpack_bframes_bsf;
+extern const FFBitStreamFilter ff_mov2textsub_bsf;
+extern const FFBitStreamFilter ff_noise_bsf;
+extern const FFBitStreamFilter ff_null_bsf;
+extern const FFBitStreamFilter ff_opus_metadata_bsf;
+extern const FFBitStreamFilter ff_pcm_rechunk_bsf;
+extern const FFBitStreamFilter ff_pgs_frame_merge_bsf;
+extern const FFBitStreamFilter ff_prores_metadata_bsf;
+extern const FFBitStreamFilter ff_remove_extradata_bsf;
+extern const FFBitStreamFilter ff_setts_bsf;
+extern const FFBitStreamFilter ff_text2movsub_bsf;
+extern const FFBitStreamFilter ff_trace_headers_bsf;
+extern const FFBitStreamFilter ff_truehd_core_bsf;
+extern const FFBitStreamFilter ff_vp9_metadata_bsf;
+extern const FFBitStreamFilter ff_vp9_raw_reorder_bsf;
+extern const FFBitStreamFilter ff_vp9_superframe_bsf;
+extern const FFBitStreamFilter ff_vp9_superframe_split_bsf;
 
 #include "libavcodec/bsf_list.c"
 
 const AVBitStreamFilter *av_bsf_iterate(void **opaque)
 {
     uintptr_t i = (uintptr_t)*opaque;
-    const AVBitStreamFilter *f = bitstream_filters[i];
+    const FFBitStreamFilter *f = bitstream_filters[i];
 
-    if (f)
+    if (f) {
         *opaque = (void*)(i + 1);
-
-    return f;
-}
-
-#if FF_API_NEXT
-const AVBitStreamFilter *av_bsf_next(void **opaque) {
-    return av_bsf_iterate(opaque);
+        return &f->p;
+    }
+    return NULL;
 }
-#endif
 
 const AVBitStreamFilter *av_bsf_get_by_name(const char *name)
 {
@@ -97,28 +96,6 @@
     return NULL;
 }
 
-#if FF_API_CHILD_CLASS_NEXT
-const AVClass *ff_bsf_child_class_next(const AVClass *prev)
-{
-    const AVBitStreamFilter *f = NULL;
-    void *i = 0;
-
-    /* find the filter that corresponds to prev */
-    while (prev && (f = av_bsf_iterate(&i))) {
-        if (f->priv_class == prev) {
-            break;
-        }
-    }
-
-    /* find next filter with priv options */
-    while ((f = av_bsf_iterate(&i))) {
-        if (f->priv_class)
-            return f->priv_class;
-    }
-    return NULL;
-}
-#endif
-
 const AVClass *ff_bsf_child_class_iterate(void **opaque)
 {
     const AVBitStreamFilter *f;
diff -Naur a/media/ffvpx/libavcodec/blockdsp.h b/media/ffvpx/libavcodec/blockdsp.h
--- a/media/ffvpx/libavcodec/blockdsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/blockdsp.h	2023-04-06 12:50:06.970471013 +0200
@@ -22,9 +22,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "avcodec.h"
-#include "version.h"
-
 /* add and put pixel (decoding)
  * Block sizes for op_pixels_func are 8x4,8x8 16x8 16x16.
  * h for op_pixels_func is limited to { width / 2, width },
@@ -39,12 +36,12 @@
     op_fill_func fill_block_tab[2];
 } BlockDSPContext;
 
-void ff_blockdsp_init(BlockDSPContext *c, AVCodecContext *avctx);
+void ff_blockdsp_init(BlockDSPContext *c);
 
 void ff_blockdsp_init_alpha(BlockDSPContext *c);
 void ff_blockdsp_init_arm(BlockDSPContext *c);
 void ff_blockdsp_init_ppc(BlockDSPContext *c);
-void ff_blockdsp_init_x86(BlockDSPContext *c, AVCodecContext *avctx);
+void ff_blockdsp_init_x86(BlockDSPContext *c);
 void ff_blockdsp_init_mips(BlockDSPContext *c);
 
 #endif /* AVCODEC_BLOCKDSP_H */
diff -Naur a/media/ffvpx/libavcodec/bsf.c b/media/ffvpx/libavcodec/bsf.c
--- a/media/ffvpx/libavcodec/bsf.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bsf.c	2023-04-06 12:49:40.251394809 +0200
@@ -18,6 +18,8 @@
 
 #include <string.h>
 
+#include "config_components.h"
+
 #include "libavutil/avassert.h"
 #include "libavutil/log.h"
 #include "libavutil/mem.h"
@@ -32,29 +34,40 @@
 
 #define IS_EMPTY(pkt) (!(pkt)->data && !(pkt)->side_data_elems)
 
-struct AVBSFInternal {
+static av_always_inline const FFBitStreamFilter *ff_bsf(const AVBitStreamFilter *bsf)
+{
+    return (const FFBitStreamFilter*)bsf;
+}
+
+typedef struct FFBSFContext {
+    AVBSFContext pub;
     AVPacket *buffer_pkt;
     int eof;
-};
+} FFBSFContext;
+
+static av_always_inline FFBSFContext *ffbsfcontext(AVBSFContext *ctx)
+{
+    return (FFBSFContext *)ctx;
+}
 
 void av_bsf_free(AVBSFContext **pctx)
 {
     AVBSFContext *ctx;
+    FFBSFContext *bsfi;
 
     if (!pctx || !*pctx)
         return;
-    ctx = *pctx;
+    ctx  = *pctx;
+    bsfi = ffbsfcontext(ctx);
 
-    if (ctx->internal) {
-        if (ctx->filter->close)
-            ctx->filter->close(ctx);
-        av_packet_free(&ctx->internal->buffer_pkt);
-        av_freep(&ctx->internal);
+    if (ctx->priv_data) {
+        if (ff_bsf(ctx->filter)->close)
+            ff_bsf(ctx->filter)->close(ctx);
+        if (ctx->filter->priv_class)
+            av_opt_free(ctx->priv_data);
+        av_freep(&ctx->priv_data);
     }
-    if (ctx->filter->priv_class && ctx->priv_data)
-        av_opt_free(ctx->priv_data);
-
-    av_freep(&ctx->priv_data);
+    av_packet_free(&bsfi->buffer_pkt);
 
     avcodec_parameters_free(&ctx->par_in);
     avcodec_parameters_free(&ctx->par_out);
@@ -80,9 +93,6 @@
     .item_name        = bsf_to_name,
     .version          = LIBAVUTIL_VERSION_INT,
     .child_next       = bsf_child_next,
-#if FF_API_CHILD_CLASS_NEXT
-    .child_class_next = ff_bsf_child_class_next,
-#endif
     .child_class_iterate = ff_bsf_child_class_iterate,
     .category         = AV_CLASS_CATEGORY_BITSTREAM_FILTER,
 };
@@ -95,12 +105,13 @@
 int av_bsf_alloc(const AVBitStreamFilter *filter, AVBSFContext **pctx)
 {
     AVBSFContext *ctx;
-    AVBSFInternal *bsfi;
+    FFBSFContext *bsfi;
     int ret;
 
-    ctx = av_mallocz(sizeof(*ctx));
-    if (!ctx)
+    bsfi = av_mallocz(sizeof(*bsfi));
+    if (!bsfi)
         return AVERROR(ENOMEM);
+    ctx  = &bsfi->pub;
 
     ctx->av_class = &bsf_class;
     ctx->filter   = filter;
@@ -112,8 +123,8 @@
         goto fail;
     }
     /* allocate priv data and init private options */
-    if (filter->priv_data_size) {
-        ctx->priv_data = av_mallocz(filter->priv_data_size);
+    if (ff_bsf(filter)->priv_data_size) {
+        ctx->priv_data = av_mallocz(ff_bsf(filter)->priv_data_size);
         if (!ctx->priv_data) {
             ret = AVERROR(ENOMEM);
             goto fail;
@@ -123,15 +134,6 @@
             av_opt_set_defaults(ctx->priv_data);
         }
     }
-    /* Allocate AVBSFInternal; must happen after priv_data has been allocated
-     * so that a filter->close needing priv_data is never called without. */
-    bsfi = av_mallocz(sizeof(*bsfi));
-    if (!bsfi) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-    ctx->internal = bsfi;
-
     bsfi->buffer_pkt = av_packet_alloc();
     if (!bsfi->buffer_pkt) {
         ret = AVERROR(ENOMEM);
@@ -160,9 +162,9 @@
                    "bitstream filter '%s'. Supported codecs are: ",
                    desc ? desc->name : "unknown", ctx->par_in->codec_id, ctx->filter->name);
             for (i = 0; ctx->filter->codec_ids[i] != AV_CODEC_ID_NONE; i++) {
-                desc = avcodec_descriptor_get(ctx->filter->codec_ids[i]);
+                enum AVCodecID codec_id = ctx->filter->codec_ids[i];
                 av_log(ctx, AV_LOG_ERROR, "%s (%d) ",
-                       desc ? desc->name : "unknown", ctx->filter->codec_ids[i]);
+                       avcodec_get_name(codec_id), codec_id);
             }
             av_log(ctx, AV_LOG_ERROR, "\n");
             return AVERROR(EINVAL);
@@ -177,8 +179,8 @@
 
     ctx->time_base_out = ctx->time_base_in;
 
-    if (ctx->filter->init) {
-        ret = ctx->filter->init(ctx);
+    if (ff_bsf(ctx->filter)->init) {
+        ret = ff_bsf(ctx->filter)->init(ctx);
         if (ret < 0)
             return ret;
     }
@@ -188,22 +190,24 @@
 
 void av_bsf_flush(AVBSFContext *ctx)
 {
-    AVBSFInternal *bsfi = ctx->internal;
+    FFBSFContext *const bsfi = ffbsfcontext(ctx);
 
     bsfi->eof = 0;
 
     av_packet_unref(bsfi->buffer_pkt);
 
-    if (ctx->filter->flush)
-        ctx->filter->flush(ctx);
+    if (ff_bsf(ctx->filter)->flush)
+        ff_bsf(ctx->filter)->flush(ctx);
 }
 
 int av_bsf_send_packet(AVBSFContext *ctx, AVPacket *pkt)
 {
-    AVBSFInternal *bsfi = ctx->internal;
+    FFBSFContext *const bsfi = ffbsfcontext(ctx);
     int ret;
 
     if (!pkt || IS_EMPTY(pkt)) {
+        if (pkt)
+            av_packet_unref(pkt);
         bsfi->eof = 1;
         return 0;
     }
@@ -226,12 +230,12 @@
 
 int av_bsf_receive_packet(AVBSFContext *ctx, AVPacket *pkt)
 {
-    return ctx->filter->filter(ctx, pkt);
+    return ff_bsf(ctx->filter)->filter(ctx, pkt);
 }
 
 int ff_bsf_get_packet(AVBSFContext *ctx, AVPacket **pkt)
 {
-    AVBSFInternal *bsfi = ctx->internal;
+    FFBSFContext *const bsfi = ffbsfcontext(ctx);
     AVPacket *tmp_pkt;
 
     if (bsfi->eof)
@@ -252,7 +256,7 @@
 
 int ff_bsf_get_packet_ref(AVBSFContext *ctx, AVPacket *pkt)
 {
-    AVBSFInternal *bsfi = ctx->internal;
+    FFBSFContext *const bsfi = ffbsfcontext(ctx);
 
     if (bsfi->eof)
         return AVERROR_EOF;
@@ -399,10 +403,10 @@
         .version    = LIBAVUTIL_VERSION_INT,
 };
 
-const AVBitStreamFilter ff_list_bsf = {
-        .name           = "bsf_list",
+static const FFBitStreamFilter list_bsf = {
+        .p.name         = "bsf_list",
+        .p.priv_class   = &bsf_list_class,
         .priv_data_size = sizeof(BSFListContext),
-        .priv_class     = &bsf_list_class,
         .init           = bsf_list_init,
         .filter         = bsf_list_filter,
         .flush          = bsf_list_flush,
@@ -495,7 +499,7 @@
         goto end;
     }
 
-    ret = av_bsf_alloc(&ff_list_bsf, bsf);
+    ret = av_bsf_alloc(&list_bsf.p, bsf);
     if (ret < 0)
         return ret;
 
@@ -523,7 +527,6 @@
 int av_bsf_list_parse_str(const char *str, AVBSFContext **bsf_lst)
 {
     AVBSFList *lst;
-    char *bsf_str, *buf, *dup, *saveptr;
     int ret;
 
     if (!str)
@@ -533,28 +536,27 @@
     if (!lst)
         return AVERROR(ENOMEM);
 
-    if (!(dup = buf = av_strdup(str))) {
-        ret = AVERROR(ENOMEM);
-        goto end;
-    }
-
-    while (bsf_str = av_strtok(buf, ",", &saveptr)) {
+    do {
+        char *bsf_str = av_get_token(&str, ",");
         ret = bsf_parse_single(bsf_str, lst);
+        av_free(bsf_str);
         if (ret < 0)
             goto end;
-
-        buf = NULL;
-    }
+    } while (*str && *++str);
 
     ret = av_bsf_list_finalize(&lst, bsf_lst);
 end:
     if (ret < 0)
         av_bsf_list_free(&lst);
-    av_free(dup);
     return ret;
 }
 
 int av_bsf_get_null_filter(AVBSFContext **bsf)
 {
-    return av_bsf_alloc(&ff_list_bsf, bsf);
+#if CONFIG_NULL_BSF
+    extern const FFBitStreamFilter ff_null_bsf;
+    return av_bsf_alloc(&ff_null_bsf.p, bsf);
+#else
+    return av_bsf_alloc(&list_bsf.p, bsf);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/bsf.h b/media/ffvpx/libavcodec/bsf.h
--- a/media/ffvpx/libavcodec/bsf.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bsf.h	2023-04-06 12:50:06.970471013 +0200
@@ -30,12 +30,31 @@
 #include "packet.h"
 
 /**
- * @addtogroup lavc_core
+ * @defgroup lavc_bsf Bitstream filters
+ * @ingroup libavc
+ *
+ * Bitstream filters transform encoded media data without decoding it. This
+ * allows e.g. manipulating various header values. Bitstream filters operate on
+ * @ref AVPacket "AVPackets".
+ *
+ * The bitstream filtering API is centered around two structures:
+ * AVBitStreamFilter and AVBSFContext. The former represents a bitstream filter
+ * in abstract, the latter a specific filtering process. Obtain an
+ * AVBitStreamFilter using av_bsf_get_by_name() or av_bsf_iterate(), then pass
+ * it to av_bsf_alloc() to create an AVBSFContext. Fill in the user-settable
+ * AVBSFContext fields, as described in its documentation, then call
+ * av_bsf_init() to prepare the filter context for use.
+ *
+ * Submit packets for filtering using av_bsf_send_packet(), obtain filtered
+ * results with av_bsf_receive_packet(). When no more input packets will be
+ * sent, submit a NULL AVPacket to signal the end of the stream to the filter.
+ * av_bsf_receive_packet() will then return trailing packets, if any are
+ * produced by the filter.
+ *
+ * Finally, free the filter context with av_bsf_free().
  * @{
  */
 
-typedef struct AVBSFInternal AVBSFInternal;
-
 /**
  * The bitstream filter state.
  *
@@ -58,12 +77,6 @@
     const struct AVBitStreamFilter *filter;
 
     /**
-     * Opaque libavcodec internal data. Must not be touched by the caller in any
-     * way.
-     */
-    AVBSFInternal *internal;
-
-    /**
      * Opaque filter-specific private data. If filter->priv_class is non-NULL,
      * this is an AVOptions-enabled struct.
      */
@@ -115,20 +128,6 @@
      * code to this class.
      */
     const AVClass *priv_class;
-
-    /*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-
-    int priv_data_size;
-    int (*init)(AVBSFContext *ctx);
-    int (*filter)(AVBSFContext *ctx, AVPacket *pkt);
-    void (*close)(AVBSFContext *ctx);
-    void (*flush)(AVBSFContext *ctx);
 } AVBitStreamFilter;
 
 /**
@@ -154,9 +153,9 @@
  * av_bsf_init() before sending any data to the filter.
  *
  * @param filter the filter for which to allocate an instance.
- * @param ctx a pointer into which the pointer to the newly-allocated context
- *            will be written. It must be freed with av_bsf_free() after the
- *            filtering is done.
+ * @param[out] ctx a pointer into which the pointer to the newly-allocated context
+ *                 will be written. It must be freed with av_bsf_free() after the
+ *                 filtering is done.
  *
  * @return 0 on success, a negative AVERROR code on failure
  */
@@ -165,6 +164,8 @@
 /**
  * Prepare the filter for use, after all the parameters and options have been
  * set.
+ *
+ * @param ctx a AVBSFContext previously allocated with av_bsf_alloc()
  */
 int av_bsf_init(AVBSFContext *ctx);
 
@@ -175,6 +176,7 @@
  * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
  * AVERROR_EOF.
  *
+ * @param ctx an initialized AVBSFContext
  * @param pkt the packet to filter. The bitstream filter will take ownership of
  * the packet and reset the contents of pkt. pkt is not touched if an error occurs.
  * If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),
@@ -182,15 +184,18 @@
  * sending more empty packets does nothing) and will cause the filter to output
  * any packets it may have buffered internally.
  *
- * @return 0 on success. AVERROR(EAGAIN) if packets need to be retrieved from the
- * filter (using av_bsf_receive_packet()) before new input can be consumed. Another
- * negative AVERROR value if an error occurs.
+ * @return
+ *  - 0 on success.
+ *  - AVERROR(EAGAIN) if packets need to be retrieved from the filter (using
+ *    av_bsf_receive_packet()) before new input can be consumed.
+ *  - Another negative AVERROR value if an error occurs.
  */
 int av_bsf_send_packet(AVBSFContext *ctx, AVPacket *pkt);
 
 /**
  * Retrieve a filtered packet.
  *
+ * @param ctx an initialized AVBSFContext
  * @param[out] pkt this struct will be filled with the contents of the filtered
  *                 packet. It is owned by the caller and must be freed using
  *                 av_packet_unref() when it is no longer needed.
@@ -201,10 +206,12 @@
  *                 overwritten by the returned data. On failure, pkt is not
  *                 touched.
  *
- * @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
- * filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
- * will be no further output from the filter. Another negative AVERROR value if
- * an error occurs.
+ * @return
+ *  - 0 on success.
+ *  - AVERROR(EAGAIN) if more packets need to be sent to the filter (using
+ *    av_bsf_send_packet()) to get more output.
+ *  - AVERROR_EOF if there will be no further output from the filter.
+ *  - Another negative AVERROR value if an error occurs.
  *
  * @note one input packet may result in several output packets, so after sending
  * a packet with av_bsf_send_packet(), this function needs to be called
diff -Naur a/media/ffvpx/libavcodec/bsf_internal.h b/media/ffvpx/libavcodec/bsf_internal.h
--- a/media/ffvpx/libavcodec/bsf_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bsf_internal.h	2023-04-06 12:49:40.251394809 +0200
@@ -24,6 +24,19 @@
 #include "bsf.h"
 #include "packet.h"
 
+typedef struct FFBitStreamFilter {
+    /**
+     * The public AVBitStreamFilter. See bsf.h for it.
+     */
+    AVBitStreamFilter p;
+
+    int priv_data_size;
+    int (*init)(AVBSFContext *ctx);
+    int (*filter)(AVBSFContext *ctx, AVPacket *pkt);
+    void (*close)(AVBSFContext *ctx);
+    void (*flush)(AVBSFContext *ctx);
+} FFBitStreamFilter;
+
 /**
  * Called by the bitstream filters to get the next packet for filtering.
  * The filter is responsible for either freeing the packet or passing it to the
@@ -42,10 +55,6 @@
  */
 int ff_bsf_get_packet_ref(AVBSFContext *ctx, AVPacket *pkt);
 
-#if FF_API_CHILD_CLASS_NEXT
-const AVClass *ff_bsf_child_class_next(const AVClass *prev);
-#endif
-
 const AVClass *ff_bsf_child_class_iterate(void **opaque);
 
 #endif /* AVCODEC_BSF_INTERNAL_H */
diff -Naur a/media/ffvpx/libavcodec/bsf_list.c b/media/ffvpx/libavcodec/bsf_list.c
--- a/media/ffvpx/libavcodec/bsf_list.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/bsf_list.c	2023-04-06 12:49:45.615610885 +0200
@@ -1,4 +1,6 @@
-static const AVBitStreamFilter * const bitstream_filters[] = {
+#include "config_components.h"
+
+static const FFBitStreamFilter * const bitstream_filters[] = {
     &ff_null_bsf,
 #if CONFIG_VP9_SUPERFRAME_SPLIT_BSF
     &ff_vp9_superframe_split_bsf,
diff -Naur a/media/ffvpx/libavcodec/cbs_av1.c b/media/ffvpx/libavcodec/cbs_av1.c
--- a/media/ffvpx/libavcodec/cbs_av1.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/cbs_av1.c	2023-04-06 12:50:06.971471053 +0200
@@ -20,10 +20,10 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixfmt.h"
 
+#include "avcodec.h"
 #include "cbs.h"
 #include "cbs_internal.h"
 #include "cbs_av1.h"
-#include "internal.h"
 
 
 static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,
@@ -828,7 +828,7 @@
             goto fail;
         }
 
-        err = ff_cbs_insert_unit_data(frag, -1, header.obu_type,
+        err = ff_cbs_append_unit_data(frag, header.obu_type,
                                       data, obu_length, frag->data_ref);
         if (err < 0)
             goto fail;
@@ -878,7 +878,7 @@
     GetBitContext gbc;
     int err, start_pos, end_pos;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
     obu = unit->content;
@@ -1058,15 +1058,31 @@
     AV1RawTileData *td;
     size_t header_size;
     int err, start_pos, end_pos, data_pos;
+    CodedBitstreamAV1Context av1ctx;
 
     // OBUs in the normal bitstream format must contain a size field
     // in every OBU (in annex B it is optional, but we don't support
     // writing that).
     obu->header.obu_has_size_field = 1;
+    av1ctx = *priv;
+
+    if (priv->sequence_header_ref) {
+        av1ctx.sequence_header_ref = av_buffer_ref(priv->sequence_header_ref);
+        if (!av1ctx.sequence_header_ref)
+            return AVERROR(ENOMEM);
+    }
+
+    if (priv->frame_header_ref) {
+        av1ctx.frame_header_ref = av_buffer_ref(priv->frame_header_ref);
+        if (!av1ctx.frame_header_ref) {
+            err = AVERROR(ENOMEM);
+            goto error;
+        }
+    }
 
     err = cbs_av1_write_obu_header(ctx, pbc, &obu->header);
     if (err < 0)
-        return err;
+        goto error;
 
     if (obu->header.obu_has_size_field) {
         pbc_tmp = *pbc;
@@ -1084,18 +1100,21 @@
             err = cbs_av1_write_sequence_header_obu(ctx, pbc,
                                                     &obu->obu.sequence_header);
             if (err < 0)
-                return err;
+                goto error;
 
             av_buffer_unref(&priv->sequence_header_ref);
             priv->sequence_header = NULL;
 
             err = ff_cbs_make_unit_refcounted(ctx, unit);
             if (err < 0)
-                return err;
+                goto error;
 
             priv->sequence_header_ref = av_buffer_ref(unit->content_ref);
-            if (!priv->sequence_header_ref)
-                return AVERROR(ENOMEM);
+            if (!priv->sequence_header_ref) {
+                err = AVERROR(ENOMEM);
+                goto error;
+            }
+
             priv->sequence_header = &obu->obu.sequence_header;
         }
         break;
@@ -1103,7 +1122,7 @@
         {
             err = cbs_av1_write_temporal_delimiter_obu(ctx, pbc);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     case AV1_OBU_FRAME_HEADER:
@@ -1115,7 +1134,7 @@
                                                  AV1_OBU_REDUNDANT_FRAME_HEADER,
                                                  NULL);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     case AV1_OBU_TILE_GROUP:
@@ -1123,7 +1142,7 @@
             err = cbs_av1_write_tile_group_obu(ctx, pbc,
                                                &obu->obu.tile_group);
             if (err < 0)
-                return err;
+                goto error;
 
             td = &obu->obu.tile_group.tile_data;
         }
@@ -1132,7 +1151,7 @@
         {
             err = cbs_av1_write_frame_obu(ctx, pbc, &obu->obu.frame, NULL);
             if (err < 0)
-                return err;
+                goto error;
 
             td = &obu->obu.frame.tile_group.tile_data;
         }
@@ -1141,7 +1160,7 @@
         {
             err = cbs_av1_write_tile_list_obu(ctx, pbc, &obu->obu.tile_list);
             if (err < 0)
-                return err;
+                goto error;
 
             td = &obu->obu.tile_list.tile_data;
         }
@@ -1150,18 +1169,19 @@
         {
             err = cbs_av1_write_metadata_obu(ctx, pbc, &obu->obu.metadata);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     case AV1_OBU_PADDING:
         {
             err = cbs_av1_write_padding_obu(ctx, pbc, &obu->obu.padding);
             if (err < 0)
-                return err;
+                goto error;
         }
         break;
     default:
-        return AVERROR(ENOSYS);
+        err = AVERROR(ENOSYS);
+        goto error;
     }
 
     end_pos = put_bits_count(pbc);
@@ -1172,7 +1192,7 @@
         // Add trailing bits and recalculate.
         err = cbs_av1_write_trailing_bits(ctx, pbc, 8 - end_pos % 8);
         if (err < 0)
-            return err;
+            goto error;
         end_pos = put_bits_count(pbc);
         obu->obu_size = header_size = (end_pos - start_pos + 7) / 8;
     } else {
@@ -1190,14 +1210,19 @@
     *pbc = pbc_tmp;
     err = cbs_av1_write_leb128(ctx, pbc, "obu_size", obu->obu_size);
     if (err < 0)
-        return err;
+        goto error;
 
     data_pos = put_bits_count(pbc) / 8;
     flush_put_bits(pbc);
     av_assert0(data_pos <= start_pos);
 
-    if (8 * obu->obu_size > put_bits_left(pbc))
+    if (8 * obu->obu_size > put_bits_left(pbc)) {
+        av_buffer_unref(&priv->sequence_header_ref);
+        av_buffer_unref(&priv->frame_header_ref);
+        *priv = av1ctx;
+
         return AVERROR(ENOSPC);
+    }
 
     if (obu->obu_size > 0) {
         memmove(pbc->buf + data_pos,
@@ -1213,8 +1238,13 @@
 
     // OBU data must be byte-aligned.
     av_assert0(put_bits_count(pbc) % 8 == 0);
+    err = 0;
 
-    return 0;
+error:
+    av_buffer_unref(&av1ctx.sequence_header_ref);
+    av_buffer_unref(&av1ctx.frame_header_ref);
+
+    return err;
 }
 
 static int cbs_av1_assemble_fragment(CodedBitstreamContext *ctx,
diff -Naur a/media/ffvpx/libavcodec/cbs_av1_syntax_template.c b/media/ffvpx/libavcodec/cbs_av1_syntax_template.c
--- a/media/ffvpx/libavcodec/cbs_av1_syntax_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/cbs_av1_syntax_template.c	2023-04-06 12:50:24.491176503 +0200
@@ -355,7 +355,7 @@
         AV1_REF_FRAME_ALTREF2, AV1_REF_FRAME_ALTREF
     };
     int8_t ref_frame_idx[AV1_REFS_PER_FRAME], used_frame[AV1_NUM_REF_FRAMES];
-    int8_t shifted_order_hints[AV1_NUM_REF_FRAMES];
+    int16_t shifted_order_hints[AV1_NUM_REF_FRAMES];
     int cur_frame_hint, latest_order_hint, earliest_order_hint, ref;
     int i, j;
 
@@ -1862,11 +1862,8 @@
     fb(16, white_point_chromaticity_x);
     fb(16, white_point_chromaticity_y);
 
-    fc(32, luminance_max, 1, MAX_UINT_BITS(32));
-    // luminance_min must be lower than luminance_max. Convert luminance_max from
-    // 24.8 fixed point to 18.14 fixed point in order to compare them.
-    fc(32, luminance_min, 0, FFMIN(((uint64_t)current->luminance_max << 6) - 1,
-                                   MAX_UINT_BITS(32)));
+    fb(32, luminance_max);
+    fb(32, luminance_min);
 
     return 0;
 }
diff -Naur a/media/ffvpx/libavcodec/cbs.c b/media/ffvpx/libavcodec/cbs.c
--- a/media/ffvpx/libavcodec/cbs.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/cbs.c	2023-04-06 12:50:06.971471053 +0200
@@ -25,6 +25,7 @@
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
 
+#include "avcodec.h"
 #include "cbs.h"
 #include "cbs_internal.h"
 
@@ -72,8 +73,8 @@
     AV_CODEC_ID_NONE
 };
 
-int ff_cbs_init(CodedBitstreamContext **ctx_ptr,
-                enum AVCodecID codec_id, void *log_ctx)
+av_cold int ff_cbs_init(CodedBitstreamContext **ctx_ptr,
+                        enum AVCodecID codec_id, void *log_ctx)
 {
     CodedBitstreamContext *ctx;
     const CodedBitstreamType *type;
@@ -117,13 +118,13 @@
     return 0;
 }
 
-void ff_cbs_flush(CodedBitstreamContext *ctx)
+av_cold void ff_cbs_flush(CodedBitstreamContext *ctx)
 {
     if (ctx->codec->flush)
         ctx->codec->flush(ctx);
 }
 
-void ff_cbs_close(CodedBitstreamContext **ctx_ptr)
+av_cold void ff_cbs_close(CodedBitstreamContext **ctx_ptr)
 {
     CodedBitstreamContext *ctx = *ctx_ptr;
 
@@ -167,7 +168,7 @@
     frag->data_bit_padding = 0;
 }
 
-void ff_cbs_fragment_free(CodedBitstreamFragment *frag)
+av_cold void ff_cbs_fragment_free(CodedBitstreamFragment *frag)
 {
     ff_cbs_fragment_reset(frag);
 
@@ -293,6 +294,19 @@
                          pkt->data, pkt->size, 0);
 }
 
+int ff_cbs_read_packet_side_data(CodedBitstreamContext *ctx,
+                                 CodedBitstreamFragment *frag,
+                                 const AVPacket *pkt)
+{
+    size_t side_data_size;
+    const uint8_t *side_data =
+        av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,
+                                &side_data_size);
+
+    return cbs_read_data(ctx, frag, NULL,
+                         side_data, side_data_size, 1);
+}
+
 int ff_cbs_read(CodedBitstreamContext *ctx,
                 CodedBitstreamFragment *frag,
                 const uint8_t *data, size_t size)
@@ -301,6 +315,28 @@
                          data, size, 0);
 }
 
+/**
+ * Allocate a new internal data buffer of the given size in the unit.
+ *
+ * The data buffer will have input padding.
+ */
+static int cbs_alloc_unit_data(CodedBitstreamUnit *unit,
+                               size_t size)
+{
+    av_assert0(!unit->data && !unit->data_ref);
+
+    unit->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (!unit->data_ref)
+        return AVERROR(ENOMEM);
+
+    unit->data      = unit->data_ref->data;
+    unit->data_size = size;
+
+    memset(unit->data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+
+    return 0;
+}
+
 static int cbs_write_unit_data(CodedBitstreamContext *ctx,
                                CodedBitstreamUnit *unit)
 {
@@ -346,7 +382,7 @@
 
     flush_put_bits(&pbc);
 
-    ret = ff_cbs_alloc_unit_data(unit, put_bits_count(&pbc) / 8);
+    ret = cbs_alloc_unit_data(unit, put_bytes_output(&pbc));
     if (ret < 0)
         return ret;
 
@@ -402,6 +438,10 @@
         return err;
 
     av_freep(&par->extradata);
+    par->extradata_size = 0;
+
+    if (!frag->data_size)
+        return 0;
 
     par->extradata = av_malloc(frag->data_size +
                                AV_INPUT_BUFFER_PADDING_SIZE);
@@ -659,43 +699,6 @@
 }
 
 
-int ff_cbs_alloc_unit_content(CodedBitstreamUnit *unit,
-                              size_t size,
-                              void (*free)(void *opaque, uint8_t *data))
-{
-    av_assert0(!unit->content && !unit->content_ref);
-
-    unit->content = av_mallocz(size);
-    if (!unit->content)
-        return AVERROR(ENOMEM);
-
-    unit->content_ref = av_buffer_create(unit->content, size,
-                                         free, NULL, 0);
-    if (!unit->content_ref) {
-        av_freep(&unit->content);
-        return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
-int ff_cbs_alloc_unit_data(CodedBitstreamUnit *unit,
-                           size_t size)
-{
-    av_assert0(!unit->data && !unit->data_ref);
-
-    unit->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);
-    if (!unit->data_ref)
-        return AVERROR(ENOMEM);
-
-    unit->data      = unit->data_ref->data;
-    unit->data_size = size;
-
-    memset(unit->data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
-
-    return 0;
-}
-
 static int cbs_insert_unit(CodedBitstreamFragment *frag,
                            int position)
 {
@@ -770,18 +773,16 @@
     return 0;
 }
 
-int ff_cbs_insert_unit_data(CodedBitstreamFragment *frag,
-                            int position,
-                            CodedBitstreamUnitType type,
-                            uint8_t *data, size_t data_size,
-                            AVBufferRef *data_buf)
+static int cbs_insert_unit_data(CodedBitstreamFragment *frag,
+                                CodedBitstreamUnitType type,
+                                uint8_t *data, size_t data_size,
+                                AVBufferRef *data_buf,
+                                int position)
 {
     CodedBitstreamUnit *unit;
     AVBufferRef *data_ref;
     int err;
 
-    if (position == -1)
-        position = frag->nb_units;
     av_assert0(position >= 0 && position <= frag->nb_units);
 
     if (data_buf)
@@ -809,6 +810,16 @@
     return 0;
 }
 
+int ff_cbs_append_unit_data(CodedBitstreamFragment *frag,
+                            CodedBitstreamUnitType type,
+                            uint8_t *data, size_t data_size,
+                            AVBufferRef *data_buf)
+{
+    return cbs_insert_unit_data(frag, type,
+                                data, data_size, data_buf,
+                                frag->nb_units);
+}
+
 void ff_cbs_delete_unit(CodedBitstreamFragment *frag,
                         int position)
 {
@@ -828,12 +839,10 @@
 static void cbs_default_free_unit_content(void *opaque, uint8_t *data)
 {
     const CodedBitstreamUnitTypeDescriptor *desc = opaque;
-    if (desc->content_type == CBS_CONTENT_TYPE_INTERNAL_REFS) {
-        int i;
-        for (i = 0; i < desc->nb_ref_offsets; i++) {
-            void **ptr = (void**)(data + desc->ref_offsets[i]);
-            av_buffer_unref((AVBufferRef**)(ptr + 1));
-        }
+
+    for (int i = 0; i < desc->type.ref.nb_offsets; i++) {
+        void **ptr = (void**)(data + desc->type.ref.offsets[i]);
+        av_buffer_unref((AVBufferRef**)(ptr + 1));
     }
     av_free(data);
 }
@@ -853,12 +862,12 @@
         if (desc->nb_unit_types == 0)
             break;
         if (desc->nb_unit_types == CBS_UNIT_TYPE_RANGE) {
-            if (unit->type >= desc->unit_type_range_start &&
-                unit->type <= desc->unit_type_range_end)
+            if (unit->type >= desc->unit_type.range.start &&
+                unit->type <= desc->unit_type.range.end)
                 return desc;
         } else {
             for (j = 0; j < desc->nb_unit_types; j++) {
-                if (desc->unit_types[j] == unit->type)
+                if (desc->unit_type.list[j] == unit->type)
                     return desc;
             }
         }
@@ -866,8 +875,8 @@
     return NULL;
 }
 
-int ff_cbs_alloc_unit_content2(CodedBitstreamContext *ctx,
-                               CodedBitstreamUnit *unit)
+int ff_cbs_alloc_unit_content(CodedBitstreamContext *ctx,
+                              CodedBitstreamUnit *unit)
 {
     const CodedBitstreamUnitTypeDescriptor *desc;
 
@@ -883,7 +892,8 @@
 
     unit->content_ref =
         av_buffer_create(unit->content, desc->content_size,
-                         desc->content_free ? desc->content_free
+                         desc->content_type == CBS_CONTENT_TYPE_COMPLEX
+                                            ? desc->type.complex.content_free
                                             : cbs_default_free_unit_content,
                          (void*)desc, 0);
     if (!unit->content_ref) {
@@ -894,13 +904,12 @@
     return 0;
 }
 
-static int cbs_clone_unit_content(AVBufferRef **clone_ref,
-                                  CodedBitstreamUnit *unit,
-                                  const CodedBitstreamUnitTypeDescriptor *desc)
-{
-    uint8_t *src, *copy;
-    uint8_t **src_ptr, **copy_ptr;
-    AVBufferRef **src_buf, **copy_buf;
+static int cbs_clone_internal_refs_unit_content(AVBufferRef **clone_ref,
+                                                const CodedBitstreamUnit *unit,
+                                                const CodedBitstreamUnitTypeDescriptor *desc)
+{
+    const uint8_t *src;
+    uint8_t *copy;
     int err, i;
 
     av_assert0(unit->content);
@@ -910,17 +919,17 @@
     if (!copy)
         return AVERROR(ENOMEM);
 
-    for (i = 0; i < desc->nb_ref_offsets; i++) {
-        src_ptr  = (uint8_t**)(src + desc->ref_offsets[i]);
-        src_buf  = (AVBufferRef**)(src_ptr + 1);
-        copy_ptr = (uint8_t**)(copy + desc->ref_offsets[i]);
-        copy_buf = (AVBufferRef**)(copy_ptr + 1);
+    for (i = 0; i < desc->type.ref.nb_offsets; i++) {
+        const uint8_t *const *src_ptr = (const uint8_t* const*)(src + desc->type.ref.offsets[i]);
+        const AVBufferRef *src_buf = *(AVBufferRef**)(src_ptr + 1);
+        uint8_t **copy_ptr = (uint8_t**)(copy + desc->type.ref.offsets[i]);
+        AVBufferRef **copy_buf = (AVBufferRef**)(copy_ptr + 1);
 
         if (!*src_ptr) {
-            av_assert0(!*src_buf);
+            av_assert0(!src_buf);
             continue;
         }
-        if (!*src_buf) {
+        if (!src_buf) {
             // We can't handle a non-refcounted pointer here - we don't
             // have enough information to handle whatever structure lies
             // at the other end of it.
@@ -928,21 +937,14 @@
             goto fail;
         }
 
-        // src_ptr is required to point somewhere inside src_buf.  If it
-        // doesn't, there is a bug somewhere.
-        av_assert0(*src_ptr >= (*src_buf)->data &&
-                   *src_ptr <  (*src_buf)->data + (*src_buf)->size);
-
-        *copy_buf = av_buffer_ref(*src_buf);
+        *copy_buf = av_buffer_ref(src_buf);
         if (!*copy_buf) {
             err = AVERROR(ENOMEM);
             goto fail;
         }
-        *copy_ptr = (*copy_buf)->data + (*src_ptr - (*src_buf)->data);
     }
 
     *clone_ref = av_buffer_create(copy, desc->content_size,
-                                  desc->content_free ? desc->content_free :
                                   cbs_default_free_unit_content,
                                   (void*)desc, 0);
     if (!*clone_ref) {
@@ -954,46 +956,37 @@
 
 fail:
     for (--i; i >= 0; i--)
-        av_buffer_unref((AVBufferRef**)(copy + desc->ref_offsets[i]));
+        av_buffer_unref((AVBufferRef**)(copy + desc->type.ref.offsets[i]));
     av_freep(&copy);
     *clone_ref = NULL;
     return err;
 }
 
-int ff_cbs_make_unit_refcounted(CodedBitstreamContext *ctx,
-                                CodedBitstreamUnit *unit)
+/*
+ * On success, unit->content and unit->content_ref are updated with
+ * the new content; unit is untouched on failure.
+ * Any old content_ref is simply overwritten and not freed.
+ */
+static int cbs_clone_unit_content(CodedBitstreamContext *ctx,
+                                  CodedBitstreamUnit *unit)
 {
     const CodedBitstreamUnitTypeDescriptor *desc;
     AVBufferRef *ref;
     int err;
 
-    av_assert0(unit->content);
-    if (unit->content_ref) {
-        // Already refcounted, nothing to do.
-        return 0;
-    }
-
     desc = cbs_find_unit_type_desc(ctx, unit);
     if (!desc)
         return AVERROR(ENOSYS);
 
     switch (desc->content_type) {
-    case CBS_CONTENT_TYPE_POD:
-        ref = av_buffer_alloc(desc->content_size);
-        if (!ref)
-            return AVERROR(ENOMEM);
-        memcpy(ref->data, unit->content, desc->content_size);
-        err = 0;
-        break;
-
     case CBS_CONTENT_TYPE_INTERNAL_REFS:
-        err = cbs_clone_unit_content(&ref, unit, desc);
+        err = cbs_clone_internal_refs_unit_content(&ref, unit, desc);
         break;
 
     case CBS_CONTENT_TYPE_COMPLEX:
-        if (!desc->content_clone)
+        if (!desc->type.complex.content_clone)
             return AVERROR_PATCHWELCOME;
-        err = desc->content_clone(&ref, unit);
+        err = desc->type.complex.content_clone(&ref, unit);
         break;
 
     default:
@@ -1008,51 +1001,28 @@
     return 0;
 }
 
+int ff_cbs_make_unit_refcounted(CodedBitstreamContext *ctx,
+                                CodedBitstreamUnit *unit)
+{
+    av_assert0(unit->content);
+    if (unit->content_ref)
+        return 0;
+    return cbs_clone_unit_content(ctx, unit);
+}
+
 int ff_cbs_make_unit_writable(CodedBitstreamContext *ctx,
                               CodedBitstreamUnit *unit)
 {
-    const CodedBitstreamUnitTypeDescriptor *desc;
-    AVBufferRef *ref;
+    AVBufferRef *ref = unit->content_ref;
     int err;
 
-    // This can only be applied to refcounted units.
-    err = ff_cbs_make_unit_refcounted(ctx, unit);
-    if (err < 0)
-        return err;
-    av_assert0(unit->content && unit->content_ref);
-
-    if (av_buffer_is_writable(unit->content_ref))
+    av_assert0(unit->content);
+    if (ref && av_buffer_is_writable(ref))
         return 0;
 
-    desc = cbs_find_unit_type_desc(ctx, unit);
-    if (!desc)
-        return AVERROR(ENOSYS);
-
-    switch (desc->content_type) {
-    case CBS_CONTENT_TYPE_POD:
-        err = av_buffer_make_writable(&unit->content_ref);
-        break;
-
-    case CBS_CONTENT_TYPE_INTERNAL_REFS:
-        err = cbs_clone_unit_content(&ref, unit, desc);
-        break;
-
-    case CBS_CONTENT_TYPE_COMPLEX:
-        if (!desc->content_clone)
-            return AVERROR_PATCHWELCOME;
-        err = desc->content_clone(&ref, unit);
-        break;
-
-    default:
-        av_assert0(0 && "Invalid content type.");
-    }
+    err = cbs_clone_unit_content(ctx, unit);
     if (err < 0)
         return err;
-
-    if (desc->content_type != CBS_CONTENT_TYPE_POD) {
-        av_buffer_unref(&unit->content_ref);
-        unit->content_ref = ref;
-    }
-    unit->content = unit->content_ref->data;
+    av_buffer_unref(&ref);
     return 0;
 }
diff -Naur a/media/ffvpx/libavcodec/cbs.h b/media/ffvpx/libavcodec/cbs.h
--- a/media/ffvpx/libavcodec/cbs.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/cbs.h	2023-04-06 12:50:06.971471053 +0200
@@ -24,7 +24,9 @@
 
 #include "libavutil/buffer.h"
 
-#include "avcodec.h"
+#include "codec_id.h"
+#include "codec_par.h"
+#include "packet.h"
 
 
 /*
@@ -40,6 +42,7 @@
  * bitstream.
  */
 
+struct AVCodecContext;
 struct CodedBitstreamType;
 
 /**
@@ -271,7 +274,11 @@
  */
 int ff_cbs_read_extradata_from_codec(CodedBitstreamContext *ctx,
                                      CodedBitstreamFragment *frag,
-                                     const AVCodecContext *avctx);
+                                     const struct AVCodecContext *avctx);
+
+int ff_cbs_read_packet_side_data(CodedBitstreamContext *ctx,
+                                 CodedBitstreamFragment *frag,
+                                 const AVPacket *pkt);
 
 /**
  * Read the data bitstream from a packet into a fragment, then
@@ -357,30 +364,12 @@
 void ff_cbs_fragment_free(CodedBitstreamFragment *frag);
 
 /**
- * Allocate a new internal content buffer of the given size in the unit.
- *
- * The content will be zeroed.
- */
-int ff_cbs_alloc_unit_content(CodedBitstreamUnit *unit,
-                              size_t size,
-                              void (*free)(void *opaque, uint8_t *content));
-
-/**
  * Allocate a new internal content buffer matching the type of the unit.
  *
  * The content will be zeroed.
  */
-int ff_cbs_alloc_unit_content2(CodedBitstreamContext *ctx,
-                               CodedBitstreamUnit *unit);
-
-
-/**
- * Allocate a new internal data buffer of the given size in the unit.
- *
- * The data buffer will have input padding.
- */
-int ff_cbs_alloc_unit_data(CodedBitstreamUnit *unit,
-                           size_t size);
+int ff_cbs_alloc_unit_content(CodedBitstreamContext *ctx,
+                              CodedBitstreamUnit *unit);
 
 /**
  * Insert a new unit into a fragment with the given content.
@@ -395,14 +384,13 @@
                                AVBufferRef *content_buf);
 
 /**
- * Insert a new unit into a fragment with the given data bitstream.
+ * Add a new unit to a fragment with the given data bitstream.
  *
  * If data_buf is not supplied then data must have been allocated with
  * av_malloc() and will on success become owned by the unit after this
  * call or freed on error.
  */
-int ff_cbs_insert_unit_data(CodedBitstreamFragment *frag,
-                            int position,
+int ff_cbs_append_unit_data(CodedBitstreamFragment *frag,
                             CodedBitstreamUnitType type,
                             uint8_t *data, size_t data_size,
                             AVBufferRef *data_buf);
diff -Naur a/media/ffvpx/libavcodec/cbs_internal.h b/media/ffvpx/libavcodec/cbs_internal.h
--- a/media/ffvpx/libavcodec/cbs_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/cbs_internal.h	2023-04-06 12:50:06.971471053 +0200
@@ -19,16 +19,19 @@
 #ifndef AVCODEC_CBS_INTERNAL_H
 #define AVCODEC_CBS_INTERNAL_H
 
-#include "avcodec.h"
+#include <stdint.h>
+
+#include "libavutil/buffer.h"
+#include "libavutil/log.h"
+
 #include "cbs.h"
+#include "codec_id.h"
 #include "get_bits.h"
 #include "put_bits.h"
 
 
 enum CBSContentType {
-    // Unit content is a simple structure.
-    CBS_CONTENT_TYPE_POD,
-    // Unit content contains some references to other structures, but all
+    // Unit content may contain some references to other structures, but all
     // managed via buffer reference counting.  The descriptor defines the
     // structure offsets of every buffer reference.
     CBS_CONTENT_TYPE_INTERNAL_REFS,
@@ -38,9 +41,9 @@
 };
 
 enum {
-      // Maximum number of unit types described by the same unit type
-      // descriptor.
-      CBS_MAX_UNIT_TYPES  = 3,
+      // Maximum number of unit types described by the same non-range
+      // unit type descriptor.
+      CBS_MAX_LIST_UNIT_TYPES = 3,
       // Maximum number of reference buffer offsets in any one unit.
       CBS_MAX_REF_OFFSETS = 2,
       // Special value used in a unit type descriptor to indicate that it
@@ -55,13 +58,16 @@
     // used instead.
     int nb_unit_types;
 
-    // Array of unit types that this entry describes.
-    const CodedBitstreamUnitType unit_types[CBS_MAX_UNIT_TYPES];
-
-    // Start and end of unit type range, used if nb_unit_types is
-    // CBS_UNIT_TYPE_RANGE.
-    const CodedBitstreamUnitType unit_type_range_start;
-    const CodedBitstreamUnitType unit_type_range_end;
+    union {
+        // Array of unit types that this entry describes.
+        CodedBitstreamUnitType list[CBS_MAX_LIST_UNIT_TYPES];
+        // Start and end of unit type range, used if nb_unit_types is
+        // CBS_UNIT_TYPE_RANGE.
+        struct {
+            CodedBitstreamUnitType start;
+            CodedBitstreamUnitType end;
+        } range;
+    } unit_type;
 
     // The type of content described.
     enum CBSContentType content_type;
@@ -69,18 +75,27 @@
     // the decomposed content of this type of unit.
     size_t content_size;
 
-    // Number of entries in the ref_offsets array.  Only used if the
-    // content_type is CBS_CONTENT_TYPE_INTERNAL_REFS.
-    int nb_ref_offsets;
-    // The structure must contain two adjacent elements:
-    //   type        *field;
-    //   AVBufferRef *field_ref;
-    // where field points to something in the buffer referred to by
-    // field_ref.  This offset is then set to offsetof(struct, field).
-    size_t ref_offsets[CBS_MAX_REF_OFFSETS];
-
-    void (*content_free)(void *opaque, uint8_t *data);
-    int  (*content_clone)(AVBufferRef **ref, CodedBitstreamUnit *unit);
+    union {
+        // This union's state is determined by content_type:
+        // ref for CBS_CONTENT_TYPE_INTERNAL_REFS,
+        // complex for CBS_CONTENT_TYPE_COMPLEX.
+        struct {
+            // Number of entries in the ref_offsets array.
+            // May be zero, then the structure is POD-like.
+            int nb_offsets;
+            // The structure must contain two adjacent elements:
+            //   type        *field;
+            //   AVBufferRef *field_ref;
+            // where field points to something in the buffer referred to by
+            // field_ref.  This offset is then set to offsetof(struct, field).
+            size_t offsets[CBS_MAX_REF_OFFSETS];
+        } ref;
+
+        struct {
+            void (*content_free)(void *opaque, uint8_t *data);
+            int  (*content_clone)(AVBufferRef **ref, CodedBitstreamUnit *unit);
+        } complex;
+    } type;
 } CodedBitstreamUnitTypeDescriptor;
 
 typedef struct CodedBitstreamType {
@@ -176,28 +191,54 @@
 // range_min in the above functions.
 #define MIN_INT_BITS(length) (-(INT64_C(1) << ((length) - 1)))
 
-
-#define CBS_UNIT_TYPE_POD(type, structure) { \
+#define TYPE_LIST(...) { __VA_ARGS__ }
+#define CBS_UNIT_TYPE_POD(type_, structure) { \
         .nb_unit_types  = 1, \
-        .unit_types     = { type }, \
-        .content_type   = CBS_CONTENT_TYPE_POD, \
+        .unit_type.list = { type_ }, \
+        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS, \
         .content_size   = sizeof(structure), \
+        .type.ref       = { .nb_offsets = 0 }, \
     }
-#define CBS_UNIT_TYPE_INTERNAL_REF(type, structure, ref_field) { \
-        .nb_unit_types  = 1, \
-        .unit_types     = { type }, \
+#define CBS_UNIT_RANGE_POD(range_start, range_end, structure) { \
+        .nb_unit_types         = CBS_UNIT_TYPE_RANGE, \
+        .unit_type.range.start = range_start, \
+        .unit_type.range.end   = range_end, \
+        .content_type          = CBS_CONTENT_TYPE_INTERNAL_REFS, \
+        .content_size          = sizeof(structure), \
+        .type.ref              = { .nb_offsets = 0 }, \
+    }
+
+#define CBS_UNIT_TYPES_INTERNAL_REF(types, structure, ref_field) { \
+        .nb_unit_types  = FF_ARRAY_ELEMS((CodedBitstreamUnitType[])TYPE_LIST types), \
+        .unit_type.list = TYPE_LIST types, \
         .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS, \
         .content_size   = sizeof(structure), \
-        .nb_ref_offsets = 1, \
-        .ref_offsets    = { offsetof(structure, ref_field) }, \
+        .type.ref       = { .nb_offsets = 1, \
+                            .offsets    = { offsetof(structure, ref_field) } }, \
     }
-#define CBS_UNIT_TYPE_COMPLEX(type, structure, free_func) { \
-        .nb_unit_types  = 1, \
-        .unit_types     = { type }, \
+#define CBS_UNIT_TYPE_INTERNAL_REF(type, structure, ref_field) \
+    CBS_UNIT_TYPES_INTERNAL_REF((type), structure, ref_field)
+
+#define CBS_UNIT_RANGE_INTERNAL_REF(range_start, range_end, structure, ref_field) { \
+        .nb_unit_types         = CBS_UNIT_TYPE_RANGE, \
+        .unit_type.range.start = range_start, \
+        .unit_type.range.end   = range_end, \
+        .content_type          = CBS_CONTENT_TYPE_INTERNAL_REFS, \
+        .content_size          = sizeof(structure), \
+        .type.ref = { .nb_offsets = 1, \
+                      .offsets    = { offsetof(structure, ref_field) } }, \
+    }
+
+#define CBS_UNIT_TYPES_COMPLEX(types, structure, free_func) { \
+        .nb_unit_types  = FF_ARRAY_ELEMS((CodedBitstreamUnitType[])TYPE_LIST types), \
+        .unit_type.list = TYPE_LIST types, \
         .content_type   = CBS_CONTENT_TYPE_COMPLEX, \
         .content_size   = sizeof(structure), \
-        .content_free   = free_func, \
+        .type.complex   = { .content_free = free_func }, \
     }
+#define CBS_UNIT_TYPE_COMPLEX(type, structure, free_func) \
+    CBS_UNIT_TYPES_COMPLEX((type), structure, free_func)
+
 #define CBS_UNIT_TYPE_END_OF_LIST { .nb_unit_types = 0 }
 
 
diff -Naur a/media/ffvpx/libavcodec/codec_desc.c b/media/ffvpx/libavcodec/codec_desc.c
--- a/media/ffvpx/libavcodec/codec_desc.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec_desc.c	2023-04-06 12:50:24.491176503 +0200
@@ -19,15 +19,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stdlib.h>
 #include <string.h>
 
-#include "libavutil/common.h"
 #include "libavutil/internal.h"
+#include "libavutil/macros.h"
 
 #include "codec_id.h"
 #include "codec_desc.h"
 #include "profiles.h"
-#include "version.h"
 
 #define MT(...) (const char *const[]){ __VA_ARGS__, NULL }
 
@@ -1462,6 +1462,7 @@
         .long_name = NULL_IF_CONFIG_SMALL("Avid Meridien Uncompressed"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
+#if FF_API_AYUV_CODECID
     {
         .id        = AV_CODEC_ID_AYUV,
         .type      = AVMEDIA_TYPE_VIDEO,
@@ -1469,6 +1470,7 @@
         .long_name = NULL_IF_CONFIG_SMALL("Uncompressed packed MS 4:4:4:4"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
+#endif
     {
         .id        = AV_CODEC_ID_TARGA_Y216,
         .type      = AVMEDIA_TYPE_VIDEO,
@@ -1856,6 +1858,71 @@
         .long_name = NULL_IF_CONFIG_SMALL("Digital Pictures SGA Video"),
         .props     = AV_CODEC_PROP_LOSSY,
     },
+    {
+        .id        = AV_CODEC_ID_GEM,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "gem",
+        .long_name = NULL_IF_CONFIG_SMALL("GEM Raster image"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_VBN,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "vbn",
+        .long_name = NULL_IF_CONFIG_SMALL("Vizrt Binary Image"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_JPEGXL,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "jpegxl",
+        .long_name = NULL_IF_CONFIG_SMALL("JPEG XL"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY |
+                     AV_CODEC_PROP_LOSSLESS,
+        .mime_types= MT("image/jxl"),
+    },
+    {
+        .id        = AV_CODEC_ID_QOI,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "qoi",
+        .long_name = NULL_IF_CONFIG_SMALL("QOI (Quite OK Image)"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_PHM,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "phm",
+        .long_name = NULL_IF_CONFIG_SMALL("PHM (Portable HalfFloatMap) image"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_RADIANCE_HDR,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "hdr",
+        .long_name = NULL_IF_CONFIG_SMALL("HDR (Radiance RGBE format) image"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_WBMP,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "wbmp",
+        .long_name = NULL_IF_CONFIG_SMALL("WBMP (Wireless Application Protocol Bitmap) image"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_MEDIA100,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "media100",
+        .long_name = NULL_IF_CONFIG_SMALL("Media 100i"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_VQC,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "vqc",
+        .long_name = NULL_IF_CONFIG_SMALL("ViewQuest VQC"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
 
     /* various PCM "codecs" */
     {
@@ -2462,6 +2529,20 @@
         .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA MobiClip MOFLEX"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
+    {
+        .id        = AV_CODEC_ID_ADPCM_IMA_ACORN,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "adpcm_ima_acorn",
+        .long_name = NULL_IF_CONFIG_SMALL("ADPCM IMA Acorn Replay"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_ADPCM_XMD,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "adpcm_xmd",
+        .long_name = NULL_IF_CONFIG_SMALL("ADPCM Konami XMD"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
 
     /* AMR */
     {
@@ -2545,6 +2626,20 @@
         .long_name = NULL_IF_CONFIG_SMALL("DPCM Xilam DERF"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
+    {
+        .id        = AV_CODEC_ID_WADY_DPCM,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "wady_dpcm",
+        .long_name = NULL_IF_CONFIG_SMALL("DPCM Marble WADY"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_CBD2_DPCM,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "cbd2_dpcm",
+        .long_name = NULL_IF_CONFIG_SMALL("DPCM Cuberoot-Delta-Exact"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
 
     /* audio codecs */
     {
@@ -2758,7 +2853,7 @@
         .type      = AVMEDIA_TYPE_AUDIO,
         .name      = "mlp",
         .long_name = NULL_IF_CONFIG_SMALL("MLP (Meridian Lossless Packing)"),
-        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+        .props     = AV_CODEC_PROP_LOSSLESS,
     },
     {
         .id        = AV_CODEC_ID_GSM_MS,
@@ -3216,6 +3311,62 @@
         .long_name = NULL_IF_CONFIG_SMALL("MobiClip FastAudio"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
+    {
+        .id        = AV_CODEC_ID_MSNSIREN,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "msnsiren",
+        .long_name = NULL_IF_CONFIG_SMALL("MSN Siren"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_DFPWM,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "dfpwm",
+        .long_name = NULL_IF_CONFIG_SMALL("DFPWM (Dynamic Filter Pulse Width Modulation)"),
+        .props     = AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_BONK,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "bonk",
+        .long_name = NULL_IF_CONFIG_SMALL("Bonk audio"),
+        .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_MISC4,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "misc4",
+        .long_name = NULL_IF_CONFIG_SMALL("Micronas SC-4 Audio"),
+        .props     = AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_INTRA_ONLY,
+    },
+    {
+        .id        = AV_CODEC_ID_APAC,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "apac",
+        .long_name = NULL_IF_CONFIG_SMALL("Marian's A-pac audio"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_FTR,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "ftr",
+        .long_name = NULL_IF_CONFIG_SMALL("FTR Voice"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_WAVARC,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "wavarc",
+        .long_name = NULL_IF_CONFIG_SMALL("Waveform Archiver"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
+    {
+        .id        = AV_CODEC_ID_RKA,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "rka",
+        .long_name = NULL_IF_CONFIG_SMALL("RKA (RK Audio)"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY | AV_CODEC_PROP_LOSSLESS,
+    },
 
     /* subtitle codecs */
     {
@@ -3488,6 +3639,18 @@
         .long_name = NULL_IF_CONFIG_SMALL("AVFrame to AVPacket passthrough"),
         .props     = AV_CODEC_PROP_LOSSLESS,
     },
+    {
+        .id        = AV_CODEC_ID_VNULL,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "vnull",
+        .long_name = NULL_IF_CONFIG_SMALL("Null video codec"),
+    },
+    {
+        .id        = AV_CODEC_ID_ANULL,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "anull",
+        .long_name = NULL_IF_CONFIG_SMALL("Null audio codec"),
+    },
 };
 
 static int descriptor_compare(const void *key, const void *member)
diff -Naur a/media/ffvpx/libavcodec/codec.h b/media/ffvpx/libavcodec/codec.h
--- a/media/ffvpx/libavcodec/codec.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec.h	2023-04-06 12:50:24.491176503 +0200
@@ -31,7 +31,7 @@
 #include "libavutil/samplefmt.h"
 
 #include "libavcodec/codec_id.h"
-#include "libavcodec/version.h"
+#include "libavcodec/version_major.h"
 
 /**
  * @addtogroup lavc_core
@@ -50,7 +50,6 @@
  * avcodec_default_get_buffer2 or avcodec_default_get_encode_buffer.
  */
 #define AV_CODEC_CAP_DR1                 (1 <<  1)
-#define AV_CODEC_CAP_TRUNCATED           (1 <<  3)
 /**
  * Encoder or decoder requires flushing with NULL input at the end in order to
  * give the complete and correct output.
@@ -120,9 +119,6 @@
  * multithreading-capable external libraries.
  */
 #define AV_CODEC_CAP_OTHER_THREADS       (1 << 15)
-#if FF_API_AUTO_THREADS
-#define AV_CODEC_CAP_AUTO_THREADS        AV_CODEC_CAP_OTHER_THREADS
-#endif
 /**
  * Audio encoder supports receiving a different number of samples in each call.
  */
@@ -138,17 +134,6 @@
  */
 #define AV_CODEC_CAP_AVOID_PROBING       (1 << 17)
 
-#if FF_API_UNUSED_CODEC_CAPS
-/**
- * Deprecated and unused. Use AVCodecDescriptor.props instead
- */
-#define AV_CODEC_CAP_INTRA_ONLY       0x40000000
-/**
- * Deprecated and unused. Use AVCodecDescriptor.props instead
- */
-#define AV_CODEC_CAP_LOSSLESS         0x80000000
-#endif
-
 /**
  * Codec is backed by a hardware implementation. Typically used to
  * identify a non-hwaccel hardware decoder. For information about hwaccels, use
@@ -164,9 +149,9 @@
 #define AV_CODEC_CAP_HYBRID              (1 << 19)
 
 /**
- * This codec takes the reordered_opaque field from input AVFrames
- * and returns it in the corresponding field in AVCodecContext after
- * encoding.
+ * This encoder can reorder user opaque values from input AVFrames and return
+ * them with corresponding output packets.
+ * @see AV_CODEC_FLAG_COPY_OPAQUE
  */
 #define AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE (1 << 20)
 
@@ -178,6 +163,14 @@
 #define AV_CODEC_CAP_ENCODER_FLUSH   (1 << 21)
 
 /**
+ * The encoder is able to output reconstructed frame data, i.e. raw frames that
+ * would be produced by decoding the encoded bitstream.
+ *
+ * Reconstructed frame output is enabled by the AV_CODEC_FLAG_RECON_FRAME flag.
+ */
+#define AV_CODEC_CAP_ENCODER_RECON_FRAME (1 << 22)
+
+/**
  * AVProfile.
  */
 typedef struct AVProfile {
@@ -185,12 +178,6 @@
     const char *name; ///< short name for the profile
 } AVProfile;
 
-typedef struct AVCodecDefault AVCodecDefault;
-
-struct AVCodecContext;
-struct AVSubtitle;
-struct AVPacket;
-
 /**
  * AVCodec.
  */
@@ -214,12 +201,18 @@
      * see AV_CODEC_CAP_*
      */
     int capabilities;
+    uint8_t max_lowres;                     ///< maximum value for lowres supported by the decoder
     const AVRational *supported_framerates; ///< array of supported framerates, or NULL if any, array is terminated by {0,0}
     const enum AVPixelFormat *pix_fmts;     ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
     const int *supported_samplerates;       ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
     const enum AVSampleFormat *sample_fmts; ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
+#if FF_API_OLD_CHANNEL_LAYOUT
+    /**
+     * @deprecated use ch_layouts instead
+     */
+    attribute_deprecated
     const uint64_t *channel_layouts;         ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
-    uint8_t max_lowres;                     ///< maximum value for lowres supported by the decoder
+#endif
     const AVClass *priv_class;              ///< AVClass for the private context
     const AVProfile *profiles;              ///< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
 
@@ -235,117 +228,10 @@
      */
     const char *wrapper_name;
 
-    /*****************************************************************
-     * No fields below this line are part of the public API. They
-     * may not be used outside of libavcodec and can be changed and
-     * removed at will.
-     * New public fields should be added right above.
-     *****************************************************************
-     */
-    int priv_data_size;
-#if FF_API_NEXT
-    struct AVCodec *next;
-#endif
-    /**
-     * @name Frame-level threading support functions
-     * @{
-     */
-    /**
-     * Copy necessary context variables from a previous thread context to the current one.
-     * If not defined, the next thread will start automatically; otherwise, the codec
-     * must call ff_thread_finish_setup().
-     *
-     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
-     */
-    int (*update_thread_context)(struct AVCodecContext *dst, const struct AVCodecContext *src);
-    /** @} */
-
-    /**
-     * Private codec-specific defaults.
-     */
-    const AVCodecDefault *defaults;
-
     /**
-     * Initialize codec static data, called from av_codec_iterate().
-     *
-     * This is not intended for time consuming operations as it is
-     * run for every codec regardless of that codec being used.
+     * Array of supported channel layouts, terminated with a zeroed layout.
      */
-    void (*init_static_data)(struct AVCodec *codec);
-
-    int (*init)(struct AVCodecContext *);
-    int (*encode_sub)(struct AVCodecContext *, uint8_t *buf, int buf_size,
-                      const struct AVSubtitle *sub);
-    /**
-     * Encode data to an AVPacket.
-     *
-     * @param      avctx          codec context
-     * @param      avpkt          output AVPacket
-     * @param[in]  frame          AVFrame containing the raw data to be encoded
-     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
-     *                            non-empty packet was returned in avpkt.
-     * @return 0 on success, negative error code on failure
-     */
-    int (*encode2)(struct AVCodecContext *avctx, struct AVPacket *avpkt,
-                   const struct AVFrame *frame, int *got_packet_ptr);
-    /**
-     * Decode picture or subtitle data.
-     *
-     * @param      avctx          codec context
-     * @param      outdata        codec type dependent output struct
-     * @param[out] got_frame_ptr  decoder sets to 0 or 1 to indicate that a
-     *                            non-empty frame or subtitle was returned in
-     *                            outdata.
-     * @param[in]  avpkt          AVPacket containing the data to be decoded
-     * @return amount of bytes read from the packet on success, negative error
-     *         code on failure
-     */
-    int (*decode)(struct AVCodecContext *avctx, void *outdata,
-                  int *got_frame_ptr, struct AVPacket *avpkt);
-    int (*close)(struct AVCodecContext *);
-    /**
-     * Encode API with decoupled frame/packet dataflow. This function is called
-     * to get one output packet. It should call ff_encode_get_frame() to obtain
-     * input data.
-     */
-    int (*receive_packet)(struct AVCodecContext *avctx, struct AVPacket *avpkt);
-
-    /**
-     * Decode API with decoupled packet/frame dataflow. This function is called
-     * to get one output frame. It should call ff_decode_get_packet() to obtain
-     * input data.
-     */
-    int (*receive_frame)(struct AVCodecContext *avctx, struct AVFrame *frame);
-    /**
-     * Flush buffers.
-     * Will be called when seeking
-     */
-    void (*flush)(struct AVCodecContext *);
-    /**
-     * Internal codec capabilities.
-     * See FF_CODEC_CAP_* in internal.h
-     */
-    int caps_internal;
-
-    /**
-     * Decoding only, a comma-separated list of bitstream filters to apply to
-     * packets before decoding.
-     */
-    const char *bsfs;
-
-    /**
-     * Array of pointers to hardware configurations supported by the codec,
-     * or NULL if no hardware supported.  The array is terminated by a NULL
-     * pointer.
-     *
-     * The user can only access this field via avcodec_get_hw_config().
-     */
-    const struct AVCodecHWConfigInternal *const *hw_configs;
-
-    /**
-     * List of supported codec_tags, terminated by FF_CODEC_TAGS_END.
-     */
-    const uint32_t *codec_tags;
+    const AVChannelLayout *ch_layouts;
 } AVCodec;
 
 /**
@@ -365,7 +251,7 @@
  * @param id AVCodecID of the requested decoder
  * @return A decoder if one was found, NULL otherwise.
  */
-AVCodec *avcodec_find_decoder(enum AVCodecID id);
+const AVCodec *avcodec_find_decoder(enum AVCodecID id);
 
 /**
  * Find a registered decoder with the specified name.
@@ -373,7 +259,7 @@
  * @param name name of the requested decoder
  * @return A decoder if one was found, NULL otherwise.
  */
-AVCodec *avcodec_find_decoder_by_name(const char *name);
+const AVCodec *avcodec_find_decoder_by_name(const char *name);
 
 /**
  * Find a registered encoder with a matching codec ID.
@@ -381,7 +267,7 @@
  * @param id AVCodecID of the requested encoder
  * @return An encoder if one was found, NULL otherwise.
  */
-AVCodec *avcodec_find_encoder(enum AVCodecID id);
+const AVCodec *avcodec_find_encoder(enum AVCodecID id);
 
 /**
  * Find a registered encoder with the specified name.
@@ -389,7 +275,7 @@
  * @param name name of the requested encoder
  * @return An encoder if one was found, NULL otherwise.
  */
-AVCodec *avcodec_find_encoder_by_name(const char *name);
+const AVCodec *avcodec_find_encoder_by_name(const char *name);
 /**
  * @return a non-zero number if codec is an encoder, zero otherwise
  */
@@ -400,6 +286,15 @@
  */
 int av_codec_is_decoder(const AVCodec *codec);
 
+/**
+ * Return a name for the specified profile, if available.
+ *
+ * @param codec the codec that is searched for the given profile
+ * @param profile the profile value for which a name is requested
+ * @return A name for the profile if found, NULL otherwise.
+ */
+const char *av_get_profile_name(const AVCodec *codec, int profile);
+
 enum {
     /**
      * The codec supports this format via the hw_device_ctx interface.
diff -Naur a/media/ffvpx/libavcodec/codec_id.h b/media/ffvpx/libavcodec/codec_id.h
--- a/media/ffvpx/libavcodec/codec_id.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec_id.h	2023-04-06 12:50:24.491176503 +0200
@@ -24,6 +24,8 @@
 #include "libavutil/avutil.h"
 #include "libavutil/samplefmt.h"
 
+#include "version_major.h"
+
 /**
  * @addtogroup lavc_core
  * @{
@@ -251,7 +253,9 @@
     AV_CODEC_ID_AVRP,
     AV_CODEC_ID_012V,
     AV_CODEC_ID_AVUI,
+#if FF_API_AYUV_CODECID
     AV_CODEC_ID_AYUV,
+#endif
     AV_CODEC_ID_TARGA_Y216,
     AV_CODEC_ID_V308,
     AV_CODEC_ID_V408,
@@ -308,6 +312,14 @@
     AV_CODEC_ID_SIMBIOSIS_IMX,
     AV_CODEC_ID_SGA_VIDEO,
     AV_CODEC_ID_GEM,
+    AV_CODEC_ID_VBN,
+    AV_CODEC_ID_JPEGXL,
+    AV_CODEC_ID_QOI,
+    AV_CODEC_ID_PHM,
+    AV_CODEC_ID_RADIANCE_HDR,
+    AV_CODEC_ID_WBMP,
+    AV_CODEC_ID_MEDIA100,
+    AV_CODEC_ID_VQC,
 
     /* various PCM "codecs" */
     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
@@ -401,6 +413,7 @@
     AV_CODEC_ID_ADPCM_IMA_CUNNING,
     AV_CODEC_ID_ADPCM_IMA_MOFLEX,
     AV_CODEC_ID_ADPCM_IMA_ACORN,
+    AV_CODEC_ID_ADPCM_XMD,
 
     /* AMR */
     AV_CODEC_ID_AMR_NB = 0x12000,
@@ -418,6 +431,8 @@
     AV_CODEC_ID_SDX2_DPCM,
     AV_CODEC_ID_GREMLIN_DPCM,
     AV_CODEC_ID_DERF_DPCM,
+    AV_CODEC_ID_WADY_DPCM,
+    AV_CODEC_ID_CBD2_DPCM,
 
     /* audio codecs */
     AV_CODEC_ID_MP2 = 0x15000,
@@ -516,6 +531,13 @@
     AV_CODEC_ID_HCA,
     AV_CODEC_ID_FASTAUDIO,
     AV_CODEC_ID_MSNSIREN,
+    AV_CODEC_ID_DFPWM,
+    AV_CODEC_ID_BONK,
+    AV_CODEC_ID_MISC4,
+    AV_CODEC_ID_APAC,
+    AV_CODEC_ID_FTR,
+    AV_CODEC_ID_WAVARC,
+    AV_CODEC_ID_RKA,
 
     /* subtitle codecs */
     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
@@ -570,6 +592,16 @@
                                 * stream (only used by libavformat) */
     AV_CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
     AV_CODEC_ID_WRAPPED_AVFRAME = 0x21001, ///< Passthrough codec, AVFrames wrapped in AVPacket
+    /**
+     * Dummy null video codec, useful mainly for development and debugging.
+     * Null encoder/decoder discard all input and never return any output.
+     */
+    AV_CODEC_ID_VNULL,
+    /**
+     * Dummy null audio codec, useful mainly for development and debugging.
+     * Null encoder/decoder discard all input and never return any output.
+     */
+    AV_CODEC_ID_ANULL,
 };
 
 /**
diff -Naur a/media/ffvpx/libavcodec/codec_internal.h b/media/ffvpx/libavcodec/codec_internal.h
--- a/media/ffvpx/libavcodec/codec_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec_internal.h	2023-04-06 12:50:24.491176503 +0200
@@ -0,0 +1,330 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_CODEC_INTERNAL_H
+#define AVCODEC_CODEC_INTERNAL_H
+
+#include <stdint.h>
+
+#include "libavutil/attributes.h"
+#include "codec.h"
+#include "config.h"
+
+/**
+ * The codec is not known to be init-threadsafe (i.e. it might be unsafe
+ * to initialize this codec and another codec concurrently, typically because
+ * the codec calls external APIs that are not known to be thread-safe).
+ * Therefore calling the codec's init function needs to be guarded with a lock.
+ */
+#define FF_CODEC_CAP_NOT_INIT_THREADSAFE    (1 << 0)
+/**
+ * The codec allows calling the close function for deallocation even if
+ * the init function returned a failure. Without this capability flag, a
+ * codec does such cleanup internally when returning failures from the
+ * init function and does not expect the close function to be called at
+ * all.
+ */
+#define FF_CODEC_CAP_INIT_CLEANUP           (1 << 1)
+/**
+ * Decoders marked with FF_CODEC_CAP_SETS_PKT_DTS want to set
+ * AVFrame.pkt_dts manually. If the flag is set, decode.c won't overwrite
+ * this field. If it's unset, decode.c tries to guess the pkt_dts field
+ * from the input AVPacket.
+ */
+#define FF_CODEC_CAP_SETS_PKT_DTS           (1 << 2)
+/**
+ * The decoder extracts and fills its parameters even if the frame is
+ * skipped due to the skip_frame setting.
+ */
+#define FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM  (1 << 3)
+/**
+ * The decoder sets the cropping fields in the output frames manually.
+ * If this cap is set, the generic code will initialize output frame
+ * dimensions to coded rather than display values.
+ */
+#define FF_CODEC_CAP_EXPORTS_CROPPING       (1 << 4)
+/**
+ * Codec initializes slice-based threading with a main function
+ */
+#define FF_CODEC_CAP_SLICE_THREAD_HAS_MF    (1 << 5)
+/*
+ * The codec supports frame threading and has inter-frame dependencies, so it
+ * uses ff_thread_report/await_progress().
+ */
+#define FF_CODEC_CAP_ALLOCATE_PROGRESS      (1 << 6)
+/**
+ * Codec handles avctx->thread_count == 0 (auto) internally.
+ */
+#define FF_CODEC_CAP_AUTO_THREADS           (1 << 7)
+/**
+ * Codec handles output frame properties internally instead of letting the
+ * internal logic derive them from AVCodecInternal.last_pkt_props.
+ */
+#define FF_CODEC_CAP_SETS_FRAME_PROPS       (1 << 8)
+/**
+ * Codec supports embedded ICC profiles (AV_FRAME_DATA_ICC_PROFILE).
+ */
+#define FF_CODEC_CAP_ICC_PROFILES           (1 << 9)
+/**
+ * The encoder has AV_CODEC_CAP_DELAY set, but does not actually have delay - it
+ * only wants to be flushed at the end to update some context variables (e.g.
+ * 2pass stats) or produce a trailing packet. Besides that it immediately
+ * produces exactly one output packet per each input frame, just as no-delay
+ * encoders do.
+ */
+#define FF_CODEC_CAP_EOF_FLUSH              (1 << 10)
+
+/**
+ * FFCodec.codec_tags termination value
+ */
+#define FF_CODEC_TAGS_END -1
+
+typedef struct FFCodecDefault {
+    const char *key;
+    const char *value;
+} FFCodecDefault;
+
+struct AVCodecContext;
+struct AVSubtitle;
+struct AVPacket;
+
+enum FFCodecType {
+    /* The codec is a decoder using the decode callback;
+     * audio and video codecs only. */
+    FF_CODEC_CB_TYPE_DECODE,
+    /* The codec is a decoder using the decode_sub callback;
+     * subtitle codecs only. */
+    FF_CODEC_CB_TYPE_DECODE_SUB,
+    /* The codec is a decoder using the receive_frame callback;
+     * audio and video codecs only. */
+    FF_CODEC_CB_TYPE_RECEIVE_FRAME,
+    /* The codec is an encoder using the encode callback;
+     * audio and video codecs only. */
+    FF_CODEC_CB_TYPE_ENCODE,
+    /* The codec is an encoder using the encode_sub callback;
+     * subtitle codecs only. */
+    FF_CODEC_CB_TYPE_ENCODE_SUB,
+    /* The codec is an encoder using the receive_packet callback;
+     * audio and video codecs only. */
+    FF_CODEC_CB_TYPE_RECEIVE_PACKET,
+};
+
+typedef struct FFCodec {
+    /**
+     * The public AVCodec. See codec.h for it.
+     */
+    AVCodec p;
+
+    /**
+     * Internal codec capabilities FF_CODEC_CAP_*.
+     */
+    unsigned caps_internal:29;
+
+    /**
+     * This field determines the type of the codec (decoder/encoder)
+     * and also the exact callback cb implemented by the codec.
+     * cb_type uses enum FFCodecType values.
+     */
+    unsigned cb_type:3;
+
+    int priv_data_size;
+    /**
+     * @name Frame-level threading support functions
+     * @{
+     */
+    /**
+     * Copy necessary context variables from a previous thread context to the current one.
+     * If not defined, the next thread will start automatically; otherwise, the codec
+     * must call ff_thread_finish_setup().
+     *
+     * dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
+     */
+    int (*update_thread_context)(struct AVCodecContext *dst, const struct AVCodecContext *src);
+
+    /**
+     * Copy variables back to the user-facing context
+     */
+    int (*update_thread_context_for_user)(struct AVCodecContext *dst, const struct AVCodecContext *src);
+    /** @} */
+
+    /**
+     * Private codec-specific defaults.
+     */
+    const FFCodecDefault *defaults;
+
+    /**
+     * Initialize codec static data, called from av_codec_iterate().
+     *
+     * This is not intended for time consuming operations as it is
+     * run for every codec regardless of that codec being used.
+     */
+    void (*init_static_data)(struct FFCodec *codec);
+
+    int (*init)(struct AVCodecContext *);
+
+    union {
+        /**
+         * Decode to an AVFrame.
+         * cb is in this state if cb_type is FF_CODEC_CB_TYPE_DECODE.
+         *
+         * @param      avctx          codec context
+         * @param[out] frame          AVFrame for output
+         * @param[out] got_frame_ptr  decoder sets to 0 or 1 to indicate that
+         *                            a non-empty frame was returned in frame.
+         * @param[in]  avpkt          AVPacket containing the data to be decoded
+         * @return amount of bytes read from the packet on success,
+         *         negative error code on failure
+         */
+        int (*decode)(struct AVCodecContext *avctx, struct AVFrame *frame,
+                      int *got_frame_ptr, struct AVPacket *avpkt);
+        /**
+         * Decode subtitle data to an AVSubtitle.
+         * cb is in this state if cb_type is FF_CODEC_CB_TYPE_DECODE_SUB.
+         *
+         * Apart from that this is like the decode callback.
+         */
+        int (*decode_sub)(struct AVCodecContext *avctx, struct AVSubtitle *sub,
+                          int *got_frame_ptr, const struct AVPacket *avpkt);
+        /**
+         * Decode API with decoupled packet/frame dataflow.
+         * cb is in this state if cb_type is FF_CODEC_CB_TYPE_RECEIVE_FRAME.
+         *
+         * This function is called to get one output frame. It should call
+         * ff_decode_get_packet() to obtain input data.
+         */
+        int (*receive_frame)(struct AVCodecContext *avctx, struct AVFrame *frame);
+        /**
+         * Encode data to an AVPacket.
+         * cb is in this state if cb_type is FF_CODEC_CB_TYPE_ENCODE
+         *
+         * @param      avctx          codec context
+         * @param[out] avpkt          output AVPacket
+         * @param[in]  frame          AVFrame containing the input to be encoded
+         * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
+         *                            non-empty packet was returned in avpkt.
+         * @return 0 on success, negative error code on failure
+         */
+        int (*encode)(struct AVCodecContext *avctx, struct AVPacket *avpkt,
+                      const struct AVFrame *frame, int *got_packet_ptr);
+        /**
+         * Encode subtitles to a raw buffer.
+         * cb is in this state if cb_type is FF_CODEC_CB_TYPE_ENCODE_SUB.
+         */
+        int (*encode_sub)(struct AVCodecContext *avctx, uint8_t *buf,
+                          int buf_size, const struct AVSubtitle *sub);
+        /**
+         * Encode API with decoupled frame/packet dataflow.
+         * cb is in this state if cb_type is FF_CODEC_CB_TYPE_RECEIVE_PACKET.
+         *
+         * This function is called to get one output packet.
+         * It should call ff_encode_get_frame() to obtain input data.
+         */
+        int (*receive_packet)(struct AVCodecContext *avctx, struct AVPacket *avpkt);
+    } cb;
+
+    int (*close)(struct AVCodecContext *);
+
+    /**
+     * Flush buffers.
+     * Will be called when seeking
+     */
+    void (*flush)(struct AVCodecContext *);
+
+    /**
+     * Decoding only, a comma-separated list of bitstream filters to apply to
+     * packets before decoding.
+     */
+    const char *bsfs;
+
+    /**
+     * Array of pointers to hardware configurations supported by the codec,
+     * or NULL if no hardware supported.  The array is terminated by a NULL
+     * pointer.
+     *
+     * The user can only access this field via avcodec_get_hw_config().
+     */
+    const struct AVCodecHWConfigInternal *const *hw_configs;
+
+    /**
+     * List of supported codec_tags, terminated by FF_CODEC_TAGS_END.
+     */
+    const uint32_t *codec_tags;
+} FFCodec;
+
+#if CONFIG_SMALL
+#define CODEC_LONG_NAME(str) .p.long_name = NULL
+#else
+#define CODEC_LONG_NAME(str) .p.long_name = str
+#endif
+
+#if HAVE_THREADS
+#define UPDATE_THREAD_CONTEXT(func) \
+        .update_thread_context          = (func)
+#define UPDATE_THREAD_CONTEXT_FOR_USER(func) \
+        .update_thread_context_for_user = (func)
+#else
+#define UPDATE_THREAD_CONTEXT(func) \
+        .update_thread_context          = NULL
+#define UPDATE_THREAD_CONTEXT_FOR_USER(func) \
+        .update_thread_context_for_user = NULL
+#endif
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+#define CODEC_OLD_CHANNEL_LAYOUTS(...) CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(((const uint64_t[]) { __VA_ARGS__, 0 }))
+#if defined(__clang__)
+#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array) \
+        FF_DISABLE_DEPRECATION_WARNINGS \
+        .p.channel_layouts = (array), \
+        FF_ENABLE_DEPRECATION_WARNINGS
+#else
+#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array) .p.channel_layouts = (array),
+#endif
+#else
+/* This is only provided to allow to test disabling FF_API_OLD_CHANNEL_LAYOUT
+ * without removing all the FF_API_OLD_CHANNEL_LAYOUT codeblocks.
+ * It is of course still expected to be removed when FF_API_OLD_CHANNEL_LAYOUT
+ * will be finally removed (along with all usages of these macros). */
+#define CODEC_OLD_CHANNEL_LAYOUTS(...)
+#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array)
+#endif
+
+#define FF_CODEC_DECODE_CB(func)                          \
+    .cb_type           = FF_CODEC_CB_TYPE_DECODE,         \
+    .cb.decode         = (func)
+#define FF_CODEC_DECODE_SUB_CB(func)                      \
+    .cb_type           = FF_CODEC_CB_TYPE_DECODE_SUB,     \
+    .cb.decode_sub     = (func)
+#define FF_CODEC_RECEIVE_FRAME_CB(func)                   \
+    .cb_type           = FF_CODEC_CB_TYPE_RECEIVE_FRAME,  \
+    .cb.receive_frame  = (func)
+#define FF_CODEC_ENCODE_CB(func)                          \
+    .cb_type           = FF_CODEC_CB_TYPE_ENCODE,         \
+    .cb.encode         = (func)
+#define FF_CODEC_ENCODE_SUB_CB(func)                      \
+    .cb_type           = FF_CODEC_CB_TYPE_ENCODE_SUB,     \
+    .cb.encode_sub     = (func)
+#define FF_CODEC_RECEIVE_PACKET_CB(func)                  \
+    .cb_type           = FF_CODEC_CB_TYPE_RECEIVE_PACKET, \
+    .cb.receive_packet = (func)
+
+static av_always_inline const FFCodec *ffcodec(const AVCodec *codec)
+{
+    return (const FFCodec*)codec;
+}
+
+#endif /* AVCODEC_CODEC_INTERNAL_H */
diff -Naur a/media/ffvpx/libavcodec/codec_list.c b/media/ffvpx/libavcodec/codec_list.c
--- a/media/ffvpx/libavcodec/codec_list.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec_list.c	2023-04-06 12:49:45.617610966 +0200
@@ -1,4 +1,4 @@
-static const AVCodec * const codec_list[] = {
+static const FFCodec * const codec_list[] = {
 #if CONFIG_VP8_DECODER
     &ff_vp8_decoder,
 #endif
diff -Naur a/media/ffvpx/libavcodec/codec_par.c b/media/ffvpx/libavcodec/codec_par.c
--- a/media/ffvpx/libavcodec/codec_par.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec_par.c	2023-04-06 12:49:40.252394850 +0200
@@ -31,12 +31,14 @@
 static void codec_parameters_reset(AVCodecParameters *par)
 {
     av_freep(&par->extradata);
+    av_channel_layout_uninit(&par->ch_layout);
 
     memset(par, 0, sizeof(*par));
 
     par->codec_type          = AVMEDIA_TYPE_UNKNOWN;
     par->codec_id            = AV_CODEC_ID_NONE;
     par->format              = -1;
+    par->ch_layout.order     = AV_CHANNEL_ORDER_UNSPEC;
     par->field_order         = AV_FIELD_UNKNOWN;
     par->color_range         = AVCOL_RANGE_UNSPECIFIED;
     par->color_primaries     = AVCOL_PRI_UNSPECIFIED;
@@ -71,9 +73,12 @@
 
 int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src)
 {
+    int ret;
+
     codec_parameters_reset(dst);
     memcpy(dst, src, sizeof(*dst));
 
+    dst->ch_layout      = (AVChannelLayout){0};
     dst->extradata      = NULL;
     dst->extradata_size = 0;
     if (src->extradata) {
@@ -84,12 +89,18 @@
         dst->extradata_size = src->extradata_size;
     }
 
+    ret = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
+    if (ret < 0)
+        return ret;
+
     return 0;
 }
 
 int avcodec_parameters_from_context(AVCodecParameters *par,
                                     const AVCodecContext *codec)
 {
+    int ret;
+
     codec_parameters_reset(par);
 
     par->codec_type = codec->codec_type;
@@ -118,8 +129,32 @@
         break;
     case AVMEDIA_TYPE_AUDIO:
         par->format           = codec->sample_fmt;
-        par->channel_layout   = codec->channel_layout;
-        par->channels         = codec->channels;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        // if the old/new fields are set inconsistently, prefer the old ones
+        if ((codec->channels && codec->channels != codec->ch_layout.nb_channels) ||
+            (codec->channel_layout && (codec->ch_layout.order != AV_CHANNEL_ORDER_NATIVE ||
+                                       codec->ch_layout.u.mask != codec->channel_layout))) {
+            if (codec->channel_layout)
+                av_channel_layout_from_mask(&par->ch_layout, codec->channel_layout);
+            else {
+                par->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+                par->ch_layout.nb_channels = codec->channels;
+            }
+FF_ENABLE_DEPRECATION_WARNINGS
+        } else {
+#endif
+        ret = av_channel_layout_copy(&par->ch_layout, &codec->ch_layout);
+        if (ret < 0)
+            return ret;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        }
+        par->channel_layout  = par->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
+                               par->ch_layout.u.mask : 0;
+        par->channels        = par->ch_layout.nb_channels;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
         par->sample_rate      = codec->sample_rate;
         par->block_align      = codec->block_align;
         par->frame_size       = codec->frame_size;
@@ -147,6 +182,8 @@
 int avcodec_parameters_to_context(AVCodecContext *codec,
                                   const AVCodecParameters *par)
 {
+    int ret;
+
     codec->codec_type = par->codec_type;
     codec->codec_id   = par->codec_id;
     codec->codec_tag  = par->codec_tag;
@@ -173,8 +210,32 @@
         break;
     case AVMEDIA_TYPE_AUDIO:
         codec->sample_fmt       = par->format;
-        codec->channel_layout   = par->channel_layout;
-        codec->channels         = par->channels;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        // if the old/new fields are set inconsistently, prefer the old ones
+        if ((par->channels && par->channels != par->ch_layout.nb_channels) ||
+            (par->channel_layout && (par->ch_layout.order != AV_CHANNEL_ORDER_NATIVE ||
+                                     par->ch_layout.u.mask != par->channel_layout))) {
+            if (par->channel_layout)
+                av_channel_layout_from_mask(&codec->ch_layout, par->channel_layout);
+            else {
+                codec->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+                codec->ch_layout.nb_channels = par->channels;
+            }
+FF_ENABLE_DEPRECATION_WARNINGS
+        } else {
+#endif
+        ret = av_channel_layout_copy(&codec->ch_layout, &par->ch_layout);
+        if (ret < 0)
+            return ret;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        }
+        codec->channel_layout = codec->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
+                                codec->ch_layout.u.mask : 0;
+        codec->channels       = codec->ch_layout.nb_channels;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
         codec->sample_rate      = par->sample_rate;
         codec->block_align      = par->block_align;
         codec->frame_size       = par->frame_size;
diff -Naur a/media/ffvpx/libavcodec/codec_par.h b/media/ffvpx/libavcodec/codec_par.h
--- a/media/ffvpx/libavcodec/codec_par.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/codec_par.h	2023-04-06 12:50:06.971471053 +0200
@@ -24,6 +24,7 @@
 #include <stdint.h>
 
 #include "libavutil/avutil.h"
+#include "libavutil/channel_layout.h"
 #include "libavutil/rational.h"
 #include "libavutil/pixfmt.h"
 
@@ -31,15 +32,16 @@
 
 /**
  * @addtogroup lavc_core
+ * @{
  */
 
 enum AVFieldOrder {
     AV_FIELD_UNKNOWN,
     AV_FIELD_PROGRESSIVE,
-    AV_FIELD_TT,          //< Top coded_first, top displayed first
-    AV_FIELD_BB,          //< Bottom coded first, bottom displayed first
-    AV_FIELD_TB,          //< Top coded first, bottom displayed first
-    AV_FIELD_BT,          //< Bottom coded first, top displayed first
+    AV_FIELD_TT,          ///< Top coded_first, top displayed first
+    AV_FIELD_BB,          ///< Bottom coded first, bottom displayed first
+    AV_FIELD_TB,          ///< Top coded first, bottom displayed first
+    AV_FIELD_BT,          ///< Bottom coded first, top displayed first
 };
 
 /**
@@ -154,16 +156,22 @@
      */
     int video_delay;
 
+#if FF_API_OLD_CHANNEL_LAYOUT
     /**
      * Audio only. The channel layout bitmask. May be 0 if the channel layout is
      * unknown or unspecified, otherwise the number of bits set must be equal to
      * the channels field.
+     * @deprecated use ch_layout
      */
+    attribute_deprecated
     uint64_t channel_layout;
     /**
      * Audio only. The number of audio channels.
+     * @deprecated use ch_layout.nb_channels
      */
+    attribute_deprecated
     int      channels;
+#endif
     /**
      * Audio only. The number of audio samples per second.
      */
@@ -198,6 +206,11 @@
      * Audio only. Number of samples to skip after a discontinuity.
      */
     int seek_preroll;
+
+    /**
+     * Audio only. The channel layout and number of channels.
+     */
+    AVChannelLayout ch_layout;
 } AVCodecParameters;
 
 /**
diff -Naur a/media/ffvpx/libavcodec/dct.c b/media/ffvpx/libavcodec/dct.c
--- a/media/ffvpx/libavcodec/dct.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/dct.c	2023-04-06 12:49:40.252394850 +0200
@@ -30,7 +30,9 @@
 #include <math.h>
 #include <string.h>
 
+#include "libavutil/error.h"
 #include "libavutil/mathematics.h"
+#include "libavutil/mem.h"
 #include "dct.h"
 #include "dct32.h"
 
@@ -212,8 +214,9 @@
     }
 
     s->dct32 = ff_dct32_float;
-    if (ARCH_X86)
-        ff_dct_init_x86(s);
+#if ARCH_X86
+    ff_dct_init_x86(s);
+#endif
 
     return 0;
 }
diff -Naur a/media/ffvpx/libavcodec/decode.c b/media/ffvpx/libavcodec/decode.c
--- a/media/ffvpx/libavcodec/decode.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/decode.c	2023-04-06 12:50:24.491176503 +0200
@@ -30,7 +30,9 @@
 #include "libavutil/avassert.h"
 #include "libavutil/avstring.h"
 #include "libavutil/bprint.h"
+#include "libavutil/channel_layout.h"
 #include "libavutil/common.h"
+#include "libavutil/fifo.h"
 #include "libavutil/frame.h"
 #include "libavutil/hwcontext.h"
 #include "libavutil/imgutils.h"
@@ -40,34 +42,17 @@
 
 #include "avcodec.h"
 #include "bytestream.h"
+#include "bsf.h"
+#include "codec_internal.h"
 #include "decode.h"
 #include "hwconfig.h"
 #include "internal.h"
 #include "thread.h"
 
-typedef struct FramePool {
-    /**
-     * Pools for each data plane. For audio all the planes have the same size,
-     * so only pools[0] is used.
-     */
-    AVBufferPool *pools[4];
-
-    /*
-     * Pool parameters
-     */
-    int format;
-    int width, height;
-    int stride_align[AV_NUM_DATA_POINTERS];
-    int linesize[4];
-    int planes;
-    int channels;
-    int samples;
-} FramePool;
-
 static int apply_param_change(AVCodecContext *avctx, const AVPacket *avpkt)
 {
     int ret;
-    buffer_size_t size;
+    size_t size;
     const uint8_t *data;
     uint32_t flags;
     int64_t val;
@@ -89,6 +74,8 @@
     flags = bytestream_get_le32(&data);
     size -= 4;
 
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {
         if (size < 4)
             goto fail;
@@ -107,6 +94,8 @@
         avctx->channel_layout = bytestream_get_le64(&data);
         size -= 8;
     }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {
         if (size < 4)
             goto fail;
@@ -143,59 +132,31 @@
     return 0;
 }
 
-#define IS_EMPTY(pkt) (!(pkt)->data)
-
-static int copy_packet_props(AVPacket *dst, const AVPacket *src)
-{
-    int ret = av_packet_copy_props(dst, src);
-    if (ret < 0)
-        return ret;
-
-    dst->size = src->size; // HACK: Needed for ff_decode_frame_props().
-    dst->data = (void*)1;  // HACK: Needed for IS_EMPTY().
-
-    return 0;
-}
-
 static int extract_packet_props(AVCodecInternal *avci, const AVPacket *pkt)
 {
-    AVPacket tmp = { 0 };
     int ret = 0;
 
-    if (IS_EMPTY(avci->last_pkt_props)) {
-        if (av_fifo_size(avci->pkt_props) >= sizeof(*pkt)) {
-            av_fifo_generic_read(avci->pkt_props, avci->last_pkt_props,
-                                 sizeof(*avci->last_pkt_props), NULL);
-        } else
-            return copy_packet_props(avci->last_pkt_props, pkt);
-    }
-
-    if (av_fifo_space(avci->pkt_props) < sizeof(*pkt)) {
-        ret = av_fifo_grow(avci->pkt_props, sizeof(*pkt));
-        if (ret < 0)
-            return ret;
+    av_packet_unref(avci->last_pkt_props);
+    if (pkt) {
+        ret = av_packet_copy_props(avci->last_pkt_props, pkt);
+        if (!ret)
+            avci->last_pkt_props->opaque = (void *)(intptr_t)pkt->size; // Needed for ff_decode_frame_props().
     }
-
-    ret = copy_packet_props(&tmp, pkt);
-    if (ret < 0)
-        return ret;
-
-    av_fifo_generic_write(avci->pkt_props, &tmp, sizeof(tmp), NULL);
-
-    return 0;
+    return ret;
 }
 
 static int decode_bsfs_init(AVCodecContext *avctx)
 {
     AVCodecInternal *avci = avctx->internal;
+    const FFCodec *const codec = ffcodec(avctx->codec);
     int ret;
 
     if (avci->bsf)
         return 0;
 
-    ret = av_bsf_list_parse_str(avctx->codec->bsfs, &avci->bsf);
+    ret = av_bsf_list_parse_str(codec->bsfs, &avci->bsf);
     if (ret < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Error parsing decoder bitstream filters '%s': %s\n", avctx->codec->bsfs, av_err2str(ret));
+        av_log(avctx, AV_LOG_ERROR, "Error parsing decoder bitstream filters '%s': %s\n", codec->bsfs, av_err2str(ret));
         if (ret != AVERROR(ENOMEM))
             ret = AVERROR_BUG;
         goto fail;
@@ -233,7 +194,7 @@
     if (ret < 0)
         return ret;
 
-    if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
+    if (!(ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
         ret = extract_packet_props(avctx->internal, pkt);
         if (ret < 0)
             goto finish;
@@ -243,11 +204,6 @@
     if (ret < 0)
         goto finish;
 
-#if FF_API_OLD_ENCDEC
-    if (avctx->codec->receive_frame)
-        avci->compat_decode_consumed += pkt->size;
-#endif
-
     return 0;
 finish:
     av_packet_unref(pkt);
@@ -299,8 +255,8 @@
 static inline int decode_simple_internal(AVCodecContext *avctx, AVFrame *frame, int64_t *discarded_samples)
 {
     AVCodecInternal   *avci = avctx->internal;
-    DecodeSimpleContext *ds = &avci->ds;
-    AVPacket           *pkt = ds->in_pkt;
+    AVPacket     *const pkt = avci->in_pkt;
+    const FFCodec *const codec = ffcodec(avctx->codec);
     int got_frame, actual_got_frame;
     int ret;
 
@@ -326,9 +282,9 @@
     if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) {
         ret = ff_thread_decode_frame(avctx, frame, &got_frame, pkt);
     } else {
-        ret = avctx->codec->decode(avctx, frame, &got_frame, pkt);
+        ret = codec->cb.decode(avctx, frame, &got_frame, pkt);
 
-        if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_PKT_DTS))
+        if (!(codec->caps_internal & FF_CODEC_CAP_SETS_PKT_DTS))
             frame->pkt_dts = pkt->dts;
         if (avctx->codec->type == AVMEDIA_TYPE_VIDEO) {
             if(!avctx->has_b_frames)
@@ -351,7 +307,7 @@
             got_frame = 0;
     } else if (avctx->codec->type == AVMEDIA_TYPE_AUDIO) {
         uint8_t *side;
-        buffer_size_t side_size;
+        size_t side_size;
         uint32_t discard_padding = 0;
         uint8_t skip_reason = 0;
         uint8_t discard_reason = 0;
@@ -359,17 +315,30 @@
         if (ret >= 0 && got_frame) {
             if (frame->format == AV_SAMPLE_FMT_NONE)
                 frame->format = avctx->sample_fmt;
+            if (!frame->ch_layout.nb_channels) {
+                int ret2 = av_channel_layout_copy(&frame->ch_layout, &avctx->ch_layout);
+                if (ret2 < 0) {
+                    ret = ret2;
+                    got_frame = 0;
+                }
+            }
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
             if (!frame->channel_layout)
-                frame->channel_layout = avctx->channel_layout;
+                frame->channel_layout = avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
+                                        avctx->ch_layout.u.mask : 0;
             if (!frame->channels)
-                frame->channels = avctx->channels;
+                frame->channels = avctx->ch_layout.nb_channels;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
             if (!frame->sample_rate)
                 frame->sample_rate = avctx->sample_rate;
         }
 
         side= av_packet_get_side_data(avci->last_pkt_props, AV_PKT_DATA_SKIP_SAMPLES, &side_size);
         if(side && side_size>=10) {
-            avci->skip_samples = AV_RL32(side) * avci->skip_samples_multiplier;
+            avci->skip_samples = AV_RL32(side);
+            avci->skip_samples = FFMAX(0, avci->skip_samples);
             discard_padding = AV_RL32(side + 4);
             av_log(avctx, AV_LOG_DEBUG, "skip %d / discard %d samples due to side data\n",
                    avci->skip_samples, (int)discard_padding);
@@ -394,23 +363,17 @@
                        avci->skip_samples);
             } else {
                 av_samples_copy(frame->extended_data, frame->extended_data, 0, avci->skip_samples,
-                                frame->nb_samples - avci->skip_samples, avctx->channels, frame->format);
+                                frame->nb_samples - avci->skip_samples, avctx->ch_layout.nb_channels, frame->format);
                 if(avctx->pkt_timebase.num && avctx->sample_rate) {
                     int64_t diff_ts = av_rescale_q(avci->skip_samples,
                                                    (AVRational){1, avctx->sample_rate},
                                                    avctx->pkt_timebase);
                     if(frame->pts!=AV_NOPTS_VALUE)
                         frame->pts += diff_ts;
-#if FF_API_PKT_PTS
-FF_DISABLE_DEPRECATION_WARNINGS
-                    if(frame->pkt_pts!=AV_NOPTS_VALUE)
-                        frame->pkt_pts += diff_ts;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
                     if(frame->pkt_dts!=AV_NOPTS_VALUE)
                         frame->pkt_dts += diff_ts;
-                    if (frame->pkt_duration >= diff_ts)
-                        frame->pkt_duration -= diff_ts;
+                    if (frame->duration >= diff_ts)
+                        frame->duration -= diff_ts;
                 } else {
                     av_log(avctx, AV_LOG_WARNING, "Could not update timestamps for skipped samples.\n");
                 }
@@ -432,7 +395,7 @@
                     int64_t diff_ts = av_rescale_q(frame->nb_samples - discard_padding,
                                                    (AVRational){1, avctx->sample_rate},
                                                    avctx->pkt_timebase);
-                    frame->pkt_duration = diff_ts;
+                    frame->duration = diff_ts;
                 } else {
                     av_log(avctx, AV_LOG_WARNING, "Could not update timestamps for discarded samples.\n");
                 }
@@ -464,14 +427,9 @@
     if (!got_frame)
         av_frame_unref(frame);
 
-    if (ret >= 0 && avctx->codec->type == AVMEDIA_TYPE_VIDEO && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))
+    if (ret >= 0 && avctx->codec->type == AVMEDIA_TYPE_VIDEO)
         ret = pkt->size;
 
-#if FF_API_AVCTX_TIMEBASE
-    if (avctx->framerate.num > 0 && avctx->framerate.den > 0)
-        avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
-#endif
-
     /* do not stop draining when actual_got_frame != 0 or ret < 0 */
     /* got_frame == 0 but actual_got_frame != 0 when frame is discarded */
     if (avci->draining && !actual_got_frame) {
@@ -492,13 +450,8 @@
         }
     }
 
-#if FF_API_OLD_ENCDEC
-    avci->compat_decode_consumed += ret;
-#endif
-
     if (ret >= pkt->size || ret < 0) {
         av_packet_unref(pkt);
-        av_packet_unref(avci->last_pkt_props);
     } else {
         int consumed = ret;
 
@@ -506,8 +459,9 @@
         pkt->size                -= consumed;
         pkt->pts                  = AV_NOPTS_VALUE;
         pkt->dts                  = AV_NOPTS_VALUE;
-        if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
-            avci->last_pkt_props->size -= consumed; // See extract_packet_props() comment.
+        if (!(codec->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
+            // See extract_packet_props() comment.
+            avci->last_pkt_props->opaque = (void *)((intptr_t)avci->last_pkt_props->opaque - consumed);
             avci->last_pkt_props->pts = AV_NOPTS_VALUE;
             avci->last_pkt_props->dts = AV_NOPTS_VALUE;
         }
@@ -519,6 +473,54 @@
     return ret < 0 ? ret : 0;
 }
 
+#if CONFIG_LCMS2
+static int detect_colorspace(AVCodecContext *avctx, AVFrame *frame)
+{
+    AVCodecInternal *avci = avctx->internal;
+    enum AVColorTransferCharacteristic trc;
+    AVColorPrimariesDesc coeffs;
+    enum AVColorPrimaries prim;
+    cmsHPROFILE profile;
+    AVFrameSideData *sd;
+    int ret;
+    if (!(avctx->flags2 & AV_CODEC_FLAG2_ICC_PROFILES))
+        return 0;
+
+    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_ICC_PROFILE);
+    if (!sd || !sd->size)
+        return 0;
+
+    if (!avci->icc.avctx) {
+        ret = ff_icc_context_init(&avci->icc, avctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    profile = cmsOpenProfileFromMemTHR(avci->icc.ctx, sd->data, sd->size);
+    if (!profile)
+        return AVERROR_INVALIDDATA;
+
+    ret = ff_icc_profile_read_primaries(&avci->icc, profile, &coeffs);
+    if (!ret)
+        ret = ff_icc_profile_detect_transfer(&avci->icc, profile, &trc);
+    cmsCloseProfile(profile);
+    if (ret < 0)
+        return ret;
+
+    prim = av_csp_primaries_id_from_desc(&coeffs);
+    if (prim != AVCOL_PRI_UNSPECIFIED)
+        frame->color_primaries = prim;
+    if (trc != AVCOL_TRC_UNSPECIFIED)
+        frame->color_trc = trc;
+    return 0;
+}
+#else /* !CONFIG_LCMS2 */
+static int detect_colorspace(av_unused AVCodecContext *c, av_unused AVFrame *f)
+{
+    return 0;
+}
+#endif
+
 static int decode_simple_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     int ret;
@@ -538,30 +540,37 @@
 static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
 {
     AVCodecInternal *avci = avctx->internal;
-    int ret;
+    const FFCodec *const codec = ffcodec(avctx->codec);
+    int ret, ok;
 
     av_assert0(!frame->buf[0]);
 
-    if (avctx->codec->receive_frame) {
-        ret = avctx->codec->receive_frame(avctx, frame);
-        if (ret != AVERROR(EAGAIN))
-            av_packet_unref(avci->last_pkt_props);
+    if (codec->cb_type == FF_CODEC_CB_TYPE_RECEIVE_FRAME) {
+        ret = codec->cb.receive_frame(avctx, frame);
     } else
         ret = decode_simple_receive_frame(avctx, frame);
 
     if (ret == AVERROR_EOF)
         avci->draining_done = 1;
 
-    if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS) &&
-        IS_EMPTY(avci->last_pkt_props) && av_fifo_size(avci->pkt_props) >= sizeof(*avci->last_pkt_props))
-        av_fifo_generic_read(avci->pkt_props,
-                             avci->last_pkt_props, sizeof(*avci->last_pkt_props), NULL);
+    /* preserve ret */
+    ok = detect_colorspace(avctx, frame);
+    if (ok < 0) {
+        av_frame_unref(frame);
+        return ok;
+    }
 
     if (!ret) {
         frame->best_effort_timestamp = guess_correct_pts(avctx,
                                                          frame->pts,
                                                          frame->pkt_dts);
 
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+        frame->pkt_duration = frame->duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
         /* the only case where decode data is not set should be decoders
          * that do not call ff_get_buffer() */
         av_assert0((frame->private_ref && frame->private_ref->size == sizeof(FrameDecodeData)) ||
@@ -649,13 +658,38 @@
                                           AV_FRAME_CROP_UNALIGNED : 0);
 }
 
-int attribute_align_arg avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+// make sure frames returned to the caller are valid
+static int frame_validate(AVCodecContext *avctx, AVFrame *frame)
+{
+    if (!frame->buf[0] || frame->format < 0)
+        goto fail;
+
+    switch (avctx->codec_type) {
+    case AVMEDIA_TYPE_VIDEO:
+        if (frame->width <= 0 || frame->height <= 0)
+            goto fail;
+        break;
+    case AVMEDIA_TYPE_AUDIO:
+        if (!av_channel_layout_check(&frame->ch_layout) ||
+            frame->sample_rate <= 0)
+            goto fail;
+
+        break;
+    default: av_assert0(0);
+    }
+
+    return 0;
+fail:
+    av_log(avctx, AV_LOG_ERROR, "An invalid frame was output by a decoder. "
+           "This is a bug, please report it.\n");
+    return AVERROR_BUG;
+}
+
+int ff_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     AVCodecInternal *avci = avctx->internal;
     int ret, changed;
 
-    av_frame_unref(frame);
-
     if (!avcodec_is_open(avctx) || !av_codec_is_decoder(avctx->codec))
         return AVERROR(EINVAL);
 
@@ -667,19 +701,26 @@
             return ret;
     }
 
+    ret = frame_validate(avctx, frame);
+    if (ret < 0)
+        goto fail;
+
     if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
         ret = apply_cropping(avctx, frame);
-        if (ret < 0) {
-            av_frame_unref(frame);
-            return ret;
-        }
+        if (ret < 0)
+            goto fail;
     }
 
-    avctx->frame_number++;
+    avctx->frame_num++;
+#if FF_API_AVCTX_FRAME_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->frame_number = avctx->frame_num;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
 
     if (avctx->flags & AV_CODEC_FLAG_DROPCHANGED) {
 
-        if (avctx->frame_number == 1) {
+        if (avctx->frame_num == 1) {
             avci->initial_format = frame->format;
             switch(avctx->codec_type) {
             case AVMEDIA_TYPE_VIDEO:
@@ -689,13 +730,14 @@
             case AVMEDIA_TYPE_AUDIO:
                 avci->initial_sample_rate = frame->sample_rate ? frame->sample_rate :
                                                                  avctx->sample_rate;
-                avci->initial_channels       = frame->channels;
-                avci->initial_channel_layout = frame->channel_layout;
+                ret = av_channel_layout_copy(&avci->initial_ch_layout, &frame->ch_layout);
+                if (ret < 0)
+                    goto fail;
                 break;
             }
         }
 
-        if (avctx->frame_number > 1) {
+        if (avctx->frame_num > 1) {
             changed = avci->initial_format != frame->format;
 
             switch(avctx->codec_type) {
@@ -706,171 +748,27 @@
             case AVMEDIA_TYPE_AUDIO:
                 changed |= avci->initial_sample_rate    != frame->sample_rate ||
                            avci->initial_sample_rate    != avctx->sample_rate ||
-                           avci->initial_channels       != frame->channels ||
-                           avci->initial_channel_layout != frame->channel_layout;
+                           av_channel_layout_compare(&avci->initial_ch_layout, &frame->ch_layout);
                 break;
             }
 
             if (changed) {
                 avci->changed_frames_dropped++;
-                av_log(avctx, AV_LOG_INFO, "dropped changed frame #%d pts %"PRId64
+                av_log(avctx, AV_LOG_INFO, "dropped changed frame #%"PRId64" pts %"PRId64
                                             " drop count: %d \n",
-                                            avctx->frame_number, frame->pts,
+                                            avctx->frame_num, frame->pts,
                                             avci->changed_frames_dropped);
-                av_frame_unref(frame);
-                return AVERROR_INPUT_CHANGED;
+                ret = AVERROR_INPUT_CHANGED;
+                goto fail;
             }
         }
     }
     return 0;
-}
-
-#if FF_API_OLD_ENCDEC
-FF_DISABLE_DEPRECATION_WARNINGS
-static int unrefcount_frame(AVCodecInternal *avci, AVFrame *frame)
-{
-    int ret;
-
-    /* move the original frame to our backup */
-    av_frame_unref(avci->to_free);
-    av_frame_move_ref(avci->to_free, frame);
-
-    /* now copy everything except the AVBufferRefs back
-     * note that we make a COPY of the side data, so calling av_frame_free() on
-     * the caller's frame will work properly */
-    ret = av_frame_copy_props(frame, avci->to_free);
-    if (ret < 0)
-        return ret;
-
-    memcpy(frame->data,     avci->to_free->data,     sizeof(frame->data));
-    memcpy(frame->linesize, avci->to_free->linesize, sizeof(frame->linesize));
-    if (avci->to_free->extended_data != avci->to_free->data) {
-        int planes = avci->to_free->channels;
-        int size   = planes * sizeof(*frame->extended_data);
-
-        if (!size) {
-            av_frame_unref(frame);
-            return AVERROR_BUG;
-        }
-
-        frame->extended_data = av_malloc(size);
-        if (!frame->extended_data) {
-            av_frame_unref(frame);
-            return AVERROR(ENOMEM);
-        }
-        memcpy(frame->extended_data, avci->to_free->extended_data,
-               size);
-    } else
-        frame->extended_data = frame->data;
-
-    frame->format         = avci->to_free->format;
-    frame->width          = avci->to_free->width;
-    frame->height         = avci->to_free->height;
-    frame->channel_layout = avci->to_free->channel_layout;
-    frame->nb_samples     = avci->to_free->nb_samples;
-    frame->channels       = avci->to_free->channels;
-
-    return 0;
-}
-
-static int compat_decode(AVCodecContext *avctx, AVFrame *frame,
-                         int *got_frame, const AVPacket *pkt)
-{
-    AVCodecInternal *avci = avctx->internal;
-    int ret = 0;
-
-    av_assert0(avci->compat_decode_consumed == 0);
-
-    if (avci->draining_done && pkt && pkt->size != 0) {
-        av_log(avctx, AV_LOG_WARNING, "Got unexpected packet after EOF\n");
-        avcodec_flush_buffers(avctx);
-    }
-
-    *got_frame = 0;
-
-    if (avci->compat_decode_partial_size > 0 &&
-        avci->compat_decode_partial_size != pkt->size) {
-        av_log(avctx, AV_LOG_ERROR,
-               "Got unexpected packet size after a partial decode\n");
-        ret = AVERROR(EINVAL);
-        goto finish;
-    }
-
-    if (!avci->compat_decode_partial_size) {
-        ret = avcodec_send_packet(avctx, pkt);
-        if (ret == AVERROR_EOF)
-            ret = 0;
-        else if (ret == AVERROR(EAGAIN)) {
-            /* we fully drain all the output in each decode call, so this should not
-             * ever happen */
-            ret = AVERROR_BUG;
-            goto finish;
-        } else if (ret < 0)
-            goto finish;
-    }
-
-    while (ret >= 0) {
-        ret = avcodec_receive_frame(avctx, frame);
-        if (ret < 0) {
-            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
-                ret = 0;
-            goto finish;
-        }
-
-        if (frame != avci->compat_decode_frame) {
-            if (!avctx->refcounted_frames) {
-                ret = unrefcount_frame(avci, frame);
-                if (ret < 0)
-                    goto finish;
-            }
-
-            *got_frame = 1;
-            frame = avci->compat_decode_frame;
-        } else {
-            if (!avci->compat_decode_warned) {
-                av_log(avctx, AV_LOG_WARNING, "The deprecated avcodec_decode_* "
-                       "API cannot return all the frames for this decoder. "
-                       "Some frames will be dropped. Update your code to the "
-                       "new decoding API to fix this.\n");
-                avci->compat_decode_warned = 1;
-            }
-        }
-
-        if (avci->draining || (!avctx->codec->bsfs && avci->compat_decode_consumed < pkt->size))
-            break;
-    }
-
-finish:
-    if (ret == 0) {
-        /* if there are any bsfs then assume full packet is always consumed */
-        if (avctx->codec->bsfs)
-            ret = pkt->size;
-        else
-            ret = FFMIN(avci->compat_decode_consumed, pkt->size);
-    }
-    avci->compat_decode_consumed = 0;
-    avci->compat_decode_partial_size = (ret >= 0) ? pkt->size - ret : 0;
-
+fail:
+    av_frame_unref(frame);
     return ret;
 }
 
-int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
-                                              int *got_picture_ptr,
-                                              const AVPacket *avpkt)
-{
-    return compat_decode(avctx, picture, got_picture_ptr, avpkt);
-}
-
-int attribute_align_arg avcodec_decode_audio4(AVCodecContext *avctx,
-                                              AVFrame *frame,
-                                              int *got_frame_ptr,
-                                              const AVPacket *avpkt)
-{
-    return compat_decode(avctx, frame, got_frame_ptr, avpkt);
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 static void get_subtitle_defaults(AVSubtitle *sub)
 {
     memset(sub, 0, sizeof(*sub));
@@ -878,8 +776,8 @@
 }
 
 #define UTF8_MAX_BYTES 4 /* 5 and 6 bytes sequences should not be used */
-static int recode_subtitle(AVCodecContext *avctx, AVPacket **outpkt,
-                           AVPacket *inpkt, AVPacket *buf_pkt)
+static int recode_subtitle(AVCodecContext *avctx, const AVPacket **outpkt,
+                           const AVPacket *inpkt, AVPacket *buf_pkt)
 {
 #if CONFIG_ICONV
     iconv_t cd = (iconv_t)-1;
@@ -958,82 +856,8 @@
     return 1;
 }
 
-#if FF_API_ASS_TIMING
-static void insert_ts(AVBPrint *buf, int ts)
-{
-    if (ts == -1) {
-        av_bprintf(buf, "9:59:59.99,");
-    } else {
-        int h, m, s;
-
-        h = ts/360000;  ts -= 360000*h;
-        m = ts/  6000;  ts -=   6000*m;
-        s = ts/   100;  ts -=    100*s;
-        av_bprintf(buf, "%d:%02d:%02d.%02d,", h, m, s, ts);
-    }
-}
-
-static int convert_sub_to_old_ass_form(AVSubtitle *sub, const AVPacket *pkt, AVRational tb)
-{
-    int i;
-    AVBPrint buf;
-
-    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
-
-    for (i = 0; i < sub->num_rects; i++) {
-        char *final_dialog;
-        const char *dialog;
-        AVSubtitleRect *rect = sub->rects[i];
-        int ts_start, ts_duration = -1;
-        long int layer;
-
-        if (rect->type != SUBTITLE_ASS || !strncmp(rect->ass, "Dialogue: ", 10))
-            continue;
-
-        av_bprint_clear(&buf);
-
-        /* skip ReadOrder */
-        dialog = strchr(rect->ass, ',');
-        if (!dialog)
-            continue;
-        dialog++;
-
-        /* extract Layer or Marked */
-        layer = strtol(dialog, (char**)&dialog, 10);
-        if (*dialog != ',')
-            continue;
-        dialog++;
-
-        /* rescale timing to ASS time base (ms) */
-        ts_start = av_rescale_q(pkt->pts, tb, av_make_q(1, 100));
-        if (pkt->duration != -1)
-            ts_duration = av_rescale_q(pkt->duration, tb, av_make_q(1, 100));
-        sub->end_display_time = FFMAX(sub->end_display_time, 10 * ts_duration);
-
-        /* construct ASS (standalone file form with timestamps) string */
-        av_bprintf(&buf, "Dialogue: %ld,", layer);
-        insert_ts(&buf, ts_start);
-        insert_ts(&buf, ts_duration == -1 ? -1 : ts_start + ts_duration);
-        av_bprintf(&buf, "%s\r\n", dialog);
-
-        final_dialog = av_strdup(buf.str);
-        if (!av_bprint_is_complete(&buf) || !final_dialog) {
-            av_freep(&final_dialog);
-            av_bprint_finalize(&buf, NULL);
-            return AVERROR(ENOMEM);
-        }
-        av_freep(&rect->ass);
-        rect->ass = final_dialog;
-    }
-
-    av_bprint_finalize(&buf, NULL);
-    return 0;
-}
-#endif
-
 int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
-                             int *got_sub_ptr,
-                             AVPacket *avpkt)
+                             int *got_sub_ptr, const AVPacket *avpkt)
 {
     int ret = 0;
 
@@ -1053,7 +877,7 @@
 
     if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size) {
         AVCodecInternal *avci = avctx->internal;
-        AVPacket *pkt;
+        const AVPacket *pkt;
 
         ret = recode_subtitle(avctx, &pkt, avpkt, avci->buffer_pkt);
         if (ret < 0)
@@ -1062,20 +886,15 @@
         if (avctx->pkt_timebase.num && avpkt->pts != AV_NOPTS_VALUE)
             sub->pts = av_rescale_q(avpkt->pts,
                                     avctx->pkt_timebase, AV_TIME_BASE_Q);
-        ret = avctx->codec->decode(avctx, sub, got_sub_ptr, pkt);
-        av_assert1((ret >= 0) >= !!*got_sub_ptr &&
-                   !!*got_sub_ptr >= !!sub->num_rects);
-
-#if FF_API_ASS_TIMING
-        if (avctx->sub_text_format == FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS
-            && *got_sub_ptr && sub->num_rects) {
-            const AVRational tb = avctx->pkt_timebase.num ? avctx->pkt_timebase
-                                  : avctx->time_base;
-            int err = convert_sub_to_old_ass_form(sub, avpkt, tb);
-            if (err < 0)
-                ret = err;
+        ret = ffcodec(avctx->codec)->cb.decode_sub(avctx, sub, got_sub_ptr, pkt);
+        if (pkt == avci->buffer_pkt) // did we recode?
+            av_packet_unref(avci->buffer_pkt);
+        if (ret < 0) {
+            *got_sub_ptr = 0;
+            avsubtitle_free(sub);
+            return ret;
         }
-#endif
+        av_assert1(!sub->num_rects || *got_sub_ptr);
 
         if (sub->num_rects && !sub->end_display_time && avpkt->duration &&
             avctx->pkt_timebase.num) {
@@ -1096,16 +915,18 @@
                        "Invalid UTF-8 in decoded subtitles text; "
                        "maybe missing -sub_charenc option\n");
                 avsubtitle_free(sub);
-                ret = AVERROR_INVALIDDATA;
-                break;
+                *got_sub_ptr = 0;
+                return AVERROR_INVALIDDATA;
             }
         }
 
         if (*got_sub_ptr)
-            avctx->frame_number++;
-
-        if (pkt == avci->buffer_pkt) // did we recode?
-            av_packet_unref(avci->buffer_pkt);
+            avctx->frame_num++;
+#if FF_API_AVCTX_FRAME_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
+        avctx->frame_number = avctx->frame_num;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     }
 
     return ret;
@@ -1120,11 +941,11 @@
 
     // If a device was supplied when the codec was opened, assume that the
     // user wants to use it.
-    if (avctx->hw_device_ctx && avctx->codec->hw_configs) {
+    if (avctx->hw_device_ctx && ffcodec(avctx->codec)->hw_configs) {
         AVHWDeviceContext *device_ctx =
             (AVHWDeviceContext*)avctx->hw_device_ctx->data;
         for (i = 0;; i++) {
-            config = &avctx->codec->hw_configs[i]->public;
+            config = &ffcodec(avctx->codec)->hw_configs[i]->public;
             if (!config)
                 break;
             if (!(config->methods &
@@ -1236,7 +1057,7 @@
     int i, ret;
 
     for (i = 0;; i++) {
-        hw_config = avctx->codec->hw_configs[i];
+        hw_config = ffcodec(avctx->codec)->hw_configs[i];
         if (!hw_config)
             return AVERROR(ENOENT);
         if (hw_config->public.pix_fmt == hw_pix_fmt)
@@ -1344,12 +1165,10 @@
         avctx->sw_pix_fmt = fmt[n - 1];
     }
 
-    choices = av_malloc_array(n + 1, sizeof(*choices));
+    choices = av_memdup(fmt, (n + 1) * sizeof(*choices));
     if (!choices)
         return AV_PIX_FMT_NONE;
 
-    memcpy(choices, fmt, (n + 1) * sizeof(*choices));
-
     for (;;) {
         // Remove the previous hwaccel, if there was one.
         hwaccel_uninit(avctx);
@@ -1382,9 +1201,9 @@
             break;
         }
 
-        if (avctx->codec->hw_configs) {
+        if (ffcodec(avctx->codec)->hw_configs) {
             for (i = 0;; i++) {
-                hw_config = avctx->codec->hw_configs[i];
+                hw_config = ffcodec(avctx->codec)->hw_configs[i];
                 if (!hw_config)
                     break;
                 if (hw_config->public.pix_fmt == user_choice)
@@ -1460,265 +1279,9 @@
     return ret;
 }
 
-static void frame_pool_free(void *opaque, uint8_t *data)
-{
-    FramePool *pool = (FramePool*)data;
-    int i;
-
-    for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
-        av_buffer_pool_uninit(&pool->pools[i]);
-
-    av_freep(&data);
-}
-
-static AVBufferRef *frame_pool_alloc(void)
-{
-    FramePool *pool = av_mallocz(sizeof(*pool));
-    AVBufferRef *buf;
-
-    if (!pool)
-        return NULL;
-
-    buf = av_buffer_create((uint8_t*)pool, sizeof(*pool),
-                           frame_pool_free, NULL, 0);
-    if (!buf) {
-        av_freep(&pool);
-        return NULL;
-    }
-
-    return buf;
-}
-
-static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
-{
-    FramePool *pool = avctx->internal->pool ?
-                      (FramePool*)avctx->internal->pool->data : NULL;
-    AVBufferRef *pool_buf;
-    int i, ret, ch, planes;
-
-    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
-        int planar = av_sample_fmt_is_planar(frame->format);
-        ch     = frame->channels;
-        planes = planar ? ch : 1;
-    }
-
-    if (pool && pool->format == frame->format) {
-        if (avctx->codec_type == AVMEDIA_TYPE_VIDEO &&
-            pool->width == frame->width && pool->height == frame->height)
-            return 0;
-        if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pool->planes == planes &&
-            pool->channels == ch && frame->nb_samples == pool->samples)
-            return 0;
-    }
-
-    pool_buf = frame_pool_alloc();
-    if (!pool_buf)
-        return AVERROR(ENOMEM);
-    pool = (FramePool*)pool_buf->data;
-
-    switch (avctx->codec_type) {
-    case AVMEDIA_TYPE_VIDEO: {
-        int linesize[4];
-        int w = frame->width;
-        int h = frame->height;
-        int unaligned;
-        ptrdiff_t linesize1[4];
-        size_t size[4];
-
-        avcodec_align_dimensions2(avctx, &w, &h, pool->stride_align);
-
-        do {
-            // NOTE: do not align linesizes individually, this breaks e.g. assumptions
-            // that linesize[0] == 2*linesize[1] in the MPEG-encoder for 4:2:2
-            ret = av_image_fill_linesizes(linesize, avctx->pix_fmt, w);
-            if (ret < 0)
-                goto fail;
-            // increase alignment of w for next try (rhs gives the lowest bit set in w)
-            w += w & ~(w - 1);
-
-            unaligned = 0;
-            for (i = 0; i < 4; i++)
-                unaligned |= linesize[i] % pool->stride_align[i];
-        } while (unaligned);
-
-        for (i = 0; i < 4; i++)
-            linesize1[i] = linesize[i];
-        ret = av_image_fill_plane_sizes(size, avctx->pix_fmt, h, linesize1);
-        if (ret < 0)
-            goto fail;
-
-        for (i = 0; i < 4; i++) {
-            pool->linesize[i] = linesize[i];
-            if (size[i]) {
-                if (size[i] > INT_MAX - (16 + STRIDE_ALIGN - 1)) {
-                    ret = AVERROR(EINVAL);
-                    goto fail;
-                }
-                pool->pools[i] = av_buffer_pool_init(size[i] + 16 + STRIDE_ALIGN - 1,
-                                                     CONFIG_MEMORY_POISONING ?
-                                                        NULL :
-                                                        av_buffer_allocz);
-                if (!pool->pools[i]) {
-                    ret = AVERROR(ENOMEM);
-                    goto fail;
-                }
-            }
-        }
-        pool->format = frame->format;
-        pool->width  = frame->width;
-        pool->height = frame->height;
-
-        break;
-        }
-    case AVMEDIA_TYPE_AUDIO: {
-        ret = av_samples_get_buffer_size(&pool->linesize[0], ch,
-                                         frame->nb_samples, frame->format, 0);
-        if (ret < 0)
-            goto fail;
-
-        pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
-        if (!pool->pools[0]) {
-            ret = AVERROR(ENOMEM);
-            goto fail;
-        }
-
-        pool->format     = frame->format;
-        pool->planes     = planes;
-        pool->channels   = ch;
-        pool->samples = frame->nb_samples;
-        break;
-        }
-    default: av_assert0(0);
-    }
-
-    av_buffer_unref(&avctx->internal->pool);
-    avctx->internal->pool = pool_buf;
-
-    return 0;
-fail:
-    av_buffer_unref(&pool_buf);
-    return ret;
-}
-
-static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)
-{
-    FramePool *pool = (FramePool*)avctx->internal->pool->data;
-    int planes = pool->planes;
-    int i;
-
-    frame->linesize[0] = pool->linesize[0];
-
-    if (planes > AV_NUM_DATA_POINTERS) {
-        frame->extended_data = av_mallocz_array(planes, sizeof(*frame->extended_data));
-        frame->nb_extended_buf = planes - AV_NUM_DATA_POINTERS;
-        frame->extended_buf  = av_mallocz_array(frame->nb_extended_buf,
-                                          sizeof(*frame->extended_buf));
-        if (!frame->extended_data || !frame->extended_buf) {
-            av_freep(&frame->extended_data);
-            av_freep(&frame->extended_buf);
-            return AVERROR(ENOMEM);
-        }
-    } else {
-        frame->extended_data = frame->data;
-        av_assert0(frame->nb_extended_buf == 0);
-    }
-
-    for (i = 0; i < FFMIN(planes, AV_NUM_DATA_POINTERS); i++) {
-        frame->buf[i] = av_buffer_pool_get(pool->pools[0]);
-        if (!frame->buf[i])
-            goto fail;
-        frame->extended_data[i] = frame->data[i] = frame->buf[i]->data;
-    }
-    for (i = 0; i < frame->nb_extended_buf; i++) {
-        frame->extended_buf[i] = av_buffer_pool_get(pool->pools[0]);
-        if (!frame->extended_buf[i])
-            goto fail;
-        frame->extended_data[i + AV_NUM_DATA_POINTERS] = frame->extended_buf[i]->data;
-    }
-
-    if (avctx->debug & FF_DEBUG_BUFFERS)
-        av_log(avctx, AV_LOG_DEBUG, "default_get_buffer called on frame %p", frame);
-
-    return 0;
-fail:
-    av_frame_unref(frame);
-    return AVERROR(ENOMEM);
-}
-
-static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
-{
-    FramePool *pool = (FramePool*)s->internal->pool->data;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);
-    int i;
-
-    if (pic->data[0] || pic->data[1] || pic->data[2] || pic->data[3]) {
-        av_log(s, AV_LOG_ERROR, "pic->data[*]!=NULL in avcodec_default_get_buffer\n");
-        return -1;
-    }
-
-    if (!desc) {
-        av_log(s, AV_LOG_ERROR,
-            "Unable to get pixel format descriptor for format %s\n",
-            av_get_pix_fmt_name(pic->format));
-        return AVERROR(EINVAL);
-    }
-
-    memset(pic->data, 0, sizeof(pic->data));
-    pic->extended_data = pic->data;
-
-    for (i = 0; i < 4 && pool->pools[i]; i++) {
-        pic->linesize[i] = pool->linesize[i];
-
-        pic->buf[i] = av_buffer_pool_get(pool->pools[i]);
-        if (!pic->buf[i])
-            goto fail;
-
-        pic->data[i] = pic->buf[i]->data;
-    }
-    for (; i < AV_NUM_DATA_POINTERS; i++) {
-        pic->data[i] = NULL;
-        pic->linesize[i] = 0;
-    }
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL ||
-        ((desc->flags & FF_PSEUDOPAL) && pic->data[1]))
-        avpriv_set_systematic_pal2((uint32_t *)pic->data[1], pic->format);
-
-    if (s->debug & FF_DEBUG_BUFFERS)
-        av_log(s, AV_LOG_DEBUG, "default_get_buffer called on pic %p\n", pic);
-
-    return 0;
-fail:
-    av_frame_unref(pic);
-    return AVERROR(ENOMEM);
-}
-
-int avcodec_default_get_buffer2(AVCodecContext *avctx, AVFrame *frame, int flags)
-{
-    int ret;
-
-    if (avctx->hw_frames_ctx) {
-        ret = av_hwframe_get_buffer(avctx->hw_frames_ctx, frame, 0);
-        frame->width  = avctx->coded_width;
-        frame->height = avctx->coded_height;
-        return ret;
-    }
-
-    if ((ret = update_frame_pool(avctx, frame)) < 0)
-        return ret;
-
-    switch (avctx->codec_type) {
-    case AVMEDIA_TYPE_VIDEO:
-        return video_get_buffer(avctx, frame);
-    case AVMEDIA_TYPE_AUDIO:
-        return audio_get_buffer(avctx, frame);
-    default:
-        return -1;
-    }
-}
-
 static int add_metadata_from_side_data(const AVPacket *avpkt, AVFrame *frame)
 {
-    buffer_size_t size;
+    size_t size;
     const uint8_t *side_metadata;
 
     AVDictionary **frame_md = &frame->metadata;
@@ -1728,9 +1291,9 @@
     return av_packet_unpack_dictionary(side_metadata, size, frame_md);
 }
 
-int ff_decode_frame_props(AVCodecContext *avctx, AVFrame *frame)
+int ff_decode_frame_props_from_pkt(const AVCodecContext *avctx,
+                                   AVFrame *frame, const AVPacket *pkt)
 {
-    AVPacket *pkt = avctx->internal->last_pkt_props;
     static const struct {
         enum AVPacketSideDataType packet;
         enum AVFrameSideDataType frame;
@@ -1745,41 +1308,60 @@
         { AV_PKT_DATA_A53_CC,                     AV_FRAME_DATA_A53_CC },
         { AV_PKT_DATA_ICC_PROFILE,                AV_FRAME_DATA_ICC_PROFILE },
         { AV_PKT_DATA_S12M_TIMECODE,              AV_FRAME_DATA_S12M_TIMECODE },
+        { AV_PKT_DATA_DYNAMIC_HDR10_PLUS,         AV_FRAME_DATA_DYNAMIC_HDR_PLUS },
     };
 
-    if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
-        frame->pts = pkt->pts;
-#if FF_API_PKT_PTS
-FF_DISABLE_DEPRECATION_WARNINGS
-        frame->pkt_pts = pkt->pts;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-        frame->pkt_pos      = pkt->pos;
-        frame->pkt_duration = pkt->duration;
-        frame->pkt_size     = pkt->size;
-
-        for (int i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
-            buffer_size_t size;
-            uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
-            if (packet_sd) {
-                AVFrameSideData *frame_sd = av_frame_new_side_data(frame,
-                                                                   sd[i].frame,
-                                                                   size);
-                if (!frame_sd)
-                    return AVERROR(ENOMEM);
+    frame->pts          = pkt->pts;
+    frame->pkt_pos      = pkt->pos;
+    frame->duration     = pkt->duration;
+    frame->pkt_size     = pkt->size;
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
+        size_t size;
+        uint8_t *packet_sd = av_packet_get_side_data(pkt, sd[i].packet, &size);
+        if (packet_sd) {
+            AVFrameSideData *frame_sd = av_frame_new_side_data(frame,
+                                                               sd[i].frame,
+                                                               size);
+            if (!frame_sd)
+                return AVERROR(ENOMEM);
 
-                memcpy(frame_sd->data, packet_sd, size);
-            }
+            memcpy(frame_sd->data, packet_sd, size);
         }
-        add_metadata_from_side_data(pkt, frame);
+    }
+    add_metadata_from_side_data(pkt, frame);
 
-        if (pkt->flags & AV_PKT_FLAG_DISCARD) {
-            frame->flags |= AV_FRAME_FLAG_DISCARD;
-        } else {
-            frame->flags = (frame->flags & ~AV_FRAME_FLAG_DISCARD);
-        }
+    if (pkt->flags & AV_PKT_FLAG_DISCARD) {
+        frame->flags |= AV_FRAME_FLAG_DISCARD;
+    } else {
+        frame->flags = (frame->flags & ~AV_FRAME_FLAG_DISCARD);
     }
+
+    if (avctx->flags & AV_CODEC_FLAG_COPY_OPAQUE) {
+        int ret = av_buffer_replace(&frame->opaque_ref, pkt->opaque_ref);
+        if (ret < 0)
+            return ret;
+        frame->opaque = pkt->opaque;
+    }
+
+    return 0;
+}
+
+int ff_decode_frame_props(AVCodecContext *avctx, AVFrame *frame)
+{
+    const AVPacket *pkt = avctx->internal->last_pkt_props;
+
+    if (!(ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
+        int ret = ff_decode_frame_props_from_pkt(avctx, frame, pkt);
+        if (ret < 0)
+            return ret;
+        frame->pkt_size     = (int)(intptr_t)pkt->opaque;
+    }
+#if FF_API_REORDERED_OPAQUE
+FF_DISABLE_DEPRECATION_WARNINGS
     frame->reordered_opaque = avctx->reordered_opaque;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
 
     if (frame->color_primaries == AVCOL_PRI_UNSPECIFIED)
         frame->color_primaries = avctx->color_primaries;
@@ -1813,25 +1395,18 @@
             frame->sample_rate    = avctx->sample_rate;
         if (frame->format < 0)
             frame->format         = avctx->sample_fmt;
-        if (!frame->channel_layout) {
-            if (avctx->channel_layout) {
-                 if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=
-                     avctx->channels) {
-                     av_log(avctx, AV_LOG_ERROR, "Inconsistent channel "
-                            "configuration.\n");
-                     return AVERROR(EINVAL);
-                 }
-
-                frame->channel_layout = avctx->channel_layout;
-            } else {
-                if (avctx->channels > FF_SANE_NB_CHANNELS) {
-                    av_log(avctx, AV_LOG_ERROR, "Too many channels: %d.\n",
-                           avctx->channels);
-                    return AVERROR(ENOSYS);
-                }
-            }
+        if (!frame->ch_layout.nb_channels) {
+            int ret = av_channel_layout_copy(&frame->ch_layout, &avctx->ch_layout);
+            if (ret < 0)
+                return ret;
         }
-        frame->channels = avctx->channels;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        frame->channels = frame->ch_layout.nb_channels;
+        frame->channel_layout = frame->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
+                                frame->ch_layout.u.mask : 0;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
         break;
     }
     return 0;
@@ -1846,8 +1421,6 @@
         int flags = desc ? desc->flags : 0;
         if (num_planes == 1 && (flags & AV_PIX_FMT_FLAG_PAL))
             num_planes = 2;
-        if ((flags & FF_PSEUDOPAL) && frame->data[1])
-            num_planes = 2;
         for (i = 0; i < num_planes; i++) {
             av_assert0(frame->data[i]);
         }
@@ -1903,6 +1476,8 @@
     int override_dimensions = 1;
     int ret;
 
+    av_assert0(av_codec_is_decoder(avctx->codec));
+
     if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
         if ((unsigned)avctx->width > INT_MAX - STRIDE_ALIGN ||
             (ret = av_image_check_size2(FFALIGN(avctx->width, STRIDE_ALIGN), avctx->height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx)) < 0 || avctx->pix_fmt<0) {
@@ -1923,7 +1498,16 @@
             goto fail;
         }
     } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
-        if (frame->nb_samples * (int64_t)avctx->channels > avctx->max_samples) {
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        /* compat layer for old-style get_buffer() implementations */
+        avctx->channels = avctx->ch_layout.nb_channels;
+        avctx->channel_layout = (avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE) ?
+                                avctx->ch_layout.u.mask : 0;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+        if (frame->nb_samples * (int64_t)avctx->ch_layout.nb_channels > avctx->max_samples) {
             av_log(avctx, AV_LOG_ERROR, "samples per frame %d, exceeds max_samples %"PRId64"\n", frame->nb_samples, avctx->max_samples);
             ret = AVERROR(EINVAL);
             goto fail;
@@ -1953,7 +1537,7 @@
 
 end:
     if (avctx->codec_type == AVMEDIA_TYPE_VIDEO && !override_dimensions &&
-        !(avctx->codec->caps_internal & FF_CODEC_CAP_EXPORTS_CROPPING)) {
+        !(ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_EXPORTS_CROPPING)) {
         frame->width  = avctx->width;
         frame->height = avctx->height;
     }
@@ -2014,30 +1598,53 @@
 
 int ff_decode_preinit(AVCodecContext *avctx)
 {
+    AVCodecInternal *avci = avctx->internal;
     int ret = 0;
 
     /* if the decoder init function was already called previously,
      * free the already allocated subtitle_header before overwriting it */
     av_freep(&avctx->subtitle_header);
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-FF_DISABLE_DEPRECATION_WARNINGS
-    if ((avctx->thread_type & FF_THREAD_FRAME) &&
-        avctx->get_buffer2 != avcodec_default_get_buffer2 &&
-        !avctx->thread_safe_callbacks) {
-        av_log(avctx, AV_LOG_WARNING, "Requested frame threading with a "
-               "custom get_buffer2() implementation which is not marked as "
-               "thread safe. This is not supported anymore, make your "
-               "callback thread-safe.\n");
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {
         av_log(avctx, AV_LOG_WARNING, "The maximum value for lowres supported by the decoder is %d\n",
                avctx->codec->max_lowres);
         avctx->lowres = avctx->codec->max_lowres;
     }
+    if (avctx->sub_charenc) {
+        if (avctx->codec_type != AVMEDIA_TYPE_SUBTITLE) {
+            av_log(avctx, AV_LOG_ERROR, "Character encoding is only "
+                   "supported with subtitles codecs\n");
+            return AVERROR(EINVAL);
+        } else if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB) {
+            av_log(avctx, AV_LOG_WARNING, "Codec '%s' is bitmap-based, "
+                   "subtitles character encoding will be ignored\n",
+                   avctx->codec_descriptor->name);
+            avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_DO_NOTHING;
+        } else {
+            /* input character encoding is set for a text based subtitle
+             * codec at this point */
+            if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_AUTOMATIC)
+                avctx->sub_charenc_mode = FF_SUB_CHARENC_MODE_PRE_DECODER;
+
+            if (avctx->sub_charenc_mode == FF_SUB_CHARENC_MODE_PRE_DECODER) {
+#if CONFIG_ICONV
+                iconv_t cd = iconv_open("UTF-8", avctx->sub_charenc);
+                if (cd == (iconv_t)-1) {
+                    ret = AVERROR(errno);
+                    av_log(avctx, AV_LOG_ERROR, "Unable to open iconv context "
+                           "with input character encoding \"%s\"\n", avctx->sub_charenc);
+                    return ret;
+                }
+                iconv_close(cd);
+#else
+                av_log(avctx, AV_LOG_ERROR, "Character encoding subtitles "
+                       "conversion needs a libavcodec built with iconv support "
+                       "for this codec\n");
+                return AVERROR(ENOSYS);
+#endif
+            }
+        }
+    }
 
     avctx->pts_correction_num_faulty_pts =
     avctx->pts_correction_num_faulty_dts = 0;
@@ -2052,9 +1659,29 @@
         avctx->export_side_data |= AV_CODEC_EXPORT_DATA_MVS;
     }
 
+    avci->in_pkt         = av_packet_alloc();
+    avci->last_pkt_props = av_packet_alloc();
+    if (!avci->in_pkt || !avci->last_pkt_props)
+        return AVERROR(ENOMEM);
+
     ret = decode_bsfs_init(avctx);
     if (ret < 0)
         return ret;
 
     return 0;
 }
+
+int ff_copy_palette(void *dst, const AVPacket *src, void *logctx)
+{
+    size_t size;
+    const void *pal = av_packet_get_side_data(src, AV_PKT_DATA_PALETTE, &size);
+
+    if (pal && size == AVPALETTE_SIZE) {
+        memcpy(dst, pal, AVPALETTE_SIZE);
+        return 1;
+    } else if (pal) {
+        av_log(logctx, AV_LOG_ERROR,
+               "Palette size %"SIZE_SPECIFIER" is wrong\n", size);
+    }
+    return 0;
+}
diff -Naur a/media/ffvpx/libavcodec/decode.h b/media/ffvpx/libavcodec/decode.h
--- a/media/ffvpx/libavcodec/decode.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/decode.h	2023-04-06 12:50:24.491176503 +0200
@@ -54,6 +54,11 @@
 } FrameDecodeData;
 
 /**
+ * avcodec_receive_frame() implementation for decoders.
+ */
+int ff_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame);
+
+/**
  * Called by decoders to get the next packet for decoding.
  *
  * @param pkt An empty packet to be filled with data.
@@ -65,6 +70,12 @@
 int ff_decode_get_packet(AVCodecContext *avctx, AVPacket *pkt);
 
 /**
+ * Set various frame properties from the provided packet.
+ */
+int ff_decode_frame_props_from_pkt(const AVCodecContext *avctx,
+                                   AVFrame *frame, const AVPacket *pkt);
+
+/**
  * Set various frame properties from the codec context / packet data.
  */
 int ff_decode_frame_props(AVCodecContext *avctx, AVFrame *frame);
@@ -80,9 +91,63 @@
 int ff_attach_decode_data(AVFrame *frame);
 
 /**
+ * Check whether the side-data of src contains a palette of
+ * size AVPALETTE_SIZE; if so, copy it to dst and return 1;
+ * else return 0.
+ * Also emit an error message upon encountering a palette
+ * with invalid size.
+ */
+int ff_copy_palette(void *dst, const AVPacket *src, void *logctx);
+
+/**
  * Perform decoder initialization and validation.
- * Called when opening the decoder, before the AVCodec.init() call.
+ * Called when opening the decoder, before the FFCodec.init() call.
  */
 int ff_decode_preinit(AVCodecContext *avctx);
 
+/**
+ * Check that the provided frame dimensions are valid and set them on the codec
+ * context.
+ */
+int ff_set_dimensions(AVCodecContext *s, int width, int height);
+
+/**
+ * Check that the provided sample aspect ratio is valid and set it on the codec
+ * context.
+ */
+int ff_set_sar(AVCodecContext *avctx, AVRational sar);
+
+/**
+ * Select the (possibly hardware accelerated) pixel format.
+ * This is a wrapper around AVCodecContext.get_format() and should be used
+ * instead of calling get_format() directly.
+ *
+ * The list of pixel formats must contain at least one valid entry, and is
+ * terminated with AV_PIX_FMT_NONE.  If it is possible to decode to software,
+ * the last entry in the list must be the most accurate software format.
+ * If it is not possible to decode to software, AVCodecContext.sw_pix_fmt
+ * must be set before calling this function.
+ */
+int ff_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt);
+
+/**
+ * Get a buffer for a frame. This is a wrapper around
+ * AVCodecContext.get_buffer() and should be used instead calling get_buffer()
+ * directly.
+ */
+int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags);
+
+#define FF_REGET_BUFFER_FLAG_READONLY 1 ///< the returned buffer does not need to be writable
+/**
+ * Identical in function to ff_get_buffer(), except it reuses the existing buffer
+ * if available.
+ */
+int ff_reget_buffer(AVCodecContext *avctx, AVFrame *frame, int flags);
+
+/**
+ * Add or update AV_FRAME_DATA_MATRIXENCODING side data.
+ */
+int ff_side_data_update_matrix_encoding(AVFrame *frame,
+                                        enum AVMatrixEncoding matrix_encoding);
+
 #endif /* AVCODEC_DECODE_H */
diff -Naur a/media/ffvpx/libavcodec/defs.h b/media/ffvpx/libavcodec/defs.h
--- a/media/ffvpx/libavcodec/defs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/defs.h	2023-04-06 12:50:06.971471053 +0200
@@ -0,0 +1,192 @@
+/*
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_DEFS_H
+#define AVCODEC_DEFS_H
+
+/**
+ * @file
+ * @ingroup libavc
+ * Misc types and constants that do not belong anywhere else.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+/**
+ * @ingroup lavc_decoding
+ * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
+ * This is mainly needed because some optimized bitstream readers read
+ * 32 or 64 bit at once and could read over the end.<br>
+ * Note: If the first 23 bits of the additional bytes are not 0, then damaged
+ * MPEG bitstreams could cause overread and segfault.
+ */
+#define AV_INPUT_BUFFER_PADDING_SIZE 64
+
+/**
+ * Verify checksums embedded in the bitstream (could be of either encoded or
+ * decoded data, depending on the format) and print an error message on mismatch.
+ * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
+ * decoder/demuxer returning an error.
+ */
+#define AV_EF_CRCCHECK       (1<<0)
+#define AV_EF_BITSTREAM      (1<<1)   ///< detect bitstream specification deviations
+#define AV_EF_BUFFER         (1<<2)   ///< detect improper bitstream length
+#define AV_EF_EXPLODE        (1<<3)   ///< abort decoding on minor error detection
+
+#define AV_EF_IGNORE_ERR     (1<<15)  ///< ignore errors and continue
+#define AV_EF_CAREFUL        (1<<16)  ///< consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors
+#define AV_EF_COMPLIANT      (1<<17)  ///< consider all spec non compliances as errors
+#define AV_EF_AGGRESSIVE     (1<<18)  ///< consider things that a sane encoder/muxer should not do as an error
+
+#define FF_COMPLIANCE_VERY_STRICT   2 ///< Strictly conform to an older more strict version of the spec or reference software.
+#define FF_COMPLIANCE_STRICT        1 ///< Strictly conform to all the things in the spec no matter what consequences.
+#define FF_COMPLIANCE_NORMAL        0
+#define FF_COMPLIANCE_UNOFFICIAL   -1 ///< Allow unofficial extensions
+#define FF_COMPLIANCE_EXPERIMENTAL -2 ///< Allow nonstandardized experimental things.
+
+/**
+ * @ingroup lavc_decoding
+ */
+enum AVDiscard{
+    /* We leave some space between them for extensions (drop some
+     * keyframes for intra-only or drop just some bidir frames). */
+    AVDISCARD_NONE    =-16, ///< discard nothing
+    AVDISCARD_DEFAULT =  0, ///< discard useless packets like 0 size packets in avi
+    AVDISCARD_NONREF  =  8, ///< discard all non reference
+    AVDISCARD_BIDIR   = 16, ///< discard all bidirectional frames
+    AVDISCARD_NONINTRA= 24, ///< discard all non intra frames
+    AVDISCARD_NONKEY  = 32, ///< discard all frames except keyframes
+    AVDISCARD_ALL     = 48, ///< discard all
+};
+
+enum AVAudioServiceType {
+    AV_AUDIO_SERVICE_TYPE_MAIN              = 0,
+    AV_AUDIO_SERVICE_TYPE_EFFECTS           = 1,
+    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
+    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED  = 3,
+    AV_AUDIO_SERVICE_TYPE_DIALOGUE          = 4,
+    AV_AUDIO_SERVICE_TYPE_COMMENTARY        = 5,
+    AV_AUDIO_SERVICE_TYPE_EMERGENCY         = 6,
+    AV_AUDIO_SERVICE_TYPE_VOICE_OVER        = 7,
+    AV_AUDIO_SERVICE_TYPE_KARAOKE           = 8,
+    AV_AUDIO_SERVICE_TYPE_NB                   , ///< Not part of ABI
+};
+
+/**
+ * Pan Scan area.
+ * This specifies the area which should be displayed.
+ * Note there may be multiple such areas for one frame.
+ */
+typedef struct AVPanScan {
+    /**
+     * id
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    int id;
+
+    /**
+     * width and height in 1/16 pel
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    int width;
+    int height;
+
+    /**
+     * position of the top left corner in 1/16 pel for up to 3 fields/frames
+     * - encoding: Set by user.
+     * - decoding: Set by libavcodec.
+     */
+    int16_t position[3][2];
+} AVPanScan;
+
+/**
+ * This structure describes the bitrate properties of an encoded bitstream. It
+ * roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
+ * parameters for H.264/HEVC.
+ */
+typedef struct AVCPBProperties {
+    /**
+     * Maximum bitrate of the stream, in bits per second.
+     * Zero if unknown or unspecified.
+     */
+    int64_t max_bitrate;
+    /**
+     * Minimum bitrate of the stream, in bits per second.
+     * Zero if unknown or unspecified.
+     */
+    int64_t min_bitrate;
+    /**
+     * Average bitrate of the stream, in bits per second.
+     * Zero if unknown or unspecified.
+     */
+    int64_t avg_bitrate;
+
+    /**
+     * The size of the buffer to which the ratecontrol is applied, in bits.
+     * Zero if unknown or unspecified.
+     */
+    int64_t buffer_size;
+
+    /**
+     * The delay between the time the packet this structure is associated with
+     * is received and the time when it should be decoded, in periods of a 27MHz
+     * clock.
+     *
+     * UINT64_MAX when unknown or unspecified.
+     */
+    uint64_t vbv_delay;
+} AVCPBProperties;
+
+/**
+ * Allocate a CPB properties structure and initialize its fields to default
+ * values.
+ *
+ * @param size if non-NULL, the size of the allocated struct will be written
+ *             here. This is useful for embedding it in side data.
+ *
+ * @return the newly allocated struct or NULL on failure
+ */
+AVCPBProperties *av_cpb_properties_alloc(size_t *size);
+
+/**
+ * This structure supplies correlation between a packet timestamp and a wall clock
+ * production time. The definition follows the Producer Reference Time ('prft')
+ * as defined in ISO/IEC 14496-12
+ */
+typedef struct AVProducerReferenceTime {
+    /**
+     * A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime()).
+     */
+    int64_t wallclock;
+    int flags;
+} AVProducerReferenceTime;
+
+/**
+ * Encode extradata length to a buffer. Used by xiph codecs.
+ *
+ * @param s buffer to write to; must be at least (v/255+1) bytes long
+ * @param v size of extradata in bytes
+ * @return number of bytes written to the buffer.
+ */
+unsigned int av_xiphlacing(unsigned char *s, unsigned int v);
+
+#endif // AVCODEC_DEFS_H
diff -Naur a/media/ffvpx/libavcodec/encode.c b/media/ffvpx/libavcodec/encode.c
--- a/media/ffvpx/libavcodec/encode.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/encode.c	2023-04-06 12:50:24.491176503 +0200
@@ -20,17 +20,19 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/avassert.h"
+#include "libavutil/channel_layout.h"
 #include "libavutil/frame.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/internal.h"
 #include "libavutil/samplefmt.h"
 
 #include "avcodec.h"
+#include "codec_internal.h"
 #include "encode.h"
 #include "frame_thread_encoder.h"
 #include "internal.h"
 
-int ff_alloc_packet2(AVCodecContext *avctx, AVPacket *avpkt, int64_t size, int64_t min_size)
+int ff_alloc_packet(AVCodecContext *avctx, AVPacket *avpkt, int64_t size)
 {
     if (size < 0 || size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
         av_log(avctx, AV_LOG_ERROR, "Invalid minimum required packet size %"PRId64" (max allowed is %d)\n",
@@ -40,18 +42,14 @@
 
     av_assert0(!avpkt->data);
 
-    if (avctx && 2*min_size < size) { // FIXME The factor needs to be finetuned
-        av_fast_padded_malloc(&avctx->internal->byte_buffer, &avctx->internal->byte_buffer_size, size);
-        avpkt->data = avctx->internal->byte_buffer;
-        avpkt->size = size;
-    }
-
+    av_fast_padded_malloc(&avctx->internal->byte_buffer,
+                          &avctx->internal->byte_buffer_size, size);
+    avpkt->data = avctx->internal->byte_buffer;
     if (!avpkt->data) {
-        int ret = av_new_packet(avpkt, size);
-        if (ret < 0)
-            av_log(avctx, AV_LOG_ERROR, "Failed to allocate packet of size %"PRId64"\n", size);
-        return ret;
+        av_log(avctx, AV_LOG_ERROR, "Failed to allocate packet of size %"PRId64"\n", size);
+        return AVERROR(ENOMEM);
     }
+    avpkt->size = size;
 
     return 0;
 }
@@ -74,7 +72,6 @@
         return ret;
     }
     avpkt->data = avpkt->buf->data;
-    memset(avpkt->data + avpkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
     return 0;
 }
@@ -98,6 +95,7 @@
         ret = AVERROR(EINVAL);
         goto fail;
     }
+    memset(avpkt->data + avpkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
     ret = 0;
 fail:
@@ -109,17 +107,35 @@
     return ret;
 }
 
+static int encode_make_refcounted(AVCodecContext *avctx, AVPacket *avpkt)
+{
+    uint8_t *data = avpkt->data;
+    int ret;
+
+    if (avpkt->buf)
+        return 0;
+
+    avpkt->data = NULL;
+    ret = ff_get_encode_buffer(avctx, avpkt, avpkt->size, 0);
+    if (ret < 0)
+        return ret;
+    memcpy(avpkt->data, data, avpkt->size);
+
+    return 0;
+}
+
 /**
  * Pad last frame with silence.
  */
-static int pad_last_frame(AVCodecContext *s, AVFrame *frame, const AVFrame *src)
+static int pad_last_frame(AVCodecContext *s, AVFrame *frame, const AVFrame *src, int out_samples)
 {
     int ret;
 
     frame->format         = src->format;
-    frame->channel_layout = src->channel_layout;
-    frame->channels       = src->channels;
-    frame->nb_samples     = s->frame_size;
+    frame->nb_samples     = out_samples;
+    ret = av_channel_layout_copy(&frame->ch_layout, &s->ch_layout);
+    if (ret < 0)
+        goto fail;
     ret = av_frame_get_buffer(frame, 0);
     if (ret < 0)
         goto fail;
@@ -129,17 +145,19 @@
         goto fail;
 
     if ((ret = av_samples_copy(frame->extended_data, src->extended_data, 0, 0,
-                               src->nb_samples, s->channels, s->sample_fmt)) < 0)
+                               src->nb_samples, s->ch_layout.nb_channels,
+                               s->sample_fmt)) < 0)
         goto fail;
     if ((ret = av_samples_set_silence(frame->extended_data, src->nb_samples,
                                       frame->nb_samples - src->nb_samples,
-                                      s->channels, s->sample_fmt)) < 0)
+                                      s->ch_layout.nb_channels, s->sample_fmt)) < 0)
         goto fail;
 
     return 0;
 
 fail:
     av_frame_unref(frame);
+    s->internal->last_audio_frame = 0;
     return ret;
 }
 
@@ -152,8 +170,13 @@
         return -1;
     }
 
-    ret = avctx->codec->encode_sub(avctx, buf, buf_size, sub);
-    avctx->frame_number++;
+    ret = ffcodec(avctx->codec)->cb.encode_sub(avctx, buf, buf_size, sub);
+    avctx->frame_num++;
+#if FF_API_AVCTX_FRAME_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->frame_number = avctx->frame_num;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     return ret;
 }
 
@@ -172,11 +195,87 @@
     return 0;
 }
 
+int ff_encode_reordered_opaque(AVCodecContext *avctx,
+                               AVPacket *pkt, const AVFrame *frame)
+{
+#if FF_API_REORDERED_OPAQUE
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->reordered_opaque = frame->reordered_opaque;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+    if (avctx->flags & AV_CODEC_FLAG_COPY_OPAQUE) {
+        int ret = av_buffer_replace(&pkt->opaque_ref, frame->opaque_ref);
+        if (ret < 0)
+            return ret;
+        pkt->opaque = frame->opaque;
+    }
+
+    return 0;
+}
+
+int ff_encode_encode_cb(AVCodecContext *avctx, AVPacket *avpkt,
+                        AVFrame *frame, int *got_packet)
+{
+    const FFCodec *const codec = ffcodec(avctx->codec);
+    int ret;
+
+    ret = codec->cb.encode(avctx, avpkt, frame, got_packet);
+    emms_c();
+    av_assert0(ret <= 0);
+
+    if (!ret && *got_packet) {
+        if (avpkt->data) {
+            ret = encode_make_refcounted(avctx, avpkt);
+            if (ret < 0)
+                goto unref;
+            // Date returned by encoders must always be ref-counted
+            av_assert0(avpkt->buf);
+        }
+
+        // set the timestamps for the simple no-delay case
+        // encoders with delay have to set the timestamps themselves
+        if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY) ||
+            (frame && (codec->caps_internal & FF_CODEC_CAP_EOF_FLUSH))) {
+            if (avpkt->pts == AV_NOPTS_VALUE)
+                avpkt->pts = frame->pts;
+
+            if (!avpkt->duration) {
+                if (frame->duration)
+                    avpkt->duration = frame->duration;
+                else if (avctx->codec->type == AVMEDIA_TYPE_AUDIO) {
+                    avpkt->duration = ff_samples_to_time_base(avctx,
+                                                              frame->nb_samples);
+                }
+            }
+
+            ret = ff_encode_reordered_opaque(avctx, avpkt, frame);
+            if (ret < 0)
+                goto unref;
+        }
+
+        // dts equals pts unless there is reordering
+        // there can be no reordering if there is no encoder delay
+        if (!(avctx->codec_descriptor->props & AV_CODEC_PROP_REORDER) ||
+            !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY)        ||
+            (codec->caps_internal & FF_CODEC_CAP_EOF_FLUSH))
+            avpkt->dts = avpkt->pts;
+    } else {
+unref:
+        av_packet_unref(avpkt);
+    }
+
+    if (frame)
+        av_frame_unref(frame);
+
+    return ret;
+}
+
 static int encode_simple_internal(AVCodecContext *avctx, AVPacket *avpkt)
 {
     AVCodecInternal   *avci = avctx->internal;
-    EncodeSimpleContext *es = &avci->es;
-    AVFrame          *frame = es->in_frame;
+    AVFrame          *frame = avci->in_frame;
+    const FFCodec *const codec = ffcodec(avctx->codec);
     int got_packet;
     int ret;
 
@@ -192,7 +291,7 @@
 
     if (!frame->buf[0]) {
         if (!(avctx->codec->capabilities & AV_CODEC_CAP_DELAY ||
-              (avci->frame_thread_encoder && avctx->active_thread_type & FF_THREAD_FRAME)))
+              avci->frame_thread_encoder))
             return AVERROR_EOF;
 
         // Flushing is signaled with a NULL frame
@@ -201,69 +300,18 @@
 
     got_packet = 0;
 
-    av_assert0(avctx->codec->encode2);
+    av_assert0(codec->cb_type == FF_CODEC_CB_TYPE_ENCODE);
 
-    if (CONFIG_FRAME_THREAD_ENCODER &&
-        avci->frame_thread_encoder && (avctx->active_thread_type & FF_THREAD_FRAME))
-        /* This might modify frame, but it doesn't matter, because
-         * the frame properties used below are not used for video
-         * (due to the delay inherent in frame threaded encoding, it makes
-         *  no sense to use the properties of the current frame anyway). */
+    if (CONFIG_FRAME_THREAD_ENCODER && avci->frame_thread_encoder)
+        /* This will unref frame. */
         ret = ff_thread_video_encode_frame(avctx, avpkt, frame, &got_packet);
     else {
-        ret = avctx->codec->encode2(avctx, avpkt, frame, &got_packet);
-        if (avctx->codec->type == AVMEDIA_TYPE_VIDEO && !ret && got_packet &&
-            !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY))
-            avpkt->pts = avpkt->dts = frame->pts;
-    }
-
-    av_assert0(ret <= 0);
-
-    emms_c();
-
-    if (!ret && got_packet) {
-        if (avpkt->data) {
-            ret = av_packet_make_refcounted(avpkt);
-            if (ret < 0)
-                goto end;
-        }
-
-        if (frame && !(avctx->codec->capabilities & AV_CODEC_CAP_DELAY)) {
-            if (avctx->codec->type == AVMEDIA_TYPE_AUDIO) {
-                if (avpkt->pts == AV_NOPTS_VALUE)
-                    avpkt->pts = frame->pts;
-                if (!avpkt->duration)
-                    avpkt->duration = ff_samples_to_time_base(avctx,
-                                                              frame->nb_samples);
-            }
-        }
-        if (avctx->codec->type == AVMEDIA_TYPE_AUDIO) {
-            /* NOTE: if we add any audio encoders which output non-keyframe packets,
-             *       this needs to be moved to the encoders, but for now we can do it
-             *       here to simplify things */
-            avpkt->flags |= AV_PKT_FLAG_KEY;
-            avpkt->dts = avpkt->pts;
-        }
+        ret = ff_encode_encode_cb(avctx, avpkt, frame, &got_packet);
     }
 
     if (avci->draining && !got_packet)
         avci->draining_done = 1;
 
-end:
-    if (ret < 0 || !got_packet)
-        av_packet_unref(avpkt);
-
-    if (frame) {
-        if (!ret)
-            avctx->frame_number++;
-        av_frame_unref(frame);
-    }
-
-    if (got_packet)
-        // Encoders must always return ref-counted buffers.
-        // Side-data only packets have no data and can be not ref-counted.
-        av_assert0(!avpkt->data || avpkt->buf);
-
     return ret;
 }
 
@@ -297,8 +345,8 @@
             return AVERROR(EINVAL);
     }
 
-    if (avctx->codec->receive_packet) {
-        ret = avctx->codec->receive_packet(avctx, avpkt);
+    if (ffcodec(avctx->codec)->cb_type == FF_CODEC_CB_TYPE_RECEIVE_PACKET) {
+        ret = ffcodec(avctx->codec)->cb.receive_packet(avctx, avpkt);
         if (ret < 0)
             av_packet_unref(avpkt);
         else
@@ -307,6 +355,8 @@
             av_assert0(!avpkt->data || avpkt->buf);
     } else
         ret = encode_simple_receive_packet(avctx, avpkt);
+    if (ret >= 0)
+        avpkt->flags |= avci->intra_only_flag;
 
     if (ret == AVERROR_EOF)
         avci->draining_done = 1;
@@ -314,6 +364,53 @@
     return ret;
 }
 
+#if CONFIG_LCMS2
+static int encode_generate_icc_profile(AVCodecContext *avctx, AVFrame *frame)
+{
+    enum AVColorTransferCharacteristic trc = frame->color_trc;
+    enum AVColorPrimaries prim = frame->color_primaries;
+    const FFCodec *const codec = ffcodec(avctx->codec);
+    AVCodecInternal *avci = avctx->internal;
+    cmsHPROFILE profile;
+    int ret;
+
+    /* don't generate ICC profiles if disabled or unsupported */
+    if (!(avctx->flags2 & AV_CODEC_FLAG2_ICC_PROFILES))
+        return 0;
+    if (!(codec->caps_internal & FF_CODEC_CAP_ICC_PROFILES))
+        return 0;
+
+    if (trc == AVCOL_TRC_UNSPECIFIED)
+        trc = avctx->color_trc;
+    if (prim == AVCOL_PRI_UNSPECIFIED)
+        prim = avctx->color_primaries;
+    if (trc == AVCOL_TRC_UNSPECIFIED || prim == AVCOL_PRI_UNSPECIFIED)
+        return 0; /* can't generate ICC profile with missing csp tags */
+
+    if (av_frame_get_side_data(frame, AV_FRAME_DATA_ICC_PROFILE))
+        return 0; /* don't overwrite existing ICC profile */
+
+    if (!avci->icc.avctx) {
+        ret = ff_icc_context_init(&avci->icc, avctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    ret = ff_icc_profile_generate(&avci->icc, prim, trc, &profile);
+    if (ret < 0)
+        return ret;
+
+    ret = ff_icc_profile_attach(&avci->icc, profile, frame);
+    cmsCloseProfile(profile);
+    return ret;
+}
+#else /* !CONFIG_LCMS2 */
+static int encode_generate_icc_profile(av_unused AVCodecContext *c, av_unused AVFrame *f)
+{
+    return 0;
+}
+#endif
+
 static int encode_send_frame_internal(AVCodecContext *avctx, const AVFrame *src)
 {
     AVCodecInternal *avci = avctx->internal;
@@ -327,37 +424,59 @@
             avctx->audio_service_type = *(enum AVAudioServiceType*)sd->data;
 
         /* check for valid frame size */
-        if (avctx->codec->capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME) {
-            if (src->nb_samples > avctx->frame_size) {
-                av_log(avctx, AV_LOG_ERROR, "more samples than frame size\n");
-                return AVERROR(EINVAL);
-            }
-        } else if (!(avctx->codec->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE)) {
+        if (!(avctx->codec->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE)) {
             /* if we already got an undersized frame, that must have been the last */
             if (avctx->internal->last_audio_frame) {
                 av_log(avctx, AV_LOG_ERROR, "frame_size (%d) was not respected for a non-last frame\n", avctx->frame_size);
                 return AVERROR(EINVAL);
             }
-
+            if (src->nb_samples > avctx->frame_size) {
+                av_log(avctx, AV_LOG_ERROR, "nb_samples (%d) > frame_size (%d)\n", src->nb_samples, avctx->frame_size);
+                return AVERROR(EINVAL);
+            }
             if (src->nb_samples < avctx->frame_size) {
-                ret = pad_last_frame(avctx, dst, src);
-                if (ret < 0)
-                    return ret;
-
                 avctx->internal->last_audio_frame = 1;
-            } else if (src->nb_samples > avctx->frame_size) {
-                av_log(avctx, AV_LOG_ERROR, "nb_samples (%d) != frame_size (%d)\n", src->nb_samples, avctx->frame_size);
-                return AVERROR(EINVAL);
+                if (!(avctx->codec->capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME)) {
+                    int pad_samples = avci->pad_samples ? avci->pad_samples : avctx->frame_size;
+                    int out_samples = (src->nb_samples + pad_samples - 1) / pad_samples * pad_samples;
+
+                    if (out_samples != src->nb_samples) {
+                        ret = pad_last_frame(avctx, dst, src, out_samples);
+                        if (ret < 0)
+                            return ret;
+                        goto finish;
+                    }
+                }
             }
         }
     }
 
-    if (!dst->data[0]) {
-        ret = av_frame_ref(dst, src);
+    ret = av_frame_ref(dst, src);
+    if (ret < 0)
+        return ret;
+
+finish:
+
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (dst->pkt_duration && dst->pkt_duration != dst->duration)
+        dst->duration = dst->pkt_duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+    if (avctx->codec->type == AVMEDIA_TYPE_VIDEO) {
+        ret = encode_generate_icc_profile(avctx, dst);
         if (ret < 0)
-             return ret;
+            return ret;
     }
 
+    // unset frame duration unless AV_CODEC_FLAG_FRAME_DURATION is set,
+    // since otherwise we cannot be sure that whatever value it has is in the
+    // right timebase, so we would produce an incorrect value, which is worse
+    // than none at all
+    if (!(avctx->flags & AV_CODEC_FLAG_FRAME_DURATION))
+        dst->duration = 0;
+
     return 0;
 }
 
@@ -372,7 +491,7 @@
     if (avci->draining)
         return AVERROR_EOF;
 
-    if (avci->buffer_frame->data[0])
+    if (avci->buffer_frame->buf[0])
         return AVERROR(EAGAIN);
 
     if (!frame) {
@@ -389,6 +508,13 @@
             return ret;
     }
 
+    avctx->frame_num++;
+#if FF_API_AVCTX_FRAME_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
+    avctx->frame_number = avctx->frame_num;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
     return 0;
 }
 
@@ -413,139 +539,82 @@
     return 0;
 }
 
-#if FF_API_OLD_ENCDEC
-static int compat_encode(AVCodecContext *avctx, AVPacket *avpkt,
-                         int *got_packet, const AVFrame *frame)
+static int encode_preinit_video(AVCodecContext *avctx)
 {
-    AVCodecInternal *avci = avctx->internal;
-    AVPacket user_pkt;
-    int ret;
-
-    *got_packet = 0;
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);
+    int i;
 
-    if (frame && avctx->codec->type == AVMEDIA_TYPE_VIDEO) {
-        if (frame->format == AV_PIX_FMT_NONE)
-            av_log(avctx, AV_LOG_WARNING, "AVFrame.format is not set\n");
-        if (frame->width == 0 || frame->height == 0)
-            av_log(avctx, AV_LOG_WARNING, "AVFrame.width or height is not set\n");
+    if (avctx->codec->pix_fmts) {
+        for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)
+            if (avctx->pix_fmt == avctx->codec->pix_fmts[i])
+                break;
+        if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE) {
+            char buf[128];
+            snprintf(buf, sizeof(buf), "%d", avctx->pix_fmt);
+            av_log(avctx, AV_LOG_ERROR, "Specified pixel format %s is invalid or not supported\n",
+                   (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));
+            return AVERROR(EINVAL);
+        }
+        if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||
+            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||
+            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||
+            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||
+            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)
+            avctx->color_range = AVCOL_RANGE_JPEG;
     }
 
-    if (avctx->codec->capabilities & AV_CODEC_CAP_DR1) {
-        av_log(avctx, AV_LOG_WARNING, "The deprecated avcodec_encode_* API does not support "
-                                      "AV_CODEC_CAP_DR1 encoders\n");
-        return AVERROR(ENOSYS);
+    if (    avctx->bits_per_raw_sample < 0
+        || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {
+        av_log(avctx, AV_LOG_WARNING, "Specified bit depth %d not possible with the specified pixel formats depth %d\n",
+            avctx->bits_per_raw_sample, pixdesc->comp[0].depth);
+        avctx->bits_per_raw_sample = pixdesc->comp[0].depth;
+    }
+    if (avctx->width <= 0 || avctx->height <= 0) {
+        av_log(avctx, AV_LOG_ERROR, "dimensions not set\n");
+        return AVERROR(EINVAL);
     }
 
-    ret = avcodec_send_frame(avctx, frame);
-    if (ret == AVERROR_EOF)
-        ret = 0;
-    else if (ret == AVERROR(EAGAIN)) {
-        /* we fully drain all the output in each encode call, so this should not
-         * ever happen */
-        return AVERROR_BUG;
-    } else if (ret < 0)
-        return ret;
-
-    av_packet_move_ref(&user_pkt, avpkt);
-    while (ret >= 0) {
-        ret = avcodec_receive_packet(avctx, avpkt);
-        if (ret < 0) {
-            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
-                ret = 0;
-            goto finish;
-        }
-
-        if (avpkt != avci->compat_encode_packet) {
-            if (avpkt->data && user_pkt.data) {
-                if (user_pkt.size >= avpkt->size) {
-                    memcpy(user_pkt.data, avpkt->data, avpkt->size);
-                    av_buffer_unref(&avpkt->buf);
-                    avpkt->buf  = user_pkt.buf;
-                    avpkt->data = user_pkt.data;
-FF_DISABLE_DEPRECATION_WARNINGS
-                    av_init_packet(&user_pkt);
-FF_ENABLE_DEPRECATION_WARNINGS
-                } else {
-                    av_log(avctx, AV_LOG_ERROR, "Provided packet is too small, needs to be %d\n", avpkt->size);
-                    av_packet_unref(avpkt);
-                    ret = AVERROR(EINVAL);
-                    goto finish;
-                }
-            }
+    if (avctx->ticks_per_frame && avctx->time_base.num &&
+        avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {
+        av_log(avctx, AV_LOG_ERROR,
+               "ticks_per_frame %d too large for the timebase %d/%d.",
+               avctx->ticks_per_frame,
+               avctx->time_base.num,
+               avctx->time_base.den);
+        return AVERROR(EINVAL);
+    }
 
-            *got_packet = 1;
-            avpkt = avci->compat_encode_packet;
-        } else {
-            if (!avci->compat_decode_warned) {
-                av_log(avctx, AV_LOG_WARNING, "The deprecated avcodec_encode_* "
-                       "API cannot return all the packets for this encoder. "
-                       "Some packets will be dropped. Update your code to the "
-                       "new encoding API to fix this.\n");
-                avci->compat_decode_warned = 1;
-                av_packet_unref(avpkt);
-            }
+    if (avctx->hw_frames_ctx) {
+        AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
+        if (frames_ctx->format != avctx->pix_fmt) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\n");
+            return AVERROR(EINVAL);
         }
-
-        if (avci->draining)
-            break;
+        if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&
+            avctx->sw_pix_fmt != frames_ctx->sw_format) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Mismatching AVCodecContext.sw_pix_fmt (%s) "
+                   "and AVHWFramesContext.sw_format (%s)\n",
+                   av_get_pix_fmt_name(avctx->sw_pix_fmt),
+                   av_get_pix_fmt_name(frames_ctx->sw_format));
+            return AVERROR(EINVAL);
+        }
+        avctx->sw_pix_fmt = frames_ctx->sw_format;
     }
 
-finish:
-    if (ret < 0)
-        av_packet_unref(&user_pkt);
-
-    return ret;
-}
-
-int attribute_align_arg avcodec_encode_audio2(AVCodecContext *avctx,
-                                              AVPacket *avpkt,
-                                              const AVFrame *frame,
-                                              int *got_packet_ptr)
-{
-    int ret = compat_encode(avctx, avpkt, got_packet_ptr, frame);
-
-    if (ret < 0)
-        av_packet_unref(avpkt);
-
-    return ret;
-}
-
-int attribute_align_arg avcodec_encode_video2(AVCodecContext *avctx,
-                                              AVPacket *avpkt,
-                                              const AVFrame *frame,
-                                              int *got_packet_ptr)
-{
-    int ret = compat_encode(avctx, avpkt, got_packet_ptr, frame);
-
-    if (ret < 0)
-        av_packet_unref(avpkt);
-
-    return ret;
+    return 0;
 }
-#endif
 
-int ff_encode_preinit(AVCodecContext *avctx)
+static int encode_preinit_audio(AVCodecContext *avctx)
 {
     int i;
-#if FF_API_CODED_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->coded_frame = av_frame_alloc();
-    if (!avctx->coded_frame) {
-        return AVERROR(ENOMEM);
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
-    if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {
-        av_log(avctx, AV_LOG_ERROR, "The encoder timebase is not set.\n");
-        return AVERROR(EINVAL);
-    }
 
     if (avctx->codec->sample_fmts) {
         for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) {
             if (avctx->sample_fmt == avctx->codec->sample_fmts[i])
                 break;
-            if (avctx->channels == 1 &&
+            if (avctx->ch_layout.nb_channels == 1 &&
                 av_get_planar_sample_fmt(avctx->sample_fmt) ==
                 av_get_planar_sample_fmt(avctx->codec->sample_fmts[i])) {
                 avctx->sample_fmt = avctx->codec->sample_fmts[i];
@@ -560,26 +629,6 @@
             return AVERROR(EINVAL);
         }
     }
-    if (avctx->codec->pix_fmts) {
-        for (i = 0; avctx->codec->pix_fmts[i] != AV_PIX_FMT_NONE; i++)
-            if (avctx->pix_fmt == avctx->codec->pix_fmts[i])
-                break;
-        if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_NONE
-            && !(avctx->codec_id == AV_CODEC_ID_MJPEG
-                 && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {
-            char buf[128];
-            snprintf(buf, sizeof(buf), "%d", avctx->pix_fmt);
-            av_log(avctx, AV_LOG_ERROR, "Specified pixel format %s is invalid or not supported\n",
-                   (char *)av_x_if_null(av_get_pix_fmt_name(avctx->pix_fmt), buf));
-            return AVERROR(EINVAL);
-        }
-        if (avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ420P ||
-            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ411P ||
-            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ422P ||
-            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ440P ||
-            avctx->codec->pix_fmts[i] == AV_PIX_FMT_YUVJ444P)
-            avctx->color_range = AVCOL_RANGE_JPEG;
-    }
     if (avctx->codec->supported_samplerates) {
         for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)
             if (avctx->sample_rate == avctx->codec->supported_samplerates[i])
@@ -595,52 +644,50 @@
                 avctx->sample_rate);
         return AVERROR(EINVAL);
     }
-    if (avctx->codec->channel_layouts) {
-        if (!avctx->channel_layout) {
-            av_log(avctx, AV_LOG_WARNING, "Channel layout not specified\n");
-        } else {
-            for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)
-                if (avctx->channel_layout == avctx->codec->channel_layouts[i])
-                    break;
-            if (avctx->codec->channel_layouts[i] == 0) {
-                char buf[512];
-                av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
-                av_log(avctx, AV_LOG_ERROR, "Specified channel layout '%s' is not supported\n", buf);
-                return AVERROR(EINVAL);
-            }
+    if (avctx->codec->ch_layouts) {
+        for (i = 0; avctx->codec->ch_layouts[i].nb_channels; i++) {
+            if (!av_channel_layout_compare(&avctx->ch_layout, &avctx->codec->ch_layouts[i]))
+                break;
         }
-    }
-    if (avctx->channel_layout && avctx->channels) {
-        int channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
-        if (channels != avctx->channels) {
+        if (!avctx->codec->ch_layouts[i].nb_channels) {
             char buf[512];
-            av_get_channel_layout_string(buf, sizeof(buf), -1, avctx->channel_layout);
-            av_log(avctx, AV_LOG_ERROR,
-                   "Channel layout '%s' with %d channels does not match number of specified channels %d\n",
-                   buf, channels, avctx->channels);
+            int ret = av_channel_layout_describe(&avctx->ch_layout, buf, sizeof(buf));
+            if (ret > 0)
+                av_log(avctx, AV_LOG_ERROR, "Specified channel layout '%s' is not supported\n", buf);
             return AVERROR(EINVAL);
         }
-    } else if (avctx->channel_layout) {
-        avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);
     }
-    if (avctx->channels < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Specified number of channels %d is not supported\n",
-                avctx->channels);
-        return AVERROR(EINVAL);
-    }
-    if(avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
-        const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(avctx->pix_fmt);
-        if (    avctx->bits_per_raw_sample < 0
-            || (avctx->bits_per_raw_sample > 8 && pixdesc->comp[0].depth <= 8)) {
-            av_log(avctx, AV_LOG_WARNING, "Specified bit depth %d not possible with the specified pixel formats depth %d\n",
-                avctx->bits_per_raw_sample, pixdesc->comp[0].depth);
-            avctx->bits_per_raw_sample = pixdesc->comp[0].depth;
-        }
-        if (avctx->width <= 0 || avctx->height <= 0) {
-            av_log(avctx, AV_LOG_ERROR, "dimensions not set\n");
-            return AVERROR(EINVAL);
-        }
+
+    if (!avctx->bits_per_raw_sample)
+        avctx->bits_per_raw_sample = 8 * av_get_bytes_per_sample(avctx->sample_fmt);
+
+    return 0;
+}
+
+int ff_encode_preinit(AVCodecContext *avctx)
+{
+    AVCodecInternal *avci = avctx->internal;
+    int ret = 0;
+
+    if (avctx->time_base.num <= 0 || avctx->time_base.den <= 0) {
+        av_log(avctx, AV_LOG_ERROR, "The encoder timebase is not set.\n");
+        return AVERROR(EINVAL);
+    }
+
+    if (avctx->flags & AV_CODEC_FLAG_COPY_OPAQUE &&
+        !(avctx->codec->capabilities & AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE)) {
+        av_log(avctx, AV_LOG_ERROR, "The copy_opaque flag is set, but the "
+               "encoder does not support it.\n");
+        return AVERROR(EINVAL);
+    }
+
+    switch (avctx->codec_type) {
+    case AVMEDIA_TYPE_VIDEO: ret = encode_preinit_video(avctx); break;
+    case AVMEDIA_TYPE_AUDIO: ret = encode_preinit_audio(avctx); break;
     }
+    if (ret < 0)
+        return ret;
+
     if (   (avctx->codec_type == AVMEDIA_TYPE_VIDEO || avctx->codec_type == AVMEDIA_TYPE_AUDIO)
         && avctx->bit_rate>0 && avctx->bit_rate<1000) {
         av_log(avctx, AV_LOG_WARNING, "Bitrate %"PRId64" is extremely low, maybe you mean %"PRId64"k\n", avctx->bit_rate, avctx->bit_rate);
@@ -649,34 +696,79 @@
     if (!avctx->rc_initial_buffer_occupancy)
         avctx->rc_initial_buffer_occupancy = avctx->rc_buffer_size * 3LL / 4;
 
-    if (avctx->ticks_per_frame && avctx->time_base.num &&
-        avctx->ticks_per_frame > INT_MAX / avctx->time_base.num) {
-        av_log(avctx, AV_LOG_ERROR,
-               "ticks_per_frame %d too large for the timebase %d/%d.",
-               avctx->ticks_per_frame,
-               avctx->time_base.num,
-               avctx->time_base.den);
-        return AVERROR(EINVAL);
+    if (avctx->codec_descriptor->props & AV_CODEC_PROP_INTRA_ONLY)
+        avctx->internal->intra_only_flag = AV_PKT_FLAG_KEY;
+
+    if (ffcodec(avctx->codec)->cb_type == FF_CODEC_CB_TYPE_ENCODE) {
+        avci->in_frame = av_frame_alloc();
+        if (!avci->in_frame)
+            return AVERROR(ENOMEM);
     }
 
-    if (avctx->hw_frames_ctx) {
-        AVHWFramesContext *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;
-        if (frames_ctx->format != avctx->pix_fmt) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Mismatching AVCodecContext.pix_fmt and AVHWFramesContext.format\n");
-            return AVERROR(EINVAL);
+    if ((avctx->flags & AV_CODEC_FLAG_RECON_FRAME)) {
+        if (!(avctx->codec->capabilities & AV_CODEC_CAP_ENCODER_RECON_FRAME)) {
+            av_log(avctx, AV_LOG_ERROR, "Reconstructed frame output requested "
+                   "from an encoder not supporting it\n");
+            return AVERROR(ENOSYS);
         }
-        if (avctx->sw_pix_fmt != AV_PIX_FMT_NONE &&
-            avctx->sw_pix_fmt != frames_ctx->sw_format) {
-            av_log(avctx, AV_LOG_ERROR,
-                   "Mismatching AVCodecContext.sw_pix_fmt (%s) "
-                   "and AVHWFramesContext.sw_format (%s)\n",
-                   av_get_pix_fmt_name(avctx->sw_pix_fmt),
-                   av_get_pix_fmt_name(frames_ctx->sw_format));
-            return AVERROR(EINVAL);
+
+        avci->recon_frame = av_frame_alloc();
+        if (!avci->recon_frame)
+            return AVERROR(ENOMEM);
+    }
+
+    if (CONFIG_FRAME_THREAD_ENCODER) {
+        ret = ff_frame_thread_encoder_init(avctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    return 0;
+}
+
+int ff_encode_alloc_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    int ret;
+
+    switch (avctx->codec->type) {
+    case AVMEDIA_TYPE_VIDEO:
+        frame->format = avctx->pix_fmt;
+        if (frame->width <= 0 || frame->height <= 0) {
+            frame->width  = FFMAX(avctx->width,  avctx->coded_width);
+            frame->height = FFMAX(avctx->height, avctx->coded_height);
         }
-        avctx->sw_pix_fmt = frames_ctx->sw_format;
+
+        break;
+    case AVMEDIA_TYPE_AUDIO:
+        frame->sample_rate = avctx->sample_rate;
+        frame->format      = avctx->sample_fmt;
+        if (!frame->ch_layout.nb_channels) {
+            ret = av_channel_layout_copy(&frame->ch_layout, &avctx->ch_layout);
+            if (ret < 0)
+                return ret;
+        }
+        break;
     }
 
+    ret = avcodec_default_get_buffer2(avctx, frame, 0);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
+        av_frame_unref(frame);
+        return ret;
+    }
+
+    return 0;
+}
+
+int ff_encode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    AVCodecInternal *avci = avctx->internal;
+
+    if (!avci->recon_frame)
+        return AVERROR(EINVAL);
+    if (!avci->recon_frame->buf[0])
+        return avci->draining_done ? AVERROR_EOF : AVERROR(EAGAIN);
+
+    av_frame_move_ref(frame, avci->recon_frame);
     return 0;
 }
diff -Naur a/media/ffvpx/libavcodec/encode.h b/media/ffvpx/libavcodec/encode.h
--- a/media/ffvpx/libavcodec/encode.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/encode.h	2023-04-06 12:50:24.491176503 +0200
@@ -27,6 +27,11 @@
 #include "packet.h"
 
 /**
+ * avcodec_receive_frame() implementation for encoders.
+ */
+int ff_encode_receive_frame(AVCodecContext *avctx, AVFrame *frame);
+
+/**
  * Called by encoders to get the next frame for encoding.
  *
  * @param frame An empty frame to be filled with data.
@@ -44,10 +49,51 @@
  */
 int ff_get_encode_buffer(AVCodecContext *avctx, AVPacket *avpkt, int64_t size, int flags);
 
+/**
+ * Allocate buffers for a frame. Encoder equivalent to ff_get_buffer().
+ */
+int ff_encode_alloc_frame(AVCodecContext *avctx, AVFrame *frame);
+
+/**
+ * Check AVPacket size and allocate data.
+ *
+ * Encoders of type FF_CODEC_CB_TYPE_ENCODE can use this as a convenience to
+ * obtain a big enough buffer for the encoded bitstream.
+ *
+ * @param avctx   the AVCodecContext of the encoder
+ * @param avpkt   The AVPacket: on success, avpkt->data will point to a buffer
+ *                of size at least `size`; the packet will not be refcounted.
+ *                This packet must be initially blank.
+ * @param size    an upper bound of the size of the packet to encode
+ * @return        non negative on success, negative error code on failure
+ */
+int ff_alloc_packet(AVCodecContext *avctx, AVPacket *avpkt, int64_t size);
+
+/**
+ * Propagate user opaque values from the frame to avctx/pkt as needed.
+ */
+int ff_encode_reordered_opaque(AVCodecContext *avctx,
+                               AVPacket *pkt, const AVFrame *frame);
+
 /*
  * Perform encoder initialization and validation.
- * Called when opening the encoder, before the AVCodec.init() call.
+ * Called when opening the encoder, before the FFCodec.init() call.
  */
 int ff_encode_preinit(AVCodecContext *avctx);
 
+int ff_encode_encode_cb(AVCodecContext *avctx, AVPacket *avpkt,
+                        AVFrame *frame, int *got_packet);
+
+/**
+ * Rescale from sample rate to AVCodecContext.time_base.
+ */
+static av_always_inline int64_t ff_samples_to_time_base(const AVCodecContext *avctx,
+                                                        int64_t samples)
+{
+    if (samples == AV_NOPTS_VALUE)
+        return AV_NOPTS_VALUE;
+    return av_rescale_q(samples, (AVRational){ 1, avctx->sample_rate },
+                        avctx->time_base);
+}
+
 #endif /* AVCODEC_ENCODE_H */
diff -Naur a/media/ffvpx/libavcodec/error_resilience.h b/media/ffvpx/libavcodec/error_resilience.h
--- a/media/ffvpx/libavcodec/error_resilience.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/error_resilience.h	2023-04-06 12:50:06.971471053 +0200
@@ -24,7 +24,7 @@
 
 #include "avcodec.h"
 #include "me_cmp.h"
-#include "thread.h"
+#include "threadframe.h"
 
 ///< current MB is the first after a resync marker
 #define VP_START               1
@@ -52,7 +52,8 @@
 
 typedef struct ERContext {
     AVCodecContext *avctx;
-    MECmpContext mecc;
+
+    me_cmp_func sad;
     int mecc_inited;
 
     int *mb_index2xy;
@@ -74,14 +75,13 @@
     ERPicture last_pic;
     ERPicture next_pic;
 
-    AVBufferRef *ref_index_buf[2];
-    AVBufferRef *motion_val_buf[2];
+    int8_t *ref_index[2];
+    int16_t (*motion_val_base[2])[2];
 
     uint16_t pp_time;
     uint16_t pb_time;
     int quarter_sample;
     int partitioned_frame;
-    int ref_count;
 
     void (*decode_mb)(void *opaque, int ref, int mv_dir, int mv_type,
                       int (*mv)[2][4][2],
diff -Naur a/media/ffvpx/libavcodec/fdctdsp.c b/media/ffvpx/libavcodec/fdctdsp.c
--- a/media/ffvpx/libavcodec/fdctdsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/fdctdsp.c	2023-04-06 12:49:40.252394850 +0200
@@ -25,7 +25,7 @@
 
 av_cold void ff_fdctdsp_init(FDCTDSPContext *c, AVCodecContext *avctx)
 {
-    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;
+    av_unused const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;
 
     if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {
         c->fdct    = ff_jpeg_fdct_islow_10;
@@ -43,8 +43,9 @@
         c->fdct248 = ff_fdct248_islow_8;
     }
 
-    if (ARCH_PPC)
-        ff_fdctdsp_init_ppc(c, avctx, high_bit_depth);
-    if (ARCH_X86)
-        ff_fdctdsp_init_x86(c, avctx, high_bit_depth);
+#if ARCH_PPC
+    ff_fdctdsp_init_ppc(c, avctx, high_bit_depth);
+#elif ARCH_X86
+    ff_fdctdsp_init_x86(c, avctx, high_bit_depth);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/fft_fixed_32.c b/media/ffvpx/libavcodec/fft_fixed_32.c
--- a/media/ffvpx/libavcodec/fft_fixed_32.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/fft_fixed_32.c	2023-04-06 12:49:40.252394850 +0200
@@ -48,5 +48,4 @@
  */
 
 #define FFT_FLOAT 0
-#define FFT_FIXED_32 1
 #include "fft_template.c"
diff -Naur a/media/ffvpx/libavcodec/fft_float.c b/media/ffvpx/libavcodec/fft_float.c
--- a/media/ffvpx/libavcodec/fft_float.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/fft_float.c	2023-04-06 12:49:40.252394850 +0200
@@ -17,5 +17,4 @@
  */
 
 #define FFT_FLOAT 1
-#define FFT_FIXED_32 0
 #include "fft_template.c"
diff -Naur a/media/ffvpx/libavcodec/fft.h b/media/ffvpx/libavcodec/fft.h
--- a/media/ffvpx/libavcodec/fft.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/fft.h	2023-04-06 12:50:06.971471053 +0200
@@ -26,13 +26,10 @@
 #define FFT_FLOAT 1
 #endif
 
-#ifndef FFT_FIXED_32
-#define FFT_FIXED_32 0
-#endif
-
 #include <stdint.h>
 #include "config.h"
 
+#include "libavutil/attributes_internal.h"
 #include "libavutil/mem_internal.h"
 
 #if FFT_FLOAT
@@ -45,15 +42,11 @@
 
 #else
 
-#if FFT_FIXED_32
-
 #define Q31(x) (int)((x)*2147483648.0 + 0.5)
 #define FFT_NAME(x) x ## _fixed_32
 
 typedef int32_t FFTSample;
 
-#endif /* FFT_FIXED_32 */
-
 typedef struct FFTComplex {
     FFTSample re, im;
 } FFTComplex;
@@ -122,7 +115,7 @@
 #endif
 
 #define COSTABLE(size) \
-    COSTABLE_CONST DECLARE_ALIGNED(32, FFTSample, FFT_NAME(ff_cos_##size))[size/2]
+    COSTABLE_CONST attribute_visibility_hidden DECLARE_ALIGNED(32, FFTSample, FFT_NAME(ff_cos_##size))[size/2]
 
 extern COSTABLE(16);
 extern COSTABLE(32);
diff -Naur a/media/ffvpx/libavcodec/fft-internal.h b/media/ffvpx/libavcodec/fft-internal.h
--- a/media/ffvpx/libavcodec/fft-internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/fft-internal.h	2023-04-06 12:49:40.252394850 +0200
@@ -19,6 +19,9 @@
 #ifndef AVCODEC_FFT_INTERNAL_H
 #define AVCODEC_FFT_INTERNAL_H
 
+#include "libavutil/mathematics.h"
+#include "fft.h"
+
 #if FFT_FLOAT
 
 #define FIX15(v) (v)
@@ -36,10 +39,6 @@
 
 #else /* FFT_FLOAT */
 
-#define SCALE_FLOAT(a, bits) lrint((a) * (double)(1 << (bits)))
-
-#if FFT_FIXED_32
-
 #define CMUL(dre, dim, are, aim, bre, bim) do {             \
         int64_t accu;                                     \
         (accu)  = (int64_t)(bre) * (are);                 \
@@ -50,10 +49,6 @@
         (dim)   = (int)(((accu) + 0x40000000) >> 31);       \
     } while (0)
 
-#define FIX15(a) av_clip(SCALE_FLOAT(a, 31), -2147483647, 2147483647)
-
-#endif /* FFT_FIXED_32 */
-
 #endif /* FFT_FLOAT */
 
 #define ff_imdct_calc_c FFT_NAME(ff_imdct_calc_c)
diff -Naur a/media/ffvpx/libavcodec/fft_template.c b/media/ffvpx/libavcodec/fft_template.c
--- a/media/ffvpx/libavcodec/fft_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/fft_template.c	2023-04-06 12:49:40.252394850 +0200
@@ -33,9 +33,9 @@
 #include "fft.h"
 #include "fft-internal.h"
 
-#if FFT_FIXED_32
+#if !FFT_FLOAT
 #include "fft_table.h"
-#else /* FFT_FIXED_32 */
+#else /* !FFT_FLOAT */
 
 /* cos(2*pi*x/n) for 0<=x<=n/4, followed by its reverse */
 #if !CONFIG_HARDCODED_TABLES
@@ -136,7 +136,7 @@
     FFT_NAME(ff_cos_131072),
 };
 
-#endif /* FFT_FIXED_32 */
+#endif /* FFT_FLOAT */
 
 static void fft_permute_c(FFTContext *s, FFTComplex *z);
 static void fft_calc_c(FFTContext *s, FFTComplex *z);
@@ -226,20 +226,25 @@
     s->mdct_calc   = ff_mdct_calc_c;
 #endif
 
-#if FFT_FIXED_32
-    ff_fft_lut_init();
-#else /* FFT_FIXED_32 */
 #if FFT_FLOAT
-    if (ARCH_AARCH64) ff_fft_init_aarch64(s);
-    if (ARCH_ARM)     ff_fft_init_arm(s);
-    if (ARCH_PPC)     ff_fft_init_ppc(s);
-    if (ARCH_X86)     ff_fft_init_x86(s);
-    if (HAVE_MIPSFPU) ff_fft_init_mips(s);
+#if ARCH_AARCH64
+    ff_fft_init_aarch64(s);
+#elif ARCH_ARM
+    ff_fft_init_arm(s);
+#elif ARCH_PPC
+    ff_fft_init_ppc(s);
+#elif ARCH_X86
+    ff_fft_init_x86(s);
+#endif
+#if HAVE_MIPSFPU
+    ff_fft_init_mips(s);
 #endif
     for(j=4; j<=nbits; j++) {
         ff_init_ff_cos_tabs(j);
     }
-#endif /* FFT_FIXED_32 */
+#else /* FFT_FLOAT */
+    ff_fft_lut_init();
+#endif
 
 
     if (ARCH_X86 && FFT_FLOAT && s->fft_permutation == FF_FFT_PERM_AVX) {
@@ -312,7 +317,7 @@
     av_freep(&s->tmp_buf);
 }
 
-#if FFT_FIXED_32
+#if !FFT_FLOAT
 
 static void fft_calc_c(FFTContext *s, FFTComplex *z) {
 
@@ -470,7 +475,7 @@
     }
 }
 
-#else /* FFT_FIXED_32 */
+#else /* !FFT_FLOAT */
 
 #define BUTTERFLIES(a0,a1,a2,a3) {\
     BF(t3, t5, t5, t1);\
@@ -620,4 +625,4 @@
 {
     fft_dispatch[s->nbits-2](z);
 }
-#endif /* FFT_FIXED_32 */
+#endif /* !FFT_FLOAT */
diff -Naur a/media/ffvpx/libavcodec/flac.c b/media/ffvpx/libavcodec/flac.c
--- a/media/ffvpx/libavcodec/flac.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flac.c	2023-04-06 12:50:24.491176503 +0200
@@ -26,18 +26,19 @@
 #include "get_bits.h"
 #include "flac.h"
 #include "flacdata.h"
+#include "flac_parse.h"
 
-static const int8_t sample_size_table[] = { 0, 8, 12, 0, 16, 20, 24, 0 };
+static const int8_t sample_size_table[] = { 0, 8, 12, 0, 16, 20, 24, 32 };
 
-static const uint64_t flac_channel_layouts[8] = {
-    AV_CH_LAYOUT_MONO,
-    AV_CH_LAYOUT_STEREO,
-    AV_CH_LAYOUT_SURROUND,
-    AV_CH_LAYOUT_QUAD,
-    AV_CH_LAYOUT_5POINT0,
-    AV_CH_LAYOUT_5POINT1,
-    AV_CH_LAYOUT_6POINT1,
-    AV_CH_LAYOUT_7POINT1
+static const AVChannelLayout flac_channel_layouts[8] = {
+    AV_CHANNEL_LAYOUT_MONO,
+    AV_CHANNEL_LAYOUT_STEREO,
+    AV_CHANNEL_LAYOUT_SURROUND,
+    AV_CHANNEL_LAYOUT_QUAD,
+    AV_CHANNEL_LAYOUT_5POINT0,
+    AV_CHANNEL_LAYOUT_5POINT1,
+    AV_CHANNEL_LAYOUT_6POINT1,
+    AV_CHANNEL_LAYOUT_7POINT1
 };
 
 static int64_t get_utf8(GetBitContext *gb)
@@ -81,7 +82,7 @@
 
     /* bits per sample */
     bps_code = get_bits(gb, 3);
-    if (bps_code == 3 || bps_code == 7) {
+    if (bps_code == 3) {
         av_log(avctx, AV_LOG_ERROR + log_level_offset,
                "invalid sample size code (%d)\n",
                bps_code);
@@ -145,29 +146,7 @@
     return 0;
 }
 
-int ff_flac_get_max_frame_size(int blocksize, int ch, int bps)
-{
-    /* Technically, there is no limit to FLAC frame size, but an encoder
-       should not write a frame that is larger than if verbatim encoding mode
-       were to be used. */
-
-    int count;
-
-    count = 16;                  /* frame header */
-    count += ch * ((7+bps+7)/8); /* subframe headers */
-    if (ch == 2) {
-        /* for stereo, need to account for using decorrelation */
-        count += (( 2*bps+1) * blocksize + 7) / 8;
-    } else {
-        count += ( ch*bps    * blocksize + 7) / 8;
-    }
-    count += 2; /* frame footer */
-
-    return count;
-}
-
 int ff_flac_is_extradata_valid(AVCodecContext *avctx,
-                               enum FLACExtradataFormat *format,
                                uint8_t **streaminfo_start)
 {
     if (!avctx->extradata || avctx->extradata_size < FLAC_STREAMINFO_SIZE) {
@@ -180,25 +159,29 @@
             av_log(avctx, AV_LOG_WARNING, "extradata contains %d bytes too many.\n",
                    FLAC_STREAMINFO_SIZE-avctx->extradata_size);
         }
-        *format = FLAC_EXTRADATA_FORMAT_STREAMINFO;
         *streaminfo_start = avctx->extradata;
     } else {
         if (avctx->extradata_size < 8+FLAC_STREAMINFO_SIZE) {
             av_log(avctx, AV_LOG_ERROR, "extradata too small.\n");
             return 0;
         }
-        *format = FLAC_EXTRADATA_FORMAT_FULL_HEADER;
         *streaminfo_start = &avctx->extradata[8];
     }
     return 1;
 }
 
-void ff_flac_set_channel_layout(AVCodecContext *avctx)
+void ff_flac_set_channel_layout(AVCodecContext *avctx, int channels)
 {
-    if (avctx->channels <= FF_ARRAY_ELEMS(flac_channel_layouts))
-        avctx->channel_layout = flac_channel_layouts[avctx->channels - 1];
+    if (channels == avctx->ch_layout.nb_channels &&
+        avctx->ch_layout.order != AV_CHANNEL_ORDER_UNSPEC)
+        return;
+
+    av_channel_layout_uninit(&avctx->ch_layout);
+    if (channels <= FF_ARRAY_ELEMS(flac_channel_layouts))
+        avctx->ch_layout = flac_channel_layouts[channels - 1];
     else
-        avctx->channel_layout = 0;
+        avctx->ch_layout = (AVChannelLayout){ .order = AV_CHANNEL_ORDER_UNSPEC,
+                                              .nb_channels = channels };
 }
 
 int ff_flac_parse_streaminfo(AVCodecContext *avctx, struct FLACStreaminfo *s,
@@ -229,13 +212,9 @@
         return AVERROR_INVALIDDATA;
     }
 
-    avctx->channels = s->channels;
     avctx->sample_rate = s->samplerate;
     avctx->bits_per_raw_sample = s->bps;
-
-    if (!avctx->channel_layout ||
-        av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels)
-        ff_flac_set_channel_layout(avctx);
+    ff_flac_set_channel_layout(avctx, s->channels);
 
     s->samples = get_bits64(&gb, 36);
 
diff -Naur a/media/ffvpx/libavcodec/flacdata.c b/media/ffvpx/libavcodec/flacdata.c
--- a/media/ffvpx/libavcodec/flacdata.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdata.c	2023-04-06 12:49:40.253394890 +0200
@@ -19,7 +19,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "internal.h"
+#include "flacdata.h"
 
 const int ff_flac_sample_rate_table[16] =
 { 0,
diff -Naur a/media/ffvpx/libavcodec/flacdata.h b/media/ffvpx/libavcodec/flacdata.h
--- a/media/ffvpx/libavcodec/flacdata.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdata.h	2023-04-06 12:49:40.253394890 +0200
@@ -22,7 +22,7 @@
 #ifndef AVCODEC_FLACDATA_H
 #define AVCODEC_FLACDATA_H
 
-#include "internal.h"
+#include <stdint.h>
 
 extern const int ff_flac_sample_rate_table[16];
 
diff -Naur a/media/ffvpx/libavcodec/flacdec.c b/media/ffvpx/libavcodec/flacdec.c
--- a/media/ffvpx/libavcodec/flacdec.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdec.c	2023-04-06 12:50:24.491176503 +0200
@@ -37,20 +37,21 @@
 #include "libavutil/crc.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
-#include "internal.h"
+#include "codec_internal.h"
 #include "get_bits.h"
 #include "bytestream.h"
 #include "golomb.h"
 #include "flac.h"
 #include "flacdata.h"
 #include "flacdsp.h"
+#include "flac_parse.h"
 #include "thread.h"
 #include "unary.h"
 
 
 typedef struct FLACContext {
     AVClass *class;
-    struct FLACStreaminfo flac_stream_info;
+    FLACStreaminfo stream_info;
 
     AVCodecContext *avctx;                  ///< parent AVCodecContext
     GetBitContext gb;                       ///< GetBitContext initialized to start at the current frame
@@ -63,6 +64,9 @@
     int32_t *decoded[FLAC_MAX_CHANNELS];    ///< decoded samples
     uint8_t *decoded_buffer;
     unsigned int decoded_buffer_size;
+    int64_t *decoded_33bps;                  ///< decoded samples for a 33 bps subframe
+    uint8_t *decoded_buffer_33bps;
+    unsigned int decoded_buffer_size_33bps;
     int buggy_lpc;                          ///< use workaround for old lavc encoded files
 
     FLACDSPContext dsp;
@@ -73,7 +77,7 @@
 static void flac_set_bps(FLACContext *s)
 {
     enum AVSampleFormat req = s->avctx->request_sample_fmt;
-    int need32 = s->flac_stream_info.bps > 16;
+    int need32 = s->stream_info.bps > 16;
     int want32 = av_get_bytes_per_sample(req) > 2;
     int planar = av_sample_fmt_is_planar(req);
 
@@ -82,19 +86,18 @@
             s->avctx->sample_fmt = AV_SAMPLE_FMT_S32P;
         else
             s->avctx->sample_fmt = AV_SAMPLE_FMT_S32;
-        s->sample_shift = 32 - s->flac_stream_info.bps;
+        s->sample_shift = 32 - s->stream_info.bps;
     } else {
         if (planar)
             s->avctx->sample_fmt = AV_SAMPLE_FMT_S16P;
         else
             s->avctx->sample_fmt = AV_SAMPLE_FMT_S16;
-        s->sample_shift = 16 - s->flac_stream_info.bps;
+        s->sample_shift = 16 - s->stream_info.bps;
     }
 }
 
 static av_cold int flac_decode_init(AVCodecContext *avctx)
 {
-    enum FLACExtradataFormat format;
     uint8_t *streaminfo;
     int ret;
     FLACContext *s = avctx->priv_data;
@@ -105,11 +108,11 @@
     if (!avctx->extradata)
         return 0;
 
-    if (!ff_flac_is_extradata_valid(avctx, &format, &streaminfo))
+    if (!ff_flac_is_extradata_valid(avctx, &streaminfo))
         return AVERROR_INVALIDDATA;
 
     /* initialize based on the demuxer-supplied streamdata header */
-    ret = ff_flac_parse_streaminfo(avctx, &s->flac_stream_info, streaminfo);
+    ret = ff_flac_parse_streaminfo(avctx, &s->stream_info, streaminfo);
     if (ret < 0)
         return ret;
     ret = allocate_buffers(s);
@@ -117,7 +120,7 @@
         return ret;
     flac_set_bps(s);
     ff_flacdsp_init(&s->dsp, avctx->sample_fmt,
-                    s->flac_stream_info.channels, s->flac_stream_info.bps);
+                    s->stream_info.channels);
     s->got_streaminfo = 1;
 
     return 0;
@@ -137,10 +140,10 @@
     int buf_size;
     int ret;
 
-    av_assert0(s->flac_stream_info.max_blocksize);
+    av_assert0(s->stream_info.max_blocksize);
 
-    buf_size = av_samples_get_buffer_size(NULL, s->flac_stream_info.channels,
-                                          s->flac_stream_info.max_blocksize,
+    buf_size = av_samples_get_buffer_size(NULL, s->stream_info.channels,
+                                          s->stream_info.max_blocksize,
                                           AV_SAMPLE_FMT_S32P, 0);
     if (buf_size < 0)
         return buf_size;
@@ -151,9 +154,27 @@
 
     ret = av_samples_fill_arrays((uint8_t **)s->decoded, NULL,
                                  s->decoded_buffer,
-                                 s->flac_stream_info.channels,
-                                 s->flac_stream_info.max_blocksize,
+                                 s->stream_info.channels,
+                                 s->stream_info.max_blocksize,
                                  AV_SAMPLE_FMT_S32P, 0);
+    if (ret >= 0 && s->stream_info.bps == 32 && s->stream_info.channels == 2) {
+        buf_size = av_samples_get_buffer_size(NULL, 1,
+                                              s->stream_info.max_blocksize,
+                                              AV_SAMPLE_FMT_S64P, 0);
+        if (buf_size < 0)
+            return buf_size;
+
+        av_fast_malloc(&s->decoded_buffer_33bps, &s->decoded_buffer_size_33bps, buf_size);
+        if (!s->decoded_buffer_33bps)
+            return AVERROR(ENOMEM);
+
+        ret = av_samples_fill_arrays((uint8_t **)&s->decoded_33bps, NULL,
+                                     s->decoded_buffer_33bps,
+                                     1,
+                                     s->stream_info.max_blocksize,
+                                     AV_SAMPLE_FMT_S64P, 0);
+
+    }
     return ret < 0 ? ret : 0;
 }
 
@@ -177,7 +198,7 @@
         metadata_size != FLAC_STREAMINFO_SIZE) {
         return AVERROR_INVALIDDATA;
     }
-    ret = ff_flac_parse_streaminfo(s->avctx, &s->flac_stream_info, &buf[8]);
+    ret = ff_flac_parse_streaminfo(s->avctx, &s->stream_info, &buf[8]);
     if (ret < 0)
         return ret;
     ret = allocate_buffers(s);
@@ -185,7 +206,7 @@
         return ret;
     flac_set_bps(s);
     ff_flacdsp_init(&s->dsp, s->avctx->sample_fmt,
-                    s->flac_stream_info.channels, s->flac_stream_info.bps);
+                    s->stream_info.channels);
     s->got_streaminfo = 1;
 
     return 0;
@@ -260,7 +281,7 @@
             for (; i < samples; i++)
                 *decoded++ = get_sbits_long(&gb, tmp);
         } else {
-            int real_limit = tmp ? (INT_MAX >> tmp) + 2 : INT_MAX;
+            int real_limit = (tmp > 1) ? (INT_MAX >> (tmp - 1)) + 2 : INT_MAX;
             for (; i < samples; i++) {
                 int v = get_sr_golomb_flac(&gb, tmp, real_limit, 1);
                 if (v == 0x80000000){
@@ -331,6 +352,62 @@
     return 0;
 }
 
+#define DECODER_SUBFRAME_FIXED_WIDE(residual) {                       \
+    const int blocksize = s->blocksize;                               \
+    int ret;                                                          \
+                                                                      \
+    if ((ret = decode_residuals(s, residual, pred_order)) < 0)        \
+        return ret;                                                   \
+                                                                      \
+    switch (pred_order) {                                             \
+    case 0:                                                           \
+        for (int i = pred_order; i < blocksize; i++)                  \
+            decoded[i] = residual[i];                                 \
+        break;                                                        \
+    case 1:                                                           \
+        for (int i = pred_order; i < blocksize; i++)                  \
+            decoded[i] = (int64_t)residual[i] + (int64_t)decoded[i-1];\
+        break;                                                        \
+    case 2:                                                           \
+        for (int i = pred_order; i < blocksize; i++)                  \
+            decoded[i] = (int64_t)residual[i] + 2*(int64_t)decoded[i-1] - (int64_t)decoded[i-2];  \
+        break;                                                        \
+    case 3:                                                           \
+        for (int i = pred_order; i < blocksize; i++)                  \
+            decoded[i] = (int64_t)residual[i] + 3*(int64_t)decoded[i-1] - 3*(int64_t)decoded[i-2] + (int64_t)decoded[i-3];   \
+        break;                                                        \
+    case 4:                                                           \
+        for (int i = pred_order; i < blocksize; i++)                  \
+            decoded[i] = (int64_t)residual[i] + 4*(int64_t)decoded[i-1] - 6*(int64_t)decoded[i-2] + 4*(int64_t)decoded[i-3] - (int64_t)decoded[i-4];   \
+        break;                                                        \
+    default:                                                          \
+        av_log(s->avctx, AV_LOG_ERROR, "illegal pred order %d\n", pred_order);   \
+        return AVERROR_INVALIDDATA;                                   \
+    }                                                                 \
+    return 0;                                                         \
+}
+
+static int decode_subframe_fixed_wide(FLACContext *s, int32_t *decoded,
+                                      int pred_order, int bps)
+{
+    /* warm up samples */
+    for (int i = 0; i < pred_order; i++) {
+        decoded[i] = get_sbits_long(&s->gb, bps);
+    }
+    DECODER_SUBFRAME_FIXED_WIDE(decoded);
+}
+
+
+static int decode_subframe_fixed_33bps(FLACContext *s, int64_t *decoded,
+                                       int32_t *residual, int pred_order)
+{
+    /* warm up samples */                                             \
+    for (int i = 0; i < pred_order; i++) {                            \
+        decoded[i] = get_sbits64(&s->gb, 33);                         \
+    }                                                                 \
+    DECODER_SUBFRAME_FIXED_WIDE(residual);
+}
+
 static void lpc_analyze_remodulate(SUINT32 *decoded, const int coeffs[32],
                                    int order, int qlevel, int len, int bps)
 {
@@ -389,25 +466,66 @@
     if ((ret = decode_residuals(s, decoded, pred_order)) < 0)
         return ret;
 
-    if (   (    s->buggy_lpc && s->flac_stream_info.bps <= 16)
+    if (   (    s->buggy_lpc && s->stream_info.bps <= 16)
         || (   !s->buggy_lpc && bps <= 16
             && bps + coeff_prec + av_log2(pred_order) <= 32)) {
         s->dsp.lpc16(decoded, coeffs, pred_order, qlevel, s->blocksize);
     } else {
         s->dsp.lpc32(decoded, coeffs, pred_order, qlevel, s->blocksize);
-        if (s->flac_stream_info.bps <= 16)
+        if (s->stream_info.bps <= 16)
             lpc_analyze_remodulate(decoded, coeffs, pred_order, qlevel, s->blocksize, bps);
     }
 
     return 0;
 }
 
+static int decode_subframe_lpc_33bps(FLACContext *s, int64_t *decoded,
+                                     int32_t *residual, int pred_order)
+{
+    int i, j, ret;
+    int coeff_prec, qlevel;
+    int coeffs[32];
+
+    /* warm up samples */
+    for (i = 0; i < pred_order; i++) {
+        decoded[i] = get_sbits64(&s->gb, 33);
+    }
+
+    coeff_prec = get_bits(&s->gb, 4) + 1;
+    if (coeff_prec == 16) {
+        av_log(s->avctx, AV_LOG_ERROR, "invalid coeff precision\n");
+        return AVERROR_INVALIDDATA;
+    }
+    qlevel = get_sbits(&s->gb, 5);
+    if (qlevel < 0) {
+        av_log(s->avctx, AV_LOG_ERROR, "qlevel %d not supported, maybe buggy stream\n",
+               qlevel);
+        return AVERROR_INVALIDDATA;
+    }
+
+    for (i = 0; i < pred_order; i++) {
+        coeffs[pred_order - i - 1] = get_sbits(&s->gb, coeff_prec);
+    }
+
+    if ((ret = decode_residuals(s, residual, pred_order)) < 0)
+        return ret;
+
+    for (i = pred_order; i < s->blocksize; i++, decoded++) {
+        int64_t sum = 0;
+        for (j = 0; j < pred_order; j++)
+            sum += (int64_t)coeffs[j] * decoded[j];
+        decoded[j] = residual[i] + (sum >> qlevel);
+    }
+
+    return 0;
+}
+
 static inline int decode_subframe(FLACContext *s, int channel)
 {
     int32_t *decoded = s->decoded[channel];
     int type, wasted = 0;
-    int bps = s->flac_stream_info.bps;
-    int i, tmp, ret;
+    int bps = s->stream_info.bps;
+    int i, ret;
 
     if (channel == 0) {
         if (s->ch_mode == FLAC_CHMODE_RIGHT_SIDE)
@@ -427,7 +545,7 @@
         int left = get_bits_left(&s->gb);
         if ( left <= 0 ||
             (left < bps && !show_bits_long(&s->gb, left)) ||
-                           !show_bits_long(&s->gb, bps)) {
+                           !show_bits_long(&s->gb, bps-1)) {
             av_log(s->avctx, AV_LOG_ERROR,
                    "Invalid number of wasted bits > available bits (%d) - left=%d\n",
                    bps, left);
@@ -436,34 +554,63 @@
         wasted = 1 + get_unary(&s->gb, 1, get_bits_left(&s->gb));
         bps -= wasted;
     }
-    if (bps > 32) {
-        avpriv_report_missing_feature(s->avctx, "Decorrelated bit depth > 32");
-        return AVERROR_PATCHWELCOME;
-    }
 
 //FIXME use av_log2 for types
     if (type == 0) {
-        tmp = get_sbits_long(&s->gb, bps);
-        for (i = 0; i < s->blocksize; i++)
-            decoded[i] = tmp;
+        if (bps < 33) {
+            int32_t tmp = get_sbits_long(&s->gb, bps);
+            for (i = 0; i < s->blocksize; i++)
+                decoded[i] = tmp;
+        } else {
+            int64_t tmp = get_sbits64(&s->gb, 33);
+            for (i = 0; i < s->blocksize; i++)
+                s->decoded_33bps[i] = tmp;
+        }
     } else if (type == 1) {
-        for (i = 0; i < s->blocksize; i++)
-            decoded[i] = get_sbits_long(&s->gb, bps);
+        if (bps < 33) {
+            for (i = 0; i < s->blocksize; i++)
+                decoded[i] = get_sbits_long(&s->gb, bps);
+        } else {
+            for (i = 0; i < s->blocksize; i++)
+                s->decoded_33bps[i] = get_sbits64(&s->gb, 33);
+        }
     } else if ((type >= 8) && (type <= 12)) {
-        if ((ret = decode_subframe_fixed(s, decoded, type & ~0x8, bps)) < 0)
-            return ret;
+        int order = type & ~0x8;
+        if (bps < 33) {
+            if (bps + order <= 32) {
+                if ((ret = decode_subframe_fixed(s, decoded, order, bps)) < 0)
+                    return ret;
+            } else {
+                if ((ret = decode_subframe_fixed_wide(s, decoded, order, bps)) < 0)
+                    return ret;
+            }
+        } else {
+            if ((ret = decode_subframe_fixed_33bps(s, s->decoded_33bps, decoded, order)) < 0)
+                return ret;
+        }
     } else if (type >= 32) {
-        if ((ret = decode_subframe_lpc(s, decoded, (type & ~0x20)+1, bps)) < 0)
-            return ret;
+        if (bps < 33) {
+            if ((ret = decode_subframe_lpc(s, decoded, (type & ~0x20)+1, bps)) < 0)
+                return ret;
+        } else {
+            if ((ret = decode_subframe_lpc_33bps(s, s->decoded_33bps, decoded, (type & ~0x20)+1)) < 0)
+                return ret;
+        }
     } else {
         av_log(s->avctx, AV_LOG_ERROR, "invalid coding type\n");
         return AVERROR_INVALIDDATA;
     }
 
-    if (wasted && wasted < 32) {
-        int i;
-        for (i = 0; i < s->blocksize; i++)
-            decoded[i] = (unsigned)decoded[i] << wasted;
+    if (wasted) {
+        if (wasted+bps == 33) {
+            int i;
+            for (i = 0; i < s->blocksize; i++)
+                s->decoded_33bps[i] = (uint64_t)decoded[i] << wasted;
+        } else if (wasted < 32) {
+            int i;
+            for (i = 0; i < s->blocksize; i++)
+                decoded[i] = (unsigned)decoded[i] << wasted;
+        }
     }
 
     return 0;
@@ -480,69 +627,68 @@
         return ret;
     }
 
-    if (   s->flac_stream_info.channels
-        && fi.channels != s->flac_stream_info.channels
+    if (   s->stream_info.channels
+        && fi.channels != s->stream_info.channels
         && s->got_streaminfo) {
-        s->flac_stream_info.channels = s->avctx->channels = fi.channels;
-        ff_flac_set_channel_layout(s->avctx);
+        s->stream_info.channels = fi.channels;
+        ff_flac_set_channel_layout(s->avctx, fi.channels);
         ret = allocate_buffers(s);
         if (ret < 0)
             return ret;
     }
-    s->flac_stream_info.channels = s->avctx->channels = fi.channels;
-    if (!s->avctx->channel_layout)
-        ff_flac_set_channel_layout(s->avctx);
+    s->stream_info.channels = fi.channels;
+    ff_flac_set_channel_layout(s->avctx, fi.channels);
     s->ch_mode = fi.ch_mode;
 
-    if (!s->flac_stream_info.bps && !fi.bps) {
+    if (!s->stream_info.bps && !fi.bps) {
         av_log(s->avctx, AV_LOG_ERROR, "bps not found in STREAMINFO or frame header\n");
         return AVERROR_INVALIDDATA;
     }
     if (!fi.bps) {
-        fi.bps = s->flac_stream_info.bps;
-    } else if (s->flac_stream_info.bps && fi.bps != s->flac_stream_info.bps) {
+        fi.bps = s->stream_info.bps;
+    } else if (s->stream_info.bps && fi.bps != s->stream_info.bps) {
         av_log(s->avctx, AV_LOG_ERROR, "switching bps mid-stream is not "
                                        "supported\n");
         return AVERROR_INVALIDDATA;
     }
 
-    if (!s->flac_stream_info.bps) {
-        s->flac_stream_info.bps = s->avctx->bits_per_raw_sample = fi.bps;
+    if (!s->stream_info.bps) {
+        s->stream_info.bps = s->avctx->bits_per_raw_sample = fi.bps;
         flac_set_bps(s);
     }
 
-    if (!s->flac_stream_info.max_blocksize)
-        s->flac_stream_info.max_blocksize = FLAC_MAX_BLOCKSIZE;
-    if (fi.blocksize > s->flac_stream_info.max_blocksize) {
+    if (!s->stream_info.max_blocksize)
+        s->stream_info.max_blocksize = FLAC_MAX_BLOCKSIZE;
+    if (fi.blocksize > s->stream_info.max_blocksize) {
         av_log(s->avctx, AV_LOG_ERROR, "blocksize %d > %d\n", fi.blocksize,
-               s->flac_stream_info.max_blocksize);
+               s->stream_info.max_blocksize);
         return AVERROR_INVALIDDATA;
     }
     s->blocksize = fi.blocksize;
 
-    if (!s->flac_stream_info.samplerate && !fi.samplerate) {
+    if (!s->stream_info.samplerate && !fi.samplerate) {
         av_log(s->avctx, AV_LOG_ERROR, "sample rate not found in STREAMINFO"
                                         " or frame header\n");
         return AVERROR_INVALIDDATA;
     }
     if (fi.samplerate == 0)
-        fi.samplerate = s->flac_stream_info.samplerate;
-    s->flac_stream_info.samplerate = s->avctx->sample_rate = fi.samplerate;
+        fi.samplerate = s->stream_info.samplerate;
+    s->stream_info.samplerate = s->avctx->sample_rate = fi.samplerate;
 
     if (!s->got_streaminfo) {
         ret = allocate_buffers(s);
         if (ret < 0)
             return ret;
         s->got_streaminfo = 1;
-        dump_headers(s->avctx, &s->flac_stream_info);
+        dump_headers(s->avctx, &s->stream_info);
     }
     ff_flacdsp_init(&s->dsp, s->avctx->sample_fmt,
-                    s->flac_stream_info.channels, s->flac_stream_info.bps);
+                    s->stream_info.channels);
 
-//    dump_headers(s->avctx, &s->flac_stream_info);
+//    dump_headers(s->avctx, &s->stream_info);
 
     /* subframes */
-    for (i = 0; i < s->flac_stream_info.channels; i++) {
+    for (i = 0; i < s->stream_info.channels; i++) {
         if ((ret = decode_subframe(s, i)) < 0)
             return ret;
     }
@@ -555,11 +701,29 @@
     return 0;
 }
 
-static int flac_decode_frame(AVCodecContext *avctx, void *data,
+static void decorrelate_33bps(int ch_mode, int32_t **decoded, int64_t *decoded_33bps, int len)
+{
+    int i;
+    if (ch_mode == FLAC_CHMODE_LEFT_SIDE ) {
+        for (i = 0; i < len; i++)
+           decoded[1][i] = decoded[0][i] - decoded_33bps[i];
+    } else if (ch_mode == FLAC_CHMODE_RIGHT_SIDE ) {
+        for (i = 0; i < len; i++)
+           decoded[0][i] = decoded[1][i] + decoded_33bps[i];
+    } else if (ch_mode == FLAC_CHMODE_MID_SIDE ) {
+        for (i = 0; i < len; i++) {
+            uint64_t a = decoded[0][i];
+            int64_t b = decoded_33bps[i];
+            a -= b >> 1;
+            decoded[0][i] = (a + b);
+            decoded[1][i] = a;
+        }
+    }
+}
+
+static int flac_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                              int *got_frame_ptr, AVPacket *avpkt)
 {
-    AVFrame *frame     = data;
-    ThreadFrame tframe = { .f = data };
     const uint8_t *buf = avpkt->data;
     int buf_size = avpkt->size;
     FLACContext *s = avctx->priv_data;
@@ -568,12 +732,6 @@
 
     *got_frame_ptr = 0;
 
-    if (s->flac_stream_info.max_framesize == 0) {
-        s->flac_stream_info.max_framesize =
-            ff_flac_get_max_frame_size(s->flac_stream_info.max_blocksize ? s->flac_stream_info.max_blocksize : FLAC_MAX_BLOCKSIZE,
-                                       FLAC_MAX_CHANNELS, 32);
-    }
-
     if (buf_size > 5 && !memcmp(buf, "\177FLAC", 5)) {
         av_log(s->avctx, AV_LOG_DEBUG, "skipping flac header packet 1\n");
         return buf_size;
@@ -586,7 +744,7 @@
 
     /* check that there is at least the smallest decodable amount of data.
        this amount corresponds to the smallest valid FLAC frame possible.
-       FF F8 69 02 00 00 9A 00 00 34 46 */
+       FF F8 69 02 00 00 9A 00 00 34 */
     if (buf_size < FLAC_MIN_FRAME_SIZE)
         return buf_size;
 
@@ -618,12 +776,18 @@
 
     /* get output buffer */
     frame->nb_samples = s->blocksize;
-    if ((ret = ff_thread_get_buffer(avctx, &tframe, 0)) < 0)
+    if ((ret = ff_thread_get_buffer(avctx, frame, 0)) < 0)
         return ret;
 
-    s->dsp.decorrelate[s->ch_mode](frame->data, s->decoded,
-                                   s->flac_stream_info.channels,
-                                   s->blocksize, s->sample_shift);
+    if (s->stream_info.bps == 32 && s->ch_mode > 0) {
+        decorrelate_33bps(s->ch_mode, s->decoded, s->decoded_33bps, s->blocksize);
+        s->dsp.decorrelate[0](frame->data, s->decoded, s->stream_info.channels,
+                              s->blocksize, s->sample_shift);
+    } else {
+        s->dsp.decorrelate[s->ch_mode](frame->data, s->decoded,
+                                       s->stream_info.channels,
+                                       s->blocksize, s->sample_shift);
+    }
 
     if (bytes_read > buf_size) {
         av_log(s->avctx, AV_LOG_ERROR, "overread: %d\n", bytes_read - buf_size);
@@ -644,6 +808,7 @@
     FLACContext *s = avctx->priv_data;
 
     av_freep(&s->decoded_buffer);
+    av_freep(&s->decoded_buffer_33bps);
 
     return 0;
 }
@@ -660,22 +825,22 @@
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
-AVCodec ff_flac_decoder = {
-    .name           = "flac",
-    .long_name      = NULL_IF_CONFIG_SMALL("FLAC (Free Lossless Audio Codec)"),
-    .type           = AVMEDIA_TYPE_AUDIO,
-    .id             = AV_CODEC_ID_FLAC,
+const FFCodec ff_flac_decoder = {
+    .p.name         = "flac",
+    CODEC_LONG_NAME("FLAC (Free Lossless Audio Codec)"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_FLAC,
     .priv_data_size = sizeof(FLACContext),
     .init           = flac_decode_init,
     .close          = flac_decode_close,
-    .decode         = flac_decode_frame,
-    .capabilities   = AV_CODEC_CAP_CHANNEL_CONF |
+    FF_CODEC_DECODE_CB(flac_decode_frame),
+    .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1 |
                       AV_CODEC_CAP_FRAME_THREADS,
-    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16,
+    .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S32,
                                                       AV_SAMPLE_FMT_S32P,
                                                       AV_SAMPLE_FMT_NONE },
-    .priv_class     = &flac_decoder_class,
+    .p.priv_class   = &flac_decoder_class,
 };
diff -Naur a/media/ffvpx/libavcodec/flacdsp.c b/media/ffvpx/libavcodec/flacdsp.c
--- a/media/ffvpx/libavcodec/flacdsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdsp.c	2023-04-06 12:50:06.972471094 +0200
@@ -19,6 +19,7 @@
  */
 
 #include "libavutil/attributes.h"
+#include "libavutil/internal.h"
 #include "libavutil/samplefmt.h"
 #include "flacdsp.h"
 #include "config.h"
@@ -26,7 +27,6 @@
 #define SAMPLE_SIZE 16
 #define PLANAR 0
 #include "flacdsp_template.c"
-#include "flacdsp_lpc_template.c"
 
 #undef  PLANAR
 #define PLANAR 1
@@ -37,7 +37,6 @@
 #define SAMPLE_SIZE 32
 #define PLANAR 0
 #include "flacdsp_template.c"
-#include "flacdsp_lpc_template.c"
 
 #undef  PLANAR
 #define PLANAR 1
@@ -85,13 +84,10 @@
 
 }
 
-av_cold void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels,
-                             int bps)
+av_cold void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels)
 {
     c->lpc16        = flac_lpc_16_c;
     c->lpc32        = flac_lpc_32_c;
-    c->lpc16_encode = flac_lpc_encode_c_16;
-    c->lpc32_encode = flac_lpc_encode_c_32;
 
     switch (fmt) {
     case AV_SAMPLE_FMT_S32:
@@ -123,8 +119,9 @@
         break;
     }
 
-    if (ARCH_ARM)
-        ff_flacdsp_init_arm(c, fmt, channels, bps);
-    if (ARCH_X86)
-        ff_flacdsp_init_x86(c, fmt, channels, bps);
+#if ARCH_ARM
+    ff_flacdsp_init_arm(c, fmt, channels);
+#elif ARCH_X86
+    ff_flacdsp_init_x86(c, fmt, channels);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/flacdsp.h b/media/ffvpx/libavcodec/flacdsp.h
--- a/media/ffvpx/libavcodec/flacdsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdsp.h	2023-04-06 12:50:06.972471094 +0200
@@ -20,7 +20,7 @@
 #define AVCODEC_FLACDSP_H
 
 #include <stdint.h>
-#include "libavutil/internal.h"
+
 #include "libavutil/samplefmt.h"
 
 typedef struct FLACDSPContext {
@@ -36,8 +36,8 @@
                          const int32_t coefs[32], int shift);
 } FLACDSPContext;
 
-void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels, int bps);
-void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels, int bps);
-void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels, int bps);
+void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels);
+void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels);
+void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels);
 
 #endif /* AVCODEC_FLACDSP_H */
diff -Naur a/media/ffvpx/libavcodec/flacdsp_lpc_template.c b/media/ffvpx/libavcodec/flacdsp_lpc_template.c
--- a/media/ffvpx/libavcodec/flacdsp_lpc_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdsp_lpc_template.c	2023-04-06 12:49:40.253394890 +0200
@@ -17,7 +17,7 @@
  */
 
 #include <stdint.h>
-#include "libavutil/avutil.h"
+#include "libavutil/common.h"
 #include "mathops.h"
 
 #undef FUNC
diff -Naur a/media/ffvpx/libavcodec/flacdsp_template.c b/media/ffvpx/libavcodec/flacdsp_template.c
--- a/media/ffvpx/libavcodec/flacdsp_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flacdsp_template.c	2023-04-06 12:49:40.253394890 +0200
@@ -19,7 +19,7 @@
  */
 
 #include <stdint.h>
-#include "libavutil/avutil.h"
+#include "libavutil/macros.h"
 
 #undef FUNC
 #undef FSUF
@@ -66,8 +66,8 @@
     int i;
 
     for (i = 0; i < len; i++) {
-        int a = in[0][i];
-        int b = in[1][i];
+        unsigned a = in[0][i];
+        unsigned b = in[1][i];
         S(samples, 0, i) =  a      << shift;
         S(samples, 1, i) = (a - b) << shift;
     }
@@ -80,8 +80,8 @@
     int i;
 
     for (i = 0; i < len; i++) {
-        int a = in[0][i];
-        int b = in[1][i];
+        unsigned a = in[0][i];
+        unsigned b = in[1][i];
         S(samples, 0, i) = (a + b) << shift;
         S(samples, 1, i) =  b      << shift;
     }
@@ -94,7 +94,7 @@
     int i;
 
     for (i = 0; i < len; i++) {
-        int a = in[0][i];
+        unsigned a = in[0][i];
         int b = in[1][i];
         a -= b >> 1;
         S(samples, 0, i) = (a + b) << shift;
diff -Naur a/media/ffvpx/libavcodec/flac.h b/media/ffvpx/libavcodec/flac.h
--- a/media/ffvpx/libavcodec/flac.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/flac.h	2023-04-06 12:50:06.971471053 +0200
@@ -1,5 +1,5 @@
 /*
- * FLAC (Free Lossless Audio Codec) decoder/demuxer common functions
+ * FLAC (Free Lossless Audio Codec) common stuff
  * Copyright (c) 2008 Justin Ruggles
  *
  * This file is part of FFmpeg.
@@ -21,21 +21,19 @@
 
 /**
  * @file
- * FLAC (Free Lossless Audio Codec) decoder/demuxer common functions
+ * FLAC (Free Lossless Audio Codec) common stuff
  */
 
 #ifndef AVCODEC_FLAC_H
 #define AVCODEC_FLAC_H
 
-#include "avcodec.h"
-#include "bytestream.h"
-#include "get_bits.h"
+#include "libavutil/intreadwrite.h"
 
 #define FLAC_STREAMINFO_SIZE   34
 #define FLAC_MAX_CHANNELS       8
 #define FLAC_MIN_BLOCKSIZE     16
 #define FLAC_MAX_BLOCKSIZE  65535
-#define FLAC_MIN_FRAME_SIZE    11
+#define FLAC_MIN_FRAME_SIZE    10
 
 enum {
     FLAC_CHMODE_INDEPENDENT = 0,
@@ -55,84 +53,6 @@
     FLAC_METADATA_TYPE_INVALID = 127
 };
 
-enum FLACExtradataFormat {
-    FLAC_EXTRADATA_FORMAT_STREAMINFO  = 0,
-    FLAC_EXTRADATA_FORMAT_FULL_HEADER = 1
-};
-
-#define FLACCOMMONINFO \
-    int samplerate;         /**< sample rate                             */\
-    int channels;           /**< number of channels                      */\
-    int bps;                /**< bits-per-sample                         */\
-
-/**
- * Data needed from the Streaminfo header for use by the raw FLAC demuxer
- * and/or the FLAC decoder.
- */
-#define FLACSTREAMINFO \
-    FLACCOMMONINFO \
-    int max_blocksize;      /**< maximum block size, in samples          */\
-    int max_framesize;      /**< maximum frame size, in bytes            */\
-    int64_t samples;        /**< total number of samples                 */\
-
-typedef struct FLACStreaminfo {
-    FLACSTREAMINFO
-} FLACStreaminfo;
-
-typedef struct FLACFrameInfo {
-    FLACCOMMONINFO
-    int blocksize;          /**< block size of the frame                 */
-    int ch_mode;            /**< channel decorrelation mode              */
-    int64_t frame_or_sample_num;    /**< frame number or sample number   */
-    int is_var_size;                /**< specifies if the stream uses variable
-                                         block sizes or a fixed block size;
-                                         also determines the meaning of
-                                         frame_or_sample_num             */
-} FLACFrameInfo;
-
-/**
- * Parse the Streaminfo metadata block
- * @param[out] avctx   codec context to set basic stream parameters
- * @param[out] s       where parsed information is stored
- * @param[in]  buffer  pointer to start of 34-byte streaminfo data
- *
- * @return negative error code on faiure or >= 0 on success
- */
-int ff_flac_parse_streaminfo(AVCodecContext *avctx, struct FLACStreaminfo *s,
-                              const uint8_t *buffer);
-
-/**
- * Validate the FLAC extradata.
- * @param[in]  avctx codec context containing the extradata.
- * @param[out] format extradata format.
- * @param[out] streaminfo_start pointer to start of 34-byte STREAMINFO data.
- * @return 1 if valid, 0 if not valid.
- */
-int ff_flac_is_extradata_valid(AVCodecContext *avctx,
-                               enum FLACExtradataFormat *format,
-                               uint8_t **streaminfo_start);
-
-/**
- * Calculate an estimate for the maximum frame size based on verbatim mode.
- * @param blocksize block size, in samples
- * @param ch number of channels
- * @param bps bits-per-sample
- */
-int ff_flac_get_max_frame_size(int blocksize, int ch, int bps);
-
-/**
- * Validate and decode a frame header.
- * @param      avctx AVCodecContext to use as av_log() context
- * @param      gb    GetBitContext from which to read frame header
- * @param[out] fi    frame information
- * @param      log_level_offset  log level offset. can be used to silence error messages.
- * @return non-zero on error, 0 if ok
- */
-int ff_flac_decode_frame_header(AVCodecContext *avctx, GetBitContext *gb,
-                                FLACFrameInfo *fi, int log_level_offset);
-
-void ff_flac_set_channel_layout(AVCodecContext *avctx);
-
 /**
  * Parse the metadata block parameters from the header.
  * @param[in]  block_header header data, at least 4 bytes
@@ -143,13 +63,13 @@
 static av_always_inline void flac_parse_block_header(const uint8_t *block_header,
                                                       int *last, int *type, int *size)
 {
-    int tmp = bytestream_get_byte(&block_header);
+    int tmp = *block_header;
     if (last)
         *last = tmp & 0x80;
     if (type)
         *type = tmp & 0x7F;
     if (size)
-        *size = bytestream_get_be24(&block_header);
+        *size = AV_RB24(block_header + 1);
 }
 
 #endif /* AVCODEC_FLAC_H */
diff -Naur a/media/ffvpx/libavcodec/flac_parse.h b/media/ffvpx/libavcodec/flac_parse.h
--- a/media/ffvpx/libavcodec/flac_parse.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/flac_parse.h	2023-04-06 12:50:06.971471053 +0200
@@ -0,0 +1,89 @@
+/*
+ * FLAC (Free Lossless Audio Codec) decoder/parser common functions
+ * Copyright (c) 2008 Justin Ruggles
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * FLAC (Free Lossless Audio Codec) decoder/parser common functions
+ */
+
+#ifndef AVCODEC_FLAC_PARSE_H
+#define AVCODEC_FLAC_PARSE_H
+
+#include "avcodec.h"
+#include "get_bits.h"
+
+typedef struct FLACStreaminfo {
+    int samplerate;         /**< sample rate                             */
+    int channels;           /**< number of channels                      */
+    int bps;                /**< bits-per-sample                         */
+    int max_blocksize;      /**< maximum block size, in samples          */
+    int max_framesize;      /**< maximum frame size, in bytes            */
+    int64_t samples;        /**< total number of samples                 */
+} FLACStreaminfo;
+
+typedef struct FLACFrameInfo {
+    int samplerate;         /**< sample rate                             */
+    int channels;           /**< number of channels                      */
+    int bps;                /**< bits-per-sample                         */
+    int blocksize;          /**< block size of the frame                 */
+    int ch_mode;            /**< channel decorrelation mode              */
+    int64_t frame_or_sample_num;    /**< frame number or sample number   */
+    int is_var_size;                /**< specifies if the stream uses variable
+                                         block sizes or a fixed block size;
+                                         also determines the meaning of
+                                         frame_or_sample_num             */
+} FLACFrameInfo;
+
+/**
+ * Parse the Streaminfo metadata block
+ * @param[out] avctx   codec context to set basic stream parameters
+ * @param[out] s       where parsed information is stored
+ * @param[in]  buffer  pointer to start of 34-byte streaminfo data
+ *
+ * @return negative error code on faiure or >= 0 on success
+ */
+int ff_flac_parse_streaminfo(AVCodecContext *avctx, struct FLACStreaminfo *s,
+                              const uint8_t *buffer);
+
+/**
+ * Validate the FLAC extradata.
+ * @param[in]  avctx codec context containing the extradata.
+ * @param[out] format extradata format.
+ * @param[out] streaminfo_start pointer to start of 34-byte STREAMINFO data.
+ * @return 1 if valid, 0 if not valid.
+ */
+int ff_flac_is_extradata_valid(AVCodecContext *avctx,
+                               uint8_t **streaminfo_start);
+
+/**
+ * Validate and decode a frame header.
+ * @param      avctx AVCodecContext to use as av_log() context
+ * @param      gb    GetBitContext from which to read frame header
+ * @param[out] fi    frame information
+ * @param      log_level_offset  log level offset. can be used to silence error messages.
+ * @return non-zero on error, 0 if ok
+ */
+int ff_flac_decode_frame_header(AVCodecContext *avctx, GetBitContext *gb,
+                                FLACFrameInfo *fi, int log_level_offset);
+
+void ff_flac_set_channel_layout(AVCodecContext *avctx, int channels);
+
+#endif /* AVCODEC_FLAC_PARSE_H */
diff -Naur a/media/ffvpx/libavcodec/frame_thread_encoder.h b/media/ffvpx/libavcodec/frame_thread_encoder.h
--- a/media/ffvpx/libavcodec/frame_thread_encoder.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/frame_thread_encoder.h	2023-04-06 12:49:40.253394890 +0200
@@ -27,7 +27,7 @@
  * Initialize frame thread encoder.
  * @note hardware encoders are not supported
  */
-int ff_frame_thread_encoder_init(AVCodecContext *avctx, AVDictionary *options);
+int ff_frame_thread_encoder_init(AVCodecContext *avctx);
 void ff_frame_thread_encoder_free(AVCodecContext *avctx);
 int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                                  AVFrame *frame, int *got_packet_ptr);
diff -Naur a/media/ffvpx/libavcodec/get_bits.h b/media/ffvpx/libavcodec/get_bits.h
--- a/media/ffvpx/libavcodec/get_bits.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/get_bits.h	2023-04-06 12:50:24.492176543 +0200
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 2004 Michael Niedermayer <michaelni@gmx.at>
- * Copyright (c) 2016 Alexandra Hájková
  *
  * This file is part of FFmpeg.
  *
@@ -31,9 +30,9 @@
 
 #include "libavutil/common.h"
 #include "libavutil/intreadwrite.h"
-#include "libavutil/log.h"
 #include "libavutil/avassert.h"
-#include "avcodec.h"
+
+#include "defs.h"
 #include "mathops.h"
 #include "vlc.h"
 
@@ -58,12 +57,55 @@
 #define CACHED_BITSTREAM_READER 0
 #endif
 
+#if CACHED_BITSTREAM_READER
+
+// we always want the LE implementation, to provide get_bits_le()
+#define BITSTREAM_LE
+
+#ifndef BITSTREAM_READER_LE
+# define BITSTREAM_BE
+# define BITSTREAM_DEFAULT_BE
+#endif
+
+#include "bitstream.h"
+
+#undef BITSTREAM_LE
+#undef BITSTREAM_BE
+#undef BITSTREAM_DEFAULT_BE
+
+typedef BitstreamContext GetBitContext;
+
+#define get_bits_count      bits_tell
+#define get_bits_left       bits_left
+#define skip_bits_long      bits_skip
+#define skip_bits           bits_skip
+#define get_bits            bits_read_nz
+#define get_bitsz           bits_read
+#define get_bits_long       bits_read
+#define get_bits1           bits_read_bit
+#define get_bits64          bits_read_64
+#define get_xbits           bits_read_xbits
+#define get_sbits           bits_read_signed_nz
+#define get_sbits_long      bits_read_signed
+#define show_bits           bits_peek
+#define show_bits_long      bits_peek
+#define init_get_bits       bits_init
+#define init_get_bits8      bits_init8
+#define align_get_bits      bits_align
+#define get_vlc2            bits_read_vlc
+
+#define init_get_bits8_le(s, buffer, byte_size) bits_init8_le((BitstreamContextLE*)s, buffer, byte_size)
+#define get_bits_le(s, n)                       bits_read_le((BitstreamContextLE*)s, n)
+
+#define show_bits1(s)       bits_peek(s, 1)
+#define skip_bits1(s)       bits_skip(s, 1)
+
+#define skip_1stop_8data_bits bits_skip_1stop_8data
+
+#else   // CACHED_BITSTREAM_READER
+
 typedef struct GetBitContext {
     const uint8_t *buffer, *buffer_end;
-#if CACHED_BITSTREAM_READER
-    uint64_t cache;
-    unsigned bits_left;
-#endif
     int index;
     int size_in_bits;
     int size_in_bits_plus8;
@@ -120,16 +162,12 @@
  * For examples see get_bits, show_bits, skip_bits, get_vlc.
  */
 
-#if CACHED_BITSTREAM_READER
-#   define MIN_CACHE_BITS 64
-#elif defined LONG_BITSTREAM_READER
+#if defined LONG_BITSTREAM_READER
 #   define MIN_CACHE_BITS 32
 #else
 #   define MIN_CACHE_BITS 25
 #endif
 
-#if !CACHED_BITSTREAM_READER
-
 #define OPEN_READER_NOSIZE(name, gb)            \
     unsigned int name ## _index = (gb)->index;  \
     unsigned int av_unused name ## _cache
@@ -214,73 +252,12 @@
 
 #define GET_CACHE(name, gb) ((uint32_t) name ## _cache)
 
-#endif
 
 static inline int get_bits_count(const GetBitContext *s)
 {
-#if CACHED_BITSTREAM_READER
-    return s->index - s->bits_left;
-#else
     return s->index;
-#endif
-}
-
-#if CACHED_BITSTREAM_READER
-static inline void refill_32(GetBitContext *s, int is_le)
-{
-#if !UNCHECKED_BITSTREAM_READER
-    if (s->index >> 3 >= s->buffer_end - s->buffer)
-        return;
-#endif
-
-    if (is_le)
-        s->cache = (uint64_t)AV_RL32(s->buffer + (s->index >> 3)) << s->bits_left | s->cache;
-    else
-        s->cache = s->cache | (uint64_t)AV_RB32(s->buffer + (s->index >> 3)) << (32 - s->bits_left);
-    s->index     += 32;
-    s->bits_left += 32;
 }
 
-static inline void refill_64(GetBitContext *s, int is_le)
-{
-#if !UNCHECKED_BITSTREAM_READER
-    if (s->index >> 3 >= s->buffer_end - s->buffer)
-        return;
-#endif
-
-    if (is_le)
-        s->cache = AV_RL64(s->buffer + (s->index >> 3));
-    else
-        s->cache = AV_RB64(s->buffer + (s->index >> 3));
-    s->index += 64;
-    s->bits_left = 64;
-}
-
-static inline uint64_t get_val(GetBitContext *s, unsigned n, int is_le)
-{
-    uint64_t ret;
-    av_assert2(n>0 && n<=63);
-    if (is_le) {
-        ret = s->cache & ((UINT64_C(1) << n) - 1);
-        s->cache >>= n;
-    } else {
-        ret = s->cache >> (64 - n);
-        s->cache <<= n;
-    }
-    s->bits_left -= n;
-    return ret;
-}
-
-static inline unsigned show_val(const GetBitContext *s, unsigned n)
-{
-#ifdef BITSTREAM_READER_LE
-    return s->cache & ((UINT64_C(1) << n) - 1);
-#else
-    return s->cache >> (64 - n);
-#endif
-}
-#endif
-
 /**
  * Skips the specified number of bits.
  * @param n the number of bits to skip,
@@ -290,29 +267,13 @@
  */
 static inline void skip_bits_long(GetBitContext *s, int n)
 {
-#if CACHED_BITSTREAM_READER
-    skip_bits(s, n);
-#else
 #if UNCHECKED_BITSTREAM_READER
     s->index += n;
 #else
     s->index += av_clip(n, -s->index, s->size_in_bits_plus8 - s->index);
 #endif
-#endif
 }
 
-#if CACHED_BITSTREAM_READER
-static inline void skip_remaining(GetBitContext *s, unsigned n)
-{
-#ifdef BITSTREAM_READER_LE
-    s->cache >>= n;
-#else
-    s->cache <<= n;
-#endif
-    s->bits_left -= n;
-}
-#endif
-
 /**
  * Read MPEG-1 dc-style VLC (sign bit + mantissa with no MSB).
  * if MSB not set it is negative
@@ -320,13 +281,6 @@
  */
 static inline int get_xbits(GetBitContext *s, int n)
 {
-#if CACHED_BITSTREAM_READER
-    int32_t cache = show_bits(s, 32);
-    int sign = ~cache >> 31;
-    skip_remaining(s, n);
-
-    return ((((uint32_t)(sign ^ cache)) >> (32 - n)) ^ sign) - sign;
-#else
     register int sign;
     register int32_t cache;
     OPEN_READER(re, s);
@@ -337,10 +291,8 @@
     LAST_SKIP_BITS(re, s, n);
     CLOSE_READER(re, s);
     return (NEG_USR32(sign ^ cache, n) ^ sign) - sign;
-#endif
 }
 
-#if !CACHED_BITSTREAM_READER
 static inline int get_xbits_le(GetBitContext *s, int n)
 {
     register int sign;
@@ -354,22 +306,16 @@
     CLOSE_READER(re, s);
     return (zero_extend(sign ^ cache, n) ^ sign) - sign;
 }
-#endif
 
 static inline int get_sbits(GetBitContext *s, int n)
 {
     register int tmp;
-#if CACHED_BITSTREAM_READER
-    av_assert2(n>0 && n<=25);
-    tmp = sign_extend(get_bits(s, n), n);
-#else
     OPEN_READER(re, s);
     av_assert2(n>0 && n<=25);
     UPDATE_CACHE(re, s);
     tmp = SHOW_SBITS(re, s, n);
     LAST_SKIP_BITS(re, s, n);
     CLOSE_READER(re, s);
-#endif
     return tmp;
 }
 
@@ -379,32 +325,12 @@
 static inline unsigned int get_bits(GetBitContext *s, int n)
 {
     register unsigned int tmp;
-#if CACHED_BITSTREAM_READER
-
-    av_assert2(n>0 && n<=32);
-    if (n > s->bits_left) {
-#ifdef BITSTREAM_READER_LE
-        refill_32(s, 1);
-#else
-        refill_32(s, 0);
-#endif
-        if (s->bits_left < 32)
-            s->bits_left = n;
-    }
-
-#ifdef BITSTREAM_READER_LE
-    tmp = get_val(s, n, 1);
-#else
-    tmp = get_val(s, n, 0);
-#endif
-#else
     OPEN_READER(re, s);
     av_assert2(n>0 && n<=25);
     UPDATE_CACHE(re, s);
     tmp = SHOW_UBITS(re, s, n);
     LAST_SKIP_BITS(re, s, n);
     CLOSE_READER(re, s);
-#endif
     av_assert2(tmp < UINT64_C(1) << n);
     return tmp;
 }
@@ -419,16 +345,6 @@
 
 static inline unsigned int get_bits_le(GetBitContext *s, int n)
 {
-#if CACHED_BITSTREAM_READER
-    av_assert2(n>0 && n<=32);
-    if (n > s->bits_left) {
-        refill_32(s, 1);
-        if (s->bits_left < 32)
-            s->bits_left = n;
-    }
-
-    return get_val(s, n, 1);
-#else
     register int tmp;
     OPEN_READER(re, s);
     av_assert2(n>0 && n<=25);
@@ -437,7 +353,6 @@
     LAST_SKIP_BITS(re, s, n);
     CLOSE_READER(re, s);
     return tmp;
-#endif
 }
 
 /**
@@ -446,71 +361,22 @@
 static inline unsigned int show_bits(GetBitContext *s, int n)
 {
     register unsigned int tmp;
-#if CACHED_BITSTREAM_READER
-    if (n > s->bits_left)
-#ifdef BITSTREAM_READER_LE
-        refill_32(s, 1);
-#else
-        refill_32(s, 0);
-#endif
-
-    tmp = show_val(s, n);
-#else
     OPEN_READER_NOSIZE(re, s);
     av_assert2(n>0 && n<=25);
     UPDATE_CACHE(re, s);
     tmp = SHOW_UBITS(re, s, n);
-#endif
     return tmp;
 }
 
 static inline void skip_bits(GetBitContext *s, int n)
 {
-#if CACHED_BITSTREAM_READER
-    if (n < s->bits_left)
-        skip_remaining(s, n);
-    else {
-        n -= s->bits_left;
-        s->cache = 0;
-        s->bits_left = 0;
-
-        if (n >= 64) {
-            unsigned skip = (n / 8) * 8;
-
-            n -= skip;
-            s->index += skip;
-        }
-#ifdef BITSTREAM_READER_LE
-        refill_64(s, 1);
-#else
-        refill_64(s, 0);
-#endif
-        if (n)
-            skip_remaining(s, n);
-    }
-#else
     OPEN_READER(re, s);
     LAST_SKIP_BITS(re, s, n);
     CLOSE_READER(re, s);
-#endif
 }
 
 static inline unsigned int get_bits1(GetBitContext *s)
 {
-#if CACHED_BITSTREAM_READER
-    if (!s->bits_left)
-#ifdef BITSTREAM_READER_LE
-        refill_64(s, 1);
-#else
-        refill_64(s, 0);
-#endif
-
-#ifdef BITSTREAM_READER_LE
-    return get_val(s, 1, 1);
-#else
-    return get_val(s, 1, 0);
-#endif
-#else
     unsigned int index = s->index;
     uint8_t result     = s->buffer[index >> 3];
 #ifdef BITSTREAM_READER_LE
@@ -527,7 +393,6 @@
     s->index = index;
 
     return result;
-#endif
 }
 
 static inline unsigned int show_bits1(GetBitContext *s)
@@ -548,10 +413,6 @@
     av_assert2(n>=0 && n<=32);
     if (!n) {
         return 0;
-#if CACHED_BITSTREAM_READER
-    }
-    return get_bits(s, n);
-#else
     } else if (n <= MIN_CACHE_BITS) {
         return get_bits(s, n);
     } else {
@@ -563,7 +424,6 @@
         return ret | get_bits(s, n - 16);
 #endif
     }
-#endif
 }
 
 /**
@@ -597,6 +457,18 @@
 }
 
 /**
+ * Read 0-64 bits as a signed integer.
+ */
+static inline int64_t get_sbits64(GetBitContext *s, int n)
+{
+    // sign_extend(x, 0) is undefined
+    if (!n)
+        return 0;
+
+    return sign_extend64(get_bits64(s, n), n);
+}
+
+/**
  * Show 0-32 bits.
  */
 static inline unsigned int show_bits_long(GetBitContext *s, int n)
@@ -609,18 +481,17 @@
     }
 }
 
-static inline int check_marker(void *logctx, GetBitContext *s, const char *msg)
-{
-    int bit = get_bits1(s);
-    if (!bit)
-        av_log(logctx, AV_LOG_INFO, "Marker bit missing at %d of %d %s\n",
-               get_bits_count(s) - 1, s->size_in_bits, msg);
-
-    return bit;
-}
 
-static inline int init_get_bits_xe(GetBitContext *s, const uint8_t *buffer,
-                                   int bit_size, int is_le)
+/**
+ * Initialize GetBitContext.
+ * @param buffer bitstream buffer, must be AV_INPUT_BUFFER_PADDING_SIZE bytes
+ *        larger than the actual read bits because some optimized bitstream
+ *        readers read 32 or 64 bit at once and could read over the end
+ * @param bit_size the size of the buffer in bits
+ * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.
+ */
+static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,
+                                int bit_size)
 {
     int buffer_size;
     int ret = 0;
@@ -639,12 +510,6 @@
     s->buffer_end         = buffer + buffer_size;
     s->index              = 0;
 
-#if CACHED_BITSTREAM_READER
-    s->cache              = 0;
-    s->bits_left          = 0;
-    refill_64(s, is_le);
-#endif
-
     return ret;
 }
 
@@ -653,24 +518,6 @@
  * @param buffer bitstream buffer, must be AV_INPUT_BUFFER_PADDING_SIZE bytes
  *        larger than the actual read bits because some optimized bitstream
  *        readers read 32 or 64 bit at once and could read over the end
- * @param bit_size the size of the buffer in bits
- * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.
- */
-static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,
-                                int bit_size)
-{
-#ifdef BITSTREAM_READER_LE
-    return init_get_bits_xe(s, buffer, bit_size, 1);
-#else
-    return init_get_bits_xe(s, buffer, bit_size, 0);
-#endif
-}
-
-/**
- * Initialize GetBitContext.
- * @param buffer bitstream buffer, must be AV_INPUT_BUFFER_PADDING_SIZE bytes
- *        larger than the actual read bits because some optimized bitstream
- *        readers read 32 or 64 bit at once and could read over the end
  * @param byte_size the size of the buffer in bytes
  * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.
  */
@@ -687,7 +534,7 @@
 {
     if (byte_size > INT_MAX / 8 || byte_size < 0)
         byte_size = -1;
-    return init_get_bits_xe(s, buffer, byte_size * 8, 1);
+    return init_get_bits(s, buffer, byte_size * 8);
 }
 
 static inline const uint8_t *align_get_bits(GetBitContext *s)
@@ -709,8 +556,8 @@
         unsigned int index;                                     \
                                                                 \
         index = SHOW_UBITS(name, gb, bits);                     \
-        code  = table[index][0];                                \
-        n     = table[index][1];                                \
+        code  = table[index].sym;                               \
+        n     = table[index].len;                               \
                                                                 \
         if (max_depth > 1 && n < 0) {                           \
             LAST_SKIP_BITS(name, gb, bits);                     \
@@ -719,8 +566,8 @@
             nb_bits = -n;                                       \
                                                                 \
             index = SHOW_UBITS(name, gb, nb_bits) + code;       \
-            code  = table[index][0];                            \
-            n     = table[index][1];                            \
+            code  = table[index].sym;                           \
+            n     = table[index].len;                           \
             if (max_depth > 2 && n < 0) {                       \
                 LAST_SKIP_BITS(name, gb, nb_bits);              \
                 UPDATE_CACHE(name, gb);                         \
@@ -728,8 +575,8 @@
                 nb_bits = -n;                                   \
                                                                 \
                 index = SHOW_UBITS(name, gb, nb_bits) + code;   \
-                code  = table[index][0];                        \
-                n     = table[index][1];                        \
+                code  = table[index].sym;                       \
+                n     = table[index].len;                       \
             }                                                   \
         }                                                       \
         SKIP_BITS(name, gb, n);                                 \
@@ -772,19 +619,6 @@
         SKIP_BITS(name, gb, n);                                 \
     } while (0)
 
-/* Return the LUT element for the given bitstream configuration. */
-static inline int set_idx(GetBitContext *s, int code, int *n, int *nb_bits,
-                          VLC_TYPE (*table)[2])
-{
-    unsigned idx;
-
-    *nb_bits = -*n;
-    idx = show_bits(s, *nb_bits) + code;
-    *n = table[idx][1];
-
-    return table[idx][0];
-}
-
 /**
  * Parse a vlc code.
  * @param bits is the number of bits which will be read at once, must be
@@ -794,27 +628,9 @@
  *                  = (max_vlc_length + bits - 1) / bits
  * @returns the code parsed or -1 if no vlc matches
  */
-static av_always_inline int get_vlc2(GetBitContext *s, VLC_TYPE (*table)[2],
+static av_always_inline int get_vlc2(GetBitContext *s, const VLCElem *table,
                                      int bits, int max_depth)
 {
-#if CACHED_BITSTREAM_READER
-    int nb_bits;
-    unsigned idx = show_bits(s, bits);
-    int code = table[idx][0];
-    int n    = table[idx][1];
-
-    if (max_depth > 1 && n < 0) {
-        skip_remaining(s, bits);
-        code = set_idx(s, code, &n, &nb_bits, table);
-        if (max_depth > 2 && n < 0) {
-            skip_remaining(s, nb_bits);
-            code = set_idx(s, code, &n, &nb_bits, table);
-        }
-    }
-    skip_remaining(s, n);
-
-    return code;
-#else
     int code;
 
     OPEN_READER(re, s);
@@ -825,7 +641,6 @@
     CLOSE_READER(re, s);
 
     return code;
-#endif
 }
 
 static inline int decode012(GetBitContext *gb)
@@ -865,4 +680,6 @@
     return 0;
 }
 
+#endif // CACHED_BITSTREAM_READER
+
 #endif /* AVCODEC_GET_BITS_H */
diff -Naur a/media/ffvpx/libavcodec/get_buffer.c b/media/ffvpx/libavcodec/get_buffer.c
--- a/media/ffvpx/libavcodec/get_buffer.c	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/get_buffer.c	2023-04-06 12:50:06.972471094 +0200
@@ -0,0 +1,304 @@
+/*
+ * The default get_buffer2() implementation
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "libavutil/avassert.h"
+#include "libavutil/avutil.h"
+#include "libavutil/buffer.h"
+#include "libavutil/frame.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/mem.h"
+#include "libavutil/samplefmt.h"
+#include "libavutil/version.h"
+
+#include "avcodec.h"
+#include "internal.h"
+
+typedef struct FramePool {
+    /**
+     * Pools for each data plane. For audio all the planes have the same size,
+     * so only pools[0] is used.
+     */
+    AVBufferPool *pools[4];
+
+    /*
+     * Pool parameters
+     */
+    int format;
+    int width, height;
+    int stride_align[AV_NUM_DATA_POINTERS];
+    int linesize[4];
+    int planes;
+    int channels;
+    int samples;
+} FramePool;
+
+static void frame_pool_free(void *opaque, uint8_t *data)
+{
+    FramePool *pool = (FramePool*)data;
+    int i;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
+        av_buffer_pool_uninit(&pool->pools[i]);
+
+    av_freep(&data);
+}
+
+static AVBufferRef *frame_pool_alloc(void)
+{
+    FramePool *pool = av_mallocz(sizeof(*pool));
+    AVBufferRef *buf;
+
+    if (!pool)
+        return NULL;
+
+    buf = av_buffer_create((uint8_t*)pool, sizeof(*pool),
+                           frame_pool_free, NULL, 0);
+    if (!buf) {
+        av_freep(&pool);
+        return NULL;
+    }
+
+    return buf;
+}
+
+static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
+{
+    FramePool *pool = avctx->internal->pool ?
+                      (FramePool*)avctx->internal->pool->data : NULL;
+    AVBufferRef *pool_buf;
+    int i, ret, ch, planes;
+
+    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
+        int planar = av_sample_fmt_is_planar(frame->format);
+        ch     = frame->ch_layout.nb_channels;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        if (!ch)
+            ch = frame->channels;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+        planes = planar ? ch : 1;
+    }
+
+    if (pool && pool->format == frame->format) {
+        if (avctx->codec_type == AVMEDIA_TYPE_VIDEO &&
+            pool->width == frame->width && pool->height == frame->height)
+            return 0;
+        if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pool->planes == planes &&
+            pool->channels == ch && frame->nb_samples == pool->samples)
+            return 0;
+    }
+
+    pool_buf = frame_pool_alloc();
+    if (!pool_buf)
+        return AVERROR(ENOMEM);
+    pool = (FramePool*)pool_buf->data;
+
+    switch (avctx->codec_type) {
+    case AVMEDIA_TYPE_VIDEO: {
+        int linesize[4];
+        int w = frame->width;
+        int h = frame->height;
+        int unaligned;
+        ptrdiff_t linesize1[4];
+        size_t size[4];
+
+        avcodec_align_dimensions2(avctx, &w, &h, pool->stride_align);
+
+        do {
+            // NOTE: do not align linesizes individually, this breaks e.g. assumptions
+            // that linesize[0] == 2*linesize[1] in the MPEG-encoder for 4:2:2
+            ret = av_image_fill_linesizes(linesize, avctx->pix_fmt, w);
+            if (ret < 0)
+                goto fail;
+            // increase alignment of w for next try (rhs gives the lowest bit set in w)
+            w += w & ~(w - 1);
+
+            unaligned = 0;
+            for (i = 0; i < 4; i++)
+                unaligned |= linesize[i] % pool->stride_align[i];
+        } while (unaligned);
+
+        for (i = 0; i < 4; i++)
+            linesize1[i] = linesize[i];
+        ret = av_image_fill_plane_sizes(size, avctx->pix_fmt, h, linesize1);
+        if (ret < 0)
+            goto fail;
+
+        for (i = 0; i < 4; i++) {
+            pool->linesize[i] = linesize[i];
+            if (size[i]) {
+                if (size[i] > INT_MAX - (16 + STRIDE_ALIGN - 1)) {
+                    ret = AVERROR(EINVAL);
+                    goto fail;
+                }
+                pool->pools[i] = av_buffer_pool_init(size[i] + 16 + STRIDE_ALIGN - 1,
+                                                     CONFIG_MEMORY_POISONING ?
+                                                        NULL :
+                                                        av_buffer_allocz);
+                if (!pool->pools[i]) {
+                    ret = AVERROR(ENOMEM);
+                    goto fail;
+                }
+            }
+        }
+        pool->format = frame->format;
+        pool->width  = frame->width;
+        pool->height = frame->height;
+
+        break;
+        }
+    case AVMEDIA_TYPE_AUDIO: {
+        ret = av_samples_get_buffer_size(&pool->linesize[0], ch,
+                                         frame->nb_samples, frame->format, 0);
+        if (ret < 0)
+            goto fail;
+
+        pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
+        if (!pool->pools[0]) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+
+        pool->format     = frame->format;
+        pool->planes     = planes;
+        pool->channels   = ch;
+        pool->samples = frame->nb_samples;
+        break;
+        }
+    default: av_assert0(0);
+    }
+
+    av_buffer_unref(&avctx->internal->pool);
+    avctx->internal->pool = pool_buf;
+
+    return 0;
+fail:
+    av_buffer_unref(&pool_buf);
+    return ret;
+}
+
+static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)
+{
+    FramePool *pool = (FramePool*)avctx->internal->pool->data;
+    int planes = pool->planes;
+    int i;
+
+    frame->linesize[0] = pool->linesize[0];
+
+    if (planes > AV_NUM_DATA_POINTERS) {
+        frame->extended_data = av_calloc(planes, sizeof(*frame->extended_data));
+        frame->nb_extended_buf = planes - AV_NUM_DATA_POINTERS;
+        frame->extended_buf  = av_calloc(frame->nb_extended_buf,
+                                          sizeof(*frame->extended_buf));
+        if (!frame->extended_data || !frame->extended_buf) {
+            av_freep(&frame->extended_data);
+            av_freep(&frame->extended_buf);
+            return AVERROR(ENOMEM);
+        }
+    } else {
+        frame->extended_data = frame->data;
+        av_assert0(frame->nb_extended_buf == 0);
+    }
+
+    for (i = 0; i < FFMIN(planes, AV_NUM_DATA_POINTERS); i++) {
+        frame->buf[i] = av_buffer_pool_get(pool->pools[0]);
+        if (!frame->buf[i])
+            goto fail;
+        frame->extended_data[i] = frame->data[i] = frame->buf[i]->data;
+    }
+    for (i = 0; i < frame->nb_extended_buf; i++) {
+        frame->extended_buf[i] = av_buffer_pool_get(pool->pools[0]);
+        if (!frame->extended_buf[i])
+            goto fail;
+        frame->extended_data[i + AV_NUM_DATA_POINTERS] = frame->extended_buf[i]->data;
+    }
+
+    if (avctx->debug & FF_DEBUG_BUFFERS)
+        av_log(avctx, AV_LOG_DEBUG, "default_get_buffer called on frame %p", frame);
+
+    return 0;
+fail:
+    av_frame_unref(frame);
+    return AVERROR(ENOMEM);
+}
+
+static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
+{
+    FramePool *pool = (FramePool*)s->internal->pool->data;
+    int i;
+
+    if (pic->data[0] || pic->data[1] || pic->data[2] || pic->data[3]) {
+        av_log(s, AV_LOG_ERROR, "pic->data[*]!=NULL in avcodec_default_get_buffer\n");
+        return -1;
+    }
+
+    memset(pic->data, 0, sizeof(pic->data));
+    pic->extended_data = pic->data;
+
+    for (i = 0; i < 4 && pool->pools[i]; i++) {
+        pic->linesize[i] = pool->linesize[i];
+
+        pic->buf[i] = av_buffer_pool_get(pool->pools[i]);
+        if (!pic->buf[i])
+            goto fail;
+
+        pic->data[i] = pic->buf[i]->data;
+    }
+    for (; i < AV_NUM_DATA_POINTERS; i++) {
+        pic->data[i] = NULL;
+        pic->linesize[i] = 0;
+    }
+
+    if (s->debug & FF_DEBUG_BUFFERS)
+        av_log(s, AV_LOG_DEBUG, "default_get_buffer called on pic %p\n", pic);
+
+    return 0;
+fail:
+    av_frame_unref(pic);
+    return AVERROR(ENOMEM);
+}
+
+int avcodec_default_get_buffer2(AVCodecContext *avctx, AVFrame *frame, int flags)
+{
+    int ret;
+
+    if (avctx->hw_frames_ctx) {
+        ret = av_hwframe_get_buffer(avctx->hw_frames_ctx, frame, 0);
+        frame->width  = avctx->coded_width;
+        frame->height = avctx->coded_height;
+        return ret;
+    }
+
+    if ((ret = update_frame_pool(avctx, frame)) < 0)
+        return ret;
+
+    switch (avctx->codec_type) {
+    case AVMEDIA_TYPE_VIDEO:
+        return video_get_buffer(avctx, frame);
+    case AVMEDIA_TYPE_AUDIO:
+        return audio_get_buffer(avctx, frame);
+    default:
+        return -1;
+    }
+}
diff -Naur a/media/ffvpx/libavcodec/golomb.c b/media/ffvpx/libavcodec/golomb.c
--- a/media/ffvpx/libavcodec/golomb.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/golomb.c	2023-04-06 12:49:40.253394890 +0200
@@ -26,7 +26,7 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#include "libavutil/common.h"
+#include <stdint.h>
 
 const uint8_t ff_golomb_vlc_len[512]={
 19,17,15,15,13,13,13,13,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
diff -Naur a/media/ffvpx/libavcodec/golomb.h b/media/ffvpx/libavcodec/golomb.h
--- a/media/ffvpx/libavcodec/golomb.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/golomb.h	2023-04-06 12:49:40.253394890 +0200
@@ -33,14 +33,12 @@
 #include <stdint.h>
 
 #include "get_bits.h"
-#include "put_bits.h"
 
 #define INVALID_VLC           0x80000000
 
 extern const uint8_t ff_golomb_vlc_len[512];
 extern const uint8_t ff_ue_golomb_vlc_code[512];
 extern const  int8_t ff_se_golomb_vlc_code[512];
-extern const uint8_t ff_ue_golomb_len[256];
 
 extern const uint8_t ff_interleaved_golomb_vlc_len[256];
 extern const uint8_t ff_interleaved_ue_golomb_vlc_code[256];
@@ -615,135 +613,4 @@
 #define get_te0_golomb(a, r) get_te(a, r, __FILE__, __func__, __LINE__)
 
 #endif /* TRACE */
-
-/**
- * write unsigned exp golomb code. 2^16 - 2 at most
- */
-static inline void set_ue_golomb(PutBitContext *pb, int i)
-{
-    av_assert2(i >= 0);
-    av_assert2(i <= 0xFFFE);
-
-    if (i < 256)
-        put_bits(pb, ff_ue_golomb_len[i], i + 1);
-    else {
-        int e = av_log2(i + 1);
-        put_bits(pb, 2 * e + 1, i + 1);
-    }
-}
-
-/**
- * write unsigned exp golomb code. 2^32-2 at most.
- */
-static inline void set_ue_golomb_long(PutBitContext *pb, uint32_t i)
-{
-    av_assert2(i <= (UINT32_MAX - 1));
-
-    if (i < 256)
-        put_bits(pb, ff_ue_golomb_len[i], i + 1);
-    else {
-        int e = av_log2(i + 1);
-        put_bits64(pb, 2 * e + 1, i + 1);
-    }
-}
-
-/**
- * write truncated unsigned exp golomb code.
- */
-static inline void set_te_golomb(PutBitContext *pb, int i, int range)
-{
-    av_assert2(range >= 1);
-    av_assert2(i <= range);
-
-    if (range == 2)
-        put_bits(pb, 1, i ^ 1);
-    else
-        set_ue_golomb(pb, i);
-}
-
-/**
- * write signed exp golomb code. 16 bits at most.
- */
-static inline void set_se_golomb(PutBitContext *pb, int i)
-{
-    i = 2 * i - 1;
-    if (i < 0)
-        i ^= -1;    //FIXME check if gcc does the right thing
-    set_ue_golomb(pb, i);
-}
-
-/**
- * write unsigned golomb rice code (ffv1).
- */
-static inline void set_ur_golomb(PutBitContext *pb, int i, int k, int limit,
-                                 int esc_len)
-{
-    int e;
-
-    av_assert2(i >= 0);
-
-    e = i >> k;
-    if (e < limit)
-        put_bits(pb, e + k + 1, (1 << k) + av_mod_uintp2(i, k));
-    else
-        put_bits(pb, limit + esc_len, i - limit + 1);
-}
-
-/**
- * write unsigned golomb rice code (jpegls).
- */
-static inline void set_ur_golomb_jpegls(PutBitContext *pb, int i, int k,
-                                        int limit, int esc_len)
-{
-    int e;
-
-    av_assert2(i >= 0);
-
-    e = (i >> k) + 1;
-    if (e < limit) {
-        while (e > 31) {
-            put_bits(pb, 31, 0);
-            e -= 31;
-        }
-        put_bits(pb, e, 1);
-        if (k)
-            put_sbits(pb, k, i);
-    } else {
-        while (limit > 31) {
-            put_bits(pb, 31, 0);
-            limit -= 31;
-        }
-        put_bits(pb, limit, 1);
-        put_bits(pb, esc_len, i - 1);
-    }
-}
-
-/**
- * write signed golomb rice code (ffv1).
- */
-static inline void set_sr_golomb(PutBitContext *pb, int i, int k, int limit,
-                                 int esc_len)
-{
-    int v;
-
-    v  = -2 * i - 1;
-    v ^= (v >> 31);
-
-    set_ur_golomb(pb, v, k, limit, esc_len);
-}
-
-/**
- * write signed golomb rice code (flac).
- */
-static inline void set_sr_golomb_flac(PutBitContext *pb, int i, int k,
-                                      int limit, int esc_len)
-{
-    int v;
-
-    v  = -2 * i - 1;
-    v ^= (v >> 31);
-
-    set_ur_golomb_jpegls(pb, v, k, limit, esc_len);
-}
-
 #endif /* AVCODEC_GOLOMB_H */
diff -Naur a/media/ffvpx/libavcodec/h264chroma.h b/media/ffvpx/libavcodec/h264chroma.h
--- a/media/ffvpx/libavcodec/h264chroma.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/h264chroma.h	2023-04-06 12:50:06.972471094 +0200
@@ -22,7 +22,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
-typedef void (*h264_chroma_mc_func)(uint8_t *dst /*align 8*/, uint8_t *src /*align 1*/, ptrdiff_t srcStride, int h, int x, int y);
+typedef void (*h264_chroma_mc_func)(uint8_t *dst /*align 8*/, const uint8_t *src /*align 1*/, ptrdiff_t srcStride, int h, int x, int y);
 
 typedef struct H264ChromaContext {
     h264_chroma_mc_func put_h264_chroma_pixels_tab[4];
@@ -36,5 +36,6 @@
 void ff_h264chroma_init_ppc(H264ChromaContext *c, int bit_depth);
 void ff_h264chroma_init_x86(H264ChromaContext *c, int bit_depth);
 void ff_h264chroma_init_mips(H264ChromaContext *c, int bit_depth);
+void ff_h264chroma_init_loongarch(H264ChromaContext *c, int bit_depth);
 
 #endif /* AVCODEC_H264CHROMA_H */
diff -Naur a/media/ffvpx/libavcodec/h264dsp.h b/media/ffvpx/libavcodec/h264dsp.h
--- a/media/ffvpx/libavcodec/h264dsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/h264dsp.h	2023-04-06 12:49:40.253394890 +0200
@@ -89,16 +89,16 @@
 
     void (*h264_idct_add16)(uint8_t *dst /*align 16*/, const int *blockoffset,
                             int16_t *block /*align 16*/, int stride,
-                            const uint8_t nnzc[15 * 8]);
+                            const uint8_t nnzc[5 * 8]);
     void (*h264_idct8_add4)(uint8_t *dst /*align 16*/, const int *blockoffset,
                             int16_t *block /*align 16*/, int stride,
-                            const uint8_t nnzc[15 * 8]);
+                            const uint8_t nnzc[5 * 8]);
     void (*h264_idct_add8)(uint8_t **dst /*align 16*/, const int *blockoffset,
                            int16_t *block /*align 16*/, int stride,
                            const uint8_t nnzc[15 * 8]);
     void (*h264_idct_add16intra)(uint8_t *dst /*align 16*/, const int *blockoffset,
                                  int16_t *block /*align 16*/,
-                                 int stride, const uint8_t nnzc[15 * 8]);
+                                 int stride, const uint8_t nnzc[5 * 8]);
     void (*h264_luma_dc_dequant_idct)(int16_t *output,
                                       int16_t *input /*align 16*/, int qmul);
     void (*h264_chroma_dc_dequant_idct)(int16_t *block, int qmul);
@@ -129,5 +129,7 @@
                          const int chroma_format_idc);
 void ff_h264dsp_init_mips(H264DSPContext *c, const int bit_depth,
                           const int chroma_format_idc);
+void ff_h264dsp_init_loongarch(H264DSPContext *c, const int bit_depth,
+                               const int chroma_format_idc);
 
 #endif /* AVCODEC_H264DSP_H */
diff -Naur a/media/ffvpx/libavcodec/h264pred.c b/media/ffvpx/libavcodec/h264pred.c
--- a/media/ffvpx/libavcodec/h264pred.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/h264pred.c	2023-04-06 12:49:40.253394890 +0200
@@ -25,11 +25,13 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
+#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/avassert.h"
 #include "libavutil/intreadwrite.h"
-#include "avcodec.h"
+#include "codec_id.h"
 #include "h264pred.h"
+#include "mathops.h"
 
 #define BIT_DEPTH 8
 #include "h264pred_template.c"
@@ -51,6 +53,30 @@
 #include "h264pred_template.c"
 #undef BIT_DEPTH
 
+static void pred4x4_127_dc_c(uint8_t *src, const uint8_t *topright,
+                             ptrdiff_t _stride)
+{
+    int stride = _stride;
+    const uint32_t a = 0x7F7F7F7FU;
+
+    AV_WN32A(src + 0 * stride, a);
+    AV_WN32A(src + 1 * stride, a);
+    AV_WN32A(src + 2 * stride, a);
+    AV_WN32A(src + 3 * stride, a);
+}
+
+static void pred4x4_129_dc_c(uint8_t *src, const uint8_t *topright,
+                             ptrdiff_t _stride)
+{
+    int stride = _stride;
+    const uint32_t a = 0x81818181U;
+
+    AV_WN32A(src + 0 * stride, a);
+    AV_WN32A(src + 1 * stride, a);
+    AV_WN32A(src + 2 * stride, a);
+    AV_WN32A(src + 3 * stride, a);
+}
+
 static void pred4x4_vertical_vp8_c(uint8_t *src, const uint8_t *topright,
                                    ptrdiff_t stride)
 {
@@ -419,56 +445,19 @@
 #define FUNCD(a) a ## _c
 
 #define H264_PRED(depth) \
-    if(codec_id != AV_CODEC_ID_RV40){\
-        if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {\
-            h->pred4x4[VERT_PRED       ]= FUNCD(pred4x4_vertical_vp8);\
-            h->pred4x4[HOR_PRED        ]= FUNCD(pred4x4_horizontal_vp8);\
-        } else {\
-            h->pred4x4[VERT_PRED       ]= FUNCC(pred4x4_vertical          , depth);\
-            h->pred4x4[HOR_PRED        ]= FUNCC(pred4x4_horizontal        , depth);\
-        }\
-        h->pred4x4[DC_PRED             ]= FUNCC(pred4x4_dc                , depth);\
-        if(codec_id == AV_CODEC_ID_SVQ3)\
-            h->pred4x4[DIAG_DOWN_LEFT_PRED ]= FUNCD(pred4x4_down_left_svq3);\
-        else\
-            h->pred4x4[DIAG_DOWN_LEFT_PRED ]= FUNCC(pred4x4_down_left     , depth);\
-        h->pred4x4[DIAG_DOWN_RIGHT_PRED]= FUNCC(pred4x4_down_right        , depth);\
-        h->pred4x4[VERT_RIGHT_PRED     ]= FUNCC(pred4x4_vertical_right    , depth);\
-        h->pred4x4[HOR_DOWN_PRED       ]= FUNCC(pred4x4_horizontal_down   , depth);\
-        if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {\
-            h->pred4x4[VERT_LEFT_PRED  ]= FUNCD(pred4x4_vertical_left_vp8);\
-        } else\
-            h->pred4x4[VERT_LEFT_PRED  ]= FUNCC(pred4x4_vertical_left     , depth);\
-        h->pred4x4[HOR_UP_PRED         ]= FUNCC(pred4x4_horizontal_up     , depth);\
-        if (codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8) {\
-            h->pred4x4[LEFT_DC_PRED    ]= FUNCC(pred4x4_left_dc           , depth);\
-            h->pred4x4[TOP_DC_PRED     ]= FUNCC(pred4x4_top_dc            , depth);\
-        } else {\
-            h->pred4x4[TM_VP8_PRED     ]= FUNCD(pred4x4_tm_vp8);\
-            h->pred4x4[DC_127_PRED     ]= FUNCC(pred4x4_127_dc            , depth);\
-            h->pred4x4[DC_129_PRED     ]= FUNCC(pred4x4_129_dc            , depth);\
-            h->pred4x4[VERT_VP8_PRED   ]= FUNCC(pred4x4_vertical          , depth);\
-            h->pred4x4[HOR_VP8_PRED    ]= FUNCC(pred4x4_horizontal        , depth);\
-        }\
-        if (codec_id != AV_CODEC_ID_VP8)\
-            h->pred4x4[DC_128_PRED     ]= FUNCC(pred4x4_128_dc            , depth);\
-    }else{\
-        h->pred4x4[VERT_PRED           ]= FUNCC(pred4x4_vertical          , depth);\
-        h->pred4x4[HOR_PRED            ]= FUNCC(pred4x4_horizontal        , depth);\
-        h->pred4x4[DC_PRED             ]= FUNCC(pred4x4_dc                , depth);\
-        h->pred4x4[DIAG_DOWN_LEFT_PRED ]= FUNCD(pred4x4_down_left_rv40);\
-        h->pred4x4[DIAG_DOWN_RIGHT_PRED]= FUNCC(pred4x4_down_right        , depth);\
-        h->pred4x4[VERT_RIGHT_PRED     ]= FUNCC(pred4x4_vertical_right    , depth);\
-        h->pred4x4[HOR_DOWN_PRED       ]= FUNCC(pred4x4_horizontal_down   , depth);\
-        h->pred4x4[VERT_LEFT_PRED      ]= FUNCD(pred4x4_vertical_left_rv40);\
-        h->pred4x4[HOR_UP_PRED         ]= FUNCD(pred4x4_horizontal_up_rv40);\
-        h->pred4x4[LEFT_DC_PRED        ]= FUNCC(pred4x4_left_dc           , depth);\
-        h->pred4x4[TOP_DC_PRED         ]= FUNCC(pred4x4_top_dc            , depth);\
-        h->pred4x4[DC_128_PRED         ]= FUNCC(pred4x4_128_dc            , depth);\
-        h->pred4x4[DIAG_DOWN_LEFT_PRED_RV40_NODOWN]= FUNCD(pred4x4_down_left_rv40_nodown);\
-        h->pred4x4[HOR_UP_PRED_RV40_NODOWN]= FUNCD(pred4x4_horizontal_up_rv40_nodown);\
-        h->pred4x4[VERT_LEFT_PRED_RV40_NODOWN]= FUNCD(pred4x4_vertical_left_rv40_nodown);\
-    }\
+    h->pred4x4[VERT_PRED           ] = FUNCC(pred4x4_vertical,        depth);\
+    h->pred4x4[HOR_PRED            ] = FUNCC(pred4x4_horizontal,      depth);\
+    h->pred4x4[DC_PRED             ] = FUNCC(pred4x4_dc,              depth);\
+    h->pred4x4[DIAG_DOWN_LEFT_PRED ] = FUNCC(pred4x4_down_left,       depth);\
+    h->pred4x4[DIAG_DOWN_RIGHT_PRED] = FUNCC(pred4x4_down_right,      depth);\
+    h->pred4x4[VERT_RIGHT_PRED     ] = FUNCC(pred4x4_vertical_right,  depth);\
+    h->pred4x4[HOR_DOWN_PRED       ] = FUNCC(pred4x4_horizontal_down, depth);\
+    h->pred4x4[VERT_LEFT_PRED      ] = FUNCC(pred4x4_vertical_left,   depth);\
+    h->pred4x4[HOR_UP_PRED         ] = FUNCC(pred4x4_horizontal_up,   depth);\
+    h->pred4x4[LEFT_DC_PRED        ] = FUNCC(pred4x4_left_dc,         depth);\
+    h->pred4x4[TOP_DC_PRED         ] = FUNCC(pred4x4_top_dc,          depth);\
+    if (depth > 8 || codec_id != AV_CODEC_ID_VP8)\
+        h->pred4x4[DC_128_PRED     ] = FUNCC(pred4x4_128_dc,          depth);\
 \
     h->pred8x8l[VERT_PRED           ]= FUNCC(pred8x8l_vertical            , depth);\
     h->pred8x8l[HOR_PRED            ]= FUNCC(pred8x8l_horizontal          , depth);\
@@ -486,20 +475,15 @@
     if (chroma_format_idc <= 1) {\
         h->pred8x8[VERT_PRED8x8   ]= FUNCC(pred8x8_vertical               , depth);\
         h->pred8x8[HOR_PRED8x8    ]= FUNCC(pred8x8_horizontal             , depth);\
+        h->pred8x8[PLANE_PRED8x8] = FUNCC(pred8x8_plane,       depth);\
     } else {\
         h->pred8x8[VERT_PRED8x8   ]= FUNCC(pred8x16_vertical              , depth);\
         h->pred8x8[HOR_PRED8x8    ]= FUNCC(pred8x16_horizontal            , depth);\
+        h->pred8x8[PLANE_PRED8x8] = FUNCC(pred8x16_plane,      depth);\
     }\
-    if (codec_id != AV_CODEC_ID_VP7 && codec_id != AV_CODEC_ID_VP8) {\
-        if (chroma_format_idc <= 1) {\
-            h->pred8x8[PLANE_PRED8x8]= FUNCC(pred8x8_plane                , depth);\
-        } else {\
-            h->pred8x8[PLANE_PRED8x8]= FUNCC(pred8x16_plane               , depth);\
-        }\
-    } else\
-        h->pred8x8[PLANE_PRED8x8]= FUNCD(pred8x8_tm_vp8);\
-    if (codec_id != AV_CODEC_ID_RV40 && codec_id != AV_CODEC_ID_VP7 && \
-        codec_id != AV_CODEC_ID_VP8) {\
+    if (depth > 8 || (codec_id != AV_CODEC_ID_RV40 && \
+                      codec_id != AV_CODEC_ID_VP7  && \
+                      codec_id != AV_CODEC_ID_VP8)) { \
         if (chroma_format_idc <= 1) {\
             h->pred8x8[DC_PRED8x8     ]= FUNCC(pred8x8_dc                     , depth);\
             h->pred8x8[LEFT_DC_PRED8x8]= FUNCC(pred8x8_left_dc                , depth);\
@@ -521,10 +505,6 @@
         h->pred8x8[DC_PRED8x8     ]= FUNCD(pred8x8_dc_rv40);\
         h->pred8x8[LEFT_DC_PRED8x8]= FUNCD(pred8x8_left_dc_rv40);\
         h->pred8x8[TOP_DC_PRED8x8 ]= FUNCD(pred8x8_top_dc_rv40);\
-        if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {\
-            h->pred8x8[DC_127_PRED8x8]= FUNCC(pred8x8_127_dc              , depth);\
-            h->pred8x8[DC_129_PRED8x8]= FUNCC(pred8x8_129_dc              , depth);\
-        }\
     }\
     if (chroma_format_idc <= 1) {\
         h->pred8x8[DC_128_PRED8x8 ]= FUNCC(pred8x8_128_dc                 , depth);\
@@ -535,23 +515,7 @@
     h->pred16x16[DC_PRED8x8     ]= FUNCC(pred16x16_dc                     , depth);\
     h->pred16x16[VERT_PRED8x8   ]= FUNCC(pred16x16_vertical               , depth);\
     h->pred16x16[HOR_PRED8x8    ]= FUNCC(pred16x16_horizontal             , depth);\
-    switch(codec_id){\
-    case AV_CODEC_ID_SVQ3:\
-       h->pred16x16[PLANE_PRED8x8  ]= FUNCD(pred16x16_plane_svq3);\
-       break;\
-    case AV_CODEC_ID_RV40:\
-       h->pred16x16[PLANE_PRED8x8  ]= FUNCD(pred16x16_plane_rv40);\
-       break;\
-    case AV_CODEC_ID_VP7:\
-    case AV_CODEC_ID_VP8:\
-       h->pred16x16[PLANE_PRED8x8  ]= FUNCD(pred16x16_tm_vp8);\
-       h->pred16x16[DC_127_PRED8x8]= FUNCC(pred16x16_127_dc               , depth);\
-       h->pred16x16[DC_129_PRED8x8]= FUNCC(pred16x16_129_dc               , depth);\
-       break;\
-    default:\
-       h->pred16x16[PLANE_PRED8x8  ]= FUNCC(pred16x16_plane               , depth);\
-       break;\
-    }\
+    h->pred16x16[PLANE_PRED8x8  ]= FUNCC(pred16x16_plane                  , depth);\
     h->pred16x16[LEFT_DC_PRED8x8]= FUNCC(pred16x16_left_dc                , depth);\
     h->pred16x16[TOP_DC_PRED8x8 ]= FUNCC(pred16x16_top_dc                 , depth);\
     h->pred16x16[DC_128_PRED8x8 ]= FUNCC(pred16x16_128_dc                 , depth);\
@@ -564,8 +528,8 @@
     h->pred8x8l_filter_add [VERT_PRED   ]= FUNCC(pred8x8l_vertical_filter_add           , depth);\
     h->pred8x8l_filter_add [ HOR_PRED   ]= FUNCC(pred8x8l_horizontal_filter_add         , depth);\
     if (chroma_format_idc <= 1) {\
-    h->pred8x8_add  [VERT_PRED8x8]= FUNCC(pred8x8_vertical_add            , depth);\
-    h->pred8x8_add  [ HOR_PRED8x8]= FUNCC(pred8x8_horizontal_add          , depth);\
+        h->pred8x8_add[VERT_PRED8x8] = FUNCC(pred8x8_vertical_add,    depth);\
+        h->pred8x8_add[ HOR_PRED8x8] = FUNCC(pred8x8_horizontal_add,  depth);\
     } else {\
         h->pred8x8_add  [VERT_PRED8x8]= FUNCC(pred8x16_vertical_add            , depth);\
         h->pred8x8_add  [ HOR_PRED8x8]= FUNCC(pred8x16_horizontal_add          , depth);\
@@ -589,15 +553,50 @@
         default:
             av_assert0(bit_depth<=8);
             H264_PRED(8)
+            switch (codec_id) {
+            case AV_CODEC_ID_SVQ3:
+                h->pred4x4[DIAG_DOWN_LEFT_PRED] = FUNCD(pred4x4_down_left_svq3);
+                h->pred16x16[PLANE_PRED8x8    ] = FUNCD(pred16x16_plane_svq3);
+                break;
+            case AV_CODEC_ID_RV40:
+                h->pred4x4[DIAG_DOWN_LEFT_PRED] = FUNCD(pred4x4_down_left_rv40);
+                h->pred4x4[VERT_LEFT_PRED     ] = FUNCD(pred4x4_vertical_left_rv40);
+                h->pred4x4[HOR_UP_PRED        ] = FUNCD(pred4x4_horizontal_up_rv40);
+                h->pred4x4[DIAG_DOWN_LEFT_PRED_RV40_NODOWN] = FUNCD(pred4x4_down_left_rv40_nodown);
+                h->pred4x4[HOR_UP_PRED_RV40_NODOWN] = FUNCD(pred4x4_horizontal_up_rv40_nodown);
+                h->pred4x4[VERT_LEFT_PRED_RV40_NODOWN] = FUNCD(pred4x4_vertical_left_rv40_nodown);
+                h->pred16x16[PLANE_PRED8x8    ] = FUNCD(pred16x16_plane_rv40);
+                break;
+            case AV_CODEC_ID_VP7:
+            case AV_CODEC_ID_VP8:
+                h->pred4x4[VERT_PRED       ] = FUNCD(pred4x4_vertical_vp8);
+                h->pred4x4[HOR_PRED        ] = FUNCD(pred4x4_horizontal_vp8);
+                h->pred4x4[VERT_LEFT_PRED  ] = FUNCD(pred4x4_vertical_left_vp8);
+                h->pred4x4[TM_VP8_PRED     ] = FUNCD(pred4x4_tm_vp8);
+                h->pred4x4[VERT_VP8_PRED   ] = FUNCC(pred4x4_vertical, 8);
+                h->pred4x4[DC_127_PRED     ] = FUNCD(pred4x4_127_dc);
+                h->pred4x4[DC_129_PRED     ] = FUNCD(pred4x4_129_dc);
+                h->pred4x4[HOR_VP8_PRED    ] = FUNCC(pred4x4_horizontal, 8);
+                h->pred8x8[PLANE_PRED8x8   ] = FUNCD(pred8x8_tm_vp8);
+                h->pred8x8[DC_127_PRED8x8  ] = FUNCC(pred8x8_127_dc, 8);
+                h->pred8x8[DC_129_PRED8x8  ] = FUNCC(pred8x8_129_dc, 8);
+                h->pred16x16[PLANE_PRED8x8 ] = FUNCD(pred16x16_tm_vp8);
+                h->pred16x16[DC_127_PRED8x8] = FUNCC(pred16x16_127_dc, 8);
+                h->pred16x16[DC_129_PRED8x8] = FUNCC(pred16x16_129_dc, 8);
+                break;
+            }
             break;
     }
 
-    if (ARCH_AARCH64)
-        ff_h264_pred_init_aarch64(h, codec_id, bit_depth, chroma_format_idc);
-    if (ARCH_ARM)
-        ff_h264_pred_init_arm(h, codec_id, bit_depth, chroma_format_idc);
-    if (ARCH_X86)
-        ff_h264_pred_init_x86(h, codec_id, bit_depth, chroma_format_idc);
-    if (ARCH_MIPS)
-        ff_h264_pred_init_mips(h, codec_id, bit_depth, chroma_format_idc);
+#if ARCH_AARCH64
+    ff_h264_pred_init_aarch64(h, codec_id, bit_depth, chroma_format_idc);
+#elif ARCH_ARM
+    ff_h264_pred_init_arm(h, codec_id, bit_depth, chroma_format_idc);
+#elif ARCH_X86
+    ff_h264_pred_init_x86(h, codec_id, bit_depth, chroma_format_idc);
+#elif ARCH_MIPS
+    ff_h264_pred_init_mips(h, codec_id, bit_depth, chroma_format_idc);
+#elif ARCH_LOONGARCH
+    ff_h264_pred_init_loongarch(h, codec_id, bit_depth, chroma_format_idc);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/h264pred.h b/media/ffvpx/libavcodec/h264pred.h
--- a/media/ffvpx/libavcodec/h264pred.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/h264pred.h	2023-04-06 12:49:40.253394890 +0200
@@ -86,6 +86,8 @@
 #define DC_129_PRED8x8         8
 //@}
 
+#define PART_NOT_AVAILABLE -2
+
 /**
  * Context for storing H.264 prediction functions
  */
@@ -122,5 +124,7 @@
                            const int bit_depth, const int chroma_format_idc);
 void ff_h264_pred_init_mips(H264PredContext *h, int codec_id,
                             const int bit_depth, const int chroma_format_idc);
+void ff_h264_pred_init_loongarch(H264PredContext *h, int codec_id,
+                                 const int bit_depth, const int chroma_format_idc);
 
 #endif /* AVCODEC_H264PRED_H */
diff -Naur a/media/ffvpx/libavcodec/h264pred_template.c b/media/ffvpx/libavcodec/h264pred_template.c
--- a/media/ffvpx/libavcodec/h264pred_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/h264pred_template.c	2023-04-06 12:49:40.253394890 +0200
@@ -111,32 +111,6 @@
     AV_WN4PA(src+3*stride, a);
 }
 
-static void FUNCC(pred4x4_127_dc)(uint8_t *_src, const uint8_t *topright,
-                                  ptrdiff_t _stride)
-{
-    pixel *src = (pixel*)_src;
-    int stride = _stride>>(sizeof(pixel)-1);
-    const pixel4 a = PIXEL_SPLAT_X4((1<<(BIT_DEPTH-1))-1);
-
-    AV_WN4PA(src+0*stride, a);
-    AV_WN4PA(src+1*stride, a);
-    AV_WN4PA(src+2*stride, a);
-    AV_WN4PA(src+3*stride, a);
-}
-
-static void FUNCC(pred4x4_129_dc)(uint8_t *_src, const uint8_t *topright,
-                                  ptrdiff_t _stride)
-{
-    pixel *src = (pixel*)_src;
-    int stride = _stride>>(sizeof(pixel)-1);
-    const pixel4 a = PIXEL_SPLAT_X4((1<<(BIT_DEPTH-1))+1);
-
-    AV_WN4PA(src+0*stride, a);
-    AV_WN4PA(src+1*stride, a);
-    AV_WN4PA(src+2*stride, a);
-    AV_WN4PA(src+3*stride, a);
-}
-
 
 #define LOAD_TOP_RIGHT_EDGE\
     const unsigned av_unused t4 = topright[0];\
@@ -427,9 +401,11 @@
     PREDICT_16x16_DC(PIXEL_SPLAT_X4(v));\
 }
 
-PRED16x16_X(127, (1<<(BIT_DEPTH-1))-1)
 PRED16x16_X(128, (1<<(BIT_DEPTH-1))+0)
+#if BIT_DEPTH == 8
+PRED16x16_X(127, (1<<(BIT_DEPTH-1))-1)
 PRED16x16_X(129, (1<<(BIT_DEPTH-1))+1)
+#endif
 
 static inline void FUNCC(pred16x16_plane_compat)(uint8_t *_src,
                                                  ptrdiff_t _stride,
@@ -551,9 +527,11 @@
     }\
 }
 
-PRED8x8_X(127, (1<<(BIT_DEPTH-1))-1)
 PRED8x8_X(128, (1<<(BIT_DEPTH-1))+0)
+#if BIT_DEPTH == 8
+PRED8x8_X(127, (1<<(BIT_DEPTH-1))-1)
 PRED8x8_X(129, (1<<(BIT_DEPTH-1))+1)
+#endif
 
 static void FUNCC(pred8x16_128_dc)(uint8_t *_src, ptrdiff_t stride)
 {
diff -Naur a/media/ffvpx/libavcodec/hpeldsp.h b/media/ffvpx/libavcodec/hpeldsp.h
--- a/media/ffvpx/libavcodec/hpeldsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/hpeldsp.h	2023-04-06 12:49:40.253394890 +0200
@@ -102,5 +102,6 @@
 void ff_hpeldsp_init_ppc(HpelDSPContext *c, int flags);
 void ff_hpeldsp_init_x86(HpelDSPContext *c, int flags);
 void ff_hpeldsp_init_mips(HpelDSPContext *c, int flags);
+void ff_hpeldsp_init_loongarch(HpelDSPContext *c, int flags);
 
 #endif /* AVCODEC_HPELDSP_H */
diff -Naur a/media/ffvpx/libavcodec/hwaccels.h b/media/ffvpx/libavcodec/hwaccels.h
--- a/media/ffvpx/libavcodec/hwaccels.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/hwaccels.h	2023-04-06 12:50:06.972471094 +0200
@@ -26,6 +26,7 @@
 extern const AVHWAccel ff_av1_dxva2_hwaccel;
 extern const AVHWAccel ff_av1_nvdec_hwaccel;
 extern const AVHWAccel ff_av1_vaapi_hwaccel;
+extern const AVHWAccel ff_av1_vdpau_hwaccel;
 extern const AVHWAccel ff_h263_vaapi_hwaccel;
 extern const AVHWAccel ff_h263_videotoolbox_hwaccel;
 extern const AVHWAccel ff_h264_d3d11va_hwaccel;
@@ -47,7 +48,6 @@
 extern const AVHWAccel ff_mpeg1_nvdec_hwaccel;
 extern const AVHWAccel ff_mpeg1_vdpau_hwaccel;
 extern const AVHWAccel ff_mpeg1_videotoolbox_hwaccel;
-extern const AVHWAccel ff_mpeg1_xvmc_hwaccel;
 extern const AVHWAccel ff_mpeg2_d3d11va_hwaccel;
 extern const AVHWAccel ff_mpeg2_d3d11va2_hwaccel;
 extern const AVHWAccel ff_mpeg2_nvdec_hwaccel;
@@ -55,11 +55,11 @@
 extern const AVHWAccel ff_mpeg2_vaapi_hwaccel;
 extern const AVHWAccel ff_mpeg2_vdpau_hwaccel;
 extern const AVHWAccel ff_mpeg2_videotoolbox_hwaccel;
-extern const AVHWAccel ff_mpeg2_xvmc_hwaccel;
 extern const AVHWAccel ff_mpeg4_nvdec_hwaccel;
 extern const AVHWAccel ff_mpeg4_vaapi_hwaccel;
 extern const AVHWAccel ff_mpeg4_vdpau_hwaccel;
 extern const AVHWAccel ff_mpeg4_videotoolbox_hwaccel;
+extern const AVHWAccel ff_prores_videotoolbox_hwaccel;
 extern const AVHWAccel ff_vc1_d3d11va_hwaccel;
 extern const AVHWAccel ff_vc1_d3d11va2_hwaccel;
 extern const AVHWAccel ff_vc1_dxva2_hwaccel;
@@ -74,6 +74,7 @@
 extern const AVHWAccel ff_vp9_nvdec_hwaccel;
 extern const AVHWAccel ff_vp9_vaapi_hwaccel;
 extern const AVHWAccel ff_vp9_vdpau_hwaccel;
+extern const AVHWAccel ff_vp9_videotoolbox_hwaccel;
 extern const AVHWAccel ff_wmv3_d3d11va_hwaccel;
 extern const AVHWAccel ff_wmv3_d3d11va2_hwaccel;
 extern const AVHWAccel ff_wmv3_dxva2_hwaccel;
diff -Naur a/media/ffvpx/libavcodec/hwconfig.h b/media/ffvpx/libavcodec/hwconfig.h
--- a/media/ffvpx/libavcodec/hwconfig.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/hwconfig.h	2023-04-06 12:49:40.253394890 +0200
@@ -78,8 +78,6 @@
     HW_CONFIG_HWACCEL(1, 1, 1, VIDEOTOOLBOX, VIDEOTOOLBOX, ff_ ## codec ## _videotoolbox_hwaccel)
 #define HWACCEL_D3D11VA(codec) \
     HW_CONFIG_HWACCEL(0, 0, 1, D3D11VA_VLD,  NONE,         ff_ ## codec ## _d3d11va_hwaccel)
-#define HWACCEL_XVMC(codec) \
-    HW_CONFIG_HWACCEL(0, 0, 1, XVMC,         NONE,         ff_ ## codec ## _xvmc_hwaccel)
 
 #define HW_CONFIG_ENCODER(device, frames, ad_hoc, format, device_type_) \
     &(const AVCodecHWConfigInternal) { \
diff -Naur a/media/ffvpx/libavcodec/idctdsp.c b/media/ffvpx/libavcodec/idctdsp.c
--- a/media/ffvpx/libavcodec/idctdsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/idctdsp.c	2023-04-06 12:50:06.972471094 +0200
@@ -17,6 +17,7 @@
  */
 
 #include "config.h"
+#include "config_components.h"
 #include "libavutil/attributes.h"
 #include "libavutil/common.h"
 #include "avcodec.h"
@@ -26,24 +27,12 @@
 #include "simple_idct.h"
 #include "xvididct.h"
 
-av_cold void ff_init_scantable(uint8_t *permutation, ScanTable *st,
-                               const uint8_t *src_scantable)
+av_cold void ff_permute_scantable(uint8_t dst[64], const uint8_t src[64],
+                                  const uint8_t permutation[64])
 {
-    int i, end;
-
-    st->scantable = src_scantable;
-
-    for (i = 0; i < 64; i++) {
-        int j = src_scantable[i];
-        st->permutated[i] = permutation[j];
-    }
-
-    end = -1;
-    for (i = 0; i < 64; i++) {
-        int j = st->permutated[i];
-        if (j > end)
-            end = j;
-        st->raster_end[i] = end;
+    for (int i = 0; i < 64; i++) {
+        int j = src[i];
+        dst[i] = permutation[j];
     }
 }
 
@@ -52,10 +41,11 @@
 {
     int i;
 
-    if (ARCH_X86)
-        if (ff_init_scantable_permutation_x86(idct_permutation,
-                                              perm_type))
-            return;
+#if ARCH_X86
+    if (ff_init_scantable_permutation_x86(idct_permutation,
+                                          perm_type))
+        return;
+#endif
 
     switch (perm_type) {
     case FF_IDCT_PERM_NONE:
@@ -237,7 +227,7 @@
 
 av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)
 {
-    const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;
+    av_unused const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8;
 
     if (avctx->lowres==1) {
         c->idct_put  = ff_jref_idct4_put;
@@ -287,7 +277,6 @@
                 c->perm_type = FF_IDCT_PERM_NONE;
 #endif /* CONFIG_FAANIDCT */
             } else { // accurate/default
-                /* Be sure FF_IDCT_NONE will select this one, since it uses FF_IDCT_PERM_NONE */
                 c->idct_put  = ff_simple_idct_put_int16_8bit;
                 c->idct_add  = ff_simple_idct_add_int16_8bit;
                 c->idct      = ff_simple_idct_int16_8bit;
@@ -303,18 +292,23 @@
     if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID)
         ff_xvid_idct_init(c, avctx);
 
-    if (ARCH_AARCH64)
-        ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);
-    if (ARCH_ALPHA)
-        ff_idctdsp_init_alpha(c, avctx, high_bit_depth);
-    if (ARCH_ARM)
-        ff_idctdsp_init_arm(c, avctx, high_bit_depth);
-    if (ARCH_PPC)
-        ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
-    if (ARCH_X86)
-        ff_idctdsp_init_x86(c, avctx, high_bit_depth);
-    if (ARCH_MIPS)
-        ff_idctdsp_init_mips(c, avctx, high_bit_depth);
+#if ARCH_AARCH64
+    ff_idctdsp_init_aarch64(c, avctx, high_bit_depth);
+#elif ARCH_ALPHA
+    ff_idctdsp_init_alpha(c, avctx, high_bit_depth);
+#elif ARCH_ARM
+    ff_idctdsp_init_arm(c, avctx, high_bit_depth);
+#elif ARCH_PPC
+    ff_idctdsp_init_ppc(c, avctx, high_bit_depth);
+#elif ARCH_RISCV
+    ff_idctdsp_init_riscv(c, avctx, high_bit_depth);
+#elif ARCH_X86
+    ff_idctdsp_init_x86(c, avctx, high_bit_depth);
+#elif ARCH_MIPS
+    ff_idctdsp_init_mips(c, avctx, high_bit_depth);
+#elif ARCH_LOONGARCH
+    ff_idctdsp_init_loongarch(c, avctx, high_bit_depth);
+#endif
 
     ff_init_scantable_permutation(c->idct_permutation,
                                   c->perm_type);
diff -Naur a/media/ffvpx/libavcodec/idctdsp.h b/media/ffvpx/libavcodec/idctdsp.h
--- a/media/ffvpx/libavcodec/idctdsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/idctdsp.h	2023-04-06 12:50:06.972471094 +0200
@@ -25,15 +25,6 @@
 
 #include "avcodec.h"
 
-/**
- * Scantable.
- */
-typedef struct ScanTable {
-    const uint8_t *scantable;
-    uint8_t permutated[64];
-    uint8_t raster_end[64];
-} ScanTable;
-
 enum idct_permutation_type {
     FF_IDCT_PERM_NONE,
     FF_IDCT_PERM_LIBMPEG2,
@@ -43,8 +34,8 @@
     FF_IDCT_PERM_SSE2,
 };
 
-void ff_init_scantable(uint8_t *permutation, ScanTable *st,
-                       const uint8_t *src_scantable);
+void ff_permute_scantable(uint8_t dst[64], const uint8_t src[64],
+                          const uint8_t permutation[64]);
 void ff_init_scantable_permutation(uint8_t *idct_permutation,
                                    enum idct_permutation_type perm_type);
 int ff_init_scantable_permutation_x86(uint8_t *idct_permutation,
@@ -114,9 +105,13 @@
                          unsigned high_bit_depth);
 void ff_idctdsp_init_ppc(IDCTDSPContext *c, AVCodecContext *avctx,
                          unsigned high_bit_depth);
+void ff_idctdsp_init_riscv(IDCTDSPContext *c, AVCodecContext *avctx,
+                           unsigned high_bit_depth);
 void ff_idctdsp_init_x86(IDCTDSPContext *c, AVCodecContext *avctx,
                          unsigned high_bit_depth);
 void ff_idctdsp_init_mips(IDCTDSPContext *c, AVCodecContext *avctx,
                           unsigned high_bit_depth);
+void ff_idctdsp_init_loongarch(IDCTDSPContext *c, AVCodecContext *avctx,
+                               unsigned high_bit_depth);
 
 #endif /* AVCODEC_IDCTDSP_H */
diff -Naur a/media/ffvpx/libavcodec/imgconvert.c b/media/ffvpx/libavcodec/imgconvert.c
--- a/media/ffvpx/libavcodec/imgconvert.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/imgconvert.c	2023-04-06 12:49:40.253394890 +0200
@@ -25,46 +25,9 @@
  */
 
 #include "avcodec.h"
-#include "internal.h"
-#include "mathops.h"
-#include "libavutil/avassert.h"
-#include "libavutil/colorspace.h"
-#include "libavutil/common.h"
 #include "libavutil/pixdesc.h"
-#include "libavutil/internal.h"
-#include "libavutil/imgutils.h"
+#include "libavutil/pixfmt.h"
 
-#if FF_API_GETCHROMA
-void avcodec_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
-{
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
-    av_assert0(desc);
-    *h_shift = desc->log2_chroma_w;
-    *v_shift = desc->log2_chroma_h;
-}
-#endif
-
-#if FF_API_AVCODEC_PIX_FMT
-int avcodec_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt,
-                             enum AVPixelFormat src_pix_fmt,
-                             int has_alpha)
-{
-    return av_get_pix_fmt_loss(dst_pix_fmt, src_pix_fmt, has_alpha);
-}
-
-enum AVPixelFormat avcodec_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                            enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
-{
-    return av_find_best_pix_fmt_of_2(dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr);
-}
-
-enum AVPixelFormat avcodec_find_best_pix_fmt2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
-                                            enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
-{
-    return av_find_best_pix_fmt_of_2(dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr);
-}
-
-#endif
 enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list,
                                             enum AVPixelFormat src_pix_fmt,
                                             int has_alpha, int *loss_ptr){
@@ -83,152 +46,3 @@
     return best;
 }
 
-#if FF_API_AVPICTURE
-FF_DISABLE_DEPRECATION_WARNINGS
-/* return true if yuv planar */
-static inline int is_yuv_planar(const AVPixFmtDescriptor *desc)
-{
-    int i;
-    int planes[4] = { 0 };
-
-    if (     desc->flags & AV_PIX_FMT_FLAG_RGB
-        || !(desc->flags & AV_PIX_FMT_FLAG_PLANAR))
-        return 0;
-
-    /* set the used planes */
-    for (i = 0; i < desc->nb_components; i++)
-        planes[desc->comp[i].plane] = 1;
-
-    /* if there is an unused plane, the format is not planar */
-    for (i = 0; i < desc->nb_components; i++)
-        if (!planes[i])
-            return 0;
-    return 1;
-}
-
-int av_picture_crop(AVPicture *dst, const AVPicture *src,
-                    enum AVPixelFormat pix_fmt, int top_band, int left_band)
-{
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
-    int y_shift;
-    int x_shift;
-    int max_step[4];
-
-    if (pix_fmt < 0 || pix_fmt >= AV_PIX_FMT_NB)
-        return -1;
-
-    y_shift = desc->log2_chroma_h;
-    x_shift = desc->log2_chroma_w;
-    av_image_fill_max_pixsteps(max_step, NULL, desc);
-
-    if (is_yuv_planar(desc)) {
-    dst->data[0] = src->data[0] + (top_band * src->linesize[0]) + left_band;
-    dst->data[1] = src->data[1] + ((top_band >> y_shift) * src->linesize[1]) + (left_band >> x_shift);
-    dst->data[2] = src->data[2] + ((top_band >> y_shift) * src->linesize[2]) + (left_band >> x_shift);
-    } else{
-        if(top_band % (1<<y_shift) || left_band % (1<<x_shift))
-            return -1;
-        dst->data[0] = src->data[0] + (top_band * src->linesize[0]) + (left_band * max_step[0]);
-    }
-
-    dst->linesize[0] = src->linesize[0];
-    dst->linesize[1] = src->linesize[1];
-    dst->linesize[2] = src->linesize[2];
-    return 0;
-}
-
-int av_picture_pad(AVPicture *dst, const AVPicture *src, int height, int width,
-                   enum AVPixelFormat pix_fmt, int padtop, int padbottom, int padleft, int padright,
-            int *color)
-{
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
-    uint8_t *optr;
-    int y_shift;
-    int x_shift;
-    int yheight;
-    int i, y;
-    int max_step[4];
-
-    if (pix_fmt < 0 || pix_fmt >= AV_PIX_FMT_NB)
-        return -1;
-
-    if (!is_yuv_planar(desc)) {
-        if (src)
-            return -1; //TODO: Not yet implemented
-
-        av_image_fill_max_pixsteps(max_step, NULL, desc);
-
-        if (padtop || padleft) {
-            memset(dst->data[0], color[0],
-                    dst->linesize[0] * padtop + (padleft * max_step[0]));
-        }
-
-        if (padleft || padright) {
-            optr = dst->data[0] + dst->linesize[0] * padtop +
-                    (dst->linesize[0] - (padright * max_step[0]));
-            yheight = height - 1 - (padtop + padbottom);
-            for (y = 0; y < yheight; y++) {
-                memset(optr, color[0], (padleft + padright) * max_step[0]);
-                optr += dst->linesize[0];
-            }
-        }
-
-        if (padbottom || padright) {
-            optr = dst->data[0] + dst->linesize[0] * (height - padbottom) -
-                    (padright * max_step[0]);
-            memset(optr, color[0], dst->linesize[0] * padbottom +
-                    (padright * max_step[0]));
-        }
-
-        return 0;
-    }
-
-    for (i = 0; i < 3; i++) {
-        x_shift = i ? desc->log2_chroma_w : 0;
-        y_shift = i ? desc->log2_chroma_h : 0;
-
-        if (padtop || padleft) {
-            memset(dst->data[i], color[i],
-                dst->linesize[i] * (padtop >> y_shift) + (padleft >> x_shift));
-        }
-
-        if (padleft || padright) {
-            optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +
-                (dst->linesize[i] - (padright >> x_shift));
-            yheight = (height - 1 - (padtop + padbottom)) >> y_shift;
-            for (y = 0; y < yheight; y++) {
-                memset(optr, color[i], (padleft + padright) >> x_shift);
-                optr += dst->linesize[i];
-            }
-        }
-
-        if (src) { /* first line */
-            uint8_t *iptr = src->data[i];
-            optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +
-                    (padleft >> x_shift);
-            memcpy(optr, iptr, (width - padleft - padright) >> x_shift);
-            iptr += src->linesize[i];
-            optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +
-                (dst->linesize[i] - (padright >> x_shift));
-            yheight = (height - 1 - (padtop + padbottom)) >> y_shift;
-            for (y = 0; y < yheight; y++) {
-                memset(optr, color[i], (padleft + padright) >> x_shift);
-                memcpy(optr + ((padleft + padright) >> x_shift), iptr,
-                       (width - padleft - padright) >> x_shift);
-                iptr += src->linesize[i];
-                optr += dst->linesize[i];
-            }
-        }
-
-        if (padbottom || padright) {
-            optr = dst->data[i] + dst->linesize[i] *
-                ((height - padbottom) >> y_shift) - (padright >> x_shift);
-            memset(optr, color[i],dst->linesize[i] *
-                (padbottom >> y_shift) + (padright >> x_shift));
-        }
-    }
-
-    return 0;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif /* FF_API_AVPICTURE */
diff -Naur a/media/ffvpx/libavcodec/internal.h b/media/ffvpx/libavcodec/internal.h
--- a/media/ffvpx/libavcodec/internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/internal.h	2023-04-06 12:50:24.492176543 +0200
@@ -28,86 +28,17 @@
 
 #include "libavutil/buffer.h"
 #include "libavutil/channel_layout.h"
-#include "libavutil/fifo.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/pixfmt.h"
 #include "avcodec.h"
 #include "config.h"
 
-/**
- * The codec does not modify any global variables in the init function,
- * allowing to call the init function without locking any global mutexes.
- */
-#define FF_CODEC_CAP_INIT_THREADSAFE        (1 << 0)
-/**
- * The codec allows calling the close function for deallocation even if
- * the init function returned a failure. Without this capability flag, a
- * codec does such cleanup internally when returning failures from the
- * init function and does not expect the close function to be called at
- * all.
- */
-#define FF_CODEC_CAP_INIT_CLEANUP           (1 << 1)
-/**
- * Decoders marked with FF_CODEC_CAP_SETS_PKT_DTS want to set
- * AVFrame.pkt_dts manually. If the flag is set, decode.c won't overwrite
- * this field. If it's unset, decode.c tries to guess the pkt_dts field
- * from the input AVPacket.
- */
-#define FF_CODEC_CAP_SETS_PKT_DTS           (1 << 2)
-/**
- * The decoder extracts and fills its parameters even if the frame is
- * skipped due to the skip_frame setting.
- */
-#define FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM  (1 << 3)
-/**
- * The decoder sets the cropping fields in the output frames manually.
- * If this cap is set, the generic code will initialize output frame
- * dimensions to coded rather than display values.
- */
-#define FF_CODEC_CAP_EXPORTS_CROPPING       (1 << 4)
-/**
- * Codec initializes slice-based threading with a main function
- */
-#define FF_CODEC_CAP_SLICE_THREAD_HAS_MF    (1 << 5)
-/*
- * The codec supports frame threading and has inter-frame dependencies, so it
- * uses ff_thread_report/await_progress().
- */
-#define FF_CODEC_CAP_ALLOCATE_PROGRESS      (1 << 6)
-/**
- * Codec handles avctx->thread_count == 0 (auto) internally.
- */
-#define FF_CODEC_CAP_AUTO_THREADS           (1 << 7)
-/**
- * Codec handles output frame properties internally instead of letting the
- * internal logic derive them from AVCodecInternal.last_pkt_props.
- */
-#define FF_CODEC_CAP_SETS_FRAME_PROPS       (1 << 8)
-
-/**
- * AVCodec.codec_tags termination value
- */
-#define FF_CODEC_TAGS_END -1
-
-
-#ifdef TRACE
-#   define ff_tlog(ctx, ...) av_log(ctx, AV_LOG_TRACE, __VA_ARGS__)
-#else
-#   define ff_tlog(ctx, ...) do { } while(0)
+#if CONFIG_LCMS2
+# include "fflcms2.h"
 #endif
 
-
-#define FF_DEFAULT_QUANT_BIAS 999999
-
-#define FF_QSCALE_TYPE_MPEG1 0
-#define FF_QSCALE_TYPE_MPEG2 1
-#define FF_QSCALE_TYPE_H264  2
-#define FF_QSCALE_TYPE_VP56  3
-
 #define FF_SANE_NB_CHANNELS 512U
 
-#define FF_SIGNBIT(x) ((x) >> CHAR_BIT * sizeof(x) - 1)
-
 #if HAVE_SIMD_ALIGN_64
 #   define STRIDE_ALIGN 64 /* AVX-512 */
 #elif HAVE_SIMD_ALIGN_32
@@ -118,46 +49,45 @@
 #   define STRIDE_ALIGN 8
 #endif
 
-typedef struct DecodeSimpleContext {
-    AVPacket *in_pkt;
-} DecodeSimpleContext;
-
-typedef struct EncodeSimpleContext {
-    AVFrame *in_frame;
-} EncodeSimpleContext;
-
 typedef struct AVCodecInternal {
     /**
-     * Whether the parent AVCodecContext is a copy of the context which had
-     * init() called on it.
-     * This is used by multithreading - shared tables and picture pointers
-     * should be freed from the original context only.
+     * When using frame-threaded decoding, this field is set for the first
+     * worker thread (e.g. to decode extradata just once).
      */
     int is_copy;
 
     /**
-     * An audio frame with less than required samples has been submitted and
-     * padded with silence. Reject all subsequent frames.
+     * An audio frame with less than required samples has been submitted (and
+     * potentially padded with silence). Reject all subsequent frames.
      */
     int last_audio_frame;
 
-#if FF_API_OLD_ENCDEC
-    AVFrame *to_free;
-#endif
+    /**
+     * Audio encoders can set this flag during init to indicate that they
+     * want the small last frame to be padded to a multiple of pad_samples.
+     */
+    int pad_samples;
 
     AVBufferRef *pool;
 
     void *thread_ctx;
 
-    DecodeSimpleContext ds;
-    AVBSFContext *bsf;
+    /**
+     * This packet is used to hold the packet given to decoders
+     * implementing the .decode API; it is unused by the generic
+     * code for decoders implementing the .receive_frame API and
+     * may be freely used (but not freed) by them with the caveat
+     * that the packet will be unreferenced generically in
+     * avcodec_flush_buffers().
+     */
+    AVPacket *in_pkt;
+    struct AVBSFContext *bsf;
 
     /**
      * Properties (timestamps+side data) extracted from the last packet passed
      * for decoding.
      */
     AVPacket *last_pkt_props;
-    AVFifoBuffer *pkt_props;
 
     /**
      * temporary buffer used for encoders to store their bitstream
@@ -165,9 +95,36 @@
     uint8_t *byte_buffer;
     unsigned int byte_buffer_size;
 
+    /**
+     * This is set to AV_PKT_FLAG_KEY for encoders that encode intra-only
+     * formats (i.e. whose codec descriptor has AV_CODEC_PROP_INTRA_ONLY set).
+     * This is used to set said flag generically for said encoders.
+     */
+    int intra_only_flag;
+
     void *frame_thread_encoder;
 
-    EncodeSimpleContext es;
+    /**
+     * The input frame is stored here for encoders implementing the simple
+     * encode API.
+     *
+     * Not allocated in other cases.
+     */
+    AVFrame *in_frame;
+
+    /**
+     * When the AV_CODEC_FLAG_RECON_FRAME flag is used. the encoder should store
+     * here the reconstructed frame corresponding to the last returned packet.
+     *
+     * Not allocated in other cases.
+     */
+    AVFrame *recon_frame;
+
+    /**
+     * If this is set, then FFCodec->close (if existing) needs to be called
+     * for the parent AVCodecContext.
+     */
+    int needs_close;
 
     /**
      * Number of audio samples to skip at the start of the next decoded frame
@@ -185,28 +142,14 @@
     int draining;
 
     /**
-     * buffers for using new encode/decode API through legacy API
+     * Temporary buffers for newly received or not yet output packets/frames.
      */
     AVPacket *buffer_pkt;
     AVFrame *buffer_frame;
     int draining_done;
 
-#if FF_API_OLD_ENCDEC
-    int compat_decode_warned;
-    /* this variable is set by the decoder internals to signal to the old
-     * API compat wrappers the amount of data consumed from the last packet */
-    size_t compat_decode_consumed;
-    /* when a partial packet has been consumed, this stores the remaining size
-     * of the packet (that should be submitted in the next decode call */
-    size_t compat_decode_partial_size;
-    AVFrame *compat_decode_frame;
-    AVPacket *compat_encode_packet;
-#endif
-
     int showed_multi_packet_warning;
 
-    int skip_samples_multiplier;
-
     /* to prevent infinite loop on errors when draining */
     int nb_draining_errors;
 
@@ -215,16 +158,12 @@
     int initial_format;
     int initial_width, initial_height;
     int initial_sample_rate;
-    int initial_channels;
-    uint64_t initial_channel_layout;
-} AVCodecInternal;
-
-struct AVCodecDefault {
-    const uint8_t *key;
-    const uint8_t *value;
-};
+    AVChannelLayout initial_ch_layout;
 
-extern const uint8_t ff_log2_run[41];
+#if CONFIG_LCMS2
+    FFIccContext icc; /* used to read and write embedded ICC profiles */
+#endif
+} AVCodecInternal;
 
 /**
  * Return the index into tab at which {a,b} match elements {[0],[1]} of tab.
@@ -232,7 +171,7 @@
  */
 int ff_match_2uint16(const uint16_t (*tab)[2], int size, int a, int b);
 
-unsigned int avpriv_toupper4(unsigned int x);
+unsigned int ff_toupper4(unsigned int x);
 
 void ff_color_frame(AVFrame *frame, const int color[4]);
 
@@ -244,46 +183,6 @@
 #define FF_MAX_EXTRADATA_SIZE ((1 << 28) - AV_INPUT_BUFFER_PADDING_SIZE)
 
 /**
- * Check AVPacket size and/or allocate data.
- *
- * Encoders supporting AVCodec.encode2() can use this as a convenience to
- * ensure the output packet data is large enough, whether provided by the user
- * or allocated in this function.
- *
- * @param avctx   the AVCodecContext of the encoder
- * @param avpkt   the AVPacket
- *                If avpkt->data is already set, avpkt->size is checked
- *                to ensure it is large enough.
- *                If avpkt->data is NULL, a new buffer is allocated.
- *                avpkt->size is set to the specified size.
- *                All other AVPacket fields will be reset with av_init_packet().
- * @param size    the minimum required packet size
- * @param min_size This is a hint to the allocation algorithm, which indicates
- *                to what minimal size the caller might later shrink the packet
- *                to. Encoders often allocate packets which are larger than the
- *                amount of data that is written into them as the exact amount is
- *                not known at the time of allocation. min_size represents the
- *                size a packet might be shrunk to by the caller. Can be set to
- *                0. setting this roughly correctly allows the allocation code
- *                to choose between several allocation strategies to improve
- *                speed slightly.
- * @return        non negative on success, negative error code on failure
- */
-int ff_alloc_packet2(AVCodecContext *avctx, AVPacket *avpkt, int64_t size, int64_t min_size);
-
-/**
- * Rescale from sample rate to AVCodecContext.time_base.
- */
-static av_always_inline int64_t ff_samples_to_time_base(AVCodecContext *avctx,
-                                                        int64_t samples)
-{
-    if(samples == AV_NOPTS_VALUE)
-        return AV_NOPTS_VALUE;
-    return av_rescale_q(samples, (AVRational){ 1, avctx->sample_rate },
-                        avctx->time_base);
-}
-
-/**
  * 2^(x) for integer x
  * @return correctly rounded float
  */
@@ -302,62 +201,11 @@
         return 0;
 }
 
-/**
- * Get a buffer for a frame. This is a wrapper around
- * AVCodecContext.get_buffer() and should be used instead calling get_buffer()
- * directly.
- */
-int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags);
-
-#define FF_REGET_BUFFER_FLAG_READONLY 1 ///< the returned buffer does not need to be writable
-/**
- * Identical in function to ff_get_buffer(), except it reuses the existing buffer
- * if available.
- */
-int ff_reget_buffer(AVCodecContext *avctx, AVFrame *frame, int flags);
-
-int ff_thread_can_start_frame(AVCodecContext *avctx);
-
 int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx);
 
-const uint8_t *avpriv_find_start_code(const uint8_t *p,
-                                      const uint8_t *end,
-                                      uint32_t *state);
-
 int avpriv_codec_get_cap_skip_frame_fill_param(const AVCodec *codec);
 
 /**
- * Check that the provided frame dimensions are valid and set them on the codec
- * context.
- */
-int ff_set_dimensions(AVCodecContext *s, int width, int height);
-
-/**
- * Check that the provided sample aspect ratio is valid and set it on the codec
- * context.
- */
-int ff_set_sar(AVCodecContext *avctx, AVRational sar);
-
-/**
- * Add or update AV_FRAME_DATA_MATRIXENCODING side data.
- */
-int ff_side_data_update_matrix_encoding(AVFrame *frame,
-                                        enum AVMatrixEncoding matrix_encoding);
-
-/**
- * Select the (possibly hardware accelerated) pixel format.
- * This is a wrapper around AVCodecContext.get_format() and should be used
- * instead of calling get_format() directly.
- *
- * The list of pixel formats must contain at least one valid entry, and is
- * terminated with AV_PIX_FMT_NONE.  If it is possible to decode to software,
- * the last entry in the list must be the most accurate software format.
- * If it is not possible to decode to software, AVCodecContext.sw_pix_fmt
- * must be set before calling this function.
- */
-int ff_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt);
-
-/**
  * Add a CPB properties side data to an encoding context.
  */
 AVCPBProperties *ff_add_cpb_side_data(AVCodecContext *avctx);
@@ -396,12 +244,4 @@
 int ff_int_from_list_or_default(void *ctx, const char * val_name, int val,
                                 const int * array_valid_values, int default_value);
 
-void ff_dvdsub_parse_palette(uint32_t *palette, const char *p);
-
-#if defined(_WIN32) && CONFIG_SHARED && !defined(BUILDING_avcodec)
-#    define av_export_avcodec __declspec(dllimport)
-#else
-#    define av_export_avcodec
-#endif
-
 #endif /* AVCODEC_INTERNAL_H */
diff -Naur a/media/ffvpx/libavcodec/jfdctfst.c b/media/ffvpx/libavcodec/jfdctfst.c
--- a/media/ffvpx/libavcodec/jfdctfst.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/jfdctfst.c	2023-04-06 12:49:40.253394890 +0200
@@ -66,9 +66,8 @@
  * Independent JPEG Group's fast AAN dct.
  */
 
-#include <stdlib.h>
-#include <stdio.h>
-#include "libavutil/common.h"
+#include <stdint.h>
+#include "libavutil/attributes.h"
 #include "dct.h"
 
 #define DCTSIZE 8
diff -Naur a/media/ffvpx/libavcodec/jrevdct.c b/media/ffvpx/libavcodec/jrevdct.c
--- a/media/ffvpx/libavcodec/jrevdct.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/jrevdct.c	2023-04-06 12:50:06.972471094 +0200
@@ -62,7 +62,9 @@
  * Independent JPEG Group's LLM idct.
  */
 
-#include "libavutil/common.h"
+#include <stddef.h>
+#include <stdint.h>
+
 #include "libavutil/intreadwrite.h"
 
 #include "dct.h"
@@ -253,7 +255,7 @@
       if (d0) {
           /* Compute a 32 bit value to assign. */
           int16_t dcval = (int16_t) (d0 * (1 << PASS1_BITS));
-          register int v = (dcval & 0xffff) | ((dcval * (1 << 16)) & 0xffff0000);
+          register unsigned v = (dcval & 0xffff) | ((uint32_t)dcval << 16);
 
           AV_WN32A(&idataptr[ 0], v);
           AV_WN32A(&idataptr[ 4], v);
@@ -986,8 +988,8 @@
       /* AC terms all zero */
       if (d0) {
           /* Compute a 32 bit value to assign. */
-          int16_t dcval = (int16_t) (d0 << PASS1_BITS);
-          register int v = (dcval & 0xffff) | ((dcval << 16) & 0xffff0000);
+          int16_t dcval = (int16_t) (d0 * (1 << PASS1_BITS));
+          register unsigned v = (dcval & 0xffff) | ((uint32_t)dcval << 16);
 
           AV_WN32A(&idataptr[0], v);
           AV_WN32A(&idataptr[4], v);
@@ -1006,8 +1008,8 @@
                     tmp2 = z1 + MULTIPLY(-d6, FIX_1_847759065);
                     tmp3 = z1 + MULTIPLY(d2, FIX_0_765366865);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1018,8 +1020,8 @@
                     tmp2 = MULTIPLY(-d6, FIX_1_306562965);
                     tmp3 = MULTIPLY(d6, FIX_0_541196100);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1032,8 +1034,8 @@
                     tmp2 = MULTIPLY(d2, FIX_0_541196100);
                     tmp3 = MULTIPLY(d2, FIX_1_306562965);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1041,8 +1043,8 @@
                     tmp12 = tmp1 - tmp2;
             } else {
                     /* d0 != 0, d2 == 0, d4 != 0, d6 == 0 */
-                    tmp10 = tmp13 = (d0 + d4) << CONST_BITS;
-                    tmp11 = tmp12 = (d0 - d4) << CONST_BITS;
+                    tmp10 = tmp13 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp11 = tmp12 = (d0 - d4) * (1 << CONST_BITS);
             }
       }
 
@@ -1084,8 +1086,8 @@
                     tmp2 = z1 + MULTIPLY(-d6, FIX_1_847759065);
                     tmp3 = z1 + MULTIPLY(d2, FIX_0_765366865);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1096,8 +1098,8 @@
                     tmp2 = MULTIPLY(-d6, FIX_1_306562965);
                     tmp3 = MULTIPLY(d6, FIX_0_541196100);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1110,8 +1112,8 @@
                     tmp2 = MULTIPLY(d2, FIX_0_541196100);
                     tmp3 = MULTIPLY(d2, FIX_1_306562965);
 
-                    tmp0 = (d0 + d4) << CONST_BITS;
-                    tmp1 = (d0 - d4) << CONST_BITS;
+                    tmp0 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp1 = (d0 - d4) * (1 << CONST_BITS);
 
                     tmp10 = tmp0 + tmp3;
                     tmp13 = tmp0 - tmp3;
@@ -1119,8 +1121,8 @@
                     tmp12 = tmp1 - tmp2;
             } else {
                     /* d0 != 0, d2 == 0, d4 != 0, d6 == 0 */
-                    tmp10 = tmp13 = (d0 + d4) << CONST_BITS;
-                    tmp11 = tmp12 = (d0 - d4) << CONST_BITS;
+                    tmp10 = tmp13 = (d0 + d4) * (1 << CONST_BITS);
+                    tmp11 = tmp12 = (d0 - d4) * (1 << CONST_BITS);
             }
     }
 
diff -Naur a/media/ffvpx/libavcodec/libdav1d.c b/media/ffvpx/libavcodec/libdav1d.c
--- a/media/ffvpx/libavcodec/libdav1d.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/libdav1d.c	2023-04-06 12:50:24.492176543 +0200
@@ -19,9 +19,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "dav1d/dav1d.h"
+#include <dav1d/dav1d.h>
 
 #include "libavutil/avassert.h"
+#include "libavutil/cpu.h"
 #include "libavutil/film_grain_params.h"
 #include "libavutil/mastering_display_metadata.h"
 #include "libavutil/imgutils.h"
@@ -30,6 +31,7 @@
 #include "atsc_a53.h"
 #include "avcodec.h"
 #include "bytestream.h"
+#include "codec_internal.h"
 #include "decode.h"
 #include "internal.h"
 
@@ -45,6 +47,7 @@
     Dav1dData data;
     int tile_threads;
     int frame_threads;
+    int max_frame_delay;
     int apply_grain;
     int operating_point;
     int all_layers;
@@ -123,11 +126,94 @@
     av_buffer_unref(&buf);
 }
 
+static void libdav1d_init_params(AVCodecContext *c, const Dav1dSequenceHeader *seq)
+{
+    c->profile = seq->profile;
+    c->level = ((seq->operating_points[0].major_level - 2) << 2)
+               | seq->operating_points[0].minor_level;
+
+    switch (seq->chr) {
+    case DAV1D_CHR_VERTICAL:
+        c->chroma_sample_location = AVCHROMA_LOC_LEFT;
+        break;
+    case DAV1D_CHR_COLOCATED:
+        c->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;
+        break;
+    }
+    c->colorspace = (enum AVColorSpace) seq->mtrx;
+    c->color_primaries = (enum AVColorPrimaries) seq->pri;
+    c->color_trc = (enum AVColorTransferCharacteristic) seq->trc;
+    c->color_range = seq->color_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;
+
+    if (seq->layout == DAV1D_PIXEL_LAYOUT_I444 &&
+        seq->mtrx == DAV1D_MC_IDENTITY &&
+        seq->pri  == DAV1D_COLOR_PRI_BT709 &&
+        seq->trc  == DAV1D_TRC_SRGB)
+        c->pix_fmt = pix_fmt_rgb[seq->hbd];
+    else
+        c->pix_fmt = pix_fmt[seq->layout][seq->hbd];
+
+    if (seq->num_units_in_tick && seq->time_scale) {
+        av_reduce(&c->framerate.den, &c->framerate.num,
+                  seq->num_units_in_tick, seq->time_scale, INT_MAX);
+        if (seq->equal_picture_interval)
+            c->ticks_per_frame = seq->num_ticks_per_picture;
+    }
+
+   if (seq->film_grain_present)
+       c->properties |= FF_CODEC_PROPERTY_FILM_GRAIN;
+   else
+       c->properties &= ~FF_CODEC_PROPERTY_FILM_GRAIN;
+}
+
+static av_cold int libdav1d_parse_extradata(AVCodecContext *c)
+{
+    Dav1dSequenceHeader seq;
+    size_t offset = 0;
+    int res;
+
+    if (!c->extradata || c->extradata_size <= 0)
+        return 0;
+
+    if (c->extradata[0] & 0x80) {
+        int version = c->extradata[0] & 0x7F;
+
+        if (version != 1 || c->extradata_size < 4) {
+            int explode = !!(c->err_recognition & AV_EF_EXPLODE);
+            av_log(c, explode ? AV_LOG_ERROR : AV_LOG_WARNING,
+                   "Error decoding extradata\n");
+            return explode ? AVERROR_INVALIDDATA : 0;
+        }
+
+        // Do nothing if there are no configOBUs to parse
+        if (c->extradata_size == 4)
+            return 0;
+
+        offset = 4;
+    }
+
+    res = dav1d_parse_sequence_header(&seq, c->extradata + offset,
+                                      c->extradata_size  - offset);
+    if (res < 0)
+        return 0; // Assume no seqhdr OBUs are present
+
+    libdav1d_init_params(c, &seq);
+    res = ff_set_dimensions(c, seq.max_width, seq.max_height);
+    if (res < 0)
+        return res;
+
+    return 0;
+}
+
 static av_cold int libdav1d_init(AVCodecContext *c)
 {
     Libdav1dContext *dav1d = c->priv_data;
     Dav1dSettings s;
+#if FF_DAV1D_VERSION_AT_LEAST(6,0)
+    int threads = c->thread_count;
+#else
     int threads = (c->thread_count ? c->thread_count : av_cpu_count()) * 3 / 2;
+#endif
     int res;
 
     av_log(c, AV_LOG_INFO, "libdav1d %s\n", dav1d_version());
@@ -141,19 +227,24 @@
     s.frame_size_limit = c->max_pixels;
     if (dav1d->apply_grain >= 0)
         s.apply_grain = dav1d->apply_grain;
-    else if (c->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN)
-        s.apply_grain = 0;
+    else
+        s.apply_grain = !(c->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN);
 
     s.all_layers = dav1d->all_layers;
     if (dav1d->operating_point >= 0)
         s.operating_point = dav1d->operating_point;
+#if FF_DAV1D_VERSION_AT_LEAST(6,2)
+    s.strict_std_compliance = c->strict_std_compliance > 0;
+#endif
 
 #if FF_DAV1D_VERSION_AT_LEAST(6,0)
     if (dav1d->frame_threads || dav1d->tile_threads)
         s.n_threads = FFMAX(dav1d->frame_threads, dav1d->tile_threads);
     else
         s.n_threads = FFMIN(threads, DAV1D_MAX_THREADS);
-    s.max_frame_delay = (c->flags & AV_CODEC_FLAG_LOW_DELAY) ? 1 : s.n_threads;
+    if (dav1d->max_frame_delay > 0 && (c->flags & AV_CODEC_FLAG_LOW_DELAY))
+        av_log(c, AV_LOG_WARNING, "Low delay mode requested, forcing max_frame_delay 1\n");
+    s.max_frame_delay = (c->flags & AV_CODEC_FLAG_LOW_DELAY) ? 1 : dav1d->max_frame_delay;
     av_log(c, AV_LOG_DEBUG, "Using %d threads, %d max_frame_delay\n",
            s.n_threads, s.max_frame_delay);
 #else
@@ -163,10 +254,25 @@
     s.n_frame_threads = dav1d->frame_threads
                       ? dav1d->frame_threads
                       : FFMIN(ceil(threads / s.n_tile_threads), DAV1D_MAX_FRAME_THREADS);
+    if (dav1d->max_frame_delay > 0)
+        s.n_frame_threads = FFMIN(s.n_frame_threads, dav1d->max_frame_delay);
     av_log(c, AV_LOG_DEBUG, "Using %d frame threads, %d tile threads\n",
            s.n_frame_threads, s.n_tile_threads);
 #endif
 
+#if FF_DAV1D_VERSION_AT_LEAST(6,8)
+    if (c->skip_frame >= AVDISCARD_NONKEY)
+        s.decode_frame_type = DAV1D_DECODEFRAMETYPE_KEY;
+    else if (c->skip_frame >= AVDISCARD_NONINTRA)
+        s.decode_frame_type = DAV1D_DECODEFRAMETYPE_INTRA;
+    else if (c->skip_frame >= AVDISCARD_NONREF)
+        s.decode_frame_type = DAV1D_DECODEFRAMETYPE_REFERENCE;
+#endif
+
+    res = libdav1d_parse_extradata(c);
+    if (res < 0)
+        return res;
+
     res = dav1d_open(&dav1d->c, &s);
     if (res < 0)
         return AVERROR(ENOMEM);
@@ -182,6 +288,13 @@
     dav1d_flush(dav1d->c);
 }
 
+typedef struct OpaqueData {
+    void    *pkt_orig_opaque;
+#if FF_API_REORDERED_OPAQUE
+    int64_t  reordered_opaque;
+#endif
+} OpaqueData;
+
 static void libdav1d_data_free(const uint8_t *data, void *opaque) {
     AVBufferRef *buf = opaque;
 
@@ -189,8 +302,10 @@
 }
 
 static void libdav1d_user_data_free(const uint8_t *data, void *opaque) {
+    AVPacket *pkt = opaque;
     av_assert0(data == opaque);
-    av_free(opaque);
+    av_free(pkt->opaque);
+    av_packet_free(&pkt);
 }
 
 static int libdav1d_receive_frame(AVCodecContext *c, AVFrame *frame)
@@ -198,45 +313,68 @@
     Libdav1dContext *dav1d = c->priv_data;
     Dav1dData *data = &dav1d->data;
     Dav1dPicture pic = { 0 }, *p = &pic;
+    AVPacket *pkt;
+    OpaqueData *od = NULL;
+#if FF_DAV1D_VERSION_AT_LEAST(5,1)
+    enum Dav1dEventFlags event_flags = 0;
+#endif
     int res;
 
     if (!data->sz) {
-        AVPacket pkt = { 0 };
+        pkt = av_packet_alloc();
+
+        if (!pkt)
+            return AVERROR(ENOMEM);
 
-        res = ff_decode_get_packet(c, &pkt);
-        if (res < 0 && res != AVERROR_EOF)
+        res = ff_decode_get_packet(c, pkt);
+        if (res < 0 && res != AVERROR_EOF) {
+            av_packet_free(&pkt);
             return res;
+        }
 
-        if (pkt.size) {
-            res = dav1d_data_wrap(data, pkt.data, pkt.size, libdav1d_data_free, pkt.buf);
+        if (pkt->size) {
+            res = dav1d_data_wrap(data, pkt->data, pkt->size,
+                                  libdav1d_data_free, pkt->buf);
             if (res < 0) {
-                av_packet_unref(&pkt);
+                av_packet_free(&pkt);
                 return res;
             }
 
-            data->m.timestamp = pkt.pts;
-            data->m.offset = pkt.pos;
-            data->m.duration = pkt.duration;
-
-            pkt.buf = NULL;
-            av_packet_unref(&pkt);
-
-            if (c->reordered_opaque != AV_NOPTS_VALUE) {
-                uint8_t *reordered_opaque = av_malloc(sizeof(c->reordered_opaque));
-                if (!reordered_opaque) {
+            pkt->buf = NULL;
+
+FF_DISABLE_DEPRECATION_WARNINGS
+            if (
+#if FF_API_REORDERED_OPAQUE
+                c->reordered_opaque != AV_NOPTS_VALUE ||
+#endif
+                (pkt->opaque && (c->flags & AV_CODEC_FLAG_COPY_OPAQUE))) {
+                od = av_mallocz(sizeof(*od));
+                if (!od) {
+                    av_packet_free(&pkt);
                     dav1d_data_unref(data);
                     return AVERROR(ENOMEM);
                 }
+                od->pkt_orig_opaque  = pkt->opaque;
+#if FF_API_REORDERED_OPAQUE
+                od->reordered_opaque = c->reordered_opaque;
+#endif
+FF_ENABLE_DEPRECATION_WARNINGS
+            }
+            pkt->opaque = od;
 
-                memcpy(reordered_opaque, &c->reordered_opaque, sizeof(c->reordered_opaque));
-                res = dav1d_data_wrap_user_data(data, reordered_opaque,
-                                                libdav1d_user_data_free, reordered_opaque);
-                if (res < 0) {
-                    av_free(reordered_opaque);
-                    dav1d_data_unref(data);
-                    return res;
-                }
+            res = dav1d_data_wrap_user_data(data, (const uint8_t *)pkt,
+                                            libdav1d_user_data_free, pkt);
+            if (res < 0) {
+                av_free(pkt->opaque);
+                av_packet_free(&pkt);
+                dav1d_data_unref(data);
+                return res;
             }
+            pkt = NULL;
+        } else {
+            av_packet_free(&pkt);
+            if (res >= 0)
+                return AVERROR(EAGAIN);
         }
     }
 
@@ -244,8 +382,10 @@
     if (res < 0) {
         if (res == AVERROR(EINVAL))
             res = AVERROR_INVALIDDATA;
-        if (res != AVERROR(EAGAIN))
+        if (res != AVERROR(EAGAIN)) {
+            dav1d_data_unref(data);
             return res;
+        }
     }
 
     res = dav1d_get_picture(dav1d->c, p);
@@ -274,9 +414,16 @@
     frame->linesize[1] = p->stride[1];
     frame->linesize[2] = p->stride[1];
 
-    c->profile = p->seq_hdr->profile;
-    c->level = ((p->seq_hdr->operating_points[0].major_level - 2) << 2)
-               | p->seq_hdr->operating_points[0].minor_level;
+#if FF_DAV1D_VERSION_AT_LEAST(5,1)
+    dav1d_get_event_flags(dav1d->c, &event_flags);
+    if (c->pix_fmt == AV_PIX_FMT_NONE ||
+        event_flags & DAV1D_EVENT_FLAG_NEW_SEQUENCE)
+#endif
+    libdav1d_init_params(c, p->seq_hdr);
+    res = ff_decode_frame_props(c, frame);
+    if (res < 0)
+        goto fail;
+
     frame->width = p->p.w;
     frame->height = p->p.h;
     if (c->width != p->p.w || c->height != p->p.h) {
@@ -292,50 +439,29 @@
               INT_MAX);
     ff_set_sar(c, frame->sample_aspect_ratio);
 
-    switch (p->seq_hdr->chr) {
-    case DAV1D_CHR_VERTICAL:
-        frame->chroma_location = c->chroma_sample_location = AVCHROMA_LOC_LEFT;
-        break;
-    case DAV1D_CHR_COLOCATED:
-        frame->chroma_location = c->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;
-        break;
-    }
-    frame->colorspace = c->colorspace = (enum AVColorSpace) p->seq_hdr->mtrx;
-    frame->color_primaries = c->color_primaries = (enum AVColorPrimaries) p->seq_hdr->pri;
-    frame->color_trc = c->color_trc = (enum AVColorTransferCharacteristic) p->seq_hdr->trc;
-    frame->color_range = c->color_range = p->seq_hdr->color_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;
-
-    if (p->p.layout == DAV1D_PIXEL_LAYOUT_I444 &&
-        p->seq_hdr->mtrx == DAV1D_MC_IDENTITY &&
-        p->seq_hdr->pri  == DAV1D_COLOR_PRI_BT709 &&
-        p->seq_hdr->trc  == DAV1D_TRC_SRGB)
-        frame->format = c->pix_fmt = pix_fmt_rgb[p->seq_hdr->hbd];
-    else
-        frame->format = c->pix_fmt = pix_fmt[p->p.layout][p->seq_hdr->hbd];
-
-    if (p->m.user_data.data)
-        memcpy(&frame->reordered_opaque, p->m.user_data.data, sizeof(frame->reordered_opaque));
+    pkt = (AVPacket *)p->m.user_data.data;
+    od  = pkt->opaque;
+#if FF_API_REORDERED_OPAQUE
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (od && od->reordered_opaque != AV_NOPTS_VALUE)
+        frame->reordered_opaque = od->reordered_opaque;
     else
         frame->reordered_opaque = AV_NOPTS_VALUE;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
 
-    if (p->seq_hdr->num_units_in_tick && p->seq_hdr->time_scale) {
-        av_reduce(&c->framerate.den, &c->framerate.num,
-                  p->seq_hdr->num_units_in_tick, p->seq_hdr->time_scale, INT_MAX);
-        if (p->seq_hdr->equal_picture_interval)
-            c->ticks_per_frame = p->seq_hdr->num_ticks_per_picture;
-    }
+    // restore the original user opaque value for
+    // ff_decode_frame_props_from_pkt()
+    pkt->opaque = od ? od->pkt_orig_opaque : NULL;
+    av_freep(&od);
 
     // match timestamps and packet size
-    frame->pts = p->m.timestamp;
-#if FF_API_PKT_PTS
-FF_DISABLE_DEPRECATION_WARNINGS
-    frame->pkt_pts = p->m.timestamp;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-    frame->pkt_dts = p->m.timestamp;
-    frame->pkt_pos = p->m.offset;
-    frame->pkt_size = p->m.size;
-    frame->pkt_duration = p->m.duration;
+    res = ff_decode_frame_props_from_pkt(c, frame, pkt);
+    pkt->opaque = NULL;
+    if (res < 0)
+        goto fail;
+
+    frame->pkt_dts = pkt->pts;
     frame->key_frame = p->frame_hdr->frame_type == DAV1D_FRAME_TYPE_KEY;
 
     switch (p->frame_hdr->frame_type) {
@@ -475,12 +601,16 @@
 #ifndef DAV1D_MAX_TILE_THREADS
 #define DAV1D_MAX_TILE_THREADS DAV1D_MAX_THREADS
 #endif
+#ifndef DAV1D_MAX_FRAME_DELAY
+#define DAV1D_MAX_FRAME_DELAY DAV1D_MAX_FRAME_THREADS
+#endif
 
 #define OFFSET(x) offsetof(Libdav1dContext, x)
 #define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
 static const AVOption libdav1d_options[] = {
-    { "tilethreads", "Tile threads", OFFSET(tile_threads), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_TILE_THREADS, VD },
-    { "framethreads", "Frame threads", OFFSET(frame_threads), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_FRAME_THREADS, VD },
+    { "tilethreads", "Tile threads", OFFSET(tile_threads), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_TILE_THREADS, VD | AV_OPT_FLAG_DEPRECATED },
+    { "framethreads", "Frame threads", OFFSET(frame_threads), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_FRAME_THREADS, VD | AV_OPT_FLAG_DEPRECATED },
+    { "max_frame_delay", "Max frame delay", OFFSET(max_frame_delay), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, DAV1D_MAX_FRAME_DELAY, VD },
     { "filmgrain", "Apply Film Grain", OFFSET(apply_grain), AV_OPT_TYPE_BOOL, { .i64 = -1 }, -1, 1, VD | AV_OPT_FLAG_DEPRECATED },
     { "oppoint",  "Select an operating point of the scalable bitstream", OFFSET(operating_point), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 31, VD },
     { "alllayers", "Output all spatial layers", OFFSET(all_layers), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VD },
@@ -494,19 +624,19 @@
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
-AVCodec ff_libdav1d_decoder = {
-    .name           = "libdav1d",
-    .long_name      = NULL_IF_CONFIG_SMALL("dav1d AV1 decoder by VideoLAN"),
-    .type           = AVMEDIA_TYPE_VIDEO,
-    .id             = AV_CODEC_ID_AV1,
+const FFCodec ff_libdav1d_decoder = {
+    .p.name         = "libdav1d",
+    CODEC_LONG_NAME("dav1d AV1 decoder by VideoLAN"),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_AV1,
     .priv_data_size = sizeof(Libdav1dContext),
     .init           = libdav1d_init,
     .close          = libdav1d_close,
     .flush          = libdav1d_flush,
-    .receive_frame  = libdav1d_receive_frame,
-    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_SETS_PKT_DTS |
+    FF_CODEC_RECEIVE_FRAME_CB(libdav1d_receive_frame),
+    .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS,
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_SETS_FRAME_PROPS |
                       FF_CODEC_CAP_AUTO_THREADS,
-    .priv_class     = &libdav1d_class,
-    .wrapper_name   = "libdav1d",
+    .p.priv_class   = &libdav1d_class,
+    .p.wrapper_name = "libdav1d",
 };
diff -Naur a/media/ffvpx/libavcodec/mathops.h b/media/ffvpx/libavcodec/mathops.h
--- a/media/ffvpx/libavcodec/mathops.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mathops.h	2023-04-06 12:50:24.492176543 +0200
@@ -24,15 +24,16 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
 #include "libavutil/common.h"
-#include "libavutil/reverse.h"
 #include "config.h"
 
 #define MAX_NEG_CROP 1024
 
 extern const uint32_t ff_inverse[257];
+extern const uint8_t ff_log2_run[41];
 extern const uint8_t ff_sqrt_tab[256];
-extern const uint8_t ff_crop_tab[256 + 2 * MAX_NEG_CROP];
+extern const uint8_t attribute_visibility_hidden ff_crop_tab[256 + 2 * MAX_NEG_CROP];
 extern const uint8_t ff_zigzag_direct[64];
 extern const uint8_t ff_zigzag_scan[16+1];
 
@@ -126,6 +127,8 @@
 }
 #endif
 
+#define FF_SIGNBIT(x) ((x) >> CHAR_BIT * sizeof(x) - 1)
+
 #ifndef sign_extend
 static inline av_const int sign_extend(int val, unsigned bits)
 {
@@ -135,6 +138,15 @@
 }
 #endif
 
+#ifndef sign_extend64
+static inline av_const int64_t sign_extend64(int64_t val, unsigned bits)
+{
+    unsigned shift = 8 * sizeof(int64_t) - bits;
+    union { uint64_t u; int64_t s; } v = { (uint64_t) val << shift };
+    return v.s >> shift;
+}
+#endif
+
 #ifndef zero_extend
 static inline av_const unsigned zero_extend(unsigned val, unsigned bits)
 {
@@ -240,12 +252,4 @@
     return b.s8;
 }
 
-static av_always_inline uint32_t bitswap_32(uint32_t x)
-{
-    return (uint32_t)ff_reverse[ x        & 0xFF] << 24 |
-           (uint32_t)ff_reverse[(x >> 8)  & 0xFF] << 16 |
-           (uint32_t)ff_reverse[(x >> 16) & 0xFF] << 8  |
-           (uint32_t)ff_reverse[ x >> 24];
-}
-
 #endif /* AVCODEC_MATHOPS_H */
diff -Naur a/media/ffvpx/libavcodec/mathtables.c b/media/ffvpx/libavcodec/mathtables.c
--- a/media/ffvpx/libavcodec/mathtables.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mathtables.c	2023-04-06 12:49:40.254394930 +0200
@@ -112,3 +112,12 @@
     1 + 2 * 4, 0 + 3 * 4, 1 + 3 * 4, 2 + 2 * 4,
     3 + 1 * 4, 3 + 2 * 4, 2 + 3 * 4, 3 + 3 * 4,
 };
+
+const uint8_t ff_log2_run[41] = {
+ 0,  0,  0,  0,  1,  1,  1,  1,
+ 2,  2,  2,  2,  3,  3,  3,  3,
+ 4,  4,  5,  5,  6,  6,  7,  7,
+ 8,  9, 10, 11, 12, 13, 14, 15,
+16, 17, 18, 19, 20, 21, 22, 23,
+24,
+};
diff -Naur a/media/ffvpx/libavcodec/me_cmp.h b/media/ffvpx/libavcodec/me_cmp.h
--- a/media/ffvpx/libavcodec/me_cmp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/me_cmp.h	2023-04-06 12:50:06.972471094 +0200
@@ -21,9 +21,11 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
 #include "avcodec.h"
 
-extern const uint32_t ff_square_tab[512];
+extern const uint32_t attribute_visibility_hidden ff_square_tab[512];
 
 
 /* minimum alignment rules ;)
@@ -46,12 +48,12 @@
  * Although currently h < 4 is not used as functions with
  * width < 8 are neither used nor implemented. */
 typedef int (*me_cmp_func)(struct MpegEncContext *c,
-                           uint8_t *blk1 /* align width (8 or 16) */,
-                           uint8_t *blk2 /* align 1 */, ptrdiff_t stride,
+                           const uint8_t *blk1 /* align width (8 or 16) */,
+                           const uint8_t *blk2 /* align 1 */, ptrdiff_t stride,
                            int h);
 
 typedef struct MECmpContext {
-    int (*sum_abs_dctelem)(int16_t *block /* align 16 */);
+    int (*sum_abs_dctelem)(const int16_t *block /* align 16 */);
 
     me_cmp_func sad[6]; /* identical to pix_absAxA except additional void * */
     me_cmp_func sse[6];
@@ -80,6 +82,7 @@
 } MECmpContext;
 
 void ff_me_cmp_init(MECmpContext *c, AVCodecContext *avctx);
+void ff_me_cmp_init_aarch64(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_alpha(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_arm(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_ppc(MECmpContext *c, AVCodecContext *avctx);
diff -Naur a/media/ffvpx/libavcodec/motion_est.h b/media/ffvpx/libavcodec/motion_est.h
--- a/media/ffvpx/libavcodec/motion_est.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/motion_est.h	2023-04-06 12:50:24.492176543 +0200
@@ -51,10 +51,7 @@
     int direct_basis_mv[4][2];
     uint8_t *scratchpad;            /**< data area for the ME algo, so that
                                      * the ME does not need to malloc/free. */
-    uint8_t *best_mb;
-    uint8_t *temp_mb[2];
     uint8_t *temp;
-    int best_bits;
     uint32_t *map;                  ///< map to avoid duplicate evaluations
     uint32_t *score_map;            ///< map to store the scores
     unsigned map_generation;
@@ -77,8 +74,8 @@
     int ymax;
     int pred_x;
     int pred_y;
-    uint8_t *src[4][4];
-    uint8_t *ref[4][4];
+    const uint8_t *src[4][4];
+    const uint8_t *ref[4][4];
     int stride;
     int uvstride;
     /* temp variables for picture complexity calculation */
@@ -118,14 +115,14 @@
 
 int ff_epzs_motion_search(struct MpegEncContext *s, int *mx_ptr, int *my_ptr,
                           int P[10][2], int src_index, int ref_index,
-                          int16_t (*last_mv)[2], int ref_mv_scale, int size,
-                          int h);
+                          const int16_t (*last_mv)[2], int ref_mv_scale,
+                          int size, int h);
 
 int ff_get_mb_score(struct MpegEncContext *s, int mx, int my, int src_index,
                     int ref_index, int size, int h, int add_rate);
 
 int ff_get_best_fcode(struct MpegEncContext *s,
-                      int16_t (*mv_table)[2], int type);
+                      const int16_t (*mv_table)[2], int type);
 
 void ff_fix_long_p_mvs(struct MpegEncContext *s, int type);
 void ff_fix_long_mvs(struct MpegEncContext *s, uint8_t *field_select_table,
diff -Naur a/media/ffvpx/libavcodec/moz.build b/media/ffvpx/libavcodec/moz.build
--- a/media/ffvpx/libavcodec/moz.build	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/moz.build	2023-04-06 12:50:06.972471094 +0200
@@ -9,11 +9,12 @@
 if CONFIG['FFVPX_ASFLAGS']:
     if CONFIG['CPU_ARCH'] == 'x86' or CONFIG['CPU_ARCH'] == 'x86_64':
         DIRS += ['x86']
-    elif CONFIG['CPU_ARCH'] == 'aarch64':
-        DIRS += ['aarch64']
     elif CONFIG['CPU_ARCH'] == 'arm':
         DIRS += ['arm']
 
+if CONFIG['CPU_ARCH'] == 'aarch64':
+    DIRS += ['aarch64']
+
 SharedLibrary('mozavcodec')
 SOURCES += [
     'allcodecs.c',
@@ -40,6 +41,7 @@
     'flacdata.c',
     'flacdec.c',
     'flacdsp.c',
+    'get_buffer.c',
     'idctdsp.c',
     'jfdctfst.c',
     'jfdctint.c',
@@ -54,10 +56,12 @@
     'mpegaudiodsp_data.c',
     'mpegaudiodsp_fixed.c',
     'mpegaudiodsp_float.c',
+    'mpegaudiotabs.c',
     'null_bsf.c',
     'options.c',
     'parser.c',
     'parsers.c',
+    'profiles.c',
     'pthread.c',
     'pthread_frame.c',
     'pthread_slice.c',
@@ -65,26 +69,27 @@
     'reverse.c',
     'simple_idct.c',
     'utils.c',
+    'version.c',
+    'vlc.c',
     'vorbis_parser.c',
     'xiph.c'
 ]
 
 if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
     SOURCES += [
+        'atsc_a53.c',
         'av1dec.c',
         'avpicture.c',
-        'bitstream_filter.c',
         'cbs.c',
         'cbs_av1.c',
         'golomb.c',
         'h264pred.c',
         'imgconvert.c',
+        'libdav1d.c',
         'mathtables.c',
-        'profiles.c',
         'qsv_api.c',
         'raw.c',
         'videodsp.c',
-        'vp56rac.c',
         'vp8.c',
         'vp8_parser.c',
         'vp8dsp.c',
@@ -100,21 +105,22 @@
         'vp9lpf.c',
         'vp9mvs.c',
         'vp9prob.c',
-        'vp9recon.c'
+        'vp9recon.c',
+        'vpx_rac.c',
+    ]
+    USE_LIBS += [
+        'dav1d',
+        'media_libdav1d_asm',
     ]
     if CONFIG['MOZ_WAYLAND']:
         LOCAL_INCLUDES += ['/media/mozva']
         SOURCES += [
-            'atsc_a53.c',
-            'libdav1d.c',
             'vaapi_av1.c',
             'vaapi_decode.c',
             'vaapi_vp8.c',
             'vaapi_vp9.c',
         ]
         USE_LIBS += [
-          'dav1d',
-          'media_libdav1d_asm',
           'mozva'
         ]
 
diff -Naur a/media/ffvpx/libavcodec/mpeg12data.h b/media/ffvpx/libavcodec/mpeg12data.h
--- a/media/ffvpx/libavcodec/mpeg12data.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpeg12data.h	2023-04-06 12:50:06.972471094 +0200
@@ -30,7 +30,6 @@
 
 #include <stdint.h>
 #include "libavutil/rational.h"
-#include "rl.h"
 
 extern const uint16_t ff_mpeg1_default_intra_matrix[];
 extern const uint16_t ff_mpeg1_default_non_intra_matrix[64];
@@ -40,9 +39,6 @@
 extern const uint16_t ff_mpeg12_vlc_dc_chroma_code[12];
 extern const unsigned char ff_mpeg12_vlc_dc_chroma_bits[12];
 
-extern RLTable ff_rl_mpeg1;
-extern RLTable ff_rl_mpeg2;
-
 extern const uint8_t ff_mpeg12_mbAddrIncrTable[36][2];
 extern const uint8_t ff_mpeg12_mbPatTable[64][2];
 
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodata.c b/media/ffvpx/libavcodec/mpegaudiodata.c
--- a/media/ffvpx/libavcodec/mpegaudiodata.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodata.c	2023-04-06 12:49:40.254394930 +0200
@@ -26,19 +26,6 @@
 
 #include "mpegaudiodata.h"
 
-
-const uint16_t avpriv_mpa_bitrate_tab[2][3][15] = {
-    { {0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448 },
-      {0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384 },
-      {0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320 } },
-    { {0, 32, 48, 56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
-      {0,  8, 16, 24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
-      {0,  8, 16, 24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
-    }
-};
-
-const uint16_t avpriv_mpa_freq_tab[3] = { 44100, 48000, 32000 };
-
 /*******************************************************/
 /* layer 2 tables */
 
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodata.h b/media/ffvpx/libavcodec/mpegaudiodata.h
--- a/media/ffvpx/libavcodec/mpegaudiodata.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodata.h	2023-04-06 12:49:40.254394930 +0200
@@ -31,14 +31,13 @@
 
 #include "config.h"
 
-#include "internal.h"
 #include "vlc.h"
 
 #define MODE_EXT_MS_STEREO 2
 #define MODE_EXT_I_STEREO  1
 
-extern av_export_avcodec const uint16_t avpriv_mpa_bitrate_tab[2][3][15];
-extern av_export_avcodec const uint16_t avpriv_mpa_freq_tab[3];
+extern const uint16_t ff_mpa_bitrate_tab[2][3][15];
+extern const uint16_t ff_mpa_freq_tab[3];
 extern const int ff_mpa_sblimit_table[5];
 extern const int ff_mpa_quant_steps[17];
 extern const int ff_mpa_quant_bits[17];
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodec_common.c b/media/ffvpx/libavcodec/mpegaudiodec_common.c
--- a/media/ffvpx/libavcodec/mpegaudiodec_common.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodec_common.c	2023-04-06 12:50:06.972471094 +0200
@@ -28,6 +28,7 @@
 #include <stdint.h>
 
 #include "libavutil/avassert.h"
+#include "libavutil/libm.h"
 #include "libavutil/thread.h"
 
 #include "mpegaudiodata.h"
@@ -64,10 +65,10 @@
 
 /* mpegaudio layer 3 huffman tables */
 VLC ff_huff_vlc[16];
-static VLC_TYPE huff_vlc_tables[128 + 128 + 128 + 130 + 128 + 154 + 166 + 142 +
-                                204 + 190 + 170 + 542 + 460 + 662 + 414][2];
+static VLCElem huff_vlc_tables[128 + 128 + 128 + 130 + 128 + 154 + 166 + 142 +
+                               204 + 190 + 170 + 542 + 460 + 662 + 414];
 VLC ff_huff_quad_vlc[2];
-static VLC_TYPE  huff_quad_vlc_tables[64 + 16][2];
+static VLCElem huff_quad_vlc_tables[64 + 16];
 
 static const uint8_t mpa_hufflens[] = {
     /* Huffman table 1 - 4 entries */
@@ -368,7 +369,7 @@
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
   20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 22050 */
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  18, 22, 26, 32, 38, 46, 52, 64, 70, 76, 36, }, /* 24000 */
+  18, 22, 26, 32, 38, 46, 54, 62, 70, 76, 36, }, /* 24000 */
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
   20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 16000 */
 { 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodec_fixed.c b/media/ffvpx/libavcodec/mpegaudiodec_fixed.c
--- a/media/ffvpx/libavcodec/mpegaudiodec_fixed.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodec_fixed.c	2023-04-06 12:50:06.972471094 +0200
@@ -19,10 +19,12 @@
  */
 
 #include "config.h"
+#include "config_components.h"
 #include "libavutil/samplefmt.h"
 
 #define USE_FLOATS 0
 
+#include "codec_internal.h"
 #include "mpegaudio.h"
 
 #define SHR(a,b)       (((int)(a))>>(b))
@@ -59,92 +61,88 @@
 #include "mpegaudiodec_template.c"
 
 #if CONFIG_MP1_DECODER
-AVCodec ff_mp1_decoder = {
-    .name           = "mp1",
-    .long_name      = NULL_IF_CONFIG_SMALL("MP1 (MPEG audio layer 1)"),
-    .type           = AVMEDIA_TYPE_AUDIO,
-    .id             = AV_CODEC_ID_MP1,
+const FFCodec ff_mp1_decoder = {
+    .p.name         = "mp1",
+    CODEC_LONG_NAME("MP1 (MPEG audio layer 1)"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_MP1,
     .priv_data_size = sizeof(MPADecodeContext),
     .init           = decode_init,
-    .decode         = decode_frame,
-    .capabilities   = AV_CODEC_CAP_CHANNEL_CONF |
+    FF_CODEC_DECODE_CB(decode_frame),
+    .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
     .flush          = flush,
-    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
+    .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP2_DECODER
-AVCodec ff_mp2_decoder = {
-    .name           = "mp2",
-    .long_name      = NULL_IF_CONFIG_SMALL("MP2 (MPEG audio layer 2)"),
-    .type           = AVMEDIA_TYPE_AUDIO,
-    .id             = AV_CODEC_ID_MP2,
+const FFCodec ff_mp2_decoder = {
+    .p.name         = "mp2",
+    CODEC_LONG_NAME("MP2 (MPEG audio layer 2)"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_MP2,
     .priv_data_size = sizeof(MPADecodeContext),
     .init           = decode_init,
-    .decode         = decode_frame,
-    .capabilities   = AV_CODEC_CAP_CHANNEL_CONF |
+    FF_CODEC_DECODE_CB(decode_frame),
+    .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
     .flush          = flush,
-    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
+    .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3_DECODER
-AVCodec ff_mp3_decoder = {
-    .name           = "mp3",
-    .long_name      = NULL_IF_CONFIG_SMALL("MP3 (MPEG audio layer 3)"),
-    .type           = AVMEDIA_TYPE_AUDIO,
-    .id             = AV_CODEC_ID_MP3,
+const FFCodec ff_mp3_decoder = {
+    .p.name         = "mp3",
+    CODEC_LONG_NAME("MP3 (MPEG audio layer 3)"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_MP3,
     .priv_data_size = sizeof(MPADecodeContext),
     .init           = decode_init,
-    .decode         = decode_frame,
-    .capabilities   = AV_CODEC_CAP_CHANNEL_CONF |
+    FF_CODEC_DECODE_CB(decode_frame),
+    .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
     .flush          = flush,
-    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
+    .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3ADU_DECODER
-AVCodec ff_mp3adu_decoder = {
-    .name           = "mp3adu",
-    .long_name      = NULL_IF_CONFIG_SMALL("ADU (Application Data Unit) MP3 (MPEG audio layer 3)"),
-    .type           = AVMEDIA_TYPE_AUDIO,
-    .id             = AV_CODEC_ID_MP3ADU,
+const FFCodec ff_mp3adu_decoder = {
+    .p.name         = "mp3adu",
+    CODEC_LONG_NAME("ADU (Application Data Unit) MP3 (MPEG audio layer 3)"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_MP3ADU,
     .priv_data_size = sizeof(MPADecodeContext),
     .init           = decode_init,
-    .decode         = decode_frame_adu,
-    .capabilities   = AV_CODEC_CAP_CHANNEL_CONF |
+    FF_CODEC_DECODE_CB(decode_frame_adu),
+    .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
     .flush          = flush,
-    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
+    .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3ON4_DECODER
-AVCodec ff_mp3on4_decoder = {
-    .name           = "mp3on4",
-    .long_name      = NULL_IF_CONFIG_SMALL("MP3onMP4"),
-    .type           = AVMEDIA_TYPE_AUDIO,
-    .id             = AV_CODEC_ID_MP3ON4,
+const FFCodec ff_mp3on4_decoder = {
+    .p.name         = "mp3on4",
+    CODEC_LONG_NAME("MP3onMP4"),
+    .p.type         = AVMEDIA_TYPE_AUDIO,
+    .p.id           = AV_CODEC_ID_MP3ON4,
     .priv_data_size = sizeof(MP3On4DecodeContext),
     .init           = decode_init_mp3on4,
     .close          = decode_close_mp3on4,
-    .decode         = decode_frame_mp3on4,
-    .capabilities   = AV_CODEC_CAP_CHANNEL_CONF |
+    FF_CODEC_DECODE_CB(decode_frame_mp3on4),
+    .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
     .flush          = flush_mp3on4,
-    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
+    .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodecheader.c b/media/ffvpx/libavcodec/mpegaudiodecheader.c
--- a/media/ffvpx/libavcodec/mpegaudiodecheader.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodecheader.c	2023-04-06 12:49:40.254394930 +0200
@@ -24,10 +24,8 @@
  * MPEG Audio header decoder.
  */
 
-#include "libavutil/common.h"
+#include "libavutil/macros.h"
 
-#include "avcodec.h"
-#include "internal.h"
 #include "mpegaudio.h"
 #include "mpegaudiodata.h"
 #include "mpegaudiodecheader.h"
@@ -54,9 +52,9 @@
     s->layer = 4 - ((header >> 17) & 3);
     /* extract frequency */
     sample_rate_index = (header >> 10) & 3;
-    if (sample_rate_index >= FF_ARRAY_ELEMS(avpriv_mpa_freq_tab))
+    if (sample_rate_index >= FF_ARRAY_ELEMS(ff_mpa_freq_tab))
         sample_rate_index = 0;
-    sample_rate = avpriv_mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);
+    sample_rate = ff_mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);
     sample_rate_index += 3 * (s->lsf + mpeg25);
     s->sample_rate_index = sample_rate_index;
     s->error_protection = ((header >> 16) & 1) ^ 1;
@@ -77,7 +75,7 @@
         s->nb_channels = 2;
 
     if (bitrate_index != 0) {
-        frame_size = avpriv_mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];
+        frame_size = ff_mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];
         s->bit_rate = frame_size * 1000;
         switch(s->layer) {
         case 1:
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodecheader.h b/media/ffvpx/libavcodec/mpegaudiodecheader.h
--- a/media/ffvpx/libavcodec/mpegaudiodecheader.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodecheader.h	2023-04-06 12:49:40.254394930 +0200
@@ -27,7 +27,8 @@
 #ifndef AVCODEC_MPEGAUDIODECHEADER_H
 #define AVCODEC_MPEGAUDIODECHEADER_H
 
-#include "avcodec.h"
+#include <stdint.h>
+#include "codec_id.h"
 
 #define MP3_MASK 0xFFFE0CCF
 
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodec_template.c b/media/ffvpx/libavcodec/mpegaudiodec_template.c
--- a/media/ffvpx/libavcodec/mpegaudiodec_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodec_template.c	2023-04-06 12:50:06.972471094 +0200
@@ -24,6 +24,8 @@
  * MPEG Audio decoder
  */
 
+#include "config_components.h"
+
 #include "libavutil/attributes.h"
 #include "libavutil/avassert.h"
 #include "libavutil/channel_layout.h"
@@ -34,8 +36,8 @@
 #include "libavutil/thread.h"
 
 #include "avcodec.h"
+#include "decode.h"
 #include "get_bits.h"
-#include "internal.h"
 #include "mathops.h"
 #include "mpegaudiodsp.h"
 
@@ -372,7 +374,7 @@
         crc_val = av_crc(crc_tab, crc_val, &buf[6], sec_byte_len);
 
         AV_WB32(tmp_buf,
-                ((buf[6 + sec_byte_len] & (0xFF00 >> sec_rem_bits)) << 24) +
+                ((buf[6 + sec_byte_len] & (0xFF00U >> sec_rem_bits)) << 24) +
                 ((s->crc << 16) >> sec_rem_bits));
 
         crc_val = av_crc(crc_tab, crc_val, tmp_buf, 3);
@@ -1546,8 +1548,8 @@
     return nb_frames * 32 * sizeof(OUT_INT) * s->nb_channels;
 }
 
-static int decode_frame(AVCodecContext * avctx, void *data, int *got_frame_ptr,
-                        AVPacket *avpkt)
+static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                        int *got_frame_ptr, AVPacket *avpkt)
 {
     const uint8_t *buf  = avpkt->data;
     int buf_size        = avpkt->size;
@@ -1580,8 +1582,9 @@
         return AVERROR_INVALIDDATA;
     }
     /* update codec info */
-    avctx->channels       = s->nb_channels;
-    avctx->channel_layout = s->nb_channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;
+    av_channel_layout_uninit(&avctx->ch_layout);
+    avctx->ch_layout = s->nb_channels == 1 ? (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO :
+                                             (AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO;
     if (!avctx->bit_rate)
         avctx->bit_rate = s->bit_rate;
 
@@ -1593,7 +1596,7 @@
         buf_size= s->frame_size;
     }
 
-    s->frame = data;
+    s->frame = frame;
 
     ret = mp_decode_frame(s, NULL, buf, buf_size);
     if (ret >= 0) {
@@ -1630,7 +1633,7 @@
 }
 
 #if CONFIG_MP3ADU_DECODER || CONFIG_MP3ADUFLOAT_DECODER
-static int decode_frame_adu(AVCodecContext *avctx, void *data,
+static int decode_frame_adu(AVCodecContext *avctx, AVFrame *frame,
                             int *got_frame_ptr, AVPacket *avpkt)
 {
     const uint8_t *buf  = avpkt->data;
@@ -1638,7 +1641,6 @@
     MPADecodeContext *s = avctx->priv_data;
     uint32_t header;
     int len, ret;
-    int av_unused out_size;
 
     len = buf_size;
 
@@ -1662,14 +1664,15 @@
     }
     /* update codec info */
     avctx->sample_rate = s->sample_rate;
-    avctx->channels    = s->nb_channels;
-    avctx->channel_layout = s->nb_channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO;
+    av_channel_layout_uninit(&avctx->ch_layout);
+    avctx->ch_layout = s->nb_channels == 1 ? (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO :
+                                             (AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO;
     if (!avctx->bit_rate)
         avctx->bit_rate = s->bit_rate;
 
     s->frame_size = len;
 
-    s->frame = data;
+    s->frame = frame;
 
     ret = mp_decode_frame(s, NULL, buf, buf_size);
     if (ret < 0) {
@@ -1757,8 +1760,8 @@
     }
     s->frames             = mp3Frames[cfg.chan_config];
     s->coff               = chan_offset[cfg.chan_config];
-    avctx->channels       = ff_mpeg4audio_channels[cfg.chan_config];
-    avctx->channel_layout = chan_layout[cfg.chan_config];
+    av_channel_layout_uninit(&avctx->ch_layout);
+    av_channel_layout_from_mask(&avctx->ch_layout, chan_layout[cfg.chan_config]);
 
     if (cfg.sample_rate < 16000)
         s->syncword = 0xffe00000;
@@ -1810,10 +1813,9 @@
 }
 
 
-static int decode_frame_mp3on4(AVCodecContext *avctx, void *data,
+static int decode_frame_mp3on4(AVCodecContext *avctx, AVFrame *frame,
                                int *got_frame_ptr, AVPacket *avpkt)
 {
-    AVFrame *frame         = data;
     const uint8_t *buf     = avpkt->data;
     int buf_size           = avpkt->size;
     MP3On4DecodeContext *s = avctx->priv_data;
@@ -1855,8 +1857,8 @@
             return AVERROR_INVALIDDATA;
         }
 
-        if (ch + m->nb_channels > avctx->channels ||
-            s->coff[fr] + m->nb_channels > avctx->channels) {
+        if (ch + m->nb_channels > avctx->ch_layout.nb_channels ||
+            s->coff[fr] + m->nb_channels > avctx->ch_layout.nb_channels) {
             av_log(avctx, AV_LOG_ERROR, "frame channel count exceeds codec "
                                         "channel count\n");
             return AVERROR_INVALIDDATA;
@@ -1881,7 +1883,7 @@
 
         avctx->bit_rate += m->bit_rate;
     }
-    if (ch != avctx->channels) {
+    if (ch != avctx->ch_layout.nb_channels) {
         av_log(avctx, AV_LOG_ERROR, "failed to decode all channels\n");
         return AVERROR_INVALIDDATA;
     }
@@ -1889,7 +1891,7 @@
     /* update codec info */
     avctx->sample_rate = s->mp3decctx[0]->sample_rate;
 
-    frame->nb_samples = out_size / (avctx->channels * sizeof(OUT_INT));
+    frame->nb_samples = out_size / (avctx->ch_layout.nb_channels * sizeof(OUT_INT));
     *got_frame_ptr    = 1;
 
     return buf_size;
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodsp.c b/media/ffvpx/libavcodec/mpegaudiodsp.c
--- a/media/ffvpx/libavcodec/mpegaudiodsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodsp.c	2023-04-06 12:49:40.254394930 +0200
@@ -74,8 +74,9 @@
         }
     }
 
-    if (ARCH_X86)
-        ff_mpadsp_init_x86_tabs();
+#if ARCH_X86
+    ff_mpadsp_init_x86_tabs();
+#endif
 }
 
 av_cold void ff_mpadsp_init(MPADSPContext *s)
@@ -94,10 +95,19 @@
     s->imdct36_blocks_float = ff_imdct36_blocks_float;
     s->imdct36_blocks_fixed = ff_imdct36_blocks_fixed;
 
-    if (ARCH_AARCH64) ff_mpadsp_init_aarch64(s);
-    if (ARCH_ARM)     ff_mpadsp_init_arm(s);
-    if (ARCH_PPC)     ff_mpadsp_init_ppc(s);
-    if (ARCH_X86)     ff_mpadsp_init_x86(s);
-    if (HAVE_MIPSFPU)   ff_mpadsp_init_mipsfpu(s);
-    if (HAVE_MIPSDSP) ff_mpadsp_init_mipsdsp(s);
+#if ARCH_AARCH64
+    ff_mpadsp_init_aarch64(s);
+#elif ARCH_ARM
+    ff_mpadsp_init_arm(s);
+#elif ARCH_PPC
+    ff_mpadsp_init_ppc(s);
+#elif ARCH_X86
+    ff_mpadsp_init_x86(s);
+#endif
+#if HAVE_MIPSFPU
+    ff_mpadsp_init_mipsfpu(s);
+#endif
+#if HAVE_MIPSDSP
+    ff_mpadsp_init_mipsdsp(s);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodsp.h b/media/ffvpx/libavcodec/mpegaudiodsp.h
--- a/media/ffvpx/libavcodec/mpegaudiodsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodsp.h	2023-04-06 12:49:40.254394930 +0200
@@ -22,7 +22,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "libavutil/common.h"
+#include "libavutil/macros.h"
 
 typedef struct MPADSPContext {
     void (*apply_window_float)(float *synth_buf, float *window,
diff -Naur a/media/ffvpx/libavcodec/mpegaudiodsp_template.c b/media/ffvpx/libavcodec/mpegaudiodsp_template.c
--- a/media/ffvpx/libavcodec/mpegaudiodsp_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiodsp_template.c	2023-04-06 12:49:40.254394930 +0200
@@ -21,7 +21,6 @@
 #include <stdint.h>
 
 #include "libavutil/attributes.h"
-#include "libavutil/mem.h"
 #include "libavutil/mem_internal.h"
 #include "libavutil/thread.h"
 
diff -Naur a/media/ffvpx/libavcodec/mpegaudiotab.h b/media/ffvpx/libavcodec/mpegaudiotab.h
--- a/media/ffvpx/libavcodec/mpegaudiotab.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiotab.h	2023-04-06 12:49:40.254394930 +0200
@@ -0,0 +1,102 @@
+/*
+ * mpeg audio layer 2 tables. Most of them come from the mpeg audio
+ * specification.
+ *
+ * Copyright (c) 2000, 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * mpeg audio layer 2 tables.
+ * Most of them come from the mpeg audio specification.
+ */
+
+#ifndef AVCODEC_MPEGAUDIOTAB_H
+#define AVCODEC_MPEGAUDIOTAB_H
+
+#include <stdint.h>
+#include "mpegaudio.h"
+
+static const int costab32[30] = {
+    FIX(0.54119610014619701222),
+    FIX(1.3065629648763763537),
+
+    FIX(0.50979557910415917998),
+    FIX(2.5629154477415054814),
+    FIX(0.89997622313641556513),
+    FIX(0.60134488693504528634),
+
+    FIX(0.5024192861881556782),
+    FIX(5.1011486186891552563),
+    FIX(0.78815462345125020249),
+    FIX(0.64682178335999007679),
+    FIX(0.56694403481635768927),
+    FIX(1.0606776859903470633),
+    FIX(1.7224470982383341955),
+    FIX(0.52249861493968885462),
+
+    FIX(10.19000812354803287),
+    FIX(0.674808341455005678),
+    FIX(1.1694399334328846596),
+    FIX(0.53104259108978413284),
+    FIX(2.0577810099534108446),
+    FIX(0.58293496820613388554),
+    FIX(0.83934964541552681272),
+    FIX(0.50547095989754364798),
+    FIX(3.4076084184687189804),
+    FIX(0.62250412303566482475),
+    FIX(0.97256823786196078263),
+    FIX(0.51544730992262455249),
+    FIX(1.4841646163141661852),
+    FIX(0.5531038960344445421),
+    FIX(0.74453627100229857749),
+    FIX(0.5006029982351962726),
+};
+
+static const int bitinv32[32] = {
+    0,  16,  8, 24,  4,  20,  12,  28,
+    2,  18, 10, 26,  6,  22,  14,  30,
+    1,  17,  9, 25,  5,  21,  13,  29,
+    3,  19, 11, 27,  7,  23,  15,  31
+};
+
+
+/* signal to noise ratio of each quantification step (could be
+   computed from quant_steps[]). The values are dB multiplied by 10
+*/
+static const unsigned short quant_snr[17] = {
+     70, 110, 160, 208,
+    253, 316, 378, 439,
+    499, 559, 620, 680,
+    740, 800, 861, 920,
+    980
+};
+
+/* fixed psycho acoustic model. Values of SNR taken from the 'toolame'
+   project */
+static const float fixed_smr[SBLIMIT] =  {
+    30, 17, 16, 10, 3, 12, 8, 2.5,
+    5, 5, 6, 6, 5, 6, 10, 6,
+    -4, -10, -21, -30, -42, -55, -68, -75,
+    -75, -75, -75, -75, -91, -107, -110, -108
+};
+
+static const unsigned char nb_scale_factors[4] = { 3, 2, 1, 2 };
+
+#endif /* AVCODEC_MPEGAUDIOTAB_H */
diff -Naur a/media/ffvpx/libavcodec/mpegaudiotabs.c b/media/ffvpx/libavcodec/mpegaudiotabs.c
--- a/media/ffvpx/libavcodec/mpegaudiotabs.c	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiotabs.c	2023-04-06 12:49:40.254394930 +0200
@@ -0,0 +1,22 @@
+/*
+ * MPEG Audio common tables
+ * copyright (c) 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "mpegaudiotabs.h"
diff -Naur a/media/ffvpx/libavcodec/mpegaudiotabs.h b/media/ffvpx/libavcodec/mpegaudiotabs.h
--- a/media/ffvpx/libavcodec/mpegaudiotabs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegaudiotabs.h	2023-04-06 12:49:40.254394930 +0200
@@ -0,0 +1,39 @@
+/*
+ * MPEG Audio common tables
+ * copyright (c) 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_MPEGAUDIOTABS_H
+#define AVCODEC_MPEGAUDIOTABS_H
+
+#include <stdint.h>
+
+const uint16_t ff_mpa_bitrate_tab[2][3][15] = {
+    { { 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448 },
+      { 0, 32, 48, 56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384 },
+      { 0, 32, 40, 48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320 } },
+    { { 0, 32, 48, 56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256 },
+      { 0,  8, 16, 24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160 },
+      { 0,  8, 16, 24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160 }
+    }
+};
+
+const uint16_t ff_mpa_freq_tab[3] = { 44100, 48000, 32000 };
+
+#endif
diff -Naur a/media/ffvpx/libavcodec/mpegpicture.h b/media/ffvpx/libavcodec/mpegpicture.h
--- a/media/ffvpx/libavcodec/mpegpicture.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegpicture.h	2023-04-06 12:50:24.492176543 +0200
@@ -27,8 +27,9 @@
 
 #include "avcodec.h"
 #include "motion_est.h"
-#include "thread.h"
+#include "threadframe.h"
 
+#define MPEGVIDEO_MAX_PLANES 4
 #define MAX_PICTURE_COUNT 36
 #define EDGE_WIDTH 16
 
@@ -61,34 +62,23 @@
     AVBufferRef *ref_index_buf[2];
     int8_t *ref_index[2];
 
-    AVBufferRef *mb_var_buf;
-    uint16_t *mb_var;           ///< Table for MB variances
-
-    AVBufferRef *mc_mb_var_buf;
-    uint16_t *mc_mb_var;        ///< Table for motion compensated MB variances
-
     int alloc_mb_width;         ///< mb_width used to allocate tables
     int alloc_mb_height;        ///< mb_height used to allocate tables
     int alloc_mb_stride;        ///< mb_stride used to allocate tables
 
-    AVBufferRef *mb_mean_buf;
-    uint8_t *mb_mean;           ///< Table for MB luminance
-
     AVBufferRef *hwaccel_priv_buf;
     void *hwaccel_picture_private; ///< Hardware accelerator private data
 
     int field_picture;          ///< whether or not the picture was encoded in separate fields
 
-    int64_t mb_var_sum;         ///< sum of MB variance for current frame
-    int64_t mc_mb_var_sum;      ///< motion compensated MB variance for current frame
-
     int b_frame_score;
     int needs_realloc;          ///< Picture needs to be reallocated (eg due to a frame size change)
 
     int reference;
     int shared;
 
-    uint64_t encoding_error[AV_NUM_DATA_POINTERS];
+    int display_picture_number;
+    int coded_picture_number;
 } Picture;
 
 /**
@@ -107,8 +97,8 @@
 int ff_mpeg_ref_picture(AVCodecContext *avctx, Picture *dst, Picture *src);
 void ff_mpeg_unref_picture(AVCodecContext *avctx, Picture *picture);
 
-void ff_free_picture_tables(Picture *pic);
-int ff_update_picture_tables(Picture *dst, Picture *src);
+void ff_mpv_picture_free(AVCodecContext *avctx, Picture *pic);
+int ff_update_picture_tables(Picture *dst, const Picture *src);
 
 int ff_find_unused_picture(AVCodecContext *avctx, Picture *picture, int shared);
 
diff -Naur a/media/ffvpx/libavcodec/mpegutils.h b/media/ffvpx/libavcodec/mpegutils.h
--- a/media/ffvpx/libavcodec/mpegutils.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegutils.h	2023-04-06 12:50:06.972471094 +0200
@@ -26,7 +26,6 @@
 #include "libavutil/frame.h"
 
 #include "avcodec.h"
-#include "version.h"
 
 /**
  * Return value for header parsers if frame is not coded.
@@ -38,12 +37,6 @@
 #define PICT_BOTTOM_FIELD  2
 #define PICT_FRAME         3
 
-/**
- * Value of Picture.reference when Picture is not a reference picture, but
- * is held for delayed output.
- */
-#define DELAYED_PIC_REF 4
-
 #define MAX_MB_BYTES    (30 * 16 * 16 * 3 / 8 + 120)
 #define MAX_FCODE        7
 
@@ -134,16 +127,16 @@
  *
  * @param h is the normal height, this will be reduced automatically if needed
  */
-void ff_draw_horiz_band(AVCodecContext *avctx, AVFrame *cur, AVFrame *last,
+void ff_draw_horiz_band(AVCodecContext *avctx, const AVFrame *cur, const AVFrame *last,
                         int y, int h, int picture_structure, int first_field,
                         int low_delay);
 
 /**
  * Print debugging info for the given picture.
  */
-void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict, uint8_t *mbskip_table,
-                         uint32_t *mbtype_table, int8_t *qscale_table, int16_t (*motion_val[2])[2],
-                         int *low_delay,
-                         int mb_width, int mb_height, int mb_stride, int quarter_sample);
+void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict,
+                          const uint8_t *mbskip_table, const uint32_t *mbtype_table,
+                          const int8_t *qscale_table, int16_t (*const motion_val[2])[2],
+                          int mb_width, int mb_height, int mb_stride, int quarter_sample);
 
 #endif /* AVCODEC_MPEGUTILS_H */
diff -Naur a/media/ffvpx/libavcodec/mpegvideodata.h b/media/ffvpx/libavcodec/mpegvideodata.h
--- a/media/ffvpx/libavcodec/mpegvideodata.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegvideodata.h	2023-04-06 12:50:06.972471094 +0200
@@ -21,15 +21,19 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
+
+FF_VISIBILITY_PUSH_HIDDEN
 /* encoding scans */
 extern const uint8_t ff_alternate_horizontal_scan[64];
 extern const uint8_t ff_alternate_vertical_scan[64];
 
-extern const uint8_t ff_mpeg1_dc_scale_table[128];
-extern const uint8_t * const ff_mpeg2_dc_scale_table[4];
+extern const uint8_t ff_mpeg12_dc_scale_table[4][32];
+static const uint8_t *const ff_mpeg1_dc_scale_table = ff_mpeg12_dc_scale_table[0];
 
 extern const uint8_t ff_mpeg2_non_linear_qscale[32];
 
 extern const uint8_t ff_default_chroma_qscale_table[32];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_MPEGVIDEODATA_H */
diff -Naur a/media/ffvpx/libavcodec/mpegvideoencdsp.h b/media/ffvpx/libavcodec/mpegvideoencdsp.h
--- a/media/ffvpx/libavcodec/mpegvideoencdsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegvideoencdsp.h	2023-04-06 12:50:06.973471134 +0200
@@ -30,12 +30,12 @@
 #define EDGE_BOTTOM 2
 
 typedef struct MpegvideoEncDSPContext {
-    int (*try_8x8basis)(int16_t rem[64], int16_t weight[64],
-                        int16_t basis[64], int scale);
-    void (*add_8x8basis)(int16_t rem[64], int16_t basis[64], int scale);
+    int (*try_8x8basis)(const int16_t rem[64], const int16_t weight[64],
+                        const int16_t basis[64], int scale);
+    void (*add_8x8basis)(int16_t rem[64], const int16_t basis[64], int scale);
 
-    int (*pix_sum)(uint8_t *pix, int line_size);
-    int (*pix_norm1)(uint8_t *pix, int line_size);
+    int (*pix_sum)(const uint8_t *pix, int line_size);
+    int (*pix_norm1)(const uint8_t *pix, int line_size);
 
     void (*shrink[4])(uint8_t *dst, int dst_wrap, const uint8_t *src,
                       int src_wrap, int width, int height);
diff -Naur a/media/ffvpx/libavcodec/mpegvideo.h b/media/ffvpx/libavcodec/mpegvideo.h
--- a/media/ffvpx/libavcodec/mpegvideo.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/mpegvideo.h	2023-04-06 12:50:24.492176543 +0200
@@ -28,8 +28,6 @@
 #ifndef AVCODEC_MPEGVIDEO_H
 #define AVCODEC_MPEGVIDEO_H
 
-#include <float.h>
-
 #include "avcodec.h"
 #include "blockdsp.h"
 #include "error_resilience.h"
@@ -39,41 +37,29 @@
 #include "h263dsp.h"
 #include "hpeldsp.h"
 #include "idctdsp.h"
-#include "internal.h"
 #include "me_cmp.h"
 #include "motion_est.h"
 #include "mpegpicture.h"
-#include "mpegvideodsp.h"
 #include "mpegvideoencdsp.h"
-#include "mpegvideodata.h"
 #include "pixblockdsp.h"
 #include "put_bits.h"
 #include "ratecontrol.h"
-#include "parser.h"
 #include "mpegutils.h"
-#include "mpeg12data.h"
 #include "qpeldsp.h"
-#include "thread.h"
 #include "videodsp.h"
 
-#include "libavutil/opt.h"
-#include "libavutil/timecode.h"
-
 #define MAX_THREADS 32
 
 #define MAX_B_FRAMES 16
 
-/* Start codes. */
-#define SEQ_END_CODE            0x000001b7
-#define SEQ_START_CODE          0x000001b3
-#define GOP_START_CODE          0x000001b8
-#define PICTURE_START_CODE      0x00000100
-#define SLICE_MIN_START_CODE    0x00000101
-#define SLICE_MAX_START_CODE    0x000001af
-#define EXT_START_CODE          0x000001b5
-#define USER_START_CODE         0x000001b2
-#define SLICE_START_CODE        0x000001b7
-
+/**
+ * Scantable.
+ */
+typedef struct ScanTable {
+    const uint8_t *scantable;
+    uint8_t permutated[64];
+    uint8_t raster_end[64];
+} ScanTable;
 
 /**
  * MpegEncContext.
@@ -88,14 +74,18 @@
 
     /* scantables */
     ScanTable inter_scantable; ///< if inter == intra then intra should be used to reduce the cache usage
-    ScanTable intra_scantable;
-    ScanTable intra_h_scantable;
-    ScanTable intra_v_scantable;
 
     /* WARNING: changes above this line require updates to hardcoded
      *          offsets used in ASM. */
 
+    ScanTable intra_scantable;
+    uint8_t permutated_intra_h_scantable[64];
+    uint8_t permutated_intra_v_scantable[64];
+
     struct AVCodecContext *avctx;
+    /* The following pointer is intended for codecs sharing code
+     * between decoder and encoder and in need of a common context to do so. */
+    void *private_ctx;
     /* the following parameters must be initialized before encoding */
     int width, height;///< picture size. must be a multiple of 16
     int gop_size;
@@ -115,7 +105,6 @@
     int max_b_frames; ///< max number of B-frames for encoding
     int luma_elim_threshold;
     int chroma_elim_threshold;
-    int strict_std_compliance; ///< strictly follow the std (MPEG-4, ...)
     int workaround_bugs;       ///< workaround bugs in encoders which cannot be detected automatically
     int codec_tag;             ///< internal codec_tag upper case converted from avctx codec_tag
     /* the following fields are managed internally by the encoder */
@@ -125,6 +114,7 @@
     int input_picture_number;  ///< used to set pic->display_picture_number, should not be used for/by anything else
     int coded_picture_number;  ///< used to set pic->coded_picture_number, should not be used for/by anything else
     int picture_number;       //FIXME remove, unclear definition
+    int extradata_parsed;
     int picture_in_gop_number; ///< 0-> first pic in gop, ...
     int mb_width, mb_height;   ///< number of MBs horizontally & vertically
     int mb_stride;             ///< mb_width+1 used for some arrays to allow simple addressing of left & top MBs without sig11
@@ -137,7 +127,7 @@
     Picture **input_picture;   ///< next pictures on display order for encoding
     Picture **reordered_input_picture; ///< pointer to the next pictures in coded order for encoding
 
-    int64_t user_specified_pts; ///< last non-zero pts from AVFrame which was passed into avcodec_encode_video2()
+    int64_t user_specified_pts; ///< last non-zero pts from AVFrame which was passed into avcodec_send_frame()
     /**
      * pts difference between the first and second input frame, used for
      * calculating dts of the first frame when there's a delay */
@@ -168,10 +158,10 @@
     Picture next_picture;
 
     /**
-     * copy of the source picture structure for encoding.
+     * Reference to the source picture for encoding.
      * note, linesize & data, might not match the source picture (for field pictures)
      */
-    Picture new_picture;
+    AVFrame *new_picture;
 
     /**
      * copy of the current picture structure.
@@ -182,6 +172,7 @@
     Picture *last_picture_ptr;     ///< pointer to the previous picture.
     Picture *next_picture_ptr;     ///< pointer to the next picture (for bidir pred)
     Picture *current_picture_ptr;  ///< pointer to the current picture
+    int skipped_last_frame;
     int last_dc[3];                ///< last DC values for MPEG-1
     int16_t *dc_val_base;
     int16_t *dc_val[3];            ///< used for MPEG-4 DC prediction, all 3 arrays must be continuous
@@ -208,14 +199,11 @@
     int *lambda_table;
     int adaptive_quant;         ///< use adaptive quantization
     int dquant;                 ///< qscale difference to prev qscale
-    int closed_gop;             ///< MPEG1/2 GOP is closed
     int pict_type;              ///< AV_PICTURE_TYPE_I, AV_PICTURE_TYPE_P, AV_PICTURE_TYPE_B, ...
     int vbv_delay;
     int last_pict_type; //FIXME removes
     int last_non_b_pict_type;   ///< used for MPEG-4 gmc B-frames & ratecontrol
     int droppable;
-    int frame_rate_index;
-    AVRational mpeg2_frame_rate_ext;
     int last_lambda_for[5];     ///< last lambda for a specific pict type
     int skipdct;                ///< skip dct and code zero residual
 
@@ -229,7 +217,6 @@
     HpelDSPContext hdsp;
     IDCTDSPContext idsp;
     MECmpContext mecc;
-    MpegVideoDSPContext mdsp;
     MpegvideoEncDSPContext mpvencdsp;
     PixblockDSPContext pdsp;
     QpelDSPContext qdsp;
@@ -243,8 +230,8 @@
     int16_t (*b_bidir_forw_mv_table_base)[2];
     int16_t (*b_bidir_back_mv_table_base)[2];
     int16_t (*b_direct_mv_table_base)[2];
-    int16_t (*p_field_mv_table_base[2][2])[2];
-    int16_t (*b_field_mv_table_base[2][2][2])[2];
+    int16_t (*p_field_mv_table_base)[2];
+    int16_t (*b_field_mv_table_base)[2];
     int16_t (*p_mv_table)[2];            ///< MV table (1MV per MB) P-frame encoding
     int16_t (*b_forw_mv_table)[2];       ///< MV table (1MV per MB) forward mode B-frame encoding
     int16_t (*b_back_mv_table)[2];       ///< MV table (1MV per MB) backward mode B-frame encoding
@@ -253,8 +240,17 @@
     int16_t (*b_direct_mv_table)[2];     ///< MV table (1MV per MB) direct mode B-frame encoding
     int16_t (*p_field_mv_table[2][2])[2];   ///< MV table (2MV per MB) interlaced P-frame encoding
     int16_t (*b_field_mv_table[2][2][2])[2];///< MV table (4MV per MB) interlaced B-frame encoding
-    uint8_t (*p_field_select_table[2]);
-    uint8_t (*b_field_select_table[2][2]);
+    uint8_t (*p_field_select_table[2]);  ///< Only the first element is allocated
+    uint8_t (*b_field_select_table[2][2]); ///< Only the first element is allocated
+
+    /* The following fields are encoder-only */
+    uint16_t *mb_var;           ///< Table for MB variances
+    uint16_t *mc_mb_var;        ///< Table for motion compensated MB variances
+    uint8_t *mb_mean;           ///< Table for MB luminance
+    int64_t mb_var_sum;         ///< sum of MB variance for current frame
+    int64_t mc_mb_var_sum;      ///< motion compensated MB variance for current frame
+    uint64_t encoding_error[MPEGVIDEO_MAX_PLANES];
+
     int motion_est;                      ///< ME algorithm
     int me_penalty_compensation;
     int me_pre;                          ///< prepass for motion estimation
@@ -301,7 +297,6 @@
     uint16_t chroma_intra_matrix[64];
     uint16_t inter_matrix[64];
     uint16_t chroma_inter_matrix[64];
-    int force_duplicated_matrix; ///< Force duplication of mjpeg matrices, useful for rtp streaming
 
     int intra_quant_bias;    ///< bias for the quantizer
     int inter_quant_bias;    ///< bias for the quantizer
@@ -315,7 +310,6 @@
     uint8_t *inter_ac_vlc_length;
     uint8_t *inter_ac_vlc_last_length;
     uint8_t *luma_dc_vlc_length;
-#define UNI_AC_ENC_INDEX(run,level) ((run)*128 + (level))
 
     int coded_score[12];
 
@@ -346,8 +340,6 @@
     int i_tex_bits;
     int p_tex_bits;
     int i_count;
-    int f_count;
-    int b_count;
     int skip_count;
     int misc_bits; ///< cbp, mb_type
     int last_bits; ///< temp var used for calculating the above vars
@@ -357,9 +349,6 @@
     int resync_mb_y;                 ///< y position of last resync marker
     GetBitContext last_resync_gb;    ///< used to search for the next resync marker
     int mb_num_left;                 ///< number of MBs left in this video packet (for partitioned Slices only)
-    int next_p_frame_damaged;        ///< set if the next p frame is damaged, to avoid showing trashed B-frames
-
-    ParseContext parse_context;
 
     /* H.263 specific */
     int gob_index;
@@ -369,9 +358,6 @@
     uint8_t *mb_info_ptr;
     int mb_info_size;
     int ehc_mode;
-#if FF_API_MPV_RC_STRATEGY
-    int rc_strategy;                ///< deprecated
-#endif
 
     /* H.263+ specific */
     int umvplus;                    ///< == H.263+ && unrestricted_mv
@@ -395,18 +381,12 @@
     uint16_t pb_time;               ///< time distance between the last b and p,s,i frame
     uint16_t pp_field_time;
     uint16_t pb_field_time;         ///< like above, just for interlaced
-    int real_sprite_warping_points;
-    int sprite_offset[2][2];         ///< sprite offset[isChroma][isMVY]
-    int sprite_delta[2][2];          ///< sprite_delta [isY][isMVY]
     int mcsel;
     int quant_precision;
     int quarter_sample;              ///< 1->qpel, 0->half pel ME/MC
-    int aspect_ratio_info; //FIXME remove
-    int sprite_warping_accuracy;
     int data_partitioning;           ///< data partitioning flag from header
     int partitioned_frame;           ///< is current frame partitioned
     int low_delay;                   ///< no reordering needed / has no B-frames
-    int vo_type;
     PutBitContext tex_pb;            ///< used for data partitioned VOPs
     PutBitContext pb2;               ///< used for data partitioned VOPs
     int mpeg_quant;
@@ -425,8 +405,6 @@
     /* MJPEG specific */
     struct MJpegContext *mjpeg_ctx;
     int esc_pos;
-    int pred;
-    int huffman;
 
     /* MSMPEG4 specific */
     int mv_table_index;
@@ -441,31 +419,23 @@
     int per_mb_rl_table;
     int esc3_level_length;
     int esc3_run_length;
-    /** [mb_intra][isChroma][level][run][last] */
-    int (*ac_stats)[2][MAX_LEVEL+1][MAX_RUN+1][2];
     int inter_intra_pred;
     int mspel;
 
-    /* SpeedHQ specific */
-    int slice_start;
-
     /* decompression specific */
     GetBitContext gb;
 
     /* MPEG-1 specific */
-    int gop_picture_number;  ///< index of the first picture of a GOP based on fake_pic_num & MPEG-1 specific
     int last_mv_dir;         ///< last mv_dir, used for B-frame encoding
-    uint8_t *vbv_delay_ptr;  ///< pointer to vbv_delay in the bitstream
+    int vbv_delay_pos;       ///< offset of vbv_delay in the bitstream
 
     /* MPEG-2-specific - I wished not to have to support this mess. */
     int progressive_sequence;
     int mpeg_f_code[2][2];
-    int a53_cc;
 
     // picture structure defines are loaded from mpegutils.h
     int picture_structure;
 
-    int64_t timecode_frame_start; ///< GOP timecode frame start number, in non drop frame format
     int intra_dc_precision;
     int frame_pred_frame_dct;
     int top_field_first;
@@ -474,14 +444,6 @@
     int brd_scale;
     int intra_vlc_format;
     int alternate_scan;
-    int seq_disp_ext;
-    int video_format;
-#define VIDEO_FORMAT_COMPONENT   0
-#define VIDEO_FORMAT_PAL         1
-#define VIDEO_FORMAT_NTSC        2
-#define VIDEO_FORMAT_SECAM       3
-#define VIDEO_FORMAT_MAC         4
-#define VIDEO_FORMAT_UNSPECIFIED 5
     int repeat_first_field;
     int chroma_420_type;
     int chroma_format;
@@ -495,29 +457,18 @@
     int full_pel[2];
     int interlaced_dct;
     int first_field;         ///< is 1 for the first field of a field picture 0 otherwise
-    int drop_frame_timecode; ///< timecode is in drop frame format.
-    int scan_offset;         ///< reserve space for SVCD scan offset user data.
 
     /* RTP specific */
     int rtp_mode;
     int rtp_payload_size;
 
-    char *tc_opt_str;        ///< timecode option string
-    AVTimecode tc;           ///< timecode context
-
     uint8_t *ptr_lastgob;
-    int swap_uv;             //vcr2 codec is an MPEG-2 variant with U and V swapped
-    int pack_pblocks;        //xvmc needs to keep blocks without gaps.
     int16_t (*pblocks[12])[64];
 
     int16_t (*block)[64]; ///< points to one of the following blocks
     int16_t (*blocks)[12][64]; // for HQ mode we need to keep the best block
     int (*decode_mb)(struct MpegEncContext *s, int16_t block[12][64]); // used by some codecs to avoid a switch()
 
-    int32_t (*block32)[12][64];
-    int dpcm_direction;          // 0 = DCT, 1 = DPCM top to bottom scan, -1 = DPCM bottom to top scan
-    int16_t (*dpcm_macroblock)[3][256];
-
 #define SLICE_OK         0
 #define SLICE_ERROR     -1
 #define SLICE_END       -2 ///<end marker found
@@ -589,98 +540,6 @@
     int intra_penalty;
 } MpegEncContext;
 
-/* mpegvideo_enc common options */
-#define FF_MPV_FLAG_SKIP_RD      0x0001
-#define FF_MPV_FLAG_STRICT_GOP   0x0002
-#define FF_MPV_FLAG_QP_RD        0x0004
-#define FF_MPV_FLAG_CBP_RD       0x0008
-#define FF_MPV_FLAG_NAQ          0x0010
-#define FF_MPV_FLAG_MV0          0x0020
-
-#define FF_MPV_OPT_CMP_FUNC \
-{ "sad",    "Sum of absolute differences, fast", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SAD }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "sse",    "Sum of squared errors", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SSE }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "satd",   "Sum of absolute Hadamard transformed differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SATD }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "dct",    "Sum of absolute DCT transformed differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCT }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "psnr",   "Sum of squared quantization errors, low quality", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_PSNR }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "bit",    "Number of bits needed for the block", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_BIT }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "rd",     "Rate distortion optimal, slow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_RD }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "zero",   "Zero", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_ZERO }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "vsad",   "Sum of absolute vertical differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_VSAD }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "vsse",   "Sum of squared vertical differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_VSSE }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "nsse",   "Noise preserving sum of squared differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_NSSE }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "dct264", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCT264 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "dctmax", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCTMAX }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_CHROMA }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{ "msad",   "Sum of absolute differences, median predicted", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_MEDIAN_SAD }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }
-
-#ifndef FF_MPV_OFFSET
-#define FF_MPV_OFFSET(x) offsetof(MpegEncContext, x)
-#endif
-#if FF_API_MPV_RC_STRATEGY
-#define FF_MPV_RC_STRATEGY_OPTS \
-{"rc_strategy", "ratecontrol method",                               FF_MPV_OFFSET(rc_strategy), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, 1, FF_MPV_OPT_FLAGS | AV_OPT_FLAG_DEPRECATED, "rc_strategy" },   \
-    { "ffmpeg", "deprecated, does nothing", 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FF_MPV_OPT_FLAGS | AV_OPT_FLAG_DEPRECATED, "rc_strategy" }, \
-    { "xvid",   "deprecated, does nothing", 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FF_MPV_OPT_FLAGS | AV_OPT_FLAG_DEPRECATED, "rc_strategy" },
-#else
-#define FF_MPV_RC_STRATEGY_OPTS
-#endif
-#define FF_MPV_OPT_FLAGS (AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM)
-#define FF_MPV_COMMON_OPTS \
-FF_MPV_OPT_CMP_FUNC, \
-{ "mpv_flags",      "Flags common for all mpegvideo-based encoders.", FF_MPV_OFFSET(mpv_flags), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "skip_rd",        "RD optimal MB level residual skipping", 0, AV_OPT_TYPE_CONST, { .i64 = FF_MPV_FLAG_SKIP_RD },    0, 0, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "strict_gop",     "Strictly enforce gop size",             0, AV_OPT_TYPE_CONST, { .i64 = FF_MPV_FLAG_STRICT_GOP }, 0, 0, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "qp_rd",          "Use rate distortion optimization for qp selection", 0, AV_OPT_TYPE_CONST, { .i64 = FF_MPV_FLAG_QP_RD },  0, 0, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "cbp_rd",         "use rate distortion optimization for CBP",          0, AV_OPT_TYPE_CONST, { .i64 = FF_MPV_FLAG_CBP_RD }, 0, 0, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "naq",            "normalize adaptive quantization",                   0, AV_OPT_TYPE_CONST, { .i64 = FF_MPV_FLAG_NAQ },    0, 0, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "mv0",            "always try a mb with mv=<0,0>",                     0, AV_OPT_TYPE_CONST, { .i64 = FF_MPV_FLAG_MV0 },    0, 0, FF_MPV_OPT_FLAGS, "mpv_flags" },\
-{ "luma_elim_threshold",   "single coefficient elimination threshold for luminance (negative values also consider dc coefficient)",\
-                                                                      FF_MPV_OFFSET(luma_elim_threshold), AV_OPT_TYPE_INT, { .i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS },\
-{ "chroma_elim_threshold", "single coefficient elimination threshold for chrominance (negative values also consider dc coefficient)",\
-                                                                      FF_MPV_OFFSET(chroma_elim_threshold), AV_OPT_TYPE_INT, { .i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS },\
-{ "quantizer_noise_shaping", NULL,                                  FF_MPV_OFFSET(quantizer_noise_shaping), AV_OPT_TYPE_INT, { .i64 = 0 },       0, INT_MAX, FF_MPV_OPT_FLAGS },\
-{ "error_rate", "Simulate errors in the bitstream to test error concealment.",                                                                                                  \
-                                                                    FF_MPV_OFFSET(error_rate),              AV_OPT_TYPE_INT, { .i64 = 0 },       0, INT_MAX, FF_MPV_OPT_FLAGS },\
-{"qsquish", "how to keep quantizer between qmin and qmax (0 = clip, 1 = use differentiable function)",                                                                          \
-                                                                    FF_MPV_OFFSET(rc_qsquish), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, 0, 99, FF_MPV_OPT_FLAGS},                        \
-{"rc_qmod_amp", "experimental quantizer modulation",                FF_MPV_OFFSET(rc_qmod_amp), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, FF_MPV_OPT_FLAGS},           \
-{"rc_qmod_freq", "experimental quantizer modulation",               FF_MPV_OFFSET(rc_qmod_freq), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS},             \
-{"rc_eq", "Set rate control equation. When computing the expression, besides the standard functions "                                                                           \
-          "defined in the section 'Expression Evaluation', the following functions are available: "                                                                             \
-          "bits2qp(bits), qp2bits(qp). Also the following constants are available: iTex pTex tex mv "                                                                           \
-          "fCode iCount mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex avgBPTex avgTex.",                                                                         \
-                                                                    FF_MPV_OFFSET(rc_eq), AV_OPT_TYPE_STRING,                           .flags = FF_MPV_OPT_FLAGS },            \
-{"rc_init_cplx", "initial complexity for 1-pass encoding",          FF_MPV_OFFSET(rc_initial_cplx), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, FF_MPV_OPT_FLAGS},       \
-{"rc_buf_aggressivity", "currently useless",                        FF_MPV_OFFSET(rc_buffer_aggressivity), AV_OPT_TYPE_FLOAT, {.dbl = 1.0 }, -FLT_MAX, FLT_MAX, FF_MPV_OPT_FLAGS}, \
-{"border_mask", "increase the quantizer for macroblocks close to borders", FF_MPV_OFFSET(border_masking), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, FF_MPV_OPT_FLAGS},    \
-{"lmin", "minimum Lagrange factor (VBR)",                           FF_MPV_OFFSET(lmin), AV_OPT_TYPE_INT, {.i64 =  2*FF_QP2LAMBDA }, 0, INT_MAX, FF_MPV_OPT_FLAGS },            \
-{"lmax", "maximum Lagrange factor (VBR)",                           FF_MPV_OFFSET(lmax), AV_OPT_TYPE_INT, {.i64 = 31*FF_QP2LAMBDA }, 0, INT_MAX, FF_MPV_OPT_FLAGS },            \
-{"ibias", "intra quant bias",                                       FF_MPV_OFFSET(intra_quant_bias), AV_OPT_TYPE_INT, {.i64 = FF_DEFAULT_QUANT_BIAS }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS },   \
-{"pbias", "inter quant bias",                                       FF_MPV_OFFSET(inter_quant_bias), AV_OPT_TYPE_INT, {.i64 = FF_DEFAULT_QUANT_BIAS }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS },   \
-{"motion_est", "motion estimation algorithm",                       FF_MPV_OFFSET(motion_est), AV_OPT_TYPE_INT, {.i64 = FF_ME_EPZS }, FF_ME_ZERO, FF_ME_XONE, FF_MPV_OPT_FLAGS, "motion_est" },   \
-{ "zero", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_ME_ZERO }, 0, 0, FF_MPV_OPT_FLAGS, "motion_est" }, \
-{ "epzs", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_ME_EPZS }, 0, 0, FF_MPV_OPT_FLAGS, "motion_est" }, \
-{ "xone", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = FF_ME_XONE }, 0, 0, FF_MPV_OPT_FLAGS, "motion_est" }, \
-{ "force_duplicated_matrix", "Always write luma and chroma matrix for mjpeg, useful for rtp streaming.", FF_MPV_OFFSET(force_duplicated_matrix), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1, FF_MPV_OPT_FLAGS },   \
-{"b_strategy", "Strategy to choose between I/P/B-frames",           FF_MPV_OFFSET(b_frame_strategy), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, 2, FF_MPV_OPT_FLAGS }, \
-{"b_sensitivity", "Adjust sensitivity of b_frame_strategy 1",       FF_MPV_OFFSET(b_sensitivity), AV_OPT_TYPE_INT, {.i64 = 40 }, 1, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"brd_scale", "Downscale frames for dynamic B-frame decision",      FF_MPV_OFFSET(brd_scale), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, 3, FF_MPV_OPT_FLAGS }, \
-{"skip_threshold", "Frame skip threshold",                          FF_MPV_OFFSET(frame_skip_threshold), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"skip_factor", "Frame skip factor",                                FF_MPV_OFFSET(frame_skip_factor), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"skip_exp", "Frame skip exponent",                                 FF_MPV_OFFSET(frame_skip_exp), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"skip_cmp", "Frame skip compare function",                         FF_MPV_OFFSET(frame_skip_cmp), AV_OPT_TYPE_INT, {.i64 = FF_CMP_DCTMAX }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS, "cmp_func" }, \
-{"sc_threshold", "Scene change threshold",                          FF_MPV_OFFSET(scenechange_threshold), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"noise_reduction", "Noise reduction",                              FF_MPV_OFFSET(noise_reduction), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"mpeg_quant", "Use MPEG quantizers instead of H.263",              FF_MPV_OFFSET(mpeg_quant), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, 1, FF_MPV_OPT_FLAGS }, \
-{"ps", "RTP payload size in bytes",                             FF_MPV_OFFSET(rtp_payload_size), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"mepc", "Motion estimation bitrate penalty compensation (1.0 = 256)", FF_MPV_OFFSET(me_penalty_compensation), AV_OPT_TYPE_INT, {.i64 = 256 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"mepre", "pre motion estimation", FF_MPV_OFFSET(me_pre), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, FF_MPV_OPT_FLAGS }, \
-{"intra_penalty", "Penalty for intra blocks in block decision", FF_MPV_OFFSET(intra_penalty), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX/2, FF_MPV_OPT_FLAGS }, \
-{"a53cc", "Use A53 Closed Captions (if available)", FF_MPV_OFFSET(a53_cc), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, FF_MPV_OPT_FLAGS }, \
-FF_MPV_RC_STRATEGY_OPTS
-
-extern const AVOption ff_mpv_generic_options[];
 
 /**
  * Set the given MpegEncContext to common defaults (same for encoding
@@ -689,8 +548,6 @@
  */
 void ff_mpv_common_defaults(MpegEncContext *s);
 
-void ff_dct_encode_init_x86(MpegEncContext *s);
-
 int ff_mpv_common_init(MpegEncContext *s);
 void ff_mpv_common_init_arm(MpegEncContext *s);
 void ff_mpv_common_init_axp(MpegEncContext *s);
@@ -698,58 +555,48 @@
 void ff_mpv_common_init_ppc(MpegEncContext *s);
 void ff_mpv_common_init_x86(MpegEncContext *s);
 void ff_mpv_common_init_mips(MpegEncContext *s);
+/**
+ * Initialize an MpegEncContext's thread contexts. Presumes that
+ * slice_context_count is already set and that all the fields
+ * that are freed/reset in free_duplicate_context() are NULL.
+ */
+int ff_mpv_init_duplicate_contexts(MpegEncContext *s);
+/**
+ * Initialize and allocates MpegEncContext fields dependent on the resolution.
+ */
+int ff_mpv_init_context_frame(MpegEncContext *s);
+/**
+ * Frees and resets MpegEncContext fields depending on the resolution
+ * as well as the slice thread contexts.
+ * Is used during resolution changes to avoid a full reinitialization of the
+ * codec.
+ */
+void ff_mpv_free_context_frame(MpegEncContext *s);
 
-int ff_mpv_common_frame_size_change(MpegEncContext *s);
 void ff_mpv_common_end(MpegEncContext *s);
 
-void ff_mpv_decode_init(MpegEncContext *s, AVCodecContext *avctx);
-void ff_mpv_reconstruct_mb(MpegEncContext *s, int16_t block[12][64]);
-void ff_mpv_report_decode_progress(MpegEncContext *s);
-
-int ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx);
-void ff_mpv_frame_end(MpegEncContext *s);
-
-int ff_mpv_encode_init(AVCodecContext *avctx);
-void ff_mpv_encode_init_x86(MpegEncContext *s);
-
-int ff_mpv_encode_end(AVCodecContext *avctx);
-int ff_mpv_encode_picture(AVCodecContext *avctx, AVPacket *pkt,
-                          const AVFrame *frame, int *got_packet);
-int ff_mpv_reallocate_putbitbuffer(MpegEncContext *s, size_t threshold, size_t size_increase);
-
 void ff_clean_intra_table_entries(MpegEncContext *s);
-void ff_mpeg_draw_horiz_band(MpegEncContext *s, int y, int h);
-void ff_mpeg_flush(AVCodecContext *avctx);
-
-void ff_print_debug_info(MpegEncContext *s, Picture *p, AVFrame *pict);
-
-int ff_mpv_export_qp_table(MpegEncContext *s, AVFrame *f, Picture *p, int qp_type);
-
-void ff_write_quant_matrix(PutBitContext *pb, uint16_t *matrix);
 
-int ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src);
-int ff_mpeg_update_thread_context(AVCodecContext *dst, const AVCodecContext *src);
+int ff_update_duplicate_context(MpegEncContext *dst, const MpegEncContext *src);
 void ff_set_qscale(MpegEncContext * s, int qscale);
 
 void ff_mpv_idct_init(MpegEncContext *s);
-int ff_dct_encode_init(MpegEncContext *s);
-void ff_convert_matrix(MpegEncContext *s, int (*qmat)[64], uint16_t (*qmat16)[2][64],
-                       const uint16_t *quant_matrix, int bias, int qmin, int qmax, int intra);
-int ff_dct_quantize_c(MpegEncContext *s, int16_t *block, int n, int qscale, int *overflow);
-void ff_block_permute(int16_t *block, uint8_t *permutation,
-                      const uint8_t *scantable, int last);
+void ff_init_scantable(const uint8_t *permutation, ScanTable *st,
+                       const uint8_t *src_scantable);
 void ff_init_block_index(MpegEncContext *s);
 
 void ff_mpv_motion(MpegEncContext *s,
                    uint8_t *dest_y, uint8_t *dest_cb,
                    uint8_t *dest_cr, int dir,
-                   uint8_t **ref_picture,
+                   uint8_t *const *ref_picture,
                    op_pixels_func (*pix_op)[4],
                    qpel_mc_func (*qpix_op)[16]);
 
-static inline void ff_update_block_index(MpegEncContext *s){
-    const int bytes_per_pixel = 1 + (s->avctx->bits_per_raw_sample > 8);
-    const int block_size= (8*bytes_per_pixel) >> s->avctx->lowres;
+static inline void ff_update_block_index(MpegEncContext *s, int bits_per_raw_sample,
+                                         int lowres, int chroma_x_shift)
+{
+    const int bytes_per_pixel = 1 + (bits_per_raw_sample > 8);
+    const int block_size = (8 * bytes_per_pixel) >> lowres;
 
     s->block_index[0]+=2;
     s->block_index[1]+=2;
@@ -758,26 +605,8 @@
     s->block_index[4]++;
     s->block_index[5]++;
     s->dest[0]+= 2*block_size;
-    s->dest[1]+= (2 >> s->chroma_x_shift) * block_size;
-    s->dest[2]+= (2 >> s->chroma_x_shift) * block_size;
-}
-
-static inline int get_bits_diff(MpegEncContext *s){
-    const int bits= put_bits_count(&s->pb);
-    const int last= s->last_bits;
-
-    s->last_bits = bits;
-
-    return bits - last;
-}
-
-static inline int mpeg_get_qscale(MpegEncContext *s)
-{
-    int qscale = get_bits(&s->gb, 5);
-    if (s->q_scale_type)
-        return ff_mpeg2_non_linear_qscale[qscale];
-    else
-        return qscale << 1;
+    s->dest[1] += (2 >> chroma_x_shift) * block_size;
+    s->dest[2] += (2 >> chroma_x_shift) * block_size;
 }
 
 #endif /* AVCODEC_MPEGVIDEO_H */
diff -Naur a/media/ffvpx/libavcodec/null_bsf.c b/media/ffvpx/libavcodec/null_bsf.c
--- a/media/ffvpx/libavcodec/null_bsf.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/null_bsf.c	2023-04-06 12:49:40.254394930 +0200
@@ -21,10 +21,9 @@
  * Null bitstream filter -- pass the input through unchanged.
  */
 
-#include "bsf.h"
 #include "bsf_internal.h"
 
-const AVBitStreamFilter ff_null_bsf = {
-    .name           = "null",
+const FFBitStreamFilter ff_null_bsf = {
+    .p.name         = "null",
     .filter         = ff_bsf_get_packet_ref,
 };
diff -Naur a/media/ffvpx/libavcodec/options.c b/media/ffvpx/libavcodec/options.c
--- a/media/ffvpx/libavcodec/options.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/options.c	2023-04-06 12:50:24.492176543 +0200
@@ -24,8 +24,10 @@
  * Options definition for AVCodecContext.
  */
 
+#include "config_components.h"
+
 #include "avcodec.h"
-#include "internal.h"
+#include "codec_internal.h"
 #include "libavutil/avassert.h"
 #include "libavutil/internal.h"
 #include "libavutil/mem.h"
@@ -39,7 +41,7 @@
 static const char* context_to_name(void* ptr) {
     AVCodecContext *avc= ptr;
 
-    if(avc && avc->codec && avc->codec->name)
+    if (avc && avc->codec)
         return avc->codec->name;
     else
         return "NULL";
@@ -53,25 +55,6 @@
     return NULL;
 }
 
-#if FF_API_CHILD_CLASS_NEXT
-static const AVClass *codec_child_class_next(const AVClass *prev)
-{
-    void *iter = NULL;
-    const AVCodec *c = NULL;
-
-    /* find the codec that corresponds to prev */
-    while (prev && (c = av_codec_iterate(&iter)))
-        if (c->priv_class == prev)
-            break;
-
-    /* find next codec with priv options */
-    while (c = av_codec_iterate(&iter))
-        if (c->priv_class)
-            return c->priv_class;
-    return NULL;
-}
-#endif
-
 static const AVClass *codec_child_class_iterate(void **iter)
 {
     const AVCodec *c;
@@ -85,8 +68,10 @@
 static AVClassCategory get_category(void *ptr)
 {
     AVCodecContext* avctx = ptr;
-    if(avctx->codec && avctx->codec->decode) return AV_CLASS_CATEGORY_DECODER;
-    else                                     return AV_CLASS_CATEGORY_ENCODER;
+    if (avctx->codec && av_codec_is_decoder(avctx->codec))
+        return AV_CLASS_CATEGORY_DECODER;
+    else
+        return AV_CLASS_CATEGORY_ENCODER;
 }
 
 static const AVClass av_codec_context_class = {
@@ -96,9 +81,6 @@
     .version                 = LIBAVUTIL_VERSION_INT,
     .log_level_offset_offset = offsetof(AVCodecContext, log_level_offset),
     .child_next              = codec_child_next,
-#if FF_API_CHILD_CLASS_NEXT
-    .child_class_next        = codec_child_class_next,
-#endif
     .child_class_iterate     = codec_child_class_iterate,
     .category                = AV_CLASS_CATEGORY_ENCODER,
     .get_category            = get_category,
@@ -106,6 +88,7 @@
 
 static int init_context_defaults(AVCodecContext *s, const AVCodec *codec)
 {
+    const FFCodec *const codec2 = ffcodec(codec);
     int flags=0;
     memset(s, 0, sizeof(AVCodecContext));
 
@@ -125,6 +108,8 @@
         flags= AV_OPT_FLAG_SUBTITLE_PARAM;
     av_opt_set_defaults2(s, flags, flags);
 
+    av_channel_layout_uninit(&s->ch_layout);
+
     s->time_base           = (AVRational){0,1};
     s->framerate           = (AVRational){ 0, 1 };
     s->pkt_timebase        = (AVRational){ 0, 1 };
@@ -134,26 +119,28 @@
     s->execute             = avcodec_default_execute;
     s->execute2            = avcodec_default_execute2;
     s->sample_aspect_ratio = (AVRational){0,1};
+    s->ch_layout.order     = AV_CHANNEL_ORDER_UNSPEC;
     s->pix_fmt             = AV_PIX_FMT_NONE;
     s->sw_pix_fmt          = AV_PIX_FMT_NONE;
     s->sample_fmt          = AV_SAMPLE_FMT_NONE;
 
+#if FF_API_REORDERED_OPAQUE
+FF_DISABLE_DEPRECATION_WARNINGS
     s->reordered_opaque    = AV_NOPTS_VALUE;
-    if(codec && codec->priv_data_size){
-        if(!s->priv_data){
-            s->priv_data= av_mallocz(codec->priv_data_size);
-            if (!s->priv_data) {
-                return AVERROR(ENOMEM);
-            }
-        }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    if(codec && codec2->priv_data_size){
+        s->priv_data = av_mallocz(codec2->priv_data_size);
+        if (!s->priv_data)
+            return AVERROR(ENOMEM);
         if(codec->priv_class){
             *(const AVClass**)s->priv_data = codec->priv_class;
             av_opt_set_defaults(s->priv_data);
         }
     }
-    if (codec && codec->defaults) {
+    if (codec && codec2->defaults) {
         int ret;
-        const AVCodecDefault *d = codec->defaults;
+        const FFCodecDefault *d = codec2->defaults;
         while (d->key) {
             ret = av_opt_set(s, d->key, d->value, 0);
             av_assert0(ret >= 0);
@@ -163,13 +150,6 @@
     return 0;
 }
 
-#if FF_API_GET_CONTEXT_DEFAULTS
-int avcodec_get_context_defaults3(AVCodecContext *s, const AVCodec *codec)
-{
-    return init_context_defaults(s, codec);
-}
-#endif
-
 AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
 {
     AVCodecContext *avctx= av_malloc(sizeof(AVCodecContext));
@@ -199,149 +179,16 @@
     av_freep(&avctx->intra_matrix);
     av_freep(&avctx->inter_matrix);
     av_freep(&avctx->rc_override);
+    av_channel_layout_uninit(&avctx->ch_layout);
 
     av_freep(pavctx);
 }
 
-#if FF_API_COPY_CONTEXT
-static void copy_context_reset(AVCodecContext *avctx)
-{
-    int i;
-
-    av_opt_free(avctx);
-#if FF_API_CODED_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-    av_frame_free(&avctx->coded_frame);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-    av_freep(&avctx->rc_override);
-    av_freep(&avctx->intra_matrix);
-    av_freep(&avctx->inter_matrix);
-    av_freep(&avctx->extradata);
-    av_freep(&avctx->subtitle_header);
-    av_buffer_unref(&avctx->hw_frames_ctx);
-    av_buffer_unref(&avctx->hw_device_ctx);
-    for (i = 0; i < avctx->nb_coded_side_data; i++)
-        av_freep(&avctx->coded_side_data[i].data);
-    av_freep(&avctx->coded_side_data);
-    avctx->subtitle_header_size = 0;
-    avctx->nb_coded_side_data = 0;
-    avctx->extradata_size = 0;
-}
-
-int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src)
-{
-    const AVCodec *orig_codec = dest->codec;
-    uint8_t *orig_priv_data = dest->priv_data;
-
-    if (avcodec_is_open(dest)) { // check that the dest context is uninitialized
-        av_log(dest, AV_LOG_ERROR,
-               "Tried to copy AVCodecContext %p into already-initialized %p\n",
-               src, dest);
-        return AVERROR(EINVAL);
-    }
-
-    copy_context_reset(dest);
-
-    memcpy(dest, src, sizeof(*dest));
-    av_opt_copy(dest, src);
-
-    dest->priv_data       = orig_priv_data;
-    dest->codec           = orig_codec;
-
-    if (orig_priv_data && src->codec && src->codec->priv_class &&
-        dest->codec && dest->codec->priv_class)
-        av_opt_copy(orig_priv_data, src->priv_data);
-
-
-    /* set values specific to opened codecs back to their default state */
-    dest->slice_offset    = NULL;
-    dest->hwaccel         = NULL;
-    dest->internal        = NULL;
-#if FF_API_CODED_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-    dest->coded_frame     = NULL;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
-    /* reallocate values that should be allocated separately */
-    dest->extradata       = NULL;
-    dest->coded_side_data = NULL;
-    dest->intra_matrix    = NULL;
-    dest->inter_matrix    = NULL;
-    dest->rc_override     = NULL;
-    dest->subtitle_header = NULL;
-    dest->hw_frames_ctx   = NULL;
-    dest->hw_device_ctx   = NULL;
-    dest->nb_coded_side_data = 0;
-
-#define alloc_and_copy_or_fail(obj, size, pad) \
-    if (src->obj && size > 0) { \
-        dest->obj = av_malloc(size + pad); \
-        if (!dest->obj) \
-            goto fail; \
-        memcpy(dest->obj, src->obj, size); \
-        if (pad) \
-            memset(((uint8_t *) dest->obj) + size, 0, pad); \
-    }
-    alloc_and_copy_or_fail(extradata,    src->extradata_size,
-                           AV_INPUT_BUFFER_PADDING_SIZE);
-    dest->extradata_size  = src->extradata_size;
-    alloc_and_copy_or_fail(intra_matrix, 64 * sizeof(int16_t), 0);
-    alloc_and_copy_or_fail(inter_matrix, 64 * sizeof(int16_t), 0);
-    alloc_and_copy_or_fail(rc_override,  src->rc_override_count * sizeof(*src->rc_override), 0);
-    alloc_and_copy_or_fail(subtitle_header, src->subtitle_header_size, 1);
-    av_assert0(dest->subtitle_header_size == src->subtitle_header_size);
-#undef alloc_and_copy_or_fail
-
-    if (src->hw_frames_ctx) {
-        dest->hw_frames_ctx = av_buffer_ref(src->hw_frames_ctx);
-        if (!dest->hw_frames_ctx)
-            goto fail;
-    }
-
-    return 0;
-
-fail:
-    copy_context_reset(dest);
-    return AVERROR(ENOMEM);
-}
-#endif
-
 const AVClass *avcodec_get_class(void)
 {
     return &av_codec_context_class;
 }
 
-#if FF_API_GET_FRAME_CLASS
-#define FOFFSET(x) offsetof(AVFrame,x)
-
-static const AVOption frame_options[]={
-{"best_effort_timestamp", "", FOFFSET(best_effort_timestamp), AV_OPT_TYPE_INT64, {.i64 = AV_NOPTS_VALUE }, INT64_MIN, INT64_MAX, 0},
-{"pkt_pos", "", FOFFSET(pkt_pos), AV_OPT_TYPE_INT64, {.i64 = -1 }, INT64_MIN, INT64_MAX, 0},
-{"pkt_size", "", FOFFSET(pkt_size), AV_OPT_TYPE_INT64, {.i64 = -1 }, INT64_MIN, INT64_MAX, 0},
-{"sample_aspect_ratio", "", FOFFSET(sample_aspect_ratio), AV_OPT_TYPE_RATIONAL, {.dbl = 0 }, 0, INT_MAX, 0},
-{"width", "", FOFFSET(width), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, 0},
-{"height", "", FOFFSET(height), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, 0},
-{"format", "", FOFFSET(format), AV_OPT_TYPE_INT, {.i64 = -1 }, 0, INT_MAX, 0},
-{"channel_layout", "", FOFFSET(channel_layout), AV_OPT_TYPE_INT64, {.i64 = 0 }, 0, INT64_MAX, 0},
-{"sample_rate", "", FOFFSET(sample_rate), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, 0},
-{NULL},
-};
-
-static const AVClass av_frame_class = {
-    .class_name              = "AVFrame",
-    .item_name               = NULL,
-    .option                  = frame_options,
-    .version                 = LIBAVUTIL_VERSION_INT,
-};
-
-const AVClass *avcodec_get_frame_class(void)
-{
-    return &av_frame_class;
-}
-#endif
-
 #define SROFFSET(x) offsetof(AVSubtitleRect,x)
 
 static const AVOption subtitle_rect_options[]={
diff -Naur a/media/ffvpx/libavcodec/options_table.h b/media/ffvpx/libavcodec/options_table.h
--- a/media/ffvpx/libavcodec/options_table.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/options_table.h	2023-04-06 12:50:24.492176543 +0200
@@ -22,13 +22,15 @@
 #ifndef AVCODEC_OPTIONS_TABLE_H
 #define AVCODEC_OPTIONS_TABLE_H
 
+#include "config_components.h"
+
 #include <float.h>
 #include <limits.h>
 #include <stdint.h>
 
 #include "libavutil/opt.h"
 #include "avcodec.h"
-#include "version.h"
+#include "version_major.h"
 
 #define OFFSET(x) offsetof(AVCodecContext,x)
 #define DEFAULT 0 //should be NAN but it does not work as it is not a constant in glibc as required by ANSI/ISO C
@@ -55,11 +57,13 @@
 {"qpel", "use 1/4-pel motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QPEL }, INT_MIN, INT_MAX, V|E, "flags"},
 {"loop", "use loop filter", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOOP_FILTER }, INT_MIN, INT_MAX, V|E, "flags"},
 {"qscale", "use fixed qscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QSCALE }, INT_MIN, INT_MAX, 0, "flags"},
+{"recon_frame", "export reconstructed frames", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_RECON_FRAME}, .unit = "flags"},
+{"copy_opaque", "propagate opaque values", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_COPY_OPAQUE}, .unit = "flags"},
+{"frame_duration", "use frame durations", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_FRAME_DURATION}, .unit = "flags"},
 {"pass1", "use internal 2-pass ratecontrol in first  pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS1 }, INT_MIN, INT_MAX, 0, "flags"},
 {"pass2", "use internal 2-pass ratecontrol in second pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS2 }, INT_MIN, INT_MAX, 0, "flags"},
 {"gray", "only decode/encode grayscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GRAY }, INT_MIN, INT_MAX, V|E|D, "flags"},
 {"psnr", "error[?] variables will be set during encoding", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PSNR }, INT_MIN, INT_MAX, V|E, "flags"},
-{"truncated", "Input bitstream might be randomly truncated", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_TRUNCATED }, INT_MIN, INT_MAX, V|D, "flags"},
 {"ildct", "use interlaced DCT", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_INTERLACED_DCT }, INT_MIN, INT_MAX, V|E, "flags"},
 {"low_delay", "force low delay", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOW_DELAY }, INT_MIN, INT_MAX, V|D|E, "flags"},
 {"global_header", "place global headers in extradata instead of every keyframe", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GLOBAL_HEADER }, INT_MIN, INT_MAX, V|A|E, "flags"},
@@ -79,6 +83,7 @@
 {"export_mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_EXPORT_MVS}, INT_MIN, INT_MAX, V|D, "flags2"},
 {"skip_manual", "do not skip samples and export skip information as frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_SKIP_MANUAL}, INT_MIN, INT_MAX, A|D, "flags2"},
 {"ass_ro_flush_noop", "do not reset ASS ReadOrder field on flush", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_RO_FLUSH_NOOP}, INT_MIN, INT_MAX, S|D, "flags2"},
+{"icc_profiles", "generate/parse embedded ICC profiles from/to colorimetry tags", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_ICC_PROFILES}, INT_MIN, INT_MAX, S|D, "flags2"},
 {"export_side_data", "Export metadata as side data", OFFSET(export_side_data), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT}, 0, UINT_MAX, A|V|S|D|E, "export_side_data"},
 {"mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_MVS}, INT_MIN, INT_MAX, V|D, "export_side_data"},
 {"prft", "export Producer Reference Time through packet side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_PRFT}, INT_MIN, INT_MAX, A|V|S|E, "export_side_data"},
@@ -87,10 +92,12 @@
 {"time_base", NULL, OFFSET(time_base), AV_OPT_TYPE_RATIONAL, {.dbl = 0}, 0, INT_MAX},
 {"g", "set the group of picture (GOP) size", OFFSET(gop_size), AV_OPT_TYPE_INT, {.i64 = 12 }, INT_MIN, INT_MAX, V|E},
 {"ar", "set audio sampling rate (in Hz)", OFFSET(sample_rate), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, A|D|E},
+#if FF_API_OLD_CHANNEL_LAYOUT
 {"ac", "set number of audio channels", OFFSET(channels), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, A|D|E},
+#endif
 {"cutoff", "set cutoff bandwidth", OFFSET(cutoff), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, A|E},
 {"frame_size", NULL, OFFSET(frame_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, A|E},
-{"frame_number", NULL, OFFSET(frame_number), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
+{"frame_number", NULL, OFFSET(frame_num), AV_OPT_TYPE_INT64, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
 {"delay", NULL, OFFSET(delay), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
 {"qcomp", "video quantizer scale compression (VBR). Constant of ratecontrol equation. "
           "Recommended range for default rc_eq: 0.0-1.0",
@@ -101,21 +108,6 @@
 {"qdiff", "maximum difference between the quantizer scales (VBR)", OFFSET(max_qdiff), AV_OPT_TYPE_INT, {.i64 = 3 }, INT_MIN, INT_MAX, V|E},
 {"bf", "set maximum number of B-frames between non-B-frames", OFFSET(max_b_frames), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, -1, INT_MAX, V|E},
 {"b_qfactor", "QP factor between P- and B-frames", OFFSET(b_quant_factor), AV_OPT_TYPE_FLOAT, {.dbl = 1.25 }, -FLT_MAX, FLT_MAX, V|E},
-#if FF_API_PRIVATE_OPT
-{"b_strategy", "strategy to choose between I/P/B-frames", OFFSET(b_frame_strategy), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, V|E},
-{"ps", "RTP payload size in bytes", OFFSET(rtp_payload_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
-#if FF_API_STAT_BITS
-{"mv_bits", NULL, OFFSET(mv_bits), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"header_bits", NULL, OFFSET(header_bits), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"i_tex_bits", NULL, OFFSET(i_tex_bits), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"p_tex_bits", NULL, OFFSET(p_tex_bits), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"i_count", NULL, OFFSET(i_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"p_count", NULL, OFFSET(p_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"skip_count", NULL, OFFSET(skip_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"misc_bits", NULL, OFFSET(misc_bits), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"frame_bits", NULL, OFFSET(frame_bits), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-#endif
 {"codec_tag", NULL, OFFSET(codec_tag), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
 {"bug", "work around not autodetected encoder bugs", OFFSET(workaround_bugs), AV_OPT_TYPE_FLAGS, {.i64 = FF_BUG_AUTODETECT }, INT_MIN, INT_MAX, V|D, "bug"},
 {"autodetect", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_AUTODETECT }, INT_MIN, INT_MAX, V|D, "bug"},
@@ -151,9 +143,6 @@
 {"aggressive", "consider things that a sane encoder should not do as an error", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_AGGRESSIVE | AV_EF_COMPLIANT | AV_EF_CAREFUL}, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
 {"has_b_frames", NULL, OFFSET(has_b_frames), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
 {"block_align", NULL, OFFSET(block_align), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
-#if FF_API_PRIVATE_OPT
-{"mpeg_quant", "use MPEG quantizers instead of H.263", OFFSET(mpeg_quant), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
 {"rc_override_count", NULL, OFFSET(rc_override_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
 {"maxrate", "maximum bitrate (in bits/s). Used for VBV together with bufsize.", OFFSET(rc_max_rate), AV_OPT_TYPE_INT64, {.i64 = DEFAULT }, 0, INT_MAX, V|A|E},
 {"minrate", "minimum bitrate (in bits/s). Most useful in setting up a CBR encode. It is of little use otherwise.",
@@ -194,12 +183,6 @@
 {"deblock", "use strong deblock filter for damaged MBs", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_DEBLOCK }, INT_MIN, INT_MAX, V|D, "ec"},
 {"favor_inter", "favor predicting from the previous frame", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_FAVOR_INTER }, INT_MIN, INT_MAX, V|D, "ec"},
 {"bits_per_coded_sample", NULL, OFFSET(bits_per_coded_sample), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
-#if FF_API_PRIVATE_OPT
-{"pred", "prediction method", OFFSET(prediction_method), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "pred"},
-{"left", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_PRED_LEFT }, INT_MIN, INT_MAX, V|E, "pred"},
-{"plane", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_PRED_PLANE }, INT_MIN, INT_MAX, V|E, "pred"},
-{"median", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_PRED_MEDIAN }, INT_MIN, INT_MAX, V|E, "pred"},
-#endif
 {"aspect", "sample aspect ratio", OFFSET(sample_aspect_ratio), AV_OPT_TYPE_RATIONAL, {.dbl = 0}, 0, 10, V|E},
 {"sar",    "sample aspect ratio", OFFSET(sample_aspect_ratio), AV_OPT_TYPE_RATIONAL, {.dbl = 0}, 0, 10, V|E},
 {"debug", "print specific debug info", OFFSET(debug), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT }, 0, INT_MAX, V|A|S|E|D, "debug"},
@@ -220,34 +203,15 @@
 {"nomc", "skip motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_NOMC }, INT_MIN, INT_MAX, V|A|D, "debug"},
 {"dia_size", "diamond type & size for motion estimation", OFFSET(dia_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"last_pred", "amount of motion predictors from the previous frame", OFFSET(last_predictor_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#if FF_API_PRIVATE_OPT
-{"preme", "pre motion estimation", OFFSET(pre_me), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
 {"pre_dia_size", "diamond type & size for motion estimation pre-pass", OFFSET(pre_dia_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"subq", "sub-pel motion estimation quality", OFFSET(me_subpel_quality), AV_OPT_TYPE_INT, {.i64 = 8 }, INT_MIN, INT_MAX, V|E},
 {"me_range", "limit motion vectors range (1023 for DivX player)", OFFSET(me_range), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"global_quality", NULL, OFFSET(global_quality), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|A|E},
-#if FF_API_CODER_TYPE
-{"coder", NULL, OFFSET(coder_type), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "coder"},
-{"vlc", "variable length coder / Huffman coder", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CODER_TYPE_VLC }, INT_MIN, INT_MAX, V|E, "coder"},
-{"ac", "arithmetic coder", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CODER_TYPE_AC }, INT_MIN, INT_MAX, V|E, "coder"},
-{"raw", "raw (no encoding)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CODER_TYPE_RAW }, INT_MIN, INT_MAX, V|E, "coder"},
-{"rle", "run-length coder", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CODER_TYPE_RLE }, INT_MIN, INT_MAX, V|E, "coder"},
-#endif /* FF_API_CODER_TYPE */
-#if FF_API_PRIVATE_OPT
-{"context", "context model", OFFSET(context_model), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
 {"slice_flags", NULL, OFFSET(slice_flags), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
 {"mbd", "macroblock decision algorithm (high quality mode)", OFFSET(mb_decision), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, 2, V|E, "mbd"},
 {"simple", "use mbcmp", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_SIMPLE }, INT_MIN, INT_MAX, V|E, "mbd"},
 {"bits", "use fewest bits", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_BITS }, INT_MIN, INT_MAX, V|E, "mbd"},
 {"rd", "use best rate distortion", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_RD }, INT_MIN, INT_MAX, V|E, "mbd"},
-#if FF_API_PRIVATE_OPT
-{"sc_threshold", "scene change threshold", OFFSET(scenechange_threshold), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
-#if FF_API_PRIVATE_OPT
-{"nr", "noise reduction", OFFSET(noise_reduction), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
 {"rc_init_occupancy", "number of bits which should be loaded into the rc buffer before decoding starts", OFFSET(rc_initial_buffer_occupancy), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"threads", "set the number of threads", OFFSET(thread_count), AV_OPT_TYPE_INT, {.i64 = 1 }, 0, INT_MAX, V|A|E|D, "threads"},
 {"auto", "autodetect a suitable number of threads to use", 0, AV_OPT_TYPE_CONST, {.i64 = 0 }, INT_MIN, INT_MAX, V|E|D, "threads"},
@@ -261,12 +225,6 @@
 {"level", NULL, OFFSET(level), AV_OPT_TYPE_INT, {.i64 = FF_LEVEL_UNKNOWN }, INT_MIN, INT_MAX, V|A|E|CC, "avctx.level"},
 {"unknown", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_LEVEL_UNKNOWN }, INT_MIN, INT_MAX, V|A|E, "avctx.level"},
 {"lowres", "decode at 1= 1/2, 2=1/4, 3=1/8 resolutions", OFFSET(lowres), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, V|A|D},
-#if FF_API_PRIVATE_OPT
-{"skip_threshold", "frame skip threshold", OFFSET(frame_skip_threshold), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-{"skip_factor", "frame skip factor", OFFSET(frame_skip_factor), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-{"skip_exp", "frame skip exponent", OFFSET(frame_skip_exp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-{"skipcmp", "frame skip compare function", OFFSET(frame_skip_cmp), AV_OPT_TYPE_INT, {.i64 = FF_CMP_DCTMAX }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-#endif
 {"cmp", "full-pel ME compare function", OFFSET(me_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
 {"subcmp", "sub-pel ME compare function", OFFSET(me_sub_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
 {"mbcmp", "macroblock compare function", OFFSET(mb_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
@@ -292,9 +250,6 @@
 {"msad", "sum of absolute differences, median predicted", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_MEDIAN_SAD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
 {"mblmin", "minimum macroblock Lagrange factor (VBR)", OFFSET(mb_lmin), AV_OPT_TYPE_INT, {.i64 = FF_QP2LAMBDA * 2 }, 1, FF_LAMBDA_MAX, V|E},
 {"mblmax", "maximum macroblock Lagrange factor (VBR)", OFFSET(mb_lmax), AV_OPT_TYPE_INT, {.i64 = FF_QP2LAMBDA * 31 }, 1, FF_LAMBDA_MAX, V|E},
-#if FF_API_PRIVATE_OPT
-{"mepc", "motion estimation bitrate penalty compensation (1.0 = 256)", OFFSET(me_penalty_compensation), AV_OPT_TYPE_INT, {.i64 = 256 }, INT_MIN, INT_MAX, V|E},
-#endif
 {"skip_loop_filter", "skip loop filtering process for the selected frames", OFFSET(skip_loop_filter), AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
 {"skip_idct"       , "skip IDCT/dequantization for the selected frames",    OFFSET(skip_idct),        AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
 {"skip_frame"      , "skip decoding for the selected frames",               OFFSET(skip_frame),       AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
@@ -306,28 +261,17 @@
 {"nointra"         , "discard all frames except I frames",  0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONINTRA}, INT_MIN, INT_MAX, V|D, "avdiscard"},
 {"all"             , "discard all frames",                  0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_ALL     }, INT_MIN, INT_MAX, V|D, "avdiscard"},
 {"bidir_refine", "refine the two motion vectors used in bidirectional macroblocks", OFFSET(bidir_refine), AV_OPT_TYPE_INT, {.i64 = 1 }, 0, 4, V|E},
-#if FF_API_PRIVATE_OPT
-{"brd_scale", "downscale frames for dynamic B-frame decision", OFFSET(brd_scale), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, 10, V|E},
-#endif
 {"keyint_min", "minimum interval between IDR-frames", OFFSET(keyint_min), AV_OPT_TYPE_INT, {.i64 = 25 }, INT_MIN, INT_MAX, V|E},
 {"refs", "reference frames to consider for motion compensation", OFFSET(refs), AV_OPT_TYPE_INT, {.i64 = 1 }, INT_MIN, INT_MAX, V|E},
-#if FF_API_PRIVATE_OPT
-{"chromaoffset", "chroma QP offset from luma", OFFSET(chromaoffset), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-#endif
 {"trellis", "rate-distortion optimal quantization", OFFSET(trellis), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|A|E},
 {"mv0_threshold", NULL, OFFSET(mv0_threshold), AV_OPT_TYPE_INT, {.i64 = 256 }, 0, INT_MAX, V|E},
-#if FF_API_PRIVATE_OPT
-{"b_sensitivity", "adjust sensitivity of b_frame_strategy 1", OFFSET(b_sensitivity), AV_OPT_TYPE_INT, {.i64 = 40 }, 1, INT_MAX, V|E},
-#endif
 {"compression_level", NULL, OFFSET(compression_level), AV_OPT_TYPE_INT, {.i64 = FF_COMPRESSION_DEFAULT }, INT_MIN, INT_MAX, V|A|E},
-#if FF_API_PRIVATE_OPT
-{"min_prediction_order", NULL, OFFSET(min_prediction_order), AV_OPT_TYPE_INT, {.i64 = -1 }, INT_MIN, INT_MAX, A|E},
-{"max_prediction_order", NULL, OFFSET(max_prediction_order), AV_OPT_TYPE_INT, {.i64 = -1 }, INT_MIN, INT_MAX, A|E},
-{"timecode_frame_start", "GOP timecode frame start number, in non-drop-frame format", OFFSET(timecode_frame_start), AV_OPT_TYPE_INT64, {.i64 = -1 }, -1, INT64_MAX, V|E},
-#endif
 {"bits_per_raw_sample", NULL, OFFSET(bits_per_raw_sample), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
-{"channel_layout", NULL, OFFSET(channel_layout), AV_OPT_TYPE_UINT64, {.i64 = DEFAULT }, 0, UINT64_MAX, A|E|D, "channel_layout"},
-{"request_channel_layout", NULL, OFFSET(request_channel_layout), AV_OPT_TYPE_UINT64, {.i64 = DEFAULT }, 0, UINT64_MAX, A|D, "request_channel_layout"},
+{"ch_layout", NULL, OFFSET(ch_layout), AV_OPT_TYPE_CHLAYOUT, {.str = NULL }, 0, 0, A|E|D, "ch_layout"},
+#if FF_API_OLD_CHANNEL_LAYOUT
+{"channel_layout", NULL, OFFSET(channel_layout), AV_OPT_TYPE_CHANNEL_LAYOUT, {.i64 = DEFAULT }, 0, UINT64_MAX, A|E|D, "channel_layout"},
+{"request_channel_layout", NULL, OFFSET(request_channel_layout), AV_OPT_TYPE_CHANNEL_LAYOUT, {.i64 = DEFAULT }, 0, UINT64_MAX, A|D, "request_channel_layout"},
+#endif
 {"rc_max_vbv_use", NULL, OFFSET(rc_max_available_vbv_use), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, 0.0, FLT_MAX, V|E},
 {"rc_min_vbv_use", NULL, OFFSET(rc_min_vbv_overflow_use),  AV_OPT_TYPE_FLOAT, {.dbl = 3 },     0.0, FLT_MAX, V|E},
 {"ticks_per_frame", NULL, OFFSET(ticks_per_frame), AV_OPT_TYPE_INT, {.i64 = 1 }, 1, INT_MAX, A|V|E|D},
@@ -432,21 +376,6 @@
 {"auto",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_AUTOMATIC},   INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
 {"pre_decoder", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_PRE_DECODER}, INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
 {"ignore",      NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_IGNORE},      INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
-#if FF_API_ASS_TIMING
-{"sub_text_format", "set decoded text subtitle format", OFFSET(sub_text_format), AV_OPT_TYPE_INT, {.i64 = FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS}, 0, 1, S|D, "sub_text_format"},
-#else
-{"sub_text_format", "set decoded text subtitle format", OFFSET(sub_text_format), AV_OPT_TYPE_INT, {.i64 = FF_SUB_TEXT_FMT_ASS}, 0, 1, S|D, "sub_text_format"},
-#endif
-{"ass",              NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_TEXT_FMT_ASS},              INT_MIN, INT_MAX, S|D, "sub_text_format"},
-#if FF_API_ASS_TIMING
-{"ass_with_timings", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS}, INT_MIN, INT_MAX, S|D, "sub_text_format"},
-#endif
-#if FF_API_OLD_ENCDEC
-{"refcounted_frames", NULL, OFFSET(refcounted_frames), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, A|V|D },
-#endif
-#if FF_API_SIDEDATA_ONLY_PKT
-{"side_data_only_packets", NULL, OFFSET(side_data_only_packets), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, A|V|E },
-#endif
 {"apply_cropping", NULL, OFFSET(apply_cropping), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, V | D },
 {"skip_alpha", "Skip processing alpha", OFFSET(skip_alpha), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1, V|D },
 {"field_order", "Field order", OFFSET(field_order), AV_OPT_TYPE_INT, {.i64 = AV_FIELD_UNKNOWN }, 0, 5, V|D|E, "field_order" },
@@ -465,6 +394,7 @@
 {"ignore_level", "ignore level even if the codec level used is unknown or higher than the maximum supported level reported by the hardware driver", 0, AV_OPT_TYPE_CONST, { .i64 = AV_HWACCEL_FLAG_IGNORE_LEVEL }, INT_MIN, INT_MAX, V | D, "hwaccel_flags" },
 {"allow_high_depth", "allow to output YUV pixel formats with a different chroma sampling than 4:2:0 and/or other than 8 bits per component", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH }, INT_MIN, INT_MAX, V | D, "hwaccel_flags"},
 {"allow_profile_mismatch", "attempt to decode anyway if HW accelerated decoder's supported profiles do not exactly match the stream", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH }, INT_MIN, INT_MAX, V | D, "hwaccel_flags"},
+{"unsafe_output", "allow potentially unsafe hwaccel frame output that might require special care to process successfully", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_UNSAFE_OUTPUT }, INT_MIN, INT_MAX, V | D, "hwaccel_flags"},
 {"extra_hw_frames", "Number of extra hardware frames to allocate for the user", OFFSET(extra_hw_frames), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, V|D },
 {"discard_damaged_percentage", "Percentage of damaged samples to discard a frame", OFFSET(discard_damaged_percentage), AV_OPT_TYPE_INT, {.i64 = 95 }, 0, 100, V|D },
 {NULL},
diff -Naur a/media/ffvpx/libavcodec/packet.h b/media/ffvpx/libavcodec/packet.h
--- a/media/ffvpx/libavcodec/packet.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/packet.h	2023-04-06 12:50:06.973471134 +0200
@@ -28,8 +28,9 @@
 #include "libavutil/buffer.h"
 #include "libavutil/dict.h"
 #include "libavutil/rational.h"
+#include "libavutil/version.h"
 
-#include "libavcodec/version.h"
+#include "libavcodec/version_major.h"
 
 /**
  * @defgroup lavc_packet AVPacket
@@ -160,7 +161,7 @@
      * the packet may contain "dual mono" audio specific to Japanese DTV
      * and if it is true, recommends only the selected channel to be used.
      * @code
-     * u8    selected channels (0=mail/left, 1=sub/right, 2=both)
+     * u8    selected channels (0=main/left, 1=sub/right, 2=both)
      * @endcode
      */
     AV_PKT_DATA_JP_DUALMONO,
@@ -291,6 +292,14 @@
     AV_PKT_DATA_S12M_TIMECODE,
 
     /**
+     * HDR10+ dynamic metadata associated with a video frame. The metadata is in
+     * the form of the AVDynamicHDRPlus struct and contains
+     * information for color volume transform - application 4 of
+     * SMPTE 2094-40:2016 standard.
+     */
+    AV_PKT_DATA_DYNAMIC_HDR10_PLUS,
+
+    /**
      * The number of side data types.
      * This is not part of the public API/ABI in the sense that it may
      * change when new side data types are added.
@@ -305,11 +314,7 @@
 
 typedef struct AVPacketSideData {
     uint8_t *data;
-#if FF_API_BUFFER_SIZE_T
-    int      size;
-#else
     size_t   size;
-#endif
     enum AVPacketSideDataType type;
 } AVPacketSideData;
 
@@ -388,15 +393,29 @@
 
     int64_t pos;                            ///< byte position in stream, -1 if unknown
 
-#if FF_API_CONVERGENCE_DURATION
     /**
-     * @deprecated Same as the duration field, but as int64_t. This was required
-     * for Matroska subtitles, whose duration values could overflow when the
-     * duration field was still an int.
+     * for some private data of the user
      */
-    attribute_deprecated
-    int64_t convergence_duration;
-#endif
+    void *opaque;
+
+    /**
+     * AVBufferRef for free use by the API user. FFmpeg will never check the
+     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
+     * the packet is unreferenced. av_packet_copy_props() calls create a new
+     * reference with av_buffer_ref() for the target packet's opaque_ref field.
+     *
+     * This is unrelated to the opaque field, although it serves a similar
+     * purpose.
+     */
+    AVBufferRef *opaque_ref;
+
+    /**
+     * Time base of the packet's timestamps.
+     * In the future, this field may be set on packets output by encoders or
+     * demuxers, but its value will be by default ignored on input to decoders
+     * or muxers.
+     */
+    AVRational time_base;
 } AVPacket;
 
 #if FF_API_INIT_PACKET
@@ -429,8 +448,13 @@
 #define AV_PKT_FLAG_DISPOSABLE 0x0010
 
 enum AVSideDataParamChangeFlags {
+#if FF_API_OLD_CHANNEL_LAYOUT
+    /**
+     * @deprecated those are not used by any decoder
+     */
     AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT  = 0x0001,
     AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002,
+#endif
     AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE    = 0x0004,
     AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS     = 0x0008,
 };
@@ -529,45 +553,6 @@
  */
 int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size);
 
-#if FF_API_AVPACKET_OLD_API
-/**
- * @warning This is a hack - the packet memory allocation stuff is broken. The
- * packet is allocated if it was not really allocated.
- *
- * @deprecated Use av_packet_ref or av_packet_make_refcounted
- */
-attribute_deprecated
-int av_dup_packet(AVPacket *pkt);
-/**
- * Copy packet, including contents
- *
- * @return 0 on success, negative AVERROR on fail
- *
- * @deprecated Use av_packet_ref
- */
-attribute_deprecated
-int av_copy_packet(AVPacket *dst, const AVPacket *src);
-
-/**
- * Copy packet side data
- *
- * @return 0 on success, negative AVERROR on fail
- *
- * @deprecated Use av_packet_copy_props
- */
-attribute_deprecated
-int av_copy_packet_side_data(AVPacket *dst, const AVPacket *src);
-
-/**
- * Free a packet.
- *
- * @deprecated Use av_packet_unref
- *
- * @param pkt packet to free
- */
-attribute_deprecated
-void av_free_packet(AVPacket *pkt);
-#endif
 /**
  * Allocate new information of a packet.
  *
@@ -577,11 +562,7 @@
  * @return pointer to fresh allocated data or NULL otherwise
  */
 uint8_t* av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-#if FF_API_BUFFER_SIZE_T
-                                 int size);
-#else
                                  size_t size);
-#endif
 
 /**
  * Wrap an existing array as a packet side data.
@@ -608,11 +589,7 @@
  * @return 0 on success, < 0 on failure
  */
 int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-#if FF_API_BUFFER_SIZE_T
-                               int size);
-#else
                                size_t size);
-#endif
 
 /**
  * Get side information from packet.
@@ -624,19 +601,7 @@
  * @return pointer to data if present or NULL otherwise
  */
 uint8_t* av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type,
-#if FF_API_BUFFER_SIZE_T
-                                 int *size);
-#else
                                  size_t *size);
-#endif
-
-#if FF_API_MERGE_SD_API
-attribute_deprecated
-int av_packet_merge_side_data(AVPacket *pkt);
-
-attribute_deprecated
-int av_packet_split_side_data(AVPacket *pkt);
-#endif
 
 const char *av_packet_side_data_name(enum AVPacketSideDataType type);
 
@@ -647,11 +612,7 @@
  * @param size pointer to store the size of the returned data
  * @return pointer to data if successful, NULL otherwise
  */
-#if FF_API_BUFFER_SIZE_T
-uint8_t *av_packet_pack_dictionary(AVDictionary *dict, int *size);
-#else
 uint8_t *av_packet_pack_dictionary(AVDictionary *dict, size_t *size);
-#endif
 /**
  * Unpack a dictionary from side_data.
  *
@@ -660,12 +621,8 @@
  * @param dict the metadata storage dictionary
  * @return 0 on success, < 0 on failure
  */
-#if FF_API_BUFFER_SIZE_T
-int av_packet_unpack_dictionary(const uint8_t *data, int size, AVDictionary **dict);
-#else
 int av_packet_unpack_dictionary(const uint8_t *data, size_t size,
                                 AVDictionary **dict);
-#endif
 
 /**
  * Convenience function to free all the side data stored.
diff -Naur a/media/ffvpx/libavcodec/packet_internal.h b/media/ffvpx/libavcodec/packet_internal.h
--- a/media/ffvpx/libavcodec/packet_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/packet_internal.h	2023-04-06 12:49:40.255394971 +0200
@@ -23,16 +23,19 @@
 
 #include "packet.h"
 
-typedef struct PacketList {
+typedef struct PacketListEntry {
+    struct PacketListEntry *next;
     AVPacket pkt;
-    struct PacketList *next;
+} PacketListEntry;
+
+typedef struct PacketList {
+    PacketListEntry *head, *tail;
 } PacketList;
 
 /**
  * Append an AVPacket to the list.
  *
- * @param head  List head element
- * @param tail  List tail element
+ * @param list  A PacketList
  * @param pkt   The packet being appended. The data described in it will
  *              be made reference counted if it isn't already.
  * @param copy  A callback to copy the contents of the packet to the list.
@@ -41,8 +44,7 @@
  * @return 0 on success, negative AVERROR value on failure. On failure,
            the packet and the list are unchanged.
  */
-int avpriv_packet_list_put(PacketList **head, PacketList **tail,
-                           AVPacket *pkt,
+int avpriv_packet_list_put(PacketList *list, AVPacket *pkt,
                            int (*copy)(AVPacket *dst, const AVPacket *src),
                            int flags);
 
@@ -52,22 +54,17 @@
  * @note The pkt will be overwritten completely on success. The caller
  *       owns the packet and must unref it by itself.
  *
- * @param head List head element
- * @param tail List tail element
+ * @param head A pointer to a PacketList struct
  * @param pkt  Pointer to an AVPacket struct
  * @return 0 on success, and a packet is returned. AVERROR(EAGAIN) if
  *         the list was empty.
  */
-int avpriv_packet_list_get(PacketList **head, PacketList **tail,
-                           AVPacket *pkt);
+int avpriv_packet_list_get(PacketList *list, AVPacket *pkt);
 
 /**
  * Wipe the list and unref all the packets in it.
- *
- * @param head List head element
- * @param tail List tail element
  */
-void avpriv_packet_list_free(PacketList **head, PacketList **tail);
+void avpriv_packet_list_free(PacketList *list);
 
 int ff_side_data_set_encoder_stats(AVPacket *pkt, int quality, int64_t *error, int error_count, int pict_type);
 
diff -Naur a/media/ffvpx/libavcodec/parser.c b/media/ffvpx/libavcodec/parser.c
--- a/media/ffvpx/libavcodec/parser.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/parser.c	2023-04-06 12:49:40.255394971 +0200
@@ -25,10 +25,8 @@
 #include <string.h>
 
 #include "libavutil/avassert.h"
-#include "libavutil/internal.h"
 #include "libavutil/mem.h"
 
-#include "internal.h"
 #include "parser.h"
 
 AVCodecParserContext *av_parser_init(int codec_id)
@@ -46,7 +44,9 @@
             parser->codec_ids[1] == codec_id ||
             parser->codec_ids[2] == codec_id ||
             parser->codec_ids[3] == codec_id ||
-            parser->codec_ids[4] == codec_id)
+            parser->codec_ids[4] == codec_id ||
+            parser->codec_ids[5] == codec_id ||
+            parser->codec_ids[6] == codec_id)
             goto found;
     }
     return NULL;
@@ -55,7 +55,7 @@
     s = av_mallocz(sizeof(AVCodecParserContext));
     if (!s)
         goto err_out;
-    s->parser = (AVCodecParser*)parser;
+    s->parser = parser;
     s->priv_data = av_mallocz(parser->priv_data_size);
     if (!s->priv_data)
         goto err_out;
@@ -67,11 +67,6 @@
             goto err_out;
     }
     s->key_frame            = -1;
-#if FF_API_CONVERGENCE_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-    s->convergence_duration = 0;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     s->dts_sync_point       = INT_MIN;
     s->dts_ref_dts_delta    = INT_MIN;
     s->pts_dts_delta        = INT_MIN;
@@ -132,7 +127,9 @@
                avctx->codec_id == s->parser->codec_ids[1] ||
                avctx->codec_id == s->parser->codec_ids[2] ||
                avctx->codec_id == s->parser->codec_ids[3] ||
-               avctx->codec_id == s->parser->codec_ids[4]);
+               avctx->codec_id == s->parser->codec_ids[4] ||
+               avctx->codec_id == s->parser->codec_ids[5] ||
+               avctx->codec_id == s->parser->codec_ids[6]);
 
     if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {
         s->next_frame_offset =
@@ -189,42 +186,6 @@
     return index;
 }
 
-#if FF_API_PARSER_CHANGE
-int av_parser_change(AVCodecParserContext *s, AVCodecContext *avctx,
-                     uint8_t **poutbuf, int *poutbuf_size,
-                     const uint8_t *buf, int buf_size, int keyframe)
-{
-    if (s && s->parser->split) {
-        if (avctx->flags  & AV_CODEC_FLAG_GLOBAL_HEADER ||
-            avctx->flags2 & AV_CODEC_FLAG2_LOCAL_HEADER) {
-            int i = s->parser->split(avctx, buf, buf_size);
-            buf      += i;
-            buf_size -= i;
-        }
-    }
-
-    /* cast to avoid warning about discarding qualifiers */
-    *poutbuf      = (uint8_t *) buf;
-    *poutbuf_size = buf_size;
-    if (avctx->extradata) {
-        if (keyframe && (avctx->flags2 & AV_CODEC_FLAG2_LOCAL_HEADER)) {
-            int size = buf_size + avctx->extradata_size;
-
-            *poutbuf_size = size;
-            *poutbuf      = av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE);
-            if (!*poutbuf)
-                return AVERROR(ENOMEM);
-
-            memcpy(*poutbuf, avctx->extradata, avctx->extradata_size);
-            memcpy(*poutbuf + avctx->extradata_size, buf,
-                   buf_size + AV_INPUT_BUFFER_PADDING_SIZE);
-            return 1;
-        }
-    }
-
-    return 0;
-}
-#endif
 void av_parser_close(AVCodecParserContext *s)
 {
     if (s) {
@@ -326,17 +287,3 @@
 
     av_freep(&pc->buffer);
 }
-
-int ff_mpeg4video_split(AVCodecContext *avctx, const uint8_t *buf, int buf_size)
-{
-    uint32_t state = -1;
-    const uint8_t *ptr = buf, *end = buf + buf_size;
-
-    while (ptr < end) {
-        ptr = avpriv_find_start_code(ptr, end, &state);
-        if (state == 0x1B3 || state == 0x1B6)
-            return ptr - 4 - buf;
-    }
-
-    return 0;
-}
diff -Naur a/media/ffvpx/libavcodec/parser.h b/media/ffvpx/libavcodec/parser.h
--- a/media/ffvpx/libavcodec/parser.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/parser.h	2023-04-06 12:50:06.973471134 +0200
@@ -45,8 +45,6 @@
  *         AVERROR(ENOMEM) if there was a memory allocation error
  */
 int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size);
-int ff_mpeg4video_split(AVCodecContext *avctx, const uint8_t *buf,
-                        int buf_size);
 void ff_parse_close(AVCodecParserContext *s);
 
 /**
diff -Naur a/media/ffvpx/libavcodec/parser_list.c b/media/ffvpx/libavcodec/parser_list.c
--- a/media/ffvpx/libavcodec/parser_list.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/parser_list.c	2023-04-06 12:49:45.623611208 +0200
@@ -1,3 +1,5 @@
+#include "config_components.h"
+
 static const AVCodecParser * const parser_list[] = {
 #if CONFIG_VP8_PARSER
     &ff_vp8_parser,
diff -Naur a/media/ffvpx/libavcodec/parsers.c b/media/ffvpx/libavcodec/parsers.c
--- a/media/ffvpx/libavcodec/parsers.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/parsers.c	2023-04-06 12:50:06.973471134 +0200
@@ -18,98 +18,69 @@
 
 #include <stdint.h>
 
-#include "libavutil/thread.h"
-
 #include "avcodec.h"
-#include "version.h"
 
-extern AVCodecParser ff_aac_parser;
-extern AVCodecParser ff_aac_latm_parser;
-extern AVCodecParser ff_ac3_parser;
-extern AVCodecParser ff_adx_parser;
-extern AVCodecParser ff_av1_parser;
-extern AVCodecParser ff_avs2_parser;
-extern AVCodecParser ff_avs3_parser;
-extern AVCodecParser ff_bmp_parser;
-extern AVCodecParser ff_cavsvideo_parser;
-extern AVCodecParser ff_cook_parser;
-extern AVCodecParser ff_cri_parser;
-extern AVCodecParser ff_dca_parser;
-extern AVCodecParser ff_dirac_parser;
-extern AVCodecParser ff_dnxhd_parser;
-extern AVCodecParser ff_dolby_e_parser;
-extern AVCodecParser ff_dpx_parser;
-extern AVCodecParser ff_dvaudio_parser;
-extern AVCodecParser ff_dvbsub_parser;
-extern AVCodecParser ff_dvdsub_parser;
-extern AVCodecParser ff_dvd_nav_parser;
-extern AVCodecParser ff_flac_parser;
-extern AVCodecParser ff_g723_1_parser;
-extern AVCodecParser ff_g729_parser;
-extern AVCodecParser ff_gif_parser;
-extern AVCodecParser ff_gsm_parser;
-extern AVCodecParser ff_h261_parser;
-extern AVCodecParser ff_h263_parser;
-extern AVCodecParser ff_h264_parser;
-extern AVCodecParser ff_hevc_parser;
-extern AVCodecParser ff_ipu_parser;
-extern AVCodecParser ff_jpeg2000_parser;
-extern AVCodecParser ff_mjpeg_parser;
-extern AVCodecParser ff_mlp_parser;
-extern AVCodecParser ff_mpeg4video_parser;
-extern AVCodecParser ff_mpegaudio_parser;
-extern AVCodecParser ff_mpegvideo_parser;
-extern AVCodecParser ff_opus_parser;
-extern AVCodecParser ff_png_parser;
-extern AVCodecParser ff_pnm_parser;
-extern AVCodecParser ff_rv30_parser;
-extern AVCodecParser ff_rv40_parser;
-extern AVCodecParser ff_sbc_parser;
-extern AVCodecParser ff_sipr_parser;
-extern AVCodecParser ff_tak_parser;
-extern AVCodecParser ff_vc1_parser;
-extern AVCodecParser ff_vorbis_parser;
-extern AVCodecParser ff_vp3_parser;
-extern AVCodecParser ff_vp8_parser;
-extern AVCodecParser ff_vp9_parser;
-extern AVCodecParser ff_webp_parser;
-extern AVCodecParser ff_xbm_parser;
-extern AVCodecParser ff_xma_parser;
+extern const AVCodecParser ff_aac_parser;
+extern const AVCodecParser ff_aac_latm_parser;
+extern const AVCodecParser ff_ac3_parser;
+extern const AVCodecParser ff_adx_parser;
+extern const AVCodecParser ff_amr_parser;
+extern const AVCodecParser ff_av1_parser;
+extern const AVCodecParser ff_avs2_parser;
+extern const AVCodecParser ff_avs3_parser;
+extern const AVCodecParser ff_bmp_parser;
+extern const AVCodecParser ff_cavsvideo_parser;
+extern const AVCodecParser ff_cook_parser;
+extern const AVCodecParser ff_cri_parser;
+extern const AVCodecParser ff_dca_parser;
+extern const AVCodecParser ff_dirac_parser;
+extern const AVCodecParser ff_dnxhd_parser;
+extern const AVCodecParser ff_dolby_e_parser;
+extern const AVCodecParser ff_dpx_parser;
+extern const AVCodecParser ff_dvaudio_parser;
+extern const AVCodecParser ff_dvbsub_parser;
+extern const AVCodecParser ff_dvdsub_parser;
+extern const AVCodecParser ff_dvd_nav_parser;
+extern const AVCodecParser ff_flac_parser;
+extern const AVCodecParser ff_ftr_parser;
+extern const AVCodecParser ff_g723_1_parser;
+extern const AVCodecParser ff_g729_parser;
+extern const AVCodecParser ff_gif_parser;
+extern const AVCodecParser ff_gsm_parser;
+extern const AVCodecParser ff_h261_parser;
+extern const AVCodecParser ff_h263_parser;
+extern const AVCodecParser ff_h264_parser;
+extern const AVCodecParser ff_hevc_parser;
+extern const AVCodecParser ff_hdr_parser;
+extern const AVCodecParser ff_ipu_parser;
+extern const AVCodecParser ff_jpeg2000_parser;
+extern const AVCodecParser ff_misc4_parser;
+extern const AVCodecParser ff_mjpeg_parser;
+extern const AVCodecParser ff_mlp_parser;
+extern const AVCodecParser ff_mpeg4video_parser;
+extern const AVCodecParser ff_mpegaudio_parser;
+extern const AVCodecParser ff_mpegvideo_parser;
+extern const AVCodecParser ff_opus_parser;
+extern const AVCodecParser ff_png_parser;
+extern const AVCodecParser ff_pnm_parser;
+extern const AVCodecParser ff_qoi_parser;
+extern const AVCodecParser ff_rv30_parser;
+extern const AVCodecParser ff_rv40_parser;
+extern const AVCodecParser ff_sbc_parser;
+extern const AVCodecParser ff_sipr_parser;
+extern const AVCodecParser ff_tak_parser;
+extern const AVCodecParser ff_vc1_parser;
+extern const AVCodecParser ff_vorbis_parser;
+extern const AVCodecParser ff_vp3_parser;
+extern const AVCodecParser ff_vp8_parser;
+extern const AVCodecParser ff_vp9_parser;
+extern const AVCodecParser ff_webp_parser;
+extern const AVCodecParser ff_xbm_parser;
+extern const AVCodecParser ff_xma_parser;
+extern const AVCodecParser ff_xwd_parser;
 
 #include "libavcodec/parser_list.c"
 
-#if FF_API_NEXT
-FF_DISABLE_DEPRECATION_WARNINGS
-static AVOnce av_parser_next_init = AV_ONCE_INIT;
-
-static void av_parser_init_next(void)
-{
-    AVCodecParser *prev = NULL, *p;
-    int i = 0;
-    while ((p = (AVCodecParser*)parser_list[i++])) {
-        if (prev)
-            prev->next = p;
-        prev = p;
-    }
-}
-
-AVCodecParser *av_parser_next(const AVCodecParser *p)
-{
-    ff_thread_once(&av_parser_next_init, av_parser_init_next);
-
-    if (p)
-        return p->next;
-    else
-        return (AVCodecParser*)parser_list[0];
-}
-
-void av_register_codec_parser(AVCodecParser *parser)
-{
-    ff_thread_once(&av_parser_next_init, av_parser_init_next);
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 const AVCodecParser *av_parser_iterate(void **opaque)
 {
     uintptr_t i = (uintptr_t)*opaque;
diff -Naur a/media/ffvpx/libavcodec/pixblockdsp.h b/media/ffvpx/libavcodec/pixblockdsp.h
--- a/media/ffvpx/libavcodec/pixblockdsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/pixblockdsp.h	2023-04-06 12:50:06.973471134 +0200
@@ -52,6 +52,8 @@
                              unsigned high_bit_depth);
 void ff_pixblockdsp_init_ppc(PixblockDSPContext *c, AVCodecContext *avctx,
                              unsigned high_bit_depth);
+void ff_pixblockdsp_init_riscv(PixblockDSPContext *c, AVCodecContext *avctx,
+                               unsigned high_bit_depth);
 void ff_pixblockdsp_init_x86(PixblockDSPContext *c, AVCodecContext *avctx,
                              unsigned high_bit_depth);
 void ff_pixblockdsp_init_mips(PixblockDSPContext *c, AVCodecContext *avctx,
diff -Naur a/media/ffvpx/libavcodec/profiles.c b/media/ffvpx/libavcodec/profiles.c
--- a/media/ffvpx/libavcodec/profiles.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/profiles.c	2023-04-06 12:50:24.492176543 +0200
@@ -85,6 +85,7 @@
     { FF_PROFILE_HEVC_MAIN_10,              "Main 10"             },
     { FF_PROFILE_HEVC_MAIN_STILL_PICTURE,   "Main Still Picture"  },
     { FF_PROFILE_HEVC_REXT,                 "Rext"                },
+    { FF_PROFILE_HEVC_SCC,                  "Scc"                 },
     { FF_PROFILE_UNKNOWN },
 };
 
diff -Naur a/media/ffvpx/libavcodec/pthread.c b/media/ffvpx/libavcodec/pthread.c
--- a/media/ffvpx/libavcodec/pthread.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/pthread.c	2023-04-06 12:50:24.492176543 +0200
@@ -29,8 +29,10 @@
  * @see doc/multithreading.txt
  */
 
+#include "libavutil/thread.h"
+
 #include "avcodec.h"
-#include "internal.h"
+#include "codec_internal.h"
 #include "pthread_internal.h"
 #include "thread.h"
 
@@ -46,7 +48,6 @@
 static void validate_thread_parameters(AVCodecContext *avctx)
 {
     int frame_threading_supported = (avctx->codec->capabilities & AV_CODEC_CAP_FRAME_THREADS)
-                                && !(avctx->flags  & AV_CODEC_FLAG_TRUNCATED)
                                 && !(avctx->flags  & AV_CODEC_FLAG_LOW_DELAY)
                                 && !(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS);
     if (avctx->thread_count == 1) {
@@ -56,7 +57,7 @@
     } else if (avctx->codec->capabilities & AV_CODEC_CAP_SLICE_THREADS &&
                avctx->thread_type & FF_THREAD_SLICE) {
         avctx->active_thread_type = FF_THREAD_SLICE;
-    } else if (!(avctx->codec->caps_internal & FF_CODEC_CAP_AUTO_THREADS)) {
+    } else if (!(ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_AUTO_THREADS)) {
         avctx->thread_count       = 1;
         avctx->active_thread_type = 0;
     }
@@ -86,3 +87,39 @@
     else
         ff_slice_thread_free(avctx);
 }
+
+av_cold void ff_pthread_free(void *obj, const unsigned offsets[])
+{
+    unsigned cnt = *(unsigned*)((char*)obj + offsets[0]);
+    const unsigned *cur_offset = offsets;
+
+    *(unsigned*)((char*)obj + offsets[0]) = 0;
+
+    for (; *(++cur_offset) != THREAD_SENTINEL && cnt; cnt--)
+        pthread_mutex_destroy((pthread_mutex_t*)((char*)obj + *cur_offset));
+    for (; *(++cur_offset) != THREAD_SENTINEL && cnt; cnt--)
+        pthread_cond_destroy ((pthread_cond_t *)((char*)obj + *cur_offset));
+}
+
+av_cold int ff_pthread_init(void *obj, const unsigned offsets[])
+{
+    const unsigned *cur_offset = offsets;
+    unsigned cnt = 0;
+    int err;
+
+#define PTHREAD_INIT_LOOP(type)                                               \
+    for (; *(++cur_offset) != THREAD_SENTINEL; cnt++) {                       \
+        pthread_ ## type ## _t *dst = (void*)((char*)obj + *cur_offset);      \
+        err = pthread_ ## type ## _init(dst, NULL);                           \
+        if (err) {                                                            \
+            err = AVERROR(err);                                               \
+            goto fail;                                                        \
+        }                                                                     \
+    }
+    PTHREAD_INIT_LOOP(mutex)
+    PTHREAD_INIT_LOOP(cond)
+
+fail:
+    *(unsigned*)((char*)obj + offsets[0]) = cnt;
+    return err;
+}
diff -Naur a/media/ffvpx/libavcodec/pthread_frame.c b/media/ffvpx/libavcodec/pthread_frame.c
--- a/media/ffvpx/libavcodec/pthread_frame.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/pthread_frame.c	2023-04-06 12:50:24.492176543 +0200
@@ -28,11 +28,14 @@
 #include <stdint.h>
 
 #include "avcodec.h"
+#include "codec_internal.h"
+#include "decode.h"
 #include "hwconfig.h"
 #include "internal.h"
 #include "pthread_internal.h"
 #include "thread.h"
-#include "version.h"
+#include "threadframe.h"
+#include "version_major.h"
 
 #include "libavutil/avassert.h"
 #include "libavutil/buffer.h"
@@ -66,7 +69,7 @@
 
 enum {
     UNINITIALIZED,  ///< Thread has not been created, AVCodec->close mustn't be called
-    NEEDS_CLOSE,    ///< AVCodec->close needs to be called
+    NEEDS_CLOSE,    ///< FFCodec->close needs to be called
     INITIALIZED,    ///< Thread has been properly set up
 };
 
@@ -96,22 +99,6 @@
 
     atomic_int state;
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-    /**
-     * Array of frames passed to ff_thread_release_buffer().
-     * Frames are released after all threads referencing them are finished.
-     */
-    AVFrame **released_buffers;
-    int   num_released_buffers;
-    int       released_buffers_allocated;
-
-    AVFrame *requested_frame;       ///< AVFrame the codec passed to get_buffer()
-    int      requested_flags;       ///< flags passed to get_buffer() for requested_frame
-
-    const enum AVPixelFormat *available_formats; ///< Format array for get_format()
-    enum AVPixelFormat result_format;            ///< get_format() result
-#endif
-
     int die;                        ///< Set when the thread should exit.
 
     int hwaccel_serializing;
@@ -145,12 +132,13 @@
                                     * Set for the first N packets, where N is the number of threads.
                                     * While it is set, ff_thread_en/decode_frame won't return any results.
                                     */
-} FrameThreadContext;
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-#define THREAD_SAFE_CALLBACKS(avctx) \
-((avctx)->thread_safe_callbacks || (avctx)->get_buffer2 == avcodec_default_get_buffer2)
-#endif
+    /* hwaccel state is temporarily stored here in order to transfer its ownership
+     * to the next decoding thread without the need for extra synchronization */
+    const AVHWAccel *stash_hwaccel;
+    void            *stash_hwaccel_context;
+    void            *stash_hwaccel_priv;
+} FrameThreadContext;
 
 static void async_lock(FrameThreadContext *fctx)
 {
@@ -170,6 +158,17 @@
     pthread_mutex_unlock(&fctx->async_mutex);
 }
 
+static void thread_set_name(PerThreadContext *p)
+{
+    AVCodecContext *avctx = p->avctx;
+    int idx = p - p->parent->threads;
+    char name[16];
+
+    snprintf(name, sizeof(name), "av:%.7s:df%d", avctx->codec->name, idx);
+
+    ff_thread_setname(name);
+}
+
 /**
  * Codec worker thread.
  *
@@ -181,7 +180,9 @@
 {
     PerThreadContext *p = arg;
     AVCodecContext *avctx = p->avctx;
-    const AVCodec *codec = avctx->codec;
+    const FFCodec *codec = ffcodec(avctx->codec);
+
+    thread_set_name(p);
 
     pthread_mutex_lock(&p->mutex);
     while (1) {
@@ -190,14 +191,8 @@
 
         if (p->die) break;
 
-FF_DISABLE_DEPRECATION_WARNINGS
-        if (!codec->update_thread_context
-#if FF_API_THREAD_SAFE_CALLBACKS
-            && THREAD_SAFE_CALLBACKS(avctx)
-#endif
-            )
+        if (!codec->update_thread_context)
             ff_thread_finish_setup(avctx);
-FF_ENABLE_DEPRECATION_WARNINGS
 
         /* If a decoder supports hwaccel, then it must call ff_get_format().
          * Since that call must happen before ff_thread_finish_setup(), the
@@ -216,22 +211,26 @@
 
         av_frame_unref(p->frame);
         p->got_frame = 0;
-        p->result = codec->decode(avctx, p->frame, &p->got_frame, p->avpkt);
+        p->result = codec->cb.decode(avctx, p->frame, &p->got_frame, p->avpkt);
 
-        if ((p->result < 0 || !p->got_frame) && p->frame->buf[0]) {
-            if (avctx->codec->caps_internal & FF_CODEC_CAP_ALLOCATE_PROGRESS)
-                av_log(avctx, AV_LOG_ERROR, "A frame threaded decoder did not "
-                       "free the frame on failure. This is a bug, please report it.\n");
-            av_frame_unref(p->frame);
-        }
+        if ((p->result < 0 || !p->got_frame) && p->frame->buf[0])
+            ff_thread_release_buffer(avctx, p->frame);
 
         if (atomic_load(&p->state) == STATE_SETTING_UP)
             ff_thread_finish_setup(avctx);
 
         if (p->hwaccel_serializing) {
+            /* wipe hwaccel state to avoid stale pointers lying around;
+             * the state was transferred to FrameThreadContext in
+             * ff_thread_finish_setup(), so nothing is leaked */
+            avctx->hwaccel                     = NULL;
+            avctx->hwaccel_context             = NULL;
+            avctx->internal->hwaccel_priv_data = NULL;
+
             p->hwaccel_serializing = 0;
             pthread_mutex_unlock(&p->parent->hwaccel_mutex);
         }
+        av_assert0(!avctx->hwaccel);
 
         if (p->async_serializing) {
             p->async_serializing = 0;
@@ -262,9 +261,10 @@
  */
 static int update_context_from_thread(AVCodecContext *dst, AVCodecContext *src, int for_user)
 {
+    const FFCodec *const codec = ffcodec(dst->codec);
     int err = 0;
 
-    if (dst != src && (for_user || src->codec->update_thread_context)) {
+    if (dst != src && (for_user || codec->update_thread_context)) {
         dst->time_base = src->time_base;
         dst->framerate = src->framerate;
         dst->width     = src->width;
@@ -277,6 +277,7 @@
 
         dst->has_b_frames = src->has_b_frames;
         dst->idct_algo    = src->idct_algo;
+        dst->properties   = src->properties;
 
         dst->bits_per_coded_sample = src->bits_per_coded_sample;
         dst->sample_aspect_ratio   = src->sample_aspect_ratio;
@@ -293,14 +294,17 @@
         dst->color_range = src->color_range;
         dst->chroma_sample_location = src->chroma_sample_location;
 
-        dst->hwaccel = src->hwaccel;
-        dst->hwaccel_context = src->hwaccel_context;
-
-        dst->channels       = src->channels;
         dst->sample_rate    = src->sample_rate;
         dst->sample_fmt     = src->sample_fmt;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        dst->channels       = src->channels;
         dst->channel_layout = src->channel_layout;
-        dst->internal->hwaccel_priv_data = src->internal->hwaccel_priv_data;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+        err = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
+        if (err < 0)
+            return err;
 
         if (!!dst->hw_frames_ctx != !!src->hw_frames_ctx ||
             (dst->hw_frames_ctx && dst->hw_frames_ctx->data != src->hw_frames_ctx->data)) {
@@ -321,14 +325,11 @@
     }
 
     if (for_user) {
-#if FF_API_CODED_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-        dst->coded_frame = src->coded_frame;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
+        if (codec->update_thread_context_for_user)
+            err = codec->update_thread_context_for_user(dst, src);
     } else {
-        if (dst->codec->update_thread_context)
-            err = dst->codec->update_thread_context(dst, src);
+        if (codec->update_thread_context)
+            err = codec->update_thread_context(dst, src);
     }
 
     return err;
@@ -343,6 +344,8 @@
  */
 static int update_context_from_user(AVCodecContext *dst, AVCodecContext *src)
 {
+    int err;
+
     dst->flags          = src->flags;
 
     dst->draw_horiz_band= src->draw_horiz_band;
@@ -359,11 +362,15 @@
     dst->skip_idct        = src->skip_idct;
     dst->skip_frame       = src->skip_frame;
 
+    dst->frame_num        = src->frame_num;
+#if FF_API_AVCTX_FRAME_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
     dst->frame_number     = src->frame_number;
-    dst->reordered_opaque = src->reordered_opaque;
-#if FF_API_THREAD_SAFE_CALLBACKS
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+#if FF_API_REORDERED_OPAQUE
 FF_DISABLE_DEPRECATION_WARNINGS
-    dst->thread_safe_callbacks = src->thread_safe_callbacks;
+    dst->reordered_opaque = src->reordered_opaque;
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
 
@@ -378,31 +385,14 @@
                src->slice_count * sizeof(*dst->slice_offset));
     }
     dst->slice_count = src->slice_count;
-    return 0;
-}
-
-#if FF_API_THREAD_SAFE_CALLBACKS
-/// Releases the buffers that this decoding thread was the last user of.
-static void release_delayed_buffers(PerThreadContext *p)
-{
-    FrameThreadContext *fctx = p->parent;
-
-    while (p->num_released_buffers > 0) {
-        AVFrame *f;
 
-        pthread_mutex_lock(&fctx->buffer_mutex);
-
-        // fix extended data in case the caller screwed it up
-        av_assert0(p->avctx->codec_type == AVMEDIA_TYPE_VIDEO ||
-                   p->avctx->codec_type == AVMEDIA_TYPE_AUDIO);
-        f = p->released_buffers[--p->num_released_buffers];
-        f->extended_data = f->data;
-        av_frame_unref(f);
+    av_packet_unref(dst->internal->last_pkt_props);
+    err = av_packet_copy_props(dst->internal->last_pkt_props, src->internal->last_pkt_props);
+    if (err < 0)
+        return err;
 
-        pthread_mutex_unlock(&fctx->buffer_mutex);
-    }
+    return 0;
 }
-#endif
 
 static int submit_packet(PerThreadContext *p, AVCodecContext *user_avctx,
                          AVPacket *avpkt)
@@ -426,10 +416,6 @@
                           (p->avctx->debug & FF_DEBUG_THREADS) != 0,
                           memory_order_relaxed);
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-    release_delayed_buffers(p);
-#endif
-
     if (prev_thread) {
         int err;
         if (atomic_load(&prev_thread->state) == STATE_SETTING_UP) {
@@ -446,6 +432,12 @@
         }
     }
 
+    /* transfer the stashed hwaccel state, if any */
+    av_assert0(!p->avctx->hwaccel);
+    FFSWAP(const AVHWAccel*, p->avctx->hwaccel,                     fctx->stash_hwaccel);
+    FFSWAP(void*,            p->avctx->hwaccel_context,             fctx->stash_hwaccel_context);
+    FFSWAP(void*,            p->avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
+
     av_packet_unref(p->avpkt);
     ret = av_packet_ref(p->avpkt, avpkt);
     if (ret < 0) {
@@ -458,44 +450,6 @@
     pthread_cond_signal(&p->input_cond);
     pthread_mutex_unlock(&p->mutex);
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-FF_DISABLE_DEPRECATION_WARNINGS
-    /*
-     * If the client doesn't have a thread-safe get_buffer(),
-     * then decoding threads call back to the main thread,
-     * and it calls back to the client here.
-     */
-
-    if (!p->avctx->thread_safe_callbacks && (
-         p->avctx->get_format != avcodec_default_get_format ||
-         p->avctx->get_buffer2 != avcodec_default_get_buffer2)) {
-        while (atomic_load(&p->state) != STATE_SETUP_FINISHED && atomic_load(&p->state) != STATE_INPUT_READY) {
-            int call_done = 1;
-            pthread_mutex_lock(&p->progress_mutex);
-            while (atomic_load(&p->state) == STATE_SETTING_UP)
-                pthread_cond_wait(&p->progress_cond, &p->progress_mutex);
-
-            switch (atomic_load_explicit(&p->state, memory_order_acquire)) {
-            case STATE_GET_BUFFER:
-                p->result = ff_get_buffer(p->avctx, p->requested_frame, p->requested_flags);
-                break;
-            case STATE_GET_FORMAT:
-                p->result_format = ff_get_format(p->avctx, p->available_formats);
-                break;
-            default:
-                call_done = 0;
-                break;
-            }
-            if (call_done) {
-                atomic_store(&p->state, STATE_SETTING_UP);
-                pthread_cond_signal(&p->progress_cond);
-            }
-            pthread_mutex_unlock(&p->progress_mutex);
-        }
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     fctx->prev_thread = p;
     fctx->next_decoding++;
 
@@ -610,7 +564,7 @@
     pthread_mutex_unlock(&p->progress_mutex);
 }
 
-void ff_thread_await_progress(ThreadFrame *f, int n, int field)
+void ff_thread_await_progress(const ThreadFrame *f, int n, int field)
 {
     PerThreadContext *p;
     atomic_int *progress = f->progress ? (atomic_int*)f->progress->data : NULL;
@@ -649,6 +603,14 @@
         async_lock(p->parent);
     }
 
+    /* save hwaccel state for passing to the next thread;
+     * this is done here so that this worker thread can wipe its own hwaccel
+     * state after decoding, without requiring synchronization */
+    av_assert0(!p->parent->stash_hwaccel);
+    p->parent->stash_hwaccel         = avctx->hwaccel;
+    p->parent->stash_hwaccel_context = avctx->hwaccel_context;
+    p->parent->stash_hwaccel_priv    = avctx->internal->hwaccel_priv_data;
+
     pthread_mutex_lock(&p->progress_mutex);
     if(atomic_load(&p->state) == STATE_SETUP_FINISHED){
         av_log(avctx, AV_LOG_WARNING, "Multiple ff_thread_finish_setup() calls\n");
@@ -682,81 +644,26 @@
     async_lock(fctx);
 }
 
-#define SENTINEL 0 // This forbids putting a mutex/condition variable at the front.
-#define OFFSET_ARRAY(...) __VA_ARGS__, SENTINEL
-#define DEFINE_OFFSET_ARRAY(type, name, mutexes, conds)                       \
-static const unsigned name ## _offsets[] = { offsetof(type, pthread_init_cnt),\
-                                             OFFSET_ARRAY mutexes,            \
-                                             OFFSET_ARRAY conds }
-
 #define OFF(member) offsetof(FrameThreadContext, member)
-DEFINE_OFFSET_ARRAY(FrameThreadContext, thread_ctx,
+DEFINE_OFFSET_ARRAY(FrameThreadContext, thread_ctx, pthread_init_cnt,
                     (OFF(buffer_mutex), OFF(hwaccel_mutex), OFF(async_mutex)),
                     (OFF(async_cond)));
 #undef OFF
 
 #define OFF(member) offsetof(PerThreadContext, member)
-DEFINE_OFFSET_ARRAY(PerThreadContext, per_thread,
+DEFINE_OFFSET_ARRAY(PerThreadContext, per_thread, pthread_init_cnt,
                     (OFF(progress_mutex), OFF(mutex)),
                     (OFF(input_cond), OFF(progress_cond), OFF(output_cond)));
 #undef OFF
 
-static av_cold void free_pthread(void *obj, const unsigned offsets[])
-{
-    unsigned cnt = *(unsigned*)((char*)obj + offsets[0]);
-    const unsigned *cur_offset = offsets;
-
-    for (; *(++cur_offset) != SENTINEL && cnt; cnt--)
-        pthread_mutex_destroy((pthread_mutex_t*)((char*)obj + *cur_offset));
-    for (; *(++cur_offset) != SENTINEL && cnt; cnt--)
-        pthread_cond_destroy ((pthread_cond_t *)((char*)obj + *cur_offset));
-}
-
-static av_cold int init_pthread(void *obj, const unsigned offsets[])
-{
-    const unsigned *cur_offset = offsets;
-    unsigned cnt = 0;
-    int err;
-
-#define PTHREAD_INIT_LOOP(type)                                               \
-    for (; *(++cur_offset) != SENTINEL; cnt++) {                              \
-        pthread_ ## type ## _t *dst = (void*)((char*)obj + *cur_offset);      \
-        err = pthread_ ## type ## _init(dst, NULL);                           \
-        if (err) {                                                            \
-            err = AVERROR(err);                                               \
-            goto fail;                                                        \
-        }                                                                     \
-    }
-    PTHREAD_INIT_LOOP(mutex)
-    PTHREAD_INIT_LOOP(cond)
-
-fail:
-    *(unsigned*)((char*)obj + offsets[0]) = cnt;
-    return err;
-}
-
 void ff_frame_thread_free(AVCodecContext *avctx, int thread_count)
 {
     FrameThreadContext *fctx = avctx->internal->thread_ctx;
-    const AVCodec *codec = avctx->codec;
+    const FFCodec *codec = ffcodec(avctx->codec);
     int i;
 
     park_frame_worker_threads(fctx, thread_count);
 
-    if (fctx->prev_thread && avctx->internal->hwaccel_priv_data !=
-                             fctx->prev_thread->avctx->internal->hwaccel_priv_data) {
-        if (update_context_from_thread(avctx, fctx->prev_thread->avctx, 1) < 0) {
-            av_log(avctx, AV_LOG_ERROR, "Failed to update user thread.\n");
-        }
-    }
-
-    if (fctx->prev_thread && fctx->prev_thread != fctx->threads)
-        if (update_context_from_thread(fctx->threads->avctx, fctx->prev_thread->avctx, 0) < 0) {
-            av_log(avctx, AV_LOG_ERROR, "Final thread update failed\n");
-            fctx->prev_thread->avctx->internal->is_copy = fctx->threads->avctx->internal->is_copy;
-            fctx->threads->avctx->internal->is_copy = 1;
-        }
-
     for (i = 0; i < thread_count; i++) {
         PerThreadContext *p = &fctx->threads[i];
         AVCodecContext *ctx = p->avctx;
@@ -773,14 +680,8 @@
             if (codec->close && p->thread_init != UNINITIALIZED)
                 codec->close(ctx);
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-            release_delayed_buffers(p);
-            for (int j = 0; j < p->released_buffers_allocated; j++)
-                av_frame_free(&p->released_buffers[j]);
-            av_freep(&p->released_buffers);
-#endif
             if (ctx->priv_data) {
-                if (codec->priv_class)
+                if (codec->p.priv_class)
                     av_opt_free(ctx->priv_data);
                 av_freep(&ctx->priv_data);
             }
@@ -788,38 +689,42 @@
             av_freep(&ctx->slice_offset);
 
             av_buffer_unref(&ctx->internal->pool);
+            av_packet_free(&ctx->internal->last_pkt_props);
             av_freep(&ctx->internal);
             av_buffer_unref(&ctx->hw_frames_ctx);
         }
 
         av_frame_free(&p->frame);
 
-        free_pthread(p, per_thread_offsets);
+        ff_pthread_free(p, per_thread_offsets);
         av_packet_free(&p->avpkt);
 
         av_freep(&p->avctx);
     }
 
     av_freep(&fctx->threads);
-    free_pthread(fctx, thread_ctx_offsets);
+    ff_pthread_free(fctx, thread_ctx_offsets);
 
-    av_freep(&avctx->internal->thread_ctx);
+    /* if we have stashed hwaccel state, move it to the user-facing context,
+     * so it will be freed in avcodec_close() */
+    av_assert0(!avctx->hwaccel);
+    FFSWAP(const AVHWAccel*, avctx->hwaccel,                     fctx->stash_hwaccel);
+    FFSWAP(void*,            avctx->hwaccel_context,             fctx->stash_hwaccel_context);
+    FFSWAP(void*,            avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
 
-    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)
-        av_opt_free(avctx->priv_data);
-    avctx->codec = NULL;
+    av_freep(&avctx->internal->thread_ctx);
 }
 
 static av_cold int init_thread(PerThreadContext *p, int *threads_to_free,
                                FrameThreadContext *fctx, AVCodecContext *avctx,
-                               AVCodecContext *src, const AVCodec *codec, int first)
+                               const FFCodec *codec, int first)
 {
     AVCodecContext *copy;
     int err;
 
     atomic_init(&p->state, STATE_INPUT_READY);
 
-    copy = av_memdup(src, sizeof(*src));
+    copy = av_memdup(avctx, sizeof(*avctx));
     if (!copy)
         return AVERROR(ENOMEM);
     copy->priv_data = NULL;
@@ -831,7 +736,7 @@
     p->parent = fctx;
     p->avctx  = copy;
 
-    copy->internal = av_memdup(src->internal, sizeof(*src->internal));
+    copy->internal = av_mallocz(sizeof(*copy->internal));
     if (!copy->internal)
         return AVERROR(ENOMEM);
     copy->internal->thread_ctx = p;
@@ -843,26 +748,29 @@
         if (!copy->priv_data)
             return AVERROR(ENOMEM);
 
-        if (codec->priv_class) {
-            *(const AVClass **)copy->priv_data = codec->priv_class;
-            err = av_opt_copy(copy->priv_data, src->priv_data);
+        if (codec->p.priv_class) {
+            *(const AVClass **)copy->priv_data = codec->p.priv_class;
+            err = av_opt_copy(copy->priv_data, avctx->priv_data);
             if (err < 0)
                 return err;
         }
     }
 
-    err = init_pthread(p, per_thread_offsets);
+    err = ff_pthread_init(p, per_thread_offsets);
     if (err < 0)
         return err;
 
     if (!(p->frame = av_frame_alloc()) ||
         !(p->avpkt = av_packet_alloc()))
         return AVERROR(ENOMEM);
-    copy->internal->last_pkt_props = p->avpkt;
 
     if (!first)
         copy->internal->is_copy = 1;
 
+    copy->internal->last_pkt_props = av_packet_alloc();
+    if (!copy->internal->last_pkt_props)
+        return AVERROR(ENOMEM);
+
     if (codec->init) {
         err = codec->init(copy);
         if (err < 0) {
@@ -889,8 +797,7 @@
 int ff_frame_thread_init(AVCodecContext *avctx)
 {
     int thread_count = avctx->thread_count;
-    const AVCodec *codec = avctx->codec;
-    AVCodecContext *src = avctx;
+    const FFCodec *codec = ffcodec(avctx->codec);
     FrameThreadContext *fctx;
     int err, i = 0;
 
@@ -912,9 +819,9 @@
     if (!fctx)
         return AVERROR(ENOMEM);
 
-    err = init_pthread(fctx, thread_ctx_offsets);
+    err = ff_pthread_init(fctx, thread_ctx_offsets);
     if (err < 0) {
-        free_pthread(fctx, thread_ctx_offsets);
+        ff_pthread_free(fctx, thread_ctx_offsets);
         av_freep(&avctx->internal->thread_ctx);
         return err;
     }
@@ -922,10 +829,10 @@
     fctx->async_lock = 1;
     fctx->delaying = 1;
 
-    if (codec->type == AVMEDIA_TYPE_VIDEO)
-        avctx->delay = src->thread_count - 1;
+    if (codec->p.type == AVMEDIA_TYPE_VIDEO)
+        avctx->delay = avctx->thread_count - 1;
 
-    fctx->threads = av_mallocz_array(thread_count, sizeof(PerThreadContext));
+    fctx->threads = av_calloc(thread_count, sizeof(*fctx->threads));
     if (!fctx->threads) {
         err = AVERROR(ENOMEM);
         goto error;
@@ -935,7 +842,7 @@
         PerThreadContext *p  = &fctx->threads[i];
         int first = !i;
 
-        err = init_thread(p, &i, fctx, avctx, src, codec, first);
+        err = init_thread(p, &i, fctx, avctx, codec, first);
         if (err < 0)
             goto error;
     }
@@ -970,130 +877,49 @@
         av_frame_unref(p->frame);
         p->result = 0;
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-        release_delayed_buffers(p);
-#endif
-
-        if (avctx->codec->flush)
-            avctx->codec->flush(p->avctx);
+        if (ffcodec(avctx->codec)->flush)
+            ffcodec(avctx->codec)->flush(p->avctx);
     }
 }
 
 int ff_thread_can_start_frame(AVCodecContext *avctx)
 {
     PerThreadContext *p = avctx->internal->thread_ctx;
-FF_DISABLE_DEPRECATION_WARNINGS
+
     if ((avctx->active_thread_type&FF_THREAD_FRAME) && atomic_load(&p->state) != STATE_SETTING_UP &&
-        (avctx->codec->update_thread_context
-#if FF_API_THREAD_SAFE_CALLBACKS
-         || !THREAD_SAFE_CALLBACKS(avctx)
-#endif
-         )) {
+        ffcodec(avctx->codec)->update_thread_context) {
         return 0;
     }
-FF_ENABLE_DEPRECATION_WARNINGS
+
     return 1;
 }
 
-static int thread_get_buffer_internal(AVCodecContext *avctx, ThreadFrame *f, int flags)
+static int thread_get_buffer_internal(AVCodecContext *avctx, AVFrame *f, int flags)
 {
-    PerThreadContext *p = avctx->internal->thread_ctx;
+    PerThreadContext *p;
     int err;
 
-    f->owner[0] = f->owner[1] = avctx;
-
     if (!(avctx->active_thread_type & FF_THREAD_FRAME))
-        return ff_get_buffer(avctx, f->f, flags);
+        return ff_get_buffer(avctx, f, flags);
 
+    p = avctx->internal->thread_ctx;
 FF_DISABLE_DEPRECATION_WARNINGS
     if (atomic_load(&p->state) != STATE_SETTING_UP &&
-        (avctx->codec->update_thread_context
-#if FF_API_THREAD_SAFE_CALLBACKS
-         || !THREAD_SAFE_CALLBACKS(avctx)
-#endif
-         )) {
+        ffcodec(avctx->codec)->update_thread_context) {
 FF_ENABLE_DEPRECATION_WARNINGS
         av_log(avctx, AV_LOG_ERROR, "get_buffer() cannot be called after ff_thread_finish_setup()\n");
         return -1;
     }
 
-    if (avctx->codec->caps_internal & FF_CODEC_CAP_ALLOCATE_PROGRESS) {
-        atomic_int *progress;
-        f->progress = av_buffer_alloc(2 * sizeof(*progress));
-        if (!f->progress) {
-            return AVERROR(ENOMEM);
-        }
-        progress = (atomic_int*)f->progress->data;
-
-        atomic_init(&progress[0], -1);
-        atomic_init(&progress[1], -1);
-    }
-
     pthread_mutex_lock(&p->parent->buffer_mutex);
-#if !FF_API_THREAD_SAFE_CALLBACKS
-    err = ff_get_buffer(avctx, f->f, flags);
-#else
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (THREAD_SAFE_CALLBACKS(avctx)) {
-        err = ff_get_buffer(avctx, f->f, flags);
-    } else {
-        pthread_mutex_lock(&p->progress_mutex);
-        p->requested_frame = f->f;
-        p->requested_flags = flags;
-        atomic_store_explicit(&p->state, STATE_GET_BUFFER, memory_order_release);
-        pthread_cond_broadcast(&p->progress_cond);
-
-        while (atomic_load(&p->state) != STATE_SETTING_UP)
-            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);
-
-        err = p->result;
-
-        pthread_mutex_unlock(&p->progress_mutex);
-
-    }
-    if (!THREAD_SAFE_CALLBACKS(avctx) && !avctx->codec->update_thread_context)
-        ff_thread_finish_setup(avctx);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-    if (err)
-        av_buffer_unref(&f->progress);
+    err = ff_get_buffer(avctx, f, flags);
 
     pthread_mutex_unlock(&p->parent->buffer_mutex);
 
     return err;
 }
 
-#if FF_API_THREAD_SAFE_CALLBACKS
-FF_DISABLE_DEPRECATION_WARNINGS
-enum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)
-{
-    enum AVPixelFormat res;
-    PerThreadContext *p = avctx->internal->thread_ctx;
-    if (!(avctx->active_thread_type & FF_THREAD_FRAME) || avctx->thread_safe_callbacks ||
-        avctx->get_format == avcodec_default_get_format)
-        return ff_get_format(avctx, fmt);
-    if (atomic_load(&p->state) != STATE_SETTING_UP) {
-        av_log(avctx, AV_LOG_ERROR, "get_format() cannot be called after ff_thread_finish_setup()\n");
-        return -1;
-    }
-    pthread_mutex_lock(&p->progress_mutex);
-    p->available_formats = fmt;
-    atomic_store(&p->state, STATE_GET_FORMAT);
-    pthread_cond_broadcast(&p->progress_cond);
-
-    while (atomic_load(&p->state) != STATE_SETTING_UP)
-        pthread_cond_wait(&p->progress_cond, &p->progress_mutex);
-
-    res = p->result_format;
-
-    pthread_mutex_unlock(&p->progress_mutex);
-
-    return res;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
-int ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)
+int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f, int flags)
 {
     int ret = thread_get_buffer_internal(avctx, f, flags);
     if (ret < 0)
@@ -1101,71 +927,51 @@
     return ret;
 }
 
-void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)
+int ff_thread_get_ext_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)
 {
-#if FF_API_THREAD_SAFE_CALLBACKS
-FF_DISABLE_DEPRECATION_WARNINGS
-    PerThreadContext *p = avctx->internal->thread_ctx;
-    FrameThreadContext *fctx;
-    AVFrame *dst;
-    int ret = 0;
-    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||
-                          THREAD_SAFE_CALLBACKS(avctx);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
-    if (!f->f)
-        return;
-
-    if (avctx->debug & FF_DEBUG_BUFFERS)
-        av_log(avctx, AV_LOG_DEBUG, "thread_release_buffer called on pic %p\n", f);
-
-    av_buffer_unref(&f->progress);
-    f->owner[0] = f->owner[1] = NULL;
-
-#if !FF_API_THREAD_SAFE_CALLBACKS
-    av_frame_unref(f->f);
-#else
-    // when the frame buffers are not allocated, just reset it to clean state
-    if (can_direct_free || !f->f->buf[0]) {
-        av_frame_unref(f->f);
-        return;
-    }
+    int ret;
 
-    fctx = p->parent;
-    pthread_mutex_lock(&fctx->buffer_mutex);
+    f->owner[0] = f->owner[1] = avctx;
+    /* Hint: It is possible for this function to be called with codecs
+     * that don't support frame threading at all, namely in case
+     * a frame-threaded decoder shares code with codecs that are not.
+     * This currently affects non-MPEG-4 mpegvideo codecs and and VP7.
+     * The following check will always be true for them. */
+    if (!(avctx->active_thread_type & FF_THREAD_FRAME))
+        return ff_get_buffer(avctx, f->f, flags);
 
-    if (p->num_released_buffers == p->released_buffers_allocated) {
-        AVFrame **tmp = av_realloc_array(p->released_buffers, p->released_buffers_allocated + 1,
-                                         sizeof(*p->released_buffers));
-        if (tmp) {
-            tmp[p->released_buffers_allocated] = av_frame_alloc();
-            p->released_buffers = tmp;
+    if (ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_ALLOCATE_PROGRESS) {
+        atomic_int *progress;
+        f->progress = av_buffer_alloc(2 * sizeof(*progress));
+        if (!f->progress) {
+            return AVERROR(ENOMEM);
         }
+        progress = (atomic_int*)f->progress->data;
 
-        if (!tmp || !tmp[p->released_buffers_allocated]) {
-            ret = AVERROR(ENOMEM);
-            goto fail;
-        }
-        p->released_buffers_allocated++;
+        atomic_init(&progress[0], -1);
+        atomic_init(&progress[1], -1);
     }
 
-    dst = p->released_buffers[p->num_released_buffers];
-    av_frame_move_ref(dst, f->f);
+    ret = ff_thread_get_buffer(avctx, f->f, flags);
+    if (ret)
+        av_buffer_unref(&f->progress);
+    return ret;
+}
 
-    p->num_released_buffers++;
+void ff_thread_release_buffer(AVCodecContext *avctx, AVFrame *f)
+{
+    if (!f)
+        return;
 
-fail:
-    pthread_mutex_unlock(&fctx->buffer_mutex);
+    if (avctx->debug & FF_DEBUG_BUFFERS)
+        av_log(avctx, AV_LOG_DEBUG, "thread_release_buffer called on pic %p\n", f);
 
-    // make sure the frame is clean even if we fail to free it
-    // this leaks, but it is better than crashing
-    if (ret < 0) {
-        av_log(avctx, AV_LOG_ERROR, "Could not queue a frame for freeing, this will leak\n");
-        memset(f->f->buf, 0, sizeof(f->f->buf));
-        if (f->f->extended_buf)
-            memset(f->f->extended_buf, 0, f->f->nb_extended_buf * sizeof(*f->f->extended_buf));
-        av_frame_unref(f->f);
-    }
-#endif
+    av_frame_unref(f);
+}
+
+void ff_thread_release_ext_buffer(AVCodecContext *avctx, ThreadFrame *f)
+{
+    av_buffer_unref(&f->progress);
+    f->owner[0] = f->owner[1] = NULL;
+    ff_thread_release_buffer(avctx, f->f);
 }
diff -Naur a/media/ffvpx/libavcodec/pthread_internal.h b/media/ffvpx/libavcodec/pthread_internal.h
--- a/media/ffvpx/libavcodec/pthread_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/pthread_internal.h	2023-04-06 12:49:40.255394971 +0200
@@ -31,4 +31,36 @@
 int ff_frame_thread_init(AVCodecContext *avctx);
 void ff_frame_thread_free(AVCodecContext *avctx, int thread_count);
 
+#define THREAD_SENTINEL 0 // This forbids putting a mutex/condition variable at the front.
+/**
+ * Initialize/destroy a list of mutexes/conditions contained in a structure.
+ * The positions of these mutexes/conditions in the structure are given by
+ * their offsets. Because it is undefined behaviour to destroy
+ * an uninitialized mutex/condition, ff_pthread_init() stores the number
+ * of successfully initialized mutexes and conditions in the object itself
+ * and ff_pthread_free() uses this number to destroy exactly the mutexes and
+ * condition variables that have been successfully initialized.
+ *
+ * @param     obj     The object containing the mutexes/conditions.
+ * @param[in] offsets An array of offsets. Its first member gives the offset
+ *                    of the variable that contains the count of successfully
+ *                    initialized mutexes/condition variables; said variable
+ *                    must be an unsigned int. Two arrays of offsets, each
+ *                    delimited by a THREAD_SENTINEL follow. The first
+ *                    contains the offsets of all the mutexes, the second
+ *                    contains the offsets of all the condition variables.
+ */
+int  ff_pthread_init(void *obj, const unsigned offsets[]);
+void ff_pthread_free(void *obj, const unsigned offsets[]);
+
+/**
+ * Macros to help creating the above lists. mutexes and conds need
+ * to be parentheses-enclosed lists of offsets in the containing structure.
+ */
+#define OFFSET_ARRAY(...) __VA_ARGS__, THREAD_SENTINEL
+#define DEFINE_OFFSET_ARRAY(type, name, cnt_variable, mutexes, conds)         \
+static const unsigned name ## _offsets[] = { offsetof(type, cnt_variable),    \
+                                             OFFSET_ARRAY mutexes,            \
+                                             OFFSET_ARRAY conds }
+
 #endif // AVCODEC_PTHREAD_INTERNAL_H
diff -Naur a/media/ffvpx/libavcodec/pthread_slice.c b/media/ffvpx/libavcodec/pthread_slice.c
--- a/media/ffvpx/libavcodec/pthread_slice.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/pthread_slice.c	2023-04-06 12:50:06.973471134 +0200
@@ -25,6 +25,7 @@
 #include "config.h"
 
 #include "avcodec.h"
+#include "codec_internal.h"
 #include "internal.h"
 #include "pthread_internal.h"
 #include "thread.h"
@@ -40,6 +41,11 @@
 typedef int (action_func2)(AVCodecContext *c, void *arg, int jobnr, int threadnr);
 typedef int (main_func)(AVCodecContext *c);
 
+typedef struct Progress {
+    pthread_cond_t  cond;
+    pthread_mutex_t mutex;
+} Progress;
+
 typedef struct SliceThreadContext {
     AVSliceThread *thread;
     action_func *func;
@@ -52,8 +58,7 @@
     int *entries;
     int entries_count;
     int thread_count;
-    pthread_cond_t *progress_cond;
-    pthread_mutex_t *progress_mutex;
+    Progress *progress;
 } SliceThreadContext;
 
 static void main_function(void *priv) {
@@ -82,13 +87,13 @@
     avpriv_slicethread_free(&c->thread);
 
     for (i = 0; i < c->thread_count; i++) {
-        pthread_mutex_destroy(&c->progress_mutex[i]);
-        pthread_cond_destroy(&c->progress_cond[i]);
+        Progress *const progress = &c->progress[i];
+        pthread_mutex_destroy(&progress->mutex);
+        pthread_cond_destroy(&progress->cond);
     }
 
     av_freep(&c->entries);
-    av_freep(&c->progress_mutex);
-    av_freep(&c->progress_cond);
+    av_freep(&c->progress);
     av_freep(&avctx->internal->thread_ctx);
 }
 
@@ -155,7 +160,7 @@
     }
 
     avctx->internal->thread_ctx = c = av_mallocz(sizeof(*c));
-    mainfunc = avctx->codec->caps_internal & FF_CODEC_CAP_SLICE_THREAD_HAS_MF ? &main_function : NULL;
+    mainfunc = ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_SLICE_THREAD_HAS_MF ? &main_function : NULL;
     if (!c || (thread_count = avpriv_slicethread_create(&c->thread, avctx, worker_func, mainfunc, thread_count)) <= 1) {
         if (c)
             avpriv_slicethread_free(&c->thread);
@@ -171,72 +176,85 @@
     return 0;
 }
 
+int av_cold ff_slice_thread_init_progress(AVCodecContext *avctx)
+{
+    SliceThreadContext *const p = avctx->internal->thread_ctx;
+    int err, i = 0, thread_count = avctx->thread_count;
+
+    p->progress = av_calloc(thread_count, sizeof(*p->progress));
+    if (!p->progress) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    for (; i < thread_count; i++) {
+        Progress *const progress = &p->progress[i];
+        err = pthread_mutex_init(&progress->mutex, NULL);
+        if (err) {
+            err = AVERROR(err);
+            goto fail;
+        }
+        err = pthread_cond_init (&progress->cond,  NULL);
+        if (err) {
+            err = AVERROR(err);
+            pthread_mutex_destroy(&progress->mutex);
+            goto fail;
+        }
+    }
+    err = 0;
+fail:
+    p->thread_count = i;
+    return err;
+}
+
 void ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, int n)
 {
     SliceThreadContext *p = avctx->internal->thread_ctx;
+    Progress *const progress = &p->progress[thread];
     int *entries = p->entries;
 
-    pthread_mutex_lock(&p->progress_mutex[thread]);
+    pthread_mutex_lock(&progress->mutex);
     entries[field] +=n;
-    pthread_cond_signal(&p->progress_cond[thread]);
-    pthread_mutex_unlock(&p->progress_mutex[thread]);
+    pthread_cond_signal(&progress->cond);
+    pthread_mutex_unlock(&progress->mutex);
 }
 
 void ff_thread_await_progress2(AVCodecContext *avctx, int field, int thread, int shift)
 {
     SliceThreadContext *p  = avctx->internal->thread_ctx;
+    Progress *progress;
     int *entries      = p->entries;
 
     if (!entries || !field) return;
 
     thread = thread ? thread - 1 : p->thread_count - 1;
+    progress = &p->progress[thread];
 
-    pthread_mutex_lock(&p->progress_mutex[thread]);
+    pthread_mutex_lock(&progress->mutex);
     while ((entries[field - 1] - entries[field]) < shift){
-        pthread_cond_wait(&p->progress_cond[thread], &p->progress_mutex[thread]);
+        pthread_cond_wait(&progress->cond, &progress->mutex);
     }
-    pthread_mutex_unlock(&p->progress_mutex[thread]);
+    pthread_mutex_unlock(&progress->mutex);
 }
 
-int ff_alloc_entries(AVCodecContext *avctx, int count)
+int ff_slice_thread_allocz_entries(AVCodecContext *avctx, int count)
 {
-    int i;
-
     if (avctx->active_thread_type & FF_THREAD_SLICE)  {
         SliceThreadContext *p = avctx->internal->thread_ctx;
 
-        if (p->entries) {
-            av_assert0(p->thread_count == avctx->thread_count);
-            av_freep(&p->entries);
+        if (p->entries_count == count) {
+            memset(p->entries, 0, p->entries_count * sizeof(*p->entries));
+            return 0;
         }
+        av_freep(&p->entries);
 
-        p->thread_count  = avctx->thread_count;
-        p->entries       = av_mallocz_array(count, sizeof(int));
-
-        if (!p->progress_mutex) {
-            p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));
-            p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));
-        }
-
-        if (!p->entries || !p->progress_mutex || !p->progress_cond) {
-            av_freep(&p->entries);
-            av_freep(&p->progress_mutex);
-            av_freep(&p->progress_cond);
+        p->entries       = av_calloc(count, sizeof(*p->entries));
+        if (!p->entries) {
+            p->entries_count = 0;
             return AVERROR(ENOMEM);
         }
         p->entries_count  = count;
-
-        for (i = 0; i < p->thread_count; i++) {
-            pthread_mutex_init(&p->progress_mutex[i], NULL);
-            pthread_cond_init(&p->progress_cond[i], NULL);
-        }
     }
 
     return 0;
 }
-
-void ff_reset_entries(AVCodecContext *avctx)
-{
-    SliceThreadContext *p = avctx->internal->thread_ctx;
-    memset(p->entries, 0, p->entries_count * sizeof(int));
-}
diff -Naur a/media/ffvpx/libavcodec/put_bits.h b/media/ffvpx/libavcodec/put_bits.h
--- a/media/ffvpx/libavcodec/put_bits.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/put_bits.h	2023-04-06 12:50:24.492176543 +0200
@@ -32,12 +32,18 @@
 #include "config.h"
 #include "libavutil/intreadwrite.h"
 #include "libavutil/avassert.h"
+#include "libavutil/common.h"
 
-#include "version.h"
-
+#if ARCH_X86_64
+// TODO: Benchmark and optionally enable on other 64-bit architectures.
+typedef uint64_t BitBuf;
+#define AV_WBBUF AV_WB64
+#define AV_WLBUF AV_WL64
+#else
 typedef uint32_t BitBuf;
 #define AV_WBBUF AV_WB32
 #define AV_WLBUF AV_WL32
+#endif
 
 static const int BUF_BITS = 8 * sizeof(BitBuf);
 
@@ -45,7 +51,6 @@
     BitBuf bit_buf;
     int bit_left;
     uint8_t *buf, *buf_ptr, *buf_end;
-    int size_in_bits;
 } PutBitContext;
 
 /**
@@ -62,7 +67,6 @@
         buffer      = NULL;
     }
 
-    s->size_in_bits = 8 * buffer_size;
     s->buf          = buffer;
     s->buf_end      = s->buf + buffer_size;
     s->buf_ptr      = s->buf;
@@ -79,6 +83,26 @@
 }
 
 /**
+ * @return the number of bytes output so far; may only be called
+ *         when the PutBitContext is freshly initialized or flushed.
+ */
+static inline int put_bytes_output(const PutBitContext *s)
+{
+    av_assert2(s->bit_left == BUF_BITS);
+    return s->buf_ptr - s->buf;
+}
+
+/**
+ * @param  round_up  When set, the number of bits written so far will be
+ *                   rounded up to the next byte.
+ * @return the number of bytes output so far.
+ */
+static inline int put_bytes_count(const PutBitContext *s, int round_up)
+{
+    return s->buf_ptr - s->buf + ((BUF_BITS - s->bit_left + (round_up ? 7 : 0)) >> 3);
+}
+
+/**
  * Rebase the bit writer onto a reallocated buffer.
  *
  * @param buffer the buffer where to put bits
@@ -93,7 +117,6 @@
     s->buf_end = buffer + buffer_size;
     s->buf_ptr = buffer + (s->buf_ptr - s->buf);
     s->buf     = buffer;
-    s->size_in_bits = 8 * buffer_size;
 }
 
 /**
@@ -105,6 +128,16 @@
 }
 
 /**
+ * @param  round_up  When set, the number of bits written will be
+ *                   rounded up to the next byte.
+ * @return the number of bytes left.
+ */
+static inline int put_bytes_left(const PutBitContext *s, int round_up)
+{
+    return s->buf_end - s->buf_ptr - ((BUF_BITS - s->bit_left + (round_up ? 7 : 0)) >> 3);
+}
+
+/**
  * Pad the end of the output stream with zeros.
  */
 static inline void flush_put_bits(PutBitContext *s)
@@ -140,11 +173,6 @@
     s->bit_buf  = 0;
 }
 
-#if FF_API_AVPRIV_PUT_BITS
-void avpriv_align_put_bits(PutBitContext *s);
-void avpriv_copy_bits(PutBitContext *pb, const uint8_t *src, int length);
-#endif
-
 #ifdef BITSTREAM_WRITER_LE
 #define ff_put_string ff_put_string_unsupported_here
 #define ff_copy_bits ff_copy_bits_unsupported_here
@@ -335,6 +363,13 @@
     }
 }
 
+static inline void put_sbits63(PutBitContext *pb, int n, int64_t value)
+{
+    av_assert2(n >= 0 && n < 64);
+
+    put_bits64(pb, n, (uint64_t)(value) & (~(UINT64_MAX << n)));
+}
+
 /**
  * Return the pointer to the byte where the bitstream writer will put
  * the next bit.
@@ -377,7 +412,6 @@
 {
     av_assert0(size <= INT_MAX/8 - BUF_BITS);
     s->buf_end = s->buf + size;
-    s->size_in_bits = 8*size;
 }
 
 /**
diff -Naur a/media/ffvpx/libavcodec/ratecontrol.h b/media/ffvpx/libavcodec/ratecontrol.h
--- a/media/ffvpx/libavcodec/ratecontrol.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/ratecontrol.h	2023-04-06 12:50:24.492176543 +0200
@@ -80,9 +80,6 @@
     int frame_count[5];
     int last_non_b_pict_type;
 
-    void *non_lavc_opaque;        ///< context for non lavc rc code (for example xvid)
-    float dry_run_qscale;         ///< for xvid rc
-    int last_picture_number;      ///< for xvid rc
     AVExpr * rc_eq_eval;
 }RateControlContext;
 
diff -Naur a/media/ffvpx/libavcodec/raw.c b/media/ffvpx/libavcodec/raw.c
--- a/media/ffvpx/libavcodec/raw.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/raw.c	2023-04-06 12:50:06.973471134 +0200
@@ -24,11 +24,11 @@
  * Raw Video Codec
  */
 
+#include "libavutil/macros.h"
 #include "avcodec.h"
 #include "raw.h"
-#include "libavutil/common.h"
 
-const PixelFormatTag ff_raw_pix_fmt_tags[] = {
+static const PixelFormatTag raw_pix_fmt_tags[] = {
     { AV_PIX_FMT_YUV420P, MKTAG('I', '4', '2', '0') }, /* Planar formats */
     { AV_PIX_FMT_YUV420P, MKTAG('I', 'Y', 'U', 'V') },
     { AV_PIX_FMT_YUV420P, MKTAG('y', 'v', '1', '2') },
@@ -72,6 +72,7 @@
     { AV_PIX_FMT_GRAY8,   MKTAG('G', 'R', 'E', 'Y') },
     { AV_PIX_FMT_NV12,    MKTAG('N', 'V', '1', '2') },
     { AV_PIX_FMT_NV21,    MKTAG('N', 'V', '2', '1') },
+    { AV_PIX_FMT_VUYA,    MKTAG('A', 'Y', 'U', 'V') }, /* MS 4:4:4:4 */
 
     /* nut */
     { AV_PIX_FMT_RGB555LE, MKTAG('R', 'G', 'B', 15) },
@@ -299,12 +300,12 @@
 
 const struct PixelFormatTag *avpriv_get_raw_pix_fmt_tags(void)
 {
-    return ff_raw_pix_fmt_tags;
+    return raw_pix_fmt_tags;
 }
 
 unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat fmt)
 {
-    const PixelFormatTag *tags = ff_raw_pix_fmt_tags;
+    const PixelFormatTag *tags = raw_pix_fmt_tags;
     while (tags->pix_fmt >= 0) {
         if (tags->pix_fmt == fmt)
             return tags->fourcc;
@@ -313,7 +314,7 @@
     return 0;
 }
 
-const PixelFormatTag avpriv_pix_fmt_bps_avi[] = {
+static const PixelFormatTag pix_fmt_bps_avi[] = {
     { AV_PIX_FMT_PAL8,    1 },
     { AV_PIX_FMT_PAL8,    2 },
     { AV_PIX_FMT_PAL8,    4 },
@@ -326,7 +327,7 @@
     { AV_PIX_FMT_NONE,    0 },
 };
 
-const PixelFormatTag avpriv_pix_fmt_bps_mov[] = {
+static const PixelFormatTag pix_fmt_bps_mov[] = {
     { AV_PIX_FMT_PAL8,      1 },
     { AV_PIX_FMT_PAL8,      2 },
     { AV_PIX_FMT_PAL8,      4 },
@@ -337,3 +338,33 @@
     { AV_PIX_FMT_PAL8,     33 },
     { AV_PIX_FMT_NONE,      0 },
 };
+
+static enum AVPixelFormat find_pix_fmt(const PixelFormatTag *tags,
+                                       unsigned int fourcc)
+{
+    while (tags->pix_fmt != AV_PIX_FMT_NONE) {
+        if (tags->fourcc == fourcc)
+            return tags->pix_fmt;
+        tags++;
+    }
+    return AV_PIX_FMT_NONE;
+}
+
+enum AVPixelFormat avpriv_pix_fmt_find(enum PixelFormatTagLists list,
+                                       unsigned fourcc)
+{
+    const PixelFormatTag *tags;
+
+    switch (list) {
+    case PIX_FMT_LIST_RAW:
+        tags = raw_pix_fmt_tags;
+        break;
+    case PIX_FMT_LIST_AVI:
+        tags = pix_fmt_bps_avi;
+        break;
+    case PIX_FMT_LIST_MOV:
+        tags = pix_fmt_bps_mov;
+        break;
+    }
+    return find_pix_fmt(tags, fourcc);
+}
diff -Naur a/media/ffvpx/libavcodec/raw.h b/media/ffvpx/libavcodec/raw.h
--- a/media/ffvpx/libavcodec/raw.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/raw.h	2023-04-06 12:49:40.255394971 +0200
@@ -27,22 +27,22 @@
 #ifndef AVCODEC_RAW_H
 #define AVCODEC_RAW_H
 
-#include "avcodec.h"
-#include "internal.h"
-#include "libavutil/internal.h"
+#include "libavutil/pixfmt.h"
 
 typedef struct PixelFormatTag {
     enum AVPixelFormat pix_fmt;
     unsigned int fourcc;
 } PixelFormatTag;
 
-extern const PixelFormatTag ff_raw_pix_fmt_tags[]; // exposed through avpriv_get_raw_pix_fmt_tags()
-
 const struct PixelFormatTag *avpriv_get_raw_pix_fmt_tags(void);
 
-enum AVPixelFormat avpriv_find_pix_fmt(const PixelFormatTag *tags, unsigned int fourcc);
+enum PixelFormatTagLists {
+    PIX_FMT_LIST_RAW,
+    PIX_FMT_LIST_AVI,
+    PIX_FMT_LIST_MOV,
+};
 
-extern av_export_avcodec const PixelFormatTag avpriv_pix_fmt_bps_avi[];
-extern av_export_avcodec const PixelFormatTag avpriv_pix_fmt_bps_mov[];
+enum AVPixelFormat avpriv_pix_fmt_find(enum PixelFormatTagLists list,
+                                       unsigned fourcc);
 
 #endif /* AVCODEC_RAW_H */
diff -Naur a/media/ffvpx/libavcodec/rdft.c b/media/ffvpx/libavcodec/rdft.c
--- a/media/ffvpx/libavcodec/rdft.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/rdft.c	2023-04-06 12:49:40.255394971 +0200
@@ -20,6 +20,7 @@
  */
 #include <stdlib.h>
 #include <math.h>
+#include "libavutil/error.h"
 #include "libavutil/mathematics.h"
 #include "rdft.h"
 
@@ -106,7 +107,9 @@
     s->tsin = ff_cos_tabs[nbits] + (n >> 2);
     s->rdft_calc   = rdft_calc_c;
 
-    if (ARCH_ARM) ff_rdft_init_arm(s);
+#if ARCH_ARM
+    ff_rdft_init_arm(s);
+#endif
 
     return 0;
 }
diff -Naur a/media/ffvpx/libavcodec/rl.h b/media/ffvpx/libavcodec/rl.h
--- a/media/ffvpx/libavcodec/rl.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/rl.h	2023-04-06 12:50:06.973471134 +0200
@@ -49,23 +49,45 @@
 } RLTable;
 
 /**
+ * Initialize max_level and index_run from table_run and table_level;
+ * this is equivalent to initializing RLTable.max_level[0] and
+ * RLTable.index_run[0] with ff_rl_init().
+ */
+void ff_rl_init_level_run(uint8_t max_level[MAX_LEVEL + 1],
+                          uint8_t index_run[MAX_RUN + 1],
+                          const uint8_t table_run[/* n */],
+                          const uint8_t table_level[/* n*/], int n);
+
+/**
+ * Initialize index_run, max_level and max_run from n, last, table_vlc,
+ * table_run and table_level.
  * @param static_store static uint8_t array[2][2*MAX_RUN + MAX_LEVEL + 3]
  *                     to hold the level and run tables.
+ * @note  This function does not touch rl_vlc at all, hence there is no need
+ *        to synchronize calls to ff_rl_init() and ff_rl_init_vlc() using the
+ *        same RLTable.
  */
 void ff_rl_init(RLTable *rl, uint8_t static_store[2][2*MAX_RUN + MAX_LEVEL + 3]);
+
+/**
+ * Initialize rl_vlc from n, last, table_vlc, table_run and table_level.
+ * All rl_vlc pointers to be initialized must already point to a static
+ * buffer of `static_size` RL_VLC_ELEM elements; if a pointer is NULL,
+ * initializing further VLCs stops.
+ * @note  This function does not touch what ff_rl_init() initializes at all,
+ *        hence there is no need to synchronize calls to ff_rl_init() and
+ *        ff_rl_init_vlc() using the same RLTable.
+ */
 void ff_rl_init_vlc(RLTable *rl, unsigned static_size);
 
 #define INIT_VLC_RL(rl, static_size)\
 {\
-    int q;\
     static RL_VLC_ELEM rl_vlc_table[32][static_size];\
 \
-    if(!rl.rl_vlc[0]){\
-        for(q=0; q<32; q++)\
-            rl.rl_vlc[q]= rl_vlc_table[q];\
+    for (int q = 0; q < 32; q++) \
+        rl.rl_vlc[q] = rl_vlc_table[q]; \
 \
-        ff_rl_init_vlc(&rl, static_size);\
-    }\
+    ff_rl_init_vlc(&rl, static_size); \
 }
 
 #define INIT_FIRST_VLC_RL(rl, static_size)              \
diff -Naur a/media/ffvpx/libavcodec/simple_idct.c b/media/ffvpx/libavcodec/simple_idct.c
--- a/media/ffvpx/libavcodec/simple_idct.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/simple_idct.c	2023-04-06 12:49:40.255394971 +0200
@@ -26,7 +26,6 @@
  */
 
 #include "libavutil/intreadwrite.h"
-#include "avcodec.h"
 #include "mathops.h"
 #include "simple_idct.h"
 
diff -Naur a/media/ffvpx/libavcodec/startcode.h b/media/ffvpx/libavcodec/startcode.h
--- a/media/ffvpx/libavcodec/startcode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/startcode.h	2023-04-06 12:49:40.255394971 +0200
@@ -0,0 +1,36 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Accelerated start code search function for start codes common to
+ * MPEG-1/2/4 video, VC-1, H.264/5
+ */
+
+#ifndef AVCODEC_STARTCODE_H
+#define AVCODEC_STARTCODE_H
+
+#include <stdint.h>
+
+const uint8_t *avpriv_find_start_code(const uint8_t *p,
+                                      const uint8_t *end,
+                                      uint32_t *state);
+
+int ff_startcode_find_candidate_c(const uint8_t *buf, int size);
+
+#endif /* AVCODEC_STARTCODE_H */
diff -Naur a/media/ffvpx/libavcodec/threadframe.h b/media/ffvpx/libavcodec/threadframe.h
--- a/media/ffvpx/libavcodec/threadframe.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/threadframe.h	2023-04-06 12:50:06.973471134 +0200
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2022 Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_THREADFRAME_H
+#define AVCODEC_THREADFRAME_H
+
+#include "libavutil/frame.h"
+#include "avcodec.h"
+
+typedef struct ThreadFrame {
+    AVFrame *f;
+    AVCodecContext *owner[2];
+    // progress->data is an array of 2 ints holding progress for top/bottom
+    // fields
+    AVBufferRef *progress;
+} ThreadFrame;
+
+/**
+ * Notify later decoding threads when part of their reference picture is ready.
+ * Call this when some part of the picture is finished decoding.
+ * Later calls with lower values of progress have no effect.
+ *
+ * @param f The picture being decoded.
+ * @param progress Value, in arbitrary units, of how much of the picture has decoded.
+ * @param field The field being decoded, for field-picture codecs.
+ * 0 for top field or frame pictures, 1 for bottom field.
+ */
+void ff_thread_report_progress(ThreadFrame *f, int progress, int field);
+
+/**
+ * Wait for earlier decoding threads to finish reference pictures.
+ * Call this before accessing some part of a picture, with a given
+ * value for progress, and it will return after the responsible decoding
+ * thread calls ff_thread_report_progress() with the same or
+ * higher value for progress.
+ *
+ * @param f The picture being referenced.
+ * @param progress Value, in arbitrary units, to wait for.
+ * @param field The field being referenced, for field-picture codecs.
+ * 0 for top field or frame pictures, 1 for bottom field.
+ */
+void ff_thread_await_progress(const ThreadFrame *f, int progress, int field);
+
+/**
+ * Wrapper around ff_get_buffer() for frame-multithreaded codecs.
+ * Call this function instead of ff_get_buffer() if you might need
+ * to wait for progress on this frame.
+ * Cannot be called after the codec has called ff_thread_finish_setup().
+ *
+ * @param avctx The current context.
+ * @param f The frame to write into.
+ * @note: It is fine to call this with codecs that do not support
+ *        frame threading.
+ */
+int ff_thread_get_ext_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags);
+
+/**
+ * Unref a ThreadFrame.
+ *
+ * This is basically a wrapper around av_frame_unref() and should
+ * be called instead of it.
+ *
+ * @param avctx The current context.
+ * @param f The picture being released.
+ */
+void ff_thread_release_ext_buffer(AVCodecContext *avctx, ThreadFrame *f);
+
+int ff_thread_ref_frame(ThreadFrame *dst, const ThreadFrame *src);
+
+int ff_thread_can_start_frame(AVCodecContext *avctx);
+
+#endif
diff -Naur a/media/ffvpx/libavcodec/thread.h b/media/ffvpx/libavcodec/thread.h
--- a/media/ffvpx/libavcodec/thread.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/thread.h	2023-04-06 12:50:24.492176543 +0200
@@ -31,14 +31,6 @@
 
 #include "avcodec.h"
 
-typedef struct ThreadFrame {
-    AVFrame *f;
-    AVCodecContext *owner[2];
-    // progress->data is an array of 2 ints holding progress for top/bottom
-    // fields
-    AVBufferRef *progress;
-} ThreadFrame;
-
 /**
  * Wait for decoding threads to finish and reset internal state.
  * Called by avcodec_flush_buffers().
@@ -52,10 +44,10 @@
  * Returns the next available frame in picture. *got_picture_ptr
  * will be 0 if none is available.
  * The return value on success is the size of the consumed packet for
- * compatibility with avcodec_decode_video2(). This means the decoder
+ * compatibility with FFCodec.decode. This means the decoder
  * has to consume the full packet.
  *
- * Parameters are the same as avcodec_decode_video2().
+ * Parameters are the same as FFCodec.decode.
  */
 int ff_thread_decode_frame(AVCodecContext *avctx, AVFrame *picture,
                            int *got_picture_ptr, AVPacket *avpkt);
@@ -70,45 +62,7 @@
  */
 void ff_thread_finish_setup(AVCodecContext *avctx);
 
-/**
- * Notify later decoding threads when part of their reference picture is ready.
- * Call this when some part of the picture is finished decoding.
- * Later calls with lower values of progress have no effect.
- *
- * @param f The picture being decoded.
- * @param progress Value, in arbitrary units, of how much of the picture has decoded.
- * @param field The field being decoded, for field-picture codecs.
- * 0 for top field or frame pictures, 1 for bottom field.
- */
-void ff_thread_report_progress(ThreadFrame *f, int progress, int field);
-
-/**
- * Wait for earlier decoding threads to finish reference pictures.
- * Call this before accessing some part of a picture, with a given
- * value for progress, and it will return after the responsible decoding
- * thread calls ff_thread_report_progress() with the same or
- * higher value for progress.
- *
- * @param f The picture being referenced.
- * @param progress Value, in arbitrary units, to wait for.
- * @param field The field being referenced, for field-picture codecs.
- * 0 for top field or frame pictures, 1 for bottom field.
- */
-void ff_thread_await_progress(ThreadFrame *f, int progress, int field);
-
-#if FF_API_THREAD_SAFE_CALLBACKS
-/**
- * Wrapper around get_format() for frame-multithreaded codecs.
- * Call this function instead of avctx->get_format().
- * Cannot be called after the codec has called ff_thread_finish_setup().
- *
- * @param avctx The current context.
- * @param fmt The list of available formats.
- */
-enum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt);
-#else
 #define ff_thread_get_format ff_get_format
-#endif
 
 /**
  * Wrapper around get_buffer() for frame-multithreaded codecs.
@@ -118,7 +72,7 @@
  * @param avctx The current context.
  * @param f The frame to write into.
  */
-int ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags);
+int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f, int flags);
 
 /**
  * Wrapper around release_buffer() frame-for multithreaded codecs.
@@ -131,17 +85,15 @@
  * @param avctx The current context.
  * @param f The picture being released.
  */
-void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f);
-
-int ff_thread_ref_frame(ThreadFrame *dst, const ThreadFrame *src);
+void ff_thread_release_buffer(AVCodecContext *avctx, AVFrame *f);
 
 int ff_thread_init(AVCodecContext *s);
 int ff_slice_thread_execute_with_mainfunc(AVCodecContext *avctx,
         int (*action_func2)(AVCodecContext *c, void *arg, int jobnr, int threadnr),
         int (*main_func)(AVCodecContext *c), void *arg, int *ret, int job_count);
 void ff_thread_free(AVCodecContext *s);
-int ff_alloc_entries(AVCodecContext *avctx, int count);
-void ff_reset_entries(AVCodecContext *avctx);
+int ff_slice_thread_allocz_entries(AVCodecContext *avctx, int count);
+int ff_slice_thread_init_progress(AVCodecContext *avctx);
 void ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, int n);
 void ff_thread_await_progress2(AVCodecContext *avctx,  int field, int thread, int shift);
 
diff -Naur a/media/ffvpx/libavcodec/utils.c b/media/ffvpx/libavcodec/utils.c
--- a/media/ffvpx/libavcodec/utils.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/utils.c	2023-04-06 12:50:24.492176543 +0200
@@ -27,25 +27,24 @@
 
 #include "config.h"
 #include "libavutil/avassert.h"
-#include "libavutil/avstring.h"
+#include "libavutil/channel_layout.h"
 #include "libavutil/intreadwrite.h"
-#include "libavutil/mem_internal.h"
+#include "libavutil/mem.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/pixfmt.h"
 #include "avcodec.h"
 #include "codec.h"
+#include "codec_internal.h"
+#include "decode.h"
 #include "hwconfig.h"
 #include "thread.h"
+#include "threadframe.h"
 #include "internal.h"
 #include "put_bits.h"
-#include "raw.h"
-#include "version.h"
+#include "startcode.h"
 #include <stdlib.h>
-#include <stdarg.h>
-#include <stdatomic.h>
 #include <limits.h>
-#include <float.h>
 
 void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
 {
@@ -55,7 +54,8 @@
         *size = 0;
         return;
     }
-    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))
+    av_fast_mallocz(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (*p)
         memset(*p + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 }
 
@@ -67,18 +67,25 @@
         *size = 0;
         return;
     }
-    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))
+    av_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (*p)
         memset(*p, 0, min_size + AV_INPUT_BUFFER_PADDING_SIZE);
 }
 
-int av_codec_is_encoder(const AVCodec *codec)
+int av_codec_is_encoder(const AVCodec *avcodec)
 {
-    return codec && (codec->encode_sub || codec->encode2 || codec->receive_packet);
+    const FFCodec *const codec = ffcodec(avcodec);
+    return codec && (codec->cb_type == FF_CODEC_CB_TYPE_ENCODE     ||
+                     codec->cb_type == FF_CODEC_CB_TYPE_ENCODE_SUB ||
+                     codec->cb_type == FF_CODEC_CB_TYPE_RECEIVE_PACKET);
 }
 
-int av_codec_is_decoder(const AVCodec *codec)
+int av_codec_is_decoder(const AVCodec *avcodec)
 {
-    return codec && (codec->decode || codec->receive_frame);
+    const FFCodec *const codec = ffcodec(avcodec);
+    return codec && (codec->cb_type == FF_CODEC_CB_TYPE_DECODE     ||
+                     codec->cb_type == FF_CODEC_CB_TYPE_DECODE_SUB ||
+                     codec->cb_type == FF_CODEC_CB_TYPE_RECEIVE_FRAME);
 }
 
 int ff_set_dimensions(AVCodecContext *s, int width, int height)
@@ -236,6 +243,8 @@
     case AV_PIX_FMT_GBRAP16BE:
         w_align = 16; //FIXME assume 16 pixel per macroblock
         h_align = 16 * 2; // interlaced needs 2 macroblocks height
+        if (s->codec_id == AV_CODEC_ID_BINKVIDEO)
+            w_align = 16*2;
         break;
     case AV_PIX_FMT_YUV411P:
     case AV_PIX_FMT_YUVJ411P:
@@ -314,6 +323,7 @@
     *width  = FFALIGN(*width, w_align);
     *height = FFALIGN(*height, h_align);
     if (s->codec_id == AV_CODEC_ID_H264 || s->lowres ||
+        s->codec_id == AV_CODEC_ID_VC1  || s->codec_id == AV_CODEC_ID_WMV3 ||
         s->codec_id == AV_CODEC_ID_VP5  || s->codec_id == AV_CODEC_ID_VP6 ||
         s->codec_id == AV_CODEC_ID_VP6F || s->codec_id == AV_CODEC_ID_VP6A
     ) {
@@ -327,6 +337,9 @@
         // the next rounded up width is 32
         *width = FFMAX(*width, 32);
     }
+    if (s->codec_id == AV_CODEC_ID_SVQ3) {
+        *width = FFMAX(*width, 32);
+    }
 
     for (i = 0; i < 4; i++)
         linesize_align[i] = STRIDE_ALIGN;
@@ -346,29 +359,17 @@
     align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
     *width              = FFALIGN(*width, align);
 }
-
+#if FF_API_AVCODEC_CHROMA_POS
 int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
 {
-    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)
-        return AVERROR(EINVAL);
-    pos--;
-
-    *xpos = (pos&1) * 128;
-    *ypos = ((pos>>1)^(pos<4)) * 128;
-
-    return 0;
+    return av_chroma_location_enum_to_pos(xpos, ypos, pos);
 }
 
 enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
 {
-    int pos, xout, yout;
-
-    for (pos = AVCHROMA_LOC_UNSPECIFIED + 1; pos < AVCHROMA_LOC_NB; pos++) {
-        if (avcodec_enum_to_chroma_pos(&xout, &yout, pos) == 0 && xout == xpos && yout == ypos)
-            return pos;
-    }
-    return AVCHROMA_LOC_UNSPECIFIED;
+    return av_chroma_location_pos_to_enum(xpos, ypos);
 }
+#endif
 
 int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
                              enum AVSampleFormat sample_fmt, const uint8_t *buf,
@@ -384,8 +385,7 @@
 
     planar = av_sample_fmt_is_planar(sample_fmt);
     if (planar && nb_channels > AV_NUM_DATA_POINTERS) {
-        if (!(frame->extended_data = av_mallocz_array(nb_channels,
-                                                sizeof(*frame->extended_data))))
+        if (!FF_ALLOCZ_TYPED_ARRAY(frame->extended_data, nb_channels))
             return AVERROR(ENOMEM);
     } else {
         frame->extended_data = frame->data;
@@ -435,37 +435,8 @@
     }
 }
 
-enum AVPixelFormat avpriv_find_pix_fmt(const PixelFormatTag *tags,
-                                       unsigned int fourcc)
-{
-    while (tags->pix_fmt >= 0) {
-        if (tags->fourcc == fourcc)
-            return tags->pix_fmt;
-        tags++;
-    }
-    return AV_PIX_FMT_NONE;
-}
-
-#if FF_API_CODEC_GET_SET
-MAKE_ACCESSORS(AVCodecContext, codec, AVRational, pkt_timebase)
-MAKE_ACCESSORS(AVCodecContext, codec, const AVCodecDescriptor *, codec_descriptor)
-MAKE_ACCESSORS(AVCodecContext, codec, int, lowres)
-MAKE_ACCESSORS(AVCodecContext, codec, int, seek_preroll)
-MAKE_ACCESSORS(AVCodecContext, codec, uint16_t*, chroma_intra_matrix)
-
-unsigned av_codec_get_codec_properties(const AVCodecContext *codec)
-{
-    return codec->properties;
-}
-
-int av_codec_get_max_lowres(const AVCodec *codec)
-{
-    return codec->max_lowres;
-}
-#endif
-
 int avpriv_codec_get_cap_skip_frame_fill_param(const AVCodec *codec){
-    return !!(codec->caps_internal & FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM);
+    return !!(ffcodec(codec)->caps_internal & FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM);
 }
 
 const char *avcodec_get_name(enum AVCodecID id)
@@ -488,28 +459,6 @@
     return "unknown_codec";
 }
 
-#if FF_API_TAG_STRING
-size_t av_get_codec_tag_string(char *buf, size_t buf_size, unsigned int codec_tag)
-{
-    int i, len, ret = 0;
-
-#define TAG_PRINT(x)                                              \
-    (((x) >= '0' && (x) <= '9') ||                                \
-     ((x) >= 'a' && (x) <= 'z') || ((x) >= 'A' && (x) <= 'Z') ||  \
-     ((x) == '.' || (x) == ' ' || (x) == '-' || (x) == '_'))
-
-    for (i = 0; i < 4; i++) {
-        len = snprintf(buf, buf_size,
-                       TAG_PRINT(codec_tag & 0xFF) ? "%c" : "[%d]", codec_tag & 0xFF);
-        buf        += len;
-        buf_size    = buf_size > len ? buf_size - len : 0;
-        ret        += len;
-        codec_tag >>= 8;
-    }
-    return ret;
-}
-#endif
-
 const char *av_get_profile_name(const AVCodec *codec, int profile)
 {
     const AVProfile *p;
@@ -541,6 +490,8 @@
 int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
 {
     switch (codec_id) {
+    case AV_CODEC_ID_DFPWM:
+        return 1;
     case AV_CODEC_ID_8SVX_EXP:
     case AV_CODEC_ID_8SVX_FIB:
     case AV_CODEC_ID_ADPCM_ARGO:
@@ -569,7 +520,9 @@
     case AV_CODEC_ID_PCM_SGA:
     case AV_CODEC_ID_PCM_U8:
     case AV_CODEC_ID_SDX2_DPCM:
+    case AV_CODEC_ID_CBD2_DPCM:
     case AV_CODEC_ID_DERF_DPCM:
+    case AV_CODEC_ID_WADY_DPCM:
         return 8;
     case AV_CODEC_ID_PCM_S16BE:
     case AV_CODEC_ID_PCM_S16BE_PLANAR:
@@ -630,6 +583,8 @@
 int av_get_bits_per_sample(enum AVCodecID codec_id)
 {
     switch (codec_id) {
+    case AV_CODEC_ID_DFPWM:
+        return 1;
     case AV_CODEC_ID_ADPCM_SBPRO_2:
         return 2;
     case AV_CODEC_ID_ADPCM_SBPRO_3:
@@ -680,6 +635,7 @@
     case AV_CODEC_ID_MP2:
     case AV_CODEC_ID_MUSEPACK7:    return 1152;
     case AV_CODEC_ID_AC3:          return 1536;
+    case AV_CODEC_ID_FTR:          return 1024;
     }
 
     if (sr > 0) {
@@ -723,6 +679,10 @@
             return 256 * (frame_bytes / 64);
         if (id == AV_CODEC_ID_RA_144)
             return 160 * (frame_bytes / 20);
+        if (id == AV_CODEC_ID_APTX)
+            return 4 * (frame_bytes / 4);
+        if (id == AV_CODEC_ID_APTX_HD)
+            return 4 * (frame_bytes / 6);
 
         if (bps > 0) {
             /* calc from frame_bytes and bits_per_coded_sample */
@@ -746,6 +706,7 @@
                     return 0;
                 return frame_bytes * 28;
             case AV_CODEC_ID_ADPCM_4XM:
+            case AV_CODEC_ID_ADPCM_IMA_ACORN:
             case AV_CODEC_ID_ADPCM_IMA_DAT4:
             case AV_CODEC_ID_ADPCM_IMA_ISS:
                 return (frame_bytes - 4 * ch) * 2 / ch;
@@ -812,6 +773,9 @@
                 case AV_CODEC_ID_ADPCM_MTAF:
                     tmp = blocks * (ba - 16LL) * 2 / ch;
                     break;
+                case AV_CODEC_ID_ADPCM_XMD:
+                    tmp = blocks * 32;
+                    break;
                 }
                 if (tmp) {
                     if (tmp != (int)tmp)
@@ -854,8 +818,16 @@
 
 int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
 {
-    int duration = get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,
-                                    avctx->channels, avctx->block_align,
+   int channels = avctx->ch_layout.nb_channels;
+   int duration;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (!channels)
+        channels = avctx->channels;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    duration = get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,
+                                    channels, avctx->block_align,
                                     avctx->codec_tag, avctx->bits_per_coded_sample,
                                     avctx->bit_rate, avctx->extradata, avctx->frame_size,
                                     frame_bytes);
@@ -864,8 +836,16 @@
 
 int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
 {
-    int duration = get_audio_frame_duration(par->codec_id, par->sample_rate,
-                                    par->channels, par->block_align,
+   int channels = par->ch_layout.nb_channels;
+   int duration;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (!channels)
+        channels = par->channels;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    duration = get_audio_frame_duration(par->codec_id, par->sample_rate,
+                                    channels, par->block_align,
                                     par->codec_tag, par->bits_per_coded_sample,
                                     par->bit_rate, par->extradata, par->frame_size,
                                     frame_bytes);
@@ -901,8 +881,9 @@
     return i;
 }
 
-const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
+const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *avcodec, int index)
 {
+    const FFCodec *const codec = ffcodec(avcodec);
     int i;
     if (!codec->hw_configs || index < 0)
         return NULL;
@@ -912,25 +893,6 @@
     return &codec->hw_configs[index]->public;
 }
 
-#if FF_API_USER_VISIBLE_AVHWACCEL
-AVHWAccel *av_hwaccel_next(const AVHWAccel *hwaccel)
-{
-    return NULL;
-}
-
-void av_register_hwaccel(AVHWAccel *hwaccel)
-{
-}
-#endif
-
-unsigned int avpriv_toupper4(unsigned int x)
-{
-    return av_toupper(x & 0xFF) +
-          (av_toupper((x >>  8) & 0xFF) << 8)  +
-          (av_toupper((x >> 16) & 0xFF) << 16) +
-((unsigned)av_toupper((x >> 24) & 0xFF) << 24);
-}
-
 int ff_thread_ref_frame(ThreadFrame *dst, const ThreadFrame *src)
 {
     int ret;
@@ -946,7 +908,7 @@
 
     if (src->progress &&
         !(dst->progress = av_buffer_ref(src->progress))) {
-        ff_thread_release_buffer(dst->owner[0], dst);
+        ff_thread_release_ext_buffer(dst->owner[0], dst);
         return AVERROR(ENOMEM);
     }
 
@@ -955,19 +917,26 @@
 
 #if !HAVE_THREADS
 
-enum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)
+int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f, int flags)
 {
-    return ff_get_format(avctx, fmt);
+    return ff_get_buffer(avctx, f, flags);
 }
 
-int ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)
+int ff_thread_get_ext_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)
 {
     f->owner[0] = f->owner[1] = avctx;
     return ff_get_buffer(avctx, f->f, flags);
 }
 
-void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)
+void ff_thread_release_buffer(AVCodecContext *avctx, AVFrame *f)
 {
+    if (f)
+        av_frame_unref(f);
+}
+
+void ff_thread_release_ext_buffer(AVCodecContext *avctx, ThreadFrame *f)
+{
+    f->owner[0] = f->owner[1] = NULL;
     if (f->f)
         av_frame_unref(f->f);
 }
@@ -980,7 +949,7 @@
 {
 }
 
-void ff_thread_await_progress(ThreadFrame *f, int progress, int field)
+void ff_thread_await_progress(const ThreadFrame *f, int progress, int field)
 {
 }
 
@@ -989,13 +958,14 @@
     return 1;
 }
 
-int ff_alloc_entries(AVCodecContext *avctx, int count)
+int ff_slice_thread_init_progress(AVCodecContext *avctx)
 {
     return 0;
 }
 
-void ff_reset_entries(AVCodecContext *avctx)
+int ff_slice_thread_allocz_entries(AVCodecContext *avctx, int count)
 {
+    return 0;
 }
 
 void ff_thread_await_progress2(AVCodecContext *avctx, int field, int thread, int shift)
diff -Naur a/media/ffvpx/libavcodec/vaapi_av1.c b/media/ffvpx/libavcodec/vaapi_av1.c
--- a/media/ffvpx/libavcodec/vaapi_av1.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vaapi_av1.c	2023-04-06 12:50:24.492176543 +0200
@@ -18,15 +18,37 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "libavutil/frame.h"
 #include "libavutil/pixdesc.h"
 #include "hwconfig.h"
 #include "vaapi_decode.h"
+#include "internal.h"
 #include "av1dec.h"
+#include "thread.h"
+
+typedef struct VAAPIAV1FrameRef {
+    AVFrame *frame;
+    int valid;
+} VAAPIAV1FrameRef;
+
+typedef struct VAAPIAV1DecContext {
+    VAAPIDecodeContext base;
+
+    /**
+     * For film grain case, VAAPI generate 2 output for each frame,
+     * current_frame will not apply film grain, and will be used for
+     * references for next frames. Maintain the reference list without
+     * applying film grain here. And current_display_picture will be
+     * used to apply film grain and push to downstream.
+    */
+    VAAPIAV1FrameRef ref_tab[AV1_NUM_REF_FRAMES];
+    AVFrame *tmp_frame;
+} VAAPIAV1DecContext;
 
 static VASurfaceID vaapi_av1_surface_id(AV1Frame *vf)
 {
     if (vf)
-        return ff_vaapi_get_surface_id(vf->tf.f);
+        return ff_vaapi_get_surface_id(vf->f);
     else
         return VA_INVALID_SURFACE;
 }
@@ -49,6 +71,48 @@
     return bit_depth == 8 ? 0 : bit_depth == 10 ? 1 : 2;
 }
 
+static int vaapi_av1_decode_init(AVCodecContext *avctx)
+{
+    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
+
+    ctx->tmp_frame = av_frame_alloc();
+    if (!ctx->tmp_frame) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Failed to allocate frame.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++) {
+        ctx->ref_tab[i].frame = av_frame_alloc();
+        if (!ctx->ref_tab[i].frame) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Failed to allocate reference table frame %d.\n", i);
+            return AVERROR(ENOMEM);
+        }
+        ctx->ref_tab[i].valid = 0;
+    }
+
+    return ff_vaapi_decode_init(avctx);
+}
+
+static int vaapi_av1_decode_uninit(AVCodecContext *avctx)
+{
+    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
+
+    if (ctx->tmp_frame->buf[0])
+        ff_thread_release_buffer(avctx, ctx->tmp_frame);
+    av_frame_free(&ctx->tmp_frame);
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(ctx->ref_tab); i++) {
+        if (ctx->ref_tab[i].frame->buf[0])
+            ff_thread_release_buffer(avctx, ctx->ref_tab[i].frame);
+        av_frame_free(&ctx->ref_tab[i].frame);
+    }
+
+    return ff_vaapi_decode_uninit(avctx);
+}
+
+
 static int vaapi_av1_start_frame(AVCodecContext *avctx,
                                  av_unused const uint8_t *buffer,
                                  av_unused uint32_t size)
@@ -58,40 +122,62 @@
     const AV1RawFrameHeader *frame_header = s->raw_frame_header;
     const AV1RawFilmGrainParams *film_grain = &s->cur_frame.film_grain;
     VAAPIDecodePicture *pic = s->cur_frame.hwaccel_picture_private;
+    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
     VADecPictureParameterBufferAV1 pic_param;
     int8_t bit_depth_idx;
     int err = 0;
     int apply_grain = !(avctx->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN) && film_grain->apply_grain;
     uint8_t remap_lr_type[4] = {AV1_RESTORE_NONE, AV1_RESTORE_SWITCHABLE, AV1_RESTORE_WIENER, AV1_RESTORE_SGRPROJ};
-
-    pic->output_surface = vaapi_av1_surface_id(&s->cur_frame);
+    uint8_t segmentation_feature_signed[AV1_SEG_LVL_MAX] = {1, 1, 1, 1, 1, 0, 0, 0};
+    uint8_t segmentation_feature_max[AV1_SEG_LVL_MAX] = {255, AV1_MAX_LOOP_FILTER,
+        AV1_MAX_LOOP_FILTER, AV1_MAX_LOOP_FILTER, AV1_MAX_LOOP_FILTER, 7 , 0 , 0 };
 
     bit_depth_idx = vaapi_av1_get_bit_depth_idx(avctx);
     if (bit_depth_idx < 0)
         goto fail;
 
+    if (apply_grain) {
+        if (ctx->tmp_frame->buf[0])
+            ff_thread_release_buffer(avctx, ctx->tmp_frame);
+        err = ff_thread_get_buffer(avctx, ctx->tmp_frame, AV_GET_BUFFER_FLAG_REF);
+        if (err < 0)
+            goto fail;
+        pic->output_surface = ff_vaapi_get_surface_id(ctx->tmp_frame);
+    } else {
+        pic->output_surface = vaapi_av1_surface_id(&s->cur_frame);
+    }
+
     memset(&pic_param, 0, sizeof(VADecPictureParameterBufferAV1));
     pic_param = (VADecPictureParameterBufferAV1) {
-        .profile                 = seq->seq_profile,
-        .order_hint_bits_minus_1 = seq->order_hint_bits_minus_1,
-        .bit_depth_idx           = bit_depth_idx,
-        .current_frame           = pic->output_surface,
-        .current_display_picture = pic->output_surface,
-        .frame_width_minus1      = frame_header->frame_width_minus_1,
-        .frame_height_minus1     = frame_header->frame_height_minus_1,
-        .primary_ref_frame       = frame_header->primary_ref_frame,
-        .order_hint              = frame_header->order_hint,
-        .tile_cols               = frame_header->tile_cols,
-        .tile_rows               = frame_header->tile_rows,
-        .context_update_tile_id  = frame_header->context_update_tile_id,
-        .interp_filter           = frame_header->interpolation_filter,
-        .filter_level[0]         = frame_header->loop_filter_level[0],
-        .filter_level[1]         = frame_header->loop_filter_level[1],
-        .filter_level_u          = frame_header->loop_filter_level[2],
-        .filter_level_v          = frame_header->loop_filter_level[3],
-        .base_qindex             = frame_header->base_q_idx,
-        .cdef_damping_minus_3    = frame_header->cdef_damping_minus_3,
-        .cdef_bits               = frame_header->cdef_bits,
+        .profile                    = seq->seq_profile,
+        .order_hint_bits_minus_1    = seq->order_hint_bits_minus_1,
+        .bit_depth_idx              = bit_depth_idx,
+        .matrix_coefficients        = seq->color_config.matrix_coefficients,
+        .current_frame              = pic->output_surface,
+        .current_display_picture    = vaapi_av1_surface_id(&s->cur_frame),
+        .frame_width_minus1         = frame_header->frame_width_minus_1,
+        .frame_height_minus1        = frame_header->frame_height_minus_1,
+        .primary_ref_frame          = frame_header->primary_ref_frame,
+        .order_hint                 = frame_header->order_hint,
+        .tile_cols                  = frame_header->tile_cols,
+        .tile_rows                  = frame_header->tile_rows,
+        .context_update_tile_id     = frame_header->context_update_tile_id,
+        .superres_scale_denominator = frame_header->use_superres ?
+                                        frame_header->coded_denom + AV1_SUPERRES_DENOM_MIN :
+                                        AV1_SUPERRES_NUM,
+        .interp_filter              = frame_header->interpolation_filter,
+        .filter_level[0]            = frame_header->loop_filter_level[0],
+        .filter_level[1]            = frame_header->loop_filter_level[1],
+        .filter_level_u             = frame_header->loop_filter_level[2],
+        .filter_level_v             = frame_header->loop_filter_level[3],
+        .base_qindex                = frame_header->base_q_idx,
+        .y_dc_delta_q               = frame_header->delta_q_y_dc,
+        .u_dc_delta_q               = frame_header->delta_q_u_dc,
+        .u_ac_delta_q               = frame_header->delta_q_u_ac,
+        .v_dc_delta_q               = frame_header->delta_q_v_dc,
+        .v_ac_delta_q               = frame_header->delta_q_v_ac,
+        .cdef_damping_minus_3       = frame_header->cdef_damping_minus_3,
+        .cdef_bits                  = frame_header->cdef_bits,
         .seq_info_fields.fields = {
             .still_picture              = seq->still_picture,
             .use_128x128_superblock     = seq->use_128x128_superblock,
@@ -162,12 +248,15 @@
             .mode_ref_delta_update  = frame_header->loop_filter_delta_update,
         },
         .mode_control_fields.bits = {
-            .delta_q_present_flag = frame_header->delta_q_present,
-            .log2_delta_q_res     = frame_header->delta_q_res,
-            .tx_mode              = frame_header->tx_mode,
-            .reference_select     = frame_header->reference_select,
-            .reduced_tx_set_used  = frame_header->reduced_tx_set,
-            .skip_mode_present    = frame_header->skip_mode_present,
+            .delta_q_present_flag  = frame_header->delta_q_present,
+            .log2_delta_q_res      = frame_header->delta_q_res,
+            .delta_lf_present_flag = frame_header->delta_lf_present,
+            .log2_delta_lf_res     = frame_header->delta_lf_res,
+            .delta_lf_multi        = frame_header->delta_lf_multi,
+            .tx_mode               = frame_header->tx_mode,
+            .reference_select      = frame_header->reference_select,
+            .reduced_tx_set_used   = frame_header->reduced_tx_set,
+            .skip_mode_present     = frame_header->skip_mode_present,
         },
         .loop_restoration_fields.bits = {
             .yframe_restoration_type  = remap_lr_type[frame_header->lr_type[0]],
@@ -178,14 +267,19 @@
         },
         .qmatrix_fields.bits = {
             .using_qmatrix = frame_header->using_qmatrix,
+            .qm_y          = frame_header->qm_y,
+            .qm_u          = frame_header->qm_u,
+            .qm_v          = frame_header->qm_v,
         }
     };
 
     for (int i = 0; i < AV1_NUM_REF_FRAMES; i++) {
-        if (pic_param.pic_info_fields.bits.frame_type == AV1_FRAME_KEY)
+        if (pic_param.pic_info_fields.bits.frame_type == AV1_FRAME_KEY && frame_header->show_frame)
             pic_param.ref_frame_map[i] = VA_INVALID_ID;
         else
-            pic_param.ref_frame_map[i] = vaapi_av1_surface_id(&s->ref[i]);
+            pic_param.ref_frame_map[i] = ctx->ref_tab[i].valid ?
+                                         ff_vaapi_get_surface_id(ctx->ref_tab[i].frame) :
+                                         vaapi_av1_surface_id(&s->ref[i]);
     }
     for (int i = 0; i < AV1_REFS_PER_FRAME; i++) {
         pic_param.ref_frame_idx[i] = frame_header->ref_frame_idx[i];
@@ -213,10 +307,22 @@
             frame_header->height_in_sbs_minus_1[i];
     }
     for (int i = AV1_REF_FRAME_LAST; i <= AV1_REF_FRAME_ALTREF; i++) {
-        pic_param.wm[i - 1].wmtype = s->cur_frame.gm_type[i];
+        pic_param.wm[i - 1].invalid = s->cur_frame.gm_invalid[i];
+        pic_param.wm[i - 1].wmtype  = s->cur_frame.gm_type[i];
         for (int j = 0; j < 6; j++)
             pic_param.wm[i - 1].wmmat[j] = s->cur_frame.gm_params[i][j];
     }
+    for (int i = 0; i < AV1_MAX_SEGMENTS; i++) {
+        for (int j = 0; j < AV1_SEG_LVL_MAX; j++) {
+            pic_param.seg_info.feature_mask[i] |= (frame_header->feature_enabled[i][j] << j);
+            if (segmentation_feature_signed[j])
+                pic_param.seg_info.feature_data[i][j] = av_clip(frame_header->feature_value[i][j],
+                    -segmentation_feature_max[j], segmentation_feature_max[j]);
+            else
+                pic_param.seg_info.feature_data[i][j] = av_clip(frame_header->feature_value[i][j],
+                    0, segmentation_feature_max[j]);
+        }
+    }
     if (apply_grain) {
         for (int i = 0; i < film_grain->num_y_points; i++) {
             pic_param.film_grain_info.point_y_value[i] =
@@ -263,8 +369,34 @@
 static int vaapi_av1_end_frame(AVCodecContext *avctx)
 {
     const AV1DecContext *s = avctx->priv_data;
+    const AV1RawFrameHeader *header = s->raw_frame_header;
+    const AV1RawFilmGrainParams *film_grain = &s->cur_frame.film_grain;
     VAAPIDecodePicture *pic = s->cur_frame.hwaccel_picture_private;
-    return ff_vaapi_decode_issue(avctx, pic);
+    VAAPIAV1DecContext *ctx = avctx->internal->hwaccel_priv_data;
+
+    int apply_grain = !(avctx->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN) && film_grain->apply_grain;
+    int ret;
+    ret = ff_vaapi_decode_issue(avctx, pic);
+    if (ret < 0)
+        return ret;
+
+    for (int i = 0; i < AV1_NUM_REF_FRAMES; i++) {
+        if (header->refresh_frame_flags & (1 << i)) {
+            if (ctx->ref_tab[i].frame->buf[0])
+                ff_thread_release_buffer(avctx, ctx->ref_tab[i].frame);
+
+            if (apply_grain) {
+                ret = av_frame_ref(ctx->ref_tab[i].frame, ctx->tmp_frame);
+                if (ret < 0)
+                    return ret;
+                ctx->ref_tab[i].valid = 1;
+            } else {
+                ctx->ref_tab[i].valid = 0;
+            }
+        }
+    }
+
+    return 0;
 }
 
 static int vaapi_av1_decode_slice(AVCodecContext *avctx,
@@ -311,9 +443,9 @@
     .end_frame            = vaapi_av1_end_frame,
     .decode_slice         = vaapi_av1_decode_slice,
     .frame_priv_data_size = sizeof(VAAPIDecodePicture),
-    .init                 = ff_vaapi_decode_init,
-    .uninit               = ff_vaapi_decode_uninit,
+    .init                 = vaapi_av1_decode_init,
+    .uninit               = vaapi_av1_decode_uninit,
     .frame_params         = ff_vaapi_common_frame_params,
-    .priv_data_size       = sizeof(VAAPIDecodeContext),
+    .priv_data_size       = sizeof(VAAPIAV1DecContext),
     .caps_internal        = HWACCEL_CAP_ASYNC_SAFE,
 };
diff -Naur a/media/ffvpx/libavcodec/vaapi_decode.c b/media/ffvpx/libavcodec/vaapi_decode.c
--- a/media/ffvpx/libavcodec/vaapi_decode.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vaapi_decode.c	2023-04-06 12:50:24.492176543 +0200
@@ -16,6 +16,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config_components.h"
+
 #include "libavutil/avassert.h"
 #include "libavutil/common.h"
 #include "libavutil/pixdesc.h"
@@ -261,14 +263,29 @@
 #ifdef VA_FOURCC_Y210
     MAP(Y210,    Y210),
 #endif
+#ifdef VA_FOURCC_Y212
+    MAP(Y212,    Y212),
+#endif
     // 4:4:0
     MAP(422V, YUV440P),
     // 4:4:4
     MAP(444P, YUV444P),
+#ifdef VA_FOURCC_XYUV
+    MAP(XYUV, VUYX),
+#endif
+#ifdef VA_FOURCC_Y410
+    MAP(Y410,    XV30),
+#endif
+#ifdef VA_FOURCC_Y412
+    MAP(Y412,    XV36),
+#endif
     // 4:2:0 10-bit
 #ifdef VA_FOURCC_P010
     MAP(P010, P010),
 #endif
+#ifdef VA_FOURCC_P012
+    MAP(P012, P012),
+#endif
 #ifdef VA_FOURCC_I010
     MAP(I010, YUV420P10),
 #endif
@@ -355,6 +372,8 @@
 
         ctx->pixel_format_attribute = (VASurfaceAttrib) {
             .type          = VASurfaceAttribPixelFormat,
+            .flags         = VA_SURFACE_ATTRIB_SETTABLE,
+            .value.type    = VAGenericValueTypeInteger,
             .value.value.i = best_fourcc,
         };
 
@@ -391,7 +410,9 @@
 #endif
 #if VA_CHECK_VERSION(1, 2, 0) && CONFIG_HEVC_VAAPI_HWACCEL
     MAP(HEVC,        HEVC_REXT,       None,
-                 ff_vaapi_parse_hevc_rext_profile ),
+                 ff_vaapi_parse_hevc_rext_scc_profile ),
+    MAP(HEVC,        HEVC_SCC,        None,
+                 ff_vaapi_parse_hevc_rext_scc_profile ),
 #endif
     MAP(MJPEG,       MJPEG_HUFFMAN_BASELINE_DCT,
                                       JPEGBaseline),
@@ -408,7 +429,9 @@
     MAP(VP9,         VP9_0,           VP9Profile0 ),
 #endif
 #if VA_CHECK_VERSION(0, 39, 0)
+    MAP(VP9,         VP9_1,           VP9Profile1 ),
     MAP(VP9,         VP9_2,           VP9Profile2 ),
+    MAP(VP9,         VP9_3,           VP9Profile3 ),
 #endif
 #if VA_CHECK_VERSION(1, 8, 0)
     MAP(AV1,         AV1_MAIN,        AV1Profile0),
@@ -577,10 +600,10 @@
         switch (avctx->codec_id) {
         case AV_CODEC_ID_H264:
         case AV_CODEC_ID_HEVC:
+        case AV_CODEC_ID_AV1:
             frames->initial_pool_size += 16;
             break;
         case AV_CODEC_ID_VP9:
-        case AV_CODEC_ID_AV1:
             frames->initial_pool_size += 8;
             break;
         case AV_CODEC_ID_VP8:
@@ -640,46 +663,6 @@
     ctx->va_config  = VA_INVALID_ID;
     ctx->va_context = VA_INVALID_ID;
 
-#if FF_API_STRUCT_VAAPI_CONTEXT
-    if (avctx->hwaccel_context) {
-        av_log(avctx, AV_LOG_WARNING, "Using deprecated struct "
-               "vaapi_context in decode.\n");
-
-        ctx->have_old_context = 1;
-        ctx->old_context = avctx->hwaccel_context;
-
-        // Really we only want the VAAPI device context, but this
-        // allocates a whole generic device context because we don't
-        // have any other way to determine how big it should be.
-        ctx->device_ref =
-            av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_VAAPI);
-        if (!ctx->device_ref) {
-            err = AVERROR(ENOMEM);
-            goto fail;
-        }
-        ctx->device = (AVHWDeviceContext*)ctx->device_ref->data;
-        ctx->hwctx  = ctx->device->hwctx;
-
-        ctx->hwctx->display = ctx->old_context->display;
-
-        // The old VAAPI decode setup assumed this quirk was always
-        // present, so set it here to avoid the behaviour changing.
-        ctx->hwctx->driver_quirks =
-            AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS;
-
-    }
-#endif
-
-#if FF_API_STRUCT_VAAPI_CONTEXT
-    if (ctx->have_old_context) {
-        ctx->va_config  = ctx->old_context->config_id;
-        ctx->va_context = ctx->old_context->context_id;
-
-        av_log(avctx, AV_LOG_DEBUG, "Using user-supplied decoder "
-               "context: %#x/%#x.\n", ctx->va_config, ctx->va_context);
-    } else {
-#endif
-
     err = ff_decode_get_hw_frames_ctx(avctx, AV_HWDEVICE_TYPE_VAAPI);
     if (err < 0)
         goto fail;
@@ -690,7 +673,7 @@
     ctx->hwctx  = ctx->device->hwctx;
 
     err = vaapi_decode_make_config(avctx, ctx->frames->device_ref,
-                                   &ctx->va_config, avctx->hw_frames_ctx);
+                                   &ctx->va_config, NULL);
     if (err)
         goto fail;
 
@@ -709,9 +692,6 @@
 
     av_log(avctx, AV_LOG_DEBUG, "Decode context initialised: "
            "%#x/%#x.\n", ctx->va_config, ctx->va_context);
-#if FF_API_STRUCT_VAAPI_CONTEXT
-    }
-#endif
 
     return 0;
 
@@ -725,12 +705,6 @@
     VAAPIDecodeContext *ctx = avctx->internal->hwaccel_priv_data;
     VAStatus vas;
 
-#if FF_API_STRUCT_VAAPI_CONTEXT
-    if (ctx->have_old_context) {
-        av_buffer_unref(&ctx->device_ref);
-    } else {
-#endif
-
     if (ctx->va_context != VA_INVALID_ID) {
         vas = vaDestroyContext(ctx->hwctx->display, ctx->va_context);
         if (vas != VA_STATUS_SUCCESS) {
@@ -748,9 +722,5 @@
         }
     }
 
-#if FF_API_STRUCT_VAAPI_CONTEXT
-    }
-#endif
-
     return 0;
 }
diff -Naur a/media/ffvpx/libavcodec/vaapi_decode.h b/media/ffvpx/libavcodec/vaapi_decode.h
--- a/media/ffvpx/libavcodec/vaapi_decode.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vaapi_decode.h	2023-04-06 12:49:40.256395011 +0200
@@ -27,11 +27,6 @@
 
 #include "avcodec.h"
 
-#include "version.h"
-#if FF_API_STRUCT_VAAPI_CONTEXT
-#include "vaapi.h"
-#endif
-
 static inline VASurfaceID ff_vaapi_get_surface_id(AVFrame *pic)
 {
     return (uintptr_t)pic->data[3];
@@ -56,14 +51,6 @@
     VAConfigID            va_config;
     VAContextID           va_context;
 
-#if FF_API_STRUCT_VAAPI_CONTEXT
-FF_DISABLE_DEPRECATION_WARNINGS
-    int                   have_old_context;
-    struct vaapi_context *old_context;
-    AVBufferRef          *device_ref;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     AVHWDeviceContext    *device;
     AVVAAPIDeviceContext *hwctx;
 
diff -Naur a/media/ffvpx/libavcodec/vaapi_hevc.h b/media/ffvpx/libavcodec/vaapi_hevc.h
--- a/media/ffvpx/libavcodec/vaapi_hevc.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vaapi_hevc.h	2023-04-06 12:50:24.492176543 +0200
@@ -22,6 +22,6 @@
 #include <va/va.h>
 #include "avcodec.h"
 
-VAProfile ff_vaapi_parse_hevc_rext_profile(AVCodecContext *avctx);
+VAProfile ff_vaapi_parse_hevc_rext_scc_profile(AVCodecContext *avctx);
 
 #endif /* AVCODEC_VAAPI_HEVC_H */
diff -Naur a/media/ffvpx/libavcodec/vaapi_vp8.c b/media/ffvpx/libavcodec/vaapi_vp8.c
--- a/media/ffvpx/libavcodec/vaapi_vp8.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vaapi_vp8.c	2023-04-06 12:50:06.973471134 +0200
@@ -36,21 +36,21 @@
                                  av_unused uint32_t       size)
 {
     const VP8Context *s = avctx->priv_data;
-    VAAPIDecodePicture *pic = s->framep[VP56_FRAME_CURRENT]->hwaccel_picture_private;
+    VAAPIDecodePicture *pic = s->framep[VP8_FRAME_CURRENT]->hwaccel_picture_private;
     VAPictureParameterBufferVP8 pp;
     VAProbabilityDataBufferVP8 prob;
     VAIQMatrixBufferVP8 quant;
     int err, i, j, k;
 
-    pic->output_surface = vaapi_vp8_surface_id(s->framep[VP56_FRAME_CURRENT]);
+    pic->output_surface = vaapi_vp8_surface_id(s->framep[VP8_FRAME_CURRENT]);
 
     pp = (VAPictureParameterBufferVP8) {
         .frame_width                     = avctx->width,
         .frame_height                    = avctx->height,
 
-        .last_ref_frame                  = vaapi_vp8_surface_id(s->framep[VP56_FRAME_PREVIOUS]),
-        .golden_ref_frame                = vaapi_vp8_surface_id(s->framep[VP56_FRAME_GOLDEN]),
-        .alt_ref_frame                   = vaapi_vp8_surface_id(s->framep[VP56_FRAME_GOLDEN2]),
+        .last_ref_frame                  = vaapi_vp8_surface_id(s->framep[VP8_FRAME_PREVIOUS]),
+        .golden_ref_frame                = vaapi_vp8_surface_id(s->framep[VP8_FRAME_GOLDEN]),
+        .alt_ref_frame                   = vaapi_vp8_surface_id(s->framep[VP8_FRAME_ALTREF]),
         .out_of_loop_frame               = VA_INVALID_SURFACE,
 
         .pic_fields.bits = {
@@ -67,8 +67,8 @@
             .loop_filter_adj_enable      = s->lf_delta.enabled,
             .mode_ref_lf_delta_update    = s->lf_delta.update,
 
-            .sign_bias_golden            = s->sign_bias[VP56_FRAME_GOLDEN],
-            .sign_bias_alternate         = s->sign_bias[VP56_FRAME_GOLDEN2],
+            .sign_bias_golden            = s->sign_bias[VP8_FRAME_GOLDEN],
+            .sign_bias_alternate         = s->sign_bias[VP8_FRAME_ALTREF],
 
             .mb_no_coeff_skip            = s->mbskip_enabled,
             .loop_filter_disable         = s->filter.level == 0,
@@ -177,7 +177,7 @@
 static int vaapi_vp8_end_frame(AVCodecContext *avctx)
 {
     const VP8Context *s = avctx->priv_data;
-    VAAPIDecodePicture *pic = s->framep[VP56_FRAME_CURRENT]->hwaccel_picture_private;
+    VAAPIDecodePicture *pic = s->framep[VP8_FRAME_CURRENT]->hwaccel_picture_private;
 
     return ff_vaapi_decode_issue(avctx, pic);
 }
@@ -187,7 +187,7 @@
                                   uint32_t        size)
 {
     const VP8Context *s = avctx->priv_data;
-    VAAPIDecodePicture *pic = s->framep[VP56_FRAME_CURRENT]->hwaccel_picture_private;
+    VAAPIDecodePicture *pic = s->framep[VP8_FRAME_CURRENT]->hwaccel_picture_private;
     VASliceParameterBufferVP8 sp;
     int err, i;
 
diff -Naur a/media/ffvpx/libavcodec/version.c b/media/ffvpx/libavcodec/version.c
--- a/media/ffvpx/libavcodec/version.c	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/version.c	2023-04-06 12:49:40.256395011 +0200
@@ -0,0 +1,50 @@
+/*
+ * Version functions.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#include "libavutil/avassert.h"
+#include "avcodec.h"
+#include "codec_id.h"
+#include "version.h"
+
+#include "libavutil/ffversion.h"
+const char av_codec_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
+
+unsigned avcodec_version(void)
+{
+    av_assert0(AV_CODEC_ID_PCM_S8_PLANAR==65563);
+    av_assert0(AV_CODEC_ID_ADPCM_G722==69660);
+    av_assert0(AV_CODEC_ID_SRT==94216);
+    av_assert0(LIBAVCODEC_VERSION_MICRO >= 100);
+
+    return LIBAVCODEC_VERSION_INT;
+}
+
+const char *avcodec_configuration(void)
+{
+    return FFMPEG_CONFIGURATION;
+}
+
+const char *avcodec_license(void)
+{
+#define LICENSE_PREFIX "libavcodec license: "
+    return &LICENSE_PREFIX FFMPEG_LICENSE[sizeof(LICENSE_PREFIX) - 1];
+}
diff -Naur a/media/ffvpx/libavcodec/version.h b/media/ffvpx/libavcodec/version.h
--- a/media/ffvpx/libavcodec/version.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/version.h	2023-04-06 12:50:24.492176543 +0200
@@ -27,8 +27,9 @@
 
 #include "libavutil/version.h"
 
-#define LIBAVCODEC_VERSION_MAJOR  58
-#define LIBAVCODEC_VERSION_MINOR 134
+#include "version_major.h"
+
+#define LIBAVCODEC_VERSION_MINOR   5
 #define LIBAVCODEC_VERSION_MICRO 100
 
 #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
@@ -41,132 +42,4 @@
 
 #define LIBAVCODEC_IDENT        "Lavc" AV_STRINGIFY(LIBAVCODEC_VERSION)
 
-/**
- * FF_API_* defines may be placed below to indicate public API that will be
- * dropped at a future version bump. The defines themselves are not part of
- * the public API and may change, break or disappear at any time.
- *
- * @note, when bumping the major version it is recommended to manually
- * disable each FF_API_* in its own commit instead of disabling them all
- * at once through the bump. This improves the git bisect-ability of the change.
- */
-
-#ifndef FF_API_AVCTX_TIMEBASE
-#define FF_API_AVCTX_TIMEBASE    (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_CODED_FRAME
-#define FF_API_CODED_FRAME       (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_SIDEDATA_ONLY_PKT
-#define FF_API_SIDEDATA_ONLY_PKT (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_VDPAU_PROFILE
-#define FF_API_VDPAU_PROFILE     (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_CONVERGENCE_DURATION
-#define FF_API_CONVERGENCE_DURATION (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_AVPICTURE
-#define FF_API_AVPICTURE         (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_AVPACKET_OLD_API
-#define FF_API_AVPACKET_OLD_API (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_RTP_CALLBACK
-#define FF_API_RTP_CALLBACK      (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_VBV_DELAY
-#define FF_API_VBV_DELAY         (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_CODER_TYPE
-#define FF_API_CODER_TYPE        (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_STAT_BITS
-#define FF_API_STAT_BITS         (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_PRIVATE_OPT
-#define FF_API_PRIVATE_OPT      (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_ASS_TIMING
-#define FF_API_ASS_TIMING       (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_OLD_BSF
-#define FF_API_OLD_BSF          (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_COPY_CONTEXT
-#define FF_API_COPY_CONTEXT     (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_GET_CONTEXT_DEFAULTS
-#define FF_API_GET_CONTEXT_DEFAULTS (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_NVENC_OLD_NAME
-#define FF_API_NVENC_OLD_NAME    (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_STRUCT_VAAPI_CONTEXT
-#define FF_API_STRUCT_VAAPI_CONTEXT (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_MERGE_SD_API
-#define FF_API_MERGE_SD_API      (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_TAG_STRING
-#define FF_API_TAG_STRING        (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_GETCHROMA
-#define FF_API_GETCHROMA         (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_CODEC_GET_SET
-#define FF_API_CODEC_GET_SET     (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_USER_VISIBLE_AVHWACCEL
-#define FF_API_USER_VISIBLE_AVHWACCEL (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_LOCKMGR
-#define FF_API_LOCKMGR (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_NEXT
-#define FF_API_NEXT              (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_UNSANITIZED_BITRATES
-#define FF_API_UNSANITIZED_BITRATES (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_OPENH264_SLICE_MODE
-#define FF_API_OPENH264_SLICE_MODE (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_OPENH264_CABAC
-#define FF_API_OPENH264_CABAC      (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_UNUSED_CODEC_CAPS
-#define FF_API_UNUSED_CODEC_CAPS   (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_AVPRIV_PUT_BITS
-#define FF_API_AVPRIV_PUT_BITS     (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_OLD_ENCDEC
-#define FF_API_OLD_ENCDEC          (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_AVCODEC_PIX_FMT
-#define FF_API_AVCODEC_PIX_FMT     (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_MPV_RC_STRATEGY
-#define FF_API_MPV_RC_STRATEGY     (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_PARSER_CHANGE
-#define FF_API_PARSER_CHANGE       (LIBAVCODEC_VERSION_MAJOR < 59)
-#endif
-#ifndef FF_API_THREAD_SAFE_CALLBACKS
-#define FF_API_THREAD_SAFE_CALLBACKS (LIBAVCODEC_VERSION_MAJOR < 60)
-#endif
-#ifndef FF_API_DEBUG_MV
-#define FF_API_DEBUG_MV          (LIBAVCODEC_VERSION_MAJOR < 60)
-#endif
-#ifndef FF_API_GET_FRAME_CLASS
-#define FF_API_GET_FRAME_CLASS     (LIBAVCODEC_VERSION_MAJOR < 60)
-#endif
-#ifndef FF_API_AUTO_THREADS
-#define FF_API_AUTO_THREADS        (LIBAVCODEC_VERSION_MAJOR < 60)
-#endif
-#ifndef FF_API_INIT_PACKET
-#define FF_API_INIT_PACKET         (LIBAVCODEC_VERSION_MAJOR < 60)
-#endif
-
 #endif /* AVCODEC_VERSION_H */
diff -Naur a/media/ffvpx/libavcodec/version_major.h b/media/ffvpx/libavcodec/version_major.h
--- a/media/ffvpx/libavcodec/version_major.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/version_major.h	2023-04-06 12:50:24.492176543 +0200
@@ -0,0 +1,52 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VERSION_MAJOR_H
+#define AVCODEC_VERSION_MAJOR_H
+
+/**
+ * @file
+ * @ingroup libavc
+ * Libavcodec version macros.
+ */
+
+#define LIBAVCODEC_VERSION_MAJOR  60
+
+/**
+ * FF_API_* defines may be placed below to indicate public API that will be
+ * dropped at a future version bump. The defines themselves are not part of
+ * the public API and may change, break or disappear at any time.
+ *
+ * @note, when bumping the major version it is recommended to manually
+ * disable each FF_API_* in its own commit instead of disabling them all
+ * at once through the bump. This improves the git bisect-ability of the change.
+ */
+
+#define FF_API_INIT_PACKET         (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_IDCT_NONE           (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_SVTAV1_OPTS         (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AYUV_CODECID        (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_VT_OUTPUT_CALLBACK  (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AVCODEC_CHROMA_POS  (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_VT_HWACCEL_CONTEXT  (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AVCTX_FRAME_NUMBER  (LIBAVCODEC_VERSION_MAJOR < 61)
+
+// reminder to remove CrystalHD decoders on next major bump
+#define FF_CODEC_CRYSTAL_HD        (LIBAVCODEC_VERSION_MAJOR < 61)
+
+#endif /* AVCODEC_VERSION_MAJOR_H */
diff -Naur a/media/ffvpx/libavcodec/videodsp.c b/media/ffvpx/libavcodec/videodsp.c
--- a/media/ffvpx/libavcodec/videodsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/videodsp.c	2023-04-06 12:50:06.973471134 +0200
@@ -18,9 +18,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/avassert.h"
-#include "libavutil/common.h"
+#include "libavutil/macros.h"
 #include "videodsp.h"
 
 #define BIT_DEPTH 8
@@ -31,7 +32,7 @@
 #include "videodsp_template.c"
 #undef BIT_DEPTH
 
-static void just_return(uint8_t *buf, ptrdiff_t stride, int h)
+static void just_return(const uint8_t *buf, ptrdiff_t stride, int h)
 {
 }
 
@@ -44,14 +45,17 @@
         ctx->emulated_edge_mc = ff_emulated_edge_mc_16;
     }
 
-    if (ARCH_AARCH64)
-        ff_videodsp_init_aarch64(ctx, bpc);
-    if (ARCH_ARM)
-        ff_videodsp_init_arm(ctx, bpc);
-    if (ARCH_PPC)
-        ff_videodsp_init_ppc(ctx, bpc);
-    if (ARCH_X86)
-        ff_videodsp_init_x86(ctx, bpc);
-    if (ARCH_MIPS)
-        ff_videodsp_init_mips(ctx, bpc);
+#if ARCH_AARCH64
+    ff_videodsp_init_aarch64(ctx, bpc);
+#elif ARCH_ARM
+    ff_videodsp_init_arm(ctx, bpc);
+#elif ARCH_PPC
+    ff_videodsp_init_ppc(ctx, bpc);
+#elif ARCH_X86
+    ff_videodsp_init_x86(ctx, bpc);
+#elif ARCH_MIPS
+    ff_videodsp_init_mips(ctx, bpc);
+#elif ARCH_LOONGARCH64
+    ff_videodsp_init_loongarch(ctx, bpc);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/videodsp.h b/media/ffvpx/libavcodec/videodsp.h
--- a/media/ffvpx/libavcodec/videodsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/videodsp.h	2023-04-06 12:50:06.973471134 +0200
@@ -36,7 +36,6 @@
                                    int src_x, int src_y, int w, int h);
 
 EMULATED_EDGE(8)
-EMULATED_EDGE(16)
 
 typedef struct VideoDSPContext {
     /**
@@ -73,7 +72,7 @@
      * @param stride distance between two lines of buf (in bytes)
      * @param h      number of lines to prefetch
      */
-    void (*prefetch)(uint8_t *buf, ptrdiff_t stride, int h);
+    void (*prefetch)(const uint8_t *buf, ptrdiff_t stride, int h);
 } VideoDSPContext;
 
 void ff_videodsp_init(VideoDSPContext *ctx, int bpc);
@@ -84,5 +83,6 @@
 void ff_videodsp_init_ppc(VideoDSPContext *ctx, int bpc);
 void ff_videodsp_init_x86(VideoDSPContext *ctx, int bpc);
 void ff_videodsp_init_mips(VideoDSPContext *ctx, int bpc);
+void ff_videodsp_init_loongarch(VideoDSPContext *ctx, int bpc);
 
 #endif /* AVCODEC_VIDEODSP_H */
diff -Naur a/media/ffvpx/libavcodec/videodsp_template.c b/media/ffvpx/libavcodec/videodsp_template.c
--- a/media/ffvpx/libavcodec/videodsp_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/videodsp_template.c	2023-04-06 12:50:24.492176543 +0200
@@ -20,6 +20,10 @@
  */
 
 #include "bit_depth_template.c"
+#if BIT_DEPTH != 8
+// ff_emulated_edge_mc_8 is used by the x86 MpegVideoDSP API.
+static
+#endif
 void FUNC(ff_emulated_edge_mc)(uint8_t *buf, const uint8_t *src,
                                ptrdiff_t buf_linesize,
                                ptrdiff_t src_linesize,
@@ -60,7 +64,7 @@
     av_assert2(start_x < end_x && block_w);
 
     w    = end_x - start_x;
-    src += start_y * src_linesize + start_x * sizeof(pixel);
+    src += start_y * src_linesize + start_x * (ptrdiff_t)sizeof(pixel);
     buf += start_x * sizeof(pixel);
 
     // top
@@ -83,7 +87,7 @@
         buf += buf_linesize;
     }
 
-    buf -= block_h * buf_linesize + start_x * sizeof(pixel);
+    buf -= block_h * buf_linesize + start_x * (ptrdiff_t)sizeof(pixel);
     while (block_h--) {
         pixel *bufp = (pixel *) buf;
 
diff -Naur a/media/ffvpx/libavcodec/vlc.c b/media/ffvpx/libavcodec/vlc.c
--- a/media/ffvpx/libavcodec/vlc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/vlc.c	2023-04-06 12:49:40.256395011 +0200
@@ -0,0 +1,378 @@
+/*
+ * API for creating VLC trees
+ * Copyright (c) 2000, 2001 Fabrice Bellard
+ * Copyright (c) 2002-2004 Michael Niedermayer <michaelni@gmx.at>
+ * Copyright (c) 2010 Loren Merritt
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <inttypes.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "libavutil/attributes.h"
+#include "libavutil/avassert.h"
+#include "libavutil/error.h"
+#include "libavutil/internal.h"
+#include "libavutil/log.h"
+#include "libavutil/macros.h"
+#include "libavutil/mem.h"
+#include "libavutil/qsort.h"
+#include "libavutil/reverse.h"
+#include "vlc.h"
+
+#define GET_DATA(v, table, i, wrap, size)                   \
+{                                                           \
+    const uint8_t *ptr = (const uint8_t *)table + i * wrap; \
+    switch(size) {                                          \
+    case 1:                                                 \
+        v = *(const uint8_t *)ptr;                          \
+        break;                                              \
+    case 2:                                                 \
+        v = *(const uint16_t *)ptr;                         \
+        break;                                              \
+    case 4:                                                 \
+    default:                                                \
+        av_assert1(size == 4);                              \
+        v = *(const uint32_t *)ptr;                         \
+        break;                                              \
+    }                                                       \
+}
+
+
+static int alloc_table(VLC *vlc, int size, int use_static)
+{
+    int index = vlc->table_size;
+
+    vlc->table_size += size;
+    if (vlc->table_size > vlc->table_allocated) {
+        if (use_static)
+            abort(); // cannot do anything, init_vlc() is used with too little memory
+        vlc->table_allocated += (1 << vlc->bits);
+        vlc->table = av_realloc_f(vlc->table, vlc->table_allocated, sizeof(*vlc->table));
+        if (!vlc->table) {
+            vlc->table_allocated = 0;
+            vlc->table_size = 0;
+            return AVERROR(ENOMEM);
+        }
+        memset(vlc->table + vlc->table_allocated - (1 << vlc->bits), 0, sizeof(*vlc->table) << vlc->bits);
+    }
+    return index;
+}
+
+#define LOCALBUF_ELEMS 1500 // the maximum currently needed is 1296 by rv34
+
+static av_always_inline uint32_t bitswap_32(uint32_t x)
+{
+    return (uint32_t)ff_reverse[ x        & 0xFF] << 24 |
+           (uint32_t)ff_reverse[(x >> 8)  & 0xFF] << 16 |
+           (uint32_t)ff_reverse[(x >> 16) & 0xFF] << 8  |
+           (uint32_t)ff_reverse[ x >> 24];
+}
+
+typedef struct VLCcode {
+    uint8_t bits;
+    VLCBaseType symbol;
+    /** codeword, with the first bit-to-be-read in the msb
+     * (even if intended for a little-endian bitstream reader) */
+    uint32_t code;
+} VLCcode;
+
+static int vlc_common_init(VLC *vlc, int nb_bits, int nb_codes,
+                           VLCcode **buf, int flags)
+{
+    vlc->bits = nb_bits;
+    vlc->table_size = 0;
+    if (flags & INIT_VLC_USE_NEW_STATIC) {
+        av_assert0(nb_codes <= LOCALBUF_ELEMS);
+    } else {
+        vlc->table           = NULL;
+        vlc->table_allocated = 0;
+    }
+    if (nb_codes > LOCALBUF_ELEMS) {
+        *buf = av_malloc_array(nb_codes, sizeof(VLCcode));
+        if (!*buf)
+            return AVERROR(ENOMEM);
+    }
+
+    return 0;
+}
+
+static int compare_vlcspec(const void *a, const void *b)
+{
+    const VLCcode *sa = a, *sb = b;
+    return (sa->code >> 1) - (sb->code >> 1);
+}
+
+/**
+ * Build VLC decoding tables suitable for use with get_vlc().
+ *
+ * @param vlc            the context to be initialized
+ *
+ * @param table_nb_bits  max length of vlc codes to store directly in this table
+ *                       (Longer codes are delegated to subtables.)
+ *
+ * @param nb_codes       number of elements in codes[]
+ *
+ * @param codes          descriptions of the vlc codes
+ *                       These must be ordered such that codes going into the same subtable are contiguous.
+ *                       Sorting by VLCcode.code is sufficient, though not necessary.
+ */
+static int build_table(VLC *vlc, int table_nb_bits, int nb_codes,
+                       VLCcode *codes, int flags)
+{
+    int table_size, table_index;
+    VLCElem *table;
+
+    if (table_nb_bits > 30)
+       return AVERROR(EINVAL);
+    table_size = 1 << table_nb_bits;
+    table_index = alloc_table(vlc, table_size, flags & INIT_VLC_USE_NEW_STATIC);
+    ff_dlog(NULL, "new table index=%d size=%d\n", table_index, table_size);
+    if (table_index < 0)
+        return table_index;
+    table = &vlc->table[table_index];
+
+    /* first pass: map codes and compute auxiliary table sizes */
+    for (int i = 0; i < nb_codes; i++) {
+        int         n = codes[i].bits;
+        uint32_t code = codes[i].code;
+        int    symbol = codes[i].symbol;
+        ff_dlog(NULL, "i=%d n=%d code=0x%"PRIx32"\n", i, n, code);
+        if (n <= table_nb_bits) {
+            /* no need to add another table */
+            int   j = code >> (32 - table_nb_bits);
+            int  nb = 1 << (table_nb_bits - n);
+            int inc = 1;
+
+            if (flags & INIT_VLC_OUTPUT_LE) {
+                j = bitswap_32(code);
+                inc = 1 << n;
+            }
+            for (int k = 0; k < nb; k++) {
+                int   bits = table[j].len;
+                int oldsym = table[j].sym;
+                ff_dlog(NULL, "%4x: code=%d n=%d\n", j, i, n);
+                if ((bits || oldsym) && (bits != n || oldsym != symbol)) {
+                    av_log(NULL, AV_LOG_ERROR, "incorrect codes\n");
+                    return AVERROR_INVALIDDATA;
+                }
+                table[j].len = n;
+                table[j].sym = symbol;
+                j += inc;
+            }
+        } else {
+            /* fill auxiliary table recursively */
+            uint32_t code_prefix;
+            int index, subtable_bits, j, k;
+
+            n -= table_nb_bits;
+            code_prefix = code >> (32 - table_nb_bits);
+            subtable_bits = n;
+            codes[i].bits = n;
+            codes[i].code = code << table_nb_bits;
+            for (k = i + 1; k < nb_codes; k++) {
+                n = codes[k].bits - table_nb_bits;
+                if (n <= 0)
+                    break;
+                code = codes[k].code;
+                if (code >> (32 - table_nb_bits) != code_prefix)
+                    break;
+                codes[k].bits = n;
+                codes[k].code = code << table_nb_bits;
+                subtable_bits = FFMAX(subtable_bits, n);
+            }
+            subtable_bits = FFMIN(subtable_bits, table_nb_bits);
+            j = (flags & INIT_VLC_OUTPUT_LE) ? bitswap_32(code_prefix) >> (32 - table_nb_bits) : code_prefix;
+            table[j].len = -subtable_bits;
+            ff_dlog(NULL, "%4x: n=%d (subtable)\n",
+                    j, codes[i].bits + table_nb_bits);
+            index = build_table(vlc, subtable_bits, k-i, codes+i, flags);
+            if (index < 0)
+                return index;
+            /* note: realloc has been done, so reload tables */
+            table = &vlc->table[table_index];
+            table[j].sym = index;
+            if (table[j].sym != index) {
+                avpriv_request_sample(NULL, "strange codes");
+                return AVERROR_PATCHWELCOME;
+            }
+            i = k-1;
+        }
+    }
+
+    for (int i = 0; i < table_size; i++) {
+        if (table[i].len == 0)
+            table[i].sym = -1;
+    }
+
+    return table_index;
+}
+
+static int vlc_common_end(VLC *vlc, int nb_bits, int nb_codes, VLCcode *codes,
+                          int flags, VLCcode localbuf[LOCALBUF_ELEMS])
+{
+    int ret = build_table(vlc, nb_bits, nb_codes, codes, flags);
+
+    if (flags & INIT_VLC_USE_NEW_STATIC) {
+        if (vlc->table_size != vlc->table_allocated &&
+            !(flags & (INIT_VLC_STATIC_OVERLONG & ~INIT_VLC_USE_NEW_STATIC)))
+            av_log(NULL, AV_LOG_ERROR, "needed %d had %d\n", vlc->table_size, vlc->table_allocated);
+        av_assert0(ret >= 0);
+    } else {
+        if (codes != localbuf)
+            av_free(codes);
+        if (ret < 0) {
+            av_freep(&vlc->table);
+            return ret;
+        }
+    }
+    return 0;
+}
+
+/* Build VLC decoding tables suitable for use with get_vlc().
+
+   'nb_bits' sets the decoding table size (2^nb_bits) entries. The
+   bigger it is, the faster is the decoding. But it should not be too
+   big to save memory and L1 cache. '9' is a good compromise.
+
+   'nb_codes' : number of vlcs codes
+
+   'bits' : table which gives the size (in bits) of each vlc code.
+
+   'codes' : table which gives the bit pattern of of each vlc code.
+
+   'symbols' : table which gives the values to be returned from get_vlc().
+
+   'xxx_wrap' : give the number of bytes between each entry of the
+   'bits' or 'codes' tables.
+
+   'xxx_size' : gives the number of bytes of each entry of the 'bits'
+   or 'codes' tables. Currently 1,2 and 4 are supported.
+
+   'wrap' and 'size' make it possible to use any memory configuration and types
+   (byte/word/long) to store the 'bits', 'codes', and 'symbols' tables.
+*/
+int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,
+                       const void *bits, int bits_wrap, int bits_size,
+                       const void *codes, int codes_wrap, int codes_size,
+                       const void *symbols, int symbols_wrap, int symbols_size,
+                       int flags)
+{
+    VLCcode localbuf[LOCALBUF_ELEMS], *buf = localbuf;
+    int j, ret;
+
+    ret = vlc_common_init(vlc, nb_bits, nb_codes, &buf, flags);
+    if (ret < 0)
+        return ret;
+
+    av_assert0(symbols_size <= 2 || !symbols);
+    j = 0;
+#define COPY(condition)\
+    for (int i = 0; i < nb_codes; i++) {                                    \
+        unsigned len;                                                       \
+        GET_DATA(len, bits, i, bits_wrap, bits_size);                       \
+        if (!(condition))                                                   \
+            continue;                                                       \
+        if (len > 3*nb_bits || len > 32) {                                  \
+            av_log(NULL, AV_LOG_ERROR, "Too long VLC (%u) in init_vlc\n", len);\
+            if (buf != localbuf)                                            \
+                av_free(buf);                                               \
+            return AVERROR(EINVAL);                                         \
+        }                                                                   \
+        buf[j].bits = len;                                                  \
+        GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);            \
+        if (buf[j].code >= (1LL<<buf[j].bits)) {                            \
+            av_log(NULL, AV_LOG_ERROR, "Invalid code %"PRIx32" for %d in "  \
+                   "init_vlc\n", buf[j].code, i);                           \
+            if (buf != localbuf)                                            \
+                av_free(buf);                                               \
+            return AVERROR(EINVAL);                                         \
+        }                                                                   \
+        if (flags & INIT_VLC_INPUT_LE)                                      \
+            buf[j].code = bitswap_32(buf[j].code);                          \
+        else                                                                \
+            buf[j].code <<= 32 - buf[j].bits;                               \
+        if (symbols)                                                        \
+            GET_DATA(buf[j].symbol, symbols, i, symbols_wrap, symbols_size) \
+        else                                                                \
+            buf[j].symbol = i;                                              \
+        j++;                                                                \
+    }
+    COPY(len > nb_bits);
+    // qsort is the slowest part of init_vlc, and could probably be improved or avoided
+    AV_QSORT(buf, j, struct VLCcode, compare_vlcspec);
+    COPY(len && len <= nb_bits);
+    nb_codes = j;
+
+    return vlc_common_end(vlc, nb_bits, nb_codes, buf,
+                          flags, localbuf);
+}
+
+int ff_init_vlc_from_lengths(VLC *vlc, int nb_bits, int nb_codes,
+                             const int8_t *lens, int lens_wrap,
+                             const void *symbols, int symbols_wrap, int symbols_size,
+                             int offset, int flags, void *logctx)
+{
+    VLCcode localbuf[LOCALBUF_ELEMS], *buf = localbuf;
+    uint64_t code;
+    int ret, j, len_max = FFMIN(32, 3 * nb_bits);
+
+    ret = vlc_common_init(vlc, nb_bits, nb_codes, &buf, flags);
+    if (ret < 0)
+        return ret;
+
+    j = code = 0;
+    for (int i = 0; i < nb_codes; i++, lens += lens_wrap) {
+        int len = *lens;
+        if (len > 0) {
+            unsigned sym;
+
+            buf[j].bits = len;
+            if (symbols)
+                GET_DATA(sym, symbols, i, symbols_wrap, symbols_size)
+            else
+                sym = i;
+            buf[j].symbol = sym + offset;
+            buf[j++].code = code;
+        } else if (len <  0) {
+            len = -len;
+        } else
+            continue;
+        if (len > len_max || code & ((1U << (32 - len)) - 1)) {
+            av_log(logctx, AV_LOG_ERROR, "Invalid VLC (length %u)\n", len);
+            goto fail;
+        }
+        code += 1U << (32 - len);
+        if (code > UINT32_MAX + 1ULL) {
+            av_log(logctx, AV_LOG_ERROR, "Overdetermined VLC tree\n");
+            goto fail;
+        }
+    }
+    return vlc_common_end(vlc, nb_bits, j, buf, flags, localbuf);
+fail:
+    if (buf != localbuf)
+        av_free(buf);
+    return AVERROR_INVALIDDATA;
+}
+
+void ff_free_vlc(VLC *vlc)
+{
+    av_freep(&vlc->table);
+}
diff -Naur a/media/ffvpx/libavcodec/vlc.h b/media/ffvpx/libavcodec/vlc.h
--- a/media/ffvpx/libavcodec/vlc.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vlc.h	2023-04-06 12:49:40.256395011 +0200
@@ -21,11 +21,16 @@
 
 #include <stdint.h>
 
-#define VLC_TYPE int16_t
+// When changing this, be sure to also update tableprint_vlc.h accordingly.
+typedef int16_t VLCBaseType;
+
+typedef struct VLCElem {
+    VLCBaseType sym, len;
+} VLCElem;
 
 typedef struct VLC {
     int bits;
-    VLC_TYPE (*table)[2]; ///< code, bits
+    VLCElem *table;
     int table_size, table_allocated;
 } VLC;
 
@@ -98,7 +103,7 @@
 #define INIT_CUSTOM_VLC_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g,      \
                                       h, i, j, flags, static_size)         \
     do {                                                                   \
-        static VLC_TYPE table[static_size][2];                             \
+        static VLCElem table[static_size];                                 \
         (vlc)->table           = table;                                    \
         (vlc)->table_allocated = static_size;                              \
         ff_init_vlc_sparse(vlc, bits, a, b, c, d, e, f, g, h, i, j,        \
@@ -127,7 +132,7 @@
                                      symbols, symbols_wrap, symbols_size,  \
                                      offset, flags, static_size)           \
     do {                                                                   \
-        static VLC_TYPE table[static_size][2];                             \
+        static VLCElem table[static_size];                                 \
         (vlc)->table           = table;                                    \
         (vlc)->table_allocated = static_size;                              \
         ff_init_vlc_from_lengths(vlc, bits, nb_codes, lens, len_wrap,      \
diff -Naur a/media/ffvpx/libavcodec/vorbis_parser.c b/media/ffvpx/libavcodec/vorbis_parser.c
--- a/media/ffvpx/libavcodec/vorbis_parser.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vorbis_parser.c	2023-04-06 12:49:40.256395011 +0200
@@ -25,6 +25,8 @@
  * Determines the duration for each packet.
  */
 
+#include "config_components.h"
+
 #include "libavutil/log.h"
 
 #include "get_bits.h"
@@ -332,7 +334,7 @@
     av_vorbis_parse_free(&s->vp);
 }
 
-AVCodecParser ff_vorbis_parser = {
+const AVCodecParser ff_vorbis_parser = {
     .codec_ids      = { AV_CODEC_ID_VORBIS },
     .priv_data_size = sizeof(VorbisParseContext),
     .parser_parse   = vorbis_parse,
diff -Naur a/media/ffvpx/libavcodec/vp56.h b/media/ffvpx/libavcodec/vp56.h
--- a/media/ffvpx/libavcodec/vp56.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp56.h	2023-04-06 12:50:06.973471134 +0200
@@ -31,11 +31,11 @@
 #include "avcodec.h"
 #include "get_bits.h"
 #include "hpeldsp.h"
-#include "bytestream.h"
 #include "h264chroma.h"
 #include "videodsp.h"
 #include "vp3dsp.h"
 #include "vp56dsp.h"
+#include "vpx_rac.h"
 
 typedef struct vp56_context VP56Context;
 
@@ -44,7 +44,6 @@
     VP56_FRAME_CURRENT  = 0,
     VP56_FRAME_PREVIOUS = 1,
     VP56_FRAME_GOLDEN   = 2,
-    VP56_FRAME_GOLDEN2  = 3,
 } VP56Frame;
 
 typedef enum {
@@ -84,16 +83,6 @@
 typedef int  (*VP56ParseHeader)(VP56Context *s, const uint8_t *buf,
                                 int buf_size);
 
-typedef struct VP56RangeCoder {
-    int high;
-    int bits; /* stored negated (i.e. negative "bits" is a positive number of
-                 bits left) in order to eliminate a negate in cache refilling */
-    const uint8_t *buffer;
-    const uint8_t *end;
-    unsigned int code_word;
-    int end_reached;
-} VP56RangeCoder;
-
 typedef struct VP56RefDc {
     uint8_t not_null_dc;
     VP56Frame ref_frame;
@@ -134,9 +123,9 @@
     AVFrame *frames[4];
     uint8_t *edge_emu_buffer_alloc;
     uint8_t *edge_emu_buffer;
-    VP56RangeCoder c;
-    VP56RangeCoder cc;
-    VP56RangeCoder *ccp;
+    VPXRangeCoder c;
+    VPXRangeCoder cc;
+    VPXRangeCoder *ccp;
     int sub_version;
 
     /* frame info */
@@ -216,174 +205,47 @@
 };
 
 
-int ff_vp56_init(AVCodecContext *avctx, int flip, int has_alpha);
+/**
+ * Initializes an VP56Context. Expects its caller to clean up
+ * in case of error.
+ */
 int ff_vp56_init_context(AVCodecContext *avctx, VP56Context *s,
                           int flip, int has_alpha);
-int ff_vp56_free(AVCodecContext *avctx);
 int ff_vp56_free_context(VP56Context *s);
 void ff_vp56_init_dequant(VP56Context *s, int quantizer);
-int ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
-                         AVPacket *avpkt);
+int ff_vp56_decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                         int *got_frame, AVPacket *avpkt);
 
 
 /**
  * vp56 specific range coder implementation
  */
 
-extern const uint8_t ff_vp56_norm_shift[256];
-int ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size);
-
-/**
- * vp5689 returns 1 if the end of the stream has been reached, 0 otherwise.
- */
-static av_always_inline int vpX_rac_is_end(VP56RangeCoder *c)
-{
-    if (c->end <= c->buffer && c->bits >= 0)
-        c->end_reached ++;
-    return c->end_reached > 10;
-}
-
-static av_always_inline unsigned int vp56_rac_renorm(VP56RangeCoder *c)
-{
-    int shift = ff_vp56_norm_shift[c->high];
-    int bits = c->bits;
-    unsigned int code_word = c->code_word;
-
-    c->high   <<= shift;
-    code_word <<= shift;
-    bits       += shift;
-    if(bits >= 0 && c->buffer < c->end) {
-        code_word |= bytestream_get_be16(&c->buffer) << bits;
-        bits -= 16;
-    }
-    c->bits = bits;
-    return code_word;
-}
-
-#if   ARCH_ARM
-#include "arm/vp56_arith.h"
-#elif ARCH_X86
-#include "x86/vp56_arith.h"
-#endif
-
-#ifndef vp56_rac_get_prob
-#define vp56_rac_get_prob vp56_rac_get_prob
-static av_always_inline int vp56_rac_get_prob(VP56RangeCoder *c, uint8_t prob)
-{
-    unsigned int code_word = vp56_rac_renorm(c);
-    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
-    unsigned int low_shift = low << 16;
-    int bit = code_word >= low_shift;
-
-    c->high = bit ? c->high - low : low;
-    c->code_word = bit ? code_word - low_shift : code_word;
-
-    return bit;
-}
-#endif
-
-#ifndef vp56_rac_get_prob_branchy
-// branchy variant, to be used where there's a branch based on the bit decoded
-static av_always_inline int vp56_rac_get_prob_branchy(VP56RangeCoder *c, int prob)
-{
-    unsigned long code_word = vp56_rac_renorm(c);
-    unsigned low = 1 + (((c->high - 1) * prob) >> 8);
-    unsigned low_shift = low << 16;
-
-    if (code_word >= low_shift) {
-        c->high     -= low;
-        c->code_word = code_word - low_shift;
-        return 1;
-    }
-
-    c->high = low;
-    c->code_word = code_word;
-    return 0;
-}
-#endif
-
-static av_always_inline int vp56_rac_get(VP56RangeCoder *c)
-{
-    unsigned int code_word = vp56_rac_renorm(c);
-    /* equiprobable */
-    int low = (c->high + 1) >> 1;
-    unsigned int low_shift = low << 16;
-    int bit = code_word >= low_shift;
-    if (bit) {
-        c->high   -= low;
-        code_word -= low_shift;
-    } else {
-        c->high = low;
-    }
-
-    c->code_word = code_word;
-    return bit;
-}
-
-// rounding is different than vp56_rac_get, is vp56_rac_get wrong?
-static av_always_inline int vp8_rac_get(VP56RangeCoder *c)
-{
-    return vp56_rac_get_prob(c, 128);
-}
-
-static int vp56_rac_gets(VP56RangeCoder *c, int bits)
+static int vp56_rac_gets(VPXRangeCoder *c, int bits)
 {
     int value = 0;
 
     while (bits--) {
-        value = (value << 1) | vp56_rac_get(c);
+        value = (value << 1) | vpx_rac_get(c);
     }
 
     return value;
 }
 
-static int vp8_rac_get_uint(VP56RangeCoder *c, int bits)
-{
-    int value = 0;
-
-    while (bits--) {
-        value = (value << 1) | vp8_rac_get(c);
-    }
-
-    return value;
-}
-
-// fixme: add 1 bit to all the calls to this?
-static av_unused int vp8_rac_get_sint(VP56RangeCoder *c, int bits)
-{
-    int v;
-
-    if (!vp8_rac_get(c))
-        return 0;
-
-    v = vp8_rac_get_uint(c, bits);
-
-    if (vp8_rac_get(c))
-        v = -v;
-
-    return v;
-}
-
 // P(7)
-static av_unused int vp56_rac_gets_nn(VP56RangeCoder *c, int bits)
+static av_unused int vp56_rac_gets_nn(VPXRangeCoder *c, int bits)
 {
     int v = vp56_rac_gets(c, 7) << 1;
     return v + !v;
 }
 
-static av_unused int vp8_rac_get_nn(VP56RangeCoder *c)
-{
-    int v = vp8_rac_get_uint(c, 7) << 1;
-    return v + !v;
-}
-
 static av_always_inline
-int vp56_rac_get_tree(VP56RangeCoder *c,
+int vp56_rac_get_tree(VPXRangeCoder *c,
                       const VP56Tree *tree,
                       const uint8_t *probs)
 {
     while (tree->val > 0) {
-        if (vp56_rac_get_prob_branchy(c, probs[tree->prob_idx]))
+        if (vpx_rac_get_prob_branchy(c, probs[tree->prob_idx]))
             tree += tree->val;
         else
             tree++;
@@ -391,30 +253,4 @@
     return -tree->val;
 }
 
-// how probabilities are associated with decisions is different I think
-// well, the new scheme fits in the old but this way has one fewer branches per decision
-static av_always_inline int vp8_rac_get_tree(VP56RangeCoder *c, const int8_t (*tree)[2],
-                                   const uint8_t *probs)
-{
-    int i = 0;
-
-    do {
-        i = tree[i][vp56_rac_get_prob(c, probs[i])];
-    } while (i > 0);
-
-    return -i;
-}
-
-// DCTextra
-static av_always_inline int vp8_rac_get_coeff(VP56RangeCoder *c, const uint8_t *prob)
-{
-    int v = 0;
-
-    do {
-        v = (v<<1) + vp56_rac_get_prob(c, *prob++);
-    } while (*prob);
-
-    return v;
-}
-
 #endif /* AVCODEC_VP56_H */
diff -Naur a/media/ffvpx/libavcodec/vp56rac.c b/media/ffvpx/libavcodec/vp56rac.c
--- a/media/ffvpx/libavcodec/vp56rac.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp56rac.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-/*
- * VP5/6/8 decoder
- * Copyright (c) 2010 Fiona Glaser <fiona@x264.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libavutil/common.h"
-#include "vp56.h"
-
-const uint8_t ff_vp56_norm_shift[256]= {
- 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
- 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
- 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
- 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-};
-
-int ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
-{
-    c->high = 255;
-    c->bits = -16;
-    c->buffer = buf;
-    c->end = buf + buf_size;
-    c->end_reached = 0;
-    if (buf_size < 1)
-        return AVERROR_INVALIDDATA;
-    c->code_word = bytestream_get_be24(&c->buffer);
-    return 0;
-}
diff -Naur a/media/ffvpx/libavcodec/vp89_rac.h b/media/ffvpx/libavcodec/vp89_rac.h
--- a/media/ffvpx/libavcodec/vp89_rac.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp89_rac.h	2023-04-06 12:50:06.974471174 +0200
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Range decoder functions common to VP8 and VP9
+ */
+
+#ifndef AVCODEC_VP89_RAC_H
+#define AVCODEC_VP89_RAC_H
+
+#include <stdint.h>
+
+#include "libavutil/attributes.h"
+
+#include "vpx_rac.h"
+
+// rounding is different than vpx_rac_get, is vpx_rac_get wrong?
+static av_always_inline int vp89_rac_get(VPXRangeCoder *c)
+{
+    return vpx_rac_get_prob(c, 128);
+}
+
+static av_unused int vp89_rac_get_uint(VPXRangeCoder *c, int bits)
+{
+    int value = 0;
+
+    while (bits--) {
+        value = (value << 1) | vp89_rac_get(c);
+    }
+
+    return value;
+}
+
+// how probabilities are associated with decisions is different I think
+// well, the new scheme fits in the old but this way has one fewer branches per decision
+static av_always_inline int vp89_rac_get_tree(VPXRangeCoder *c, const int8_t (*tree)[2],
+                                              const uint8_t *probs)
+{
+    int i = 0;
+
+    do {
+        i = tree[i][vpx_rac_get_prob(c, probs[i])];
+    } while (i > 0);
+
+    return -i;
+}
+
+#endif /* AVCODEC_VP89_RAC_H */
diff -Naur a/media/ffvpx/libavcodec/vp8.c b/media/ffvpx/libavcodec/vp8.c
--- a/media/ffvpx/libavcodec/vp8.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp8.c	2023-04-06 12:50:24.493176583 +0200
@@ -24,29 +24,59 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "libavutil/imgutils.h"
+#include "config_components.h"
+
 #include "libavutil/mem_internal.h"
 
 #include "avcodec.h"
+#include "codec_internal.h"
+#include "decode.h"
 #include "hwconfig.h"
-#include "internal.h"
 #include "mathops.h"
-#include "rectangle.h"
 #include "thread.h"
+#include "threadframe.h"
 #include "vp8.h"
+#include "vp89_rac.h"
 #include "vp8data.h"
+#include "vpx_rac.h"
 
 #if ARCH_ARM
 #   include "arm/vp8.h"
 #endif
 
-#if CONFIG_VP7_DECODER && CONFIG_VP8_DECODER
-#define VPX(vp7, f) (vp7 ? vp7_ ## f : vp8_ ## f)
-#elif CONFIG_VP7_DECODER
-#define VPX(vp7, f) vp7_ ## f
-#else // CONFIG_VP8_DECODER
-#define VPX(vp7, f) vp8_ ## f
-#endif
+// fixme: add 1 bit to all the calls to this?
+static int vp8_rac_get_sint(VPXRangeCoder *c, int bits)
+{
+    int v;
+
+    if (!vp89_rac_get(c))
+        return 0;
+
+    v = vp89_rac_get_uint(c, bits);
+
+    if (vp89_rac_get(c))
+        v = -v;
+
+    return v;
+}
+
+static int vp8_rac_get_nn(VPXRangeCoder *c)
+{
+    int v = vp89_rac_get_uint(c, 7) << 1;
+    return v + !v;
+}
+
+// DCTextra
+static int vp8_rac_get_coeff(VPXRangeCoder *c, const uint8_t *prob)
+{
+    int v = 0;
+
+    do {
+        v = (v<<1) + vpx_rac_get_prob(c, *prob++);
+    } while (*prob);
+
+    return v;
+}
 
 static void free_buffers(VP8Context *s)
 {
@@ -71,8 +101,8 @@
 static int vp8_alloc_frame(VP8Context *s, VP8Frame *f, int ref)
 {
     int ret;
-    if ((ret = ff_thread_get_buffer(s->avctx, &f->tf,
-                                    ref ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)
+    if ((ret = ff_thread_get_ext_buffer(s->avctx, &f->tf,
+                                        ref ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)
         return ret;
     if (!(f->seg_map = av_buffer_allocz(s->mb_width * s->mb_height)))
         goto fail;
@@ -89,7 +119,7 @@
 
 fail:
     av_buffer_unref(&f->seg_map);
-    ff_thread_release_buffer(s->avctx, &f->tf);
+    ff_thread_release_ext_buffer(s->avctx, &f->tf);
     return AVERROR(ENOMEM);
 }
 
@@ -98,11 +128,11 @@
     av_buffer_unref(&f->seg_map);
     av_buffer_unref(&f->hwaccel_priv_buf);
     f->hwaccel_picture_private = NULL;
-    ff_thread_release_buffer(s->avctx, &f->tf);
+    ff_thread_release_ext_buffer(s->avctx, &f->tf);
 }
 
 #if CONFIG_VP8_DECODER
-static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, VP8Frame *src)
+static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, const VP8Frame *src)
 {
     int ret;
 
@@ -151,10 +181,10 @@
 
     // find a free buffer
     for (i = 0; i < 5; i++)
-        if (&s->frames[i] != s->framep[VP56_FRAME_CURRENT]  &&
-            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) {
+        if (&s->frames[i] != s->framep[VP8_FRAME_CURRENT]  &&
+            &s->frames[i] != s->framep[VP8_FRAME_PREVIOUS] &&
+            &s->frames[i] != s->framep[VP8_FRAME_GOLDEN]   &&
+            &s->frames[i] != s->framep[VP8_FRAME_ALTREF]) {
             frame = &s->frames[i];
             break;
         }
@@ -262,14 +292,14 @@
 
 static void parse_segment_info(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i;
 
-    s->segmentation.update_map = vp8_rac_get(c);
-    s->segmentation.update_feature_data = vp8_rac_get(c);
+    s->segmentation.update_map = vp89_rac_get(c);
+    s->segmentation.update_feature_data = vp89_rac_get(c);
 
     if (s->segmentation.update_feature_data) {
-        s->segmentation.absolute_vals = vp8_rac_get(c);
+        s->segmentation.absolute_vals = vp89_rac_get(c);
 
         for (i = 0; i < 4; i++)
             s->segmentation.base_quant[i]   = vp8_rac_get_sint(c, 7);
@@ -279,28 +309,28 @@
     }
     if (s->segmentation.update_map)
         for (i = 0; i < 3; i++)
-            s->prob->segmentid[i] = vp8_rac_get(c) ? vp8_rac_get_uint(c, 8) : 255;
+            s->prob->segmentid[i] = vp89_rac_get(c) ? vp89_rac_get_uint(c, 8) : 255;
 }
 
 static void update_lf_deltas(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i;
 
     for (i = 0; i < 4; i++) {
-        if (vp8_rac_get(c)) {
-            s->lf_delta.ref[i] = vp8_rac_get_uint(c, 6);
+        if (vp89_rac_get(c)) {
+            s->lf_delta.ref[i] = vp89_rac_get_uint(c, 6);
 
-            if (vp8_rac_get(c))
+            if (vp89_rac_get(c))
                 s->lf_delta.ref[i] = -s->lf_delta.ref[i];
         }
     }
 
     for (i = MODE_I4x4; i <= VP8_MVMODE_SPLIT; i++) {
-        if (vp8_rac_get(c)) {
-            s->lf_delta.mode[i] = vp8_rac_get_uint(c, 6);
+        if (vp89_rac_get(c)) {
+            s->lf_delta.mode[i] = vp89_rac_get_uint(c, 6);
 
-            if (vp8_rac_get(c))
+            if (vp89_rac_get(c))
                 s->lf_delta.mode[i] = -s->lf_delta.mode[i];
         }
     }
@@ -312,7 +342,7 @@
     int i;
     int ret;
 
-    s->num_coeff_partitions = 1 << vp8_rac_get_uint(&s->c, 2);
+    s->num_coeff_partitions = 1 << vp89_rac_get_uint(&s->c, 2);
 
     buf      += 3 * (s->num_coeff_partitions - 1);
     buf_size -= 3 * (s->num_coeff_partitions - 1);
@@ -325,7 +355,7 @@
             return -1;
         s->coeff_partition_size[i] = size;
 
-        ret = ff_vp56_init_range_decoder(&s->coeff_partition[i], buf, size);
+        ret = ff_vpx_init_range_decoder(&s->coeff_partition[i], buf, size);
         if (ret < 0)
             return ret;
         buf      += size;
@@ -333,21 +363,21 @@
     }
 
     s->coeff_partition_size[i] = buf_size;
-    ff_vp56_init_range_decoder(&s->coeff_partition[i], buf, buf_size);
+    ff_vpx_init_range_decoder(&s->coeff_partition[i], buf, buf_size);
 
     return 0;
 }
 
 static void vp7_get_quants(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
-    int yac_qi  = vp8_rac_get_uint(c, 7);
-    int ydc_qi  = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int y2dc_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int y2ac_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int uvdc_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int uvac_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
+    int yac_qi  = vp89_rac_get_uint(c, 7);
+    int ydc_qi  = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int y2dc_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int y2ac_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int uvdc_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int uvac_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
 
     s->qmat[0].luma_qmul[0]    =       vp7_ydc_qlookup[ydc_qi];
     s->qmat[0].luma_qmul[1]    =       vp7_yac_qlookup[yac_qi];
@@ -359,10 +389,10 @@
 
 static void vp8_get_quants(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i, base_qi;
 
-    s->quant.yac_qi     = vp8_rac_get_uint(c, 7);
+    s->quant.yac_qi     = vp89_rac_get_uint(c, 7);
     s->quant.ydc_delta  = vp8_rac_get_sint(c, 4);
     s->quant.y2dc_delta = vp8_rac_get_sint(c, 4);
     s->quant.y2ac_delta = vp8_rac_get_sint(c, 4);
@@ -395,28 +425,28 @@
  * The spec isn't clear here, so I'm going by my understanding of what libvpx does
  *
  * Intra frames update all 3 references
- * Inter frames update VP56_FRAME_PREVIOUS if the update_last flag is set
+ * Inter frames update VP8_FRAME_PREVIOUS if the update_last flag is set
  * If the update (golden|altref) flag is set, it's updated with the current frame
- *      if update_last is set, and VP56_FRAME_PREVIOUS otherwise.
+ *      if update_last is set, and VP8_FRAME_PREVIOUS otherwise.
  * If the flag is not set, the number read means:
  *      0: no update
- *      1: VP56_FRAME_PREVIOUS
+ *      1: VP8_FRAME_PREVIOUS
  *      2: update golden with altref, or update altref with golden
  */
-static VP56Frame ref_to_update(VP8Context *s, int update, VP56Frame ref)
+static VP8FrameType ref_to_update(VP8Context *s, int update, VP8FrameType ref)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
     if (update)
-        return VP56_FRAME_CURRENT;
+        return VP8_FRAME_CURRENT;
 
-    switch (vp8_rac_get_uint(c, 2)) {
+    switch (vp89_rac_get_uint(c, 2)) {
     case 1:
-        return VP56_FRAME_PREVIOUS;
+        return VP8_FRAME_PREVIOUS;
     case 2:
-        return (ref == VP56_FRAME_GOLDEN) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN;
+        return (ref == VP8_FRAME_GOLDEN) ? VP8_FRAME_ALTREF : VP8_FRAME_GOLDEN;
     }
-    return VP56_FRAME_NONE;
+    return VP8_FRAME_NONE;
 }
 
 static void vp78_reset_probability_tables(VP8Context *s)
@@ -430,15 +460,15 @@
 
 static void vp78_update_probability_tables(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i, j, k, l, m;
 
     for (i = 0; i < 4; i++)
         for (j = 0; j < 8; j++)
             for (k = 0; k < 3; k++)
                 for (l = 0; l < NUM_DCT_TOKENS-1; l++)
-                    if (vp56_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l])) {
-                        int prob = vp8_rac_get_uint(c, 8);
+                    if (vpx_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l])) {
+                        int prob = vp89_rac_get_uint(c, 8);
                         for (m = 0; vp8_coeff_band_indexes[j][m] >= 0; m++)
                             s->prob->token[i][vp8_coeff_band_indexes[j][m]][k][l] = prob;
                     }
@@ -450,35 +480,35 @@
 static void vp78_update_pred16x16_pred8x8_mvc_probabilities(VP8Context *s,
                                                             int mvc_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i, j;
 
-    if (vp8_rac_get(c))
+    if (vp89_rac_get(c))
         for (i = 0; i < 4; i++)
-            s->prob->pred16x16[i] = vp8_rac_get_uint(c, 8);
-    if (vp8_rac_get(c))
+            s->prob->pred16x16[i] = vp89_rac_get_uint(c, 8);
+    if (vp89_rac_get(c))
         for (i = 0; i < 3; i++)
-            s->prob->pred8x8c[i]  = vp8_rac_get_uint(c, 8);
+            s->prob->pred8x8c[i]  = vp89_rac_get_uint(c, 8);
 
     // 17.2 MV probability update
     for (i = 0; i < 2; i++)
         for (j = 0; j < mvc_size; j++)
-            if (vp56_rac_get_prob_branchy(c, vp8_mv_update_prob[i][j]))
+            if (vpx_rac_get_prob_branchy(c, vp8_mv_update_prob[i][j]))
                 s->prob->mvc[i][j] = vp8_rac_get_nn(c);
 }
 
 static void update_refs(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
-    int update_golden = vp8_rac_get(c);
-    int update_altref = vp8_rac_get(c);
+    int update_golden = vp89_rac_get(c);
+    int update_altref = vp89_rac_get(c);
 
-    s->update_golden = ref_to_update(s, update_golden, VP56_FRAME_GOLDEN);
-    s->update_altref = ref_to_update(s, update_altref, VP56_FRAME_GOLDEN2);
+    s->update_golden = ref_to_update(s, update_golden, VP8_FRAME_GOLDEN);
+    s->update_altref = ref_to_update(s, update_altref, VP8_FRAME_ALTREF);
 }
 
-static void copy_chroma(AVFrame *dst, AVFrame *src, int width, int height)
+static void copy_chroma(AVFrame *dst, const AVFrame *src, int width, int height)
 {
     int i, j;
 
@@ -512,24 +542,25 @@
     if (!s->keyframe && (alpha || beta)) {
         int width  = s->mb_width * 16;
         int height = s->mb_height * 16;
-        AVFrame *src, *dst;
+        const AVFrame *src;
+        AVFrame *dst;
 
-        if (!s->framep[VP56_FRAME_PREVIOUS] ||
-            !s->framep[VP56_FRAME_GOLDEN]) {
+        if (!s->framep[VP8_FRAME_PREVIOUS] ||
+            !s->framep[VP8_FRAME_GOLDEN]) {
             av_log(s->avctx, AV_LOG_WARNING, "Discarding interframe without a prior keyframe!\n");
             return AVERROR_INVALIDDATA;
         }
 
-        dst =
-        src = s->framep[VP56_FRAME_PREVIOUS]->tf.f;
+        src =
+        dst = s->framep[VP8_FRAME_PREVIOUS]->tf.f;
 
         /* preserve the golden frame, write a new previous frame */
-        if (s->framep[VP56_FRAME_GOLDEN] == s->framep[VP56_FRAME_PREVIOUS]) {
-            s->framep[VP56_FRAME_PREVIOUS] = vp8_find_free_buffer(s);
-            if ((ret = vp8_alloc_frame(s, s->framep[VP56_FRAME_PREVIOUS], 1)) < 0)
+        if (s->framep[VP8_FRAME_GOLDEN] == s->framep[VP8_FRAME_PREVIOUS]) {
+            s->framep[VP8_FRAME_PREVIOUS] = vp8_find_free_buffer(s);
+            if ((ret = vp8_alloc_frame(s, s->framep[VP8_FRAME_PREVIOUS], 1)) < 0)
                 return ret;
 
-            dst = s->framep[VP56_FRAME_PREVIOUS]->tf.f;
+            dst = s->framep[VP8_FRAME_PREVIOUS]->tf.f;
 
             copy_chroma(dst, src, width, height);
         }
@@ -544,12 +575,13 @@
 
 static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int part1_size, hscale, vscale, i, j, ret;
     int width  = s->avctx->width;
     int height = s->avctx->height;
     int alpha = 0;
     int beta  = 0;
+    int fade_present = 1;
 
     if (buf_size < 4) {
         return AVERROR_INVALIDDATA;
@@ -575,7 +607,7 @@
 
     memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab, sizeof(s->put_pixels_tab));
 
-    ret = ff_vp56_init_range_decoder(c, buf, part1_size);
+    ret = ff_vpx_init_range_decoder(c, buf, part1_size);
     if (ret < 0)
         return ret;
     buf      += part1_size;
@@ -583,14 +615,14 @@
 
     /* A. Dimension information (keyframes only) */
     if (s->keyframe) {
-        width  = vp8_rac_get_uint(c, 12);
-        height = vp8_rac_get_uint(c, 12);
-        hscale = vp8_rac_get_uint(c, 2);
-        vscale = vp8_rac_get_uint(c, 2);
+        width  = vp89_rac_get_uint(c, 12);
+        height = vp89_rac_get_uint(c, 12);
+        hscale = vp89_rac_get_uint(c, 2);
+        vscale = vp89_rac_get_uint(c, 2);
         if (hscale || vscale)
             avpriv_request_sample(s->avctx, "Upscaling");
 
-        s->update_golden = s->update_altref = VP56_FRAME_CURRENT;
+        s->update_golden = s->update_altref = VP8_FRAME_CURRENT;
         vp78_reset_probability_tables(s);
         memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter,
                sizeof(s->prob->pred16x16));
@@ -609,18 +641,18 @@
 
     /* B. Decoding information for all four macroblock-level features */
     for (i = 0; i < 4; i++) {
-        s->feature_enabled[i] = vp8_rac_get(c);
+        s->feature_enabled[i] = vp89_rac_get(c);
         if (s->feature_enabled[i]) {
-             s->feature_present_prob[i] = vp8_rac_get_uint(c, 8);
+             s->feature_present_prob[i] = vp89_rac_get_uint(c, 8);
 
              for (j = 0; j < 3; j++)
                  s->feature_index_prob[i][j] =
-                     vp8_rac_get(c) ? vp8_rac_get_uint(c, 8) : 255;
+                     vp89_rac_get(c) ? vp89_rac_get_uint(c, 8) : 255;
 
              if (vp7_feature_value_size[s->profile][i])
                  for (j = 0; j < 4; j++)
                      s->feature_value[i][j] =
-                        vp8_rac_get(c) ? vp8_rac_get_uint(c, vp7_feature_value_size[s->profile][i]) : 0;
+                        vp89_rac_get(c) ? vp89_rac_get_uint(c, vp7_feature_value_size[s->profile][i]) : 0;
         }
     }
 
@@ -629,7 +661,7 @@
     s->lf_delta.enabled        = 0;
 
     s->num_coeff_partitions = 1;
-    ret = ff_vp56_init_range_decoder(&s->coeff_partition[0], buf, buf_size);
+    ret = ff_vpx_init_range_decoder(&s->coeff_partition[0], buf, buf_size);
     if (ret < 0)
         return ret;
 
@@ -645,45 +677,44 @@
 
     /* D. Golden frame update flag (a Flag) for interframes only */
     if (!s->keyframe) {
-        s->update_golden = vp8_rac_get(c) ? VP56_FRAME_CURRENT : VP56_FRAME_NONE;
-        s->sign_bias[VP56_FRAME_GOLDEN] = 0;
+        s->update_golden = vp89_rac_get(c) ? VP8_FRAME_CURRENT : VP8_FRAME_NONE;
+        s->sign_bias[VP8_FRAME_GOLDEN] = 0;
     }
 
     s->update_last          = 1;
     s->update_probabilities = 1;
-    s->fade_present         = 1;
 
     if (s->profile > 0) {
-        s->update_probabilities = vp8_rac_get(c);
+        s->update_probabilities = vp89_rac_get(c);
         if (!s->update_probabilities)
             s->prob[1] = s->prob[0];
 
         if (!s->keyframe)
-            s->fade_present = vp8_rac_get(c);
+            fade_present = vp89_rac_get(c);
     }
 
-    if (vpX_rac_is_end(c))
+    if (vpx_rac_is_end(c))
         return AVERROR_INVALIDDATA;
     /* E. Fading information for previous frame */
-    if (s->fade_present && vp8_rac_get(c)) {
-        alpha = (int8_t) vp8_rac_get_uint(c, 8);
-        beta  = (int8_t) vp8_rac_get_uint(c, 8);
+    if (fade_present && vp89_rac_get(c)) {
+        alpha = (int8_t) vp89_rac_get_uint(c, 8);
+        beta  = (int8_t) vp89_rac_get_uint(c, 8);
     }
 
     /* F. Loop filter type */
     if (!s->profile)
-        s->filter.simple = vp8_rac_get(c);
+        s->filter.simple = vp89_rac_get(c);
 
     /* G. DCT coefficient ordering specification */
-    if (vp8_rac_get(c))
+    if (vp89_rac_get(c))
         for (i = 1; i < 16; i++)
-            s->prob[0].scan[i] = ff_zigzag_scan[vp8_rac_get_uint(c, 4)];
+            s->prob[0].scan[i] = ff_zigzag_scan[vp89_rac_get_uint(c, 4)];
 
     /* H. Loop filter levels  */
     if (s->profile > 0)
-        s->filter.simple = vp8_rac_get(c);
-    s->filter.level     = vp8_rac_get_uint(c, 6);
-    s->filter.sharpness = vp8_rac_get_uint(c, 3);
+        s->filter.simple = vp89_rac_get(c);
+    s->filter.level     = vp89_rac_get_uint(c, 6);
+    s->filter.sharpness = vp89_rac_get_uint(c, 3);
 
     /* I. DCT coefficient probability update; 13.3 Token Probability Updates */
     vp78_update_probability_tables(s);
@@ -692,12 +723,12 @@
 
     /* J. The remaining frame header data occurs ONLY FOR INTERFRAMES */
     if (!s->keyframe) {
-        s->prob->intra  = vp8_rac_get_uint(c, 8);
-        s->prob->last   = vp8_rac_get_uint(c, 8);
+        s->prob->intra  = vp89_rac_get_uint(c, 8);
+        s->prob->last   = vp89_rac_get_uint(c, 8);
         vp78_update_pred16x16_pred8x8_mvc_probabilities(s, VP7_MVC_SIZE);
     }
 
-    if (vpX_rac_is_end(c))
+    if (vpx_rac_is_end(c))
         return AVERROR_INVALIDDATA;
 
     if ((ret = vp7_fade_frame(s, alpha, beta)) < 0)
@@ -708,7 +739,7 @@
 
 static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int header_size, hscale, vscale, ret;
     int width  = s->avctx->width;
     int height = s->avctx->height;
@@ -758,7 +789,7 @@
         if (hscale || vscale)
             avpriv_request_sample(s->avctx, "Upscaling");
 
-        s->update_golden = s->update_altref = VP56_FRAME_CURRENT;
+        s->update_golden = s->update_altref = VP8_FRAME_CURRENT;
         vp78_reset_probability_tables(s);
         memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter,
                sizeof(s->prob->pred16x16));
@@ -770,30 +801,30 @@
         memset(&s->lf_delta, 0, sizeof(s->lf_delta));
     }
 
-    ret = ff_vp56_init_range_decoder(c, buf, header_size);
+    ret = ff_vpx_init_range_decoder(c, buf, header_size);
     if (ret < 0)
         return ret;
     buf      += header_size;
     buf_size -= header_size;
 
     if (s->keyframe) {
-        s->colorspace = vp8_rac_get(c);
+        s->colorspace = vp89_rac_get(c);
         if (s->colorspace)
             av_log(s->avctx, AV_LOG_WARNING, "Unspecified colorspace\n");
-        s->fullrange = vp8_rac_get(c);
+        s->fullrange = vp89_rac_get(c);
     }
 
-    if ((s->segmentation.enabled = vp8_rac_get(c)))
+    if ((s->segmentation.enabled = vp89_rac_get(c)))
         parse_segment_info(s);
     else
         s->segmentation.update_map = 0; // FIXME: move this to some init function?
 
-    s->filter.simple    = vp8_rac_get(c);
-    s->filter.level     = vp8_rac_get_uint(c, 6);
-    s->filter.sharpness = vp8_rac_get_uint(c, 3);
+    s->filter.simple    = vp89_rac_get(c);
+    s->filter.level     = vp89_rac_get_uint(c, 6);
+    s->filter.sharpness = vp89_rac_get_uint(c, 3);
 
-    if ((s->lf_delta.enabled = vp8_rac_get(c))) {
-        s->lf_delta.update = vp8_rac_get(c);
+    if ((s->lf_delta.enabled = vp89_rac_get(c))) {
+        s->lf_delta.update = vp89_rac_get(c);
         if (s->lf_delta.update)
             update_lf_deltas(s);
     }
@@ -813,31 +844,31 @@
 
     if (!s->keyframe) {
         update_refs(s);
-        s->sign_bias[VP56_FRAME_GOLDEN]               = vp8_rac_get(c);
-        s->sign_bias[VP56_FRAME_GOLDEN2 /* altref */] = vp8_rac_get(c);
+        s->sign_bias[VP8_FRAME_GOLDEN] = vp89_rac_get(c);
+        s->sign_bias[VP8_FRAME_ALTREF] = vp89_rac_get(c);
     }
 
     // if we aren't saving this frame's probabilities for future frames,
     // make a copy of the current probabilities
-    if (!(s->update_probabilities = vp8_rac_get(c)))
+    if (!(s->update_probabilities = vp89_rac_get(c)))
         s->prob[1] = s->prob[0];
 
-    s->update_last = s->keyframe || vp8_rac_get(c);
+    s->update_last = s->keyframe || vp89_rac_get(c);
 
     vp78_update_probability_tables(s);
 
-    if ((s->mbskip_enabled = vp8_rac_get(c)))
-        s->prob->mbskip = vp8_rac_get_uint(c, 8);
+    if ((s->mbskip_enabled = vp89_rac_get(c)))
+        s->prob->mbskip = vp89_rac_get_uint(c, 8);
 
     if (!s->keyframe) {
-        s->prob->intra  = vp8_rac_get_uint(c, 8);
-        s->prob->last   = vp8_rac_get_uint(c, 8);
-        s->prob->golden = vp8_rac_get_uint(c, 8);
+        s->prob->intra  = vp89_rac_get_uint(c, 8);
+        s->prob->last   = vp89_rac_get_uint(c, 8);
+        s->prob->golden = vp89_rac_get_uint(c, 8);
         vp78_update_pred16x16_pred8x8_mvc_probabilities(s, VP8_MVC_SIZE);
     }
 
     // Record the entropy coder state here so that hwaccels can use it.
-    s->c.code_word = vp56_rac_renorm(&s->c);
+    s->c.code_word = vpx_rac_renorm(&s->c);
     s->coder_state_at_header_end.input     = s->c.buffer - (-s->c.bits / 8);
     s->coder_state_at_header_end.range     = s->c.high;
     s->coder_state_at_header_end.value     = s->c.code_word >> 16;
@@ -847,7 +878,7 @@
 }
 
 static av_always_inline
-void clamp_mv(VP8mvbounds *s, VP56mv *dst, const VP56mv *src)
+void clamp_mv(const VP8mvbounds *s, VP8mv *dst, const VP8mv *src)
 {
     dst->x = av_clip(src->x, av_clip(s->mv_min.x, INT16_MIN, INT16_MAX),
                              av_clip(s->mv_max.x, INT16_MIN, INT16_MAX));
@@ -858,40 +889,40 @@
 /**
  * Motion vector coding, 17.1.
  */
-static av_always_inline int read_mv_component(VP56RangeCoder *c, const uint8_t *p, int vp7)
+static av_always_inline int read_mv_component(VPXRangeCoder *c, const uint8_t *p, int vp7)
 {
     int bit, x = 0;
 
-    if (vp56_rac_get_prob_branchy(c, p[0])) {
+    if (vpx_rac_get_prob_branchy(c, p[0])) {
         int i;
 
         for (i = 0; i < 3; i++)
-            x += vp56_rac_get_prob(c, p[9 + i]) << i;
+            x += vpx_rac_get_prob(c, p[9 + i]) << i;
         for (i = (vp7 ? 7 : 9); i > 3; i--)
-            x += vp56_rac_get_prob(c, p[9 + i]) << i;
-        if (!(x & (vp7 ? 0xF0 : 0xFFF0)) || vp56_rac_get_prob(c, p[12]))
+            x += vpx_rac_get_prob(c, p[9 + i]) << i;
+        if (!(x & (vp7 ? 0xF0 : 0xFFF0)) || vpx_rac_get_prob(c, p[12]))
             x += 8;
     } else {
         // small_mvtree
         const uint8_t *ps = p + 2;
-        bit = vp56_rac_get_prob(c, *ps);
+        bit = vpx_rac_get_prob(c, *ps);
         ps += 1 + 3 * bit;
         x  += 4 * bit;
-        bit = vp56_rac_get_prob(c, *ps);
+        bit = vpx_rac_get_prob(c, *ps);
         ps += 1 + bit;
         x  += 2 * bit;
-        x  += vp56_rac_get_prob(c, *ps);
+        x  += vpx_rac_get_prob(c, *ps);
     }
 
-    return (x && vp56_rac_get_prob(c, p[1])) ? -x : x;
+    return (x && vpx_rac_get_prob(c, p[1])) ? -x : x;
 }
 
-static int vp7_read_mv_component(VP56RangeCoder *c, const uint8_t *p)
+static int vp7_read_mv_component(VPXRangeCoder *c, const uint8_t *p)
 {
     return read_mv_component(c, p, 1);
 }
 
-static int vp8_read_mv_component(VP56RangeCoder *c, const uint8_t *p)
+static int vp8_read_mv_component(VPXRangeCoder *c, const uint8_t *p)
 {
     return read_mv_component(c, p, 0);
 }
@@ -914,18 +945,18 @@
  * @returns the number of motion vectors parsed (2, 4 or 16)
  */
 static av_always_inline
-int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
+int decode_splitmvs(const VP8Context *s, VPXRangeCoder *c, VP8Macroblock *mb,
                     int layout, int is_vp7)
 {
     int part_idx;
     int n, num;
-    VP8Macroblock *top_mb;
-    VP8Macroblock *left_mb = &mb[-1];
+    const VP8Macroblock *top_mb;
+    const VP8Macroblock *left_mb = &mb[-1];
     const uint8_t *mbsplits_left = vp8_mbsplits[left_mb->partitioning];
     const uint8_t *mbsplits_top, *mbsplits_cur, *firstidx;
-    VP56mv *top_mv;
-    VP56mv *left_mv = left_mb->bmv;
-    VP56mv *cur_mv  = mb->bmv;
+    const VP8mv *top_mv;
+    const VP8mv *left_mv = left_mb->bmv;
+    const VP8mv *cur_mv  = mb->bmv;
 
     if (!layout) // layout is inlined, s->mb_layout is not
         top_mb = &mb[2];
@@ -934,9 +965,9 @@
     mbsplits_top = vp8_mbsplits[top_mb->partitioning];
     top_mv       = top_mb->bmv;
 
-    if (vp56_rac_get_prob_branchy(c, vp8_mbsplit_prob[0])) {
-        if (vp56_rac_get_prob_branchy(c, vp8_mbsplit_prob[1]))
-            part_idx = VP8_SPLITMVMODE_16x8 + vp56_rac_get_prob(c, vp8_mbsplit_prob[2]);
+    if (vpx_rac_get_prob_branchy(c, vp8_mbsplit_prob[0])) {
+        if (vpx_rac_get_prob_branchy(c, vp8_mbsplit_prob[1]))
+            part_idx = VP8_SPLITMVMODE_16x8 + vpx_rac_get_prob(c, vp8_mbsplit_prob[2]);
         else
             part_idx = VP8_SPLITMVMODE_8x8;
     } else {
@@ -964,9 +995,9 @@
 
         submv_prob = get_submv_prob(left, above, is_vp7);
 
-        if (vp56_rac_get_prob_branchy(c, submv_prob[0])) {
-            if (vp56_rac_get_prob_branchy(c, submv_prob[1])) {
-                if (vp56_rac_get_prob_branchy(c, submv_prob[2])) {
+        if (vpx_rac_get_prob_branchy(c, submv_prob[0])) {
+            if (vpx_rac_get_prob_branchy(c, submv_prob[1])) {
+                if (vpx_rac_get_prob_branchy(c, submv_prob[2])) {
                     mb->bmv[n].y = mb->mv.y +
                                    read_mv_component(c, s->prob->mvc[0], is_vp7);
                     mb->bmv[n].x = mb->mv.x +
@@ -1009,7 +1040,7 @@
     return 1;
 }
 
-static const VP56mv *get_bmv_ptr(const VP8Macroblock *mb, int subblock)
+static const VP8mv *get_bmv_ptr(const VP8Macroblock *mb, int subblock)
 {
     return &mb->bmv[mb->mode == VP8_MVMODE_SPLIT ? vp8_mbsplits[mb->partitioning][subblock] : 0];
 }
@@ -1018,13 +1049,12 @@
 void vp7_decode_mvs(VP8Context *s, VP8Macroblock *mb,
                     int mb_x, int mb_y, int layout)
 {
-    VP8Macroblock *mb_edge[12];
     enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR };
     enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };
     int idx = CNT_ZERO;
-    VP56mv near_mv[3];
+    VP8mv near_mv[3];
     uint8_t cnt[3] = { 0 };
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i;
 
     AV_ZERO32(&near_mv[0]);
@@ -1037,11 +1067,11 @@
 
         if (vp7_calculate_mb_offset(mb_x, mb_y, s->mb_width, pred->xoffset,
                                     pred->yoffset, !s->profile, &edge_x, &edge_y)) {
-            VP8Macroblock *edge = mb_edge[i] = (s->mb_layout == 1)
-                                             ? s->macroblocks_base + 1 + edge_x +
-                                               (s->mb_width + 1) * (edge_y + 1)
-                                             : s->macroblocks + edge_x +
-                                               (s->mb_height - edge_y - 1) * 2;
+            const VP8Macroblock *edge = (s->mb_layout == 1)
+                                      ? s->macroblocks_base + 1 + edge_x +
+                                        (s->mb_width + 1) * (edge_y + 1)
+                                      : s->macroblocks + edge_x +
+                                        (s->mb_height - edge_y - 1) * 2;
             uint32_t mv = AV_RN32A(get_bmv_ptr(edge, vp7_mv_pred[i].subblock));
             if (mv) {
                 if (AV_RN32A(&near_mv[CNT_NEAREST])) {
@@ -1070,19 +1100,19 @@
 
     mb->partitioning = VP8_SPLITMVMODE_NONE;
 
-    if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_ZERO]][0])) {
+    if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_ZERO]][0])) {
         mb->mode = VP8_MVMODE_MV;
 
-        if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAREST]][1])) {
+        if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAREST]][1])) {
 
-            if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][2])) {
+            if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][2])) {
 
                 if (cnt[CNT_NEAREST] > cnt[CNT_NEAR])
                     AV_WN32A(&mb->mv, cnt[CNT_ZERO] > cnt[CNT_NEAREST] ? 0 : AV_RN32A(&near_mv[CNT_NEAREST]));
                 else
                     AV_WN32A(&mb->mv, cnt[CNT_ZERO] > cnt[CNT_NEAR]    ? 0 : AV_RN32A(&near_mv[CNT_NEAR]));
 
-                if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][3])) {
+                if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][3])) {
                     mb->mode = VP8_MVMODE_SPLIT;
                     mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP7) - 1];
                 } else {
@@ -1106,7 +1136,7 @@
 }
 
 static av_always_inline
-void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
+void vp8_decode_mvs(VP8Context *s, const VP8mvbounds *mv_bounds, VP8Macroblock *mb,
                     int mb_x, int mb_y, int layout)
 {
     VP8Macroblock *mb_edge[3] = { 0      /* top */,
@@ -1116,10 +1146,10 @@
     enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };
     int idx = CNT_ZERO;
     int cur_sign_bias = s->sign_bias[mb->ref_frame];
-    int8_t *sign_bias = s->sign_bias;
-    VP56mv near_mv[4];
+    const int8_t *sign_bias = s->sign_bias;
+    VP8mv near_mv[4];
     uint8_t cnt[4] = { 0 };
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
     if (!layout) { // layout is inlined (s->mb_layout is not)
         mb_edge[0] = mb + 2;
@@ -1136,9 +1166,9 @@
     /* Process MB on top, left and top-left */
 #define MV_EDGE_CHECK(n)                                                      \
     {                                                                         \
-        VP8Macroblock *edge = mb_edge[n];                                     \
+        const VP8Macroblock *edge = mb_edge[n];                               \
         int edge_ref = edge->ref_frame;                                       \
-        if (edge_ref != VP56_FRAME_CURRENT) {                                 \
+        if (edge_ref != VP8_FRAME_CURRENT) {                                 \
             uint32_t mv = AV_RN32A(&edge->mv);                                \
             if (mv) {                                                         \
                 if (cur_sign_bias != sign_bias[edge_ref]) {                   \
@@ -1160,7 +1190,7 @@
     MV_EDGE_CHECK(2)
 
     mb->partitioning = VP8_SPLITMVMODE_NONE;
-    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {
+    if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {
         mb->mode = VP8_MVMODE_MV;
 
         /* If we have three distinct MVs, merge first and last if they're the same */
@@ -1171,18 +1201,18 @@
         /* Swap near and nearest if necessary */
         if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {
             FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);
-            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);
+            FFSWAP(VP8mv,   near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);
         }
 
-        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {
-            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {
+        if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {
+            if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {
                 /* Choose the best mv out of 0,0 and the nearest mv */
                 clamp_mv(mv_bounds, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);
                 cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +
                                     (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +
                                     (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);
 
-                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {
+                if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {
                     mb->mode = VP8_MVMODE_SPLIT;
                     mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];
                 } else {
@@ -1206,7 +1236,7 @@
 }
 
 static av_always_inline
-void decode_intra4x4_modes(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
+void decode_intra4x4_modes(VP8Context *s, VPXRangeCoder *c, VP8Macroblock *mb,
                            int mb_x, int keyframe, int layout)
 {
     uint8_t *intra4x4 = mb->intra4x4_pred_mode_mb;
@@ -1227,7 +1257,7 @@
             for (x = 0; x < 4; x++) {
                 const uint8_t *ctx;
                 ctx       = vp8_pred4x4_prob_intra[top[x]][left[y]];
-                *intra4x4 = vp8_rac_get_tree(c, vp8_pred4x4_tree, ctx);
+                *intra4x4 = vp89_rac_get_tree(c, vp8_pred4x4_tree, ctx);
                 left[y]   = top[x] = *intra4x4;
                 intra4x4++;
             }
@@ -1235,17 +1265,17 @@
     } else {
         int i;
         for (i = 0; i < 16; i++)
-            intra4x4[i] = vp8_rac_get_tree(c, vp8_pred4x4_tree,
-                                           vp8_pred4x4_prob_inter);
+            intra4x4[i] = vp89_rac_get_tree(c, vp8_pred4x4_tree,
+                                            vp8_pred4x4_prob_inter);
     }
 }
 
 static av_always_inline
-void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
+void decode_mb_mode(VP8Context *s, const VP8mvbounds *mv_bounds,
                     VP8Macroblock *mb, int mb_x, int mb_y,
-                    uint8_t *segment, uint8_t *ref, int layout, int is_vp7)
+                    uint8_t *segment, const uint8_t *ref, int layout, int is_vp7)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     static const char * const vp7_feature_name[] = { "q-index",
                                                      "lf-delta",
                                                      "partial-golden-update",
@@ -1255,9 +1285,9 @@
         *segment = 0;
         for (i = 0; i < 4; i++) {
             if (s->feature_enabled[i]) {
-                if (vp56_rac_get_prob_branchy(c, s->feature_present_prob[i])) {
-                      int index = vp8_rac_get_tree(c, vp7_feature_index_tree,
-                                                   s->feature_index_prob[i]);
+                if (vpx_rac_get_prob_branchy(c, s->feature_present_prob[i])) {
+                      int index = vp89_rac_get_tree(c, vp7_feature_index_tree,
+                                                    s->feature_index_prob[i]);
                       av_log(s->avctx, AV_LOG_WARNING,
                              "Feature %s present in macroblock (value 0x%x)\n",
                              vp7_feature_name[i], s->feature_value[i][index]);
@@ -1265,17 +1295,17 @@
            }
         }
     } else if (s->segmentation.update_map) {
-        int bit  = vp56_rac_get_prob(c, s->prob->segmentid[0]);
-        *segment = vp56_rac_get_prob(c, s->prob->segmentid[1+bit]) + 2*bit;
+        int bit  = vpx_rac_get_prob(c, s->prob->segmentid[0]);
+        *segment = vpx_rac_get_prob(c, s->prob->segmentid[1+bit]) + 2*bit;
     } else if (s->segmentation.enabled)
         *segment = ref ? *ref : *segment;
     mb->segment = *segment;
 
-    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;
+    mb->skip = s->mbskip_enabled ? vpx_rac_get_prob(c, s->prob->mbskip) : 0;
 
     if (s->keyframe) {
-        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,
-                                    vp8_pred16x16_prob_intra);
+        mb->mode = vp89_rac_get_tree(c, vp8_pred16x16_tree_intra,
+                                     vp8_pred16x16_prob_intra);
 
         if (mb->mode == MODE_I4x4) {
             decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);
@@ -1289,17 +1319,17 @@
             AV_WN32A(s->intra4x4_pred_mode_left, modes);
         }
 
-        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,
-                                                vp8_pred8x8c_prob_intra);
-        mb->ref_frame        = VP56_FRAME_CURRENT;
-    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {
+        mb->chroma_pred_mode = vp89_rac_get_tree(c, vp8_pred8x8c_tree,
+                                                 vp8_pred8x8c_prob_intra);
+        mb->ref_frame        = VP8_FRAME_CURRENT;
+    } else if (vpx_rac_get_prob_branchy(c, s->prob->intra)) {
         // inter MB, 16.2
-        if (vp56_rac_get_prob_branchy(c, s->prob->last))
+        if (vpx_rac_get_prob_branchy(c, s->prob->last))
             mb->ref_frame =
-                (!is_vp7 && vp56_rac_get_prob(c, s->prob->golden)) ? VP56_FRAME_GOLDEN2 /* altref */
-                                                                   : VP56_FRAME_GOLDEN;
+                (!is_vp7 && vpx_rac_get_prob(c, s->prob->golden)) ? VP8_FRAME_ALTREF
+                                                                  : VP8_FRAME_GOLDEN;
         else
-            mb->ref_frame = VP56_FRAME_PREVIOUS;
+            mb->ref_frame = VP8_FRAME_PREVIOUS;
         s->ref_count[mb->ref_frame - 1]++;
 
         // motion vectors, 16.3
@@ -1309,14 +1339,15 @@
             vp8_decode_mvs(s, mv_bounds, mb, mb_x, mb_y, layout);
     } else {
         // intra MB, 16.1
-        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);
+        mb->mode = vp89_rac_get_tree(c, vp8_pred16x16_tree_inter,
+                                     s->prob->pred16x16);
 
         if (mb->mode == MODE_I4x4)
             decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);
 
-        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,
-                                                s->prob->pred8x8c);
-        mb->ref_frame        = VP56_FRAME_CURRENT;
+        mb->chroma_pred_mode = vp89_rac_get_tree(c, vp8_pred8x8c_tree,
+                                                 s->prob->pred8x8c);
+        mb->ref_frame        = VP8_FRAME_CURRENT;
         mb->partitioning     = VP8_SPLITMVMODE_NONE;
         AV_ZERO32(&mb->bmv[0]);
     }
@@ -1333,21 +1364,21 @@
  *         otherwise, the index of the last coeff decoded plus one
  */
 static av_always_inline
-int decode_block_coeffs_internal(VP56RangeCoder *r, int16_t block[16],
+int decode_block_coeffs_internal(VPXRangeCoder *r, int16_t block[16],
                                  uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                                 int i, uint8_t *token_prob, int16_t qmul[2],
+                                 int i, const uint8_t *token_prob, const int16_t qmul[2],
                                  const uint8_t scan[16], int vp7)
 {
-    VP56RangeCoder c = *r;
+    VPXRangeCoder c = *r;
     goto skip_eob;
     do {
         int coeff;
 restart:
-        if (!vp56_rac_get_prob_branchy(&c, token_prob[0]))   // DCT_EOB
+        if (!vpx_rac_get_prob_branchy(&c, token_prob[0]))   // DCT_EOB
             break;
 
 skip_eob:
-        if (!vp56_rac_get_prob_branchy(&c, token_prob[1])) { // DCT_0
+        if (!vpx_rac_get_prob_branchy(&c, token_prob[1])) { // DCT_0
             if (++i == 16)
                 break; // invalid input; blocks should end with EOB
             token_prob = probs[i][0];
@@ -1356,28 +1387,28 @@
             goto skip_eob;
         }
 
-        if (!vp56_rac_get_prob_branchy(&c, token_prob[2])) { // DCT_1
+        if (!vpx_rac_get_prob_branchy(&c, token_prob[2])) { // DCT_1
             coeff = 1;
             token_prob = probs[i + 1][1];
         } else {
-            if (!vp56_rac_get_prob_branchy(&c, token_prob[3])) { // DCT 2,3,4
-                coeff = vp56_rac_get_prob_branchy(&c, token_prob[4]);
+            if (!vpx_rac_get_prob_branchy(&c, token_prob[3])) { // DCT 2,3,4
+                coeff = vpx_rac_get_prob_branchy(&c, token_prob[4]);
                 if (coeff)
-                    coeff += vp56_rac_get_prob(&c, token_prob[5]);
+                    coeff += vpx_rac_get_prob(&c, token_prob[5]);
                 coeff += 2;
             } else {
                 // DCT_CAT*
-                if (!vp56_rac_get_prob_branchy(&c, token_prob[6])) {
-                    if (!vp56_rac_get_prob_branchy(&c, token_prob[7])) { // DCT_CAT1
-                        coeff = 5 + vp56_rac_get_prob(&c, vp8_dct_cat1_prob[0]);
+                if (!vpx_rac_get_prob_branchy(&c, token_prob[6])) {
+                    if (!vpx_rac_get_prob_branchy(&c, token_prob[7])) { // DCT_CAT1
+                        coeff = 5 + vpx_rac_get_prob(&c, vp8_dct_cat1_prob[0]);
                     } else {                                    // DCT_CAT2
                         coeff  = 7;
-                        coeff += vp56_rac_get_prob(&c, vp8_dct_cat2_prob[0]) << 1;
-                        coeff += vp56_rac_get_prob(&c, vp8_dct_cat2_prob[1]);
+                        coeff += vpx_rac_get_prob(&c, vp8_dct_cat2_prob[0]) << 1;
+                        coeff += vpx_rac_get_prob(&c, vp8_dct_cat2_prob[1]);
                     }
                 } else {    // DCT_CAT3 and up
-                    int a   = vp56_rac_get_prob(&c, token_prob[8]);
-                    int b   = vp56_rac_get_prob(&c, token_prob[9 + a]);
+                    int a   = vpx_rac_get_prob(&c, token_prob[8]);
+                    int b   = vpx_rac_get_prob(&c, token_prob[9 + a]);
                     int cat = (a << 1) + b;
                     coeff  = 3 + (8 << cat);
                     coeff += vp8_rac_get_coeff(&c, ff_vp8_dct_cat_prob[cat]);
@@ -1385,7 +1416,7 @@
             }
             token_prob = probs[i + 1][2];
         }
-        block[scan[i]] = (vp8_rac_get(&c) ? -coeff : coeff) * qmul[!!i];
+        block[scan[i]] = (vp89_rac_get(&c) ? -coeff : coeff) * qmul[!!i];
     } while (++i < 16);
 
     *r = c;
@@ -1415,11 +1446,11 @@
     return ret;
 }
 
-static int vp7_decode_block_coeffs_internal(VP56RangeCoder *r,
+static int vp7_decode_block_coeffs_internal(VPXRangeCoder *r,
                                             int16_t block[16],
                                             uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                                            int i, uint8_t *token_prob,
-                                            int16_t qmul[2],
+                                            int i, const uint8_t *token_prob,
+                                            const int16_t qmul[2],
                                             const uint8_t scan[16])
 {
     return decode_block_coeffs_internal(r, block, probs, i,
@@ -1427,11 +1458,11 @@
 }
 
 #ifndef vp8_decode_block_coeffs_internal
-static int vp8_decode_block_coeffs_internal(VP56RangeCoder *r,
+static int vp8_decode_block_coeffs_internal(VPXRangeCoder *r,
                                             int16_t block[16],
                                             uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                                            int i, uint8_t *token_prob,
-                                            int16_t qmul[2])
+                                            int i, const uint8_t *token_prob,
+                                            const int16_t qmul[2])
 {
     return decode_block_coeffs_internal(r, block, probs, i,
                                         token_prob, qmul, ff_zigzag_scan, IS_VP8);
@@ -1452,13 +1483,13 @@
  *         otherwise, the index of the last coeff decoded plus one
  */
 static av_always_inline
-int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
+int decode_block_coeffs(VPXRangeCoder *c, int16_t block[16],
                         uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
-                        int i, int zero_nhood, int16_t qmul[2],
+                        int i, int zero_nhood, const int16_t qmul[2],
                         const uint8_t scan[16], int vp7)
 {
-    uint8_t *token_prob = probs[i][zero_nhood];
-    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
+    const uint8_t *token_prob = probs[i][zero_nhood];
+    if (!vpx_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
         return 0;
     return vp7 ? vp7_decode_block_coeffs_internal(c, block, probs, i,
                                                   token_prob, qmul, scan)
@@ -1467,7 +1498,7 @@
 }
 
 static av_always_inline
-void decode_mb_coeffs(VP8Context *s, VP8ThreadData *td, VP56RangeCoder *c,
+void decode_mb_coeffs(VP8Context *s, VP8ThreadData *td, VPXRangeCoder *c,
                       VP8Macroblock *mb, uint8_t t_nnz[9], uint8_t l_nnz[9],
                       int is_vp7)
 {
@@ -1542,8 +1573,8 @@
 }
 
 static av_always_inline
-void backup_mb_border(uint8_t *top_border, uint8_t *src_y,
-                      uint8_t *src_cb, uint8_t *src_cr,
+void backup_mb_border(uint8_t *top_border, const uint8_t *src_y,
+                      const uint8_t *src_cb, const uint8_t *src_cr,
                       ptrdiff_t linesize, ptrdiff_t uvlinesize, int simple)
 {
     AV_COPY128(top_border, src_y + 15 * linesize);
@@ -1668,7 +1699,7 @@
 }
 
 static av_always_inline
-void intra_predict(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
+void intra_predict(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
                    VP8Macroblock *mb, int mb_x, int mb_y, int is_vp7)
 {
     int x, y, mode, nnz;
@@ -1686,14 +1717,14 @@
         s->hpc.pred16x16[mode](dst[0], s->linesize);
     } else {
         uint8_t *ptr = dst[0];
-        uint8_t *intra4x4 = mb->intra4x4_pred_mode_mb;
+        const uint8_t *intra4x4 = mb->intra4x4_pred_mode_mb;
         const uint8_t lo = is_vp7 ? 128 : 127;
         const uint8_t hi = is_vp7 ? 128 : 129;
-        uint8_t tr_top[4] = { lo, lo, lo, lo };
+        const uint8_t tr_top[4] = { lo, lo, lo, lo };
 
         // all blocks on the right edge of the macroblock use bottom edge
         // the top macroblock for their topright edge
-        uint8_t *tr_right = ptr - s->linesize + 16;
+        const uint8_t *tr_right = ptr - s->linesize + 16;
 
         // if we're on the right edge of the frame, said edge is extended
         // from the top macroblock
@@ -1706,7 +1737,7 @@
             AV_ZERO128(td->non_zero_count_cache);
 
         for (y = 0; y < 4; y++) {
-            uint8_t *topright = ptr + 4 - s->linesize;
+            const uint8_t *topright = ptr + 4 - s->linesize;
             for (x = 0; x < 4; x++) {
                 int copy = 0;
                 ptrdiff_t linesize = s->linesize;
@@ -1807,12 +1838,12 @@
  */
 static av_always_inline
 void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,
-                 ThreadFrame *ref, const VP56mv *mv,
+                 const ThreadFrame *ref, const VP8mv *mv,
                  int x_off, int y_off, int block_w, int block_h,
                  int width, int height, ptrdiff_t linesize,
                  vp8_mc_func mc_func[3][3])
 {
-    uint8_t *src = ref->f->data[0];
+    const uint8_t *src = ref->f->data[0];
 
     if (AV_RN32A(mv)) {
         ptrdiff_t src_linesize = linesize;
@@ -1865,12 +1896,12 @@
  */
 static av_always_inline
 void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1,
-                   uint8_t *dst2, ThreadFrame *ref, const VP56mv *mv,
+                   uint8_t *dst2, const ThreadFrame *ref, const VP8mv *mv,
                    int x_off, int y_off, int block_w, int block_h,
                    int width, int height, ptrdiff_t linesize,
                    vp8_mc_func mc_func[3][3])
 {
-    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];
+    const uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];
 
     if (AV_RN32A(mv)) {
         int mx = mv->x & 7, mx_idx = subpel_idx[0][mx];
@@ -1914,12 +1945,12 @@
 }
 
 static av_always_inline
-void vp8_mc_part(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
-                 ThreadFrame *ref_frame, int x_off, int y_off,
+void vp8_mc_part(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
+                 const ThreadFrame *ref_frame, int x_off, int y_off,
                  int bx_off, int by_off, int block_w, int block_h,
-                 int width, int height, VP56mv *mv)
+                 int width, int height, const VP8mv *mv)
 {
-    VP56mv uvmv = *mv;
+    VP8mv uvmv = *mv;
 
     /* Y */
     vp8_mc_luma(s, td, dst[0] + by_off * s->linesize + bx_off,
@@ -1952,8 +1983,8 @@
 /* Fetch pixels for estimated mv 4 macroblocks ahead.
  * Optimized for 64-byte cache lines. Inspired by ffh264 prefetch_motion. */
 static av_always_inline
-void prefetch_motion(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,
-                     int mb_xy, int ref)
+void prefetch_motion(const VP8Context *s, const VP8Macroblock *mb,
+                     int mb_x, int mb_y, int mb_xy, int ref)
 {
     /* Don't prefetch refs that haven't been used very often this frame. */
     if (s->ref_count[ref - 1] > (mb_xy >> 5)) {
@@ -1975,13 +2006,13 @@
  * Apply motion vectors to prediction buffer, chapter 18.
  */
 static av_always_inline
-void inter_predict(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
+void inter_predict(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
                    VP8Macroblock *mb, int mb_x, int mb_y)
 {
     int x_off = mb_x << 4, y_off = mb_y << 4;
     int width = 16 * s->mb_width, height = 16 * s->mb_height;
-    ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
-    VP56mv *bmv = mb->bmv;
+    const ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
+    const VP8mv *bmv = mb->bmv;
 
     switch (mb->partitioning) {
     case VP8_SPLITMVMODE_NONE:
@@ -1990,7 +2021,7 @@
         break;
     case VP8_SPLITMVMODE_4x4: {
         int x, y;
-        VP56mv uvmv;
+        VP8mv uvmv;
 
         /* Y */
         for (y = 0; y < 4; y++) {
@@ -2059,7 +2090,8 @@
 }
 
 static av_always_inline
-void idct_mb(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3], VP8Macroblock *mb)
+void idct_mb(VP8Context *s, VP8ThreadData *td, uint8_t *const dst[3],
+             const VP8Macroblock *mb)
 {
     int x, y, ch;
 
@@ -2121,7 +2153,7 @@
 }
 
 static av_always_inline
-void filter_level_for_mb(VP8Context *s, VP8Macroblock *mb,
+void filter_level_for_mb(const VP8Context *s, const VP8Macroblock *mb,
                          VP8FilterStrength *f, int is_vp7)
 {
     int interior_limit, filter_level;
@@ -2154,7 +2186,7 @@
 }
 
 static av_always_inline
-void filter_mb(VP8Context *s, uint8_t *dst[3], VP8FilterStrength *f,
+void filter_mb(const VP8Context *s, uint8_t *const dst[3], const VP8FilterStrength *f,
                int mb_x, int mb_y, int is_vp7)
 {
     int mbedge_lim, bedge_lim_y, bedge_lim_uv, hev_thresh;
@@ -2241,7 +2273,7 @@
 }
 
 static av_always_inline
-void filter_mb_simple(VP8Context *s, uint8_t *dst, VP8FilterStrength *f,
+void filter_mb_simple(const VP8Context *s, uint8_t *dst, const VP8FilterStrength *f,
                       int mb_x, int mb_y)
 {
     int mbedge_lim, bedge_lim;
@@ -2276,7 +2308,7 @@
 #define MARGIN (16 << 2)
 static av_always_inline
 int vp78_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *curframe,
-                                    VP8Frame *prev_frame, int is_vp7)
+                            const VP8Frame *prev_frame, int is_vp7)
 {
     VP8Context *s = avctx->priv_data;
     int mb_x, mb_y;
@@ -2294,7 +2326,7 @@
         s->mv_bounds.mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;
 
         for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {
-            if (vpX_rac_is_end(&s->c)) {
+            if (vpx_rac_is_end(&s->c)) {
                 return AVERROR_INVALIDDATA;
             }
             if (mb_y == 0)
@@ -2313,13 +2345,13 @@
 }
 
 static int vp7_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *cur_frame,
-                                   VP8Frame *prev_frame)
+                                  const VP8Frame *prev_frame)
 {
     return vp78_decode_mv_mb_modes(avctx, cur_frame, prev_frame, IS_VP7);
 }
 
 static int vp8_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *cur_frame,
-                                   VP8Frame *prev_frame)
+                                  const VP8Frame *prev_frame)
 {
     return vp78_decode_mv_mb_modes(avctx, cur_frame, prev_frame, IS_VP8);
 }
@@ -2370,8 +2402,10 @@
     int mb_y = atomic_load(&td->thread_mb_pos) >> 16;
     int mb_x, mb_xy = mb_y * s->mb_width;
     int num_jobs = s->num_jobs;
-    VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame;
-    VP56RangeCoder *c  = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)];
+    const VP8Frame *prev_frame = s->prev_frame;
+    VP8Frame *curframe = s->curframe;
+    VPXRangeCoder *coeff_c  = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)];
+
     VP8Macroblock *mb;
     uint8_t *dst[3] = {
         curframe->tf.f->data[0] + 16 * mb_y * s->linesize,
@@ -2379,7 +2413,7 @@
         curframe->tf.f->data[2] +  8 * mb_y * s->uvlinesize
     };
 
-    if (vpX_rac_is_end(c))
+    if (vpx_rac_is_end(&s->c))
          return AVERROR_INVALIDDATA;
 
     if (mb_y == 0)
@@ -2410,7 +2444,7 @@
     td->mv_bounds.mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;
 
     for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {
-        if (vpX_rac_is_end(c))
+        if (vpx_rac_is_end(&s->c))
             return AVERROR_INVALIDDATA;
         // Wait for previous thread to read mb_x+2, and reach mb_y-1.
         if (prev_td != td) {
@@ -2435,17 +2469,20 @@
                            prev_frame && prev_frame->seg_map ?
                            prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7);
 
-        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);
+        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_PREVIOUS);
 
-        if (!mb->skip)
-            decode_mb_coeffs(s, td, c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7);
+        if (!mb->skip) {
+            if (vpx_rac_is_end(coeff_c))
+                return AVERROR_INVALIDDATA;
+            decode_mb_coeffs(s, td, coeff_c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7);
+        }
 
         if (mb->mode <= MODE_I4x4)
             intra_predict(s, td, dst, mb, mb_x, mb_y, is_vp7);
         else
             inter_predict(s, td, dst, mb, mb_x, mb_y);
 
-        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);
+        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_GOLDEN);
 
         if (!mb->skip) {
             idct_mb(s, td, dst, mb);
@@ -2473,7 +2510,7 @@
                                  dst[1], dst[2], s->linesize, s->uvlinesize, 0);
         }
 
-        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);
+        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_ALTREF);
 
         dst[0]      += 16;
         dst[1]      += 8;
@@ -2532,7 +2569,7 @@
         next_td = &s->thread_data[(jobnr + 1) % num_jobs];
 
     for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb++) {
-        VP8FilterStrength *f = &td->filter_strength[mb_x];
+        const VP8FilterStrength *f = &td->filter_strength[mb_x];
         if (prev_td != td)
             check_thread_pos(td, prev_td,
                              (mb_x + 1) + (s->mb_width + 3), mb_y - 1);
@@ -2577,7 +2614,7 @@
 int vp78_decode_mb_row_sliced(AVCodecContext *avctx, void *tdata, int jobnr,
                               int threadnr, int is_vp7)
 {
-    VP8Context *s = avctx->priv_data;
+    const VP8Context *s = avctx->priv_data;
     VP8ThreadData *td = &s->thread_data[jobnr];
     VP8ThreadData *next_td = NULL, *prev_td = NULL;
     VP8Frame *curframe = s->curframe;
@@ -2621,7 +2658,7 @@
 }
 
 static av_always_inline
-int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
+int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
                       const AVPacket *avpkt, int is_vp7)
 {
     VP8Context *s = avctx->priv_data;
@@ -2648,10 +2685,10 @@
         avctx->pix_fmt = s->pix_fmt;
     }
 
-    prev_frame = s->framep[VP56_FRAME_CURRENT];
+    prev_frame = s->framep[VP8_FRAME_CURRENT];
 
-    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT ||
-                 s->update_altref == VP56_FRAME_CURRENT;
+    referenced = s->update_last || s->update_golden == VP8_FRAME_CURRENT ||
+                 s->update_altref == VP8_FRAME_CURRENT;
 
     skip_thresh = !referenced ? AVDISCARD_NONREF
                               : !s->keyframe ? AVDISCARD_NONKEY
@@ -2668,12 +2705,12 @@
     for (i = 0; i < 5; i++)
         if (s->frames[i].tf.f->buf[0] &&
             &s->frames[i] != prev_frame &&
-            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])
+            &s->frames[i] != s->framep[VP8_FRAME_PREVIOUS] &&
+            &s->frames[i] != s->framep[VP8_FRAME_GOLDEN]   &&
+            &s->frames[i] != s->framep[VP8_FRAME_ALTREF])
             vp8_release_frame(s, &s->frames[i]);
 
-    curframe = s->framep[VP56_FRAME_CURRENT] = vp8_find_free_buffer(s);
+    curframe = s->framep[VP8_FRAME_CURRENT] = vp8_find_free_buffer(s);
 
     if (!s->colorspace)
         avctx->colorspace = AVCOL_SPC_BT470BG;
@@ -2686,9 +2723,9 @@
      * likely that the values we have on a random interframe are complete
      * junk if we didn't start decode on a keyframe. So just don't display
      * anything rather than junk. */
-    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||
-                         !s->framep[VP56_FRAME_GOLDEN]   ||
-                         !s->framep[VP56_FRAME_GOLDEN2])) {
+    if (!s->keyframe && (!s->framep[VP8_FRAME_PREVIOUS] ||
+                         !s->framep[VP8_FRAME_GOLDEN]   ||
+                         !s->framep[VP8_FRAME_ALTREF])) {
         av_log(avctx, AV_LOG_WARNING,
                "Discarding interframe without a prior keyframe!\n");
         ret = AVERROR_INVALIDDATA;
@@ -2702,24 +2739,24 @@
         goto err;
 
     // check if golden and altref are swapped
-    if (s->update_altref != VP56_FRAME_NONE)
-        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];
+    if (s->update_altref != VP8_FRAME_NONE)
+        s->next_framep[VP8_FRAME_ALTREF] = s->framep[s->update_altref];
     else
-        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2];
+        s->next_framep[VP8_FRAME_ALTREF] = s->framep[VP8_FRAME_ALTREF];
 
-    if (s->update_golden != VP56_FRAME_NONE)
-        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];
+    if (s->update_golden != VP8_FRAME_NONE)
+        s->next_framep[VP8_FRAME_GOLDEN] = s->framep[s->update_golden];
     else
-        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN];
+        s->next_framep[VP8_FRAME_GOLDEN] = s->framep[VP8_FRAME_GOLDEN];
 
     if (s->update_last)
-        s->next_framep[VP56_FRAME_PREVIOUS] = curframe;
+        s->next_framep[VP8_FRAME_PREVIOUS] = curframe;
     else
-        s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];
+        s->next_framep[VP8_FRAME_PREVIOUS] = s->framep[VP8_FRAME_PREVIOUS];
 
-    s->next_framep[VP56_FRAME_CURRENT] = curframe;
+    s->next_framep[VP8_FRAME_CURRENT] = curframe;
 
-    if (avctx->codec->update_thread_context)
+    if (ffcodec(avctx->codec)->update_thread_context)
         ff_thread_finish_setup(avctx);
 
     if (avctx->hwaccel) {
@@ -2796,7 +2833,7 @@
         s->prob[0] = s->prob[1];
 
     if (!s->invisible) {
-        if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)
+        if ((ret = av_frame_ref(rframe, curframe->tf.f)) < 0)
             return ret;
         *got_frame = 1;
     }
@@ -2807,17 +2844,17 @@
     return ret;
 }
 
-int ff_vp8_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
-                        AVPacket *avpkt)
+int ff_vp8_decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                        int *got_frame, AVPacket *avpkt)
 {
-    return vp78_decode_frame(avctx, data, got_frame, avpkt, IS_VP8);
+    return vp78_decode_frame(avctx, frame, got_frame, avpkt, IS_VP8);
 }
 
 #if CONFIG_VP7_DECODER
-static int vp7_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
-                            AVPacket *avpkt)
+static int vp7_decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                            int *got_frame, AVPacket *avpkt)
 {
-    return vp78_decode_frame(avctx, data, got_frame, avpkt, IS_VP7);
+    return vp78_decode_frame(avctx, frame, got_frame, avpkt, IS_VP7);
 }
 #endif /* CONFIG_VP7_DECODER */
 
@@ -2826,9 +2863,6 @@
     VP8Context *s = avctx->priv_data;
     int i;
 
-    if (!s)
-        return 0;
-
     vp8_decode_flush_impl(avctx, 1);
     for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++)
         av_frame_free(&s->frames[i].tf.f);
@@ -2938,34 +2972,35 @@
 #endif /* CONFIG_VP8_DECODER */
 
 #if CONFIG_VP7_DECODER
-AVCodec ff_vp7_decoder = {
-    .name                  = "vp7",
-    .long_name             = NULL_IF_CONFIG_SMALL("On2 VP7"),
-    .type                  = AVMEDIA_TYPE_VIDEO,
-    .id                    = AV_CODEC_ID_VP7,
+const FFCodec ff_vp7_decoder = {
+    .p.name                = "vp7",
+    CODEC_LONG_NAME("On2 VP7"),
+    .p.type                = AVMEDIA_TYPE_VIDEO,
+    .p.id                  = AV_CODEC_ID_VP7,
     .priv_data_size        = sizeof(VP8Context),
     .init                  = vp7_decode_init,
     .close                 = ff_vp8_decode_free,
-    .decode                = vp7_decode_frame,
-    .capabilities          = AV_CODEC_CAP_DR1,
+    FF_CODEC_DECODE_CB(vp7_decode_frame),
+    .p.capabilities        = AV_CODEC_CAP_DR1,
     .flush                 = vp8_decode_flush,
 };
 #endif /* CONFIG_VP7_DECODER */
 
 #if CONFIG_VP8_DECODER
-AVCodec ff_vp8_decoder = {
-    .name                  = "vp8",
-    .long_name             = NULL_IF_CONFIG_SMALL("On2 VP8"),
-    .type                  = AVMEDIA_TYPE_VIDEO,
-    .id                    = AV_CODEC_ID_VP8,
+const FFCodec ff_vp8_decoder = {
+    .p.name                = "vp8",
+    CODEC_LONG_NAME("On2 VP8"),
+    .p.type                = AVMEDIA_TYPE_VIDEO,
+    .p.id                  = AV_CODEC_ID_VP8,
     .priv_data_size        = sizeof(VP8Context),
     .init                  = ff_vp8_decode_init,
     .close                 = ff_vp8_decode_free,
-    .decode                = ff_vp8_decode_frame,
-    .capabilities          = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
+    FF_CODEC_DECODE_CB(ff_vp8_decode_frame),
+    .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                              AV_CODEC_CAP_SLICE_THREADS,
+    .caps_internal         = FF_CODEC_CAP_ALLOCATE_PROGRESS,
     .flush                 = vp8_decode_flush,
-    .update_thread_context = ONLY_IF_THREADS_ENABLED(vp8_decode_update_thread_context),
+    UPDATE_THREAD_CONTEXT(vp8_decode_update_thread_context),
     .hw_configs            = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_VP8_VAAPI_HWACCEL
                                HWACCEL_VAAPI(vp8),
@@ -2975,6 +3010,5 @@
 #endif
                                NULL
                            },
-    .caps_internal         = FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
 #endif /* CONFIG_VP7_DECODER */
diff -Naur a/media/ffvpx/libavcodec/vp8dsp.c b/media/ffvpx/libavcodec/vp8dsp.c
--- a/media/ffvpx/libavcodec/vp8dsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp8dsp.c	2023-04-06 12:50:06.974471174 +0200
@@ -25,6 +25,8 @@
  * VP8 compatible video decoder
  */
 
+#include "config_components.h"
+
 #include "libavutil/common.h"
 #include "libavutil/intreadwrite.h"
 
@@ -466,7 +468,7 @@
 
 #define PUT_PIXELS(WIDTH)                                                     \
 static void put_vp8_pixels ## WIDTH ## _c(uint8_t *dst, ptrdiff_t dststride,  \
-                                          uint8_t *src, ptrdiff_t srcstride,  \
+                                          const uint8_t *src, ptrdiff_t srcstride, \
                                           int h, int x, int y)                \
 {                                                                             \
     int i;                                                                    \
@@ -490,7 +492,7 @@
 #define VP8_EPEL_H(SIZE, TAPS)                                                \
 static void put_vp8_epel ## SIZE ## _h ## TAPS ## _c(uint8_t *dst,            \
                                                      ptrdiff_t dststride,     \
-                                                     uint8_t *src,            \
+                                                     const uint8_t *src,      \
                                                      ptrdiff_t srcstride,     \
                                                      int h, int mx, int my)   \
 {                                                                             \
@@ -508,7 +510,7 @@
 #define VP8_EPEL_V(SIZE, TAPS)                                                \
 static void put_vp8_epel ## SIZE ## _v ## TAPS ## _c(uint8_t *dst,            \
                                                      ptrdiff_t dststride,     \
-                                                     uint8_t *src,            \
+                                                     const uint8_t *src,      \
                                                      ptrdiff_t srcstride,     \
                                                      int h, int mx, int my)   \
 {                                                                             \
@@ -527,7 +529,7 @@
 static void                                                                   \
 put_vp8_epel ## SIZE ## _h ## HTAPS ## v ## VTAPS ## _c(uint8_t *dst,         \
                                                         ptrdiff_t dststride,  \
-                                                        uint8_t *src,         \
+                                                        const uint8_t *src,   \
                                                         ptrdiff_t srcstride,  \
                                                         int h, int mx,        \
                                                         int my)               \
@@ -584,7 +586,7 @@
 
 #define VP8_BILINEAR(SIZE)                                                    \
 static void put_vp8_bilinear ## SIZE ## _h_c(uint8_t *dst, ptrdiff_t dstride, \
-                                             uint8_t *src, ptrdiff_t sstride, \
+                                             const uint8_t *src, ptrdiff_t sstride, \
                                              int h, int mx, int my)           \
 {                                                                             \
     int a = 8 - mx, b = mx;                                                   \
@@ -598,7 +600,7 @@
 }                                                                             \
                                                                               \
 static void put_vp8_bilinear ## SIZE ## _v_c(uint8_t *dst, ptrdiff_t dstride, \
-                                             uint8_t *src, ptrdiff_t sstride, \
+                                             const uint8_t *src, ptrdiff_t sstride, \
                                              int h, int mx, int my)           \
 {                                                                             \
     int c = 8 - my, d = my;                                                   \
@@ -613,7 +615,7 @@
                                                                               \
 static void put_vp8_bilinear ## SIZE ## _hv_c(uint8_t *dst,                   \
                                               ptrdiff_t dstride,              \
-                                              uint8_t *src,                   \
+                                              const uint8_t *src,             \
                                               ptrdiff_t sstride,              \
                                               int h, int mx, int my)          \
 {                                                                             \
@@ -673,14 +675,15 @@
     VP78_BILINEAR_MC_FUNC(1, 8);
     VP78_BILINEAR_MC_FUNC(2, 4);
 
-    if (ARCH_AARCH64)
-        ff_vp78dsp_init_aarch64(dsp);
-    if (ARCH_ARM)
-        ff_vp78dsp_init_arm(dsp);
-    if (ARCH_PPC)
-        ff_vp78dsp_init_ppc(dsp);
-    if (ARCH_X86)
-        ff_vp78dsp_init_x86(dsp);
+#if ARCH_AARCH64
+    ff_vp78dsp_init_aarch64(dsp);
+#elif ARCH_ARM
+    ff_vp78dsp_init_arm(dsp);
+#elif ARCH_PPC
+    ff_vp78dsp_init_ppc(dsp);
+#elif ARCH_X86
+    ff_vp78dsp_init_x86(dsp);
+#endif
 }
 
 #if CONFIG_VP7_DECODER
@@ -735,13 +738,16 @@
     dsp->vp8_v_loop_filter_simple = vp8_v_loop_filter_simple_c;
     dsp->vp8_h_loop_filter_simple = vp8_h_loop_filter_simple_c;
 
-    if (ARCH_AARCH64)
-        ff_vp8dsp_init_aarch64(dsp);
-    if (ARCH_ARM)
-        ff_vp8dsp_init_arm(dsp);
-    if (ARCH_X86)
-        ff_vp8dsp_init_x86(dsp);
-    if (ARCH_MIPS)
-        ff_vp8dsp_init_mips(dsp);
+#if ARCH_AARCH64
+    ff_vp8dsp_init_aarch64(dsp);
+#elif ARCH_ARM
+    ff_vp8dsp_init_arm(dsp);
+#elif ARCH_X86
+    ff_vp8dsp_init_x86(dsp);
+#elif ARCH_MIPS
+    ff_vp8dsp_init_mips(dsp);
+#elif ARCH_LOONGARCH
+    ff_vp8dsp_init_loongarch(dsp);
+#endif
 }
 #endif /* CONFIG_VP8_DECODER */
diff -Naur a/media/ffvpx/libavcodec/vp8dsp.h b/media/ffvpx/libavcodec/vp8dsp.h
--- a/media/ffvpx/libavcodec/vp8dsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp8dsp.h	2023-04-06 12:50:06.974471174 +0200
@@ -31,7 +31,7 @@
 #include <stdint.h>
 
 typedef void (*vp8_mc_func)(uint8_t *dst /* align 8 */, ptrdiff_t dstStride,
-                            uint8_t *src /* align 1 */, ptrdiff_t srcStride,
+                            const uint8_t *src /* align 1 */, ptrdiff_t srcStride,
                             int h, int x, int y);
 
 typedef struct VP8DSPContext {
@@ -81,13 +81,6 @@
     vp8_mc_func put_vp8_bilinear_pixels_tab[3][3][3];
 } VP8DSPContext;
 
-void ff_put_vp8_pixels16_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
-                           int h, int x, int y);
-void ff_put_vp8_pixels8_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
-                          int h, int x, int y);
-void ff_put_vp8_pixels4_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
-                          int h, int x, int y);
-
 void ff_vp7dsp_init(VP8DSPContext *c);
 
 void ff_vp78dsp_init(VP8DSPContext *c);
@@ -101,6 +94,7 @@
 void ff_vp8dsp_init_arm(VP8DSPContext *c);
 void ff_vp8dsp_init_x86(VP8DSPContext *c);
 void ff_vp8dsp_init_mips(VP8DSPContext *c);
+void ff_vp8dsp_init_loongarch(VP8DSPContext *c);
 
 #define IS_VP7 1
 #define IS_VP8 0
diff -Naur a/media/ffvpx/libavcodec/vp8.h b/media/ffvpx/libavcodec/vp8.h
--- a/media/ffvpx/libavcodec/vp8.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp8.h	2023-04-06 12:50:06.974471174 +0200
@@ -33,12 +33,21 @@
 #include "libavutil/thread.h"
 
 #include "h264pred.h"
-#include "thread.h"
-#include "vp56.h"
+#include "threadframe.h"
+#include "videodsp.h"
 #include "vp8dsp.h"
+#include "vpx_rac.h"
 
 #define VP8_MAX_QUANT 127
 
+typedef enum {
+    VP8_FRAME_NONE     = -1,
+    VP8_FRAME_CURRENT  =  0,
+    VP8_FRAME_PREVIOUS =  1,
+    VP8_FRAME_GOLDEN   =  2,
+    VP8_FRAME_ALTREF   =  3,
+} VP8FrameType;
+
 enum dct_token {
     DCT_0,
     DCT_1,
@@ -73,6 +82,11 @@
     VP8_SPLITMVMODE_NONE,        ///< (only used in prediction) no split MVs
 };
 
+typedef struct VP8mv {
+    DECLARE_ALIGNED(4, int16_t, x);
+    int16_t y;
+} VP8mv;
+
 typedef struct VP8FilterStrength {
     uint8_t filter_level;
     uint8_t inner_limit;
@@ -90,8 +104,8 @@
     uint8_t segment;
     uint8_t intra4x4_pred_mode_mb[16];
     DECLARE_ALIGNED(4, uint8_t, intra4x4_pred_mode_top)[4];
-    VP56mv mv;
-    VP56mv bmv[16];
+    VP8mv mv;
+    VP8mv bmv[16];
 } VP8Macroblock;
 
 typedef struct VP8intmv {
@@ -234,10 +248,10 @@
 
         /**
          * filter strength adjustment for macroblocks that reference:
-         * [0] - intra / VP56_FRAME_CURRENT
-         * [1] - VP56_FRAME_PREVIOUS
-         * [2] - VP56_FRAME_GOLDEN
-         * [3] - altref / VP56_FRAME_GOLDEN2
+         * [0] - intra / VP8_FRAME_CURRENT
+         * [1] - VP8_FRAME_PREVIOUS
+         * [2] - VP8_FRAME_GOLDEN
+         * [3] - altref / VP8_FRAME_ALTREF
          */
         int8_t ref[4];
     } lf_delta;
@@ -245,7 +259,7 @@
     uint8_t (*top_border)[16 + 8 + 8];
     uint8_t (*top_nnz)[9];
 
-    VP56RangeCoder c;   ///< header context, includes mb modes and motion vectors
+    VPXRangeCoder c;   ///< header context, includes mb modes and motion vectors
 
     /* This contains the entropy coder state at the end of the header
      * block, in the form specified by the standard.  For use by
@@ -282,8 +296,8 @@
 
     VP8Macroblock *macroblocks_base;
     int invisible;
-    int update_last;    ///< update VP56_FRAME_PREVIOUS with the current one
-    int update_golden;  ///< VP56_FRAME_NONE if not updated, or which frame to copy if so
+    int update_last;    ///< update VP8_FRAME_PREVIOUS with the current one
+    int update_golden;  ///< VP8_FRAME_NONE if not updated, or which frame to copy if so
     int update_altref;
 
     /**
@@ -297,7 +311,7 @@
      * There can be 1, 2, 4, or 8 of these after the header context.
      */
     int num_coeff_partitions;
-    VP56RangeCoder coeff_partition[8];
+    VPXRangeCoder coeff_partition[8];
     int coeff_partition_size[8];
     VideoDSPContext vdsp;
     VP8DSPContext vp8dsp;
@@ -322,14 +336,9 @@
     int vp7;
 
     /**
-     * Fade bit present in bitstream (VP7)
-     */
-    int fade_present;
-
-    /**
      * Interframe DC prediction (VP7)
-     * [0] VP56_FRAME_PREVIOUS
-     * [1] VP56_FRAME_GOLDEN
+     * [0] VP8_FRAME_PREVIOUS
+     * [1] VP8_FRAME_GOLDEN
      */
     uint16_t inter_dc_pred[2][2];
 
@@ -344,8 +353,8 @@
 
 int ff_vp8_decode_init(AVCodecContext *avctx);
 
-int ff_vp8_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
-                        AVPacket *avpkt);
+int ff_vp8_decode_frame(AVCodecContext *avctx, AVFrame *frame,
+                        int *got_frame, AVPacket *avpkt);
 
 int ff_vp8_decode_free(AVCodecContext *avctx);
 
diff -Naur a/media/ffvpx/libavcodec/vp8_parser.c b/media/ffvpx/libavcodec/vp8_parser.c
--- a/media/ffvpx/libavcodec/vp8_parser.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp8_parser.c	2023-04-06 12:49:40.256395011 +0200
@@ -73,7 +73,7 @@
     return buf_size;
 }
 
-AVCodecParser ff_vp8_parser = {
+const AVCodecParser ff_vp8_parser = {
     .codec_ids    = { AV_CODEC_ID_VP8 },
     .parser_parse = parse,
 };
diff -Naur a/media/ffvpx/libavcodec/vp9block.c b/media/ffvpx/libavcodec/vp9block.c
--- a/media/ffvpx/libavcodec/vp9block.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9block.c	2023-04-06 12:50:06.974471174 +0200
@@ -23,13 +23,12 @@
 
 #include "libavutil/avassert.h"
 
-#include "avcodec.h"
-#include "internal.h"
-#include "videodsp.h"
-#include "vp56.h"
+#include "threadframe.h"
+#include "vp89_rac.h"
 #include "vp9.h"
 #include "vp9data.h"
 #include "vp9dec.h"
+#include "vpx_rac.h"
 
 static av_always_inline void setctx_2d(uint8_t *ptr, int w, int h,
                                        ptrdiff_t stride, int v)
@@ -89,7 +88,7 @@
         TX_32X32, TX_32X32, TX_32X32, TX_32X32, TX_16X16, TX_16X16,
         TX_16X16, TX_8X8,   TX_8X8,   TX_8X8,   TX_4X4,   TX_4X4,  TX_4X4
     };
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col, row7 = td->row7;
     enum TxfmMode max_tx = max_tx_for_bl_bp[b->bs];
@@ -102,10 +101,11 @@
         b->seg_id = 0;
     } else if (s->s.h.keyframe || s->s.h.intraonly) {
         b->seg_id = !s->s.h.segmentation.update_map ? 0 :
-                    vp8_rac_get_tree(td->c, ff_vp9_segmentation_tree, s->s.h.segmentation.prob);
+                    vp89_rac_get_tree(td->c, ff_vp9_segmentation_tree,
+                                      s->s.h.segmentation.prob);
     } else if (!s->s.h.segmentation.update_map ||
                (s->s.h.segmentation.temporal &&
-                vp56_rac_get_prob_branchy(td->c,
+                vpx_rac_get_prob_branchy(td->c,
                     s->s.h.segmentation.pred_prob[s->above_segpred_ctx[col] +
                                     td->left_segpred_ctx[row7]]))) {
         if (!s->s.h.errorres && s->s.frames[REF_FRAME_SEGMAP].segmentation_map) {
@@ -128,8 +128,8 @@
         memset(&s->above_segpred_ctx[col], 1, w4);
         memset(&td->left_segpred_ctx[row7], 1, h4);
     } else {
-        b->seg_id = vp8_rac_get_tree(td->c, ff_vp9_segmentation_tree,
-                                     s->s.h.segmentation.prob);
+        b->seg_id = vp89_rac_get_tree(td->c, ff_vp9_segmentation_tree,
+                                      s->s.h.segmentation.prob);
 
         memset(&s->above_segpred_ctx[col], 0, w4);
         memset(&td->left_segpred_ctx[row7], 0, h4);
@@ -144,7 +144,7 @@
         s->s.h.segmentation.feat[b->seg_id].skip_enabled;
     if (!b->skip) {
         int c = td->left_skip_ctx[row7] + s->above_skip_ctx[col];
-        b->skip = vp56_rac_get_prob(td->c, s->prob.p.skip[c]);
+        b->skip = vpx_rac_get_prob(td->c, s->prob.p.skip[c]);
         td->counts.skip[c][b->skip]++;
     }
 
@@ -162,7 +162,7 @@
             c = have_a ? 2 * s->above_intra_ctx[col] :
                 have_l ? 2 * td->left_intra_ctx[row7] : 0;
         }
-        bit = vp56_rac_get_prob(td->c, s->prob.p.intra[c]);
+        bit = vpx_rac_get_prob(td->c, s->prob.p.intra[c]);
         td->counts.intra[c][bit]++;
         b->intra = !bit;
     }
@@ -187,22 +187,22 @@
         }
         switch (max_tx) {
         case TX_32X32:
-            b->tx = vp56_rac_get_prob(td->c, s->prob.p.tx32p[c][0]);
+            b->tx = vpx_rac_get_prob(td->c, s->prob.p.tx32p[c][0]);
             if (b->tx) {
-                b->tx += vp56_rac_get_prob(td->c, s->prob.p.tx32p[c][1]);
+                b->tx += vpx_rac_get_prob(td->c, s->prob.p.tx32p[c][1]);
                 if (b->tx == 2)
-                    b->tx += vp56_rac_get_prob(td->c, s->prob.p.tx32p[c][2]);
+                    b->tx += vpx_rac_get_prob(td->c, s->prob.p.tx32p[c][2]);
             }
             td->counts.tx32p[c][b->tx]++;
             break;
         case TX_16X16:
-            b->tx = vp56_rac_get_prob(td->c, s->prob.p.tx16p[c][0]);
+            b->tx = vpx_rac_get_prob(td->c, s->prob.p.tx16p[c][0]);
             if (b->tx)
-                b->tx += vp56_rac_get_prob(td->c, s->prob.p.tx16p[c][1]);
+                b->tx += vpx_rac_get_prob(td->c, s->prob.p.tx16p[c][1]);
             td->counts.tx16p[c][b->tx]++;
             break;
         case TX_8X8:
-            b->tx = vp56_rac_get_prob(td->c, s->prob.p.tx8p[c]);
+            b->tx = vpx_rac_get_prob(td->c, s->prob.p.tx8p[c]);
             td->counts.tx8p[c][b->tx]++;
             break;
         case TX_4X4:
@@ -223,11 +223,11 @@
             // necessary, they're just there to make the code slightly
             // simpler for now
             b->mode[0] =
-            a[0]       = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          ff_vp9_default_kf_ymode_probs[a[0]][l[0]]);
+            a[0]       = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           ff_vp9_default_kf_ymode_probs[a[0]][l[0]]);
             if (b->bs != BS_8x4) {
-                b->mode[1] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              ff_vp9_default_kf_ymode_probs[a[1]][b->mode[0]]);
+                b->mode[1] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               ff_vp9_default_kf_ymode_probs[a[1]][b->mode[0]]);
                 l[0]       =
                 a[1]       = b->mode[1];
             } else {
@@ -237,11 +237,11 @@
             }
             if (b->bs != BS_4x8) {
                 b->mode[2] =
-                a[0]       = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              ff_vp9_default_kf_ymode_probs[a[0]][l[1]]);
+                a[0]       = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               ff_vp9_default_kf_ymode_probs[a[0]][l[1]]);
                 if (b->bs != BS_8x4) {
-                    b->mode[3] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                                  ff_vp9_default_kf_ymode_probs[a[1]][b->mode[2]]);
+                    b->mode[3] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                                   ff_vp9_default_kf_ymode_probs[a[1]][b->mode[2]]);
                     l[1]       =
                     a[1]       = b->mode[3];
                 } else {
@@ -256,8 +256,8 @@
                 b->mode[3] = b->mode[1];
             }
         } else {
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          ff_vp9_default_kf_ymode_probs[*a][*l]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           ff_vp9_default_kf_ymode_probs[*a][*l]);
             b->mode[3] =
             b->mode[2] =
             b->mode[1] = b->mode[0];
@@ -265,28 +265,28 @@
             memset(a, b->mode[0], ff_vp9_bwh_tab[0][b->bs][0]);
             memset(l, b->mode[0], ff_vp9_bwh_tab[0][b->bs][1]);
         }
-        b->uvmode = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                     ff_vp9_default_kf_uvmode_probs[b->mode[3]]);
+        b->uvmode = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                      ff_vp9_default_kf_uvmode_probs[b->mode[3]]);
     } else if (b->intra) {
         b->comp = 0;
         if (b->bs > BS_8x8) {
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          s->prob.p.y_mode[0]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           s->prob.p.y_mode[0]);
             td->counts.y_mode[0][b->mode[0]]++;
             if (b->bs != BS_8x4) {
-                b->mode[1] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              s->prob.p.y_mode[0]);
+                b->mode[1] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               s->prob.p.y_mode[0]);
                 td->counts.y_mode[0][b->mode[1]]++;
             } else {
                 b->mode[1] = b->mode[0];
             }
             if (b->bs != BS_4x8) {
-                b->mode[2] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              s->prob.p.y_mode[0]);
+                b->mode[2] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               s->prob.p.y_mode[0]);
                 td->counts.y_mode[0][b->mode[2]]++;
                 if (b->bs != BS_8x4) {
-                    b->mode[3] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                                  s->prob.p.y_mode[0]);
+                    b->mode[3] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                                   s->prob.p.y_mode[0]);
                     td->counts.y_mode[0][b->mode[3]]++;
                 } else {
                     b->mode[3] = b->mode[2];
@@ -301,15 +301,15 @@
             };
             int sz = size_group[b->bs];
 
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          s->prob.p.y_mode[sz]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           s->prob.p.y_mode[sz]);
             b->mode[1] =
             b->mode[2] =
             b->mode[3] = b->mode[0];
             td->counts.y_mode[sz][b->mode[3]]++;
         }
-        b->uvmode = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                     s->prob.p.uv_mode[b->mode[3]]);
+        b->uvmode = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                      s->prob.p.uv_mode[b->mode[3]]);
         td->counts.uv_mode[b->mode[3]][b->uvmode]++;
     } else {
         static const uint8_t inter_mode_ctx_lut[14][14] = {
@@ -367,7 +367,7 @@
                 } else {
                     c = 1;
                 }
-                b->comp = vp56_rac_get_prob(td->c, s->prob.p.comp[c]);
+                b->comp = vpx_rac_get_prob(td->c, s->prob.p.comp[c]);
                 td->counts.comp[c][b->comp]++;
             }
 
@@ -439,7 +439,7 @@
                 } else {
                     c = 2;
                 }
-                bit = vp56_rac_get_prob(td->c, s->prob.p.comp_ref[c]);
+                bit = vpx_rac_get_prob(td->c, s->prob.p.comp_ref[c]);
                 b->ref[var_idx] = s->s.h.varcompref[bit];
                 td->counts.comp_ref[c][bit]++;
             } else /* single reference */ {
@@ -479,7 +479,7 @@
                 } else {
                     c = 2;
                 }
-                bit = vp56_rac_get_prob(td->c, s->prob.p.single_ref[c][0]);
+                bit = vpx_rac_get_prob(td->c, s->prob.p.single_ref[c][0]);
                 td->counts.single_ref[c][0][bit]++;
                 if (!bit) {
                     b->ref[0] = 0;
@@ -566,7 +566,7 @@
                     } else {
                         c = 2;
                     }
-                    bit = vp56_rac_get_prob(td->c, s->prob.p.single_ref[c][1]);
+                    bit = vpx_rac_get_prob(td->c, s->prob.p.single_ref[c][1]);
                     td->counts.single_ref[c][1][bit]++;
                     b->ref[0] = 1 + bit;
                 }
@@ -589,8 +589,8 @@
                 int c = inter_mode_ctx_lut[s->above_mode_ctx[col + off[b->bs]]]
                                           [td->left_mode_ctx[row7 + off[b->bs]]];
 
-                b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                              s->prob.p.mv_mode[c]);
+                b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                               s->prob.p.mv_mode[c]);
                 b->mode[1] =
                 b->mode[2] =
                 b->mode[3] = b->mode[0];
@@ -614,8 +614,8 @@
                 c = 3;
             }
 
-            filter_id = vp8_rac_get_tree(td->c, ff_vp9_filter_tree,
-                                         s->prob.p.filter[c]);
+            filter_id = vp89_rac_get_tree(td->c, ff_vp9_filter_tree,
+                                          s->prob.p.filter[c]);
             td->counts.filter[c][filter_id]++;
             b->filter = ff_vp9_filter_lut[filter_id];
         } else {
@@ -625,14 +625,14 @@
         if (b->bs > BS_8x8) {
             int c = inter_mode_ctx_lut[s->above_mode_ctx[col]][td->left_mode_ctx[row7]];
 
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                          s->prob.p.mv_mode[c]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                           s->prob.p.mv_mode[c]);
             td->counts.mv_mode[c][b->mode[0] - 10]++;
             ff_vp9_fill_mv(td, b->mv[0], b->mode[0], 0);
 
             if (b->bs != BS_8x4) {
-                b->mode[1] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                              s->prob.p.mv_mode[c]);
+                b->mode[1] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                               s->prob.p.mv_mode[c]);
                 td->counts.mv_mode[c][b->mode[1] - 10]++;
                 ff_vp9_fill_mv(td, b->mv[1], b->mode[1], 1);
             } else {
@@ -642,14 +642,14 @@
             }
 
             if (b->bs != BS_4x8) {
-                b->mode[2] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                              s->prob.p.mv_mode[c]);
+                b->mode[2] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                               s->prob.p.mv_mode[c]);
                 td->counts.mv_mode[c][b->mode[2] - 10]++;
                 ff_vp9_fill_mv(td, b->mv[2], b->mode[2], 2);
 
                 if (b->bs != BS_8x4) {
-                    b->mode[3] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                                  s->prob.p.mv_mode[c]);
+                    b->mode[3] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                                   s->prob.p.mv_mode[c]);
                     td->counts.mv_mode[c][b->mode[3] - 10]++;
                     ff_vp9_fill_mv(td, b->mv[3], b->mode[3], 3);
                 } else {
@@ -802,11 +802,11 @@
 
 // FIXME merge cnt/eob arguments?
 static av_always_inline int
-decode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs,
+decode_coeffs_b_generic(VPXRangeCoder *c, int16_t *coef, int n_coeffs,
                         int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3],
-                        unsigned (*eob)[6][2], uint8_t (*p)[6][11],
+                        unsigned (*eob)[6][2], const uint8_t (*p)[6][11],
                         int nnz, const int16_t *scan, const int16_t (*nb)[2],
-                        const int16_t *band_counts, int16_t *qmul)
+                        const int16_t *band_counts, const int16_t *qmul)
 {
     int i = 0, band = 0, band_left = band_counts[band];
     const uint8_t *tp = p[0][nnz];
@@ -815,13 +815,13 @@
     do {
         int val, rc;
 
-        val = vp56_rac_get_prob_branchy(c, tp[0]); // eob
+        val = vpx_rac_get_prob_branchy(c, tp[0]); // eob
         eob[band][nnz][val]++;
         if (!val)
             break;
 
 skip_eob:
-        if (!vp56_rac_get_prob_branchy(c, tp[1])) { // zero
+        if (!vpx_rac_get_prob_branchy(c, tp[1])) { // zero
             cnt[band][nnz][0]++;
             if (!--band_left)
                 band_left = band_counts[++band];
@@ -834,70 +834,70 @@
         }
 
         rc = scan[i];
-        if (!vp56_rac_get_prob_branchy(c, tp[2])) { // one
+        if (!vpx_rac_get_prob_branchy(c, tp[2])) { // one
             cnt[band][nnz][1]++;
             val       = 1;
             cache[rc] = 1;
         } else {
             cnt[band][nnz][2]++;
-            if (!vp56_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4
-                if (!vp56_rac_get_prob_branchy(c, tp[4])) {
+            if (!vpx_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4
+                if (!vpx_rac_get_prob_branchy(c, tp[4])) {
                     cache[rc] = val = 2;
                 } else {
-                    val       = 3 + vp56_rac_get_prob(c, tp[5]);
+                    val       = 3 + vpx_rac_get_prob(c, tp[5]);
                     cache[rc] = 3;
                 }
-            } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { // cat1/2
+            } else if (!vpx_rac_get_prob_branchy(c, tp[6])) { // cat1/2
                 cache[rc] = 4;
-                if (!vp56_rac_get_prob_branchy(c, tp[7])) {
-                    val  =  vp56_rac_get_prob(c, 159) + 5;
+                if (!vpx_rac_get_prob_branchy(c, tp[7])) {
+                    val  =  vpx_rac_get_prob(c, 159) + 5;
                 } else {
-                    val  = (vp56_rac_get_prob(c, 165) << 1) + 7;
-                    val +=  vp56_rac_get_prob(c, 145);
+                    val  = (vpx_rac_get_prob(c, 165) << 1) + 7;
+                    val +=  vpx_rac_get_prob(c, 145);
                 }
             } else { // cat 3-6
                 cache[rc] = 5;
-                if (!vp56_rac_get_prob_branchy(c, tp[8])) {
-                    if (!vp56_rac_get_prob_branchy(c, tp[9])) {
-                        val  = 11 + (vp56_rac_get_prob(c, 173) << 2);
-                        val +=      (vp56_rac_get_prob(c, 148) << 1);
-                        val +=       vp56_rac_get_prob(c, 140);
+                if (!vpx_rac_get_prob_branchy(c, tp[8])) {
+                    if (!vpx_rac_get_prob_branchy(c, tp[9])) {
+                        val  = 11 + (vpx_rac_get_prob(c, 173) << 2);
+                        val +=      (vpx_rac_get_prob(c, 148) << 1);
+                        val +=       vpx_rac_get_prob(c, 140);
                     } else {
-                        val  = 19 + (vp56_rac_get_prob(c, 176) << 3);
-                        val +=      (vp56_rac_get_prob(c, 155) << 2);
-                        val +=      (vp56_rac_get_prob(c, 140) << 1);
-                        val +=       vp56_rac_get_prob(c, 135);
+                        val  = 19 + (vpx_rac_get_prob(c, 176) << 3);
+                        val +=      (vpx_rac_get_prob(c, 155) << 2);
+                        val +=      (vpx_rac_get_prob(c, 140) << 1);
+                        val +=       vpx_rac_get_prob(c, 135);
                     }
-                } else if (!vp56_rac_get_prob_branchy(c, tp[10])) {
-                    val  = (vp56_rac_get_prob(c, 180) << 4) + 35;
-                    val += (vp56_rac_get_prob(c, 157) << 3);
-                    val += (vp56_rac_get_prob(c, 141) << 2);
-                    val += (vp56_rac_get_prob(c, 134) << 1);
-                    val +=  vp56_rac_get_prob(c, 130);
+                } else if (!vpx_rac_get_prob_branchy(c, tp[10])) {
+                    val  = (vpx_rac_get_prob(c, 180) << 4) + 35;
+                    val += (vpx_rac_get_prob(c, 157) << 3);
+                    val += (vpx_rac_get_prob(c, 141) << 2);
+                    val += (vpx_rac_get_prob(c, 134) << 1);
+                    val +=  vpx_rac_get_prob(c, 130);
                 } else {
                     val = 67;
                     if (!is8bitsperpixel) {
                         if (bpp == 12) {
-                            val += vp56_rac_get_prob(c, 255) << 17;
-                            val += vp56_rac_get_prob(c, 255) << 16;
+                            val += vpx_rac_get_prob(c, 255) << 17;
+                            val += vpx_rac_get_prob(c, 255) << 16;
                         }
-                        val +=  (vp56_rac_get_prob(c, 255) << 15);
-                        val +=  (vp56_rac_get_prob(c, 255) << 14);
+                        val +=  (vpx_rac_get_prob(c, 255) << 15);
+                        val +=  (vpx_rac_get_prob(c, 255) << 14);
                     }
-                    val += (vp56_rac_get_prob(c, 254) << 13);
-                    val += (vp56_rac_get_prob(c, 254) << 12);
-                    val += (vp56_rac_get_prob(c, 254) << 11);
-                    val += (vp56_rac_get_prob(c, 252) << 10);
-                    val += (vp56_rac_get_prob(c, 249) << 9);
-                    val += (vp56_rac_get_prob(c, 243) << 8);
-                    val += (vp56_rac_get_prob(c, 230) << 7);
-                    val += (vp56_rac_get_prob(c, 196) << 6);
-                    val += (vp56_rac_get_prob(c, 177) << 5);
-                    val += (vp56_rac_get_prob(c, 153) << 4);
-                    val += (vp56_rac_get_prob(c, 140) << 3);
-                    val += (vp56_rac_get_prob(c, 133) << 2);
-                    val += (vp56_rac_get_prob(c, 130) << 1);
-                    val +=  vp56_rac_get_prob(c, 129);
+                    val += (vpx_rac_get_prob(c, 254) << 13);
+                    val += (vpx_rac_get_prob(c, 254) << 12);
+                    val += (vpx_rac_get_prob(c, 254) << 11);
+                    val += (vpx_rac_get_prob(c, 252) << 10);
+                    val += (vpx_rac_get_prob(c, 249) << 9);
+                    val += (vpx_rac_get_prob(c, 243) << 8);
+                    val += (vpx_rac_get_prob(c, 230) << 7);
+                    val += (vpx_rac_get_prob(c, 196) << 6);
+                    val += (vpx_rac_get_prob(c, 177) << 5);
+                    val += (vpx_rac_get_prob(c, 153) << 4);
+                    val += (vpx_rac_get_prob(c, 140) << 3);
+                    val += (vpx_rac_get_prob(c, 133) << 2);
+                    val += (vpx_rac_get_prob(c, 130) << 1);
+                    val +=  vpx_rac_get_prob(c, 129);
                 }
             }
         }
@@ -911,9 +911,9 @@
         if (!--band_left)
             band_left = band_counts[++band];
         if (is_tx32x32)
-            STORE_COEF(coef, rc, (int)((vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2);
+            STORE_COEF(coef, rc, (int)((vp89_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2);
         else
-            STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]);
+            STORE_COEF(coef, rc, (vp89_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]);
         nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;
         tp = p[band][nnz];
     } while (++i < n_coeffs);
@@ -923,9 +923,9 @@
 
 static int decode_coeffs_b_8bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                 unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                 const int16_t (*nb)[2], const int16_t *band_counts,
-                                int16_t *qmul)
+                                const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 0, 1, 8, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -933,9 +933,9 @@
 
 static int decode_coeffs_b32_8bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                   unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                  uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                  const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                   const int16_t (*nb)[2], const int16_t *band_counts,
-                                  int16_t *qmul)
+                                  const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 1, 1, 8, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -943,9 +943,9 @@
 
 static int decode_coeffs_b_16bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                  unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                 uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                 const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                  const int16_t (*nb)[2], const int16_t *band_counts,
-                                 int16_t *qmul)
+                                 const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 0, 0, td->s->s.h.bpp, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -953,9 +953,9 @@
 
 static int decode_coeffs_b32_16bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                    unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                   uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                   const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                    const int16_t (*nb)[2], const int16_t *band_counts,
-                                   int16_t *qmul)
+                                   const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 1, 0, td->s->s.h.bpp, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -963,17 +963,17 @@
 
 static av_always_inline int decode_coeffs(VP9TileData *td, int is8bitsperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
-    uint8_t (*p)[6][11] = s->prob.coef[b->tx][0 /* y */][!b->intra];
+    const uint8_t (*p)[6][11] = s->prob.coef[b->tx][0 /* y */][!b->intra];
     unsigned (*c)[6][3] = td->counts.coef[b->tx][0 /* y */][!b->intra];
     unsigned (*e)[6][2] = td->counts.eob[b->tx][0 /* y */][!b->intra];
     int w4 = ff_vp9_bwh_tab[1][b->bs][0] << 1, h4 = ff_vp9_bwh_tab[1][b->bs][1] << 1;
     int end_x = FFMIN(2 * (s->cols - col), w4);
     int end_y = FFMIN(2 * (s->rows - row), h4);
     int n, pl, x, y, ret;
-    int16_t (*qmul)[2] = s->s.h.segmentation.feat[b->seg_id].qmul;
+    const int16_t (*qmul)[2] = s->s.h.segmentation.feat[b->seg_id].qmul;
     int tx = 4 * s->s.h.lossless + b->tx;
     const int16_t * const *yscans = ff_vp9_scans[tx];
     const int16_t (* const * ynbs)[2] = ff_vp9_scans_nb[tx];
@@ -1264,7 +1264,7 @@
                          VP9Filter *lflvl, ptrdiff_t yoff, ptrdiff_t uvoff,
                          enum BlockLevel bl, enum BlockPartition bp)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     enum BlockSize bs = bl * 3 + bp;
     int bytesperpixel = s->bytesperpixel;
diff -Naur a/media/ffvpx/libavcodec/vp9.c b/media/ffvpx/libavcodec/vp9.c
--- a/media/ffvpx/libavcodec/vp9.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9.c	2023-04-06 12:50:06.974471174 +0200
@@ -21,17 +21,24 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config_components.h"
+
 #include "avcodec.h"
+#include "codec_internal.h"
+#include "decode.h"
 #include "get_bits.h"
 #include "hwconfig.h"
-#include "internal.h"
 #include "profiles.h"
 #include "thread.h"
+#include "threadframe.h"
+#include "pthread_internal.h"
+
 #include "videodsp.h"
-#include "vp56.h"
+#include "vp89_rac.h"
 #include "vp9.h"
 #include "vp9data.h"
 #include "vp9dec.h"
+#include "vpx_rac.h"
 #include "libavutil/avassert.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/video_enc_params.h"
@@ -39,15 +46,9 @@
 #define VP9_SYNCCODE 0x498342
 
 #if HAVE_THREADS
-static void vp9_free_entries(AVCodecContext *avctx) {
-    VP9Context *s = avctx->priv_data;
-
-    if (avctx->active_thread_type & FF_THREAD_SLICE)  {
-        pthread_mutex_destroy(&s->progress_mutex);
-        pthread_cond_destroy(&s->progress_cond);
-        av_freep(&s->entries);
-    }
-}
+DEFINE_OFFSET_ARRAY(VP9Context, vp9_context, pthread_init_cnt,
+                    (offsetof(VP9Context, progress_mutex)),
+                    (offsetof(VP9Context, progress_cond)));
 
 static int vp9_alloc_entries(AVCodecContext *avctx, int n) {
     VP9Context *s = avctx->priv_data;
@@ -58,17 +59,11 @@
             av_freep(&s->entries);
 
         s->entries = av_malloc_array(n, sizeof(atomic_int));
-
-        if (!s->entries) {
-            av_freep(&s->entries);
+        if (!s->entries)
             return AVERROR(ENOMEM);
-        }
 
         for (i  = 0; i < n; i++)
             atomic_init(&s->entries[i], 0);
-
-        pthread_mutex_init(&s->progress_mutex, NULL);
-        pthread_cond_init(&s->progress_cond, NULL);
     }
     return 0;
 }
@@ -90,7 +85,6 @@
     pthread_mutex_unlock(&s->progress_mutex);
 }
 #else
-static void vp9_free_entries(AVCodecContext *avctx) {}
 static int vp9_alloc_entries(AVCodecContext *avctx, int n) { return 0; }
 #endif
 
@@ -103,7 +97,7 @@
 
 static void vp9_frame_unref(AVCodecContext *avctx, VP9Frame *f)
 {
-    ff_thread_release_buffer(avctx, &f->tf);
+    ff_thread_release_ext_buffer(avctx, &f->tf);
     av_buffer_unref(&f->extradata);
     av_buffer_unref(&f->hwaccel_priv_buf);
     f->segmentation_map = NULL;
@@ -115,7 +109,7 @@
     VP9Context *s = avctx->priv_data;
     int ret, sz;
 
-    ret = ff_thread_get_buffer(avctx, &f->tf, AV_GET_BUFFER_FLAG_REF);
+    ret = ff_thread_get_ext_buffer(avctx, &f->tf, AV_GET_BUFFER_FLAG_REF);
     if (ret < 0)
         return ret;
 
@@ -192,7 +186,8 @@
                      CONFIG_VP9_D3D11VA_HWACCEL * 2 + \
                      CONFIG_VP9_NVDEC_HWACCEL + \
                      CONFIG_VP9_VAAPI_HWACCEL + \
-                     CONFIG_VP9_VDPAU_HWACCEL)
+                     CONFIG_VP9_VDPAU_HWACCEL + \
+                     CONFIG_VP9_VIDEOTOOLBOX_HWACCEL)
     enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmtp = pix_fmts;
     VP9Context *s = avctx->priv_data;
     uint8_t *p;
@@ -224,6 +219,9 @@
 #if CONFIG_VP9_VDPAU_HWACCEL
             *fmtp++ = AV_PIX_FMT_VDPAU;
 #endif
+#if CONFIG_VP9_VIDEOTOOLBOX_HWACCEL
+            *fmtp++ = AV_PIX_FMT_VIDEOTOOLBOX;
+#endif
             break;
         case AV_PIX_FMT_YUV420P12:
 #if CONFIG_VP9_NVDEC_HWACCEL
@@ -236,6 +234,13 @@
             *fmtp++ = AV_PIX_FMT_VDPAU;
 #endif
             break;
+        case AV_PIX_FMT_YUV444P:
+        case AV_PIX_FMT_YUV444P10:
+        case AV_PIX_FMT_YUV444P12:
+#if CONFIG_VP9_VAAPI_HWACCEL
+            *fmtp++ = AV_PIX_FMT_VAAPI;
+#endif
+            break;
         }
 
         *fmtp++ = s->pix_fmt;
@@ -277,7 +282,7 @@
     assign(s->intra_pred_data[2],  uint8_t *,             64 * bytesperpixel);
     assign(s->above_y_nnz_ctx,     uint8_t *,             16);
     assign(s->above_mode_ctx,      uint8_t *,             16);
-    assign(s->above_mv_ctx,        VP56mv(*)[2],          16);
+    assign(s->above_mv_ctx,        VP9mv(*)[2],           16);
     assign(s->above_uv_nnz_ctx[0], uint8_t *,             16);
     assign(s->above_uv_nnz_ctx[1], uint8_t *,             16);
     assign(s->above_partition_ctx, uint8_t *,              8);
@@ -382,7 +387,7 @@
 }
 
 // differential forward probability updates
-static int update_prob(VP56RangeCoder *c, int p)
+static int update_prob(VPXRangeCoder *c, int p)
 {
     static const uint8_t inv_map_table[255] = {
           7,  20,  33,  46,  59,  72,  85,  98, 111, 124, 137, 150, 163, 176,
@@ -422,16 +427,16 @@
      * updates vs. the 'fine, exact' updates further down the range, which
      * adds one extra dimension to this differential update model. */
 
-    if (!vp8_rac_get(c)) {
-        d = vp8_rac_get_uint(c, 4) + 0;
-    } else if (!vp8_rac_get(c)) {
-        d = vp8_rac_get_uint(c, 4) + 16;
-    } else if (!vp8_rac_get(c)) {
-        d = vp8_rac_get_uint(c, 5) + 32;
+    if (!vp89_rac_get(c)) {
+        d = vp89_rac_get_uint(c, 4) + 0;
+    } else if (!vp89_rac_get(c)) {
+        d = vp89_rac_get_uint(c, 4) + 16;
+    } else if (!vp89_rac_get(c)) {
+        d = vp89_rac_get_uint(c, 5) + 32;
     } else {
-        d = vp8_rac_get_uint(c, 7);
+        d = vp89_rac_get_uint(c, 7);
         if (d >= 65)
-            d = (d << 1) - 65 + vp8_rac_get(c);
+            d = (d << 1) - 65 + vp89_rac_get(c);
         d += 64;
         av_assert2(d < FF_ARRAY_ELEMS(inv_map_table));
     }
@@ -787,16 +792,15 @@
     s->s.h.tiling.tile_rows = 1 << s->s.h.tiling.log2_tile_rows;
     if (s->s.h.tiling.tile_cols != (1 << s->s.h.tiling.log2_tile_cols)) {
         int n_range_coders;
-        VP56RangeCoder *rc;
+        VPXRangeCoder *rc;
 
         if (s->td) {
             for (i = 0; i < s->active_tile_cols; i++)
                 vp9_tile_data_free(&s->td[i]);
-            av_free(s->td);
+            av_freep(&s->td);
         }
 
         s->s.h.tiling.tile_cols = 1 << s->s.h.tiling.log2_tile_cols;
-        vp9_free_entries(avctx);
         s->active_tile_cols = avctx->active_thread_type == FF_THREAD_SLICE ?
                               s->s.h.tiling.tile_cols : 1;
         vp9_alloc_entries(avctx, s->sb_rows);
@@ -805,11 +809,11 @@
         } else {
             n_range_coders = s->s.h.tiling.tile_cols;
         }
-        s->td = av_mallocz_array(s->active_tile_cols, sizeof(VP9TileData) +
-                                 n_range_coders * sizeof(VP56RangeCoder));
+        s->td = av_calloc(s->active_tile_cols, sizeof(VP9TileData) +
+                                 n_range_coders * sizeof(VPXRangeCoder));
         if (!s->td)
             return AVERROR(ENOMEM);
-        rc = (VP56RangeCoder *) &s->td[s->active_tile_cols];
+        rc = (VPXRangeCoder *) &s->td[s->active_tile_cols];
         for (i = 0; i < s->active_tile_cols; i++) {
             s->td[i].s = s;
             s->td[i].c_b = rc;
@@ -881,11 +885,11 @@
         av_log(avctx, AV_LOG_ERROR, "Invalid compressed header size\n");
         return AVERROR_INVALIDDATA;
     }
-    ret = ff_vp56_init_range_decoder(&s->c, data2, size2);
+    ret = ff_vpx_init_range_decoder(&s->c, data2, size2);
     if (ret < 0)
         return ret;
 
-    if (vp56_rac_get_prob_branchy(&s->c, 128)) { // marker bit
+    if (vpx_rac_get_prob_branchy(&s->c, 128)) { // marker bit
         av_log(avctx, AV_LOG_ERROR, "Marker bit was set\n");
         return AVERROR_INVALIDDATA;
     }
@@ -909,22 +913,22 @@
     if (s->s.h.lossless) {
         s->s.h.txfmmode = TX_4X4;
     } else {
-        s->s.h.txfmmode = vp8_rac_get_uint(&s->c, 2);
+        s->s.h.txfmmode = vp89_rac_get_uint(&s->c, 2);
         if (s->s.h.txfmmode == 3)
-            s->s.h.txfmmode += vp8_rac_get(&s->c);
+            s->s.h.txfmmode += vp89_rac_get(&s->c);
 
         if (s->s.h.txfmmode == TX_SWITCHABLE) {
             for (i = 0; i < 2; i++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.tx8p[i] = update_prob(&s->c, s->prob.p.tx8p[i]);
             for (i = 0; i < 2; i++)
                 for (j = 0; j < 2; j++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.tx16p[i][j] =
                             update_prob(&s->c, s->prob.p.tx16p[i][j]);
             for (i = 0; i < 2; i++)
                 for (j = 0; j < 3; j++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.tx32p[i][j] =
                             update_prob(&s->c, s->prob.p.tx32p[i][j]);
         }
@@ -933,7 +937,7 @@
     // coef updates
     for (i = 0; i < 4; i++) {
         uint8_t (*ref)[2][6][6][3] = s->prob_ctx[c].coef[i];
-        if (vp8_rac_get(&s->c)) {
+        if (vp89_rac_get(&s->c)) {
             for (j = 0; j < 2; j++)
                 for (k = 0; k < 2; k++)
                     for (l = 0; l < 6; l++)
@@ -943,7 +947,7 @@
                             if (m >= 3 && l == 0) // dc only has 3 pt
                                 break;
                             for (n = 0; n < 3; n++) {
-                                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                                if (vpx_rac_get_prob_branchy(&s->c, 252))
                                     p[n] = update_prob(&s->c, r[n]);
                                 else
                                     p[n] = r[n];
@@ -969,33 +973,33 @@
 
     // mode updates
     for (i = 0; i < 3; i++)
-        if (vp56_rac_get_prob_branchy(&s->c, 252))
+        if (vpx_rac_get_prob_branchy(&s->c, 252))
             s->prob.p.skip[i] = update_prob(&s->c, s->prob.p.skip[i]);
     if (!s->s.h.keyframe && !s->s.h.intraonly) {
         for (i = 0; i < 7; i++)
             for (j = 0; j < 3; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_mode[i][j] =
                         update_prob(&s->c, s->prob.p.mv_mode[i][j]);
 
         if (s->s.h.filtermode == FILTER_SWITCHABLE)
             for (i = 0; i < 4; i++)
                 for (j = 0; j < 2; j++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.filter[i][j] =
                             update_prob(&s->c, s->prob.p.filter[i][j]);
 
         for (i = 0; i < 4; i++)
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
                 s->prob.p.intra[i] = update_prob(&s->c, s->prob.p.intra[i]);
 
         if (s->s.h.allowcompinter) {
-            s->s.h.comppredmode = vp8_rac_get(&s->c);
+            s->s.h.comppredmode = vp89_rac_get(&s->c);
             if (s->s.h.comppredmode)
-                s->s.h.comppredmode += vp8_rac_get(&s->c);
+                s->s.h.comppredmode += vp89_rac_get(&s->c);
             if (s->s.h.comppredmode == PRED_SWITCHABLE)
                 for (i = 0; i < 5; i++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.comp[i] =
                             update_prob(&s->c, s->prob.p.comp[i]);
         } else {
@@ -1004,10 +1008,10 @@
 
         if (s->s.h.comppredmode != PRED_COMPREF) {
             for (i = 0; i < 5; i++) {
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.single_ref[i][0] =
                         update_prob(&s->c, s->prob.p.single_ref[i][0]);
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.single_ref[i][1] =
                         update_prob(&s->c, s->prob.p.single_ref[i][1]);
             }
@@ -1015,72 +1019,72 @@
 
         if (s->s.h.comppredmode != PRED_SINGLEREF) {
             for (i = 0; i < 5; i++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.comp_ref[i] =
                         update_prob(&s->c, s->prob.p.comp_ref[i]);
         }
 
         for (i = 0; i < 4; i++)
             for (j = 0; j < 9; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.y_mode[i][j] =
                         update_prob(&s->c, s->prob.p.y_mode[i][j]);
 
         for (i = 0; i < 4; i++)
             for (j = 0; j < 4; j++)
                 for (k = 0; k < 3; k++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.partition[3 - i][j][k] =
                             update_prob(&s->c,
                                         s->prob.p.partition[3 - i][j][k]);
 
         // mv fields don't use the update_prob subexp model for some reason
         for (i = 0; i < 3; i++)
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
-                s->prob.p.mv_joint[i] = (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
+                s->prob.p.mv_joint[i] = (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
         for (i = 0; i < 2; i++) {
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
                 s->prob.p.mv_comp[i].sign =
-                    (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                    (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
             for (j = 0; j < 10; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].classes[j] =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
                 s->prob.p.mv_comp[i].class0 =
-                    (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                    (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
             for (j = 0; j < 10; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].bits[j] =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
         }
 
         for (i = 0; i < 2; i++) {
             for (j = 0; j < 2; j++)
                 for (k = 0; k < 3; k++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.mv_comp[i].class0_fp[j][k] =
-                            (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                            (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
             for (j = 0; j < 3; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].fp[j] =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
         }
 
         if (s->s.h.highprecisionmvs) {
             for (i = 0; i < 2; i++) {
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].class0_hp =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].hp =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
             }
         }
     }
@@ -1103,11 +1107,11 @@
     int bytesperpixel = s->bytesperpixel;
 
     if (bl == BL_8X8) {
-        bp = vp8_rac_get_tree(td->c, ff_vp9_partition_tree, p);
+        bp = vp89_rac_get_tree(td->c, ff_vp9_partition_tree, p);
         ff_vp9_decode_block(td, row, col, lflvl, yoff, uvoff, bl, bp);
     } else if (col + hbs < s->cols) { // FIXME why not <=?
         if (row + hbs < s->rows) { // FIXME why not <=?
-            bp = vp8_rac_get_tree(td->c, ff_vp9_partition_tree, p);
+            bp = vp89_rac_get_tree(td->c, ff_vp9_partition_tree, p);
             switch (bp) {
             case PARTITION_NONE:
                 ff_vp9_decode_block(td, row, col, lflvl, yoff, uvoff, bl, bp);
@@ -1139,7 +1143,7 @@
             default:
                 av_assert0(0);
             }
-        } else if (vp56_rac_get_prob_branchy(td->c, p[1])) {
+        } else if (vpx_rac_get_prob_branchy(td->c, p[1])) {
             bp = PARTITION_SPLIT;
             decode_sb(td, row, col, lflvl, yoff, uvoff, bl + 1);
             decode_sb(td, row, col + hbs, lflvl,
@@ -1150,7 +1154,7 @@
             ff_vp9_decode_block(td, row, col, lflvl, yoff, uvoff, bl, bp);
         }
     } else if (row + hbs < s->rows) { // FIXME why not <=?
-        if (vp56_rac_get_prob_branchy(td->c, p[2])) {
+        if (vpx_rac_get_prob_branchy(td->c, p[2])) {
             bp = PARTITION_SPLIT;
             decode_sb(td, row, col, lflvl, yoff, uvoff, bl + 1);
             yoff  += hbs * 8 * y_stride;
@@ -1244,14 +1248,17 @@
     }
     av_buffer_pool_uninit(&s->frame_extradata_pool);
     for (i = 0; i < 8; i++) {
-        ff_thread_release_buffer(avctx, &s->s.refs[i]);
+        ff_thread_release_ext_buffer(avctx, &s->s.refs[i]);
         av_frame_free(&s->s.refs[i].f);
-        ff_thread_release_buffer(avctx, &s->next_refs[i]);
+        ff_thread_release_ext_buffer(avctx, &s->next_refs[i]);
         av_frame_free(&s->next_refs[i].f);
     }
 
     free_buffers(s);
-    vp9_free_entries(avctx);
+#if HAVE_THREADS
+    av_freep(&s->entries);
+    ff_pthread_free(s, vp9_context_offsets);
+#endif
     av_freep(&s->td);
     return 0;
 }
@@ -1288,17 +1295,13 @@
                 data += 4;
                 size -= 4;
             }
-            if (tile_size > size) {
-                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);
+            if (tile_size > size)
                 return AVERROR_INVALIDDATA;
-            }
-            ret = ff_vp56_init_range_decoder(&td->c_b[tile_col], data, tile_size);
+            ret = ff_vpx_init_range_decoder(&td->c_b[tile_col], data, tile_size);
             if (ret < 0)
                 return ret;
-            if (vp56_rac_get_prob_branchy(&td->c_b[tile_col], 128)) { // marker bit
-                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);
+            if (vpx_rac_get_prob_branchy(&td->c_b[tile_col], 128)) // marker bit
                 return AVERROR_INVALIDDATA;
-            }
             data += tile_size;
             size -= tile_size;
         }
@@ -1341,7 +1344,7 @@
                         decode_sb_mem(td, row, col, lflvl_ptr,
                                       yoff2, uvoff2, BL_64X64);
                     } else {
-                        if (vpX_rac_is_end(td->c)) {
+                        if (vpx_rac_is_end(td->c)) {
                             return AVERROR_INVALIDDATA;
                         }
                         decode_sb(td, row, col, lflvl_ptr,
@@ -1551,7 +1554,7 @@
     return 0;
 }
 
-static int vp9_decode_frame(AVCodecContext *avctx, void *frame,
+static int vp9_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                             int *got_frame, AVPacket *pkt)
 {
     const uint8_t *data = pkt->data;
@@ -1571,16 +1574,11 @@
         }
         if ((ret = av_frame_ref(frame, s->s.refs[ref].f)) < 0)
             return ret;
-        ((AVFrame *)frame)->pts = pkt->pts;
-#if FF_API_PKT_PTS
-FF_DISABLE_DEPRECATION_WARNINGS
-        ((AVFrame *)frame)->pkt_pts = pkt->pts;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-        ((AVFrame *)frame)->pkt_dts = pkt->dts;
+        frame->pts     = pkt->pts;
+        frame->pkt_dts = pkt->dts;
         for (i = 0; i < 8; i++) {
             if (s->next_refs[i].f->buf[0])
-                ff_thread_release_buffer(avctx, &s->next_refs[i]);
+                ff_thread_release_ext_buffer(avctx, &s->next_refs[i]);
             if (s->s.refs[i].f->buf[0] &&
                 (ret = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)
                 return ret;
@@ -1620,7 +1618,7 @@
     // ref frame setup
     for (i = 0; i < 8; i++) {
         if (s->next_refs[i].f->buf[0])
-            ff_thread_release_buffer(avctx, &s->next_refs[i]);
+            ff_thread_release_ext_buffer(avctx, &s->next_refs[i]);
         if (s->s.h.refreshrefmask & (1 << i)) {
             ret = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);
         } else if (s->s.refs[i].f->buf[0]) {
@@ -1720,10 +1718,10 @@
                     }
                     if (tile_size > size)
                         return AVERROR_INVALIDDATA;
-                    ret = ff_vp56_init_range_decoder(&s->td[tile_col].c_b[tile_row], data, tile_size);
+                    ret = ff_vpx_init_range_decoder(&s->td[tile_col].c_b[tile_row], data, tile_size);
                     if (ret < 0)
                         return ret;
-                    if (vp56_rac_get_prob_branchy(&s->td[tile_col].c_b[tile_row], 128)) // marker bit
+                    if (vpx_rac_get_prob_branchy(&s->td[tile_col].c_b[tile_row], 128)) // marker bit
                         return AVERROR_INVALIDDATA;
                     data += tile_size;
                     size -= tile_size;
@@ -1769,7 +1767,7 @@
     // ref frame setup
     for (i = 0; i < 8; i++) {
         if (s->s.refs[i].f->buf[0])
-            ff_thread_release_buffer(avctx, &s->s.refs[i]);
+            ff_thread_release_ext_buffer(avctx, &s->s.refs[i]);
         if (s->next_refs[i].f->buf[0] &&
             (ret = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)
             return ret;
@@ -1792,45 +1790,39 @@
     for (i = 0; i < 3; i++)
         vp9_frame_unref(avctx, &s->s.frames[i]);
     for (i = 0; i < 8; i++)
-        ff_thread_release_buffer(avctx, &s->s.refs[i]);
+        ff_thread_release_ext_buffer(avctx, &s->s.refs[i]);
 }
 
-static int init_frames(AVCodecContext *avctx)
+static av_cold int vp9_decode_init(AVCodecContext *avctx)
 {
     VP9Context *s = avctx->priv_data;
-    int i;
+    int ret;
 
-    for (i = 0; i < 3; i++) {
+    s->last_bpp = 0;
+    s->s.h.filter.sharpness = -1;
+
+#if HAVE_THREADS
+    if (avctx->active_thread_type & FF_THREAD_SLICE) {
+        ret = ff_pthread_init(s, vp9_context_offsets);
+        if (ret < 0)
+            return ret;
+    }
+#endif
+
+    for (int i = 0; i < 3; i++) {
         s->s.frames[i].tf.f = av_frame_alloc();
-        if (!s->s.frames[i].tf.f) {
-            vp9_decode_free(avctx);
-            av_log(avctx, AV_LOG_ERROR, "Failed to allocate frame buffer %d\n", i);
+        if (!s->s.frames[i].tf.f)
             return AVERROR(ENOMEM);
-        }
     }
-    for (i = 0; i < 8; i++) {
-        s->s.refs[i].f = av_frame_alloc();
-        s->next_refs[i].f = av_frame_alloc();
-        if (!s->s.refs[i].f || !s->next_refs[i].f) {
-            vp9_decode_free(avctx);
-            av_log(avctx, AV_LOG_ERROR, "Failed to allocate frame buffer %d\n", i);
+    for (int i = 0; i < 8; i++) {
+        s->s.refs[i].f      = av_frame_alloc();
+        s->next_refs[i].f   = av_frame_alloc();
+        if (!s->s.refs[i].f || !s->next_refs[i].f)
             return AVERROR(ENOMEM);
-        }
     }
-
     return 0;
 }
 
-static av_cold int vp9_decode_init(AVCodecContext *avctx)
-{
-    VP9Context *s = avctx->priv_data;
-
-    s->last_bpp = 0;
-    s->s.h.filter.sharpness = -1;
-
-    return init_frames(avctx);
-}
-
 #if HAVE_THREADS
 static int vp9_decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src)
 {
@@ -1847,7 +1839,7 @@
     }
     for (i = 0; i < 8; i++) {
         if (s->s.refs[i].f->buf[0])
-            ff_thread_release_buffer(dst, &s->s.refs[i]);
+            ff_thread_release_ext_buffer(dst, &s->s.refs[i]);
         if (ssrc->next_refs[i].f->buf[0]) {
             if ((ret = ff_thread_ref_frame(&s->s.refs[i], &ssrc->next_refs[i])) < 0)
                 return ret;
@@ -1878,21 +1870,22 @@
 }
 #endif
 
-AVCodec ff_vp9_decoder = {
-    .name                  = "vp9",
-    .long_name             = NULL_IF_CONFIG_SMALL("Google VP9"),
-    .type                  = AVMEDIA_TYPE_VIDEO,
-    .id                    = AV_CODEC_ID_VP9,
+const FFCodec ff_vp9_decoder = {
+    .p.name                = "vp9",
+    CODEC_LONG_NAME("Google VP9"),
+    .p.type                = AVMEDIA_TYPE_VIDEO,
+    .p.id                  = AV_CODEC_ID_VP9,
     .priv_data_size        = sizeof(VP9Context),
     .init                  = vp9_decode_init,
     .close                 = vp9_decode_free,
-    .decode                = vp9_decode_frame,
-    .capabilities          = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal         = FF_CODEC_CAP_SLICE_THREAD_HAS_MF |
+    FF_CODEC_DECODE_CB(vp9_decode_frame),
+    .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS,
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
+                             FF_CODEC_CAP_SLICE_THREAD_HAS_MF |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS,
     .flush                 = vp9_decode_flush,
-    .update_thread_context = ONLY_IF_THREADS_ENABLED(vp9_decode_update_thread_context),
-    .profiles              = NULL_IF_CONFIG_SMALL(ff_vp9_profiles),
+    UPDATE_THREAD_CONTEXT(vp9_decode_update_thread_context),
+    .p.profiles            = NULL_IF_CONFIG_SMALL(ff_vp9_profiles),
     .bsfs                  = "vp9_superframe_split",
     .hw_configs            = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_VP9_DXVA2_HWACCEL
@@ -1913,6 +1906,9 @@
 #if CONFIG_VP9_VDPAU_HWACCEL
                                HWACCEL_VDPAU(vp9),
 #endif
+#if CONFIG_VP9_VIDEOTOOLBOX_HWACCEL
+                               HWACCEL_VIDEOTOOLBOX(vp9),
+#endif
                                NULL
                            },
 };
diff -Naur a/media/ffvpx/libavcodec/vp9dec.h b/media/ffvpx/libavcodec/vp9dec.h
--- a/media/ffvpx/libavcodec/vp9dec.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9dec.h	2023-04-06 12:50:06.974471174 +0200
@@ -33,9 +33,12 @@
 #include "libavutil/thread.h"
 #include "libavutil/internal.h"
 
+#include "get_bits.h"
+#include "videodsp.h"
 #include "vp9.h"
 #include "vp9dsp.h"
 #include "vp9shared.h"
+#include "vpx_rac.h"
 
 #define REF_INVALID_SCALE 0xFFFF
 
@@ -82,7 +85,7 @@
 typedef struct VP9Block {
     uint8_t seg_id, intra, comp, ref[2], mode[4], uvmode, skip;
     enum FilterMode filter;
-    VP56mv mv[4 /* b_idx */][2 /* ref */];
+    VP9mv mv[4 /* b_idx */][2 /* ref */];
     enum BlockSize bs;
     enum TxfmMode tx, uvtx;
     enum BlockLevel bl;
@@ -98,13 +101,14 @@
     VP9DSPContext dsp;
     VideoDSPContext vdsp;
     GetBitContext gb;
-    VP56RangeCoder c;
+    VPXRangeCoder c;
     int pass, active_tile_cols;
 
 #if HAVE_THREADS
     pthread_mutex_t progress_mutex;
     pthread_cond_t progress_cond;
     atomic_int *entries;
+    unsigned pthread_init_cnt;
 #endif
 
     uint8_t ss_h, ss_v;
@@ -145,7 +149,7 @@
     uint8_t *above_comp_ctx; // 1bit
     uint8_t *above_ref_ctx; // 2bit
     uint8_t *above_filter_ctx;
-    VP56mv (*above_mv_ctx)[2];
+    VP9mv (*above_mv_ctx)[2];
 
     // whole-frame cache
     uint8_t *intra_pred_data[3];
@@ -162,11 +166,9 @@
 } VP9Context;
 
 struct VP9TileData {
-    //VP9Context should be const, but because of the threading API(generates
-    //a lot of warnings) it's not.
-    VP9Context *s;
-    VP56RangeCoder *c_b;
-    VP56RangeCoder *c;
+    const VP9Context *s;
+    VPXRangeCoder *c_b;
+    VPXRangeCoder *c;
     int row, row7, col, col7;
     uint8_t *dst[3];
     ptrdiff_t y_stride, uv_stride;
@@ -208,7 +210,7 @@
     // contextual (left) cache
     DECLARE_ALIGNED(16, uint8_t, left_y_nnz_ctx)[16];
     DECLARE_ALIGNED(16, uint8_t, left_mode_ctx)[16];
-    DECLARE_ALIGNED(16, VP56mv, left_mv_ctx)[16][2];
+    DECLARE_ALIGNED(16, VP9mv, left_mv_ctx)[16][2];
     DECLARE_ALIGNED(16, uint8_t, left_uv_nnz_ctx)[2][16];
     DECLARE_ALIGNED(8, uint8_t, left_partition_ctx)[8];
     DECLARE_ALIGNED(8, uint8_t, left_skip_ctx)[8];
@@ -236,7 +238,7 @@
     unsigned int nb_block_structure;
 };
 
-void ff_vp9_fill_mv(VP9TileData *td, VP56mv *mv, int mode, int sb);
+void ff_vp9_fill_mv(VP9TileData *td, VP9mv *mv, int mode, int sb);
 
 void ff_vp9_adapt_probs(VP9Context *s);
 
diff -Naur a/media/ffvpx/libavcodec/vp9dsp.c b/media/ffvpx/libavcodec/vp9dsp.c
--- a/media/ffvpx/libavcodec/vp9dsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9dsp.c	2023-04-06 12:49:40.257395051 +0200
@@ -21,8 +21,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config.h"
+
+#include "libavutil/attributes.h"
 #include "libavutil/avassert.h"
-#include "libavutil/common.h"
 #include "libavutil/mem_internal.h"
 
 #include "vp9dsp.h"
@@ -94,8 +96,15 @@
         ff_vp9dsp_init_12(dsp);
     }
 
-    if (ARCH_AARCH64) ff_vp9dsp_init_aarch64(dsp, bpp);
-    if (ARCH_ARM) ff_vp9dsp_init_arm(dsp, bpp);
-    if (ARCH_X86) ff_vp9dsp_init_x86(dsp, bpp, bitexact);
-    if (ARCH_MIPS) ff_vp9dsp_init_mips(dsp, bpp);
+#if ARCH_AARCH64
+    ff_vp9dsp_init_aarch64(dsp, bpp);
+#elif ARCH_ARM
+    ff_vp9dsp_init_arm(dsp, bpp);
+#elif ARCH_X86
+    ff_vp9dsp_init_x86(dsp, bpp, bitexact);
+#elif ARCH_MIPS
+    ff_vp9dsp_init_mips(dsp, bpp);
+#elif ARCH_LOONGARCH
+    ff_vp9dsp_init_loongarch(dsp, bpp);
+#endif
 }
diff -Naur a/media/ffvpx/libavcodec/vp9dsp.h b/media/ffvpx/libavcodec/vp9dsp.h
--- a/media/ffvpx/libavcodec/vp9dsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9dsp.h	2023-04-06 12:50:06.974471174 +0200
@@ -28,6 +28,7 @@
 #include <stdint.h>
 
 #include "libavcodec/vp9.h"
+#include "libavutil/attributes_internal.h"
 
 typedef void (*vp9_mc_func)(uint8_t *dst, ptrdiff_t dst_stride,
                             const uint8_t *ref, ptrdiff_t ref_stride,
@@ -120,7 +121,7 @@
     vp9_scaled_mc_func smc[5][N_FILTERS][2];
 } VP9DSPContext;
 
-extern const int16_t ff_vp9_subpel_filters[3][16][8];
+extern const int16_t attribute_visibility_hidden ff_vp9_subpel_filters[3][16][8];
 
 void ff_vp9dsp_init(VP9DSPContext *dsp, int bpp, int bitexact);
 
@@ -132,5 +133,6 @@
 void ff_vp9dsp_init_arm(VP9DSPContext *dsp, int bpp);
 void ff_vp9dsp_init_x86(VP9DSPContext *dsp, int bpp, int bitexact);
 void ff_vp9dsp_init_mips(VP9DSPContext *dsp, int bpp);
+void ff_vp9dsp_init_loongarch(VP9DSPContext *dsp, int bpp);
 
 #endif /* AVCODEC_VP9DSP_H */
diff -Naur a/media/ffvpx/libavcodec/vp9_mc_template.c b/media/ffvpx/libavcodec/vp9_mc_template.c
--- a/media/ffvpx/libavcodec/vp9_mc_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9_mc_template.c	2023-04-06 12:50:06.974471174 +0200
@@ -22,9 +22,9 @@
  */
 
 #define ROUNDED_DIV_MVx2(a, b) \
-    (VP56mv) { .x = ROUNDED_DIV(a.x + b.x, 2), .y = ROUNDED_DIV(a.y + b.y, 2) }
+    (VP9mv) { .x = ROUNDED_DIV(a.x + b.x, 2), .y = ROUNDED_DIV(a.y + b.y, 2) }
 #define ROUNDED_DIV_MVx4(a, b, c, d) \
-    (VP56mv) { .x = ROUNDED_DIV(a.x + b.x + c.x + d.x, 4), \
+    (VP9mv) { .x = ROUNDED_DIV(a.x + b.x + c.x + d.x, 4), \
                .y = ROUNDED_DIV(a.y + b.y + c.y + d.y, 4) }
 
 static void FN(inter_pred)(VP9TileData *td)
@@ -33,11 +33,11 @@
         { 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 },
         { 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4 },
     };
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
-    ThreadFrame *tref1 = &s->s.refs[s->s.h.refidx[b->ref[0]]], *tref2;
-    AVFrame *ref1 = tref1->f, *ref2;
+    const ThreadFrame *tref1 = &s->s.refs[s->s.h.refidx[b->ref[0]]], *tref2;
+    const AVFrame *ref1 = tref1->f, *ref2;
     int w1 = ref1->width, h1 = ref1->height, w2, h2;
     ptrdiff_t ls_y = td->y_stride, ls_uv = td->uv_stride;
     int bytesperpixel = BYTES_PER_PIXEL;
@@ -51,7 +51,7 @@
 
     // y inter pred
     if (b->bs > BS_8x8) {
-        VP56mv uvmv;
+        VP9mv uvmv;
 
 #if SCALED == 0
         if (b->bs == BS_8x4) {
diff -Naur a/media/ffvpx/libavcodec/vp9mvs.c b/media/ffvpx/libavcodec/vp9mvs.c
--- a/media/ffvpx/libavcodec/vp9mvs.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9mvs.c	2023-04-06 12:50:06.974471174 +0200
@@ -21,13 +21,13 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "internal.h"
-#include "vp56.h"
-#include "vp9.h"
+#include "threadframe.h"
+#include "vp89_rac.h"
 #include "vp9data.h"
 #include "vp9dec.h"
+#include "vpx_rac.h"
 
-static av_always_inline void clamp_mv(VP56mv *dst, const VP56mv *src,
+static av_always_inline void clamp_mv(VP9mv *dst, const VP9mv *src,
                                       VP9TileData *td)
 {
     dst->x = av_clip(src->x, td->min_mv.x, td->max_mv.x);
@@ -35,7 +35,7 @@
 }
 
 static void find_ref_mvs(VP9TileData *td,
-                         VP56mv *pmv, int ref, int z, int idx, int sb)
+                         VP9mv *pmv, int ref, int z, int idx, int sb)
 {
     static const int8_t mv_ref_blk_off[N_BS_SIZES][8][2] = {
         [BS_64x64] = { {  3, -1 }, { -1,  3 }, {  4, -1 }, { -1,  4 },
@@ -65,7 +65,7 @@
         [BS_4x4]   = { {  0, -1 }, { -1,  0 }, { -1, -1 }, {  0, -2 },
                        { -2,  0 }, { -1, -2 }, { -2, -1 }, { -2, -2 } },
     };
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col, row7 = td->row7;
     const int8_t (*p)[2] = mv_ref_blk_off[b->bs];
@@ -99,7 +99,7 @@
 #define RETURN_MV(mv)                                                  \
     do {                                                               \
         if (sb > 0) {                                                  \
-            VP56mv tmp;                                                \
+            VP9mv tmp;                                                 \
             uint32_t m;                                                \
             av_assert2(idx == 1);                                      \
             av_assert2(mem != INVALID_MV);                             \
@@ -185,7 +185,7 @@
 #define RETURN_SCALE_MV(mv, scale)              \
     do {                                        \
         if (scale) {                            \
-            VP56mv mv_temp = { -mv.x, -mv.y };  \
+            VP9mv mv_temp = { -mv.x, -mv.y };   \
             RETURN_MV(mv_temp);                 \
         } else {                                \
             RETURN_MV(mv);                      \
@@ -235,10 +235,10 @@
 
 static av_always_inline int read_mv_component(VP9TileData *td, int idx, int hp)
 {
-    VP9Context *s = td->s;
-    int bit, sign = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].sign);
-    int n, c = vp8_rac_get_tree(td->c, ff_vp9_mv_class_tree,
-                                s->prob.p.mv_comp[idx].classes);
+    const VP9Context *s = td->s;
+    int bit, sign = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].sign);
+    int n, c = vp89_rac_get_tree(td->c, ff_vp9_mv_class_tree,
+                                 s->prob.p.mv_comp[idx].classes);
 
     td->counts.mv_comp[idx].sign[sign]++;
     td->counts.mv_comp[idx].classes[c]++;
@@ -246,17 +246,17 @@
         int m;
 
         for (n = 0, m = 0; m < c; m++) {
-            bit = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].bits[m]);
+            bit = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].bits[m]);
             n |= bit << m;
             td->counts.mv_comp[idx].bits[m][bit]++;
         }
         n <<= 3;
-        bit = vp8_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
-                               s->prob.p.mv_comp[idx].fp);
+        bit = vp89_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
+                                s->prob.p.mv_comp[idx].fp);
         n  |= bit << 1;
         td->counts.mv_comp[idx].fp[bit]++;
         if (hp) {
-            bit = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].hp);
+            bit = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].hp);
             td->counts.mv_comp[idx].hp[bit]++;
             n |= bit;
         } else {
@@ -267,14 +267,14 @@
         }
         n += 8 << c;
     } else {
-        n = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0);
+        n = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0);
         td->counts.mv_comp[idx].class0[n]++;
-        bit = vp8_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
-                               s->prob.p.mv_comp[idx].class0_fp[n]);
+        bit = vp89_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
+                                s->prob.p.mv_comp[idx].class0_fp[n]);
         td->counts.mv_comp[idx].class0_fp[n][bit]++;
         n = (n << 3) | (bit << 1);
         if (hp) {
-            bit = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0_hp);
+            bit = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0_hp);
             td->counts.mv_comp[idx].class0_hp[bit]++;
             n |= bit;
         } else {
@@ -288,9 +288,9 @@
     return sign ? -(n + 1) : (n + 1);
 }
 
-void ff_vp9_fill_mv(VP9TileData *td, VP56mv *mv, int mode, int sb)
+void ff_vp9_fill_mv(VP9TileData *td, VP9mv *mv, int mode, int sb)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
 
     if (mode == ZEROMV) {
@@ -319,8 +319,8 @@
             }
         }
         if (mode == NEWMV) {
-            enum MVJoint j = vp8_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
-                                              s->prob.p.mv_joint);
+            enum MVJoint j = vp89_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
+                                               s->prob.p.mv_joint);
 
             td->counts.mv_joint[j]++;
             if (j >= MV_JOINT_V)
@@ -350,8 +350,8 @@
                 }
             }
             if (mode == NEWMV) {
-                enum MVJoint j = vp8_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
-                                                  s->prob.p.mv_joint);
+                enum MVJoint j = vp89_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
+                                                   s->prob.p.mv_joint);
 
                 td->counts.mv_joint[j]++;
                 if (j >= MV_JOINT_V)
diff -Naur a/media/ffvpx/libavcodec/vp9_parser.c b/media/ffvpx/libavcodec/vp9_parser.c
--- a/media/ffvpx/libavcodec/vp9_parser.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9_parser.c	2023-04-06 12:49:40.256395011 +0200
@@ -64,7 +64,7 @@
     return size;
 }
 
-AVCodecParser ff_vp9_parser = {
+const AVCodecParser ff_vp9_parser = {
     .codec_ids      = { AV_CODEC_ID_VP9 },
     .parser_parse   = parse,
 };
diff -Naur a/media/ffvpx/libavcodec/vp9prob.c b/media/ffvpx/libavcodec/vp9prob.c
--- a/media/ffvpx/libavcodec/vp9prob.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9prob.c	2023-04-06 12:50:06.974471174 +0200
@@ -21,9 +21,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "vp56.h"
 #include "vp9.h"
-#include "vp9data.h"
 #include "vp9dec.h"
 
 static av_always_inline void adapt_prob(uint8_t *p, unsigned ct0, unsigned ct1,
diff -Naur a/media/ffvpx/libavcodec/vp9recon.c b/media/ffvpx/libavcodec/vp9recon.c
--- a/media/ffvpx/libavcodec/vp9recon.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9recon.c	2023-04-06 12:50:06.974471174 +0200
@@ -24,8 +24,7 @@
 #include "libavutil/avassert.h"
 #include "libavutil/mem_internal.h"
 
-#include "avcodec.h"
-#include "internal.h"
+#include "threadframe.h"
 #include "videodsp.h"
 #include "vp9data.h"
 #include "vp9dec.h"
@@ -37,7 +36,7 @@
                                              int row, int y, enum TxfmMode tx,
                                              int p, int ss_h, int ss_v, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     int have_top = row > 0 || y > 0;
     int have_left = col > td->tile_col_start || x > 0;
     int have_right = x < w - 1;
@@ -219,7 +218,7 @@
 static av_always_inline void intra_recon(VP9TileData *td, ptrdiff_t y_off,
                                          ptrdiff_t uv_off, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
     int w4 = ff_vp9_bwh_tab[1][b->bs][0] << 1, step1d = 1 << b->tx, n;
@@ -296,14 +295,14 @@
     intra_recon(td, y_off, uv_off, 2);
 }
 
-static av_always_inline void mc_luma_unscaled(VP9TileData *td, vp9_mc_func (*mc)[2],
+static av_always_inline void mc_luma_unscaled(VP9TileData *td, const vp9_mc_func (*mc)[2],
                                               uint8_t *dst, ptrdiff_t dst_stride,
                                               const uint8_t *ref, ptrdiff_t ref_stride,
-                                              ThreadFrame *ref_frame,
-                                              ptrdiff_t y, ptrdiff_t x, const VP56mv *mv,
+                                              const ThreadFrame *ref_frame,
+                                              ptrdiff_t y, ptrdiff_t x, const VP9mv *mv,
                                               int bw, int bh, int w, int h, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     int mx = mv->x, my = mv->y, th;
 
     y += my >> 3;
@@ -332,16 +331,16 @@
     mc[!!mx][!!my](dst, dst_stride, ref, ref_stride, bh, mx << 1, my << 1);
 }
 
-static av_always_inline void mc_chroma_unscaled(VP9TileData *td, vp9_mc_func (*mc)[2],
+static av_always_inline void mc_chroma_unscaled(VP9TileData *td, const vp9_mc_func (*mc)[2],
                                                 uint8_t *dst_u, uint8_t *dst_v,
                                                 ptrdiff_t dst_stride,
                                                 const uint8_t *ref_u, ptrdiff_t src_stride_u,
                                                 const uint8_t *ref_v, ptrdiff_t src_stride_v,
-                                                ThreadFrame *ref_frame,
-                                                ptrdiff_t y, ptrdiff_t x, const VP56mv *mv,
+                                                const ThreadFrame *ref_frame,
+                                                ptrdiff_t y, ptrdiff_t x, const VP9mv *mv,
                                                 int bw, int bh, int w, int h, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     int mx = mv->x * (1 << !s->ss_h), my = mv->y * (1 << !s->ss_v), th;
 
     y += my >> 4;
@@ -405,16 +404,16 @@
 #undef SCALED
 
 static av_always_inline void mc_luma_scaled(VP9TileData *td, vp9_scaled_mc_func smc,
-                                            vp9_mc_func (*mc)[2],
+                                            const vp9_mc_func (*mc)[2],
                                             uint8_t *dst, ptrdiff_t dst_stride,
                                             const uint8_t *ref, ptrdiff_t ref_stride,
-                                            ThreadFrame *ref_frame,
-                                            ptrdiff_t y, ptrdiff_t x, const VP56mv *in_mv,
+                                            const ThreadFrame *ref_frame,
+                                            ptrdiff_t y, ptrdiff_t x, const VP9mv *in_mv,
                                             int px, int py, int pw, int ph,
                                             int bw, int bh, int w, int h, int bytesperpixel,
                                             const uint16_t *scale, const uint8_t *step)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     if (s->s.frames[CUR_FRAME].tf.f->width == ref_frame->f->width &&
         s->s.frames[CUR_FRAME].tf.f->height == ref_frame->f->height) {
         mc_luma_unscaled(td, mc, dst, dst_stride, ref, ref_stride, ref_frame,
@@ -424,7 +423,7 @@
     int mx, my;
     int refbw_m1, refbh_m1;
     int th;
-    VP56mv mv;
+    VP9mv mv;
 
     mv.x = av_clip(in_mv->x, -(x + pw - px + 4) * 8, (s->cols * 8 - x + px + 3) * 8);
     mv.y = av_clip(in_mv->y, -(y + ph - py + 4) * 8, (s->rows * 8 - y + py + 3) * 8);
@@ -463,18 +462,18 @@
 }
 
 static av_always_inline void mc_chroma_scaled(VP9TileData *td, vp9_scaled_mc_func smc,
-                                              vp9_mc_func (*mc)[2],
+                                              const vp9_mc_func (*mc)[2],
                                               uint8_t *dst_u, uint8_t *dst_v,
                                               ptrdiff_t dst_stride,
                                               const uint8_t *ref_u, ptrdiff_t src_stride_u,
                                               const uint8_t *ref_v, ptrdiff_t src_stride_v,
-                                              ThreadFrame *ref_frame,
-                                              ptrdiff_t y, ptrdiff_t x, const VP56mv *in_mv,
+                                              const ThreadFrame *ref_frame,
+                                              ptrdiff_t y, ptrdiff_t x, const VP9mv *in_mv,
                                               int px, int py, int pw, int ph,
                                               int bw, int bh, int w, int h, int bytesperpixel,
                                               const uint16_t *scale, const uint8_t *step)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     if (s->s.frames[CUR_FRAME].tf.f->width == ref_frame->f->width &&
         s->s.frames[CUR_FRAME].tf.f->height == ref_frame->f->height) {
         mc_chroma_unscaled(td, mc, dst_u, dst_v, dst_stride, ref_u, src_stride_u,
@@ -484,7 +483,7 @@
     int mx, my;
     int refbw_m1, refbh_m1;
     int th;
-    VP56mv mv;
+    VP9mv mv;
 
     if (s->ss_h) {
         // BUG https://code.google.com/p/webm/issues/detail?id=820
@@ -569,7 +568,7 @@
 
 static av_always_inline void inter_recon(VP9TileData *td, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
 
diff -Naur a/media/ffvpx/libavcodec/vp9shared.h b/media/ffvpx/libavcodec/vp9shared.h
--- a/media/ffvpx/libavcodec/vp9shared.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9shared.h	2023-04-06 12:50:06.974471174 +0200
@@ -27,9 +27,10 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "libavutil/mem_internal.h"
+
 #include "vp9.h"
-#include "thread.h"
-#include "vp56.h"
+#include "threadframe.h"
 
 enum BlockPartition {
     PARTITION_NONE,    // [ ] <-.
@@ -51,8 +52,13 @@
     PRED_SWITCHABLE,
 };
 
+typedef struct VP9mv {
+    DECLARE_ALIGNED(4, int16_t, x);
+    int16_t y;
+} VP9mv;
+
 typedef struct VP9mvrefPair {
-    VP56mv mv[2];
+    VP9mv mv[2];
     int8_t ref[2];
 } VP9mvrefPair;
 
diff -Naur a/media/ffvpx/libavcodec/vp9_superframe_split_bsf.c b/media/ffvpx/libavcodec/vp9_superframe_split_bsf.c
--- a/media/ffvpx/libavcodec/vp9_superframe_split_bsf.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/vp9_superframe_split_bsf.c	2023-04-06 12:49:40.257395051 +0200
@@ -51,6 +51,9 @@
             return ret;
         in = s->buffer_pkt;
 
+        if (!in->size)
+            goto passthrough;
+
         marker = in->data[in->size - 1];
         if ((marker & 0xe0) == 0xc0) {
             int length_size = 1 + ((marker >> 3) & 0x3);
@@ -70,7 +73,7 @@
                         frame_size |= bytestream2_get_byte(&bc) << (j * 8);
 
                     total_size += frame_size;
-                    if (frame_size < 0 || total_size > in->size - idx_size) {
+                    if (frame_size <= 0 || total_size > in->size - idx_size) {
                         av_log(ctx, AV_LOG_ERROR,
                                "Invalid frame size in a superframe: %d\n", frame_size);
                         ret = AVERROR(EINVAL);
@@ -121,6 +124,7 @@
             out->pts = AV_NOPTS_VALUE;
 
     } else {
+passthrough:
         av_packet_move_ref(out, s->buffer_pkt);
     }
 
@@ -155,12 +159,12 @@
     av_packet_free(&s->buffer_pkt);
 }
 
-const AVBitStreamFilter ff_vp9_superframe_split_bsf = {
-    .name = "vp9_superframe_split",
+const FFBitStreamFilter ff_vp9_superframe_split_bsf = {
+    .p.name         = "vp9_superframe_split",
+    .p.codec_ids    = (const enum AVCodecID []){ AV_CODEC_ID_VP9, AV_CODEC_ID_NONE },
     .priv_data_size = sizeof(VP9SFSplitContext),
     .init           = vp9_superframe_split_init,
     .flush          = vp9_superframe_split_flush,
     .close          = vp9_superframe_split_uninit,
     .filter         = vp9_superframe_split_filter,
-    .codec_ids      = (const enum AVCodecID []){ AV_CODEC_ID_VP9, AV_CODEC_ID_NONE },
 };
diff -Naur a/media/ffvpx/libavcodec/vpx_rac.c b/media/ffvpx/libavcodec/vpx_rac.c
--- a/media/ffvpx/libavcodec/vpx_rac.c	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/vpx_rac.c	2023-04-06 12:50:06.974471174 +0200
@@ -0,0 +1,53 @@
+/*
+ * VP5/6/8 decoder
+ * Copyright (c) 2010 Fiona Glaser <fiona@x264.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include "libavutil/error.h"
+#include "bytestream.h"
+#include "vpx_rac.h"
+
+const uint8_t ff_vpx_norm_shift[256]= {
+ 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
+ 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
+ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+};
+
+int ff_vpx_init_range_decoder(VPXRangeCoder *c, const uint8_t *buf, int buf_size)
+{
+    c->high = 255;
+    c->bits = -16;
+    c->buffer = buf;
+    c->end = buf + buf_size;
+    c->end_reached = 0;
+    if (buf_size < 1)
+        return AVERROR_INVALIDDATA;
+    c->code_word = bytestream_get_be24(&c->buffer);
+    return 0;
+}
diff -Naur a/media/ffvpx/libavcodec/vpx_rac.h b/media/ffvpx/libavcodec/vpx_rac.h
--- a/media/ffvpx/libavcodec/vpx_rac.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/vpx_rac.h	2023-04-06 12:50:06.975471215 +0200
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Common VP5-VP9 range decoder stuff
+ */
+
+#ifndef AVCODEC_VPX_RAC_H
+#define AVCODEC_VPX_RAC_H
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "bytestream.h"
+
+typedef struct VPXRangeCoder {
+    int high;
+    int bits; /* stored negated (i.e. negative "bits" is a positive number of
+                 bits left) in order to eliminate a negate in cache refilling */
+    const uint8_t *buffer;
+    const uint8_t *end;
+    unsigned int code_word;
+    int end_reached;
+} VPXRangeCoder;
+
+extern const uint8_t ff_vpx_norm_shift[256];
+int ff_vpx_init_range_decoder(VPXRangeCoder *c, const uint8_t *buf, int buf_size);
+
+/**
+ * returns 1 if the end of the stream has been reached, 0 otherwise.
+ */
+static av_always_inline int vpx_rac_is_end(VPXRangeCoder *c)
+{
+    if (c->end <= c->buffer && c->bits >= 0)
+        c->end_reached ++;
+    return c->end_reached > 10;
+}
+
+static av_always_inline unsigned int vpx_rac_renorm(VPXRangeCoder *c)
+{
+    int shift = ff_vpx_norm_shift[c->high];
+    int bits = c->bits;
+    unsigned int code_word = c->code_word;
+
+    c->high   <<= shift;
+    code_word <<= shift;
+    bits       += shift;
+    if(bits >= 0 && c->buffer < c->end) {
+        code_word |= bytestream_get_be16(&c->buffer) << bits;
+        bits -= 16;
+    }
+    c->bits = bits;
+    return code_word;
+}
+
+#if   ARCH_ARM
+#include "arm/vpx_arith.h"
+#elif ARCH_X86
+#include "x86/vpx_arith.h"
+#endif
+
+#ifndef vpx_rac_get_prob
+#define vpx_rac_get_prob vpx_rac_get_prob
+static av_always_inline int vpx_rac_get_prob(VPXRangeCoder *c, uint8_t prob)
+{
+    unsigned int code_word = vpx_rac_renorm(c);
+    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
+    unsigned int low_shift = low << 16;
+    int bit = code_word >= low_shift;
+
+    c->high = bit ? c->high - low : low;
+    c->code_word = bit ? code_word - low_shift : code_word;
+
+    return bit;
+}
+#endif
+
+#ifndef vpx_rac_get_prob_branchy
+// branchy variant, to be used where there's a branch based on the bit decoded
+static av_always_inline int vpx_rac_get_prob_branchy(VPXRangeCoder *c, int prob)
+{
+    unsigned long code_word = vpx_rac_renorm(c);
+    unsigned low = 1 + (((c->high - 1) * prob) >> 8);
+    unsigned low_shift = low << 16;
+
+    if (code_word >= low_shift) {
+        c->high     -= low;
+        c->code_word = code_word - low_shift;
+        return 1;
+    }
+
+    c->high = low;
+    c->code_word = code_word;
+    return 0;
+}
+#endif
+
+static av_always_inline int vpx_rac_get(VPXRangeCoder *c)
+{
+    unsigned int code_word = vpx_rac_renorm(c);
+    /* equiprobable */
+    int low = (c->high + 1) >> 1;
+    unsigned int low_shift = low << 16;
+    int bit = code_word >= low_shift;
+    if (bit) {
+        c->high   -= low;
+        code_word -= low_shift;
+    } else {
+        c->high = low;
+    }
+
+    c->code_word = code_word;
+    return bit;
+}
+
+#endif /* AVCODEC_VPX_RAC_H */
diff -Naur a/media/ffvpx/libavcodec/x86/dct32.asm b/media/ffvpx/libavcodec/x86/dct32.asm
--- a/media/ffvpx/libavcodec/x86/dct32.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/dct32.asm	2023-04-06 12:49:40.257395051 +0200
@@ -387,7 +387,7 @@
 %endif
 
 
-; void ff_dct32_float_sse(FFTSample *out, const FFTSample *in)
+; void ff_dct32_float(FFTSample *out, const FFTSample *in)
 %macro DCT32_FUNC 0
 cglobal dct32_float, 2, 3, 16, out, in, tmp
     ; pass 1
@@ -474,18 +474,8 @@
 %endmacro
 
 %macro LOAD_INV 2
-%if cpuflag(sse2)
     pshufd      %1, %2, 0x1b
-%elif cpuflag(sse)
-    movaps      %1, %2
-    shufps      %1, %1, 0x1b
-%endif
 %endmacro
 
-%if ARCH_X86_32
-INIT_XMM sse
-DCT32_FUNC
-%endif
-
 INIT_XMM sse2
 DCT32_FUNC
diff -Naur a/media/ffvpx/libavcodec/x86/dct_init.c b/media/ffvpx/libavcodec/x86/dct_init.c
--- a/media/ffvpx/libavcodec/x86/dct_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/dct_init.c	2023-04-06 12:49:40.257395051 +0200
@@ -22,7 +22,6 @@
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/dct.h"
 
-void ff_dct32_float_sse(FFTSample *out, const FFTSample *in);
 void ff_dct32_float_sse2(FFTSample *out, const FFTSample *in);
 void ff_dct32_float_avx(FFTSample *out, const FFTSample *in);
 
@@ -30,10 +29,6 @@
 {
     int cpu_flags = av_get_cpu_flags();
 
-#if ARCH_X86_32
-    if (EXTERNAL_SSE(cpu_flags))
-        s->dct32 = ff_dct32_float_sse;
-#endif
     if (EXTERNAL_SSE2(cpu_flags))
         s->dct32 = ff_dct32_float_sse2;
     if (EXTERNAL_AVX_FAST(cpu_flags))
diff -Naur a/media/ffvpx/libavcodec/x86/fdct.c b/media/ffvpx/libavcodec/x86/fdct.c
--- a/media/ffvpx/libavcodec/x86/fdct.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/fdct.c	2023-04-06 12:49:40.257395051 +0200
@@ -30,12 +30,14 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "libavutil/common.h"
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/macros.h"
 #include "libavutil/mem_internal.h"
 #include "libavutil/x86/asm.h"
 #include "fdct.h"
 
-#if HAVE_MMX_INLINE
+#if HAVE_SSE2_INLINE
 
 //////////////////////////////////////////////////////////////////////
 //
@@ -69,8 +71,6 @@
 
 DECLARE_ALIGNED(16, static const int16_t, fdct_one_corr)[8] = { X8(1) };
 
-DECLARE_ALIGNED(8, static const int32_t, fdct_r_row)[2] = {RND_FRW_ROW, RND_FRW_ROW };
-
 static const struct
 {
  DECLARE_ALIGNED(16, const int32_t, fdct_r_row_sse2)[4];
@@ -80,80 +80,6 @@
 }};
 //DECLARE_ALIGNED(16, static const long, fdct_r_row_sse2)[4] = {RND_FRW_ROW, RND_FRW_ROW, RND_FRW_ROW, RND_FRW_ROW};
 
-DECLARE_ALIGNED(8, static const int16_t, tab_frw_01234567)[] = {  // forward_dct coeff table
-  16384,   16384,   22725,   19266,
-  16384,   16384,   12873,    4520,
-  21407,    8867,   19266,   -4520,
-  -8867,  -21407,  -22725,  -12873,
-  16384,  -16384,   12873,  -22725,
- -16384,   16384,    4520,   19266,
-   8867,  -21407,    4520,  -12873,
-  21407,   -8867,   19266,  -22725,
-
-  22725,   22725,   31521,   26722,
-  22725,   22725,   17855,    6270,
-  29692,   12299,   26722,   -6270,
- -12299,  -29692,  -31521,  -17855,
-  22725,  -22725,   17855,  -31521,
- -22725,   22725,    6270,   26722,
-  12299,  -29692,    6270,  -17855,
-  29692,  -12299,   26722,  -31521,
-
-  21407,   21407,   29692,   25172,
-  21407,   21407,   16819,    5906,
-  27969,   11585,   25172,   -5906,
- -11585,  -27969,  -29692,  -16819,
-  21407,  -21407,   16819,  -29692,
- -21407,   21407,    5906,   25172,
-  11585,  -27969,    5906,  -16819,
-  27969,  -11585,   25172,  -29692,
-
-  19266,   19266,   26722,   22654,
-  19266,   19266,   15137,    5315,
-  25172,   10426,   22654,   -5315,
- -10426,  -25172,  -26722,  -15137,
-  19266,  -19266,   15137,  -26722,
- -19266,   19266,    5315,   22654,
-  10426,  -25172,    5315,  -15137,
-  25172,  -10426,   22654,  -26722,
-
-  16384,   16384,   22725,   19266,
-  16384,   16384,   12873,    4520,
-  21407,    8867,   19266,   -4520,
-  -8867,  -21407,  -22725,  -12873,
-  16384,  -16384,   12873,  -22725,
- -16384,   16384,    4520,   19266,
-   8867,  -21407,    4520,  -12873,
-  21407,   -8867,   19266,  -22725,
-
-  19266,   19266,   26722,   22654,
-  19266,   19266,   15137,    5315,
-  25172,   10426,   22654,   -5315,
- -10426,  -25172,  -26722,  -15137,
-  19266,  -19266,   15137,  -26722,
- -19266,   19266,    5315,   22654,
-  10426,  -25172,    5315,  -15137,
-  25172,  -10426,   22654,  -26722,
-
-  21407,   21407,   29692,   25172,
-  21407,   21407,   16819,    5906,
-  27969,   11585,   25172,   -5906,
- -11585,  -27969,  -29692,  -16819,
-  21407,  -21407,   16819,  -29692,
- -21407,   21407,    5906,   25172,
-  11585,  -27969,    5906,  -16819,
-  27969,  -11585,   25172,  -29692,
-
-  22725,   22725,   31521,   26722,
-  22725,   22725,   17855,    6270,
-  29692,   12299,   26722,   -6270,
- -12299,  -29692,  -31521,  -17855,
-  22725,  -22725,   17855,  -31521,
- -22725,   22725,    6270,   26722,
-  12299,  -29692,    6270,  -17855,
-  29692,  -12299,   26722,  -31521,
-};
-
 static const struct
 {
  DECLARE_ALIGNED(16, const int16_t, tab_frw_01234567_sse2)[256];
@@ -373,7 +299,6 @@
           "r" (out + offset), "r" (ocos_4_16)); \
 }
 
-FDCT_COL(mmx, mm, movq)
 FDCT_COL(sse2, xmm, movdqa)
 
 static av_always_inline void fdct_row_sse2(const int16_t *in, int16_t *out)
@@ -441,148 +366,6 @@
     );
 }
 
-static av_always_inline void fdct_row_mmxext(const int16_t *in, int16_t *out,
-                                             const int16_t *table)
-{
-    __asm__ volatile (
-        "pshufw    $0x1B, 8(%0), %%mm5 \n\t"
-        "movq       (%0), %%mm0 \n\t"
-        "movq      %%mm0, %%mm1 \n\t"
-        "paddsw    %%mm5, %%mm0 \n\t"
-        "psubsw    %%mm5, %%mm1 \n\t"
-        "movq      %%mm0, %%mm2 \n\t"
-        "punpckldq %%mm1, %%mm0 \n\t"
-        "punpckhdq %%mm1, %%mm2 \n\t"
-        "movq       (%1), %%mm1 \n\t"
-        "movq      8(%1), %%mm3 \n\t"
-        "movq     16(%1), %%mm4 \n\t"
-        "movq     24(%1), %%mm5 \n\t"
-        "movq     32(%1), %%mm6 \n\t"
-        "movq     40(%1), %%mm7 \n\t"
-        "pmaddwd   %%mm0, %%mm1 \n\t"
-        "pmaddwd   %%mm2, %%mm3 \n\t"
-        "pmaddwd   %%mm0, %%mm4 \n\t"
-        "pmaddwd   %%mm2, %%mm5 \n\t"
-        "pmaddwd   %%mm0, %%mm6 \n\t"
-        "pmaddwd   %%mm2, %%mm7 \n\t"
-        "pmaddwd  48(%1), %%mm0 \n\t"
-        "pmaddwd  56(%1), %%mm2 \n\t"
-        "paddd     %%mm1, %%mm3 \n\t"
-        "paddd     %%mm4, %%mm5 \n\t"
-        "paddd     %%mm6, %%mm7 \n\t"
-        "paddd     %%mm0, %%mm2 \n\t"
-        "movq       (%2), %%mm0 \n\t"
-        "paddd     %%mm0, %%mm3 \n\t"
-        "paddd     %%mm0, %%mm5 \n\t"
-        "paddd     %%mm0, %%mm7 \n\t"
-        "paddd     %%mm0, %%mm2 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm3 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm5 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm7 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm2 \n\t"
-        "packssdw  %%mm5, %%mm3 \n\t"
-        "packssdw  %%mm2, %%mm7 \n\t"
-        "movq      %%mm3,  (%3) \n\t"
-        "movq      %%mm7, 8(%3) \n\t"
-        :
-        : "r" (in), "r" (table), "r" (fdct_r_row), "r" (out));
-}
-
-static av_always_inline void fdct_row_mmx(const int16_t *in, int16_t *out, const int16_t *table)
-{
-    //FIXME reorder (I do not have an old MMX-only CPU here to benchmark ...)
-    __asm__ volatile(
-        "movd     12(%0), %%mm1 \n\t"
-        "punpcklwd 8(%0), %%mm1 \n\t"
-        "movq      %%mm1, %%mm2 \n\t"
-        "psrlq     $0x20, %%mm1 \n\t"
-        "movq      0(%0), %%mm0 \n\t"
-        "punpcklwd %%mm2, %%mm1 \n\t"
-        "movq      %%mm0, %%mm5 \n\t"
-        "paddsw    %%mm1, %%mm0 \n\t"
-        "psubsw    %%mm1, %%mm5 \n\t"
-        "movq      %%mm0, %%mm2 \n\t"
-        "punpckldq %%mm5, %%mm0 \n\t"
-        "punpckhdq %%mm5, %%mm2 \n\t"
-        "movq      0(%1), %%mm1 \n\t"
-        "movq      8(%1), %%mm3 \n\t"
-        "movq     16(%1), %%mm4 \n\t"
-        "movq     24(%1), %%mm5 \n\t"
-        "movq     32(%1), %%mm6 \n\t"
-        "movq     40(%1), %%mm7 \n\t"
-        "pmaddwd   %%mm0, %%mm1 \n\t"
-        "pmaddwd   %%mm2, %%mm3 \n\t"
-        "pmaddwd   %%mm0, %%mm4 \n\t"
-        "pmaddwd   %%mm2, %%mm5 \n\t"
-        "pmaddwd   %%mm0, %%mm6 \n\t"
-        "pmaddwd   %%mm2, %%mm7 \n\t"
-        "pmaddwd  48(%1), %%mm0 \n\t"
-        "pmaddwd  56(%1), %%mm2 \n\t"
-        "paddd     %%mm1, %%mm3 \n\t"
-        "paddd     %%mm4, %%mm5 \n\t"
-        "paddd     %%mm6, %%mm7 \n\t"
-        "paddd     %%mm0, %%mm2 \n\t"
-        "movq       (%2), %%mm0 \n\t"
-        "paddd     %%mm0, %%mm3 \n\t"
-        "paddd     %%mm0, %%mm5 \n\t"
-        "paddd     %%mm0, %%mm7 \n\t"
-        "paddd     %%mm0, %%mm2 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm3 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm5 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm7 \n\t"
-        "psrad $"S(SHIFT_FRW_ROW)", %%mm2 \n\t"
-        "packssdw  %%mm5, %%mm3 \n\t"
-        "packssdw  %%mm2, %%mm7 \n\t"
-        "movq      %%mm3, 0(%3) \n\t"
-        "movq      %%mm7, 8(%3) \n\t"
-        :
-        : "r" (in), "r" (table), "r" (fdct_r_row), "r" (out));
-}
-
-void ff_fdct_mmx(int16_t *block)
-{
-    DECLARE_ALIGNED(8, int64_t, align_tmp)[16];
-    int16_t * block1= (int16_t*)align_tmp;
-    const int16_t *table= tab_frw_01234567;
-    int i;
-
-    fdct_col_mmx(block, block1, 0);
-    fdct_col_mmx(block, block1, 4);
-
-    for(i=8;i>0;i--) {
-        fdct_row_mmx(block1, block, table);
-        block1 += 8;
-        table += 32;
-        block += 8;
-    }
-}
-
-#endif /* HAVE_MMX_INLINE */
-
-#if HAVE_MMXEXT_INLINE
-
-void ff_fdct_mmxext(int16_t *block)
-{
-    DECLARE_ALIGNED(8, int64_t, align_tmp)[16];
-    int16_t *block1= (int16_t*)align_tmp;
-    const int16_t *table= tab_frw_01234567;
-    int i;
-
-    fdct_col_mmx(block, block1, 0);
-    fdct_col_mmx(block, block1, 4);
-
-    for(i=8;i>0;i--) {
-        fdct_row_mmxext(block1, block, table);
-        block1 += 8;
-        table += 32;
-        block += 8;
-    }
-}
-
-#endif /* HAVE_MMXEXT_INLINE */
-
-#if HAVE_SSE2_INLINE
-
 void ff_fdct_sse2(int16_t *block)
 {
     DECLARE_ALIGNED(16, int64_t, align_tmp)[16];
diff -Naur a/media/ffvpx/libavcodec/x86/fdctdsp_init.c b/media/ffvpx/libavcodec/x86/fdctdsp_init.c
--- a/media/ffvpx/libavcodec/x86/fdctdsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/fdctdsp_init.c	2023-04-06 12:49:40.257395051 +0200
@@ -31,12 +31,6 @@
 
     if (!high_bit_depth) {
         if ((dct_algo == FF_DCT_AUTO || dct_algo == FF_DCT_MMX)) {
-            if (INLINE_MMX(cpu_flags))
-                c->fdct = ff_fdct_mmx;
-
-            if (INLINE_MMXEXT(cpu_flags))
-                c->fdct = ff_fdct_mmxext;
-
             if (INLINE_SSE2(cpu_flags))
                 c->fdct = ff_fdct_sse2;
         }
diff -Naur a/media/ffvpx/libavcodec/x86/fdct.h b/media/ffvpx/libavcodec/x86/fdct.h
--- a/media/ffvpx/libavcodec/x86/fdct.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/fdct.h	2023-04-06 12:49:40.257395051 +0200
@@ -21,8 +21,6 @@
 
 #include <stdint.h>
 
-void ff_fdct_mmx(int16_t *block);
-void ff_fdct_mmxext(int16_t *block);
 void ff_fdct_sse2(int16_t *block);
 
 #endif /* AVCODEC_X86_FDCT_H */
diff -Naur a/media/ffvpx/libavcodec/x86/fft.asm b/media/ffvpx/libavcodec/x86/fft.asm
--- a/media/ffvpx/libavcodec/x86/fft.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/fft.asm	2023-04-06 12:50:24.493176583 +0200
@@ -1,5 +1,5 @@
 ;******************************************************************************
-;* FFT transform with SSE/3DNow optimizations
+;* FFT transform with SSE/AVX optimizations
 ;* Copyright (c) 2008 Loren Merritt
 ;* Copyright (c) 2011 Vitor Sessak
 ;*
@@ -92,29 +92,6 @@
 
 SECTION .text
 
-%macro T2_3DNOW 4 ; z0, z1, mem0, mem1
-    mova     %1, %3
-    mova     %2, %1
-    pfadd    %1, %4
-    pfsub    %2, %4
-%endmacro
-
-%macro T4_3DNOW 6 ; z0, z1, z2, z3, tmp0, tmp1
-    mova     %5, %3
-    pfsub    %3, %4
-    pfadd    %5, %4 ; {t6,t5}
-    pxor     %3, [ps_m1p1] ; {t8,t7}
-    mova     %6, %1
-    movd [r0+12], %3
-    punpckhdq %3, [r0+8]
-    pfadd    %1, %5 ; {r0,i0}
-    pfsub    %6, %5 ; {r2,i2}
-    mova     %4, %2
-    pfadd    %2, %3 ; {r1,i1}
-    pfsub    %4, %3 ; {r3,i3}
-    SWAP     %3, %6
-%endmacro
-
 ;  in: %1 = {r0,i0,r2,i2,r4,i4,r6,i6}
 ;      %2 = {r1,i1,r3,i3,r5,i5,r7,i7}
 ;      %3, %4, %5 tmp
@@ -199,7 +176,7 @@
     vextractf128  %4 %+ H(%5), %3, 0
     vextractf128   %4(%5 + 1), %2, 1
     vextractf128  %4 %+ H(%5 + 1), %3, 1
-%elif cpuflag(sse) || cpuflag(3dnow)
+%elif cpuflag(sse)
     mova     %3, %2
     unpcklps %2, %1
     unpckhps %3, %1
@@ -310,12 +287,6 @@
 %endif
 %endmacro
 
-%macro PUNPCK 3
-    mova      %3, %1
-    punpckldq %1, %2
-    punpckhdq %3, %2
-%endmacro
-
 %define Z(x) [r0+mmsize*x]
 %define Z2(x) [r0+mmsize*x]
 %define ZH(x) [r0+mmsize*x+mmsize/2]
@@ -462,68 +433,6 @@
     ret
 
 
-%macro FFT48_3DNOW 0
-align 16
-fft4 %+ SUFFIX:
-    T2_3DNOW m0, m1, Z(0), Z(1)
-    mova     m2, Z(2)
-    mova     m3, Z(3)
-    T4_3DNOW m0, m1, m2, m3, m4, m5
-    PUNPCK   m0, m1, m4
-    PUNPCK   m2, m3, m5
-    mova   Z(0), m0
-    mova   Z(1), m4
-    mova   Z(2), m2
-    mova   Z(3), m5
-    ret
-
-align 16
-fft8 %+ SUFFIX:
-    T2_3DNOW m0, m1, Z(0), Z(1)
-    mova     m2, Z(2)
-    mova     m3, Z(3)
-    T4_3DNOW m0, m1, m2, m3, m4, m5
-    mova   Z(0), m0
-    mova   Z(2), m2
-    T2_3DNOW m4, m5,  Z(4),  Z(5)
-    T2_3DNOW m6, m7, Z2(6), Z2(7)
-    PSWAPD   m0, m5
-    PSWAPD   m2, m7
-    pxor     m0, [ps_m1p1]
-    pxor     m2, [ps_m1p1]
-    pfsub    m5, m0
-    pfadd    m7, m2
-    pfmul    m5, [ps_root2]
-    pfmul    m7, [ps_root2]
-    T4_3DNOW m1, m3, m5, m7, m0, m2
-    mova   Z(5), m5
-    mova  Z2(7), m7
-    mova     m0, Z(0)
-    mova     m2, Z(2)
-    T4_3DNOW m0, m2, m4, m6, m5, m7
-    PUNPCK   m0, m1, m5
-    PUNPCK   m2, m3, m7
-    mova   Z(0), m0
-    mova   Z(1), m5
-    mova   Z(2), m2
-    mova   Z(3), m7
-    PUNPCK   m4,  Z(5), m5
-    PUNPCK   m6, Z2(7), m7
-    mova   Z(4), m4
-    mova   Z(5), m5
-    mova  Z2(6), m6
-    mova  Z2(7), m7
-    ret
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX 3dnowext
-FFT48_3DNOW
-
-INIT_MMX 3dnow
-FFT48_3DNOW
-%endif
-
 %define Z(x) [zcq + o1q*(x&6) + mmsize*(x&1)]
 %define Z2(x) [zcq + o3q + mmsize*(x&1)]
 %define ZH(x) [zcq + o1q*(x&6) + mmsize*(x&1) + mmsize/2]
@@ -566,7 +475,7 @@
     mov     r0, r1
     mov     r1, r3
     FFT_DISPATCH _interleave %+ SUFFIX, r1
-    REP_RET
+    RET
 
 %endif
 
@@ -575,7 +484,7 @@
 DECL_PASS pass_sse, PASS_BIG 1
 DECL_PASS pass_interleave_sse, PASS_BIG 0
 
-%macro FFT_CALC_FUNC 0
+INIT_XMM sse
 cglobal fft_calc, 2,5,8
     mov     r3d, [r0 + FFTContext.nbits]
     PUSH    r1
@@ -592,36 +501,16 @@
     shl     r2, cl
     sub     r4, r2
 .loop:
-%if mmsize == 8
-    PSWAPD  m0, [r4 + r2 + 4]
-    mova [r4 + r2 + 4], m0
-%else
     movaps   xmm0, [r4 + r2]
     movaps   xmm1, xmm0
     unpcklps xmm0, [r4 + r2 + 16]
     unpckhps xmm1, [r4 + r2 + 16]
     movaps   [r4 + r2],      xmm0
     movaps   [r4 + r2 + 16], xmm1
-%endif
     add      r2, mmsize*2
     jl       .loop
 .end:
-%if cpuflag(3dnow)
-    femms
     RET
-%else
-    REP_RET
-%endif
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX 3dnow
-FFT_CALC_FUNC
-INIT_MMX 3dnowext
-FFT_CALC_FUNC
-%endif
-INIT_XMM sse
-FFT_CALC_FUNC
 
 cglobal fft_permute, 2,7,1
     mov     r4,  [r0 + FFTContext.revtab]
@@ -654,9 +543,9 @@
     movaps  [r1 + r2 + 16], xmm1
     add     r2, 32
     jl      .loopcopy
-    REP_RET
+    RET
 
-%macro IMDCT_CALC_FUNC 0
+INIT_XMM sse
 cglobal imdct_calc, 3,5,3
     mov     r3d, [r0 + FFTContext.mdctsize]
     mov     r4,  [r0 + FFTContext.imdcthalf]
@@ -684,52 +573,17 @@
     neg     r2
     mova    m2, [ps_neg]
 .loop:
-%if mmsize == 8
-    PSWAPD  m0, [r1 + r3]
-    PSWAPD  m1, [r0 + r2]
-    pxor    m0, m2
-%else
     mova    m0, [r1 + r3]
     mova    m1, [r0 + r2]
     shufps  m0, m0, 0x1b
     shufps  m1, m1, 0x1b
     xorps   m0, m2
-%endif
     mova [r0 + r3], m1
     mova [r1 + r2], m0
     sub     r3, mmsize
     add     r2, mmsize
     jl      .loop
-%if cpuflag(3dnow)
-    femms
     RET
-%else
-    REP_RET
-%endif
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX 3dnow
-IMDCT_CALC_FUNC
-INIT_MMX 3dnowext
-IMDCT_CALC_FUNC
-%endif
-
-INIT_XMM sse
-IMDCT_CALC_FUNC
-
-%if ARCH_X86_32
-INIT_MMX 3dnow
-%define mulps pfmul
-%define addps pfadd
-%define subps pfsub
-%define unpcklps punpckldq
-%define unpckhps punpckhdq
-DECL_PASS pass_3dnow, PASS_SMALL 1, [wq], [wq+o1q]
-DECL_PASS pass_interleave_3dnow, PASS_BIG 0
-%define pass_3dnowext pass_3dnow
-%define pass_interleave_3dnowext pass_interleave_3dnow
-%endif
 
 %ifdef PIC
 %define SECTION_REL - $$
@@ -785,14 +639,6 @@
 INIT_XMM sse
 DECL_FFT 5
 DECL_FFT 5, _interleave
-%if ARCH_X86_32
-INIT_MMX 3dnow
-DECL_FFT 4
-DECL_FFT 4, _interleave
-INIT_MMX 3dnowext
-DECL_FFT 4
-DECL_FFT 4, _interleave
-%endif
 
 INIT_XMM sse
 %undef mulps
@@ -802,37 +648,6 @@
 %undef unpckhps
 
 %macro PREROTATER 5 ;-2*k, 2*k, input+n4, tcos+n8, tsin+n8
-%if mmsize == 8 ; j*2+2-n4, n4-2-j*2, input+n4, tcos+n8, tsin+n8
-    PSWAPD     m0, [%3+%2*4]
-    movq       m2, [%3+%1*4-8]
-    movq       m3, m0
-    punpckldq  m0, m2
-    punpckhdq  m2, m3
-    movd       m1, [%4+%1*2-4] ; tcos[j]
-    movd       m3, [%4+%2*2]   ; tcos[n4-j-1]
-    punpckldq  m1, [%5+%1*2-4] ; tsin[j]
-    punpckldq  m3, [%5+%2*2]   ; tsin[n4-j-1]
-
-    mova       m4, m0
-    PSWAPD     m5, m1
-    pfmul      m0, m1
-    pfmul      m4, m5
-    mova       m6, m2
-    PSWAPD     m5, m3
-    pfmul      m2, m3
-    pfmul      m6, m5
-%if cpuflag(3dnowext)
-    pfpnacc    m0, m4
-    pfpnacc    m2, m6
-%else
-    SBUTTERFLY dq, 0, 4, 1
-    SBUTTERFLY dq, 2, 6, 3
-    pxor       m4, m7
-    pxor       m6, m7
-    pfadd      m0, m4
-    pfadd      m2, m6
-%endif
-%else
     movaps   xmm0, [%3+%2*4]
     movaps   xmm1, [%3+%1*4-0x10]
     movaps   xmm2, xmm0
@@ -853,29 +668,15 @@
     movaps   xmm0, xmm1
     unpcklps xmm1, xmm2
     unpckhps xmm0, xmm2
-%endif
 %endmacro
 
 %macro CMUL 6 ;j, xmm0, xmm1, 3, 4, 5
-%if cpuflag(sse)
     mulps      m6, %3, [%5+%1]
     mulps      m7, %2, [%5+%1]
     mulps      %2, %2, [%6+%1]
     mulps      %3, %3, [%6+%1]
     subps      %2, %2, m6
     addps      %3, %3, m7
-%elif cpuflag(3dnow)
-    mova       m6, [%1+%2*2]
-    mova       %3, [%1+%2*2+8]
-    mova       %4, m6
-    mova       m7, %3
-    pfmul      m6, [%5+%2]
-    pfmul      %3, [%6+%2]
-    pfmul      %4, [%6+%2]
-    pfmul      m7, [%5+%2]
-    pfsub      %3, m6
-    pfadd      %4, m7
-%endif
 %endmacro
 
 %macro POSROTATESHUF 5 ;j, k, z+n8, tcos+n8, tsin+n8
@@ -909,7 +710,7 @@
     sub      %2,   0x20
     add      %1,   0x20
     jl       .post
-%elif cpuflag(sse)
+%else
     movaps   xmm1, [%3+%1*2]
     movaps   xmm0, [%3+%1*2+0x10]
     CMUL     %1,   xmm0, xmm1, %3, %4, %5
@@ -931,24 +732,6 @@
     sub      %2,   0x10
     add      %1,   0x10
     jl       .post
-%elif cpuflag(3dnow)
-    CMUL  %3, %1, m0, m1, %4, %5
-    CMUL  %3, %2, m2, m3, %4, %5
-    movd  [%3+%1*2+ 0], m0
-    movd  [%3+%2*2+12], m1
-    movd  [%3+%2*2+ 0], m2
-    movd  [%3+%1*2+12], m3
-    psrlq      m0, 32
-    psrlq      m1, 32
-    psrlq      m2, 32
-    psrlq      m3, 32
-    movd  [%3+%1*2+ 8], m0
-    movd  [%3+%2*2+ 4], m1
-    movd  [%3+%2*2+ 8], m2
-    movd  [%3+%1*2+ 4], m3
-    sub        %2, 8
-    add        %1, 8
-    jl         .post
 %endif
 %endmacro
 
@@ -981,39 +764,21 @@
     push  rrevtab
 %endif
 
-%if mmsize == 8
-    sub   r3, 2
-%else
     sub   r3, 4
-%endif
-%if ARCH_X86_64 || mmsize == 8
+%if ARCH_X86_64
     xor   r4, r4
     sub   r4, r3
 %endif
-%if notcpuflag(3dnowext) && mmsize == 8
-    movd  m7, [ps_neg]
-%endif
 .pre:
 %if ARCH_X86_64 == 0
 ;unspill
-%if mmsize != 8
     xor   r4, r4
     sub   r4, r3
-%endif
     mov   rtcos, [esp+8]
     mov   rtsin, [esp+4]
 %endif
 
     PREROTATER r4, r3, r2, rtcos, rtsin
-%if mmsize == 8
-    mov    r6, [esp]                ; rrevtab = ptr+n8
-    movzx  r5,  word [rrevtab+r4-2] ; rrevtab[j]
-    movzx  r6,  word [rrevtab+r3]   ; rrevtab[n4-j-1]
-    mova [r1+r5*8], m0
-    mova [r1+r6*8], m2
-    add    r4, 2
-    sub    r3, 2
-%else
 %if ARCH_X86_64
     movzx  r5,  word [rrevtab+r4-4]
     movzx  r6,  word [rrevtab+r4-2]
@@ -1036,7 +801,6 @@
     movhps [r1+r4*8], xmm1
 %endif
     sub    r3, 4
-%endif
     jns    .pre
 
     mov  r5, r0
@@ -1062,22 +826,11 @@
 %if ARCH_X86_64 == 0
     add esp, 12
 %endif
-%if mmsize == 8
-    femms
-%endif
     RET
 %endmacro
 
 DECL_IMDCT
 
-%if ARCH_X86_32
-INIT_MMX 3dnow
-DECL_IMDCT
-
-INIT_MMX 3dnowext
-DECL_IMDCT
-%endif
-
 INIT_YMM avx
 
 %if HAVE_AVX_EXTERNAL
diff -Naur a/media/ffvpx/libavcodec/x86/fft.h b/media/ffvpx/libavcodec/x86/fft.h
--- a/media/ffvpx/libavcodec/x86/fft.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/fft.h	2023-04-06 12:49:40.257395051 +0200
@@ -24,13 +24,7 @@
 void ff_fft_permute_sse(FFTContext *s, FFTComplex *z);
 void ff_fft_calc_avx(FFTContext *s, FFTComplex *z);
 void ff_fft_calc_sse(FFTContext *s, FFTComplex *z);
-void ff_fft_calc_3dnow(FFTContext *s, FFTComplex *z);
-void ff_fft_calc_3dnowext(FFTContext *s, FFTComplex *z);
 
-void ff_imdct_calc_3dnow(FFTContext *s, FFTSample *output, const FFTSample *input);
-void ff_imdct_half_3dnow(FFTContext *s, FFTSample *output, const FFTSample *input);
-void ff_imdct_calc_3dnowext(FFTContext *s, FFTSample *output, const FFTSample *input);
-void ff_imdct_half_3dnowext(FFTContext *s, FFTSample *output, const FFTSample *input);
 void ff_imdct_calc_sse(FFTContext *s, FFTSample *output, const FFTSample *input);
 void ff_imdct_half_sse(FFTContext *s, FFTSample *output, const FFTSample *input);
 void ff_imdct_half_avx(FFTContext *s, FFTSample *output, const FFTSample *input);
diff -Naur a/media/ffvpx/libavcodec/x86/fft_init.c b/media/ffvpx/libavcodec/x86/fft_init.c
--- a/media/ffvpx/libavcodec/x86/fft_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/fft_init.c	2023-04-06 12:49:40.257395051 +0200
@@ -31,20 +31,6 @@
     if (s->nbits > 16)
         return;
 
-#if ARCH_X86_32
-    if (EXTERNAL_AMD3DNOW(cpu_flags)) {
-        s->imdct_calc = ff_imdct_calc_3dnow;
-        s->imdct_half = ff_imdct_half_3dnow;
-        s->fft_calc   = ff_fft_calc_3dnow;
-    }
-
-    if (EXTERNAL_AMD3DNOWEXT(cpu_flags)) {
-        s->imdct_calc = ff_imdct_calc_3dnowext;
-        s->imdct_half = ff_imdct_half_3dnowext;
-        s->fft_calc   = ff_fft_calc_3dnowext;
-    }
-#endif /* ARCH_X86_32 */
-
     if (EXTERNAL_SSE(cpu_flags)) {
         s->imdct_calc  = ff_imdct_calc_sse;
         s->imdct_half  = ff_imdct_half_sse;
diff -Naur a/media/ffvpx/libavcodec/x86/flacdsp.asm b/media/ffvpx/libavcodec/x86/flacdsp.asm
--- a/media/ffvpx/libavcodec/x86/flacdsp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/flacdsp.asm	2023-04-06 12:50:24.493176583 +0200
@@ -23,6 +23,10 @@
 
 %include "libavutil/x86/x86util.asm"
 
+SECTION_RODATA
+
+vector:  db 0,1,4,5,8,9,12,13,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,4,5,8,9,12,13,
+
 SECTION .text
 
 %macro PMACSDQL 5
@@ -75,7 +79,7 @@
     movd   [decodedq+4], m1
     jg .loop_sample
 .ret:
-    REP_RET
+    RET
 %endmacro
 
 %if HAVE_XOP_EXTERNAL
@@ -89,6 +93,9 @@
 ;----------------------------------------------------------------------------------
 %macro FLAC_DECORRELATE_16 3-4
 cglobal flac_decorrelate_%1_16, 2, 4, 4, out, in0, in1, len
+%ifidn %1, indep2
+    VBROADCASTI128 m2, [vector]
+%endif
 %if ARCH_X86_32
     mov      lend, lenm
 %endif
@@ -112,15 +119,21 @@
 %endif
 %ifnidn %1, indep2
     p%4d       m2, m0, m1
+    packssdw   m%2, m%2
+    packssdw   m%3, m%3
+    punpcklwd  m%2, m%3
+    psllw      m%2, m3
+%else
+    pslld      m%2, m3
+    pslld      m%3, m3
+    pshufb     m%2, m%2, m2
+    pshufb     m%3, m%3, m2
+    punpcklwd  m%2, m%3
 %endif
-    packssdw  m%2, m%2
-    packssdw  m%3, m%3
-    punpcklwd m%2, m%3
-    psllw     m%2, m3
     mova [outq + lenq], m%2
     add      lenq, 16
     jl .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse2
@@ -164,7 +177,7 @@
     add      outq, mmsize*2
     sub      lend, mmsize/4
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse2
@@ -289,10 +302,10 @@
     add      outq, mmsize*REPCOUNT
     sub      lend, mmsize/4
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
-INIT_XMM sse2
+INIT_XMM ssse3
 FLAC_DECORRELATE_16 indep2, 0, 1 ; Reuse stereo 16bits macro
 FLAC_DECORRELATE_INDEP 32, 2, 3, d
 FLAC_DECORRELATE_INDEP 16, 4, 3, w
diff -Naur a/media/ffvpx/libavcodec/x86/flacdsp_init.c b/media/ffvpx/libavcodec/x86/flacdsp_init.c
--- a/media/ffvpx/libavcodec/x86/flacdsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/flacdsp_init.c	2023-04-06 12:50:06.975471215 +0200
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "libavutil/attributes.h"
 #include "libavcodec/flacdsp.h"
 #include "libavutil/x86/cpu.h"
 #include "config.h"
@@ -27,15 +28,15 @@
 void ff_flac_lpc_32_xop(int32_t *samples, const int coeffs[32], int order,
                         int qlevel, int len);
 
-void ff_flac_enc_lpc_16_sse4(int32_t *, const int32_t *, int, int, const int32_t *,int);
-
 #define DECORRELATE_FUNCS(fmt, opt)                                                      \
 void ff_flac_decorrelate_ls_##fmt##_##opt(uint8_t **out, int32_t **in, int channels,     \
                                           int len, int shift);                           \
 void ff_flac_decorrelate_rs_##fmt##_##opt(uint8_t **out, int32_t **in, int channels,     \
                                           int len, int shift);                           \
 void ff_flac_decorrelate_ms_##fmt##_##opt(uint8_t **out, int32_t **in, int channels,     \
-                                          int len, int shift);                           \
+                                          int len, int shift)
+
+#define DECORRELATE_IFUNCS(fmt, opt)                                                     \
 void ff_flac_decorrelate_indep2_##fmt##_##opt(uint8_t **out, int32_t **in, int channels, \
                                              int len, int shift);                        \
 void ff_flac_decorrelate_indep4_##fmt##_##opt(uint8_t **out, int32_t **in, int channels, \
@@ -49,39 +50,46 @@
 DECORRELATE_FUNCS(16,  avx);
 DECORRELATE_FUNCS(32, sse2);
 DECORRELATE_FUNCS(32,  avx);
+DECORRELATE_IFUNCS(16, ssse3);
+DECORRELATE_IFUNCS(16,  avx);
+DECORRELATE_IFUNCS(32, ssse3);
+DECORRELATE_IFUNCS(32,  avx);
 
-av_cold void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels,
-                                 int bps)
+av_cold void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels)
 {
 #if HAVE_X86ASM
     int cpu_flags = av_get_cpu_flags();
 
-#if CONFIG_FLAC_DECODER
     if (EXTERNAL_SSE2(cpu_flags)) {
         if (fmt == AV_SAMPLE_FMT_S16) {
+            c->decorrelate[1] = ff_flac_decorrelate_ls_16_sse2;
+            c->decorrelate[2] = ff_flac_decorrelate_rs_16_sse2;
+            c->decorrelate[3] = ff_flac_decorrelate_ms_16_sse2;
+        } else if (fmt == AV_SAMPLE_FMT_S32) {
+            c->decorrelate[1] = ff_flac_decorrelate_ls_32_sse2;
+            c->decorrelate[2] = ff_flac_decorrelate_rs_32_sse2;
+            c->decorrelate[3] = ff_flac_decorrelate_ms_32_sse2;
+        }
+    }
+    if (EXTERNAL_SSSE3(cpu_flags)) {
+        if (fmt == AV_SAMPLE_FMT_S16) {
             if (channels == 2)
-                c->decorrelate[0] = ff_flac_decorrelate_indep2_16_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep2_16_ssse3;
             else if (channels == 4)
-                c->decorrelate[0] = ff_flac_decorrelate_indep4_16_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep4_16_ssse3;
             else if (channels == 6)
-                c->decorrelate[0] = ff_flac_decorrelate_indep6_16_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep6_16_ssse3;
             else if (ARCH_X86_64 && channels == 8)
-                c->decorrelate[0] = ff_flac_decorrelate_indep8_16_sse2;
-            c->decorrelate[1] = ff_flac_decorrelate_ls_16_sse2;
-            c->decorrelate[2] = ff_flac_decorrelate_rs_16_sse2;
-            c->decorrelate[3] = ff_flac_decorrelate_ms_16_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep8_16_ssse3;
         } else if (fmt == AV_SAMPLE_FMT_S32) {
             if (channels == 2)
-                c->decorrelate[0] = ff_flac_decorrelate_indep2_32_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep2_32_ssse3;
             else if (channels == 4)
-                c->decorrelate[0] = ff_flac_decorrelate_indep4_32_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep4_32_ssse3;
             else if (channels == 6)
-                c->decorrelate[0] = ff_flac_decorrelate_indep6_32_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep6_32_ssse3;
             else if (ARCH_X86_64 && channels == 8)
-                c->decorrelate[0] = ff_flac_decorrelate_indep8_32_sse2;
-            c->decorrelate[1] = ff_flac_decorrelate_ls_32_sse2;
-            c->decorrelate[2] = ff_flac_decorrelate_rs_32_sse2;
-            c->decorrelate[3] = ff_flac_decorrelate_ms_32_sse2;
+                c->decorrelate[0] = ff_flac_decorrelate_indep8_32_ssse3;
         }
     }
     if (EXTERNAL_SSE4(cpu_flags)) {
@@ -103,13 +111,5 @@
     if (EXTERNAL_XOP(cpu_flags)) {
         c->lpc32 = ff_flac_lpc_32_xop;
     }
-#endif
-
-#if CONFIG_FLAC_ENCODER
-    if (EXTERNAL_SSE4(cpu_flags)) {
-        if (CONFIG_GPL)
-            c->lpc16_encode = ff_flac_enc_lpc_16_sse4;
-    }
-#endif
 #endif /* HAVE_X86ASM */
 }
diff -Naur a/media/ffvpx/libavcodec/x86/h264_intrapred_10bit.asm b/media/ffvpx/libavcodec/x86/h264_intrapred_10bit.asm
--- a/media/ffvpx/libavcodec/x86/h264_intrapred_10bit.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/h264_intrapred_10bit.asm	2023-04-06 12:50:24.493176583 +0200
@@ -327,19 +327,14 @@
     lea          r0, [r0+r1*2]
     dec          r2d
     jg .loop
-    REP_RET
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_predict_8x8_dc_10(pixel *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 %macro MOV8 2-3
 ; sort of a hack, but it works
-%if mmsize==8
-    movq    [%1+0], %2
-    movq    [%1+8], %3
-%else
     movdqa    [%1], %2
-%endif
 %endmacro
 
 %macro PRED8x8_DC 1
@@ -348,17 +343,9 @@
     pxor        m4, m4
     movq        m0, [r0+0]
     movq        m1, [r0+8]
-%if mmsize==16
     punpcklwd   m0, m1
     movhlps     m1, m0
     paddw       m0, m1
-%else
-    pshufw      m2, m0, 00001110b
-    pshufw      m3, m1, 00001110b
-    paddw       m0, m2
-    paddw       m1, m3
-    punpcklwd   m0, m1
-%endif
     %1          m2, m0, 00001110b
     paddw       m0, m2
 
@@ -389,17 +376,10 @@
     paddw       m0, m3
     psrlw       m0, 2
     pavgw       m0, m4            ; s0+s2, s1, s3, s1+s3
-%if mmsize==16
     punpcklwd   m0, m0
     pshufd      m3, m0, 11111010b
     punpckldq   m0, m0
     SWAP         0,1
-%else
-    pshufw      m1, m0, 0x00
-    pshufw      m2, m0, 0x55
-    pshufw      m3, m0, 0xaa
-    pshufw      m4, m0, 0xff
-%endif
     MOV8   r0+r1*1, m1, m2
     MOV8   r0+r1*2, m1, m2
     MOV8   r0+r5*1, m1, m2
@@ -411,8 +391,6 @@
     RET
 %endmacro
 
-INIT_MMX mmxext
-PRED8x8_DC pshufw
 INIT_XMM sse2
 PRED8x8_DC pshuflw
 
@@ -503,14 +481,14 @@
     add       r0, r1
     dec r2d
     jg .loop
-    REP_RET
+    RET
 
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred8x8l_128_dc_10(pixel *src, int has_topleft, int has_topright,
 ;                            ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
-%macro PRED8x8L_128_DC 0
+INIT_XMM sse2
 cglobal pred8x8l_128_dc_10, 4, 4
     mova      m0, [pw_512] ; (1<<(BIT_DEPTH-1))
     lea       r1, [r3*3]
@@ -524,12 +502,6 @@
     MOV8 r2+r3*2, m0, m0
     MOV8 r2+r1*1, m0, m0
     RET
-%endmacro
-
-INIT_MMX mmxext
-PRED8x8L_128_DC
-INIT_XMM sse2
-PRED8x8L_128_DC
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred8x8l_top_dc_10(pixel *src, int has_topleft, int has_topright,
@@ -1008,40 +980,26 @@
 %macro MOV16 3-5
     mova [%1+     0], %2
     mova [%1+mmsize], %3
-%if mmsize==8
-    mova [%1+    16], %4
-    mova [%1+    24], %5
-%endif
 %endmacro
 
-%macro PRED16x16_VERTICAL 0
+INIT_XMM sse2
 cglobal pred16x16_vertical_10, 2, 3
     sub   r0, r1
     mov  r2d, 8
     mova  m0, [r0+ 0]
     mova  m1, [r0+mmsize]
-%if mmsize==8
-    mova  m2, [r0+16]
-    mova  m3, [r0+24]
-%endif
 .loop:
     MOV16 r0+r1*1, m0, m1, m2, m3
     MOV16 r0+r1*2, m0, m1, m2, m3
     lea   r0, [r0+r1*2]
     dec   r2d
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PRED16x16_VERTICAL
-INIT_XMM sse2
-PRED16x16_VERTICAL
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred16x16_horizontal_10(pixel *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
-%macro PRED16x16_HORIZONTAL 0
+INIT_XMM sse2
 cglobal pred16x16_horizontal_10, 2, 3
     mov   r2d, 8
 .vloop:
@@ -1054,27 +1012,17 @@
     lea    r0, [r0+r1*2]
     dec    r2d
     jg .vloop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PRED16x16_HORIZONTAL
-INIT_XMM sse2
-PRED16x16_HORIZONTAL
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred16x16_dc_10(pixel *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
-%macro PRED16x16_DC 0
+INIT_XMM sse2
 cglobal pred16x16_dc_10, 2, 6
     mov        r5, r0
     sub        r0, r1
     mova       m0, [r0+0]
     paddw      m0, [r0+mmsize]
-%if mmsize==8
-    paddw      m0, [r0+16]
-    paddw      m0, [r0+24]
-%endif
     HADDW      m0, m2
 
     lea        r0, [r0+r1-2]
@@ -1100,26 +1048,16 @@
     lea        r5, [r5+r1*2]
     dec       r3d
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PRED16x16_DC
-INIT_XMM sse2
-PRED16x16_DC
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred16x16_top_dc_10(pixel *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
-%macro PRED16x16_TOP_DC 0
+INIT_XMM sse2
 cglobal pred16x16_top_dc_10, 2, 3
     sub        r0, r1
     mova       m0, [r0+0]
     paddw      m0, [r0+mmsize]
-%if mmsize==8
-    paddw      m0, [r0+16]
-    paddw      m0, [r0+24]
-%endif
     HADDW      m0, m2
 
     SPLATW     m0, m0
@@ -1132,18 +1070,12 @@
     lea        r0, [r0+r1*2]
     dec       r2d
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PRED16x16_TOP_DC
-INIT_XMM sse2
-PRED16x16_TOP_DC
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred16x16_left_dc_10(pixel *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
-%macro PRED16x16_LEFT_DC 0
+INIT_XMM sse2
 cglobal pred16x16_left_dc_10, 2, 6
     mov        r5, r0
 
@@ -1169,18 +1101,12 @@
     lea        r5, [r5+r1*2]
     dec       r3d
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PRED16x16_LEFT_DC
-INIT_XMM sse2
-PRED16x16_LEFT_DC
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred16x16_128_dc_10(pixel *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
-%macro PRED16x16_128_DC 0
+INIT_XMM sse2
 cglobal pred16x16_128_dc_10, 2,3
     mova       m0, [pw_512]
     mov       r2d, 8
@@ -1190,10 +1116,4 @@
     lea        r0, [r0+r1*2]
     dec       r2d
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PRED16x16_128_DC
-INIT_XMM sse2
-PRED16x16_128_DC
+    RET
diff -Naur a/media/ffvpx/libavcodec/x86/h264_intrapred.asm b/media/ffvpx/libavcodec/x86/h264_intrapred.asm
--- a/media/ffvpx/libavcodec/x86/h264_intrapred.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/h264_intrapred.asm	2023-04-06 12:50:24.493176583 +0200
@@ -48,22 +48,6 @@
 ; void ff_pred16x16_vertical_8(uint8_t *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-INIT_MMX mmx
-cglobal pred16x16_vertical_8, 2,3
-    sub   r0, r1
-    mov   r2, 8
-    movq mm0, [r0+0]
-    movq mm1, [r0+8]
-.loop:
-    movq [r0+r1*1+0], mm0
-    movq [r0+r1*1+8], mm1
-    movq [r0+r1*2+0], mm0
-    movq [r0+r1*2+8], mm1
-    lea   r0, [r0+r1*2]
-    dec   r2
-    jg .loop
-    REP_RET
-
 INIT_XMM sse
 cglobal pred16x16_vertical_8, 2,3
     sub   r0, r1
@@ -78,7 +62,7 @@
     lea   r0, [r0+r1*2]
     dec   r2
     jg .loop
-    REP_RET
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred16x16_horizontal_8(uint8_t *src, ptrdiff_t stride)
@@ -111,11 +95,9 @@
     lea       r0, [r0+r1*2]
     dec       r2
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
-INIT_MMX mmx
-PRED16x16_H
 INIT_MMX mmxext
 PRED16x16_H
 INIT_XMM ssse3
@@ -154,14 +136,6 @@
 %endif
     SPLATB_REG m0, r2, m1
 
-%if mmsize==8
-    mov       r3d, 8
-.loop:
-    mova [r4+r1*0+0], m0
-    mova [r4+r1*0+8], m0
-    mova [r4+r1*1+0], m0
-    mova [r4+r1*1+8], m0
-%else
     mov       r3d, 4
 .loop:
     mova [r4+r1*0], m0
@@ -169,15 +143,12 @@
     lea   r4, [r4+r1*2]
     mova [r4+r1*0], m0
     mova [r4+r1*1], m0
-%endif
     lea   r4, [r4+r1*2]
     dec   r3d
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
-INIT_MMX mmxext
-PRED16x16_DC
 INIT_XMM sse2
 PRED16x16_DC
 INIT_XMM ssse3
@@ -187,47 +158,6 @@
 ; void ff_pred16x16_tm_vp8_8(uint8_t *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-%macro PRED16x16_TM 0
-cglobal pred16x16_tm_vp8_8, 2,5
-    sub        r0, r1
-    pxor      mm7, mm7
-    movq      mm0, [r0+0]
-    movq      mm2, [r0+8]
-    movq      mm1, mm0
-    movq      mm3, mm2
-    punpcklbw mm0, mm7
-    punpckhbw mm1, mm7
-    punpcklbw mm2, mm7
-    punpckhbw mm3, mm7
-    movzx     r3d, byte [r0-1]
-    mov       r4d, 16
-.loop:
-    movzx     r2d, byte [r0+r1-1]
-    sub       r2d, r3d
-    movd      mm4, r2d
-    SPLATW    mm4, mm4, 0
-    movq      mm5, mm4
-    movq      mm6, mm4
-    movq      mm7, mm4
-    paddw     mm4, mm0
-    paddw     mm5, mm1
-    paddw     mm6, mm2
-    paddw     mm7, mm3
-    packuswb  mm4, mm5
-    packuswb  mm6, mm7
-    movq [r0+r1+0], mm4
-    movq [r0+r1+8], mm6
-    add        r0, r1
-    dec       r4d
-    jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmx
-PRED16x16_TM
-INIT_MMX mmxext
-PRED16x16_TM
-
 INIT_XMM sse2
 cglobal pred16x16_tm_vp8_8, 2,6,6
     sub          r0, r1
@@ -262,7 +192,7 @@
     lea          r0, [r0+r1*2]
     dec         r5d
     jg .loop
-    REP_RET
+    RET
 
 %if HAVE_AVX2_EXTERNAL
 INIT_YMM avx2
@@ -298,7 +228,7 @@
     lea                       dstq, [dstq+strideq*4]
     dec                 iterationd
     jg .loop
-    REP_RET
+    RET
 %endif
 
 ;-----------------------------------------------------------------------------
@@ -311,22 +241,6 @@
     neg          r1               ; -stride
 
     movh         m0, [r0+r1  -1]
-%if mmsize == 8
-    pxor         m4, m4
-    movh         m1, [r0+r1  +3 ]
-    movh         m2, [r0+r1  +8 ]
-    movh         m3, [r0+r1  +12]
-    punpcklbw    m0, m4
-    punpcklbw    m1, m4
-    punpcklbw    m2, m4
-    punpcklbw    m3, m4
-    pmullw       m0, [pw_m8tom1  ]
-    pmullw       m1, [pw_m8tom1+8]
-    pmullw       m2, [pw_1to8    ]
-    pmullw       m3, [pw_1to8  +8]
-    paddw        m0, m2
-    paddw        m1, m3
-%else ; mmsize == 16
 %if cpuflag(ssse3)
     movhps       m0, [r0+r1  +8]
     pmaddubsw    m0, [plane_shuf] ; H coefficients
@@ -340,21 +254,10 @@
     paddw        m0, m1
 %endif
     movhlps      m1, m0
-%endif
     paddw        m0, m1
-%if cpuflag(mmxext)
     PSHUFLW      m1, m0, 0xE
-%elif cpuflag(mmx)
-    mova         m1, m0
-    psrlq        m1, 32
-%endif
     paddw        m0, m1
-%if cpuflag(mmxext)
     PSHUFLW      m1, m0, 0x1
-%elif cpuflag(mmx)
-    mova         m1, m0
-    psrlq        m1, 16
-%endif
     paddw        m0, m1           ; sum of H coefficients
 
     lea          r4, [r0+r2*8-1]
@@ -496,24 +399,10 @@
     SWAP          0, 1
 %endif
     mova         m2, m0
-%if mmsize == 8
-    mova         m5, m0
-%endif
     pmullw       m0, [pw_0to7]    ; 0*H, 1*H, ..., 7*H  (words)
-%if mmsize == 16
     psllw        m2, 3
-%else
-    psllw        m5, 3
-    psllw        m2, 2
-    mova         m6, m5
-    paddw        m6, m2
-%endif
     paddw        m0, m3           ; a + {0,1,2,3,4,5,6,7}*H
     paddw        m2, m0           ; a + {8,9,10,11,12,13,14,15}*H
-%if mmsize == 8
-    paddw        m5, m0           ; a + {8,9,10,11}*H
-    paddw        m6, m0           ; a + {12,13,14,15}*H
-%endif
 
     mov          r4, 8
 .loop:
@@ -523,20 +412,8 @@
     psraw        m4, 5
     packuswb     m3, m4
     mova       [r0], m3
-%if mmsize == 8
-    mova         m3, m5           ; b[8..11]
-    mova         m4, m6           ; b[12..15]
-    psraw        m3, 5
-    psraw        m4, 5
-    packuswb     m3, m4
-    mova     [r0+8], m3
-%endif
     paddw        m0, m1
     paddw        m2, m1
-%if mmsize == 8
-    paddw        m5, m1
-    paddw        m6, m1
-%endif
 
     mova         m3, m0           ; b[0..7]
     mova         m4, m2           ; b[8..15]
@@ -544,35 +421,15 @@
     psraw        m4, 5
     packuswb     m3, m4
     mova    [r0+r2], m3
-%if mmsize == 8
-    mova         m3, m5           ; b[8..11]
-    mova         m4, m6           ; b[12..15]
-    psraw        m3, 5
-    psraw        m4, 5
-    packuswb     m3, m4
-    mova  [r0+r2+8], m3
-%endif
     paddw        m0, m1
     paddw        m2, m1
-%if mmsize == 8
-    paddw        m5, m1
-    paddw        m6, m1
-%endif
 
     lea          r0, [r0+r2*2]
     dec          r4
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
-INIT_MMX mmx
-H264_PRED16x16_PLANE h264
-H264_PRED16x16_PLANE rv40
-H264_PRED16x16_PLANE svq3
-INIT_MMX mmxext
-H264_PRED16x16_PLANE h264
-H264_PRED16x16_PLANE rv40
-H264_PRED16x16_PLANE svq3
 INIT_XMM sse2
 H264_PRED16x16_PLANE h264
 H264_PRED16x16_PLANE rv40
@@ -592,14 +449,6 @@
     neg          r1               ; -stride
 
     movd         m0, [r0+r1  -1]
-%if mmsize == 8
-    pxor         m2, m2
-    movh         m1, [r0+r1  +4 ]
-    punpcklbw    m0, m2
-    punpcklbw    m1, m2
-    pmullw       m0, [pw_m4to4]
-    pmullw       m1, [pw_m4to4+8]
-%else ; mmsize == 16
 %if cpuflag(ssse3)
     movhps       m0, [r0+r1  +4]   ; this reads 4 bytes more than necessary
     pmaddubsw    m0, [plane8_shuf] ; H coefficients
@@ -611,25 +460,14 @@
     pmullw       m0, [pw_m4to4]
 %endif
     movhlps      m1, m0
-%endif
     paddw        m0, m1
 
 %if notcpuflag(ssse3)
-%if cpuflag(mmxext)
     PSHUFLW      m1, m0, 0xE
-%elif cpuflag(mmx)
-    mova         m1, m0
-    psrlq        m1, 32
-%endif
     paddw        m0, m1
 %endif ; !ssse3
 
-%if cpuflag(mmxext)
     PSHUFLW      m1, m0, 0x1
-%elif cpuflag(mmx)
-    mova         m1, m0
-    psrlq        m1, 16
-%endif
     paddw        m0, m1           ; sum of H coefficients
 
     lea          r4, [r0+r2*4-1]
@@ -699,20 +537,12 @@
     SPLATW       m0, m0, 0        ; H
     SPLATW       m1, m1, 0        ; V
     SPLATW       m3, m3, 0        ; a
-%if mmsize == 8
-    mova         m2, m0
-%endif
     pmullw       m0, [pw_0to7]    ; 0*H, 1*H, ..., 7*H  (words)
     paddw        m0, m3           ; a + {0,1,2,3,4,5,6,7}*H
-%if mmsize == 8
-    psllw        m2, 2
-    paddw        m2, m0           ; a + {4,5,6,7}*H
-%endif
 
     mov          r4, 4
 ALIGN 16
 .loop:
-%if mmsize == 16
     mova         m3, m0           ; b[0..7]
     paddw        m0, m1
     psraw        m3, 5
@@ -722,35 +552,13 @@
     packuswb     m3, m4
     movh       [r0], m3
     movhps  [r0+r2], m3
-%else ; mmsize == 8
-    mova         m3, m0           ; b[0..3]
-    mova         m4, m2           ; b[4..7]
-    paddw        m0, m1
-    paddw        m2, m1
-    psraw        m3, 5
-    psraw        m4, 5
-    mova         m5, m0           ; V+b[0..3]
-    mova         m6, m2           ; V+b[4..7]
-    paddw        m0, m1
-    paddw        m2, m1
-    psraw        m5, 5
-    psraw        m6, 5
-    packuswb     m3, m4
-    packuswb     m5, m6
-    mova       [r0], m3
-    mova    [r0+r2], m5
-%endif
 
     lea          r0, [r0+r2*2]
     dec          r4
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
-INIT_MMX mmx
-H264_PRED8x8_PLANE
-INIT_MMX mmxext
-H264_PRED8x8_PLANE
 INIT_XMM sse2
 H264_PRED8x8_PLANE
 INIT_XMM ssse3
@@ -791,11 +599,9 @@
     lea       r0, [r0+r1*2]
     dec       r2
     jg .loop
-    REP_RET
+    RET
 %endmacro
 
-INIT_MMX mmx
-PRED8x8_H
 INIT_MMX mmxext
 PRED8x8_H
 INIT_MMX ssse3
@@ -931,52 +737,12 @@
     lea   r4, [r4+r1*2]
     dec   r3d
     jg .loop
-    REP_RET
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_pred8x8_tm_vp8_8(uint8_t *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-%macro PRED8x8_TM 0
-cglobal pred8x8_tm_vp8_8, 2,6
-    sub        r0, r1
-    pxor      mm7, mm7
-    movq      mm0, [r0]
-    movq      mm1, mm0
-    punpcklbw mm0, mm7
-    punpckhbw mm1, mm7
-    movzx     r4d, byte [r0-1]
-    mov       r5d, 4
-.loop:
-    movzx     r2d, byte [r0+r1*1-1]
-    movzx     r3d, byte [r0+r1*2-1]
-    sub       r2d, r4d
-    sub       r3d, r4d
-    movd      mm2, r2d
-    movd      mm4, r3d
-    SPLATW    mm2, mm2, 0
-    SPLATW    mm4, mm4, 0
-    movq      mm3, mm2
-    movq      mm5, mm4
-    paddw     mm2, mm0
-    paddw     mm3, mm1
-    paddw     mm4, mm0
-    paddw     mm5, mm1
-    packuswb  mm2, mm3
-    packuswb  mm4, mm5
-    movq [r0+r1*1], mm2
-    movq [r0+r1*2], mm4
-    lea        r0, [r0+r1*2]
-    dec       r5d
-    jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmx
-PRED8x8_TM
-INIT_MMX mmxext
-PRED8x8_TM
-
 INIT_XMM sse2
 cglobal pred8x8_tm_vp8_8, 2,6,4
     sub          r0, r1
@@ -1004,7 +770,7 @@
     lea          r0, [r0+r1*2]
     dec         r5d
     jg .loop
-    REP_RET
+    RET
 
 INIT_XMM ssse3
 cglobal pred8x8_tm_vp8_8, 2,3,6
@@ -1031,7 +797,7 @@
     lea          r0, [r0+r1*2]
     dec         r2d
     jg .loop
-    REP_RET
+    RET
 
 ; dest, left, right, src, tmp
 ; output: %1 = (t[n-1] + t[n]*2 + t[n+1] + 2) >> 2
@@ -1333,114 +1099,6 @@
 ;                              int has_topright, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-INIT_MMX mmxext
-cglobal pred8x8l_down_left_8, 4,5
-    sub          r0, r3
-    movq        mm0, [r0-8]
-    movq        mm3, [r0]
-    movq        mm1, [r0+8]
-    movq        mm2, mm3
-    movq        mm4, mm3
-    PALIGNR     mm2, mm0, 7, mm0
-    PALIGNR     mm1, mm4, 1, mm4
-    test        r1d, r1d
-    jz .fix_lt_2
-    test        r2d, r2d
-    jz .fix_tr_1
-    jmp .do_top
-.fix_lt_2:
-    movq        mm5, mm3
-    pxor        mm5, mm2
-    psllq       mm5, 56
-    psrlq       mm5, 56
-    pxor        mm2, mm5
-    test        r2d, r2d
-    jnz .do_top
-.fix_tr_1:
-    movq        mm5, mm3
-    pxor        mm5, mm1
-    psrlq       mm5, 56
-    psllq       mm5, 56
-    pxor        mm1, mm5
-    jmp .do_top
-.fix_tr_2:
-    punpckhbw   mm3, mm3
-    pshufw      mm1, mm3, 0xFF
-    jmp .do_topright
-.do_top:
-    PRED4x4_LOWPASS mm4, mm2, mm1, mm3, mm5
-    movq        mm7, mm4
-    test        r2d, r2d
-    jz .fix_tr_2
-    movq        mm0, [r0+8]
-    movq        mm5, mm0
-    movq        mm2, mm0
-    movq        mm4, mm0
-    psrlq       mm5, 56
-    PALIGNR     mm2, mm3, 7, mm3
-    PALIGNR     mm5, mm4, 1, mm4
-    PRED4x4_LOWPASS mm1, mm2, mm5, mm0, mm4
-.do_topright:
-    lea          r1, [r0+r3*2]
-    movq        mm6, mm1
-    psrlq       mm1, 56
-    movq        mm4, mm1
-    lea          r2, [r1+r3*2]
-    movq        mm2, mm6
-    PALIGNR     mm2, mm7, 1, mm0
-    movq        mm3, mm6
-    PALIGNR     mm3, mm7, 7, mm0
-    PALIGNR     mm4, mm6, 1, mm0
-    movq        mm5, mm7
-    movq        mm1, mm7
-    movq        mm7, mm6
-    lea          r4, [r2+r3*2]
-    psllq       mm1, 8
-    PRED4x4_LOWPASS mm0, mm1, mm2, mm5, mm6
-    PRED4x4_LOWPASS mm1, mm3, mm4, mm7, mm6
-    movq  [r4+r3*2], mm1
-    movq        mm2, mm0
-    psllq       mm1, 8
-    psrlq       mm2, 56
-    psllq       mm0, 8
-    por         mm1, mm2
-    movq  [r4+r3*1], mm1
-    movq        mm2, mm0
-    psllq       mm1, 8
-    psrlq       mm2, 56
-    psllq       mm0, 8
-    por         mm1, mm2
-    movq  [r2+r3*2], mm1
-    movq        mm2, mm0
-    psllq       mm1, 8
-    psrlq       mm2, 56
-    psllq       mm0, 8
-    por         mm1, mm2
-    movq  [r2+r3*1], mm1
-    movq        mm2, mm0
-    psllq       mm1, 8
-    psrlq       mm2, 56
-    psllq       mm0, 8
-    por         mm1, mm2
-    movq  [r1+r3*2], mm1
-    movq        mm2, mm0
-    psllq       mm1, 8
-    psrlq       mm2, 56
-    psllq       mm0, 8
-    por         mm1, mm2
-    movq  [r1+r3*1], mm1
-    movq        mm2, mm0
-    psllq       mm1, 8
-    psrlq       mm2, 56
-    psllq       mm0, 8
-    por         mm1, mm2
-    movq  [r0+r3*2], mm1
-    psllq       mm1, 8
-    psrlq       mm0, 56
-    por         mm1, mm0
-    movq  [r0+r3*1], mm1
-    RET
-
 %macro PRED8x8L_DOWN_LEFT 0
 cglobal pred8x8l_down_left_8, 4,4
     sub          r0, r3
@@ -1530,142 +1188,10 @@
 PRED8x8L_DOWN_LEFT
 
 ;-----------------------------------------------------------------------------
-; void ff_pred8x8l_down_right_8_mmxext(uint8_t *src, int has_topleft,
-;                                      int has_topright, ptrdiff_t stride)
+; void ff_pred8x8l_down_right_8(uint8_t *src, int has_topleft,
+;                               int has_topright, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-INIT_MMX mmxext
-cglobal pred8x8l_down_right_8, 4,5
-    sub          r0, r3
-    lea          r4, [r0+r3*2]
-    movq        mm0, [r0+r3*1-8]
-    punpckhbw   mm0, [r0+r3*0-8]
-    movq        mm1, [r4+r3*1-8]
-    punpckhbw   mm1, [r0+r3*2-8]
-    mov          r4, r0
-    punpckhwd   mm1, mm0
-    lea          r0, [r0+r3*4]
-    movq        mm2, [r0+r3*1-8]
-    punpckhbw   mm2, [r0+r3*0-8]
-    lea          r0, [r0+r3*2]
-    movq        mm3, [r0+r3*1-8]
-    punpckhbw   mm3, [r0+r3*0-8]
-    punpckhwd   mm3, mm2
-    punpckhdq   mm3, mm1
-    lea          r0, [r0+r3*2]
-    movq        mm0, [r0+r3*0-8]
-    movq        mm1, [r4]
-    mov          r0, r4
-    movq        mm4, mm3
-    movq        mm2, mm3
-    PALIGNR     mm4, mm0, 7, mm0
-    PALIGNR     mm1, mm2, 1, mm2
-    test        r1d, r1d ; top_left
-    jz .fix_lt_1
-.do_left:
-    movq        mm0, mm4
-    PRED4x4_LOWPASS mm2, mm1, mm4, mm3, mm5
-    movq        mm4, mm0
-    movq        mm7, mm2
-    movq        mm6, mm2
-    PRED4x4_LOWPASS mm1, mm3, mm0, mm4, mm5
-    psllq       mm1, 56
-    PALIGNR     mm7, mm1, 7, mm3
-    movq        mm0, [r0-8]
-    movq        mm3, [r0]
-    movq        mm1, [r0+8]
-    movq        mm2, mm3
-    movq        mm4, mm3
-    PALIGNR     mm2, mm0, 7, mm0
-    PALIGNR     mm1, mm4, 1, mm4
-    test        r1d, r1d ; top_left
-    jz .fix_lt_2
-    test        r2d, r2d ; top_right
-    jz .fix_tr_1
-.do_top:
-    PRED4x4_LOWPASS mm4, mm2, mm1, mm3, mm5
-    movq        mm5, mm4
-    jmp .body
-.fix_lt_1:
-    movq        mm5, mm3
-    pxor        mm5, mm4
-    psrlq       mm5, 56
-    psllq       mm5, 48
-    pxor        mm1, mm5
-    jmp .do_left
-.fix_lt_2:
-    movq        mm5, mm3
-    pxor        mm5, mm2
-    psllq       mm5, 56
-    psrlq       mm5, 56
-    pxor        mm2, mm5
-    test        r2d, r2d ; top_right
-    jnz .do_top
-.fix_tr_1:
-    movq        mm5, mm3
-    pxor        mm5, mm1
-    psrlq       mm5, 56
-    psllq       mm5, 56
-    pxor        mm1, mm5
-    jmp .do_top
-.body:
-    lea         r1, [r0+r3*2]
-    movq       mm1, mm7
-    movq       mm7, mm5
-    movq       mm5, mm6
-    movq       mm2, mm7
-    lea         r2, [r1+r3*2]
-    PALIGNR    mm2, mm6, 1, mm0
-    movq       mm3, mm7
-    PALIGNR    mm3, mm6, 7, mm0
-    movq       mm4, mm7
-    lea         r4, [r2+r3*2]
-    psrlq      mm4, 8
-    PRED4x4_LOWPASS mm0, mm1, mm2, mm5, mm6
-    PRED4x4_LOWPASS mm1, mm3, mm4, mm7, mm6
-    movq [r4+r3*2], mm0
-    movq       mm2, mm1
-    psrlq      mm0, 8
-    psllq      mm2, 56
-    psrlq      mm1, 8
-    por        mm0, mm2
-    movq [r4+r3*1], mm0
-    movq       mm2, mm1
-    psrlq      mm0, 8
-    psllq      mm2, 56
-    psrlq      mm1, 8
-    por        mm0, mm2
-    movq [r2+r3*2], mm0
-    movq       mm2, mm1
-    psrlq      mm0, 8
-    psllq      mm2, 56
-    psrlq      mm1, 8
-    por        mm0, mm2
-    movq [r2+r3*1], mm0
-    movq       mm2, mm1
-    psrlq      mm0, 8
-    psllq      mm2, 56
-    psrlq      mm1, 8
-    por        mm0, mm2
-    movq [r1+r3*2], mm0
-    movq       mm2, mm1
-    psrlq      mm0, 8
-    psllq      mm2, 56
-    psrlq      mm1, 8
-    por        mm0, mm2
-    movq [r1+r3*1], mm0
-    movq       mm2, mm1
-    psrlq      mm0, 8
-    psllq      mm2, 56
-    psrlq      mm1, 8
-    por        mm0, mm2
-    movq [r0+r3*2], mm0
-    psrlq      mm0, 8
-    psllq      mm1, 56
-    por        mm0, mm1
-    movq [r0+r3*1], mm0
-    RET
-
 %macro PRED8x8L_DOWN_RIGHT 0
 cglobal pred8x8l_down_right_8, 4,5
     sub          r0, r3
@@ -1786,113 +1312,6 @@
 ;                                   int has_topright, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-INIT_MMX mmxext
-cglobal pred8x8l_vertical_right_8, 4,5
-    sub          r0, r3
-    lea          r4, [r0+r3*2]
-    movq        mm0, [r0+r3*1-8]
-    punpckhbw   mm0, [r0+r3*0-8]
-    movq        mm1, [r4+r3*1-8]
-    punpckhbw   mm1, [r0+r3*2-8]
-    mov          r4, r0
-    punpckhwd   mm1, mm0
-    lea          r0, [r0+r3*4]
-    movq        mm2, [r0+r3*1-8]
-    punpckhbw   mm2, [r0+r3*0-8]
-    lea          r0, [r0+r3*2]
-    movq        mm3, [r0+r3*1-8]
-    punpckhbw   mm3, [r0+r3*0-8]
-    punpckhwd   mm3, mm2
-    punpckhdq   mm3, mm1
-    lea          r0, [r0+r3*2]
-    movq        mm0, [r0+r3*0-8]
-    movq        mm1, [r4]
-    mov          r0, r4
-    movq        mm4, mm3
-    movq        mm2, mm3
-    PALIGNR     mm4, mm0, 7, mm0
-    PALIGNR     mm1, mm2, 1, mm2
-    test        r1d, r1d
-    jz .fix_lt_1
-    jmp .do_left
-.fix_lt_1:
-    movq        mm5, mm3
-    pxor        mm5, mm4
-    psrlq       mm5, 56
-    psllq       mm5, 48
-    pxor        mm1, mm5
-    jmp .do_left
-.fix_lt_2:
-    movq        mm5, mm3
-    pxor        mm5, mm2
-    psllq       mm5, 56
-    psrlq       mm5, 56
-    pxor        mm2, mm5
-    test        r2d, r2d
-    jnz .do_top
-.fix_tr_1:
-    movq        mm5, mm3
-    pxor        mm5, mm1
-    psrlq       mm5, 56
-    psllq       mm5, 56
-    pxor        mm1, mm5
-    jmp .do_top
-.do_left:
-    movq        mm0, mm4
-    PRED4x4_LOWPASS mm2, mm1, mm4, mm3, mm5
-    movq        mm7, mm2
-    movq        mm0, [r0-8]
-    movq        mm3, [r0]
-    movq        mm1, [r0+8]
-    movq        mm2, mm3
-    movq        mm4, mm3
-    PALIGNR     mm2, mm0, 7, mm0
-    PALIGNR     mm1, mm4, 1, mm4
-    test        r1d, r1d
-    jz .fix_lt_2
-    test        r2d, r2d
-    jz .fix_tr_1
-.do_top:
-    PRED4x4_LOWPASS mm6, mm2, mm1, mm3, mm5
-    lea         r1, [r0+r3*2]
-    movq       mm2, mm6
-    movq       mm3, mm6
-    PALIGNR    mm3, mm7, 7, mm0
-    PALIGNR    mm6, mm7, 6, mm1
-    movq       mm4, mm3
-    pavgb      mm3, mm2
-    lea         r2, [r1+r3*2]
-    PRED4x4_LOWPASS mm0, mm6, mm2, mm4, mm5
-    movq [r0+r3*1], mm3
-    movq [r0+r3*2], mm0
-    movq       mm5, mm0
-    movq       mm6, mm3
-    movq       mm1, mm7
-    movq       mm2, mm1
-    psllq      mm2, 8
-    movq       mm3, mm1
-    psllq      mm3, 16
-    lea         r4, [r2+r3*2]
-    PRED4x4_LOWPASS mm0, mm1, mm3, mm2, mm4
-    PALIGNR    mm6, mm0, 7, mm2
-    movq [r1+r3*1], mm6
-    psllq      mm0, 8
-    PALIGNR    mm5, mm0, 7, mm1
-    movq [r1+r3*2], mm5
-    psllq      mm0, 8
-    PALIGNR    mm6, mm0, 7, mm2
-    movq [r2+r3*1], mm6
-    psllq      mm0, 8
-    PALIGNR    mm5, mm0, 7, mm1
-    movq [r2+r3*2], mm5
-    psllq      mm0, 8
-    PALIGNR    mm6, mm0, 7, mm2
-    movq [r4+r3*1], mm6
-    psllq      mm0, 8
-    PALIGNR    mm5, mm0, 7, mm1
-    movq [r4+r3*2], mm5
-    RET
-
 %macro PRED8x8L_VERTICAL_RIGHT 0
 cglobal pred8x8l_vertical_right_8, 4,5,7
     ; manually spill XMM registers for Win64 because
@@ -2192,121 +1611,6 @@
 ;                                    int has_topright, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-INIT_MMX mmxext
-cglobal pred8x8l_horizontal_down_8, 4,5
-    sub          r0, r3
-    lea          r4, [r0+r3*2]
-    movq        mm0, [r0+r3*1-8]
-    punpckhbw   mm0, [r0+r3*0-8]
-    movq        mm1, [r4+r3*1-8]
-    punpckhbw   mm1, [r0+r3*2-8]
-    mov          r4, r0
-    punpckhwd   mm1, mm0
-    lea          r0, [r0+r3*4]
-    movq        mm2, [r0+r3*1-8]
-    punpckhbw   mm2, [r0+r3*0-8]
-    lea          r0, [r0+r3*2]
-    movq        mm3, [r0+r3*1-8]
-    punpckhbw   mm3, [r0+r3*0-8]
-    punpckhwd   mm3, mm2
-    punpckhdq   mm3, mm1
-    lea          r0, [r0+r3*2]
-    movq        mm0, [r0+r3*0-8]
-    movq        mm1, [r4]
-    mov          r0, r4
-    movq        mm4, mm3
-    movq        mm2, mm3
-    PALIGNR     mm4, mm0, 7, mm0
-    PALIGNR     mm1, mm2, 1, mm2
-    test        r1d, r1d
-    jnz .do_left
-.fix_lt_1:
-    movq        mm5, mm3
-    pxor        mm5, mm4
-    psrlq       mm5, 56
-    psllq       mm5, 48
-    pxor        mm1, mm5
-    jmp .do_left
-.fix_lt_2:
-    movq        mm5, mm3
-    pxor        mm5, mm2
-    psllq       mm5, 56
-    psrlq       mm5, 56
-    pxor        mm2, mm5
-    test        r2d, r2d
-    jnz .do_top
-.fix_tr_1:
-    movq        mm5, mm3
-    pxor        mm5, mm1
-    psrlq       mm5, 56
-    psllq       mm5, 56
-    pxor        mm1, mm5
-    jmp .do_top
-.do_left:
-    movq        mm0, mm4
-    PRED4x4_LOWPASS mm2, mm1, mm4, mm3, mm5
-    movq        mm4, mm0
-    movq        mm7, mm2
-    movq        mm6, mm2
-    PRED4x4_LOWPASS mm1, mm3, mm0, mm4, mm5
-    psllq       mm1, 56
-    PALIGNR     mm7, mm1, 7, mm3
-    movq        mm0, [r0-8]
-    movq        mm3, [r0]
-    movq        mm1, [r0+8]
-    movq        mm2, mm3
-    movq        mm4, mm3
-    PALIGNR     mm2, mm0, 7, mm0
-    PALIGNR     mm1, mm4, 1, mm4
-    test        r1d, r1d
-    jz .fix_lt_2
-    test        r2d, r2d
-    jz .fix_tr_1
-.do_top:
-    PRED4x4_LOWPASS mm4, mm2, mm1, mm3, mm5
-    movq       mm5, mm4
-    lea         r1, [r0+r3*2]
-    psllq      mm7, 56
-    movq       mm2, mm5
-    movq       mm3, mm6
-    movq       mm4, mm2
-    PALIGNR    mm2, mm6, 7, mm5
-    PALIGNR    mm6, mm7, 7, mm0
-    lea         r2, [r1+r3*2]
-    PALIGNR    mm4, mm3, 1, mm7
-    movq       mm5, mm3
-    pavgb      mm3, mm6
-    PRED4x4_LOWPASS mm0, mm4, mm6, mm5, mm7
-    movq       mm4, mm2
-    movq       mm1, mm2
-    lea         r4, [r2+r3*2]
-    psrlq      mm4, 16
-    psrlq      mm1, 8
-    PRED4x4_LOWPASS mm6, mm4, mm2, mm1, mm5
-    movq       mm7, mm3
-    punpcklbw  mm3, mm0
-    punpckhbw  mm7, mm0
-    movq       mm1, mm7
-    movq       mm0, mm7
-    movq       mm4, mm7
-    movq [r4+r3*2], mm3
-    PALIGNR    mm7, mm3, 2, mm5
-    movq [r4+r3*1], mm7
-    PALIGNR    mm1, mm3, 4, mm5
-    movq [r2+r3*2], mm1
-    PALIGNR    mm0, mm3, 6, mm3
-    movq [r2+r3*1], mm0
-    movq       mm2, mm6
-    movq       mm3, mm6
-    movq [r1+r3*2], mm4
-    PALIGNR    mm6, mm4, 2, mm5
-    movq [r1+r3*1], mm6
-    PALIGNR    mm2, mm4, 4, mm5
-    movq [r0+r3*2], mm2
-    PALIGNR    mm3, mm4, 6, mm4
-    movq [r0+r3*1], mm3
-    RET
-
 %macro PRED8x8L_HORIZONTAL_DOWN 0
 cglobal pred8x8l_horizontal_down_8, 4,5
     sub          r0, r3
@@ -2472,7 +1776,7 @@
 ;                                 ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-%macro PRED4x4_TM 0
+INIT_MMX mmxext
 cglobal pred4x4_tm_vp8_8, 3,6
     sub        r0, r2
     pxor      mm7, mm7
@@ -2487,15 +1791,8 @@
     sub       r3d, r4d
     movd      mm2, r1d
     movd      mm4, r3d
-%if cpuflag(mmxext)
     pshufw    mm2, mm2, 0
     pshufw    mm4, mm4, 0
-%else
-    punpcklwd mm2, mm2
-    punpcklwd mm4, mm4
-    punpckldq mm2, mm2
-    punpckldq mm4, mm4
-%endif
     paddw     mm2, mm0
     paddw     mm4, mm0
     packuswb  mm2, mm2
@@ -2505,13 +1802,7 @@
     lea        r0, [r0+r2*2]
     dec       r5d
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmx
-PRED4x4_TM
-INIT_MMX mmxext
-PRED4x4_TM
+    RET
 
 INIT_XMM ssse3
 cglobal pred4x4_tm_vp8_8, 3,3
diff -Naur a/media/ffvpx/libavcodec/x86/h264_intrapred_init.c b/media/ffvpx/libavcodec/x86/h264_intrapred_init.c
--- a/media/ffvpx/libavcodec/x86/h264_intrapred_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/h264_intrapred_init.c	2023-04-06 12:49:40.257395051 +0200
@@ -18,10 +18,13 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stddef.h>
+#include <stdint.h>
+#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
 #include "libavutil/x86/cpu.h"
-#include "libavcodec/avcodec.h"
+#include "libavcodec/codec_id.h"
 #include "libavcodec/h264pred.h"
 
 #define PRED4x4(TYPE, DEPTH, OPT) \
@@ -49,7 +52,6 @@
 void ff_pred8x8_ ## TYPE ## _ ## DEPTH ## _ ## OPT (uint8_t *src, \
                                                     ptrdiff_t stride);
 
-PRED8x8(dc, 10, mmxext)
 PRED8x8(dc, 10, sse2)
 PRED8x8(top_dc, 10, sse2)
 PRED8x8(plane, 10, sse2)
@@ -64,7 +66,6 @@
 
 PRED8x8L(dc, 10, sse2)
 PRED8x8L(dc, 10, avx)
-PRED8x8L(128_dc, 10, mmxext)
 PRED8x8L(128_dc, 10, sse2)
 PRED8x8L(top_dc, 10, sse2)
 PRED8x8L(top_dc, 10, avx)
@@ -90,42 +91,25 @@
 void ff_pred16x16_ ## TYPE ## _ ## DEPTH ## _ ## OPT (uint8_t *src, \
                                                       ptrdiff_t stride);
 
-PRED16x16(dc, 10, mmxext)
 PRED16x16(dc, 10, sse2)
-PRED16x16(top_dc, 10, mmxext)
 PRED16x16(top_dc, 10, sse2)
-PRED16x16(128_dc, 10, mmxext)
 PRED16x16(128_dc, 10, sse2)
-PRED16x16(left_dc, 10, mmxext)
 PRED16x16(left_dc, 10, sse2)
-PRED16x16(vertical, 10, mmxext)
 PRED16x16(vertical, 10, sse2)
-PRED16x16(horizontal, 10, mmxext)
 PRED16x16(horizontal, 10, sse2)
 
 /* 8-bit versions */
-PRED16x16(vertical, 8, mmx)
 PRED16x16(vertical, 8, sse)
-PRED16x16(horizontal, 8, mmx)
 PRED16x16(horizontal, 8, mmxext)
 PRED16x16(horizontal, 8, ssse3)
-PRED16x16(dc, 8, mmxext)
 PRED16x16(dc, 8, sse2)
 PRED16x16(dc, 8, ssse3)
-PRED16x16(plane_h264, 8, mmx)
-PRED16x16(plane_h264, 8, mmxext)
 PRED16x16(plane_h264, 8, sse2)
 PRED16x16(plane_h264, 8, ssse3)
-PRED16x16(plane_rv40, 8, mmx)
-PRED16x16(plane_rv40, 8, mmxext)
 PRED16x16(plane_rv40, 8, sse2)
 PRED16x16(plane_rv40, 8, ssse3)
-PRED16x16(plane_svq3, 8, mmx)
-PRED16x16(plane_svq3, 8, mmxext)
 PRED16x16(plane_svq3, 8, sse2)
 PRED16x16(plane_svq3, 8, ssse3)
-PRED16x16(tm_vp8, 8, mmx)
-PRED16x16(tm_vp8, 8, mmxext)
 PRED16x16(tm_vp8, 8, sse2)
 PRED16x16(tm_vp8, 8, avx2)
 
@@ -133,15 +117,10 @@
 PRED8x8(dc_rv40, 8, mmxext)
 PRED8x8(dc, 8, mmxext)
 PRED8x8(vertical, 8, mmx)
-PRED8x8(horizontal, 8, mmx)
 PRED8x8(horizontal, 8, mmxext)
 PRED8x8(horizontal, 8, ssse3)
-PRED8x8(plane, 8, mmx)
-PRED8x8(plane, 8, mmxext)
 PRED8x8(plane, 8, sse2)
 PRED8x8(plane, 8, ssse3)
-PRED8x8(tm_vp8, 8, mmx)
-PRED8x8(tm_vp8, 8, mmxext)
 PRED8x8(tm_vp8, 8, sse2)
 PRED8x8(tm_vp8, 8, ssse3)
 
@@ -153,20 +132,16 @@
 PRED8x8L(horizontal, 8, ssse3)
 PRED8x8L(vertical, 8, mmxext)
 PRED8x8L(vertical, 8, ssse3)
-PRED8x8L(down_left, 8, mmxext)
 PRED8x8L(down_left, 8, sse2)
 PRED8x8L(down_left, 8, ssse3)
-PRED8x8L(down_right, 8, mmxext)
 PRED8x8L(down_right, 8, sse2)
 PRED8x8L(down_right, 8, ssse3)
-PRED8x8L(vertical_right, 8, mmxext)
 PRED8x8L(vertical_right, 8, sse2)
 PRED8x8L(vertical_right, 8, ssse3)
 PRED8x8L(vertical_left, 8, sse2)
 PRED8x8L(vertical_left, 8, ssse3)
 PRED8x8L(horizontal_up, 8, mmxext)
 PRED8x8L(horizontal_up, 8, ssse3)
-PRED8x8L(horizontal_down, 8, mmxext)
 PRED8x8L(horizontal_down, 8, sse2)
 PRED8x8L(horizontal_down, 8, ssse3)
 
@@ -177,7 +152,6 @@
 PRED4x4(vertical_right, 8, mmxext)
 PRED4x4(horizontal_up, 8, mmxext)
 PRED4x4(horizontal_down, 8, mmxext)
-PRED4x4(tm_vp8, 8, mmx)
 PRED4x4(tm_vp8, 8, mmxext)
 PRED4x4(tm_vp8, 8, ssse3)
 PRED4x4(vertical_vp8, 8, mmxext)
@@ -190,44 +164,20 @@
 
     if (bit_depth == 8) {
         if (EXTERNAL_MMX(cpu_flags)) {
-            h->pred16x16[VERT_PRED8x8         ] = ff_pred16x16_vertical_8_mmx;
-            h->pred16x16[HOR_PRED8x8          ] = ff_pred16x16_horizontal_8_mmx;
             if (chroma_format_idc <= 1) {
                 h->pred8x8  [VERT_PRED8x8     ] = ff_pred8x8_vertical_8_mmx;
-                h->pred8x8  [HOR_PRED8x8      ] = ff_pred8x8_horizontal_8_mmx;
-            }
-            if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
-                h->pred16x16[PLANE_PRED8x8    ] = ff_pred16x16_tm_vp8_8_mmx;
-                h->pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_mmx;
-                h->pred4x4  [TM_VP8_PRED      ] = ff_pred4x4_tm_vp8_8_mmx;
-            } else {
-                if (chroma_format_idc <= 1)
-                    h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_mmx;
-                if (codec_id == AV_CODEC_ID_SVQ3) {
-                    if (cpu_flags & AV_CPU_FLAG_CMOV)
-                        h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_svq3_8_mmx;
-                } else if (codec_id == AV_CODEC_ID_RV40) {
-                    h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_rv40_8_mmx;
-                } else {
-                    h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_plane_h264_8_mmx;
-                }
             }
         }
 
         if (EXTERNAL_MMXEXT(cpu_flags)) {
             h->pred16x16[HOR_PRED8x8            ] = ff_pred16x16_horizontal_8_mmxext;
-            h->pred16x16[DC_PRED8x8             ] = ff_pred16x16_dc_8_mmxext;
             if (chroma_format_idc <= 1)
                 h->pred8x8[HOR_PRED8x8          ] = ff_pred8x8_horizontal_8_mmxext;
             h->pred8x8l [TOP_DC_PRED            ] = ff_pred8x8l_top_dc_8_mmxext;
             h->pred8x8l [DC_PRED                ] = ff_pred8x8l_dc_8_mmxext;
             h->pred8x8l [HOR_PRED               ] = ff_pred8x8l_horizontal_8_mmxext;
             h->pred8x8l [VERT_PRED              ] = ff_pred8x8l_vertical_8_mmxext;
-            h->pred8x8l [DIAG_DOWN_RIGHT_PRED   ] = ff_pred8x8l_down_right_8_mmxext;
-            h->pred8x8l [VERT_RIGHT_PRED        ] = ff_pred8x8l_vertical_right_8_mmxext;
             h->pred8x8l [HOR_UP_PRED            ] = ff_pred8x8l_horizontal_up_8_mmxext;
-            h->pred8x8l [DIAG_DOWN_LEFT_PRED    ] = ff_pred8x8l_down_left_8_mmxext;
-            h->pred8x8l [HOR_DOWN_PRED          ] = ff_pred8x8l_horizontal_down_8_mmxext;
             h->pred4x4  [DIAG_DOWN_RIGHT_PRED   ] = ff_pred4x4_down_right_8_mmxext;
             h->pred4x4  [VERT_RIGHT_PRED        ] = ff_pred4x4_vertical_right_8_mmxext;
             h->pred4x4  [HOR_DOWN_PRED          ] = ff_pred4x4_horizontal_down_8_mmxext;
@@ -249,21 +199,9 @@
                 }
             }
             if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
-                h->pred16x16[PLANE_PRED8x8      ] = ff_pred16x16_tm_vp8_8_mmxext;
                 h->pred8x8  [DC_PRED8x8         ] = ff_pred8x8_dc_rv40_8_mmxext;
-                h->pred8x8  [PLANE_PRED8x8      ] = ff_pred8x8_tm_vp8_8_mmxext;
                 h->pred4x4  [TM_VP8_PRED        ] = ff_pred4x4_tm_vp8_8_mmxext;
                 h->pred4x4  [VERT_PRED          ] = ff_pred4x4_vertical_vp8_8_mmxext;
-            } else {
-                if (chroma_format_idc <= 1)
-                    h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_plane_8_mmxext;
-                if (codec_id == AV_CODEC_ID_SVQ3) {
-                    h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_svq3_8_mmxext;
-                } else if (codec_id == AV_CODEC_ID_RV40) {
-                    h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_rv40_8_mmxext;
-                } else {
-                    h->pred16x16[PLANE_PRED8x8  ] = ff_pred16x16_plane_h264_8_mmxext;
-                }
             }
         }
 
@@ -334,18 +272,6 @@
         if (EXTERNAL_MMXEXT(cpu_flags)) {
             h->pred4x4[DC_PRED             ] = ff_pred4x4_dc_10_mmxext;
             h->pred4x4[HOR_UP_PRED         ] = ff_pred4x4_horizontal_up_10_mmxext;
-
-            if (chroma_format_idc <= 1)
-                h->pred8x8[DC_PRED8x8      ] = ff_pred8x8_dc_10_mmxext;
-
-            h->pred8x8l[DC_128_PRED        ] = ff_pred8x8l_128_dc_10_mmxext;
-
-            h->pred16x16[DC_PRED8x8        ] = ff_pred16x16_dc_10_mmxext;
-            h->pred16x16[TOP_DC_PRED8x8    ] = ff_pred16x16_top_dc_10_mmxext;
-            h->pred16x16[DC_128_PRED8x8    ] = ff_pred16x16_128_dc_10_mmxext;
-            h->pred16x16[LEFT_DC_PRED8x8   ] = ff_pred16x16_left_dc_10_mmxext;
-            h->pred16x16[VERT_PRED8x8      ] = ff_pred16x16_vertical_10_mmxext;
-            h->pred16x16[HOR_PRED8x8       ] = ff_pred16x16_horizontal_10_mmxext;
         }
         if (EXTERNAL_SSE2(cpu_flags)) {
             h->pred4x4[DIAG_DOWN_LEFT_PRED ] = ff_pred4x4_down_left_10_sse2;
diff -Naur a/media/ffvpx/libavcodec/x86/idctdsp.asm b/media/ffvpx/libavcodec/x86/idctdsp.asm
--- a/media/ffvpx/libavcodec/x86/idctdsp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/idctdsp.asm	2023-04-06 12:49:40.257395051 +0200
@@ -37,47 +37,24 @@
 %macro PUT_SIGNED_PIXELS_CLAMPED_HALF 1
     mova     m1, [blockq+mmsize*0+%1]
     mova     m2, [blockq+mmsize*2+%1]
-%if mmsize == 8
-    mova     m3, [blockq+mmsize*4+%1]
-    mova     m4, [blockq+mmsize*6+%1]
-%endif
     packsswb m1, [blockq+mmsize*1+%1]
     packsswb m2, [blockq+mmsize*3+%1]
-%if mmsize == 8
-    packsswb m3, [blockq+mmsize*5+%1]
-    packsswb m4, [blockq+mmsize*7+%1]
-%endif
     paddb    m1, m0
     paddb    m2, m0
-%if mmsize == 8
-    paddb    m3, m0
-    paddb    m4, m0
-    movq     [pixelsq+lsizeq*0], m1
-    movq     [pixelsq+lsizeq*1], m2
-    movq     [pixelsq+lsizeq*2], m3
-    movq     [pixelsq+lsize3q ], m4
-%else
     movq     [pixelsq+lsizeq*0], m1
     movhps   [pixelsq+lsizeq*1], m1
     movq     [pixelsq+lsizeq*2], m2
     movhps   [pixelsq+lsize3q ], m2
-%endif
 %endmacro
 
-%macro PUT_SIGNED_PIXELS_CLAMPED 1
-cglobal put_signed_pixels_clamped, 3, 4, %1, block, pixels, lsize, lsize3
+INIT_XMM sse2
+cglobal put_signed_pixels_clamped, 3, 4, 3, block, pixels, lsize, lsize3
     mova     m0, [pb_80]
     lea      lsize3q, [lsizeq*3]
     PUT_SIGNED_PIXELS_CLAMPED_HALF 0
     lea      pixelsq, [pixelsq+lsizeq*4]
     PUT_SIGNED_PIXELS_CLAMPED_HALF 64
     RET
-%endmacro
-
-INIT_MMX mmx
-PUT_SIGNED_PIXELS_CLAMPED 0
-INIT_XMM sse2
-PUT_SIGNED_PIXELS_CLAMPED 3
 
 ;--------------------------------------------------------------------------
 ; void ff_put_pixels_clamped(const int16_t *block, uint8_t *pixels,
@@ -87,40 +64,21 @@
 %macro PUT_PIXELS_CLAMPED_HALF 1
     mova     m0, [blockq+mmsize*0+%1]
     mova     m1, [blockq+mmsize*2+%1]
-%if mmsize == 8
-    mova     m2, [blockq+mmsize*4+%1]
-    mova     m3, [blockq+mmsize*6+%1]
-%endif
     packuswb m0, [blockq+mmsize*1+%1]
     packuswb m1, [blockq+mmsize*3+%1]
-%if mmsize == 8
-    packuswb m2, [blockq+mmsize*5+%1]
-    packuswb m3, [blockq+mmsize*7+%1]
-    movq           [pixelsq], m0
-    movq    [lsizeq+pixelsq], m1
-    movq  [2*lsizeq+pixelsq], m2
-    movq   [lsize3q+pixelsq], m3
-%else
     movq           [pixelsq], m0
     movhps  [lsizeq+pixelsq], m0
     movq  [2*lsizeq+pixelsq], m1
     movhps [lsize3q+pixelsq], m1
-%endif
 %endmacro
 
-%macro PUT_PIXELS_CLAMPED 0
+INIT_XMM sse2
 cglobal put_pixels_clamped, 3, 4, 2, block, pixels, lsize, lsize3
     lea lsize3q, [lsizeq*3]
     PUT_PIXELS_CLAMPED_HALF 0
     lea pixelsq, [pixelsq+lsizeq*4]
     PUT_PIXELS_CLAMPED_HALF 64
     RET
-%endmacro
-
-INIT_MMX mmx
-PUT_PIXELS_CLAMPED
-INIT_XMM sse2
-PUT_PIXELS_CLAMPED
 
 ;--------------------------------------------------------------------------
 ; void ff_add_pixels_clamped(const int16_t *block, uint8_t *pixels,
@@ -130,41 +88,18 @@
 %macro ADD_PIXELS_CLAMPED 1
     mova       m0, [blockq+mmsize*0+%1]
     mova       m1, [blockq+mmsize*1+%1]
-%if mmsize == 8
-    mova       m5, [blockq+mmsize*2+%1]
-    mova       m6, [blockq+mmsize*3+%1]
-%endif
     movq       m2, [pixelsq]
     movq       m3, [pixelsq+lsizeq]
-%if mmsize == 8
-    mova       m7, m2
-    punpcklbw  m2, m4
-    punpckhbw  m7, m4
-    paddsw     m0, m2
-    paddsw     m1, m7
-    mova       m7, m3
-    punpcklbw  m3, m4
-    punpckhbw  m7, m4
-    paddsw     m5, m3
-    paddsw     m6, m7
-%else
     punpcklbw  m2, m4
     punpcklbw  m3, m4
     paddsw     m0, m2
     paddsw     m1, m3
-%endif
     packuswb   m0, m1
-%if mmsize == 8
-    packuswb   m5, m6
-    movq       [pixelsq], m0
-    movq       [pixelsq+lsizeq], m5
-%else
     movq       [pixelsq], m0
     movhps     [pixelsq+lsizeq], m0
-%endif
 %endmacro
 
-%macro ADD_PIXELS_CLAMPED 0
+INIT_XMM sse2
 cglobal add_pixels_clamped, 3, 3, 5, block, pixels, lsize
     pxor       m4, m4
     ADD_PIXELS_CLAMPED 0
@@ -175,9 +110,3 @@
     lea        pixelsq, [pixelsq+lsizeq*2]
     ADD_PIXELS_CLAMPED 96
     RET
-%endmacro
-
-INIT_MMX mmx
-ADD_PIXELS_CLAMPED
-INIT_XMM sse2
-ADD_PIXELS_CLAMPED
diff -Naur a/media/ffvpx/libavcodec/x86/idctdsp.h b/media/ffvpx/libavcodec/x86/idctdsp.h
--- a/media/ffvpx/libavcodec/x86/idctdsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/idctdsp.h	2023-04-06 12:49:40.257395051 +0200
@@ -22,16 +22,10 @@
 #include <stddef.h>
 #include <stdint.h>
 
-void ff_add_pixels_clamped_mmx(const int16_t *block, uint8_t *pixels,
-                               ptrdiff_t line_size);
 void ff_add_pixels_clamped_sse2(const int16_t *block, uint8_t *pixels,
                                 ptrdiff_t line_size);
-void ff_put_pixels_clamped_mmx(const int16_t *block, uint8_t *pixels,
-                               ptrdiff_t line_size);
 void ff_put_pixels_clamped_sse2(const int16_t *block, uint8_t *pixels,
                                 ptrdiff_t line_size);
-void ff_put_signed_pixels_clamped_mmx(const int16_t *block, uint8_t *pixels,
-                                      ptrdiff_t line_size);
 void ff_put_signed_pixels_clamped_sse2(const int16_t *block, uint8_t *pixels,
                                        ptrdiff_t line_size);
 
diff -Naur a/media/ffvpx/libavcodec/x86/idctdsp_init.c b/media/ffvpx/libavcodec/x86/idctdsp_init.c
--- a/media/ffvpx/libavcodec/x86/idctdsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/idctdsp_init.c	2023-04-06 12:49:40.258395091 +0200
@@ -63,28 +63,24 @@
 {
     int cpu_flags = av_get_cpu_flags();
 
+#if ARCH_X86_32
     if (EXTERNAL_MMX(cpu_flags)) {
-        c->put_signed_pixels_clamped = ff_put_signed_pixels_clamped_mmx;
-        c->put_pixels_clamped        = ff_put_pixels_clamped_mmx;
-        c->add_pixels_clamped        = ff_add_pixels_clamped_mmx;
-
         if (!high_bit_depth &&
             avctx->lowres == 0 &&
             (avctx->idct_algo == FF_IDCT_AUTO ||
                 avctx->idct_algo == FF_IDCT_SIMPLEAUTO ||
                 avctx->idct_algo == FF_IDCT_SIMPLEMMX)) {
-                c->idct_put  = ff_simple_idct_put_mmx;
-                c->idct_add  = ff_simple_idct_add_mmx;
                 c->idct      = ff_simple_idct_mmx;
-                c->perm_type = FF_IDCT_PERM_SIMPLE;
         }
     }
+#endif
 
     if (EXTERNAL_SSE2(cpu_flags)) {
         c->put_signed_pixels_clamped = ff_put_signed_pixels_clamped_sse2;
         c->put_pixels_clamped        = ff_put_pixels_clamped_sse2;
         c->add_pixels_clamped        = ff_add_pixels_clamped_sse2;
 
+#if ARCH_X86_32
         if (!high_bit_depth &&
             avctx->lowres == 0 &&
             (avctx->idct_algo == FF_IDCT_AUTO ||
@@ -94,6 +90,7 @@
                 c->idct_add  = ff_simple_idct_add_sse2;
                 c->perm_type = FF_IDCT_PERM_SIMPLE;
         }
+#endif
 
         if (ARCH_X86_64 &&
             !high_bit_depth &&
diff -Naur a/media/ffvpx/libavcodec/x86/imdct36.asm b/media/ffvpx/libavcodec/x86/imdct36.asm
--- a/media/ffvpx/libavcodec/x86/imdct36.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/imdct36.asm	2023-04-06 12:49:40.258395091 +0200
@@ -373,11 +373,6 @@
     RET
 %endmacro
 
-%if ARCH_X86_32
-INIT_XMM sse
-DEFINE_IMDCT
-%endif
-
 INIT_XMM sse2
 DEFINE_IMDCT
 
diff -Naur a/media/ffvpx/libavcodec/x86/moz.build b/media/ffvpx/libavcodec/x86/moz.build
--- a/media/ffvpx/libavcodec/x86/moz.build	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/moz.build	2023-04-06 12:49:40.258395091 +0200
@@ -19,7 +19,6 @@
     'idctdsp_init.c',
     'imdct36.asm',
     'mpegaudiodsp.c',
-    'simple_idct.asm',
     'videodsp.asm',
     'videodsp_init.c',
     'vp8dsp.asm',
@@ -39,10 +38,11 @@
     'vp9mc_16bpp.asm',
 ]
 
-if CONFIG['CPU_ARCH'] == "x86_64":
-    SOURCES += [
-        'simple_idct10.asm',
-    ]
+if CONFIG['CPU_ARCH'] == 'x86':
+    SOURCES += [ 'simple_idct.asm' ]
+
+if CONFIG['CPU_ARCH'] == 'x86_64':
+    SOURCES += [ 'simple_idct10.asm' ]
 
 if CONFIG['MOZ_LIBAV_FFT']:
     SOURCES += [
diff -Naur a/media/ffvpx/libavcodec/x86/mpegaudiodsp.c b/media/ffvpx/libavcodec/x86/mpegaudiodsp.c
--- a/media/ffvpx/libavcodec/x86/mpegaudiodsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/mpegaudiodsp.c	2023-04-06 12:49:40.258395091 +0200
@@ -19,9 +19,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stddef.h>
+
+#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
-#include "libavutil/internal.h"
 #include "libavutil/mem_internal.h"
 #include "libavutil/x86/asm.h"
 #include "libavutil/x86/cpu.h"
@@ -32,9 +34,6 @@
 void ff_imdct36_float_ ## CPU(float *out, float *buf, float *in, float *win);
 
 #if HAVE_X86ASM
-#if ARCH_X86_32
-DECL(sse)
-#endif
 DECL(sse2)
 DECL(sse3)
 DECL(ssse3)
@@ -228,9 +227,6 @@
 }
 
 #if HAVE_SSE
-#if ARCH_X86_32
-DECL_IMDCT_BLOCKS(sse,sse)
-#endif
 DECL_IMDCT_BLOCKS(sse2,sse)
 DECL_IMDCT_BLOCKS(sse3,sse)
 DECL_IMDCT_BLOCKS(ssse3,sse)
@@ -269,11 +265,6 @@
 
 #if HAVE_X86ASM
 #if HAVE_SSE
-#if ARCH_X86_32
-    if (EXTERNAL_SSE(cpu_flags)) {
-        s->imdct36_blocks_float = imdct36_blocks_sse;
-    }
-#endif
     if (EXTERNAL_SSE2(cpu_flags)) {
         s->imdct36_blocks_float = imdct36_blocks_sse2;
     }
diff -Naur a/media/ffvpx/libavcodec/x86/simple_idct.asm b/media/ffvpx/libavcodec/x86/simple_idct.asm
--- a/media/ffvpx/libavcodec/x86/simple_idct.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/simple_idct.asm	2023-04-06 12:50:06.975471215 +0200
@@ -27,6 +27,7 @@
 
 SECTION_RODATA
 
+%if ARCH_X86_32
 cextern pb_80
 
 wm1010: dw 0, 0xffff, 0, 0xffff
@@ -846,26 +847,6 @@
     IDCT
 RET
 
-cglobal simple_idct_put, 3, 5, 8, 128, pixels, lsize, block, lsize3, t0
-    IDCT
-    lea lsize3q, [lsizeq*3]
-    PUT_PIXELS_CLAMPED_HALF 0
-    lea pixelsq, [pixelsq+lsizeq*4]
-    PUT_PIXELS_CLAMPED_HALF 64
-RET
-
-cglobal simple_idct_add, 3, 4, 8, 128, pixels, lsize, block, t0
-    IDCT
-    pxor       m4, m4
-    ADD_PIXELS_CLAMPED 0
-    lea        pixelsq, [pixelsq+lsizeq*2]
-    ADD_PIXELS_CLAMPED 32
-    lea        pixelsq, [pixelsq+lsizeq*2]
-    ADD_PIXELS_CLAMPED 64
-    lea        pixelsq, [pixelsq+lsizeq*2]
-    ADD_PIXELS_CLAMPED 96
-RET
-
 INIT_XMM sse2
 
 cglobal simple_idct_put, 3, 5, 8, 128, pixels, lsize, block, lsize3, t0
@@ -887,3 +868,4 @@
     lea        pixelsq, [pixelsq+lsizeq*2]
     ADD_PIXELS_CLAMPED 96
 RET
+%endif
diff -Naur a/media/ffvpx/libavcodec/x86/videodsp.asm b/media/ffvpx/libavcodec/x86/videodsp.asm
--- a/media/ffvpx/libavcodec/x86/videodsp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/videodsp.asm	2023-04-06 12:50:24.493176583 +0200
@@ -45,7 +45,6 @@
     jnz .%1_y_loop
 %endmacro
 
-%macro vvar_fn 0
 ; .----. <- zero
 ; |    |    <- top is copied from first line in body of source
 ; |----| <- start_y
@@ -53,6 +52,7 @@
 ; |----| <- end_y
 ; |    |    <- bottom is copied from last line in body of source
 ; '----' <- bh
+INIT_XMM sse
 %if ARCH_X86_64
 cglobal emu_edge_vvar, 7, 8, 1, dst, dst_stride, src, src_stride, \
                                 start_y, end_y, bh, w
@@ -81,15 +81,6 @@
     V_COPY_ROW   bottom, bhq                    ;   v_copy_row(bottom, bh)
 .end:                                           ; }
     RET
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX mmx
-vvar_fn
-%endif
-
-INIT_XMM sse
-vvar_fn
 
 %macro hvar_fn 0
 cglobal emu_edge_hvar, 5, 6, 1, dst, dst_stride, start_x, n_words, h, w
@@ -105,11 +96,7 @@
     imul             wd, 0x01010101             ;   w *= 0x01010101
     movd             m0, wd
     mov              wq, n_wordsq               ;   initialize w
-%if cpuflag(sse2)
     pshufd           m0, m0, q0000              ;   splat
-%else ; mmx
-    punpckldq        m0, m0                     ;   splat
-%endif ; mmx/sse
 %endif ; avx2
 .x_loop:                                        ;   do {
     movu    [dstq+wq*2], m0                     ;     write($reg, $mmsize)
@@ -123,11 +110,6 @@
     RET
 %endmacro
 
-%if ARCH_X86_32
-INIT_MMX mmx
-hvar_fn
-%endif
-
 INIT_XMM sse2
 hvar_fn
 
@@ -338,9 +320,6 @@
 
 INIT_MMX mmx
 VERTICAL_EXTEND 1, 15
-%if ARCH_X86_32
-VERTICAL_EXTEND 16, 22
-%endif
 
 INIT_XMM sse
 VERTICAL_EXTEND 16, 22
@@ -438,9 +417,6 @@
 
 INIT_MMX mmx
 H_EXTEND 2, 14
-%if ARCH_X86_32
-H_EXTEND 16, 22
-%endif
 
 INIT_XMM sse2
 H_EXTEND 16, 22
@@ -450,19 +426,11 @@
 H_EXTEND 8, 22
 %endif
 
-%macro PREFETCH_FN 1
+INIT_MMX mmxext
 cglobal prefetch, 3, 3, 0, buf, stride, h
 .loop:
-    %1      [bufq]
+    prefetcht0 [bufq]
     add      bufq, strideq
     dec        hd
     jg .loop
-    REP_RET
-%endmacro
-
-INIT_MMX mmxext
-PREFETCH_FN prefetcht0
-%if ARCH_X86_32
-INIT_MMX 3dnow
-PREFETCH_FN prefetch
-%endif
+    RET
diff -Naur a/media/ffvpx/libavcodec/x86/videodsp_init.c b/media/ffvpx/libavcodec/x86/videodsp_init.c
--- a/media/ffvpx/libavcodec/x86/videodsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/videodsp_init.c	2023-04-06 12:50:06.975471215 +0200
@@ -24,7 +24,6 @@
 #include "libavutil/avassert.h"
 #include "libavutil/common.h"
 #include "libavutil/cpu.h"
-#include "libavutil/mem.h"
 #include "libavutil/x86/asm.h"
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/videodsp.h"
@@ -53,26 +52,6 @@
 extern emu_edge_vfix_func ff_emu_edge_vfix13_mmx;
 extern emu_edge_vfix_func ff_emu_edge_vfix14_mmx;
 extern emu_edge_vfix_func ff_emu_edge_vfix15_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix16_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix17_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix18_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix19_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix20_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix21_mmx;
-extern emu_edge_vfix_func ff_emu_edge_vfix22_mmx;
-#if ARCH_X86_32
-static emu_edge_vfix_func * const vfixtbl_mmx[22] = {
-    &ff_emu_edge_vfix1_mmx,  &ff_emu_edge_vfix2_mmx,  &ff_emu_edge_vfix3_mmx,
-    &ff_emu_edge_vfix4_mmx,  &ff_emu_edge_vfix5_mmx,  &ff_emu_edge_vfix6_mmx,
-    &ff_emu_edge_vfix7_mmx,  &ff_emu_edge_vfix8_mmx,  &ff_emu_edge_vfix9_mmx,
-    &ff_emu_edge_vfix10_mmx, &ff_emu_edge_vfix11_mmx, &ff_emu_edge_vfix12_mmx,
-    &ff_emu_edge_vfix13_mmx, &ff_emu_edge_vfix14_mmx, &ff_emu_edge_vfix15_mmx,
-    &ff_emu_edge_vfix16_mmx, &ff_emu_edge_vfix17_mmx, &ff_emu_edge_vfix18_mmx,
-    &ff_emu_edge_vfix19_mmx, &ff_emu_edge_vfix20_mmx, &ff_emu_edge_vfix21_mmx,
-    &ff_emu_edge_vfix22_mmx
-};
-#endif
-extern emu_edge_vvar_func ff_emu_edge_vvar_mmx;
 extern emu_edge_vfix_func ff_emu_edge_vfix16_sse;
 extern emu_edge_vfix_func ff_emu_edge_vfix17_sse;
 extern emu_edge_vfix_func ff_emu_edge_vfix18_sse;
@@ -104,19 +83,6 @@
 extern emu_edge_hfix_func ff_emu_edge_hfix10_mmx;
 extern emu_edge_hfix_func ff_emu_edge_hfix12_mmx;
 extern emu_edge_hfix_func ff_emu_edge_hfix14_mmx;
-extern emu_edge_hfix_func ff_emu_edge_hfix16_mmx;
-extern emu_edge_hfix_func ff_emu_edge_hfix18_mmx;
-extern emu_edge_hfix_func ff_emu_edge_hfix20_mmx;
-extern emu_edge_hfix_func ff_emu_edge_hfix22_mmx;
-#if ARCH_X86_32
-static emu_edge_hfix_func * const hfixtbl_mmx[11] = {
-    ff_emu_edge_hfix2_mmx,  ff_emu_edge_hfix4_mmx,  ff_emu_edge_hfix6_mmx,
-    ff_emu_edge_hfix8_mmx,  ff_emu_edge_hfix10_mmx, ff_emu_edge_hfix12_mmx,
-    ff_emu_edge_hfix14_mmx, ff_emu_edge_hfix16_mmx, ff_emu_edge_hfix18_mmx,
-    ff_emu_edge_hfix20_mmx, ff_emu_edge_hfix22_mmx
-};
-#endif
-extern emu_edge_hvar_func ff_emu_edge_hvar_mmx;
 extern emu_edge_hfix_func ff_emu_edge_hfix16_sse2;
 extern emu_edge_hfix_func ff_emu_edge_hfix18_sse2;
 extern emu_edge_hfix_func ff_emu_edge_hfix20_sse2;
@@ -222,30 +188,6 @@
     }
 }
 
-#if ARCH_X86_32
-static av_noinline void emulated_edge_mc_mmx(uint8_t *buf, const uint8_t *src,
-                                             ptrdiff_t buf_stride,
-                                             ptrdiff_t src_stride,
-                                             int block_w, int block_h,
-                                             int src_x, int src_y, int w, int h)
-{
-    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
-                     src_x, src_y, w, h, vfixtbl_mmx, &ff_emu_edge_vvar_mmx,
-                     hfixtbl_mmx, &ff_emu_edge_hvar_mmx);
-}
-
-static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,
-                                             ptrdiff_t buf_stride,
-                                             ptrdiff_t src_stride,
-                                             int block_w, int block_h,
-                                             int src_x, int src_y, int w, int h)
-{
-    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
-                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
-                     hfixtbl_mmx, &ff_emu_edge_hvar_mmx);
-}
-#endif
-
 static av_noinline void emulated_edge_mc_sse2(uint8_t *buf, const uint8_t *src,
                                               ptrdiff_t buf_stride,
                                               ptrdiff_t src_stride,
@@ -273,30 +215,16 @@
 #endif /* HAVE_AVX2_EXTERNAL */
 #endif /* HAVE_X86ASM */
 
-void ff_prefetch_mmxext(uint8_t *buf, ptrdiff_t stride, int h);
-void ff_prefetch_3dnow(uint8_t *buf, ptrdiff_t stride, int h);
+void ff_prefetch_mmxext(const uint8_t *buf, ptrdiff_t stride, int h);
 
 av_cold void ff_videodsp_init_x86(VideoDSPContext *ctx, int bpc)
 {
 #if HAVE_X86ASM
     int cpu_flags = av_get_cpu_flags();
 
-#if ARCH_X86_32
-    if (EXTERNAL_MMX(cpu_flags) && bpc <= 8) {
-        ctx->emulated_edge_mc = emulated_edge_mc_mmx;
-    }
-    if (EXTERNAL_AMD3DNOW(cpu_flags)) {
-        ctx->prefetch = ff_prefetch_3dnow;
-    }
-#endif /* ARCH_X86_32 */
     if (EXTERNAL_MMXEXT(cpu_flags)) {
         ctx->prefetch = ff_prefetch_mmxext;
     }
-#if ARCH_X86_32
-    if (EXTERNAL_SSE(cpu_flags) && bpc <= 8) {
-        ctx->emulated_edge_mc = emulated_edge_mc_sse;
-    }
-#endif /* ARCH_X86_32 */
     if (EXTERNAL_SSE2(cpu_flags) && bpc <= 8) {
         ctx->emulated_edge_mc = emulated_edge_mc_sse2;
     }
diff -Naur a/media/ffvpx/libavcodec/x86/vp56_arith.h b/media/ffvpx/libavcodec/x86/vp56_arith.h
--- a/media/ffvpx/libavcodec/x86/vp56_arith.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp56_arith.h	2023-04-06 12:49:40.258395091 +0200
@@ -25,6 +25,8 @@
 #define AVCODEC_X86_VP56_ARITH_H
 
 #if HAVE_INLINE_ASM && HAVE_FAST_CMOV && HAVE_6REGS
+#include "libavutil/attributes.h"
+
 #define vp56_rac_get_prob vp56_rac_get_prob
 static av_always_inline int vp56_rac_get_prob(VP56RangeCoder *c, uint8_t prob)
 {
diff -Naur a/media/ffvpx/libavcodec/x86/vp8dsp.asm b/media/ffvpx/libavcodec/x86/vp8dsp.asm
--- a/media/ffvpx/libavcodec/x86/vp8dsp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp8dsp.asm	2023-04-06 12:50:24.493176583 +0200
@@ -157,7 +157,7 @@
 ; subpel MC functions:
 ;
 ; void ff_put_vp8_epel<size>_h<htap>v<vtap>_<opt>(uint8_t *dst, ptrdiff_t deststride,
-;                                                 uint8_t *src, ptrdiff_t srcstride,
+;                                                 const uint8_t *src, ptrdiff_t srcstride,
 ;                                                 int height,   int mx, int my);
 ;-------------------------------------------------------------------------------
 
@@ -200,7 +200,7 @@
     add     srcq, srcstrideq
     dec  heightd            ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 cglobal put_vp8_epel%1_h4, 6, 6 + npicregs, 7, dst, dststride, src, srcstride, height, mx, picreg
     shl      mxd, 4
@@ -230,7 +230,7 @@
     add     srcq, srcstrideq
     dec  heightd            ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 cglobal put_vp8_epel%1_v4, 7, 7, 8, dst, dststride, src, srcstride, height, picreg, my
     shl      myd, 4
@@ -268,7 +268,7 @@
     add      srcq, srcstrideq
     dec   heightd                          ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 cglobal put_vp8_epel%1_v6, 7, 7, 8, dst, dststride, src, srcstride, height, picreg, my
     lea      myd, [myq*3]
@@ -314,7 +314,7 @@
     add      srcq, srcstrideq
     dec   heightd                          ; next row
     jg .nextrow
-    REP_RET
+    RET
 %endmacro
 
 INIT_MMX ssse3
@@ -368,7 +368,7 @@
     add      srcq, srcstrideq
     dec   heightd                          ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 ; 4x4 block, H-only 6-tap filter
 INIT_MMX mmxext
@@ -426,7 +426,7 @@
     add      srcq, srcstrideq
     dec   heightd                          ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 INIT_XMM sse2
 cglobal put_vp8_epel8_h4, 6, 6 + npicregs, 10, dst, dststride, src, srcstride, height, mx, picreg
@@ -474,7 +474,7 @@
     add     srcq, srcstrideq
     dec  heightd            ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 INIT_XMM sse2
 cglobal put_vp8_epel8_h6, 6, 6 + npicregs, 14, dst, dststride, src, srcstride, height, mx, picreg
@@ -537,7 +537,7 @@
     add     srcq, srcstrideq
     dec  heightd            ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 %macro FILTER_V 1
 ; 4x4 block, V-only 4-tap filter
@@ -590,7 +590,7 @@
     add     srcq, srcstrideq
     dec  heightd                           ; next row
     jg .nextrow
-    REP_RET
+    RET
 
 
 ; 4x4 block, V-only 6-tap filter
@@ -655,7 +655,7 @@
     add     srcq, srcstrideq
     dec  heightd                           ; next row
     jg .nextrow
-    REP_RET
+    RET
 %endmacro
 
 INIT_MMX mmxext
@@ -738,7 +738,7 @@
     lea     srcq, [srcq+srcstrideq*2]
     sub  heightd, 2
     jg .nextrow
-    REP_RET
+    RET
 
 %if cpuflag(ssse3)
 cglobal put_vp8_bilinear%1_h, 6, 6 + npicregs, 5, dst, dststride, src, srcstride, height, mx, picreg
@@ -815,7 +815,7 @@
     lea     srcq, [srcq+srcstrideq*2]
     sub  heightd, 2
     jg .nextrow
-    REP_RET
+    RET
 %endmacro
 
 INIT_MMX mmxext
@@ -838,26 +838,7 @@
     lea    dstq, [dstq+dststrideq*2]
     sub heightd, 2
     jg .nextrow
-    REP_RET
-
-%if ARCH_X86_32
-INIT_MMX mmx
-cglobal put_vp8_pixels16, 5, 5, 0, dst, dststride, src, srcstride, height
-.nextrow:
-    movq    mm0, [srcq+srcstrideq*0+0]
-    movq    mm1, [srcq+srcstrideq*0+8]
-    movq    mm2, [srcq+srcstrideq*1+0]
-    movq    mm3, [srcq+srcstrideq*1+8]
-    lea    srcq, [srcq+srcstrideq*2]
-    movq [dstq+dststrideq*0+0], mm0
-    movq [dstq+dststrideq*0+8], mm1
-    movq [dstq+dststrideq*1+0], mm2
-    movq [dstq+dststrideq*1+8], mm3
-    lea    dstq, [dstq+dststrideq*2]
-    sub heightd, 2
-    jg .nextrow
-    REP_RET
-%endif
+    RET
 
 INIT_XMM sse
 cglobal put_vp8_pixels16, 5, 5, 2, dst, dststride, src, srcstride, height
@@ -870,7 +851,7 @@
     lea    dstq, [dstq+dststrideq*2]
     sub heightd, 2
     jg .nextrow
-    REP_RET
+    RET
 
 ;-----------------------------------------------------------------------------
 ; void ff_vp8_idct_dc_add_<opt>(uint8_t *dst, int16_t block[16], ptrdiff_t stride);
@@ -895,32 +876,6 @@
     %4 [dst2q+strideq+%3], m5
 %endmacro
 
-%if ARCH_X86_32
-INIT_MMX mmx
-cglobal vp8_idct_dc_add, 3, 3, 0, dst, block, stride
-    ; load data
-    movd       m0, [blockq]
-
-    ; calculate DC
-    paddw      m0, [pw_4]
-    pxor       m1, m1
-    psraw      m0, 3
-    movd [blockq], m1
-    psubw      m1, m0
-    packuswb   m0, m0
-    packuswb   m1, m1
-    punpcklbw  m0, m0
-    punpcklbw  m1, m1
-    punpcklwd  m0, m0
-    punpcklwd  m1, m1
-
-    ; add DC
-    DEFINE_ARGS dst1, dst2, stride
-    lea     dst2q, [dst1q+strideq*2]
-    ADD_DC     m0, m1, 0, movh
-    RET
-%endif
-
 %macro VP8_IDCT_DC_ADD 0
 cglobal vp8_idct_dc_add, 3, 3, 6, dst, block, stride
     ; load data
@@ -971,44 +926,6 @@
 ; void ff_vp8_idct_dc_add4y_<opt>(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride);
 ;-----------------------------------------------------------------------------
 
-%if ARCH_X86_32
-INIT_MMX mmx
-cglobal vp8_idct_dc_add4y, 3, 3, 0, dst, block, stride
-    ; load data
-    movd      m0, [blockq+32*0] ; A
-    movd      m1, [blockq+32*2] ; C
-    punpcklwd m0, [blockq+32*1] ; A B
-    punpcklwd m1, [blockq+32*3] ; C D
-    punpckldq m0, m1        ; A B C D
-    pxor      m6, m6
-
-    ; calculate DC
-    paddw     m0, [pw_4]
-    movd [blockq+32*0], m6
-    movd [blockq+32*1], m6
-    movd [blockq+32*2], m6
-    movd [blockq+32*3], m6
-    psraw     m0, 3
-    psubw     m6, m0
-    packuswb  m0, m0
-    packuswb  m6, m6
-    punpcklbw m0, m0 ; AABBCCDD
-    punpcklbw m6, m6 ; AABBCCDD
-    movq      m1, m0
-    movq      m7, m6
-    punpcklbw m0, m0 ; AAAABBBB
-    punpckhbw m1, m1 ; CCCCDDDD
-    punpcklbw m6, m6 ; AAAABBBB
-    punpckhbw m7, m7 ; CCCCDDDD
-
-    ; add DC
-    DEFINE_ARGS dst1, dst2, stride
-    lea    dst2q, [dst1q+strideq*2]
-    ADD_DC    m0, m6, 0, mova
-    ADD_DC    m1, m7, 8, mova
-    RET
-%endif
-
 INIT_XMM sse2
 cglobal vp8_idct_dc_add4y, 3, 3, 6, dst, block, stride
     ; load data
@@ -1117,7 +1034,7 @@
     SWAP                 %4,  %3
 %endmacro
 
-%macro VP8_IDCT_ADD 0
+INIT_MMX sse
 cglobal vp8_idct_add, 3, 3, 0, dst, block, stride
     ; load block data
     movq         m0, [blockq+ 0]
@@ -1126,17 +1043,9 @@
     movq         m3, [blockq+24]
     movq         m6, [pw_20091]
     movq         m7, [pw_17734]
-%if cpuflag(sse)
     xorps      xmm0, xmm0
     movaps [blockq+ 0], xmm0
     movaps [blockq+16], xmm0
-%else
-    pxor         m4, m4
-    movq [blockq+ 0], m4
-    movq [blockq+ 8], m4
-    movq [blockq+16], m4
-    movq [blockq+24], m4
-%endif
 
     ; actual IDCT
     VP8_IDCT_TRANSFORM4x4_1D 0, 1, 2, 3, 4, 5
@@ -1153,14 +1062,6 @@
     STORE_DIFFx2 m2, m3, m6, m7, m4, 3, dst2q, strideq
 
     RET
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX mmx
-VP8_IDCT_ADD
-%endif
-INIT_MMX sse
-VP8_IDCT_ADD
 
 ;-----------------------------------------------------------------------------
 ; void ff_vp8_luma_dc_wht(int16_t block[4][4][16], int16_t dc[16])
@@ -1193,23 +1094,15 @@
     SWAP %1, %4, %3
 %endmacro
 
-%macro VP8_DC_WHT 0
+INIT_MMX sse
 cglobal vp8_luma_dc_wht, 2, 3, 0, block, dc1, dc2
     movq          m0, [dc1q]
     movq          m1, [dc1q+8]
     movq          m2, [dc1q+16]
     movq          m3, [dc1q+24]
-%if cpuflag(sse)
     xorps      xmm0, xmm0
     movaps [dc1q+ 0], xmm0
     movaps [dc1q+16], xmm0
-%else
-    pxor         m4, m4
-    movq  [dc1q+ 0], m4
-    movq  [dc1q+ 8], m4
-    movq  [dc1q+16], m4
-    movq  [dc1q+24], m4
-%endif
     HADAMARD4_1D  0, 1, 2, 3
     TRANSPOSE4x4W 0, 1, 2, 3, 4
     paddw         m0, [pw_3]
@@ -1221,11 +1114,3 @@
     SCATTER_WHT   0, 1, 0
     SCATTER_WHT   2, 3, 2
     RET
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX mmx
-VP8_DC_WHT
-%endif
-INIT_MMX sse
-VP8_DC_WHT
diff -Naur a/media/ffvpx/libavcodec/x86/vp8dsp_init.c b/media/ffvpx/libavcodec/x86/vp8dsp_init.c
--- a/media/ffvpx/libavcodec/x86/vp8dsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp8dsp_init.c	2023-04-06 12:50:06.975471215 +0200
@@ -22,7 +22,6 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
-#include "libavutil/mem.h"
 #include "libavutil/mem_internal.h"
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/vp8dsp.h"
@@ -33,96 +32,93 @@
  * MC functions
  */
 void ff_put_vp8_epel4_h4_mmxext(uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel4_h6_mmxext(uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel4_v4_mmxext(uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel4_v6_mmxext(uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 
 void ff_put_vp8_epel8_h4_sse2  (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_h6_sse2  (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_v4_sse2  (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_v6_sse2  (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 
 void ff_put_vp8_epel4_h4_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel4_h6_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel4_v4_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel4_v6_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_h4_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_h6_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_v4_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 void ff_put_vp8_epel8_v6_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                uint8_t *src, ptrdiff_t srcstride,
+                                const uint8_t *src, ptrdiff_t srcstride,
                                 int height, int mx, int my);
 
 void ff_put_vp8_bilinear4_h_mmxext(uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 void ff_put_vp8_bilinear8_h_sse2  (uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 void ff_put_vp8_bilinear4_h_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 void ff_put_vp8_bilinear8_h_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 
 void ff_put_vp8_bilinear4_v_mmxext(uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 void ff_put_vp8_bilinear8_v_sse2  (uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 void ff_put_vp8_bilinear4_v_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 void ff_put_vp8_bilinear8_v_ssse3 (uint8_t *dst, ptrdiff_t dststride,
-                                   uint8_t *src, ptrdiff_t srcstride,
+                                   const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int mx, int my);
 
 
 void ff_put_vp8_pixels8_mmx (uint8_t *dst, ptrdiff_t dststride,
-                             uint8_t *src, ptrdiff_t srcstride,
-                             int height, int mx, int my);
-void ff_put_vp8_pixels16_mmx(uint8_t *dst, ptrdiff_t dststride,
-                             uint8_t *src, ptrdiff_t srcstride,
+                             const uint8_t *src, ptrdiff_t srcstride,
                              int height, int mx, int my);
 void ff_put_vp8_pixels16_sse(uint8_t *dst, ptrdiff_t dststride,
-                             uint8_t *src, ptrdiff_t srcstride,
+                             const uint8_t *src, ptrdiff_t srcstride,
                              int height, int mx, int my);
 
 #define TAP_W16(OPT, FILTERTYPE, TAPTYPE) \
 static void ff_put_vp8_ ## FILTERTYPE ## 16_ ## TAPTYPE ## _ ## OPT( \
-    uint8_t *dst,  ptrdiff_t dststride, uint8_t *src, \
+    uint8_t *dst,  ptrdiff_t dststride, const uint8_t *src, \
     ptrdiff_t srcstride, int height, int mx, int my) \
 { \
     ff_put_vp8_ ## FILTERTYPE ## 8_ ## TAPTYPE ## _ ## OPT( \
@@ -141,19 +137,6 @@
         dst + 4, dststride, src + 4, srcstride, height, mx, my); \
 }
 
-#if ARCH_X86_32
-TAP_W8 (mmxext, epel, h4)
-TAP_W8 (mmxext, epel, h6)
-TAP_W16(mmxext, epel, h6)
-TAP_W8 (mmxext, epel, v4)
-TAP_W8 (mmxext, epel, v6)
-TAP_W16(mmxext, epel, v6)
-TAP_W8 (mmxext, bilinear, h)
-TAP_W16(mmxext, bilinear, h)
-TAP_W8 (mmxext, bilinear, v)
-TAP_W16(mmxext, bilinear, v)
-#endif
-
 TAP_W16(sse2,  epel, h6)
 TAP_W16(sse2,  epel, v6)
 TAP_W16(sse2,  bilinear, h)
@@ -166,7 +149,7 @@
 
 #define HVTAP(OPT, ALIGN, TAPNUMX, TAPNUMY, SIZE, MAXHEIGHT) \
 static void ff_put_vp8_epel ## SIZE ## _h ## TAPNUMX ## v ## TAPNUMY ## _ ## OPT( \
-    uint8_t *dst, ptrdiff_t dststride, uint8_t *src, \
+    uint8_t *dst, ptrdiff_t dststride, const uint8_t *src, \
     ptrdiff_t srcstride, int height, int mx, int my) \
 { \
     LOCAL_ALIGNED(ALIGN, uint8_t, tmp, [SIZE * (MAXHEIGHT + TAPNUMY - 1)]); \
@@ -178,16 +161,8 @@
         dst, dststride, tmpptr, SIZE,      height,               mx, my); \
 }
 
-#if ARCH_X86_32
-#define HVTAPMMX(x, y) \
-HVTAP(mmxext, 8, x, y,  4,  8) \
-HVTAP(mmxext, 8, x, y,  8, 16)
-
-HVTAP(mmxext, 8, 6, 6, 16, 16)
-#else
 #define HVTAPMMX(x, y) \
 HVTAP(mmxext, 8, x, y,  4,  8)
-#endif
 
 HVTAPMMX(4, 4)
 HVTAPMMX(4, 6)
@@ -211,7 +186,7 @@
 
 #define HVBILIN(OPT, ALIGN, SIZE, MAXHEIGHT) \
 static void ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT( \
-    uint8_t *dst, ptrdiff_t dststride, uint8_t *src, \
+    uint8_t *dst, ptrdiff_t dststride, const uint8_t *src, \
     ptrdiff_t srcstride, int height, int mx, int my) \
 { \
     LOCAL_ALIGNED(ALIGN, uint8_t, tmp, [SIZE * (MAXHEIGHT + 2)]); \
@@ -222,31 +197,21 @@
 }
 
 HVBILIN(mmxext,  8,  4,  8)
-#if ARCH_X86_32
-HVBILIN(mmxext,  8,  8, 16)
-HVBILIN(mmxext,  8, 16, 16)
-#endif
 HVBILIN(sse2,  8,  8, 16)
 HVBILIN(sse2,  8, 16, 16)
 HVBILIN(ssse3, 8,  4,  8)
 HVBILIN(ssse3, 8,  8, 16)
 HVBILIN(ssse3, 8, 16, 16)
 
-void ff_vp8_idct_dc_add_mmx(uint8_t *dst, int16_t block[16],
-                            ptrdiff_t stride);
 void ff_vp8_idct_dc_add_sse2(uint8_t *dst, int16_t block[16],
                              ptrdiff_t stride);
 void ff_vp8_idct_dc_add_sse4(uint8_t *dst, int16_t block[16],
                              ptrdiff_t stride);
-void ff_vp8_idct_dc_add4y_mmx(uint8_t *dst, int16_t block[4][16],
-                               ptrdiff_t stride);
 void ff_vp8_idct_dc_add4y_sse2(uint8_t *dst, int16_t block[4][16],
                                ptrdiff_t stride);
 void ff_vp8_idct_dc_add4uv_mmx(uint8_t *dst, int16_t block[2][16],
                                ptrdiff_t stride);
-void ff_vp8_luma_dc_wht_mmx(int16_t block[4][4][16], int16_t dc[16]);
 void ff_vp8_luma_dc_wht_sse(int16_t block[4][4][16], int16_t dc[16]);
-void ff_vp8_idct_add_mmx(uint8_t *dst, int16_t block[16], ptrdiff_t stride);
 void ff_vp8_idct_add_sse(uint8_t *dst, int16_t block[16], ptrdiff_t stride);
 
 #define DECLARE_LOOP_FILTER(NAME)                                       \
@@ -285,8 +250,6 @@
                                              ptrdiff_t s,               \
                                              int e, int i, int hvt);
 
-DECLARE_LOOP_FILTER(mmx)
-DECLARE_LOOP_FILTER(mmxext)
 DECLARE_LOOP_FILTER(sse2)
 DECLARE_LOOP_FILTER(ssse3)
 DECLARE_LOOP_FILTER(sse4)
@@ -323,10 +286,6 @@
     int cpu_flags = av_get_cpu_flags();
 
     if (EXTERNAL_MMX(cpu_flags)) {
-#if ARCH_X86_32
-        c->put_vp8_epel_pixels_tab[0][0][0]     =
-        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;
-#endif
         c->put_vp8_epel_pixels_tab[1][0][0]     =
         c->put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;
     }
@@ -336,12 +295,6 @@
     if (EXTERNAL_MMXEXT(cpu_flags)) {
         VP8_MC_FUNC(2, 4, mmxext);
         VP8_BILINEAR_MC_FUNC(2, 4, mmxext);
-#if ARCH_X86_32
-        VP8_LUMA_MC_FUNC(0, 16, mmxext);
-        VP8_MC_FUNC(1, 8, mmxext);
-        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);
-        VP8_BILINEAR_MC_FUNC(1,  8, mmxext);
-#endif
     }
 
     if (EXTERNAL_SSE(cpu_flags)) {
@@ -349,7 +302,7 @@
         c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;
     }
 
-    if (EXTERNAL_SSE2(cpu_flags) || EXTERNAL_SSE2_SLOW(cpu_flags)) {
+    if (EXTERNAL_SSE2_SLOW(cpu_flags)) {
         VP8_LUMA_MC_FUNC(0, 16, sse2);
         VP8_MC_FUNC(1, 8, sse2);
         VP8_BILINEAR_MC_FUNC(0, 16, sse2);
@@ -374,44 +327,6 @@
 
     if (EXTERNAL_MMX(cpu_flags)) {
         c->vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;
-#if ARCH_X86_32
-        c->vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;
-        c->vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;
-        c->vp8_idct_add       = ff_vp8_idct_add_mmx;
-        c->vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;
-
-        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;
-        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;
-
-        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;
-        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;
-        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;
-        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;
-
-        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;
-        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;
-        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;
-        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;
-#endif
-    }
-
-    /* note that 4-tap width=16 functions are missing because w=16
-     * is only used for luma, and luma is always a copy or sixtap. */
-    if (EXTERNAL_MMXEXT(cpu_flags)) {
-#if ARCH_X86_32
-        c->vp8_v_loop_filter_simple   = ff_vp8_v_loop_filter_simple_mmxext;
-        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_mmxext;
-
-        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;
-        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;
-        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;
-        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;
-
-        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;
-        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;
-        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;
-        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;
-#endif
     }
 
     if (EXTERNAL_SSE(cpu_flags)) {
@@ -419,7 +334,7 @@
         c->vp8_luma_dc_wht                      = ff_vp8_luma_dc_wht_sse;
     }
 
-    if (EXTERNAL_SSE2(cpu_flags) || EXTERNAL_SSE2_SLOW(cpu_flags)) {
+    if (EXTERNAL_SSE2_SLOW(cpu_flags)) {
         c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;
 
         c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;
diff -Naur a/media/ffvpx/libavcodec/x86/vp8dsp_loopfilter.asm b/media/ffvpx/libavcodec/x86/vp8dsp_loopfilter.asm
--- a/media/ffvpx/libavcodec/x86/vp8dsp_loopfilter.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp8dsp_loopfilter.asm	2023-04-06 12:49:40.258395091 +0200
@@ -46,30 +46,6 @@
 ; void ff_vp8_h/v_loop_filter_simple_<opt>(uint8_t *dst, ptrdiff_t stride, int flim);
 ;-----------------------------------------------------------------------------
 
-; macro called with 7 mm register indexes as argument, and 4 regular registers
-;
-; first 4 mm registers will carry the transposed pixel data
-; the other three are scratchspace (one would be sufficient, but this allows
-; for more spreading/pipelining and thus faster execution on OOE CPUs)
-;
-; first two regular registers are buf+4*stride and buf+5*stride
-; third is -stride, fourth is +stride
-%macro READ_8x4_INTERLEAVED 11
-    ; interleave 8 (A-H) rows of 4 pixels each
-    movd          m%1, [%8+%10*4]   ; A0-3
-    movd          m%5, [%9+%10*4]   ; B0-3
-    movd          m%2, [%8+%10*2]   ; C0-3
-    movd          m%6, [%8+%10]     ; D0-3
-    movd          m%3, [%8]         ; E0-3
-    movd          m%7, [%9]         ; F0-3
-    movd          m%4, [%9+%11]     ; G0-3
-    punpcklbw     m%1, m%5          ; A/B interleaved
-    movd          m%5, [%9+%11*2]   ; H0-3
-    punpcklbw     m%2, m%6          ; C/D interleaved
-    punpcklbw     m%3, m%7          ; E/F interleaved
-    punpcklbw     m%4, m%5          ; G/H interleaved
-%endmacro
-
 ; macro called with 7 mm register indexes as argument, and 5 regular registers
 ; first 11 mean the same as READ_8x4_TRANSPOSED above
 ; fifth regular register is scratchspace to reach the bottom 8 rows, it
@@ -112,26 +88,6 @@
     punpcklbw    m%4, m%5          ; G/H/O/P interleaved
 %endmacro
 
-; write 4 mm registers of 2 dwords each
-; first four arguments are mm register indexes containing source data
-; last four are registers containing buf+4*stride, buf+5*stride,
-; -stride and +stride
-%macro WRITE_4x2D 8
-    ; write out (2 dwords per register)
-    movd    [%5+%7*4], m%1
-    movd    [%5+%7*2], m%2
-    movd         [%5], m%3
-    movd      [%6+%8], m%4
-    punpckhdq     m%1, m%1
-    punpckhdq     m%2, m%2
-    punpckhdq     m%3, m%3
-    punpckhdq     m%4, m%4
-    movd    [%6+%7*4], m%1
-    movd      [%5+%7], m%2
-    movd         [%6], m%3
-    movd    [%6+%8*2], m%4
-%endmacro
-
 ; write 4 xmm registers of 4 dwords each
 ; arguments same as WRITE_2x4D, but with an extra register, so that the 5 regular
 ; registers contain buf+4*stride, buf+5*stride, buf+12*stride, -stride and +stride
@@ -192,42 +148,6 @@
     movd    [%7+%9*2], m%4
 %endmacro
 
-; write 4 or 8 words in the mmx/xmm registers as 8 lines
-; 1 and 2 are the registers to write, this can be the same (for SSE2)
-; for pre-SSE4:
-; 3 is a general-purpose register that we will clobber
-; for SSE4:
-; 3 is a pointer to the destination's 5th line
-; 4 is a pointer to the destination's 4th line
-; 5/6 is -stride and +stride
-%macro WRITE_2x4W 6
-    movd            %3d, %1
-    punpckhdq        %1, %1
-    mov       [%4+%5*4], %3w
-    shr              %3, 16
-    add              %4, %6
-    mov       [%4+%5*4], %3w
-
-    movd            %3d, %1
-    add              %4, %5
-    mov       [%4+%5*2], %3w
-    shr              %3, 16
-    mov       [%4+%5  ], %3w
-
-    movd            %3d, %2
-    punpckhdq        %2, %2
-    mov       [%4     ], %3w
-    shr              %3, 16
-    mov       [%4+%6  ], %3w
-
-    movd            %3d, %2
-    add              %4, %6
-    mov       [%4+%6  ], %3w
-    shr              %3, 16
-    mov       [%4+%6*2], %3w
-    add              %4, %5
-%endmacro
-
 %macro WRITE_8W 5
 %if cpuflag(sse4)
     pextrw    [%3+%4*4], %1, 0
@@ -269,29 +189,19 @@
 
 %macro SIMPLE_LOOPFILTER 2
 cglobal vp8_%1_loop_filter_simple, 3, %2, 8, dst, stride, flim, cntr
-%if mmsize == 8 ; mmx/mmxext
-    mov         cntrq, 2
-%endif
 %if cpuflag(ssse3)
     pxor           m0, m0
 %endif
     SPLATB_REG     m7, flim, m0     ; splat "flim" into register
 
     ; set up indexes to address 4 rows
-%if mmsize == 8
-    DEFINE_ARGS dst1, mstride, stride, cntr, dst2
-%else
     DEFINE_ARGS dst1, mstride, stride, dst3, dst2
-%endif
     mov       strideq, mstrideq
     neg      mstrideq
 %ifidn %1, h
     lea         dst1q, [dst1q+4*strideq-2]
 %endif
 
-%if mmsize == 8 ; mmx / mmxext
-.next8px:
-%endif
 %ifidn %1, v
     ; read 4 half/full rows of pixels
     mova           m0, [dst1q+mstrideq*2]    ; p1
@@ -301,11 +211,7 @@
 %else ; h
     lea         dst2q, [dst1q+ strideq]
 
-%if mmsize == 8 ; mmx/mmxext
-    READ_8x4_INTERLEAVED  0, 1, 2, 3, 4, 5, 6, dst1q, dst2q, mstrideq, strideq
-%else ; sse2
     READ_16x4_INTERLEAVED 0, 1, 2, 3, 4, 5, 6, dst1q, dst2q, mstrideq, strideq, dst3q
-%endif
     TRANSPOSE4x4W         0, 1, 2, 3, 4
 %endif
 
@@ -380,7 +286,6 @@
     inc        dst1q
     SBUTTERFLY    bw, 6, 4, 0
 
-%if mmsize == 16 ; sse2
 %if cpuflag(sse4)
     inc         dst2q
 %endif
@@ -390,35 +295,11 @@
     inc         dst3q
 %endif
     WRITE_8W       m4, dst3q, dst2q, mstrideq, strideq
-%else ; mmx/mmxext
-    WRITE_2x4W     m6, m4, dst2q, dst1q, mstrideq, strideq
-%endif
 %endif
 
-%if mmsize == 8 ; mmx/mmxext
-    ; next 8 pixels
-%ifidn %1, v
-    add         dst1q, 8            ; advance 8 cols = pixels
-%else ; h
-    lea         dst1q, [dst1q+strideq*8-1]  ; advance 8 rows = lines
-%endif
-    dec         cntrq
-    jg .next8px
-    REP_RET
-%else ; sse2
     RET
-%endif
 %endmacro
 
-%if ARCH_X86_32
-INIT_MMX mmx
-SIMPLE_LOOPFILTER v, 4
-SIMPLE_LOOPFILTER h, 5
-INIT_MMX mmxext
-SIMPLE_LOOPFILTER v, 4
-SIMPLE_LOOPFILTER h, 5
-%endif
-
 INIT_XMM sse2
 SIMPLE_LOOPFILTER v, 3
 SIMPLE_LOOPFILTER h, 5
@@ -485,9 +366,6 @@
 
 %if %2 == 8 ; chroma
     DEFINE_ARGS dst1, dst8, mstride, stride, dst2
-%elif mmsize == 8
-    DEFINE_ARGS dst1, mstride, stride, dst2, cntr
-    mov           cntrq, 2
 %else
     DEFINE_ARGS dst1, mstride, stride, dst2, dst8
 %endif
@@ -500,9 +378,6 @@
 %endif
 %endif
 
-%if mmsize == 8
-.next8px:
-%endif
     ; read
     lea           dst2q, [dst1q+strideq]
 %ifidn %1, v
@@ -527,33 +402,7 @@
     movhps           m7, [dst8q+ strideq*2]
     add           dst8q, mstrideq
 %endif
-%elif mmsize == 8 ; mmx/mmxext (h)
-    ; read 8 rows of 8px each
-    movu             m0, [dst1q+mstrideq*4]
-    movu             m1, [dst2q+mstrideq*4]
-    movu             m2, [dst1q+mstrideq*2]
-    movu             m3, [dst1q+mstrideq  ]
-    movu             m4, [dst1q]
-    movu             m5, [dst2q]
-    movu             m6, [dst2q+ strideq  ]
-
-    ; 8x8 transpose
-    TRANSPOSE4x4B     0, 1, 2, 3, 7
-    mova     m_q0backup, m1
-    movu             m7, [dst2q+ strideq*2]
-    TRANSPOSE4x4B     4, 5, 6, 7, 1
-    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
-    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
-    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
-    mova             m1, m_q0backup
-    mova     m_q0backup, m2          ; store q0
-    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
-    mova     m_p0backup, m5          ; store p0
-    SWAP              1, 4
-    SWAP              2, 4
-    SWAP              6, 3
-    SWAP              5, 3
-%else ; sse2 (h)
+%else ; h
 %if %2 == 16
     lea           dst8q, [dst1q+ strideq*8]
 %endif
@@ -641,25 +490,9 @@
     psubusb          m6, m5          ; q2-q1
     por              m6, m4          ; abs(q2-q1)
 
-%if notcpuflag(mmxext)
-    mova             m4, m_flimI
-    pxor             m3, m3
-    psubusb          m0, m4
-    psubusb          m1, m4
-    psubusb          m7, m4
-    psubusb          m6, m4
-    pcmpeqb          m0, m3          ; abs(p3-p2) <= I
-    pcmpeqb          m1, m3          ; abs(p2-p1) <= I
-    pcmpeqb          m7, m3          ; abs(q3-q2) <= I
-    pcmpeqb          m6, m3          ; abs(q2-q1) <= I
-    pand             m0, m1
-    pand             m7, m6
-    pand             m0, m7
-%else ; mmxext/sse2
     pmaxub           m0, m1
     pmaxub           m6, m7
     pmaxub           m0, m6
-%endif
 
     ; normal_limit and high_edge_variance for p1-p0, q1-q0
     SWAP              7, 3           ; now m7 is zero
@@ -681,18 +514,8 @@
     psubusb          m1, m3          ; p1-p0
     psubusb          m6, m2          ; p0-p1
     por              m1, m6          ; abs(p1-p0)
-%if notcpuflag(mmxext)
-    mova             m6, m1
-    psubusb          m1, m4
-    psubusb          m6, m_hevthr
-    pcmpeqb          m1, m7          ; abs(p1-p0) <= I
-    pcmpeqb          m6, m7          ; abs(p1-p0) <= hev_thresh
-    pand             m0, m1
-    mova      m_maskres, m6
-%else ; mmxext/sse2
     pmaxub           m0, m1          ; max_I
     SWAP              1, 4           ; max_hev_thresh
-%endif
 
     SWAP              6, 4           ; now m6 is I
 %ifidn %1, v
@@ -712,17 +535,6 @@
     psubusb          m1, m5          ; q0-q1
     psubusb          m7, m4          ; q1-q0
     por              m1, m7          ; abs(q1-q0)
-%if notcpuflag(mmxext)
-    mova             m7, m1
-    psubusb          m1, m6
-    psubusb          m7, m_hevthr
-    pxor             m6, m6
-    pcmpeqb          m1, m6          ; abs(q1-q0) <= I
-    pcmpeqb          m7, m6          ; abs(q1-q0) <= hev_thresh
-    mova             m6, m_maskres
-    pand             m0, m1          ; abs([pq][321]-[pq][210]) <= I
-    pand             m6, m7
-%else ; mmxext/sse2
     pxor             m7, m7
     pmaxub           m0, m1
     pmaxub           m6, m1
@@ -730,7 +542,6 @@
     psubusb          m6, m_hevthr
     pcmpeqb          m0, m7          ; max(abs(..)) <= I
     pcmpeqb          m6, m7          ; !(max(abs..) > thresh)
-%endif
 %ifdef m12
     SWAP              6, 12
 %else
@@ -820,25 +631,12 @@
 %else
     mova             m6, m_maskres
 %endif
-%if notcpuflag(mmxext)
-    mova             m7, [pb_1]
-%else ; mmxext/sse2
     pxor             m7, m7
-%endif
     pand             m0, m6
     pand             m1, m6
-%if notcpuflag(mmxext)
-    paddusb          m0, m7
-    pand             m1, [pb_FE]
-    pandn            m7, m0
-    psrlq            m1, 1
-    psrlq            m7, 1
-    SWAP              0, 7
-%else ; mmxext/sse2
     psubusb          m1, [pb_1]
     pavgb            m0, m7          ; a
     pavgb            m1, m7          ; -a
-%endif
     psubusb          m5, m0
     psubusb          m2, m1
     paddusb          m5, m1          ; q1-a
@@ -863,51 +661,13 @@
     ; 4x8/16 transpose
     TRANSPOSE4x4B     2, 3, 4, 5, 6
 
-%if mmsize == 8 ; mmx/mmxext (h)
-    WRITE_4x2D        2, 3, 4, 5, dst1q, dst2q, mstrideq, strideq
-%else ; sse2 (h)
     lea           dst8q, [dst8q+mstrideq  +2]
     WRITE_4x4D        2, 3, 4, 5, dst1q, dst2q, dst8q, mstrideq, strideq, %2
 %endif
-%endif
 
-%if mmsize == 8
-%if %2 == 8 ; chroma
-%ifidn %1, h
-    sub           dst1q, 2
-%endif
-    cmp           dst1q, dst8q
-    mov           dst1q, dst8q
-    jnz .next8px
-%else
-%ifidn %1, h
-    lea           dst1q, [dst1q+ strideq*8-2]
-%else ; v
-    add           dst1q, 8
-%endif
-    dec           cntrq
-    jg .next8px
-%endif
-    REP_RET
-%else ; mmsize == 16
     RET
-%endif
 %endmacro
 
-%if ARCH_X86_32
-INIT_MMX mmx
-INNER_LOOPFILTER v, 16
-INNER_LOOPFILTER h, 16
-INNER_LOOPFILTER v,  8
-INNER_LOOPFILTER h,  8
-
-INIT_MMX mmxext
-INNER_LOOPFILTER v, 16
-INNER_LOOPFILTER h, 16
-INNER_LOOPFILTER v,  8
-INNER_LOOPFILTER h,  8
-%endif
-
 INIT_XMM sse2
 INNER_LOOPFILTER v, 16
 INNER_LOOPFILTER h, 16
@@ -992,9 +752,6 @@
 
 %if %2 == 8 ; chroma
     DEFINE_ARGS dst1, dst8, mstride, stride, dst2
-%elif mmsize == 8
-    DEFINE_ARGS dst1, mstride, stride, dst2, cntr
-    mov           cntrq, 2
 %else
     DEFINE_ARGS dst1, mstride, stride, dst2, dst8
 %endif
@@ -1007,9 +764,6 @@
 %endif
 %endif
 
-%if mmsize == 8
-.next8px:
-%endif
     ; read
     lea           dst2q, [dst1q+ strideq  ]
 %ifidn %1, v
@@ -1034,33 +788,7 @@
     movhps           m7, [dst8q+ strideq*2]
     add           dst8q, mstrideq
 %endif
-%elif mmsize == 8 ; mmx/mmxext (h)
-    ; read 8 rows of 8px each
-    movu             m0, [dst1q+mstrideq*4]
-    movu             m1, [dst2q+mstrideq*4]
-    movu             m2, [dst1q+mstrideq*2]
-    movu             m3, [dst1q+mstrideq  ]
-    movu             m4, [dst1q]
-    movu             m5, [dst2q]
-    movu             m6, [dst2q+ strideq  ]
-
-    ; 8x8 transpose
-    TRANSPOSE4x4B     0, 1, 2, 3, 7
-    mova     m_q0backup, m1
-    movu             m7, [dst2q+ strideq*2]
-    TRANSPOSE4x4B     4, 5, 6, 7, 1
-    SBUTTERFLY       dq, 0, 4, 1     ; p3/p2
-    SBUTTERFLY       dq, 2, 6, 1     ; q0/q1
-    SBUTTERFLY       dq, 3, 7, 1     ; q2/q3
-    mova             m1, m_q0backup
-    mova     m_q0backup, m2          ; store q0
-    SBUTTERFLY       dq, 1, 5, 2     ; p1/p0
-    mova     m_p0backup, m5          ; store p0
-    SWAP              1, 4
-    SWAP              2, 4
-    SWAP              6, 3
-    SWAP              5, 3
-%else ; sse2 (h)
+%else ; h
 %if %2 == 16
     lea           dst8q, [dst1q+ strideq*8  ]
 %endif
@@ -1150,25 +878,9 @@
     psubusb          m6, m5          ; q2-q1
     por              m6, m4          ; abs(q2-q1)
 
-%if notcpuflag(mmxext)
-    mova             m4, m_flimI
-    pxor             m3, m3
-    psubusb          m0, m4
-    psubusb          m1, m4
-    psubusb          m7, m4
-    psubusb          m6, m4
-    pcmpeqb          m0, m3          ; abs(p3-p2) <= I
-    pcmpeqb          m1, m3          ; abs(p2-p1) <= I
-    pcmpeqb          m7, m3          ; abs(q3-q2) <= I
-    pcmpeqb          m6, m3          ; abs(q2-q1) <= I
-    pand             m0, m1
-    pand             m7, m6
-    pand             m0, m7
-%else ; mmxext/sse2
     pmaxub           m0, m1
     pmaxub           m6, m7
     pmaxub           m0, m6
-%endif
 
     ; normal_limit and high_edge_variance for p1-p0, q1-q0
     SWAP              7, 3           ; now m7 is zero
@@ -1190,18 +902,8 @@
     psubusb          m1, m3          ; p1-p0
     psubusb          m6, m2          ; p0-p1
     por              m1, m6          ; abs(p1-p0)
-%if notcpuflag(mmxext)
-    mova             m6, m1
-    psubusb          m1, m4
-    psubusb          m6, m_hevthr
-    pcmpeqb          m1, m7          ; abs(p1-p0) <= I
-    pcmpeqb          m6, m7          ; abs(p1-p0) <= hev_thresh
-    pand             m0, m1
-    mova      m_maskres, m6
-%else ; mmxext/sse2
     pmaxub           m0, m1          ; max_I
     SWAP              1, 4           ; max_hev_thresh
-%endif
 
     SWAP              6, 4           ; now m6 is I
 %ifidn %1, v
@@ -1221,17 +923,6 @@
     psubusb          m1, m5          ; q0-q1
     psubusb          m7, m4          ; q1-q0
     por              m1, m7          ; abs(q1-q0)
-%if notcpuflag(mmxext)
-    mova             m7, m1
-    psubusb          m1, m6
-    psubusb          m7, m_hevthr
-    pxor             m6, m6
-    pcmpeqb          m1, m6          ; abs(q1-q0) <= I
-    pcmpeqb          m7, m6          ; abs(q1-q0) <= hev_thresh
-    mova             m6, m_maskres
-    pand             m0, m1          ; abs([pq][321]-[pq][210]) <= I
-    pand             m6, m7
-%else ; mmxext/sse2
     pxor             m7, m7
     pmaxub           m0, m1
     pmaxub           m6, m1
@@ -1239,7 +930,6 @@
     psubusb          m6, m_hevthr
     pcmpeqb          m0, m7          ; max(abs(..)) <= I
     pcmpeqb          m6, m7          ; !(max(abs..) > thresh)
-%endif
 %ifdef m12
     SWAP              6, 12
 %else
@@ -1510,11 +1200,6 @@
     TRANSPOSE4x4B    1, 2, 3, 4, 0
     SBUTTERFLY      bw, 5, 6, 0
 
-%if mmsize == 8 ; mmx/mmxext (h)
-    WRITE_4x2D       1, 2, 3, 4, dst1q, dst2q, mstrideq, strideq
-    add          dst1q, 4
-    WRITE_2x4W      m5, m6, dst2q, dst1q, mstrideq, strideq
-%else ; sse2 (h)
     lea          dst8q, [dst8q+mstrideq+1]
     WRITE_4x4D       1, 2, 3, 4, dst1q, dst2q, dst8q, mstrideq, strideq, %2
     lea          dst1q, [dst2q+mstrideq+4]
@@ -1528,45 +1213,10 @@
 %endif
     WRITE_8W        m6, dst2q, dst8q, mstrideq, strideq
 %endif
-%endif
 
-%if mmsize == 8
-%if %2 == 8 ; chroma
-%ifidn %1, h
-    sub          dst1q, 5
-%endif
-    cmp          dst1q, dst8q
-    mov          dst1q, dst8q
-    jnz .next8px
-%else
-%ifidn %1, h
-    lea          dst1q, [dst1q+ strideq*8-5]
-%else ; v
-    add          dst1q, 8
-%endif
-    dec          cntrq
-    jg .next8px
-%endif
-    REP_RET
-%else ; mmsize == 16
     RET
-%endif
 %endmacro
 
-%if ARCH_X86_32
-INIT_MMX mmx
-MBEDGE_LOOPFILTER v, 16
-MBEDGE_LOOPFILTER h, 16
-MBEDGE_LOOPFILTER v,  8
-MBEDGE_LOOPFILTER h,  8
-
-INIT_MMX mmxext
-MBEDGE_LOOPFILTER v, 16
-MBEDGE_LOOPFILTER h, 16
-MBEDGE_LOOPFILTER v,  8
-MBEDGE_LOOPFILTER h,  8
-%endif
-
 INIT_XMM sse2
 MBEDGE_LOOPFILTER v, 16
 MBEDGE_LOOPFILTER h, 16
diff -Naur a/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp.c b/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp.c
--- a/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp.c	2023-04-06 12:49:40.258395091 +0200
@@ -22,7 +22,6 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
-#include "libavutil/mem.h"
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/vp9dsp.h"
 #include "libavcodec/x86/vp9dsp_init.h"
@@ -55,6 +54,8 @@
 decl_ipred_fn(dl,       32,     16, avx2);
 decl_ipred_fn(dr,       16,     16, avx2);
 decl_ipred_fn(dr,       32,     16, avx2);
+decl_ipred_fn(vl,       16,     16, avx2);
+decl_ipred_fn(hd,       16,     16, avx2);
 
 #define decl_ipred_dir_funcs(type) \
 decl_ipred_fns(type, 16, sse2,  sse2); \
@@ -140,6 +141,8 @@
         init_ipred_func(dl, DIAG_DOWN_LEFT, 16, 16, avx2);
         init_ipred_func(dl, DIAG_DOWN_LEFT, 32, 16, avx2);
         init_ipred_func(dr, DIAG_DOWN_RIGHT, 16, 16, avx2);
+        init_ipred_func(vl, VERT_LEFT, 16, 16, avx2);
+        init_ipred_func(hd, HOR_DOWN, 16, 16, avx2);
 #if ARCH_X86_64
         init_ipred_func(dr, DIAG_DOWN_RIGHT, 32, 16, avx2);
 #endif
diff -Naur a/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp_template.c b/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp_template.c
--- a/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp_template.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp9dsp_init_16bpp_template.c	2023-04-06 12:49:40.258395091 +0200
@@ -22,7 +22,6 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
-#include "libavutil/mem.h"
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/vp9dsp.h"
 #include "libavcodec/x86/vp9dsp_init.h"
diff -Naur a/media/ffvpx/libavcodec/x86/vp9dsp_init.c b/media/ffvpx/libavcodec/x86/vp9dsp_init.c
--- a/media/ffvpx/libavcodec/x86/vp9dsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp9dsp_init.c	2023-04-06 12:49:40.258395091 +0200
@@ -22,7 +22,6 @@
 
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
-#include "libavutil/mem.h"
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/vp9dsp.h"
 #include "libavcodec/x86/vp9dsp_init.h"
diff -Naur a/media/ffvpx/libavcodec/x86/vp9dsp_init.h b/media/ffvpx/libavcodec/x86/vp9dsp_init.h
--- a/media/ffvpx/libavcodec/x86/vp9dsp_init.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp9dsp_init.h	2023-04-06 12:49:40.258395091 +0200
@@ -23,6 +23,7 @@
 #ifndef AVCODEC_X86_VP9DSP_INIT_H
 #define AVCODEC_X86_VP9DSP_INIT_H
 
+#include "libavutil/attributes.h"
 #include "libavutil/mem_internal.h"
 
 #include "libavcodec/vp9dsp.h"
diff -Naur a/media/ffvpx/libavcodec/x86/vp9intrapred_16bpp.asm b/media/ffvpx/libavcodec/x86/vp9intrapred_16bpp.asm
--- a/media/ffvpx/libavcodec/x86/vp9intrapred_16bpp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp9intrapred_16bpp.asm	2023-04-06 12:49:40.258395091 +0200
@@ -1222,6 +1222,111 @@
     mova     [dst3q+strideq*4], m5                     ; 7
     RET
 
+cglobal vp9_ipred_vl_16x16_16, 4, 5, 7, dst, stride, l, a
+    movifnidn               aq, amp
+    mova                    m0, [aq]                   ; abcdefghijklmnop
+    vpbroadcastw           xm1, [aq+30]                ; pppppppp
+    vperm2i128              m2, m0, m1, q0201          ; ijklmnoppppppppp
+    vpalignr                m3, m2, m0, 2              ; bcdefghijklmnopp
+    vperm2i128              m4, m3, m1, q0201          ; jklmnopppppppppp
+    vpalignr                m5, m2, m0, 4              ; cdefghijklmnoppp
+    vperm2i128              m6, m5, m1, q0201          ; klmnoppppppppppp
+    LOWPASS                  5,  3,  0                 ; BCDEFGHIJKLMNOPP
+    LOWPASS                  6,  4,  2                 ; JKLMNOPPPPPPPPPP
+    pavgw                   m3, m0                     ; abcdefghijklmnop
+    pavgw                   m4, m2                     ; ijklmnoppppppppp
+    DEFINE_ARGS dst, stride, stride3, stride5, dst4
+    lea                  dst4q, [dstq+strideq*4]
+    lea               stride3q, [strideq*3]
+    lea               stride5q, [stride3q+strideq*2]
+
+    mova      [dstq+strideq*0], m3                     ; 0  abcdefghijklmnop
+    mova      [dstq+strideq*1], m5                     ; 1  BCDEFGHIJKLMNOPP
+    vpalignr                m0, m4, m3, 2
+    vpalignr                m1, m6, m5, 2
+    mova     [dstq+strideq*2 ], m0                     ; 2  bcdefghijklmnopp
+    mova     [dstq+stride3q*1], m1                     ; 3  CDEFGHIJKLMNOPPP
+    vpalignr                m0, m4, m3, 4
+    vpalignr                m1, m6, m5, 4
+    mova     [dst4q+strideq*0], m0                     ; 4  cdefghijklmnoppp
+    mova     [dstq+stride5q*1], m1                     ; 5  DEFGHIJKLMNOPPPP
+    vpalignr                m0, m4, m3, 6
+    vpalignr                m1, m6, m5, 6
+    mova    [ dstq+stride3q*2], m0                     ; 6  defghijklmnopppp
+    mova    [dst4q+stride3q*1], m1                     ; 7  EFGHIJKLMNOPPPPP
+    vpalignr                m0, m4, m3, 8
+    vpalignr                m1, m6, m5, 8
+    mova    [  dstq+strideq*8], m0                     ; 8  efghijklmnoppppp
+    mova    [dst4q+stride5q*1], m1                     ; 9  FGHIJKLMNOPPPPPP
+    vpalignr                m0, m4, m3, 10
+    mova     [dstq+stride5q*2], m0                     ; 10 fghijklmnopppppp
+    vpalignr                m0, m4, m3, 12
+    mova     [dst4q+strideq*8], m0                     ; 12 ghijklmnoppppppp
+    vpalignr                m0, m4, m3, 14
+    mova    [dst4q+stride5q*2], m0                     ; 14 hijklmnopppppppp
+    sub                  dst4q, strideq
+    vpalignr                m1, m6, m5, 10
+    mova     [dst4q+strideq*8], m1                     ; 11 GHIJKLMNOPPPPPPP
+    vpalignr                m1, m6, m5, 12
+    mova    [dst4q+stride5q*2], m1                     ; 13 HIJKLMNOPPPPPPPP
+    vpalignr                m1, m6, m5, 14
+    mova    [dst4q+stride3q*4], m1                     ; 15 IJKLMNOPPPPPPPPP
+    RET
+
+cglobal vp9_ipred_hd_16x16_16, 4, 5, 7, dst, stride, l, a
+    movu                    m0, [aq-2]                 ; *abcdefghijklmno
+    mova                    m1, [lq]                   ; klmnopqrstuvwxyz
+    vperm2i128              m2, m1, m0, q0201          ; stuvwxyz*abcdefg
+    vpalignr                m3, m2, m1, 2              ; lmnopqrstuvwxyz*
+    vpalignr                m4, m2, m1, 4              ; mnopqrstuvwxyz*a
+    LOWPASS                  4,  3,  1                 ; LMNOPQRSTUVWXYZ#
+    pavgw                   m3, m1                     ; klmnopqrstuvwxyz
+    mova                    m1, [aq]                   ; abcdefghijklmnop
+    movu                    m2, [aq+2]                 ; bcdefghijklmnop.
+    LOWPASS                  2,  1,  0                 ; ABCDEFGHIJKLMNO.
+    vpunpcklwd              m0, m3, m4                 ; kLlMmNnOsTtUuVvW
+    vpunpckhwd              m1, m3, m4                 ; oPpQqRrSwXxYyZz#
+    vperm2i128              m3, m1, m0, q0002          ; kLlMmNnOoPpQqRrS
+    vperm2i128              m4, m0, m1, q0301          ; sTtUuVvWwXxYyZz#
+    vperm2i128              m0, m4, m2, q0201          ; wXxYyZz#ABCDEFGH
+    vperm2i128              m1, m3, m4, q0201          ; oPpQqRrSsTtUuVvW
+    DEFINE_ARGS dst, stride, stride3, stride5, dst5
+    lea               stride3q, [strideq*3]
+    lea               stride5q, [stride3q+strideq*2]
+    lea                  dst5q, [dstq+stride5q]
+
+    mova    [dst5q+stride5q*2], m3                     ; 15 kLlMmNnOoPpQqRrS
+    mova    [dst5q+stride3q*2], m1                     ; 11 oPpQqRrSsTtUuVvW
+    mova     [dst5q+strideq*2], m4                     ; 7  sTtUuVvWwXxYyZz#
+    mova     [dstq+stride3q*1], m0                     ; 3  wXxYyZz#ABCDEFGH
+    vpalignr                m5, m4, m1, 4
+    mova     [dstq+stride5q*2], m5                     ; 10 pQqRrSsTtUuVvWwX
+    vpalignr                m5, m0, m4, 4
+    vpalignr                m6, m2, m0, 4
+    mova     [dstq+stride3q*2], m5                     ; 6  tUuVvWwXxYyZz#AB
+    mova      [dstq+strideq*2], m6                     ; 2  xYyZz#ABCDEFGHIJ
+    vpalignr                m5, m4, m1, 8
+    mova     [dst5q+strideq*4], m5                     ; 9  qRrSsTtUuVvWwXxY
+    vpalignr                m5, m0, m4, 8
+    vpalignr                m6, m2, m0, 8
+    mova     [dstq+stride5q*1], m5                     ; 5  uVvWwXxYyZz#ABCD
+    mova      [dstq+strideq*1], m6                     ; 1  yZz#ABCDEFGHIJKL
+    vpalignr                m5, m1, m3, 12
+    vpalignr                m6, m4, m1, 12
+    mova     [dstq+stride3q*4], m5                     ; 12 nOoPpQqRrSsTtUuV
+    mova      [dst5q+stride3q], m6                     ; 8  rSsTtUuVvWwXxYyZ
+    vpalignr                m5, m0, m4, 12
+    vpalignr                m6, m2, m0, 12
+    mova      [dstq+strideq*4], m5                     ; 4  nOoPpQqRrSsTtUuV
+    mova      [dstq+strideq*0], m6                     ; 0  z#ABCDEFGHIJKLMN
+    sub                  dst5q, strideq
+    vpalignr                m5, m1, m3, 4
+    mova    [dst5q+stride5q*2], m5                     ; 14 lMmNnOoPpQqRrSsT
+    sub                  dst5q, strideq
+    vpalignr                m5, m1, m3, 8
+    mova    [dst5q+stride5q*2], m5                    ; 13 mNnOoPpQqRrSsTtU
+    RET
+
 %if ARCH_X86_64
 cglobal vp9_ipred_dr_32x32_16, 4, 7, 10, dst, stride, l, a
     mova                    m0, [lq+mmsize*0+0]        ; l[0-15]
diff -Naur a/media/ffvpx/libavcodec/x86/vp9mc.asm b/media/ffvpx/libavcodec/x86/vp9mc.asm
--- a/media/ffvpx/libavcodec/x86/vp9mc.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vp9mc.asm	2023-04-06 12:49:40.258395091 +0200
@@ -604,7 +604,12 @@
     %%pavg      m0, [dstq]
     %%pavg      m1, [dstq+d%3]
     %%pavg      m2, [dstq+d%4]
+%if %2 == 4
+    %%srcfn     m4, [dstq+d%5]
+    %%pavg      m3, m4
+%else
     %%pavg      m3, [dstq+d%5]
+%endif
 %if %2/mmsize == 8
     %%pavg      m4, [dstq+mmsize*4]
     %%pavg      m5, [dstq+mmsize*5]
diff -Naur a/media/ffvpx/libavcodec/x86/vpx_arith.h b/media/ffvpx/libavcodec/x86/vpx_arith.h
--- a/media/ffvpx/libavcodec/x86/vpx_arith.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavcodec/x86/vpx_arith.h	2023-04-06 12:50:06.975471215 +0200
@@ -0,0 +1,55 @@
+/**
+ * VP5 and VP6 compatible video decoder (arith decoder)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
+ * Copyright (C) 2010  Eli Friedman
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_X86_VPX_ARITH_H
+#define AVCODEC_X86_VPX_ARITH_H
+
+#include "libavutil/x86/asm.h"
+
+#if HAVE_INLINE_ASM && HAVE_FAST_CMOV && HAVE_6REGS
+#include "libavutil/attributes.h"
+
+#define vpx_rac_get_prob vpx_rac_get_prob
+static av_always_inline int vpx_rac_get_prob(VPXRangeCoder *c, uint8_t prob)
+{
+    unsigned int code_word = vpx_rac_renorm(c);
+    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
+    unsigned int low_shift = low << 16;
+    int bit = 0;
+    c->code_word = code_word;
+
+    __asm__(
+        "subl  %4, %1      \n\t"
+        "subl  %3, %2      \n\t"
+        "setae %b0         \n\t"
+        "cmovb %4, %1      \n\t"
+        "cmovb %5, %2      \n\t"
+        : "+q"(bit), "+&r"(c->high), "+&r"(c->code_word)
+        : "r"(low_shift), "r"(low), "r"(code_word)
+    );
+
+    return bit;
+}
+#endif
+
+#endif /* AVCODEC_X86_VPX_ARITH_H */
diff -Naur a/media/ffvpx/libavcodec/xiph.c b/media/ffvpx/libavcodec/xiph.c
--- a/media/ffvpx/libavcodec/xiph.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/xiph.c	2023-04-06 12:49:40.258395091 +0200
@@ -18,6 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <limits.h>
+#include "libavutil/error.h"
 #include "libavutil/intreadwrite.h"
 #include "xiph.h"
 
diff -Naur a/media/ffvpx/libavcodec/xiph.h b/media/ffvpx/libavcodec/xiph.h
--- a/media/ffvpx/libavcodec/xiph.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavcodec/xiph.h	2023-04-06 12:49:40.258395091 +0200
@@ -21,7 +21,7 @@
 #ifndef AVCODEC_XIPH_H
 #define AVCODEC_XIPH_H
 
-#include "libavutil/common.h"
+#include <stdint.h>
 
 /**
  * Split a single extradata buffer into the three headers that most
diff -Naur a/media/ffvpx/libavutil/aarch64/asm.S b/media/ffvpx/libavutil/aarch64/asm.S
--- a/media/ffvpx/libavutil/aarch64/asm.S	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/aarch64/asm.S	2023-04-06 12:49:40.258395091 +0200
@@ -36,6 +36,125 @@
 #   define __has_feature(x) 0
 #endif
 
+
+/* Support macros for
+ *   - Armv8.3-A Pointer Authentication and
+ *   - Armv8.5-A Branch Target Identification
+ * features which require emitting a .note.gnu.property section with the
+ * appropriate architecture-dependent feature bits set.
+ *
+ * |AARCH64_SIGN_LINK_REGISTER| and |AARCH64_VALIDATE_LINK_REGISTER| expand to
+ * PACIxSP and AUTIxSP, respectively. |AARCH64_SIGN_LINK_REGISTER| should be
+ * used immediately before saving the LR register (x30) to the stack.
+ * |AARCH64_VALIDATE_LINK_REGISTER| should be used immediately after restoring
+ * it. Note |AARCH64_SIGN_LINK_REGISTER|'s modifications to LR must be undone
+ * with |AARCH64_VALIDATE_LINK_REGISTER| before RET. The SP register must also
+ * have the same value at the two points. For example:
+ *
+ *   .global f
+ *   f:
+ *     AARCH64_SIGN_LINK_REGISTER
+ *     stp x29, x30, [sp, #-96]!
+ *     mov x29, sp
+ *     ...
+ *     ldp x29, x30, [sp], #96
+ *     AARCH64_VALIDATE_LINK_REGISTER
+ *     ret
+ *
+ * |AARCH64_VALID_CALL_TARGET| expands to BTI 'c'. Either it, or
+ * |AARCH64_SIGN_LINK_REGISTER|, must be used at every point that may be an
+ * indirect call target. In particular, all symbols exported from a file must
+ * begin with one of these macros. For example, a leaf function that does not
+ * save LR can instead use |AARCH64_VALID_CALL_TARGET|:
+ *
+ *   .globl return_zero
+ *   return_zero:
+ *     AARCH64_VALID_CALL_TARGET
+ *     mov x0, #0
+ *     ret
+ *
+ * A non-leaf function which does not immediately save LR may need both macros
+ * because |AARCH64_SIGN_LINK_REGISTER| appears late. For example, the function
+ * may jump to an alternate implementation before setting up the stack:
+ *
+ *   .globl with_early_jump
+ *   with_early_jump:
+ *     AARCH64_VALID_CALL_TARGET
+ *     cmp x0, #128
+ *     b.lt .Lwith_early_jump_128
+ *     AARCH64_SIGN_LINK_REGISTER
+ *     stp x29, x30, [sp, #-96]!
+ *     mov x29, sp
+ *     ...
+ *     ldp x29, x30, [sp], #96
+ *     AARCH64_VALIDATE_LINK_REGISTER
+ *     ret
+ *
+ *  .Lwith_early_jump_128:
+ *     ...
+ *     ret
+ *
+ * These annotations are only required with indirect calls. Private symbols that
+ * are only the target of direct calls do not require annotations. Also note
+ * that |AARCH64_VALID_CALL_TARGET| is only valid for indirect calls (BLR), not
+ * indirect jumps (BR). Indirect jumps in assembly are supported through
+ * |AARCH64_VALID_JUMP_TARGET|. Landing Pads which shall serve for jumps and
+ * calls can be created using |AARCH64_VALID_JUMP_CALL_TARGET|.
+ *
+ * Although not necessary, it is safe to use these macros in 32-bit ARM
+ * assembly. This may be used to simplify dual 32-bit and 64-bit files.
+ *
+ * References:
+ * - "ELF for the Arm® 64-bit Architecture"
+ *   https: *github.com/ARM-software/abi-aa/blob/master/aaelf64/aaelf64.rst
+ * - "Providing protection for complex software"
+ *   https://developer.arm.com/architectures/learn-the-architecture/providing-protection-for-complex-software
+ */
+#if defined(__ARM_FEATURE_BTI_DEFAULT) && (__ARM_FEATURE_BTI_DEFAULT == 1)
+#   define GNU_PROPERTY_AARCH64_BTI (1 << 0)   // Has BTI
+#   define AARCH64_VALID_CALL_TARGET hint #34  // BTI 'c'
+#   define AARCH64_VALID_JUMP_TARGET hint #38  // BTI 'j'
+#else
+#   define GNU_PROPERTY_AARCH64_BTI 0          // No BTI
+#   define AARCH64_VALID_CALL_TARGET
+#   define AARCH64_VALID_JUMP_TARGET
+#endif
+
+#if defined(__ARM_FEATURE_PAC_DEFAULT)
+#   if ((__ARM_FEATURE_PAC_DEFAULT & (1 << 0)) != 0) // authentication using key A
+#       define AARCH64_SIGN_LINK_REGISTER      paciasp
+#       define AARCH64_VALIDATE_LINK_REGISTER  autiasp
+#   elif ((__ARM_FEATURE_PAC_DEFAULT & (1 << 1)) != 0) // authentication using key B
+#       define AARCH64_SIGN_LINK_REGISTER      pacibsp
+#       define AARCH64_VALIDATE_LINK_REGISTER  autibsp
+#   else
+#       error Pointer authentication defines no valid key!
+#   endif
+#   if ((__ARM_FEATURE_PAC_DEFAULT & (1 << 2)) != 0)
+#       error Authentication of leaf functions is enabled but not supported in FFmpeg!
+#   endif
+#   define GNU_PROPERTY_AARCH64_PAC (1 << 1)
+#else
+#   define GNU_PROPERTY_AARCH64_PAC 0
+#   define AARCH64_SIGN_LINK_REGISTER
+#   define AARCH64_VALIDATE_LINK_REGISTER
+#endif
+
+
+#if (GNU_PROPERTY_AARCH64_BTI != 0 || GNU_PROPERTY_AARCH64_PAC != 0) && defined(__ELF__)
+        .pushsection .note.gnu.property, "a"
+        .balign 8
+        .long 4
+        .long 0x10
+        .long 0x5
+        .asciz "GNU"
+        .long 0xc0000000 /* GNU_PROPERTY_AARCH64_FEATURE_1_AND */
+        .long 4
+        .long (GNU_PROPERTY_AARCH64_BTI | GNU_PROPERTY_AARCH64_PAC)
+        .long 0
+        .popsection
+#endif
+
 .macro  function name, export=0, align=2
     .macro endfunc
 ELF     .size   \name, . - \name
@@ -49,6 +168,7 @@
 ELF     .type   EXTERN_ASM\name, %function
 FUNC    .func   EXTERN_ASM\name
 EXTERN_ASM\name:
+        AARCH64_VALID_CALL_TARGET
     .else
 ELF     .type   \name, %function
 FUNC    .func   \name
diff -Naur a/media/ffvpx/libavutil/aarch64/bswap.h b/media/ffvpx/libavutil/aarch64/bswap.h
--- a/media/ffvpx/libavutil/aarch64/bswap.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/aarch64/bswap.h	2023-04-06 12:50:06.975471215 +0200
@@ -28,24 +28,29 @@
 #define av_bswap16 av_bswap16
 static av_always_inline av_const unsigned av_bswap16(unsigned x)
 {
-    __asm__("rev16 %w0, %w0" : "+r"(x));
-    return x;
+    unsigned y;
+
+    __asm__("rev16 %w0, %w1" : "=r"(y) : "r"(x));
+    return y;
 }
 
 #define av_bswap32 av_bswap32
 static av_always_inline av_const uint32_t av_bswap32(uint32_t x)
 {
-    __asm__("rev %w0, %w0" : "+r"(x));
-    return x;
+    uint32_t y;
+
+    __asm__("rev %w0, %w1" : "=r"(y) : "r"(x));
+    return y;
 }
 
 #define av_bswap64 av_bswap64
 static av_always_inline av_const uint64_t av_bswap64(uint64_t x)
 {
-    __asm__("rev %0, %0" : "+r"(x));
-    return x;
+    uint64_t y;
+
+    __asm__("rev %0, %1" : "=r"(y) : "r"(x));
+    return y;
 }
 
 #endif /* HAVE_INLINE_ASM */
-
 #endif /* AVUTIL_AARCH64_BSWAP_H */
diff -Naur a/media/ffvpx/libavutil/adler32.c b/media/ffvpx/libavutil/adler32.c
--- a/media/ffvpx/libavutil/adler32.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/adler32.c	2023-04-06 12:49:40.258395091 +0200
@@ -32,8 +32,8 @@
 
 #include "config.h"
 #include "adler32.h"
-#include "common.h"
 #include "intreadwrite.h"
+#include "macros.h"
 
 #define BASE 65521L /* largest prime smaller than 65536 */
 
@@ -41,12 +41,7 @@
 #define DO4(buf)  DO1(buf); DO1(buf); DO1(buf); DO1(buf);
 #define DO16(buf) DO4(buf); DO4(buf); DO4(buf); DO4(buf);
 
-#if FF_API_CRYPTO_SIZE_T
-unsigned long av_adler32_update(unsigned long adler, const uint8_t * buf,
-                                unsigned int len)
-#else
 AVAdler av_adler32_update(AVAdler adler, const uint8_t *buf, size_t len)
-#endif
 {
     unsigned long s1 = adler & 0xffff;
     unsigned long s2 = adler >> 16;
diff -Naur a/media/ffvpx/libavutil/adler32.h b/media/ffvpx/libavutil/adler32.h
--- a/media/ffvpx/libavutil/adler32.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/adler32.h	2023-04-06 12:49:40.259395132 +0200
@@ -30,7 +30,6 @@
 #include <stddef.h>
 #include <stdint.h>
 #include "attributes.h"
-#include "version.h"
 
 /**
  * @defgroup lavu_adler32 Adler-32
@@ -40,11 +39,7 @@
  * @{
  */
 
-#if FF_API_CRYPTO_SIZE_T
-typedef unsigned long AVAdler;
-#else
 typedef uint32_t AVAdler;
-#endif
 
 /**
  * Calculate the Adler32 checksum of a buffer.
@@ -59,11 +54,7 @@
  * @return      updated checksum
  */
 AVAdler av_adler32_update(AVAdler adler, const uint8_t *buf,
-#if FF_API_CRYPTO_SIZE_T
-                          unsigned int len) av_pure;
-#else
                           size_t len) av_pure;
-#endif
 
 /**
  * @}
diff -Naur a/media/ffvpx/libavutil/arm/bswap.h b/media/ffvpx/libavutil/arm/bswap.h
--- a/media/ffvpx/libavutil/arm/bswap.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/arm/bswap.h	2023-04-06 12:50:06.975471215 +0200
@@ -39,8 +39,10 @@
 #define av_bswap16 av_bswap16
 static av_always_inline av_const unsigned av_bswap16(unsigned x)
 {
-    __asm__("rev16 %0, %0" : "+r"(x));
-    return x;
+    unsigned y;
+
+    __asm__("rev16 %0, %1" : "=r"(y) : "r"(x));
+    return y;
 }
 #endif
 
@@ -48,17 +50,18 @@
 #define av_bswap32 av_bswap32
 static av_always_inline av_const uint32_t av_bswap32(uint32_t x)
 {
+    uint32_t y;
 #if HAVE_ARMV6_INLINE
-    __asm__("rev %0, %0" : "+r"(x));
+    __asm__("rev %0, %1" : "=r"(y) : "r"(x));
 #else
     uint32_t t;
-    __asm__ ("eor %1, %0, %0, ror #16 \n\t"
+    __asm__ ("eor %1, %2, %2, ror #16 \n\t"
              "bic %1, %1, #0xFF0000   \n\t"
-             "mov %0, %0, ror #8      \n\t"
+             "mov %0, %2, ror #8      \n\t"
              "eor %0, %0, %1, lsr #8  \n\t"
-             : "+r"(x), "=&r"(t));
+             : "=r"(y), "=&r"(t) : "r"(x));
 #endif /* HAVE_ARMV6_INLINE */
-    return x;
+    return y;
 }
 #endif /* AV_GCC_VERSION_AT_MOST(4,4) */
 
diff -Naur a/media/ffvpx/libavutil/arm/cpu.c b/media/ffvpx/libavutil/arm/cpu.c
--- a/media/ffvpx/libavutil/arm/cpu.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/arm/cpu.c	2023-04-06 12:49:40.259395132 +0200
@@ -38,6 +38,10 @@
 #include <string.h>
 #include "libavutil/avstring.h"
 
+#if HAVE_GETAUXVAL
+#include <sys/auxv.h>
+#endif
+
 #define AT_HWCAP        16
 
 /* Relevant HWCAP values from kernel headers */
@@ -48,6 +52,19 @@
 #define HWCAP_VFPv3     (1 << 13)
 #define HWCAP_TLS       (1 << 15)
 
+static int get_auxval(uint32_t *hwcap)
+{
+#if HAVE_GETAUXVAL
+    unsigned long ret = getauxval(AT_HWCAP);
+    if (ret == 0)
+        return -1;
+    *hwcap = ret;
+    return 0;
+#else
+    return -1;
+#endif
+}
+
 static int get_hwcap(uint32_t *hwcap)
 {
     struct { uint32_t a_type; uint32_t a_val; } auxv;
@@ -106,9 +123,10 @@
     int flags = CORE_CPU_FLAGS;
     uint32_t hwcap;
 
-    if (get_hwcap(&hwcap) < 0)
-        if (get_cpuinfo(&hwcap) < 0)
-            return flags;
+    if (get_auxval(&hwcap) < 0)
+        if (get_hwcap(&hwcap) < 0)
+            if (get_cpuinfo(&hwcap) < 0)
+                return flags;
 
 #define check_cap(cap, flag) do {               \
         if (hwcap & HWCAP_ ## cap)              \
diff -Naur a/media/ffvpx/libavutil/arm/intmath.h b/media/ffvpx/libavutil/arm/intmath.h
--- a/media/ffvpx/libavutil/arm/intmath.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/arm/intmath.h	2023-04-06 12:50:06.975471215 +0200
@@ -65,17 +65,29 @@
 #define av_clip_intp2 av_clip_intp2_arm
 static av_always_inline av_const int av_clip_intp2_arm(int a, int p)
 {
-    unsigned x;
-    __asm__ ("ssat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p+1));
-    return x;
+    if (av_builtin_constant_p(p)) {
+        unsigned x;
+        __asm__ ("ssat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p+1));
+        return x;
+    } else {
+        if (((unsigned)a + (1 << p)) & ~((2 << p) - 1))
+            return (a >> 31) ^ ((1 << p) - 1);
+        else
+            return a;
+    }
 }
 
 #define av_clip_uintp2 av_clip_uintp2_arm
 static av_always_inline av_const unsigned av_clip_uintp2_arm(int a, int p)
 {
-    unsigned x;
-    __asm__ ("usat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p));
-    return x;
+    if (av_builtin_constant_p(p)) {
+        unsigned x;
+        __asm__ ("usat %0, %2, %1" : "=r"(x) : "r"(a), "i"(p));
+        return x;
+    } else {
+        if (a & ~((1<<p) - 1)) return (~a) >> 31 & ((1<<p) - 1);
+        else                   return  a;
+    }
 }
 
 #define av_sat_add32 av_sat_add32_arm
diff -Naur a/media/ffvpx/libavutil/attributes.h b/media/ffvpx/libavutil/attributes.h
--- a/media/ffvpx/libavutil/attributes.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/attributes.h	2023-04-06 12:49:40.259395132 +0200
@@ -110,7 +110,7 @@
  * scheduled for removal.
  */
 #ifndef AV_NOWARN_DEPRECATED
-#if AV_GCC_VERSION_AT_LEAST(4,6)
+#if AV_GCC_VERSION_AT_LEAST(4,6) || defined(__clang__)
 #    define AV_NOWARN_DEPRECATED(code) \
         _Pragma("GCC diagnostic push") \
         _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") \
diff -Naur a/media/ffvpx/libavutil/attributes_internal.h b/media/ffvpx/libavutil/attributes_internal.h
--- a/media/ffvpx/libavutil/attributes_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavutil/attributes_internal.h	2023-04-06 12:50:06.975471215 +0200
@@ -0,0 +1,34 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_ATTRIBUTES_INTERNAL_H
+#define AVUTIL_ATTRIBUTES_INTERNAL_H
+
+#include "attributes.h"
+
+#if (AV_GCC_VERSION_AT_LEAST(4,0) || defined(__clang__)) && (defined(__ELF__) || defined(__MACH__))
+#    define attribute_visibility_hidden __attribute__((visibility("hidden")))
+#    define FF_VISIBILITY_PUSH_HIDDEN   _Pragma("GCC visibility push(hidden)")
+#    define FF_VISIBILITY_POP_HIDDEN    _Pragma("GCC visibility pop")
+#else
+#    define attribute_visibility_hidden
+#    define FF_VISIBILITY_PUSH_HIDDEN
+#    define FF_VISIBILITY_POP_HIDDEN
+#endif
+
+#endif /* AVUTIL_ATTRIBUTES_INTERNAL_H */
diff -Naur a/media/ffvpx/libavutil/avassert.h b/media/ffvpx/libavutil/avassert.h
--- a/media/ffvpx/libavutil/avassert.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/avassert.h	2023-04-06 12:49:40.259395132 +0200
@@ -28,8 +28,8 @@
 #define AVUTIL_AVASSERT_H
 
 #include <stdlib.h>
-#include "avutil.h"
 #include "log.h"
+#include "macros.h"
 
 /**
  * assert() equivalent, that is always enabled.
diff -Naur a/media/ffvpx/libavutil/avconfig.h b/media/ffvpx/libavutil/avconfig.h
--- a/media/ffvpx/libavutil/avconfig.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/avconfig.h	2023-04-06 12:49:40.259395132 +0200
@@ -1,4 +1,4 @@
-/* Generated by ffconf */
+/* Generated by ffmpeg configure */
 #ifndef AVUTIL_AVCONFIG_H
 #define AVUTIL_AVCONFIG_H
 #define AV_HAVE_BIGENDIAN 0
diff -Naur a/media/ffvpx/libavutil/avsscanf.c b/media/ffvpx/libavutil/avsscanf.c
--- a/media/ffvpx/libavutil/avsscanf.c	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavutil/avsscanf.c	2023-04-06 12:49:40.259395132 +0200
@@ -0,0 +1,970 @@
+/*
+ * Copyright (c) 2005-2014 Rich Felker, et al.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <limits.h>
+#include <math.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <float.h>
+
+#include "avstring.h"
+#include "libm.h"
+
+typedef struct FFFILE {
+    size_t buf_size;
+    unsigned char *buf;
+    unsigned char *rpos, *rend;
+    unsigned char *shend;
+    ptrdiff_t shlim, shcnt;
+    void *cookie;
+    size_t (*read)(struct FFFILE *, unsigned char *, size_t);
+} FFFILE;
+
+#define SIZE_hh -2
+#define SIZE_h  -1
+#define SIZE_def 0
+#define SIZE_l   1
+#define SIZE_L   2
+#define SIZE_ll  3
+
+#define shcnt(f) ((f)->shcnt + ((f)->rpos - (f)->buf))
+
+static int fftoread(FFFILE *f)
+{
+    f->rpos = f->rend = f->buf + f->buf_size;
+    return 0;
+}
+
+static size_t ffstring_read(FFFILE *f, unsigned char *buf, size_t len)
+{
+    char *src = f->cookie;
+    size_t k = len+256;
+    char *end = memchr(src, 0, k);
+
+    if (end) k = end-src;
+    if (k < len) len = k;
+    memcpy(buf, src, len);
+    f->rpos = (void *)(src+len);
+    f->rend = (void *)(src+k);
+    f->cookie = src+k;
+
+    return len;
+}
+
+static int ffuflow(FFFILE *f)
+{
+    unsigned char c;
+    if (!fftoread(f) && f->read(f, &c, 1)==1) return c;
+    return EOF;
+}
+
+static void ffshlim(FFFILE *f, ptrdiff_t lim)
+{
+    f->shlim = lim;
+    f->shcnt = f->buf - f->rpos;
+    /* If lim is nonzero, rend must be a valid pointer. */
+    if (lim && f->rend - f->rpos > lim)
+        f->shend = f->rpos + lim;
+    else
+        f->shend = f->rend;
+}
+
+static int ffshgetc(FFFILE *f)
+{
+    int c;
+    ptrdiff_t cnt = shcnt(f);
+    if (f->shlim && cnt >= f->shlim || (c=ffuflow(f)) < 0) {
+        f->shcnt = f->buf - f->rpos + cnt;
+        f->shend = 0;
+        return EOF;
+    }
+    cnt++;
+    if (f->shlim && f->rend - f->rpos > f->shlim - cnt)
+        f->shend = f->rpos + (f->shlim - cnt);
+    else
+        f->shend = f->rend;
+    f->shcnt = f->buf - f->rpos + cnt;
+    if (f->rpos[-1] != c) f->rpos[-1] = c;
+    return c;
+}
+
+#define shlim(f, lim) ffshlim((f), (lim))
+#define shgetc(f) (((f)->rpos < (f)->shend) ? *(f)->rpos++ : ffshgetc(f))
+#define shunget(f) ((f)->shend ? (void)(f)->rpos-- : (void)0)
+
+static const unsigned char table[] = { -1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
+    -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
+    25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
+    -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
+    25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+};
+
+static unsigned long long ffintscan(FFFILE *f, unsigned base, int pok, unsigned long long lim)
+{
+    const unsigned char *val = table+1;
+    int c, neg=0;
+    unsigned x;
+    unsigned long long y;
+    if (base > 36 || base == 1) {
+        errno = EINVAL;
+        return 0;
+    }
+    while (av_isspace((c=shgetc(f))));
+    if (c=='+' || c=='-') {
+        neg = -(c=='-');
+        c = shgetc(f);
+    }
+    if ((base == 0 || base == 16) && c=='0') {
+        c = shgetc(f);
+        if ((c|32)=='x') {
+            c = shgetc(f);
+            if (val[c]>=16) {
+                shunget(f);
+                if (pok) shunget(f);
+                else shlim(f, 0);
+                return 0;
+            }
+            base = 16;
+        } else if (base == 0) {
+            base = 8;
+        }
+    } else {
+        if (base == 0) base = 10;
+        if (val[c] >= base) {
+            shunget(f);
+            shlim(f, 0);
+            errno = EINVAL;
+            return 0;
+        }
+    }
+    if (base == 10) {
+        for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
+            x = x*10 + (c-'0');
+        for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
+            y = y*10 + (c-'0');
+        if (c-'0'>=10U) goto done;
+    } else if (!(base & base-1)) {
+        int bs = "\0\1\2\4\7\3\6\5"[(0x17*base)>>5&7];
+        for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
+            x = x<<bs | val[c];
+        for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
+            y = y<<bs | val[c];
+    } else {
+        for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
+            x = x*base + val[c];
+        for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
+            y = y*base + val[c];
+    }
+    if (val[c]<base) {
+        for (; val[c]<base; c=shgetc(f));
+        errno = ERANGE;
+        y = lim;
+        if (lim&1) neg = 0;
+    }
+done:
+    shunget(f);
+    if (y>=lim) {
+        if (!(lim&1) && !neg) {
+            errno = ERANGE;
+            return lim-1;
+        } else if (y>lim) {
+            errno = ERANGE;
+            return lim;
+        }
+    }
+    return (y^neg)-neg;
+}
+
+static long long scanexp(FFFILE *f, int pok)
+{
+    int c;
+    int x;
+    long long y;
+    int neg = 0;
+
+    c = shgetc(f);
+    if (c=='+' || c=='-') {
+        neg = (c=='-');
+        c = shgetc(f);
+        if (c-'0'>=10U && pok) shunget(f);
+    }
+    if (c-'0'>=10U) {
+        shunget(f);
+        return LLONG_MIN;
+    }
+    for (x=0; c-'0'<10U && x<INT_MAX/10; c = shgetc(f))
+        x = 10*x + (c-'0');
+    for (y=x; c-'0'<10U && y<LLONG_MAX/100; c = shgetc(f))
+        y = 10*y + (c-'0');
+    for (; c-'0'<10U; c = shgetc(f));
+    shunget(f);
+    return neg ? -y : y;
+}
+
+#define LD_B1B_DIG 2
+#define LD_B1B_MAX 9007199, 254740991
+#define KMAX 128
+#define MASK (KMAX-1)
+
+static double decfloat(FFFILE *f, int c, int bits, int emin, int sign, int pok)
+{
+    uint32_t x[KMAX];
+    static const uint32_t th[] = { LD_B1B_MAX };
+    int i, j, k, a, z;
+    long long lrp=0, dc=0;
+    long long e10=0;
+    int lnz = 0;
+    int gotdig = 0, gotrad = 0;
+    int rp;
+    int e2;
+    int emax = -emin-bits+3;
+    int denormal = 0;
+    double y;
+    double frac=0;
+    double bias=0;
+    static const int p10s[] = { 10, 100, 1000, 10000,
+        100000, 1000000, 10000000, 100000000 };
+
+    j=0;
+    k=0;
+
+    /* Don't let leading zeros consume buffer space */
+    for (; c=='0'; c = shgetc(f)) gotdig=1;
+    if (c=='.') {
+        gotrad = 1;
+        for (c = shgetc(f); c=='0'; c = shgetc(f)) gotdig=1, lrp--;
+    }
+
+    x[0] = 0;
+    for (; c-'0'<10U || c=='.'; c = shgetc(f)) {
+        if (c == '.') {
+            if (gotrad) break;
+            gotrad = 1;
+            lrp = dc;
+        } else if (k < KMAX-3) {
+            dc++;
+            if (c!='0') lnz = dc;
+            if (j) x[k] = x[k]*10 + c-'0';
+            else x[k] = c-'0';
+            if (++j==9) {
+                k++;
+                j=0;
+            }
+            gotdig=1;
+        } else {
+            dc++;
+            if (c!='0') {
+                lnz = (KMAX-4)*9;
+                x[KMAX-4] |= 1;
+            }
+        }
+    }
+    if (!gotrad) lrp=dc;
+
+    if (gotdig && (c|32)=='e') {
+        e10 = scanexp(f, pok);
+        if (e10 == LLONG_MIN) {
+            if (pok) {
+                shunget(f);
+            } else {
+                shlim(f, 0);
+                return 0;
+            }
+            e10 = 0;
+        }
+        lrp += e10;
+    } else if (c>=0) {
+        shunget(f);
+    }
+    if (!gotdig) {
+        errno = EINVAL;
+        shlim(f, 0);
+        return 0;
+    }
+
+    /* Handle zero specially to avoid nasty special cases later */
+    if (!x[0]) return sign * 0.0;
+
+    /* Optimize small integers (w/no exponent) and over/under-flow */
+    if (lrp==dc && dc<10 && (bits>30 || x[0]>>bits==0))
+        return sign * (double)x[0];
+    if (lrp > -emin/2) {
+        errno = ERANGE;
+        return sign * DBL_MAX * DBL_MAX;
+    }
+    if (lrp < emin-2*DBL_MANT_DIG) {
+        errno = ERANGE;
+        return sign * DBL_MIN * DBL_MIN;
+    }
+
+    /* Align incomplete final B1B digit */
+    if (j) {
+        for (; j<9; j++) x[k]*=10;
+        k++;
+        j=0;
+    }
+
+    a = 0;
+    z = k;
+    e2 = 0;
+    rp = lrp;
+
+    /* Optimize small to mid-size integers (even in exp. notation) */
+    if (lnz<9 && lnz<=rp && rp < 18) {
+        int bitlim;
+        if (rp == 9) return sign * (double)x[0];
+        if (rp < 9) return sign * (double)x[0] / p10s[8-rp];
+        bitlim = bits-3*(int)(rp-9);
+        if (bitlim>30 || x[0]>>bitlim==0)
+            return sign * (double)x[0] * p10s[rp-10];
+    }
+
+    /* Drop trailing zeros */
+    for (; !x[z-1]; z--);
+
+    /* Align radix point to B1B digit boundary */
+    if (rp % 9) {
+        int rpm9 = rp>=0 ? rp%9 : rp%9+9;
+        int p10 = p10s[8-rpm9];
+        uint32_t carry = 0;
+        for (k=a; k!=z; k++) {
+            uint32_t tmp = x[k] % p10;
+            x[k] = x[k]/p10 + carry;
+            carry = 1000000000/p10 * tmp;
+            if (k==a && !x[k]) {
+                a = (a+1 & MASK);
+                rp -= 9;
+            }
+        }
+        if (carry) x[z++] = carry;
+        rp += 9-rpm9;
+    }
+
+    /* Upscale until desired number of bits are left of radix point */
+    while (rp < 9*LD_B1B_DIG || (rp == 9*LD_B1B_DIG && x[a]<th[0])) {
+        uint32_t carry = 0;
+        e2 -= 29;
+        for (k=(z-1 & MASK); ; k=(k-1 & MASK)) {
+            uint64_t tmp = ((uint64_t)x[k] << 29) + carry;
+            if (tmp > 1000000000) {
+                carry = tmp / 1000000000;
+                x[k] = tmp % 1000000000;
+            } else {
+                carry = 0;
+                x[k] = tmp;
+            }
+            if (k==(z-1 & MASK) && k!=a && !x[k]) z = k;
+            if (k==a) break;
+        }
+        if (carry) {
+            rp += 9;
+            a = (a-1 & MASK);
+            if (a == z) {
+                z = (z-1 & MASK);
+                x[z-1 & MASK] |= x[z];
+            }
+            x[a] = carry;
+        }
+    }
+
+    /* Downscale until exactly number of bits are left of radix point */
+    for (;;) {
+        uint32_t carry = 0;
+        int sh = 1;
+        for (i=0; i<LD_B1B_DIG; i++) {
+            k = (a+i & MASK);
+            if (k == z || x[k] < th[i]) {
+                i=LD_B1B_DIG;
+                break;
+            }
+            if (x[a+i & MASK] > th[i]) break;
+        }
+        if (i==LD_B1B_DIG && rp==9*LD_B1B_DIG) break;
+        /* FIXME: find a way to compute optimal sh */
+        if (rp > 9+9*LD_B1B_DIG) sh = 9;
+        e2 += sh;
+        for (k=a; k!=z; k=(k+1 & MASK)) {
+            uint32_t tmp = x[k] & (1<<sh)-1;
+            x[k] = (x[k]>>sh) + carry;
+            carry = (1000000000>>sh) * tmp;
+            if (k==a && !x[k]) {
+                a = (a+1 & MASK);
+                i--;
+                rp -= 9;
+            }
+        }
+        if (carry) {
+            if ((z+1 & MASK) != a) {
+                x[z] = carry;
+                z = (z+1 & MASK);
+            } else x[z-1 & MASK] |= 1;
+        }
+    }
+
+    /* Assemble desired bits into floating point variable */
+    for (y=i=0; i<LD_B1B_DIG; i++) {
+        if ((a+i & MASK)==z) x[(z=(z+1 & MASK))-1] = 0;
+        y = 1000000000.0L * y + x[a+i & MASK];
+    }
+
+    y *= sign;
+
+    /* Limit precision for denormal results */
+    if (bits > DBL_MANT_DIG+e2-emin) {
+        bits = DBL_MANT_DIG+e2-emin;
+        if (bits<0) bits=0;
+        denormal = 1;
+    }
+
+    /* Calculate bias term to force rounding, move out lower bits */
+    if (bits < DBL_MANT_DIG) {
+        bias = copysign(scalbn(1, 2*DBL_MANT_DIG-bits-1), y);
+        frac = fmod(y, scalbn(1, DBL_MANT_DIG-bits));
+        y -= frac;
+        y += bias;
+    }
+
+    /* Process tail of decimal input so it can affect rounding */
+    if ((a+i & MASK) != z) {
+        uint32_t t = x[a+i & MASK];
+        if (t < 500000000 && (t || (a+i+1 & MASK) != z))
+            frac += 0.25*sign;
+        else if (t > 500000000)
+            frac += 0.75*sign;
+        else if (t == 500000000) {
+            if ((a+i+1 & MASK) == z)
+                frac += 0.5*sign;
+            else
+                frac += 0.75*sign;
+        }
+        if (DBL_MANT_DIG-bits >= 2 && !fmod(frac, 1))
+            frac++;
+    }
+
+    y += frac;
+    y -= bias;
+
+    if ((e2+DBL_MANT_DIG & INT_MAX) > emax-5) {
+        if (fabs(y) >= pow(2, DBL_MANT_DIG)) {
+            if (denormal && bits==DBL_MANT_DIG+e2-emin)
+                denormal = 0;
+            y *= 0.5;
+            e2++;
+        }
+        if (e2+DBL_MANT_DIG>emax || (denormal && frac))
+            errno = ERANGE;
+    }
+
+    return scalbn(y, e2);
+}
+
+static double hexfloat(FFFILE *f, int bits, int emin, int sign, int pok)
+{
+    uint32_t x = 0;
+    double y = 0;
+    double scale = 1;
+    double bias = 0;
+    int gottail = 0, gotrad = 0, gotdig = 0;
+    long long rp = 0;
+    long long dc = 0;
+    long long e2 = 0;
+    int d;
+    int c;
+
+    c = shgetc(f);
+
+    /* Skip leading zeros */
+    for (; c=='0'; c = shgetc(f))
+        gotdig = 1;
+
+    if (c=='.') {
+        gotrad = 1;
+        c = shgetc(f);
+        /* Count zeros after the radix point before significand */
+        for (rp=0; c=='0'; c = shgetc(f), rp--) gotdig = 1;
+    }
+
+    for (; c-'0'<10U || (c|32)-'a'<6U || c=='.'; c = shgetc(f)) {
+        if (c=='.') {
+            if (gotrad) break;
+            rp = dc;
+            gotrad = 1;
+        } else {
+            gotdig = 1;
+            if (c > '9') d = (c|32)+10-'a';
+            else d = c-'0';
+            if (dc<8) {
+                x = x*16 + d;
+            } else if (dc < DBL_MANT_DIG/4+1) {
+                y += d*(scale/=16);
+            } else if (d && !gottail) {
+                y += 0.5*scale;
+                gottail = 1;
+            }
+            dc++;
+        }
+    }
+    if (!gotdig) {
+        shunget(f);
+        if (pok) {
+            shunget(f);
+            if (gotrad) shunget(f);
+        } else {
+            shlim(f, 0);
+        }
+        return sign * 0.0;
+    }
+    if (!gotrad) rp = dc;
+    while (dc<8) x *= 16, dc++;
+    if ((c|32)=='p') {
+        e2 = scanexp(f, pok);
+        if (e2 == LLONG_MIN) {
+            if (pok) {
+                shunget(f);
+            } else {
+                shlim(f, 0);
+                return 0;
+            }
+            e2 = 0;
+        }
+    } else {
+        shunget(f);
+    }
+    e2 += 4*rp - 32;
+
+    if (!x) return sign * 0.0;
+    if (e2 > -emin) {
+        errno = ERANGE;
+        return sign * DBL_MAX * DBL_MAX;
+    }
+    if (e2 < emin-2*DBL_MANT_DIG) {
+        errno = ERANGE;
+        return sign * DBL_MIN * DBL_MIN;
+    }
+
+    while (x < 0x80000000) {
+        if (y>=0.5) {
+            x += x + 1;
+            y += y - 1;
+        } else {
+            x += x;
+            y += y;
+        }
+        e2--;
+    }
+
+    if (bits > 32+e2-emin) {
+        bits = 32+e2-emin;
+        if (bits<0) bits=0;
+    }
+
+    if (bits < DBL_MANT_DIG)
+        bias = copysign(scalbn(1, 32+DBL_MANT_DIG-bits-1), sign);
+
+    if (bits<32 && y && !(x&1)) x++, y=0;
+
+    y = bias + sign*(double)x + sign*y;
+    y -= bias;
+
+    if (!y) errno = ERANGE;
+
+    return scalbn(y, e2);
+}
+
+static double fffloatscan(FFFILE *f, int prec, int pok)
+{
+    int sign = 1;
+    size_t i;
+    int bits;
+    int emin;
+    int c;
+
+    switch (prec) {
+    case 0:
+        bits = FLT_MANT_DIG;
+        emin = FLT_MIN_EXP-bits;
+        break;
+    case 1:
+        bits = DBL_MANT_DIG;
+        emin = DBL_MIN_EXP-bits;
+        break;
+    case 2:
+        bits = DBL_MANT_DIG;
+        emin = DBL_MIN_EXP-bits;
+        break;
+    default:
+        return 0;
+    }
+
+    while (av_isspace((c = shgetc(f))));
+
+    if (c=='+' || c=='-') {
+        sign -= 2*(c=='-');
+        c = shgetc(f);
+    }
+
+    for (i=0; i<8 && (c|32)=="infinity"[i]; i++)
+        if (i<7) c = shgetc(f);
+    if (i==3 || i==8 || (i>3 && pok)) {
+        if (i!=8) {
+            shunget(f);
+            if (pok) for (; i>3; i--) shunget(f);
+        }
+        return sign * INFINITY;
+    }
+    if (!i) for (i=0; i<3 && (c|32)=="nan"[i]; i++)
+        if (i<2) c = shgetc(f);
+    if (i==3) {
+        if (shgetc(f) != '(') {
+            shunget(f);
+            return NAN;
+        }
+        for (i=1; ; i++) {
+            c = shgetc(f);
+            if (c-'0'<10U || c-'A'<26U || c-'a'<26U || c=='_')
+                continue;
+            if (c==')') return NAN;
+            shunget(f);
+            if (!pok) {
+                errno = EINVAL;
+                shlim(f, 0);
+                return 0;
+            }
+            while (i--) shunget(f);
+            return NAN;
+        }
+        return NAN;
+    }
+
+    if (i) {
+        shunget(f);
+        errno = EINVAL;
+        shlim(f, 0);
+        return 0;
+    }
+
+    if (c=='0') {
+        c = shgetc(f);
+        if ((c|32) == 'x')
+            return hexfloat(f, bits, emin, sign, pok);
+        shunget(f);
+        c = '0';
+    }
+
+    return decfloat(f, c, bits, emin, sign, pok);
+}
+
+static void *arg_n(va_list ap, unsigned int n)
+{
+    void *p;
+    unsigned int i;
+    va_list ap2;
+    va_copy(ap2, ap);
+    for (i=n; i>1; i--) va_arg(ap2, void *);
+    p = va_arg(ap2, void *);
+    va_end(ap2);
+    return p;
+}
+
+static void store_int(void *dest, int size, unsigned long long i)
+{
+    if (!dest) return;
+    switch (size) {
+    case SIZE_hh:
+        *(char *)dest = i;
+        break;
+    case SIZE_h:
+        *(short *)dest = i;
+        break;
+    case SIZE_def:
+        *(int *)dest = i;
+        break;
+    case SIZE_l:
+        *(long *)dest = i;
+        break;
+    case SIZE_ll:
+        *(long long *)dest = i;
+        break;
+    }
+}
+
+static int ff_vfscanf(FFFILE *f, const char *fmt, va_list ap)
+{
+    int width;
+    int size;
+    int base;
+    const unsigned char *p;
+    int c, t;
+    char *s;
+    void *dest=NULL;
+    int invert;
+    int matches=0;
+    unsigned long long x;
+    double y;
+    ptrdiff_t pos = 0;
+    unsigned char scanset[257];
+    size_t i;
+
+    for (p=(const unsigned char *)fmt; *p; p++) {
+
+        if (av_isspace(*p)) {
+            while (av_isspace(p[1])) p++;
+            shlim(f, 0);
+            while (av_isspace(shgetc(f)));
+            shunget(f);
+            pos += shcnt(f);
+            continue;
+        }
+        if (*p != '%' || p[1] == '%') {
+            shlim(f, 0);
+            if (*p == '%') {
+                p++;
+                while (av_isspace((c=shgetc(f))));
+            } else {
+                c = shgetc(f);
+            }
+            if (c!=*p) {
+                shunget(f);
+                if (c<0) goto input_fail;
+                goto match_fail;
+            }
+            pos += shcnt(f);
+            continue;
+        }
+
+        p++;
+        if (*p=='*') {
+            dest = 0; p++;
+        } else if (av_isdigit(*p) && p[1]=='$') {
+            dest = arg_n(ap, *p-'0'); p+=2;
+        } else {
+            dest = va_arg(ap, void *);
+        }
+
+        for (width=0; av_isdigit(*p); p++) {
+            width = 10*width + *p - '0';
+        }
+
+        if (*p=='m') {
+            s = 0;
+            p++;
+        }
+
+        size = SIZE_def;
+        switch (*p++) {
+        case 'h':
+            if (*p == 'h') p++, size = SIZE_hh;
+            else size = SIZE_h;
+            break;
+        case 'l':
+            if (*p == 'l') p++, size = SIZE_ll;
+            else size = SIZE_l;
+            break;
+        case 'j':
+            size = SIZE_ll;
+            break;
+        case 'z':
+        case 't':
+            size = SIZE_l;
+            break;
+        case 'L':
+            size = SIZE_L;
+            break;
+        case 'd': case 'i': case 'o': case 'u': case 'x':
+        case 'a': case 'e': case 'f': case 'g':
+        case 'A': case 'E': case 'F': case 'G': case 'X':
+        case 's': case 'c': case '[':
+        case 'S': case 'C':
+        case 'p': case 'n':
+            p--;
+            break;
+        default:
+            goto fmt_fail;
+        }
+
+        t = *p;
+
+        /* C or S */
+        if ((t&0x2f) == 3) {
+            t |= 32;
+            size = SIZE_l;
+        }
+
+        switch (t) {
+            case 'c':
+                if (width < 1) width = 1;
+            case '[':
+                break;
+            case 'n':
+                store_int(dest, size, pos);
+                /* do not increment match count, etc! */
+                continue;
+            default:
+                shlim(f, 0);
+                while (av_isspace(shgetc(f)));
+                shunget(f);
+                pos += shcnt(f);
+        }
+
+        shlim(f, width);
+        if (shgetc(f) < 0) goto input_fail;
+        shunget(f);
+
+        switch (t) {
+            case 's':
+            case 'c':
+            case '[':
+                if (t == 'c' || t == 's') {
+                    memset(scanset, -1, sizeof scanset);
+                    scanset[0] = 0;
+                    if (t == 's') {
+                        scanset[1 + '\t'] = 0;
+                        scanset[1 + '\n'] = 0;
+                        scanset[1 + '\v'] = 0;
+                        scanset[1 + '\f'] = 0;
+                        scanset[1 + '\r'] = 0;
+                        scanset[1 + ' ' ] = 0;
+                    }
+                } else {
+                    if (*++p == '^') p++, invert = 1;
+                    else invert = 0;
+                    memset(scanset, invert, sizeof scanset);
+                    scanset[0] = 0;
+                    if (*p == '-') p++, scanset[1+'-'] = 1-invert;
+                    else if (*p == ']') p++, scanset[1+']'] = 1-invert;
+                    for (; *p != ']'; p++) {
+                        if (!*p) goto fmt_fail;
+                        if (*p=='-' && p[1] && p[1] != ']')
+                            for (c=p++[-1]; c<*p; c++)
+                                scanset[1+c] = 1-invert;
+                        scanset[1+*p] = 1-invert;
+                    }
+                }
+                s = 0;
+                i = 0;
+                if ((s = dest)) {
+                    while (scanset[(c=shgetc(f))+1])
+                        s[i++] = c;
+                } else {
+                    while (scanset[(c=shgetc(f))+1]);
+                }
+                shunget(f);
+                if (!shcnt(f)) goto match_fail;
+                if (t == 'c' && shcnt(f) != width) goto match_fail;
+                if (t != 'c') {
+                    if (s) s[i] = 0;
+                }
+                break;
+            case 'p':
+            case 'X':
+            case 'x':
+                base = 16;
+                goto int_common;
+            case 'o':
+                base = 8;
+                goto int_common;
+            case 'd':
+            case 'u':
+                base = 10;
+                goto int_common;
+            case 'i':
+                base = 0;
+int_common:
+                x = ffintscan(f, base, 0, ULLONG_MAX);
+                if (!shcnt(f))
+                    goto match_fail;
+                if (t=='p' && dest)
+                    *(void **)dest = (void *)(uintptr_t)x;
+                else
+                    store_int(dest, size, x);
+                break;
+            case 'a': case 'A':
+            case 'e': case 'E':
+            case 'f': case 'F':
+            case 'g': case 'G':
+                y = fffloatscan(f, size, 0);
+                if (!shcnt(f))
+                    goto match_fail;
+                if (dest) {
+                    switch (size) {
+                    case SIZE_def:
+                        *(float *)dest = y;
+                        break;
+                    case SIZE_l:
+                        *(double *)dest = y;
+                        break;
+                    case SIZE_L:
+                        *(double *)dest = y;
+                        break;
+                    }
+                }
+                break;
+        }
+
+        pos += shcnt(f);
+        if (dest) matches++;
+    }
+    if (0) {
+fmt_fail:
+input_fail:
+        if (!matches) matches--;
+    }
+match_fail:
+    return matches;
+}
+
+static int ff_vsscanf(const char *s, const char *fmt, va_list ap)
+{
+    FFFILE f = {
+        .buf = (void *)s, .cookie = (void *)s,
+        .read = ffstring_read,
+    };
+
+    return ff_vfscanf(&f, fmt, ap);
+}
+
+int av_sscanf(const char *string, const char *format, ...)
+{
+    int ret;
+    va_list ap;
+    va_start(ap, format);
+    ret = ff_vsscanf(string, format, ap);
+    va_end(ap);
+    return ret;
+}
diff -Naur a/media/ffvpx/libavutil/avstring.c b/media/ffvpx/libavutil/avstring.c
--- a/media/ffvpx/libavutil/avstring.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/avstring.c	2023-04-06 12:50:24.493176583 +0200
@@ -19,17 +19,20 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <string.h>
 
 #include "config.h"
-#include "common.h"
 #include "mem.h"
 #include "avassert.h"
 #include "avstring.h"
 #include "bprint.h"
+#include "error.h"
+#include "macros.h"
+#include "version.h"
 
 int av_strstart(const char *str, const char *pfx, const char **ptr)
 {
@@ -136,16 +139,6 @@
     return p;
 }
 
-#if FF_API_D2STR
-char *av_d2str(double d)
-{
-    char *str = av_malloc(16);
-    if (str)
-        snprintf(str, 16, "%f", d);
-    return str;
-}
-#endif
-
 #define WHITESPACES " \n\t\r"
 
 char *av_get_token(const char **buf, const char *term)
diff -Naur a/media/ffvpx/libavutil/avstring.h b/media/ffvpx/libavutil/avstring.h
--- a/media/ffvpx/libavutil/avstring.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/avstring.h	2023-04-06 12:50:24.493176583 +0200
@@ -135,6 +135,7 @@
 /**
  * Get the count of continuous non zero chars starting from the beginning.
  *
+ * @param s   the string whose length to count
  * @param len maximum number of characters to check in the string, that
  *            is the maximum value which is returned by the function
  */
@@ -156,15 +157,6 @@
  */
 char *av_asprintf(const char *fmt, ...) av_printf_format(1, 2);
 
-#if FF_API_D2STR
-/**
- * Convert a number to an av_malloced string.
- * @deprecated  use av_asprintf() with "%f" or a more specific format
- */
-attribute_deprecated
-char *av_d2str(double d);
-#endif
-
 /**
  * Unescape the given string until a non escaped terminating char,
  * and return the token corresponding to the unescaped string.
diff -Naur a/media/ffvpx/libavutil/avutil.h b/media/ffvpx/libavutil/avutil.h
--- a/media/ffvpx/libavutil/avutil.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/avutil.h	2023-04-06 12:49:40.259395132 +0200
@@ -331,12 +331,18 @@
 #define av_int_list_length(list, term) \
     av_int_list_length_for_size(sizeof(*(list)), list, term)
 
+#if FF_API_AV_FOPEN_UTF8
 /**
  * Open a file using a UTF-8 filename.
  * The API of this function matches POSIX fopen(), errors are returned through
  * errno.
+ * @deprecated Avoid using it, as on Windows, the FILE* allocated by this
+ *             function may be allocated with a different CRT than the caller
+ *             who uses the FILE*. No replacement provided in public API.
  */
+attribute_deprecated
 FILE *av_fopen_utf8(const char *path, const char *mode);
+#endif
 
 /**
  * Return the fractional representation of the internal time base.
diff -Naur a/media/ffvpx/libavutil/avutil.symbols b/media/ffvpx/libavutil/avutil.symbols
--- a/media/ffvpx/libavutil/avutil.symbols	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/avutil.symbols	2023-04-06 12:55:20.669080807 +0200
@@ -30,15 +30,23 @@
 av_buffer_ref
 av_buffer_unref
 av_calloc
+av_channel_layout_check
+av_channel_layout_copy
+av_channel_layout_compare
 av_channel_layout_extract_channel
+av_channel_layout_describe
+av_channel_layout_from_mask
+av_channel_layout_uninit
 av_chroma_location_name
+av_chroma_location_enum_to_pos
+av_chroma_location_pos_to_enum
 av_color_primaries_name
 av_color_range_name
 av_color_space_name
 av_color_transfer_name
 av_compare_mod
 av_compare_ts
-#ifdef MOZ_WAYLAND
+#ifndef MOZ_FFVPX_AUDIOONLY
 av_content_light_metadata_create_side_data
 #endif
 av_cpu_count
@@ -46,7 +54,6 @@
 av_crc_get_table
 av_crc_init
 av_d2q
-av_d2str
 av_default_get_category
 av_default_item_name
 av_dict_copy
@@ -54,6 +61,7 @@
 av_dict_free
 av_dict_get
 av_dict_get_string
+av_dict_iterate
 av_dict_parse_string
 av_dict_set
 av_dict_set_int
@@ -68,20 +76,26 @@
 av_expr_parse
 av_expr_parse_and_eval
 av_fast_malloc
+av_fast_mallocz
 av_fast_realloc
 av_fifo_alloc
+av_fifo_alloc2
 av_fifo_alloc_array
+av_fifo_can_read
 av_fifo_drain
 av_fifo_free
 av_fifo_freep
+av_fifo_freep2
 av_fifo_generic_peek
 av_fifo_generic_read
 av_fifo_generic_write
 av_fifo_grow
 av_fifo_realloc2
+av_fifo_read
 av_fifo_reset
 av_fifo_size
 av_fifo_space
+av_fifo_write
 av_find_best_pix_fmt_of_2
 av_find_info_tag
 av_find_nearest_q_idx
@@ -96,42 +110,16 @@
 av_frame_copy
 av_frame_copy_props
 av_frame_free
-av_frame_get_best_effort_timestamp
 av_frame_get_buffer
-av_frame_get_channel_layout
-av_frame_get_channels
-av_frame_get_color_range
-av_frame_get_colorspace
-av_frame_get_decode_error_flags
-av_frame_get_metadata
-av_frame_get_pkt_duration
-av_frame_get_pkt_pos
-av_frame_get_pkt_size
 av_frame_get_plane_buffer
-av_frame_get_qp_table
-av_frame_get_sample_rate
 av_frame_get_side_data
 av_frame_is_writable
 av_frame_make_writable
 av_frame_move_ref
 av_frame_new_side_data
-#ifdef MOZ_WAYLAND
 av_frame_new_side_data_from_buf
-#endif
 av_frame_ref
 av_frame_remove_side_data
-av_frame_set_best_effort_timestamp
-av_frame_set_channel_layout
-av_frame_set_channels
-av_frame_set_color_range
-av_frame_set_colorspace
-av_frame_set_decode_error_flags
-av_frame_set_metadata
-av_frame_set_pkt_duration
-av_frame_set_pkt_pos
-av_frame_set_pkt_size
-av_frame_set_qp_table
-av_frame_set_sample_rate
 av_frame_side_data_name
 av_frame_unref
 av_free
@@ -146,7 +134,6 @@
 av_get_channel_layout_nb_channels
 av_get_channel_layout_string
 av_get_channel_name
-av_get_colorspace_name
 av_get_cpu_flags
 av_get_default_channel_layout
 av_get_known_color_name
@@ -201,9 +188,7 @@
 av_log_set_level
 av_malloc
 av_mallocz
-#ifdef MOZ_WAYLAND
 av_mastering_display_metadata_create_side_data
-#endif
 av_match_list
 av_match_name
 av_max_alloc
@@ -211,7 +196,6 @@
 av_memdup
 av_mul_q
 av_nearer_q
-av_opt_child_class_next
 av_opt_child_next
 av_opt_copy
 av_opt_eval_double
@@ -262,7 +246,6 @@
 av_opt_show2
 av_parse_color
 av_parse_cpu_caps
-av_parse_cpu_flags
 av_parse_ratio
 av_parse_time
 av_parse_video_rate
@@ -293,7 +276,6 @@
 av_samples_fill_arrays
 av_samples_get_buffer_size
 av_samples_set_silence
-av_set_cpu_flags_mask
 av_set_options_string
 av_small_strptime
 av_strcasecmp
@@ -314,9 +296,7 @@
 av_timegm
 av_usleep
 av_utf8_decode
-av_util_ffversion
 av_vbprintf
-av_version_info
 #ifndef MOZ_FFVPX_AUDIOONLY
 av_video_enc_params_create_side_data
 #endif
@@ -328,9 +308,6 @@
 avpriv_request_sample
 avpriv_scalarproduct_float_c
 avpriv_set_systematic_pal2
-avutil_configuration
-avutil_license
-avutil_version
 #if defined(XP_WIN) && !defined(_ARM64_)
 avpriv_emms_asm
 #endif
@@ -345,4 +322,3 @@
 av_hwframe_transfer_get_formats
 av_hwdevice_ctx_create_derived
 av_malloc_array
-av_mallocz_array
diff -Naur a/media/ffvpx/libavutil/base64.c b/media/ffvpx/libavutil/base64.c
--- a/media/ffvpx/libavutil/base64.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/base64.c	2023-04-06 12:49:40.259395132 +0200
@@ -24,10 +24,12 @@
  * @author Ryan Martell <rdm4@martellventures.com> (with lots of Michael)
  */
 
-#include "common.h"
+#include <limits.h>
+#include <stddef.h>
+
 #include "base64.h"
+#include "error.h"
 #include "intreadwrite.h"
-#include "timer.h"
 
 /* ---------------- private code */
 static const uint8_t map2[256] =
diff -Naur a/media/ffvpx/libavutil/bprint.c b/media/ffvpx/libavutil/bprint.c
--- a/media/ffvpx/libavutil/bprint.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/bprint.c	2023-04-06 12:49:40.259395132 +0200
@@ -18,16 +18,16 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
-#include "avassert.h"
 #include "avstring.h"
 #include "bprint.h"
-#include "common.h"
 #include "compat/va_copy.h"
 #include "error.h"
+#include "macros.h"
 #include "mem.h"
 
 #define av_bprint_room(buf) ((buf)->size - FFMIN((buf)->len, (buf)->size))
@@ -245,10 +245,8 @@
                 str = buf->str;
             buf->str = NULL;
         } else {
-            str = av_malloc(real_size);
-            if (str)
-                memcpy(str, buf->str, real_size);
-            else
+            str = av_memdup(buf->str, real_size);
+            if (!str)
                 ret = AVERROR(ENOMEM);
         }
         *ret_str = str;
diff -Naur a/media/ffvpx/libavutil/bprint.h b/media/ffvpx/libavutil/bprint.h
--- a/media/ffvpx/libavutil/bprint.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/bprint.h	2023-04-06 12:50:06.975471215 +0200
@@ -18,6 +18,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+/**
+ * @file
+ * @ingroup lavu_avbprint
+ * AVBPrint public header
+ */
+
 #ifndef AVUTIL_BPRINT_H
 #define AVUTIL_BPRINT_H
 
@@ -27,6 +33,14 @@
 #include "avstring.h"
 
 /**
+ * @defgroup lavu_avbprint AVBPrint
+ * @ingroup lavu_data
+ *
+ * A buffer to print data progressively
+ * @{
+ */
+
+/**
  * Define a structure with extra padding to a fixed size
  * This helps ensuring binary compatibility with future versions.
  */
@@ -48,14 +62,14 @@
  * Small buffers are kept in the structure itself, and thus require no
  * memory allocation at all (unless the contents of the buffer is needed
  * after the structure goes out of scope). This is almost as lightweight as
- * declaring a local "char buf[512]".
+ * declaring a local `char buf[512]`.
  *
  * The length of the string can go beyond the allocated size: the buffer is
  * then truncated, but the functions still keep account of the actual total
  * length.
  *
- * In other words, buf->len can be greater than buf->size and records the
- * total length of what would have been to the buffer if there had been
+ * In other words, AVBPrint.len can be greater than AVBPrint.size and records
+ * the total length of what would have been to the buffer if there had been
  * enough memory.
  *
  * Append operations do not need to be tested for failure: if a memory
@@ -63,20 +77,17 @@
  * is still updated. This situation can be tested with
  * av_bprint_is_complete().
  *
- * The size_max field determines several possible behaviours:
- *
- * size_max = -1 (= UINT_MAX) or any large value will let the buffer be
- * reallocated as necessary, with an amortized linear cost.
- *
- * size_max = 0 prevents writing anything to the buffer: only the total
- * length is computed. The write operations can then possibly be repeated in
- * a buffer with exactly the necessary size
- * (using size_init = size_max = len + 1).
- *
- * size_max = 1 is automatically replaced by the exact size available in the
- * structure itself, thus ensuring no dynamic memory allocation. The
- * internal buffer is large enough to hold a reasonable paragraph of text,
- * such as the current paragraph.
+ * The AVBPrint.size_max field determines several possible behaviours:
+ * - `size_max = -1` (= `UINT_MAX`) or any large value will let the buffer be
+ *   reallocated as necessary, with an amortized linear cost.
+ * - `size_max = 0` prevents writing anything to the buffer: only the total
+ *   length is computed. The write operations can then possibly be repeated in
+ *   a buffer with exactly the necessary size
+ *   (using `size_init = size_max = len + 1`).
+ * - `size_max = 1` is automatically replaced by the exact size available in the
+ *   structure itself, thus ensuring no dynamic memory allocation. The
+ *   internal buffer is large enough to hold a reasonable paragraph of text,
+ *   such as the current paragraph.
  */
 
 FF_PAD_STRUCTURE(AVBPrint, 1024,
@@ -88,12 +99,31 @@
 )
 
 /**
+ * @name Max size special values
  * Convenience macros for special values for av_bprint_init() size_max
  * parameter.
+ * @{
+ */
+
+/**
+ * Buffer will be reallocated as necessary, with an amortized linear cost.
  */
 #define AV_BPRINT_SIZE_UNLIMITED  ((unsigned)-1)
+/**
+ * Use the exact size available in the AVBPrint structure itself.
+ *
+ * Thus ensuring no dynamic memory allocation. The internal buffer is large
+ * enough to hold a reasonable paragraph of text, such as the current paragraph.
+ */
 #define AV_BPRINT_SIZE_AUTOMATIC  1
+/**
+ * Do not write anything to the buffer, only calculate the total length.
+ *
+ * The write operations can then possibly be repeated in a buffer with
+ * exactly the necessary size (using `size_init = size_max = AVBPrint.len + 1`).
+ */
 #define AV_BPRINT_SIZE_COUNT_ONLY 0
+/** @} */
 
 /**
  * Init a print buffer.
@@ -101,12 +131,12 @@
  * @param buf        buffer to init
  * @param size_init  initial size (including the final 0)
  * @param size_max   maximum size;
- *                   0 means do not write anything, just count the length;
- *                   1 is replaced by the maximum value for automatic storage;
- *                   any large value means that the internal buffer will be
- *                   reallocated as needed up to that limit; -1 is converted to
- *                   UINT_MAX, the largest limit possible.
- *                   Check also AV_BPRINT_SIZE_* macros.
+ *                   - `0` means do not write anything, just count the length
+ *                   - `1` is replaced by the maximum value for automatic storage
+ *                       any large value means that the internal buffer will be
+ *                       reallocated as needed up to that limit
+ *                   - `-1` is converted to `UINT_MAX`, the largest limit possible.
+ *                   Check also `AV_BPRINT_SIZE_*` macros.
  */
 void av_bprint_init(AVBPrint *buf, unsigned size_init, unsigned size_max);
 
@@ -216,4 +246,6 @@
 void av_bprint_escape(AVBPrint *dstbuf, const char *src, const char *special_chars,
                       enum AVEscapeMode mode, int flags);
 
+/** @} */
+
 #endif /* AVUTIL_BPRINT_H */
diff -Naur a/media/ffvpx/libavutil/bswap.h b/media/ffvpx/libavutil/bswap.h
--- a/media/ffvpx/libavutil/bswap.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/bswap.h	2023-04-06 12:50:06.975471215 +0200
@@ -40,6 +40,8 @@
 #   include "arm/bswap.h"
 #elif ARCH_AVR32
 #   include "avr32/bswap.h"
+#elif ARCH_RISCV
+#   include "riscv/bswap.h"
 #elif ARCH_SH4
 #   include "sh4/bswap.h"
 #elif ARCH_X86
diff -Naur a/media/ffvpx/libavutil/buffer.c b/media/ffvpx/libavutil/buffer.c
--- a/media/ffvpx/libavutil/buffer.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/buffer.c	2023-04-06 12:50:06.975471215 +0200
@@ -26,16 +26,11 @@
 #include "mem.h"
 #include "thread.h"
 
-AVBufferRef *av_buffer_create(uint8_t *data, buffer_size_t size,
-                              void (*free)(void *opaque, uint8_t *data),
-                              void *opaque, int flags)
+static AVBufferRef *buffer_create(AVBuffer *buf, uint8_t *data, size_t size,
+                                  void (*free)(void *opaque, uint8_t *data),
+                                  void *opaque, int flags)
 {
     AVBufferRef *ref = NULL;
-    AVBuffer    *buf = NULL;
-
-    buf = av_mallocz(sizeof(*buf));
-    if (!buf)
-        return NULL;
 
     buf->data     = data;
     buf->size     = size;
@@ -47,10 +42,8 @@
     buf->flags = flags;
 
     ref = av_mallocz(sizeof(*ref));
-    if (!ref) {
-        av_freep(&buf);
+    if (!ref)
         return NULL;
-    }
 
     ref->buffer = buf;
     ref->data   = data;
@@ -59,12 +52,29 @@
     return ref;
 }
 
+AVBufferRef *av_buffer_create(uint8_t *data, size_t size,
+                              void (*free)(void *opaque, uint8_t *data),
+                              void *opaque, int flags)
+{
+    AVBufferRef *ret;
+    AVBuffer *buf = av_mallocz(sizeof(*buf));
+    if (!buf)
+        return NULL;
+
+    ret = buffer_create(buf, data, size, free, opaque, flags);
+    if (!ret) {
+        av_free(buf);
+        return NULL;
+    }
+    return ret;
+}
+
 void av_buffer_default_free(void *opaque, uint8_t *data)
 {
     av_free(data);
 }
 
-AVBufferRef *av_buffer_alloc(buffer_size_t size)
+AVBufferRef *av_buffer_alloc(size_t size)
 {
     AVBufferRef *ret = NULL;
     uint8_t    *data = NULL;
@@ -80,7 +90,7 @@
     return ret;
 }
 
-AVBufferRef *av_buffer_allocz(buffer_size_t size)
+AVBufferRef *av_buffer_allocz(size_t size)
 {
     AVBufferRef *ret = av_buffer_alloc(size);
     if (!ret)
@@ -90,7 +100,7 @@
     return ret;
 }
 
-AVBufferRef *av_buffer_ref(AVBufferRef *buf)
+AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
 {
     AVBufferRef *ret = av_mallocz(sizeof(*ret));
 
@@ -117,8 +127,12 @@
         av_freep(dst);
 
     if (atomic_fetch_sub_explicit(&b->refcount, 1, memory_order_acq_rel) == 1) {
+        /* b->free below might already free the structure containing *b,
+         * so we have to read the flag now to avoid use-after-free. */
+        int free_avbuffer = !(b->flags_internal & BUFFER_FLAG_NO_FREE);
         b->free(b->opaque, b->data);
-        av_freep(&b);
+        if (free_avbuffer)
+            av_free(b);
     }
 }
 
@@ -166,7 +180,7 @@
     return 0;
 }
 
-int av_buffer_realloc(AVBufferRef **pbuf, buffer_size_t size)
+int av_buffer_realloc(AVBufferRef **pbuf, size_t size)
 {
     AVBufferRef *buf = *pbuf;
     uint8_t *tmp;
@@ -216,7 +230,7 @@
     return 0;
 }
 
-int av_buffer_replace(AVBufferRef **pdst, AVBufferRef *src)
+int av_buffer_replace(AVBufferRef **pdst, const AVBufferRef *src)
 {
     AVBufferRef *dst = *pdst;
     AVBufferRef *tmp;
@@ -242,8 +256,8 @@
     return 0;
 }
 
-AVBufferPool *av_buffer_pool_init2(buffer_size_t size, void *opaque,
-                                   AVBufferRef* (*alloc)(void *opaque, buffer_size_t size),
+AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque,
+                                   AVBufferRef* (*alloc)(void *opaque, size_t size),
                                    void (*pool_free)(void *opaque))
 {
     AVBufferPool *pool = av_mallocz(sizeof(*pool));
@@ -263,7 +277,7 @@
     return pool;
 }
 
-AVBufferPool *av_buffer_pool_init(buffer_size_t size, AVBufferRef* (*alloc)(buffer_size_t size))
+AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef* (*alloc)(size_t size))
 {
     AVBufferPool *pool = av_mallocz(sizeof(*pool));
     if (!pool)
@@ -327,9 +341,6 @@
     BufferPoolEntry *buf = opaque;
     AVBufferPool *pool = buf->pool;
 
-    if(CONFIG_MEMORY_POISONING)
-        memset(buf->data, FF_MEMORY_POISON, pool->size);
-
     ff_mutex_lock(&pool->mutex);
     buf->next = pool->pool;
     pool->pool = buf;
@@ -378,11 +389,13 @@
     ff_mutex_lock(&pool->mutex);
     buf = pool->pool;
     if (buf) {
-        ret = av_buffer_create(buf->data, pool->size, pool_release_buffer,
-                               buf, 0);
+        memset(&buf->buffer, 0, sizeof(buf->buffer));
+        ret = buffer_create(&buf->buffer, buf->data, pool->size,
+                            pool_release_buffer, buf, 0);
         if (ret) {
             pool->pool = buf->next;
             buf->next = NULL;
+            buf->buffer.flags_internal |= BUFFER_FLAG_NO_FREE;
         }
     } else {
         ret = pool_alloc_buffer(pool);
@@ -395,7 +408,7 @@
     return ret;
 }
 
-void *av_buffer_pool_buffer_get_opaque(AVBufferRef *ref)
+void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref)
 {
     BufferPoolEntry *buf = ref->buffer->opaque;
     av_assert0(buf);
diff -Naur a/media/ffvpx/libavutil/buffer.h b/media/ffvpx/libavutil/buffer.h
--- a/media/ffvpx/libavutil/buffer.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/buffer.h	2023-04-06 12:49:40.259395132 +0200
@@ -28,8 +28,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "version.h"
-
 /**
  * @defgroup lavu_buffer AVBuffer
  * @ingroup lavu_data
@@ -93,11 +91,7 @@
     /**
      * Size of data in bytes.
      */
-#if FF_API_BUFFER_SIZE_T
-    int      size;
-#else
     size_t   size;
-#endif
 } AVBufferRef;
 
 /**
@@ -105,21 +99,13 @@
  *
  * @return an AVBufferRef of given size or NULL when out of memory
  */
-#if FF_API_BUFFER_SIZE_T
-AVBufferRef *av_buffer_alloc(int size);
-#else
 AVBufferRef *av_buffer_alloc(size_t size);
-#endif
 
 /**
  * Same as av_buffer_alloc(), except the returned buffer will be initialized
  * to zero.
  */
-#if FF_API_BUFFER_SIZE_T
-AVBufferRef *av_buffer_allocz(int size);
-#else
 AVBufferRef *av_buffer_allocz(size_t size);
-#endif
 
 /**
  * Always treat the buffer as read-only, even when it has only one
@@ -142,11 +128,7 @@
  *
  * @return an AVBufferRef referring to data on success, NULL on failure.
  */
-#if FF_API_BUFFER_SIZE_T
-AVBufferRef *av_buffer_create(uint8_t *data, int size,
-#else
 AVBufferRef *av_buffer_create(uint8_t *data, size_t size,
-#endif
                               void (*free)(void *opaque, uint8_t *data),
                               void *opaque, int flags);
 
@@ -163,7 +145,7 @@
  * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
  * failure.
  */
-AVBufferRef *av_buffer_ref(AVBufferRef *buf);
+AVBufferRef *av_buffer_ref(const AVBufferRef *buf);
 
 /**
  * Free a given reference and automatically free the buffer if there are no more
@@ -214,11 +196,7 @@
  * reference to it (i.e. the one passed to this function). In all other cases
  * a new buffer is allocated and the data is copied.
  */
-#if FF_API_BUFFER_SIZE_T
-int av_buffer_realloc(AVBufferRef **buf, int size);
-#else
 int av_buffer_realloc(AVBufferRef **buf, size_t size);
-#endif
 
 /**
  * Ensure dst refers to the same data as src.
@@ -234,7 +212,7 @@
  * @return 0 on success
  *         AVERROR(ENOMEM) on memory allocation failure.
  */
-int av_buffer_replace(AVBufferRef **dst, AVBufferRef *src);
+int av_buffer_replace(AVBufferRef **dst, const AVBufferRef *src);
 
 /**
  * @}
@@ -285,11 +263,7 @@
  * (av_buffer_alloc()).
  * @return newly created buffer pool on success, NULL on error.
  */
-#if FF_API_BUFFER_SIZE_T
-AVBufferPool *av_buffer_pool_init(int size, AVBufferRef* (*alloc)(int size));
-#else
 AVBufferPool *av_buffer_pool_init(size_t size, AVBufferRef* (*alloc)(size_t size));
-#endif
 
 /**
  * Allocate and initialize a buffer pool with a more complex allocator.
@@ -306,13 +280,8 @@
  *                  data. May be NULL.
  * @return newly created buffer pool on success, NULL on error.
  */
-#if FF_API_BUFFER_SIZE_T
-AVBufferPool *av_buffer_pool_init2(int size, void *opaque,
-                                   AVBufferRef* (*alloc)(void *opaque, int size),
-#else
 AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque,
                                    AVBufferRef* (*alloc)(void *opaque, size_t size),
-#endif
                                    void (*pool_free)(void *opaque));
 
 /**
@@ -344,7 +313,7 @@
  * therefore you have to use this function to access the original opaque
  * parameter of an allocated buffer.
  */
-void *av_buffer_pool_buffer_get_opaque(AVBufferRef *ref);
+void *av_buffer_pool_buffer_get_opaque(const AVBufferRef *ref);
 
 /**
  * @}
diff -Naur a/media/ffvpx/libavutil/buffer_internal.h b/media/ffvpx/libavutil/buffer_internal.h
--- a/media/ffvpx/libavutil/buffer_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/buffer_internal.h	2023-04-06 12:49:40.259395132 +0200
@@ -22,7 +22,6 @@
 #include <stdatomic.h>
 #include <stdint.h>
 
-#include "internal.h"
 #include "buffer.h"
 #include "thread.h"
 
@@ -30,10 +29,15 @@
  * The buffer was av_realloc()ed, so it is reallocatable.
  */
 #define BUFFER_FLAG_REALLOCATABLE (1 << 0)
+/**
+ * The AVBuffer structure is part of a larger structure
+ * and should not be freed.
+ */
+#define BUFFER_FLAG_NO_FREE       (1 << 1)
 
 struct AVBuffer {
     uint8_t *data; /**< data described by this buffer */
-    buffer_size_t size; /**< size of data in bytes */
+    size_t size; /**< size of data in bytes */
 
     /**
      *  number of existing AVBufferRef instances referring to this buffer
@@ -73,6 +77,12 @@
 
     AVBufferPool *pool;
     struct BufferPoolEntry *next;
+
+    /*
+     * An AVBuffer structure to (re)use as AVBuffer for subsequent uses
+     * of this BufferPoolEntry.
+     */
+    AVBuffer buffer;
 } BufferPoolEntry;
 
 struct AVBufferPool {
@@ -90,10 +100,10 @@
      */
     atomic_uint refcount;
 
-    buffer_size_t size;
+    size_t size;
     void *opaque;
-    AVBufferRef* (*alloc)(buffer_size_t size);
-    AVBufferRef* (*alloc2)(void *opaque, buffer_size_t size);
+    AVBufferRef* (*alloc)(size_t size);
+    AVBufferRef* (*alloc2)(void *opaque, size_t size);
     void         (*pool_free)(void *opaque);
 };
 
diff -Naur a/media/ffvpx/libavutil/channel_layout.c b/media/ffvpx/libavutil/channel_layout.c
--- a/media/ffvpx/libavutil/channel_layout.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/channel_layout.c	2023-04-06 12:50:24.493176583 +0200
@@ -24,12 +24,19 @@
  */
 
 #include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
 
-#include "avstring.h"
-#include "avutil.h"
+#include "avassert.h"
 #include "channel_layout.h"
 #include "bprint.h"
 #include "common.h"
+#include "error.h"
+#include "macros.h"
+#include "opt.h"
+
+#define CHAN_IS_AMBI(x) ((x) >= AV_CHAN_AMBISONIC_BASE &&\
+                         (x) <= AV_CHAN_AMBISONIC_END)
 
 struct channel_name {
     const char *name;
@@ -37,81 +44,168 @@
 };
 
 static const struct channel_name channel_names[] = {
-     [0] = { "FL",        "front left"            },
-     [1] = { "FR",        "front right"           },
-     [2] = { "FC",        "front center"          },
-     [3] = { "LFE",       "low frequency"         },
-     [4] = { "BL",        "back left"             },
-     [5] = { "BR",        "back right"            },
-     [6] = { "FLC",       "front left-of-center"  },
-     [7] = { "FRC",       "front right-of-center" },
-     [8] = { "BC",        "back center"           },
-     [9] = { "SL",        "side left"             },
-    [10] = { "SR",        "side right"            },
-    [11] = { "TC",        "top center"            },
-    [12] = { "TFL",       "top front left"        },
-    [13] = { "TFC",       "top front center"      },
-    [14] = { "TFR",       "top front right"       },
-    [15] = { "TBL",       "top back left"         },
-    [16] = { "TBC",       "top back center"       },
-    [17] = { "TBR",       "top back right"        },
-    [29] = { "DL",        "downmix left"          },
-    [30] = { "DR",        "downmix right"         },
-    [31] = { "WL",        "wide left"             },
-    [32] = { "WR",        "wide right"            },
-    [33] = { "SDL",       "surround direct left"  },
-    [34] = { "SDR",       "surround direct right" },
-    [35] = { "LFE2",      "low frequency 2"       },
-    [36] = { "TSL",       "top side left"         },
-    [37] = { "TSR",       "top side right"        },
-    [38] = { "BFC",       "bottom front center"   },
-    [39] = { "BFL",       "bottom front left"     },
-    [40] = { "BFR",       "bottom front right"    },
+    [AV_CHAN_FRONT_LEFT           ] = { "FL",        "front left"            },
+    [AV_CHAN_FRONT_RIGHT          ] = { "FR",        "front right"           },
+    [AV_CHAN_FRONT_CENTER         ] = { "FC",        "front center"          },
+    [AV_CHAN_LOW_FREQUENCY        ] = { "LFE",       "low frequency"         },
+    [AV_CHAN_BACK_LEFT            ] = { "BL",        "back left"             },
+    [AV_CHAN_BACK_RIGHT           ] = { "BR",        "back right"            },
+    [AV_CHAN_FRONT_LEFT_OF_CENTER ] = { "FLC",       "front left-of-center"  },
+    [AV_CHAN_FRONT_RIGHT_OF_CENTER] = { "FRC",       "front right-of-center" },
+    [AV_CHAN_BACK_CENTER          ] = { "BC",        "back center"           },
+    [AV_CHAN_SIDE_LEFT            ] = { "SL",        "side left"             },
+    [AV_CHAN_SIDE_RIGHT           ] = { "SR",        "side right"            },
+    [AV_CHAN_TOP_CENTER           ] = { "TC",        "top center"            },
+    [AV_CHAN_TOP_FRONT_LEFT       ] = { "TFL",       "top front left"        },
+    [AV_CHAN_TOP_FRONT_CENTER     ] = { "TFC",       "top front center"      },
+    [AV_CHAN_TOP_FRONT_RIGHT      ] = { "TFR",       "top front right"       },
+    [AV_CHAN_TOP_BACK_LEFT        ] = { "TBL",       "top back left"         },
+    [AV_CHAN_TOP_BACK_CENTER      ] = { "TBC",       "top back center"       },
+    [AV_CHAN_TOP_BACK_RIGHT       ] = { "TBR",       "top back right"        },
+    [AV_CHAN_STEREO_LEFT          ] = { "DL",        "downmix left"          },
+    [AV_CHAN_STEREO_RIGHT         ] = { "DR",        "downmix right"         },
+    [AV_CHAN_WIDE_LEFT            ] = { "WL",        "wide left"             },
+    [AV_CHAN_WIDE_RIGHT           ] = { "WR",        "wide right"            },
+    [AV_CHAN_SURROUND_DIRECT_LEFT ] = { "SDL",       "surround direct left"  },
+    [AV_CHAN_SURROUND_DIRECT_RIGHT] = { "SDR",       "surround direct right" },
+    [AV_CHAN_LOW_FREQUENCY_2      ] = { "LFE2",      "low frequency 2"       },
+    [AV_CHAN_TOP_SIDE_LEFT        ] = { "TSL",       "top side left"         },
+    [AV_CHAN_TOP_SIDE_RIGHT       ] = { "TSR",       "top side right"        },
+    [AV_CHAN_BOTTOM_FRONT_CENTER  ] = { "BFC",       "bottom front center"   },
+    [AV_CHAN_BOTTOM_FRONT_LEFT    ] = { "BFL",       "bottom front left"     },
+    [AV_CHAN_BOTTOM_FRONT_RIGHT   ] = { "BFR",       "bottom front right"    },
 };
 
-static const char *get_channel_name(int channel_id)
+static const char *get_channel_name(enum AVChannel channel_id)
 {
-    if (channel_id < 0 || channel_id >= FF_ARRAY_ELEMS(channel_names))
+    if ((unsigned) channel_id >= FF_ARRAY_ELEMS(channel_names) ||
+        !channel_names[channel_id].name)
         return NULL;
     return channel_names[channel_id].name;
 }
 
-static const struct {
+void av_channel_name_bprint(AVBPrint *bp, enum AVChannel channel_id)
+{
+    if (channel_id >= AV_CHAN_AMBISONIC_BASE &&
+        channel_id <= AV_CHAN_AMBISONIC_END)
+        av_bprintf(bp, "AMBI%d", channel_id - AV_CHAN_AMBISONIC_BASE);
+    else if ((unsigned)channel_id < FF_ARRAY_ELEMS(channel_names) &&
+             channel_names[channel_id].name)
+        av_bprintf(bp, "%s", channel_names[channel_id].name);
+    else if (channel_id == AV_CHAN_NONE)
+        av_bprintf(bp, "NONE");
+    else
+        av_bprintf(bp, "USR%d", channel_id);
+}
+
+int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel_id)
+{
+    AVBPrint bp;
+
+    if (!buf && buf_size)
+        return AVERROR(EINVAL);
+
+    av_bprint_init_for_buffer(&bp, buf, buf_size);
+    av_channel_name_bprint(&bp, channel_id);
+
+    return bp.len;
+}
+
+void av_channel_description_bprint(AVBPrint *bp, enum AVChannel channel_id)
+{
+    if (channel_id >= AV_CHAN_AMBISONIC_BASE &&
+        channel_id <= AV_CHAN_AMBISONIC_END)
+        av_bprintf(bp, "ambisonic ACN %d", channel_id - AV_CHAN_AMBISONIC_BASE);
+    else if ((unsigned)channel_id < FF_ARRAY_ELEMS(channel_names) &&
+             channel_names[channel_id].description)
+        av_bprintf(bp, "%s", channel_names[channel_id].description);
+    else if (channel_id == AV_CHAN_NONE)
+        av_bprintf(bp, "none");
+    else
+        av_bprintf(bp, "user %d", channel_id);
+}
+
+int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel_id)
+{
+    AVBPrint bp;
+
+    if (!buf && buf_size)
+        return AVERROR(EINVAL);
+
+    av_bprint_init_for_buffer(&bp, buf, buf_size);
+    av_channel_description_bprint(&bp, channel_id);
+
+    return bp.len;
+}
+
+enum AVChannel av_channel_from_string(const char *str)
+{
+    int i;
+    char *endptr = (char *)str;
+    enum AVChannel id = AV_CHAN_NONE;
+
+    if (!strncmp(str, "AMBI", 4)) {
+        i = strtol(str + 4, NULL, 0);
+        if (i < 0 || i > AV_CHAN_AMBISONIC_END - AV_CHAN_AMBISONIC_BASE)
+            return AV_CHAN_NONE;
+        return AV_CHAN_AMBISONIC_BASE + i;
+    }
+
+    for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++) {
+        if (channel_names[i].name && !strcmp(str, channel_names[i].name))
+            return i;
+    }
+    if (!strncmp(str, "USR", 3)) {
+        const char *p = str + 3;
+        id = strtol(p, &endptr, 0);
+    }
+    if (id >= 0 && !*endptr)
+        return id;
+
+    return AV_CHAN_NONE;
+}
+
+struct channel_layout_name {
     const char *name;
-    int         nb_channels;
-    uint64_t     layout;
-} channel_layout_map[] = {
-    { "mono",        1,  AV_CH_LAYOUT_MONO },
-    { "stereo",      2,  AV_CH_LAYOUT_STEREO },
-    { "2.1",         3,  AV_CH_LAYOUT_2POINT1 },
-    { "3.0",         3,  AV_CH_LAYOUT_SURROUND },
-    { "3.0(back)",   3,  AV_CH_LAYOUT_2_1 },
-    { "4.0",         4,  AV_CH_LAYOUT_4POINT0 },
-    { "quad",        4,  AV_CH_LAYOUT_QUAD },
-    { "quad(side)",  4,  AV_CH_LAYOUT_2_2 },
-    { "3.1",         4,  AV_CH_LAYOUT_3POINT1 },
-    { "5.0",         5,  AV_CH_LAYOUT_5POINT0_BACK },
-    { "5.0(side)",   5,  AV_CH_LAYOUT_5POINT0 },
-    { "4.1",         5,  AV_CH_LAYOUT_4POINT1 },
-    { "5.1",         6,  AV_CH_LAYOUT_5POINT1_BACK },
-    { "5.1(side)",   6,  AV_CH_LAYOUT_5POINT1 },
-    { "6.0",         6,  AV_CH_LAYOUT_6POINT0 },
-    { "6.0(front)",  6,  AV_CH_LAYOUT_6POINT0_FRONT },
-    { "hexagonal",   6,  AV_CH_LAYOUT_HEXAGONAL },
-    { "6.1",         7,  AV_CH_LAYOUT_6POINT1 },
-    { "6.1(back)",   7,  AV_CH_LAYOUT_6POINT1_BACK },
-    { "6.1(front)",  7,  AV_CH_LAYOUT_6POINT1_FRONT },
-    { "7.0",         7,  AV_CH_LAYOUT_7POINT0 },
-    { "7.0(front)",  7,  AV_CH_LAYOUT_7POINT0_FRONT },
-    { "7.1",         8,  AV_CH_LAYOUT_7POINT1 },
-    { "7.1(wide)",   8,  AV_CH_LAYOUT_7POINT1_WIDE_BACK },
-    { "7.1(wide-side)",   8,  AV_CH_LAYOUT_7POINT1_WIDE },
-    { "octagonal",   8,  AV_CH_LAYOUT_OCTAGONAL },
-    { "hexadecagonal", 16, AV_CH_LAYOUT_HEXADECAGONAL },
-    { "downmix",     2,  AV_CH_LAYOUT_STEREO_DOWNMIX, },
-    { "22.2",          24, AV_CH_LAYOUT_22POINT2, },
+    AVChannelLayout layout;
+};
+
+static const struct channel_layout_name channel_layout_map[] = {
+    { "mono",           AV_CHANNEL_LAYOUT_MONO                },
+    { "stereo",         AV_CHANNEL_LAYOUT_STEREO              },
+    { "2.1",            AV_CHANNEL_LAYOUT_2POINT1             },
+    { "3.0",            AV_CHANNEL_LAYOUT_SURROUND            },
+    { "3.0(back)",      AV_CHANNEL_LAYOUT_2_1                 },
+    { "4.0",            AV_CHANNEL_LAYOUT_4POINT0             },
+    { "quad",           AV_CHANNEL_LAYOUT_QUAD                },
+    { "quad(side)",     AV_CHANNEL_LAYOUT_2_2                 },
+    { "3.1",            AV_CHANNEL_LAYOUT_3POINT1             },
+    { "5.0",            AV_CHANNEL_LAYOUT_5POINT0_BACK        },
+    { "5.0(side)",      AV_CHANNEL_LAYOUT_5POINT0             },
+    { "4.1",            AV_CHANNEL_LAYOUT_4POINT1             },
+    { "5.1",            AV_CHANNEL_LAYOUT_5POINT1_BACK        },
+    { "5.1(side)",      AV_CHANNEL_LAYOUT_5POINT1             },
+    { "6.0",            AV_CHANNEL_LAYOUT_6POINT0             },
+    { "6.0(front)",     AV_CHANNEL_LAYOUT_6POINT0_FRONT       },
+    { "hexagonal",      AV_CHANNEL_LAYOUT_HEXAGONAL           },
+    { "6.1",            AV_CHANNEL_LAYOUT_6POINT1             },
+    { "6.1(back)",      AV_CHANNEL_LAYOUT_6POINT1_BACK        },
+    { "6.1(front)",     AV_CHANNEL_LAYOUT_6POINT1_FRONT       },
+    { "7.0",            AV_CHANNEL_LAYOUT_7POINT0             },
+    { "7.0(front)",     AV_CHANNEL_LAYOUT_7POINT0_FRONT       },
+    { "7.1",            AV_CHANNEL_LAYOUT_7POINT1             },
+    { "7.1(wide)",      AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK   },
+    { "7.1(wide-side)", AV_CHANNEL_LAYOUT_7POINT1_WIDE        },
+    { "7.1(top)",       AV_CHANNEL_LAYOUT_7POINT1_TOP_BACK    },
+    { "octagonal",      AV_CHANNEL_LAYOUT_OCTAGONAL           },
+    { "cube",           AV_CHANNEL_LAYOUT_CUBE                },
+    { "hexadecagonal",  AV_CHANNEL_LAYOUT_HEXADECAGONAL       },
+    { "downmix",        AV_CHANNEL_LAYOUT_STEREO_DOWNMIX,     },
+    { "22.2",           AV_CHANNEL_LAYOUT_22POINT2,           },
 };
 
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
 static uint64_t get_channel_layout_single(const char *name, int name_len)
 {
     int i;
@@ -121,7 +215,7 @@
     for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++) {
         if (strlen(channel_layout_map[i].name) == name_len &&
             !memcmp(channel_layout_map[i].name, name, name_len))
-            return channel_layout_map[i].layout;
+            return channel_layout_map[i].layout.u.mask;
     }
     for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++)
         if (channel_names[i].name &&
@@ -189,8 +283,8 @@
         nb_channels = av_get_channel_layout_nb_channels(channel_layout);
 
     for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++)
-        if (nb_channels    == channel_layout_map[i].nb_channels &&
-            channel_layout == channel_layout_map[i].layout) {
+        if (nb_channels    == channel_layout_map[i].layout.nb_channels &&
+            channel_layout == channel_layout_map[i].layout.u.mask) {
             av_bprintf(bp, "%s", channel_layout_map[i].name);
             return;
         }
@@ -231,8 +325,8 @@
 int64_t av_get_default_channel_layout(int nb_channels) {
     int i;
     for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++)
-        if (nb_channels == channel_layout_map[i].nb_channels)
-            return channel_layout_map[i].layout;
+        if (nb_channels == channel_layout_map[i].layout.nb_channels)
+            return channel_layout_map[i].layout.u.mask;
     return 0;
 }
 
@@ -287,7 +381,626 @@
 {
     if (index >= FF_ARRAY_ELEMS(channel_layout_map))
         return AVERROR_EOF;
-    if (layout) *layout = channel_layout_map[index].layout;
+    if (layout) *layout = channel_layout_map[index].layout.u.mask;
     if (name)   *name   = channel_layout_map[index].name;
     return 0;
 }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+int av_channel_layout_from_mask(AVChannelLayout *channel_layout,
+                                uint64_t mask)
+{
+    if (!mask)
+        return AVERROR(EINVAL);
+
+    channel_layout->order       = AV_CHANNEL_ORDER_NATIVE;
+    channel_layout->nb_channels = av_popcount64(mask);
+    channel_layout->u.mask      = mask;
+
+    return 0;
+}
+
+int av_channel_layout_from_string(AVChannelLayout *channel_layout,
+                                  const char *str)
+{
+    int i;
+    int channels = 0, nb_channels = 0, native = 1;
+    enum AVChannel highest_channel = AV_CHAN_NONE;
+    const char *dup;
+    char *chlist, *end;
+    uint64_t mask = 0;
+
+    /* channel layout names */
+    for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++) {
+        if (channel_layout_map[i].name && !strcmp(str, channel_layout_map[i].name)) {
+            *channel_layout = channel_layout_map[i].layout;
+            return 0;
+        }
+    }
+
+    /* ambisonic */
+    if (!strncmp(str, "ambisonic ", 10)) {
+        const char *p = str + 10;
+        char *endptr;
+        AVChannelLayout extra = {0};
+        int order;
+
+        order = strtol(p, &endptr, 0);
+        if (order < 0 || order + 1  > INT_MAX / (order + 1) ||
+            (*endptr && *endptr != '+'))
+            return AVERROR(EINVAL);
+
+        channel_layout->order       = AV_CHANNEL_ORDER_AMBISONIC;
+        channel_layout->nb_channels = (order + 1) * (order + 1);
+
+        if (*endptr) {
+            int ret = av_channel_layout_from_string(&extra, endptr + 1);
+            if (ret < 0)
+                return ret;
+            if (extra.nb_channels >= INT_MAX - channel_layout->nb_channels) {
+                av_channel_layout_uninit(&extra);
+                return AVERROR(EINVAL);
+            }
+
+            if (extra.order == AV_CHANNEL_ORDER_NATIVE) {
+                channel_layout->u.mask = extra.u.mask;
+            } else {
+                channel_layout->order = AV_CHANNEL_ORDER_CUSTOM;
+                channel_layout->u.map =
+                    av_calloc(channel_layout->nb_channels + extra.nb_channels,
+                              sizeof(*channel_layout->u.map));
+                if (!channel_layout->u.map) {
+                    av_channel_layout_uninit(&extra);
+                    return AVERROR(ENOMEM);
+                }
+
+                for (i = 0; i < channel_layout->nb_channels; i++)
+                    channel_layout->u.map[i].id = AV_CHAN_AMBISONIC_BASE + i;
+                for (i = 0; i < extra.nb_channels; i++) {
+                    enum AVChannel ch = av_channel_layout_channel_from_index(&extra, i);
+                    if (CHAN_IS_AMBI(ch)) {
+                        av_channel_layout_uninit(&extra);
+                        return AVERROR(EINVAL);
+                    }
+                    channel_layout->u.map[channel_layout->nb_channels + i].id = ch;
+                    if (extra.order == AV_CHANNEL_ORDER_CUSTOM &&
+                        extra.u.map[i].name[0])
+                        av_strlcpy(channel_layout->u.map[channel_layout->nb_channels + i].name,
+                                   extra.u.map[i].name,
+                                   sizeof(channel_layout->u.map[channel_layout->nb_channels + i].name));
+                }
+            }
+            channel_layout->nb_channels += extra.nb_channels;
+            av_channel_layout_uninit(&extra);
+        }
+
+        return 0;
+    }
+
+    chlist = av_strdup(str);
+    if (!chlist)
+        return AVERROR(ENOMEM);
+
+    /* channel names */
+    av_sscanf(str, "%d channels (%[^)]", &nb_channels, chlist);
+    end = strchr(str, ')');
+
+    dup = chlist;
+    while (*dup) {
+        char *channel, *chname;
+        int ret = av_opt_get_key_value(&dup, "@", "+", AV_OPT_FLAG_IMPLICIT_KEY, &channel, &chname);
+        if (ret < 0) {
+            av_free(chlist);
+            return ret;
+        }
+        if (*dup)
+            dup++; // skip separator
+        if (channel && !*channel)
+            av_freep(&channel);
+        for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++) {
+            if (channel_names[i].name && !strcmp(channel ? channel : chname, channel_names[i].name)) {
+                if (channel || i < highest_channel || mask & (1ULL << i))
+                    native = 0; // Not a native layout, use a custom one
+                highest_channel = i;
+                mask |= 1ULL << i;
+                break;
+            }
+        }
+
+        if (!channel && i >= FF_ARRAY_ELEMS(channel_names)) {
+            char *endptr = chname;
+            enum AVChannel id = AV_CHAN_NONE;
+
+            if (!strncmp(chname, "USR", 3)) {
+                const char *p = chname + 3;
+                id = strtol(p, &endptr, 0);
+            }
+            if (id < 0 || *endptr) {
+                native = 0; // Unknown channel name
+                channels = 0;
+                mask = 0;
+                av_free(chname);
+                break;
+            }
+            if (id > 63)
+                native = 0; // Not a native layout, use a custom one
+            else {
+                if (id < highest_channel || mask & (1ULL << id))
+                    native = 0; // Not a native layout, use a custom one
+                highest_channel = id;
+                mask |= 1ULL << id;
+            }
+        }
+        channels++;
+        av_free(channel);
+        av_free(chname);
+    }
+
+    if (mask && native) {
+        av_free(chlist);
+        if (nb_channels && ((nb_channels != channels) || (!end || *++end)))
+            return AVERROR(EINVAL);
+        av_channel_layout_from_mask(channel_layout, mask);
+        return 0;
+    }
+
+    /* custom layout of channel names */
+    if (channels && !native) {
+        int idx = 0;
+
+        if (nb_channels && ((nb_channels != channels) || (!end || *++end))) {
+            av_free(chlist);
+            return AVERROR(EINVAL);
+        }
+
+        channel_layout->u.map = av_calloc(channels, sizeof(*channel_layout->u.map));
+        if (!channel_layout->u.map) {
+            av_free(chlist);
+            return AVERROR(ENOMEM);
+        }
+
+        channel_layout->order = AV_CHANNEL_ORDER_CUSTOM;
+        channel_layout->nb_channels = channels;
+
+        dup = chlist;
+        while (*dup) {
+            char *channel, *chname;
+            int ret = av_opt_get_key_value(&dup, "@", "+", AV_OPT_FLAG_IMPLICIT_KEY, &channel, &chname);
+            if (ret < 0) {
+                av_freep(&channel_layout->u.map);
+                av_free(chlist);
+                return ret;
+            }
+            if (*dup)
+                dup++; // skip separator
+            for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++) {
+                if (channel_names[i].name && !strcmp(channel ? channel : chname, channel_names[i].name)) {
+                    channel_layout->u.map[idx].id = i;
+                    if (channel)
+                        av_strlcpy(channel_layout->u.map[idx].name, chname, sizeof(channel_layout->u.map[idx].name));
+                    idx++;
+                    break;
+                }
+            }
+            if (i >= FF_ARRAY_ELEMS(channel_names)) {
+                const char *p = (channel ? channel : chname) + 3;
+                channel_layout->u.map[idx].id = strtol(p, NULL, 0);
+                if (channel)
+                    av_strlcpy(channel_layout->u.map[idx].name, chname, sizeof(channel_layout->u.map[idx].name));
+                idx++;
+            }
+            av_free(channel);
+            av_free(chname);
+        }
+        av_free(chlist);
+
+        return 0;
+    }
+    av_freep(&chlist);
+
+    errno = 0;
+    mask = strtoull(str, &end, 0);
+
+    /* channel layout mask */
+    if (!errno && !*end && !strchr(str, '-') && mask) {
+        av_channel_layout_from_mask(channel_layout, mask);
+        return 0;
+    }
+
+    errno = 0;
+    channels = strtol(str, &end, 10);
+
+    /* number of channels */
+    if (!errno && !strcmp(end, "c") && channels > 0) {
+        av_channel_layout_default(channel_layout, channels);
+        if (channel_layout->order == AV_CHANNEL_ORDER_NATIVE)
+            return 0;
+    }
+
+    /* number of unordered channels */
+    if (!errno && (!strcmp(end, "C") || !strcmp(end, " channels"))
+        && channels > 0) {
+        channel_layout->order = AV_CHANNEL_ORDER_UNSPEC;
+        channel_layout->nb_channels = channels;
+        return 0;
+    }
+
+    return AVERROR(EINVAL);
+}
+
+void av_channel_layout_uninit(AVChannelLayout *channel_layout)
+{
+    if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM)
+        av_freep(&channel_layout->u.map);
+    memset(channel_layout, 0, sizeof(*channel_layout));
+}
+
+int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
+{
+    av_channel_layout_uninit(dst);
+    *dst = *src;
+    if (src->order == AV_CHANNEL_ORDER_CUSTOM) {
+        dst->u.map = av_malloc_array(src->nb_channels, sizeof(*dst->u.map));
+        if (!dst->u.map)
+            return AVERROR(ENOMEM);
+        memcpy(dst->u.map, src->u.map, src->nb_channels * sizeof(*src->u.map));
+    }
+    return 0;
+}
+
+/**
+ * If the layout is n-th order standard-order ambisonic, with optional
+ * extra non-diegetic channels at the end, return the order.
+ * Return a negative error code otherwise.
+ */
+static int ambisonic_order(const AVChannelLayout *channel_layout)
+{
+    int i, highest_ambi, order;
+
+    highest_ambi = -1;
+    if (channel_layout->order == AV_CHANNEL_ORDER_AMBISONIC)
+        highest_ambi = channel_layout->nb_channels - av_popcount64(channel_layout->u.mask) - 1;
+    else {
+        const AVChannelCustom *map = channel_layout->u.map;
+        av_assert0(channel_layout->order == AV_CHANNEL_ORDER_CUSTOM);
+
+        for (i = 0; i < channel_layout->nb_channels; i++) {
+            int is_ambi = CHAN_IS_AMBI(map[i].id);
+
+            /* ambisonic following non-ambisonic */
+            if (i > 0 && is_ambi && !CHAN_IS_AMBI(map[i - 1].id))
+                return AVERROR(EINVAL);
+
+            /* non-default ordering */
+            if (is_ambi && map[i].id - AV_CHAN_AMBISONIC_BASE != i)
+                return AVERROR(EINVAL);
+
+            if (CHAN_IS_AMBI(map[i].id))
+                highest_ambi = i;
+        }
+    }
+    /* no ambisonic channels*/
+    if (highest_ambi < 0)
+        return AVERROR(EINVAL);
+
+    order = floor(sqrt(highest_ambi));
+    /* incomplete order - some harmonics are missing */
+    if ((order + 1) * (order + 1) != highest_ambi + 1)
+        return AVERROR(EINVAL);
+
+    return order;
+}
+
+/**
+ * If the custom layout is n-th order standard-order ambisonic, with optional
+ * extra non-diegetic channels at the end, write its string description in bp.
+ * Return a negative error code otherwise.
+ */
+static int try_describe_ambisonic(AVBPrint *bp, const AVChannelLayout *channel_layout)
+{
+    int nb_ambi_channels;
+    int order = ambisonic_order(channel_layout);
+    if (order < 0)
+        return order;
+
+    av_bprintf(bp, "ambisonic %d", order);
+
+    /* extra channels present */
+    nb_ambi_channels = (order + 1) * (order + 1);
+    if (nb_ambi_channels < channel_layout->nb_channels) {
+        AVChannelLayout extra = { 0 };
+
+        if (channel_layout->order == AV_CHANNEL_ORDER_AMBISONIC) {
+            extra.order       = AV_CHANNEL_ORDER_NATIVE;
+            extra.nb_channels = av_popcount64(channel_layout->u.mask);
+            extra.u.mask      = channel_layout->u.mask;
+        } else {
+            extra.order       = AV_CHANNEL_ORDER_CUSTOM;
+            extra.nb_channels = channel_layout->nb_channels - nb_ambi_channels;
+            extra.u.map       = channel_layout->u.map + nb_ambi_channels;
+        }
+
+        av_bprint_chars(bp, '+', 1);
+        av_channel_layout_describe_bprint(&extra, bp);
+        /* Not calling uninit here on extra because we don't own the u.map pointer */
+    }
+
+    return 0;
+}
+
+int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout,
+                                      AVBPrint *bp)
+{
+    int i;
+
+    switch (channel_layout->order) {
+    case AV_CHANNEL_ORDER_NATIVE:
+        for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++)
+            if (channel_layout->u.mask == channel_layout_map[i].layout.u.mask) {
+                av_bprintf(bp, "%s", channel_layout_map[i].name);
+                return 0;
+            }
+        // fall-through
+    case AV_CHANNEL_ORDER_CUSTOM:
+        if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM) {
+            int res = try_describe_ambisonic(bp, channel_layout);
+            if (res >= 0)
+                return 0;
+        }
+        if (channel_layout->nb_channels)
+            av_bprintf(bp, "%d channels (", channel_layout->nb_channels);
+        for (i = 0; i < channel_layout->nb_channels; i++) {
+            enum AVChannel ch = av_channel_layout_channel_from_index(channel_layout, i);
+
+            if (i)
+                av_bprintf(bp, "+");
+            av_channel_name_bprint(bp, ch);
+            if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM &&
+                channel_layout->u.map[i].name[0])
+                av_bprintf(bp, "@%s", channel_layout->u.map[i].name);
+        }
+        if (channel_layout->nb_channels) {
+            av_bprintf(bp, ")");
+            return 0;
+        }
+        // fall-through
+    case AV_CHANNEL_ORDER_UNSPEC:
+        av_bprintf(bp, "%d channels", channel_layout->nb_channels);
+        return 0;
+    case AV_CHANNEL_ORDER_AMBISONIC:
+        return try_describe_ambisonic(bp, channel_layout);
+    default:
+        return AVERROR(EINVAL);
+    }
+}
+
+int av_channel_layout_describe(const AVChannelLayout *channel_layout,
+                               char *buf, size_t buf_size)
+{
+    AVBPrint bp;
+    int ret;
+
+    if (!buf && buf_size)
+        return AVERROR(EINVAL);
+
+    av_bprint_init_for_buffer(&bp, buf, buf_size);
+    ret = av_channel_layout_describe_bprint(channel_layout, &bp);
+    if (ret < 0)
+        return ret;
+
+    return bp.len;
+}
+
+enum AVChannel
+av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout,
+                                     unsigned int idx)
+{
+    int i;
+
+    if (idx >= channel_layout->nb_channels)
+        return AV_CHAN_NONE;
+
+    switch (channel_layout->order) {
+    case AV_CHANNEL_ORDER_CUSTOM:
+        return channel_layout->u.map[idx].id;
+    case AV_CHANNEL_ORDER_AMBISONIC: {
+        int ambi_channels = channel_layout->nb_channels - av_popcount64(channel_layout->u.mask);
+        if (idx < ambi_channels)
+            return AV_CHAN_AMBISONIC_BASE + idx;
+        idx -= ambi_channels;
+        }
+    // fall-through
+    case AV_CHANNEL_ORDER_NATIVE:
+        for (i = 0; i < 64; i++) {
+            if ((1ULL << i) & channel_layout->u.mask && !idx--)
+                return i;
+        }
+    default:
+        return AV_CHAN_NONE;
+    }
+}
+
+enum AVChannel
+av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout,
+                                      const char *str)
+{
+    int index = av_channel_layout_index_from_string(channel_layout, str);
+
+    if (index < 0)
+        return AV_CHAN_NONE;
+
+    return av_channel_layout_channel_from_index(channel_layout, index);
+}
+
+int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout,
+                                         enum AVChannel channel)
+{
+    int i;
+
+    if (channel == AV_CHAN_NONE)
+        return AVERROR(EINVAL);
+
+    switch (channel_layout->order) {
+    case AV_CHANNEL_ORDER_CUSTOM:
+        for (i = 0; i < channel_layout->nb_channels; i++)
+            if (channel_layout->u.map[i].id == channel)
+                return i;
+        return AVERROR(EINVAL);
+    case AV_CHANNEL_ORDER_AMBISONIC:
+    case AV_CHANNEL_ORDER_NATIVE: {
+        uint64_t mask = channel_layout->u.mask;
+        int ambi_channels = channel_layout->nb_channels - av_popcount64(mask);
+        if (channel_layout->order == AV_CHANNEL_ORDER_AMBISONIC &&
+            channel >= AV_CHAN_AMBISONIC_BASE) {
+            if (channel - AV_CHAN_AMBISONIC_BASE >= ambi_channels)
+                return AVERROR(EINVAL);
+            return channel - AV_CHAN_AMBISONIC_BASE;
+        }
+        if ((unsigned)channel > 63 || !(mask & (1ULL << channel)))
+            return AVERROR(EINVAL);
+        mask &= (1ULL << channel) - 1;
+        return av_popcount64(mask) + ambi_channels;
+        }
+    default:
+        return AVERROR(EINVAL);
+    }
+}
+
+int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout,
+                                        const char *str)
+{
+    char *chname;
+    enum AVChannel ch = AV_CHAN_NONE;
+
+    switch (channel_layout->order) {
+    case AV_CHANNEL_ORDER_CUSTOM:
+        chname = strstr(str, "@");
+        if (chname) {
+            char buf[16];
+            chname++;
+            av_strlcpy(buf, str, FFMIN(sizeof(buf), chname - str));
+            if (!*chname)
+                chname = NULL;
+            ch = av_channel_from_string(buf);
+            if (ch == AV_CHAN_NONE && *buf)
+                return AVERROR(EINVAL);
+        }
+        for (int i = 0; chname && i < channel_layout->nb_channels; i++) {
+            if (!strcmp(chname, channel_layout->u.map[i].name) &&
+                (ch == AV_CHAN_NONE || ch == channel_layout->u.map[i].id))
+                return i;
+        }
+        // fall-through
+    case AV_CHANNEL_ORDER_AMBISONIC:
+    case AV_CHANNEL_ORDER_NATIVE:
+        ch = av_channel_from_string(str);
+        if (ch == AV_CHAN_NONE)
+            return AVERROR(EINVAL);
+        return av_channel_layout_index_from_channel(channel_layout, ch);
+    }
+
+    return AVERROR(EINVAL);
+}
+
+int av_channel_layout_check(const AVChannelLayout *channel_layout)
+{
+    if (channel_layout->nb_channels <= 0)
+        return 0;
+
+    switch (channel_layout->order) {
+    case AV_CHANNEL_ORDER_NATIVE:
+        return av_popcount64(channel_layout->u.mask) == channel_layout->nb_channels;
+    case AV_CHANNEL_ORDER_CUSTOM:
+        if (!channel_layout->u.map)
+            return 0;
+        for (int i = 0; i < channel_layout->nb_channels; i++) {
+            if (channel_layout->u.map[i].id == AV_CHAN_NONE)
+                return 0;
+        }
+        return 1;
+    case AV_CHANNEL_ORDER_AMBISONIC:
+        /* If non-diegetic channels are present, ensure they are taken into account */
+        return av_popcount64(channel_layout->u.mask) < channel_layout->nb_channels;
+    case AV_CHANNEL_ORDER_UNSPEC:
+        return 1;
+    default:
+        return 0;
+    }
+}
+
+int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1)
+{
+    int i;
+
+    /* different channel counts -> not equal */
+    if (chl->nb_channels != chl1->nb_channels)
+        return 1;
+
+    /* if only one is unspecified -> not equal */
+    if ((chl->order  == AV_CHANNEL_ORDER_UNSPEC) !=
+        (chl1->order == AV_CHANNEL_ORDER_UNSPEC))
+        return 1;
+    /* both are unspecified -> equal */
+    else if (chl->order == AV_CHANNEL_ORDER_UNSPEC)
+        return 0;
+
+    /* can compare masks directly */
+    if ((chl->order == AV_CHANNEL_ORDER_NATIVE ||
+         chl->order == AV_CHANNEL_ORDER_AMBISONIC) &&
+        chl->order == chl1->order)
+        return chl->u.mask != chl1->u.mask;
+
+    /* compare channel by channel */
+    for (i = 0; i < chl->nb_channels; i++)
+        if (av_channel_layout_channel_from_index(chl,  i) !=
+            av_channel_layout_channel_from_index(chl1, i))
+            return 1;
+    return 0;
+}
+
+void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels)
+{
+    int i;
+    for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++)
+        if (nb_channels == channel_layout_map[i].layout.nb_channels) {
+            *ch_layout = channel_layout_map[i].layout;
+            return;
+        }
+
+    ch_layout->order       = AV_CHANNEL_ORDER_UNSPEC;
+    ch_layout->nb_channels = nb_channels;
+}
+
+const AVChannelLayout *av_channel_layout_standard(void **opaque)
+{
+    uintptr_t i = (uintptr_t)*opaque;
+    const AVChannelLayout *ch_layout = NULL;
+
+    if (i < FF_ARRAY_ELEMS(channel_layout_map)) {
+        ch_layout = &channel_layout_map[i].layout;
+        *opaque = (void*)(i + 1);
+    }
+
+    return ch_layout;
+}
+
+uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout,
+                                  uint64_t mask)
+{
+    uint64_t ret = 0;
+    int i;
+
+    switch (channel_layout->order) {
+    case AV_CHANNEL_ORDER_NATIVE:
+    case AV_CHANNEL_ORDER_AMBISONIC:
+        return channel_layout->u.mask & mask;
+    case AV_CHANNEL_ORDER_CUSTOM:
+        for (i = 0; i < 64; i++)
+            if (mask & (1ULL << i) && av_channel_layout_index_from_channel(channel_layout, i) >= 0)
+                ret |= (1ULL << i);
+        break;
+    }
+
+    return ret;
+}
diff -Naur a/media/ffvpx/libavutil/channel_layout.h b/media/ffvpx/libavutil/channel_layout.h
--- a/media/ffvpx/libavutil/channel_layout.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/channel_layout.h	2023-04-06 12:50:24.493176583 +0200
@@ -23,17 +23,132 @@
 #define AVUTIL_CHANNEL_LAYOUT_H
 
 #include <stdint.h>
+#include <stdlib.h>
+
+#include "version.h"
+#include "attributes.h"
 
 /**
  * @file
- * audio channel layout utility functions
+ * @ingroup lavu_audio_channels
+ * Public libavutil channel layout APIs header.
  */
 
+
 /**
- * @addtogroup lavu_audio
+ * @defgroup lavu_audio_channels Audio channels
+ * @ingroup lavu_audio
+ *
+ * Audio channel layout utility functions
+ *
  * @{
  */
 
+enum AVChannel {
+    ///< Invalid channel index
+    AV_CHAN_NONE = -1,
+    AV_CHAN_FRONT_LEFT,
+    AV_CHAN_FRONT_RIGHT,
+    AV_CHAN_FRONT_CENTER,
+    AV_CHAN_LOW_FREQUENCY,
+    AV_CHAN_BACK_LEFT,
+    AV_CHAN_BACK_RIGHT,
+    AV_CHAN_FRONT_LEFT_OF_CENTER,
+    AV_CHAN_FRONT_RIGHT_OF_CENTER,
+    AV_CHAN_BACK_CENTER,
+    AV_CHAN_SIDE_LEFT,
+    AV_CHAN_SIDE_RIGHT,
+    AV_CHAN_TOP_CENTER,
+    AV_CHAN_TOP_FRONT_LEFT,
+    AV_CHAN_TOP_FRONT_CENTER,
+    AV_CHAN_TOP_FRONT_RIGHT,
+    AV_CHAN_TOP_BACK_LEFT,
+    AV_CHAN_TOP_BACK_CENTER,
+    AV_CHAN_TOP_BACK_RIGHT,
+    /** Stereo downmix. */
+    AV_CHAN_STEREO_LEFT = 29,
+    /** See above. */
+    AV_CHAN_STEREO_RIGHT,
+    AV_CHAN_WIDE_LEFT,
+    AV_CHAN_WIDE_RIGHT,
+    AV_CHAN_SURROUND_DIRECT_LEFT,
+    AV_CHAN_SURROUND_DIRECT_RIGHT,
+    AV_CHAN_LOW_FREQUENCY_2,
+    AV_CHAN_TOP_SIDE_LEFT,
+    AV_CHAN_TOP_SIDE_RIGHT,
+    AV_CHAN_BOTTOM_FRONT_CENTER,
+    AV_CHAN_BOTTOM_FRONT_LEFT,
+    AV_CHAN_BOTTOM_FRONT_RIGHT,
+
+    /** Channel is empty can be safely skipped. */
+    AV_CHAN_UNUSED = 0x200,
+
+    /** Channel contains data, but its position is unknown. */
+    AV_CHAN_UNKNOWN = 0x300,
+
+    /**
+     * Range of channels between AV_CHAN_AMBISONIC_BASE and
+     * AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.
+     *
+     * Given a channel id `<i>` between AV_CHAN_AMBISONIC_BASE and
+     * AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel `<n>` is
+     * `<n> = <i> - AV_CHAN_AMBISONIC_BASE`.
+     *
+     * @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel
+     * orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels
+     * implicitly by their position in the stream.
+     */
+    AV_CHAN_AMBISONIC_BASE = 0x400,
+    // leave space for 1024 ids, which correspond to maximum order-32 harmonics,
+    // which should be enough for the foreseeable use cases
+    AV_CHAN_AMBISONIC_END  = 0x7ff,
+};
+
+enum AVChannelOrder {
+    /**
+     * Only the channel count is specified, without any further information
+     * about the channel order.
+     */
+    AV_CHANNEL_ORDER_UNSPEC,
+    /**
+     * The native channel order, i.e. the channels are in the same order in
+     * which they are defined in the AVChannel enum. This supports up to 63
+     * different channels.
+     */
+    AV_CHANNEL_ORDER_NATIVE,
+    /**
+     * The channel order does not correspond to any other predefined order and
+     * is stored as an explicit map. For example, this could be used to support
+     * layouts with 64 or more channels, or with empty/skipped (AV_CHAN_SILENCE)
+     * channels at arbitrary positions.
+     */
+    AV_CHANNEL_ORDER_CUSTOM,
+    /**
+     * The audio is represented as the decomposition of the sound field into
+     * spherical harmonics. Each channel corresponds to a single expansion
+     * component. Channels are ordered according to ACN (Ambisonic Channel
+     * Number).
+     *
+     * The channel with the index n in the stream contains the spherical
+     * harmonic of degree l and order m given by
+     * @code{.unparsed}
+     *   l   = floor(sqrt(n)),
+     *   m   = n - l * (l + 1).
+     * @endcode
+     *
+     * Conversely given a spherical harmonic of degree l and order m, the
+     * corresponding channel index n is given by
+     * @code{.unparsed}
+     *   n = l * (l + 1) + m.
+     * @endcode
+     *
+     * Normalization is assumed to be SN3D (Schmidt Semi-Normalization)
+     * as defined in AmbiX format $ 2.1.
+     */
+    AV_CHANNEL_ORDER_AMBISONIC,
+};
+
+
 /**
  * @defgroup channel_masks Audio channel masks
  *
@@ -46,41 +161,46 @@
  *
  * @{
  */
-#define AV_CH_FRONT_LEFT             0x00000001
-#define AV_CH_FRONT_RIGHT            0x00000002
-#define AV_CH_FRONT_CENTER           0x00000004
-#define AV_CH_LOW_FREQUENCY          0x00000008
-#define AV_CH_BACK_LEFT              0x00000010
-#define AV_CH_BACK_RIGHT             0x00000020
-#define AV_CH_FRONT_LEFT_OF_CENTER   0x00000040
-#define AV_CH_FRONT_RIGHT_OF_CENTER  0x00000080
-#define AV_CH_BACK_CENTER            0x00000100
-#define AV_CH_SIDE_LEFT              0x00000200
-#define AV_CH_SIDE_RIGHT             0x00000400
-#define AV_CH_TOP_CENTER             0x00000800
-#define AV_CH_TOP_FRONT_LEFT         0x00001000
-#define AV_CH_TOP_FRONT_CENTER       0x00002000
-#define AV_CH_TOP_FRONT_RIGHT        0x00004000
-#define AV_CH_TOP_BACK_LEFT          0x00008000
-#define AV_CH_TOP_BACK_CENTER        0x00010000
-#define AV_CH_TOP_BACK_RIGHT         0x00020000
-#define AV_CH_STEREO_LEFT            0x20000000  ///< Stereo downmix.
-#define AV_CH_STEREO_RIGHT           0x40000000  ///< See AV_CH_STEREO_LEFT.
-#define AV_CH_WIDE_LEFT              0x0000000080000000ULL
-#define AV_CH_WIDE_RIGHT             0x0000000100000000ULL
-#define AV_CH_SURROUND_DIRECT_LEFT   0x0000000200000000ULL
-#define AV_CH_SURROUND_DIRECT_RIGHT  0x0000000400000000ULL
-#define AV_CH_LOW_FREQUENCY_2        0x0000000800000000ULL
-#define AV_CH_TOP_SIDE_LEFT          0x0000001000000000ULL
-#define AV_CH_TOP_SIDE_RIGHT         0x0000002000000000ULL
-#define AV_CH_BOTTOM_FRONT_CENTER    0x0000004000000000ULL
-#define AV_CH_BOTTOM_FRONT_LEFT      0x0000008000000000ULL
-#define AV_CH_BOTTOM_FRONT_RIGHT     0x0000010000000000ULL
+#define AV_CH_FRONT_LEFT             (1ULL << AV_CHAN_FRONT_LEFT           )
+#define AV_CH_FRONT_RIGHT            (1ULL << AV_CHAN_FRONT_RIGHT          )
+#define AV_CH_FRONT_CENTER           (1ULL << AV_CHAN_FRONT_CENTER         )
+#define AV_CH_LOW_FREQUENCY          (1ULL << AV_CHAN_LOW_FREQUENCY        )
+#define AV_CH_BACK_LEFT              (1ULL << AV_CHAN_BACK_LEFT            )
+#define AV_CH_BACK_RIGHT             (1ULL << AV_CHAN_BACK_RIGHT           )
+#define AV_CH_FRONT_LEFT_OF_CENTER   (1ULL << AV_CHAN_FRONT_LEFT_OF_CENTER )
+#define AV_CH_FRONT_RIGHT_OF_CENTER  (1ULL << AV_CHAN_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_BACK_CENTER            (1ULL << AV_CHAN_BACK_CENTER          )
+#define AV_CH_SIDE_LEFT              (1ULL << AV_CHAN_SIDE_LEFT            )
+#define AV_CH_SIDE_RIGHT             (1ULL << AV_CHAN_SIDE_RIGHT           )
+#define AV_CH_TOP_CENTER             (1ULL << AV_CHAN_TOP_CENTER           )
+#define AV_CH_TOP_FRONT_LEFT         (1ULL << AV_CHAN_TOP_FRONT_LEFT       )
+#define AV_CH_TOP_FRONT_CENTER       (1ULL << AV_CHAN_TOP_FRONT_CENTER     )
+#define AV_CH_TOP_FRONT_RIGHT        (1ULL << AV_CHAN_TOP_FRONT_RIGHT      )
+#define AV_CH_TOP_BACK_LEFT          (1ULL << AV_CHAN_TOP_BACK_LEFT        )
+#define AV_CH_TOP_BACK_CENTER        (1ULL << AV_CHAN_TOP_BACK_CENTER      )
+#define AV_CH_TOP_BACK_RIGHT         (1ULL << AV_CHAN_TOP_BACK_RIGHT       )
+#define AV_CH_STEREO_LEFT            (1ULL << AV_CHAN_STEREO_LEFT          )
+#define AV_CH_STEREO_RIGHT           (1ULL << AV_CHAN_STEREO_RIGHT         )
+#define AV_CH_WIDE_LEFT              (1ULL << AV_CHAN_WIDE_LEFT            )
+#define AV_CH_WIDE_RIGHT             (1ULL << AV_CHAN_WIDE_RIGHT           )
+#define AV_CH_SURROUND_DIRECT_LEFT   (1ULL << AV_CHAN_SURROUND_DIRECT_LEFT )
+#define AV_CH_SURROUND_DIRECT_RIGHT  (1ULL << AV_CHAN_SURROUND_DIRECT_RIGHT)
+#define AV_CH_LOW_FREQUENCY_2        (1ULL << AV_CHAN_LOW_FREQUENCY_2      )
+#define AV_CH_TOP_SIDE_LEFT          (1ULL << AV_CHAN_TOP_SIDE_LEFT        )
+#define AV_CH_TOP_SIDE_RIGHT         (1ULL << AV_CHAN_TOP_SIDE_RIGHT       )
+#define AV_CH_BOTTOM_FRONT_CENTER    (1ULL << AV_CHAN_BOTTOM_FRONT_CENTER  )
+#define AV_CH_BOTTOM_FRONT_LEFT      (1ULL << AV_CHAN_BOTTOM_FRONT_LEFT    )
+#define AV_CH_BOTTOM_FRONT_RIGHT     (1ULL << AV_CHAN_BOTTOM_FRONT_RIGHT   )
 
+#if FF_API_OLD_CHANNEL_LAYOUT
 /** Channel mask value used for AVCodecContext.request_channel_layout
     to indicate that the user requests the channel order of the decoder output
-    to be the native codec channel order. */
+    to be the native codec channel order.
+    @deprecated channel order is now indicated in a special field in
+                AVChannelLayout
+    */
 #define AV_CH_LAYOUT_NATIVE          0x8000000000000000ULL
+#endif
 
 /**
  * @}
@@ -112,7 +232,9 @@
 #define AV_CH_LAYOUT_7POINT1           (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)
 #define AV_CH_LAYOUT_7POINT1_WIDE      (AV_CH_LAYOUT_5POINT1|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)
 #define AV_CH_LAYOUT_7POINT1_WIDE_BACK (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)
+#define AV_CH_LAYOUT_7POINT1_TOP_BACK  (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT)
 #define AV_CH_LAYOUT_OCTAGONAL         (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_CENTER|AV_CH_BACK_RIGHT)
+#define AV_CH_LAYOUT_CUBE              (AV_CH_LAYOUT_QUAD|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT|AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_RIGHT)
 #define AV_CH_LAYOUT_HEXADECAGONAL     (AV_CH_LAYOUT_OCTAGONAL|AV_CH_WIDE_LEFT|AV_CH_WIDE_RIGHT|AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_RIGHT|AV_CH_TOP_BACK_CENTER|AV_CH_TOP_FRONT_CENTER|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT)
 #define AV_CH_LAYOUT_STEREO_DOWNMIX    (AV_CH_STEREO_LEFT|AV_CH_STEREO_RIGHT)
 #define AV_CH_LAYOUT_22POINT2          (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER|AV_CH_BACK_CENTER|AV_CH_LOW_FREQUENCY_2|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT|AV_CH_TOP_FRONT_CENTER|AV_CH_TOP_CENTER|AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_RIGHT|AV_CH_TOP_SIDE_LEFT|AV_CH_TOP_SIDE_RIGHT|AV_CH_TOP_BACK_CENTER|AV_CH_BOTTOM_FRONT_CENTER|AV_CH_BOTTOM_FRONT_LEFT|AV_CH_BOTTOM_FRONT_RIGHT)
@@ -129,6 +251,164 @@
 };
 
 /**
+ * @}
+ */
+
+/**
+ * An AVChannelCustom defines a single channel within a custom order layout
+ *
+ * Unlike most structures in FFmpeg, sizeof(AVChannelCustom) is a part of the
+ * public ABI.
+ *
+ * No new fields may be added to it without a major version bump.
+ */
+typedef struct AVChannelCustom {
+    enum AVChannel id;
+    char name[16];
+    void *opaque;
+} AVChannelCustom;
+
+/**
+ * An AVChannelLayout holds information about the channel layout of audio data.
+ *
+ * A channel layout here is defined as a set of channels ordered in a specific
+ * way (unless the channel order is AV_CHANNEL_ORDER_UNSPEC, in which case an
+ * AVChannelLayout carries only the channel count).
+ * All orders may be treated as if they were AV_CHANNEL_ORDER_UNSPEC by
+ * ignoring everything but the channel count, as long as av_channel_layout_check()
+ * considers they are valid.
+ *
+ * Unlike most structures in FFmpeg, sizeof(AVChannelLayout) is a part of the
+ * public ABI and may be used by the caller. E.g. it may be allocated on stack
+ * or embedded in caller-defined structs.
+ *
+ * AVChannelLayout can be initialized as follows:
+ * - default initialization with {0}, followed by setting all used fields
+ *   correctly;
+ * - by assigning one of the predefined AV_CHANNEL_LAYOUT_* initializers;
+ * - with a constructor function, such as av_channel_layout_default(),
+ *   av_channel_layout_from_mask() or av_channel_layout_from_string().
+ *
+ * The channel layout must be unitialized with av_channel_layout_uninit()
+ *
+ * Copying an AVChannelLayout via assigning is forbidden,
+ * av_channel_layout_copy() must be used instead (and its return value should
+ * be checked)
+ *
+ * No new fields may be added to it without a major version bump, except for
+ * new elements of the union fitting in sizeof(uint64_t).
+ */
+typedef struct AVChannelLayout {
+    /**
+     * Channel order used in this layout.
+     * This is a mandatory field.
+     */
+    enum AVChannelOrder order;
+
+    /**
+     * Number of channels in this layout. Mandatory field.
+     */
+    int nb_channels;
+
+    /**
+     * Details about which channels are present in this layout.
+     * For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
+     * used.
+     */
+    union {
+        /**
+         * This member must be used for AV_CHANNEL_ORDER_NATIVE, and may be used
+         * for AV_CHANNEL_ORDER_AMBISONIC to signal non-diegetic channels.
+         * It is a bitmask, where the position of each set bit means that the
+         * AVChannel with the corresponding value is present.
+         *
+         * I.e. when (mask & (1 << AV_CHAN_FOO)) is non-zero, then AV_CHAN_FOO
+         * is present in the layout. Otherwise it is not present.
+         *
+         * @note when a channel layout using a bitmask is constructed or
+         * modified manually (i.e.  not using any of the av_channel_layout_*
+         * functions), the code doing it must ensure that the number of set bits
+         * is equal to nb_channels.
+         */
+        uint64_t mask;
+        /**
+         * This member must be used when the channel order is
+         * AV_CHANNEL_ORDER_CUSTOM. It is a nb_channels-sized array, with each
+         * element signalling the presence of the AVChannel with the
+         * corresponding value in map[i].id.
+         *
+         * I.e. when map[i].id is equal to AV_CHAN_FOO, then AV_CH_FOO is the
+         * i-th channel in the audio data.
+         *
+         * When map[i].id is in the range between AV_CHAN_AMBISONIC_BASE and
+         * AV_CHAN_AMBISONIC_END (inclusive), the channel contains an ambisonic
+         * component with ACN index (as defined above)
+         * n = map[i].id - AV_CHAN_AMBISONIC_BASE.
+         *
+         * map[i].name may be filled with a 0-terminated string, in which case
+         * it will be used for the purpose of identifying the channel with the
+         * convenience functions below. Otherise it must be zeroed.
+         */
+        AVChannelCustom *map;
+    } u;
+
+    /**
+     * For some private data of the user.
+     */
+    void *opaque;
+} AVChannelLayout;
+
+#define AV_CHANNEL_LAYOUT_MASK(nb, m) \
+    { .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = (nb), .u = { .mask = (m) }}
+
+/**
+ * @name Common pre-defined channel layouts
+ * @{
+ */
+#define AV_CHANNEL_LAYOUT_MONO              AV_CHANNEL_LAYOUT_MASK(1,  AV_CH_LAYOUT_MONO)
+#define AV_CHANNEL_LAYOUT_STEREO            AV_CHANNEL_LAYOUT_MASK(2,  AV_CH_LAYOUT_STEREO)
+#define AV_CHANNEL_LAYOUT_2POINT1           AV_CHANNEL_LAYOUT_MASK(3,  AV_CH_LAYOUT_2POINT1)
+#define AV_CHANNEL_LAYOUT_2_1               AV_CHANNEL_LAYOUT_MASK(3,  AV_CH_LAYOUT_2_1)
+#define AV_CHANNEL_LAYOUT_SURROUND          AV_CHANNEL_LAYOUT_MASK(3,  AV_CH_LAYOUT_SURROUND)
+#define AV_CHANNEL_LAYOUT_3POINT1           AV_CHANNEL_LAYOUT_MASK(4,  AV_CH_LAYOUT_3POINT1)
+#define AV_CHANNEL_LAYOUT_4POINT0           AV_CHANNEL_LAYOUT_MASK(4,  AV_CH_LAYOUT_4POINT0)
+#define AV_CHANNEL_LAYOUT_4POINT1           AV_CHANNEL_LAYOUT_MASK(5,  AV_CH_LAYOUT_4POINT1)
+#define AV_CHANNEL_LAYOUT_2_2               AV_CHANNEL_LAYOUT_MASK(4,  AV_CH_LAYOUT_2_2)
+#define AV_CHANNEL_LAYOUT_QUAD              AV_CHANNEL_LAYOUT_MASK(4,  AV_CH_LAYOUT_QUAD)
+#define AV_CHANNEL_LAYOUT_5POINT0           AV_CHANNEL_LAYOUT_MASK(5,  AV_CH_LAYOUT_5POINT0)
+#define AV_CHANNEL_LAYOUT_5POINT1           AV_CHANNEL_LAYOUT_MASK(6,  AV_CH_LAYOUT_5POINT1)
+#define AV_CHANNEL_LAYOUT_5POINT0_BACK      AV_CHANNEL_LAYOUT_MASK(5,  AV_CH_LAYOUT_5POINT0_BACK)
+#define AV_CHANNEL_LAYOUT_5POINT1_BACK      AV_CHANNEL_LAYOUT_MASK(6,  AV_CH_LAYOUT_5POINT1_BACK)
+#define AV_CHANNEL_LAYOUT_6POINT0           AV_CHANNEL_LAYOUT_MASK(6,  AV_CH_LAYOUT_6POINT0)
+#define AV_CHANNEL_LAYOUT_6POINT0_FRONT     AV_CHANNEL_LAYOUT_MASK(6,  AV_CH_LAYOUT_6POINT0_FRONT)
+#define AV_CHANNEL_LAYOUT_HEXAGONAL         AV_CHANNEL_LAYOUT_MASK(6,  AV_CH_LAYOUT_HEXAGONAL)
+#define AV_CHANNEL_LAYOUT_6POINT1           AV_CHANNEL_LAYOUT_MASK(7,  AV_CH_LAYOUT_6POINT1)
+#define AV_CHANNEL_LAYOUT_6POINT1_BACK      AV_CHANNEL_LAYOUT_MASK(7,  AV_CH_LAYOUT_6POINT1_BACK)
+#define AV_CHANNEL_LAYOUT_6POINT1_FRONT     AV_CHANNEL_LAYOUT_MASK(7,  AV_CH_LAYOUT_6POINT1_FRONT)
+#define AV_CHANNEL_LAYOUT_7POINT0           AV_CHANNEL_LAYOUT_MASK(7,  AV_CH_LAYOUT_7POINT0)
+#define AV_CHANNEL_LAYOUT_7POINT0_FRONT     AV_CHANNEL_LAYOUT_MASK(7,  AV_CH_LAYOUT_7POINT0_FRONT)
+#define AV_CHANNEL_LAYOUT_7POINT1           AV_CHANNEL_LAYOUT_MASK(8,  AV_CH_LAYOUT_7POINT1)
+#define AV_CHANNEL_LAYOUT_7POINT1_WIDE      AV_CHANNEL_LAYOUT_MASK(8,  AV_CH_LAYOUT_7POINT1_WIDE)
+#define AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK AV_CHANNEL_LAYOUT_MASK(8,  AV_CH_LAYOUT_7POINT1_WIDE_BACK)
+#define AV_CHANNEL_LAYOUT_7POINT1_TOP_BACK  AV_CHANNEL_LAYOUT_MASK(8,  AV_CH_LAYOUT_7POINT1_TOP_BACK)
+#define AV_CHANNEL_LAYOUT_OCTAGONAL         AV_CHANNEL_LAYOUT_MASK(8,  AV_CH_LAYOUT_OCTAGONAL)
+#define AV_CHANNEL_LAYOUT_CUBE              AV_CHANNEL_LAYOUT_MASK(8,  AV_CH_LAYOUT_CUBE)
+#define AV_CHANNEL_LAYOUT_HEXADECAGONAL     AV_CHANNEL_LAYOUT_MASK(16, AV_CH_LAYOUT_HEXADECAGONAL)
+#define AV_CHANNEL_LAYOUT_STEREO_DOWNMIX    AV_CHANNEL_LAYOUT_MASK(2,  AV_CH_LAYOUT_STEREO_DOWNMIX)
+#define AV_CHANNEL_LAYOUT_22POINT2          AV_CHANNEL_LAYOUT_MASK(24, AV_CH_LAYOUT_22POINT2)
+#define AV_CHANNEL_LAYOUT_AMBISONIC_FIRST_ORDER \
+    { .order = AV_CHANNEL_ORDER_AMBISONIC, .nb_channels = 4, .u = { .mask = 0 }}
+/** @} */
+
+struct AVBPrint;
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+/**
+ * @name Deprecated Functions
+ * @{
+ */
+
+/**
  * Return a channel layout id that matches name, or 0 if no match is found.
  *
  * name can be one or several of the following notations,
@@ -144,7 +424,10 @@
  *   AV_CH_* macros).
  *
  * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
+ *
+ * @deprecated use av_channel_layout_from_string()
  */
+attribute_deprecated
 uint64_t av_get_channel_layout(const char *name);
 
 /**
@@ -158,7 +441,9 @@
  * @param[out] nb_channels      number of channels
  *
  * @return 0 on success, AVERROR(EINVAL) if the parsing fails.
+ * @deprecated use av_channel_layout_from_string()
  */
+attribute_deprecated
 int av_get_extended_channel_layout(const char *name, uint64_t* channel_layout, int* nb_channels);
 
 /**
@@ -167,47 +452,66 @@
  *
  * @param buf put here the string containing the channel layout
  * @param buf_size size in bytes of the buffer
+ * @param nb_channels number of channels
+ * @param channel_layout channel layout bitset
+ * @deprecated use av_channel_layout_describe()
  */
+attribute_deprecated
 void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout);
 
-struct AVBPrint;
 /**
  * Append a description of a channel layout to a bprint buffer.
+ * @deprecated use av_channel_layout_describe()
  */
+attribute_deprecated
 void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout);
 
 /**
  * Return the number of channels in the channel layout.
+ * @deprecated use AVChannelLayout.nb_channels
  */
+attribute_deprecated
 int av_get_channel_layout_nb_channels(uint64_t channel_layout);
 
 /**
  * Return default channel layout for a given number of channels.
+ *
+ * @deprecated use av_channel_layout_default()
  */
+attribute_deprecated
 int64_t av_get_default_channel_layout(int nb_channels);
 
 /**
  * Get the index of a channel in channel_layout.
  *
+ * @param channel_layout channel layout bitset
  * @param channel a channel layout describing exactly one channel which must be
  *                present in channel_layout.
  *
  * @return index of channel in channel_layout on success, a negative AVERROR
  *         on error.
+ *
+ * @deprecated use av_channel_layout_index_from_channel()
  */
+attribute_deprecated
 int av_get_channel_layout_channel_index(uint64_t channel_layout,
                                         uint64_t channel);
 
 /**
  * Get the channel with the given index in channel_layout.
+ * @deprecated use av_channel_layout_channel_from_index()
  */
+attribute_deprecated
 uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index);
 
 /**
  * Get the name of a given channel.
  *
  * @return channel name on success, NULL on error.
+ *
+ * @deprecated use av_channel_name()
  */
+attribute_deprecated
 const char *av_get_channel_name(uint64_t channel);
 
 /**
@@ -215,7 +519,9 @@
  *
  * @param channel  a channel layout with a single channel
  * @return  channel description on success, NULL on error
+ * @deprecated use av_channel_description()
  */
+attribute_deprecated
 const char *av_get_channel_description(uint64_t channel);
 
 /**
@@ -226,12 +532,251 @@
  * @param[out] name    name of the layout
  * @return  0  if the layout exists,
  *          <0 if index is beyond the limits
+ * @deprecated use av_channel_layout_standard()
  */
+attribute_deprecated
 int av_get_standard_channel_layout(unsigned index, uint64_t *layout,
                                    const char **name);
-
 /**
  * @}
+ */
+#endif
+
+/**
+ * Get a human readable string in an abbreviated form describing a given channel.
+ * This is the inverse function of @ref av_channel_from_string().
+ *
+ * @param buf pre-allocated buffer where to put the generated string
+ * @param buf_size size in bytes of the buffer.
+ * @param channel the AVChannel whose name to get
+ * @return amount of bytes needed to hold the output string, or a negative AVERROR
+ *         on failure. If the returned value is bigger than buf_size, then the
+ *         string was truncated.
+ */
+int av_channel_name(char *buf, size_t buf_size, enum AVChannel channel);
+
+/**
+ * bprint variant of av_channel_name().
+ *
+ * @note the string will be appended to the bprint buffer.
+ */
+void av_channel_name_bprint(struct AVBPrint *bp, enum AVChannel channel_id);
+
+/**
+ * Get a human readable string describing a given channel.
+ *
+ * @param buf pre-allocated buffer where to put the generated string
+ * @param buf_size size in bytes of the buffer.
+ * @param channel the AVChannel whose description to get
+ * @return amount of bytes needed to hold the output string, or a negative AVERROR
+ *         on failure. If the returned value is bigger than buf_size, then the
+ *         string was truncated.
+ */
+int av_channel_description(char *buf, size_t buf_size, enum AVChannel channel);
+
+/**
+ * bprint variant of av_channel_description().
+ *
+ * @note the string will be appended to the bprint buffer.
+ */
+void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_id);
+
+/**
+ * This is the inverse function of @ref av_channel_name().
+ *
+ * @return the channel with the given name
+ *         AV_CHAN_NONE when name does not identify a known channel
+ */
+enum AVChannel av_channel_from_string(const char *name);
+
+/**
+ * Initialize a native channel layout from a bitmask indicating which channels
+ * are present.
+ *
+ * @param channel_layout the layout structure to be initialized
+ * @param mask bitmask describing the channel layout
+ *
+ * @return 0 on success
+ *         AVERROR(EINVAL) for invalid mask values
+ */
+int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask);
+
+/**
+ * Initialize a channel layout from a given string description.
+ * The input string can be represented by:
+ *  - the formal channel layout name (returned by av_channel_layout_describe())
+ *  - single or multiple channel names (returned by av_channel_name(), eg. "FL",
+ *    or concatenated with "+", each optionally containing a custom name after
+ *    a "@", eg. "FL@Left+FR@Right+LFE")
+ *  - a decimal or hexadecimal value of a native channel layout (eg. "4" or "0x4")
+ *  - the number of channels with default layout (eg. "4c")
+ *  - the number of unordered channels (eg. "4C" or "4 channels")
+ *  - the ambisonic order followed by optional non-diegetic channels (eg.
+ *    "ambisonic 2+stereo")
+ *
+ * @param channel_layout input channel layout
+ * @param str string describing the channel layout
+ * @return 0 channel layout was detected, AVERROR_INVALIDATATA otherwise
+ */
+int av_channel_layout_from_string(AVChannelLayout *channel_layout,
+                                  const char *str);
+
+/**
+ * Get the default channel layout for a given number of channels.
+ *
+ * @param ch_layout the layout structure to be initialized
+ * @param nb_channels number of channels
+ */
+void av_channel_layout_default(AVChannelLayout *ch_layout, int nb_channels);
+
+/**
+ * Iterate over all standard channel layouts.
+ *
+ * @param opaque a pointer where libavutil will store the iteration state. Must
+ *               point to NULL to start the iteration.
+ *
+ * @return the standard channel layout or NULL when the iteration is
+ *         finished
+ */
+const AVChannelLayout *av_channel_layout_standard(void **opaque);
+
+/**
+ * Free any allocated data in the channel layout and reset the channel
+ * count to 0.
+ *
+ * @param channel_layout the layout structure to be uninitialized
+ */
+void av_channel_layout_uninit(AVChannelLayout *channel_layout);
+
+/**
+ * Make a copy of a channel layout. This differs from just assigning src to dst
+ * in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.
+ *
+ * @note the destination channel_layout will be always uninitialized before copy.
+ *
+ * @param dst destination channel layout
+ * @param src source channel layout
+ * @return 0 on success, a negative AVERROR on error.
+ */
+int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src);
+
+/**
+ * Get a human-readable string describing the channel layout properties.
+ * The string will be in the same format that is accepted by
+ * @ref av_channel_layout_from_string(), allowing to rebuild the same
+ * channel layout, except for opaque pointers.
+ *
+ * @param channel_layout channel layout to be described
+ * @param buf pre-allocated buffer where to put the generated string
+ * @param buf_size size in bytes of the buffer.
+ * @return amount of bytes needed to hold the output string, or a negative AVERROR
+ *         on failure. If the returned value is bigger than buf_size, then the
+ *         string was truncated.
+ */
+int av_channel_layout_describe(const AVChannelLayout *channel_layout,
+                               char *buf, size_t buf_size);
+
+/**
+ * bprint variant of av_channel_layout_describe().
+ *
+ * @note the string will be appended to the bprint buffer.
+ * @return 0 on success, or a negative AVERROR value on failure.
+ */
+int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout,
+                                      struct AVBPrint *bp);
+
+/**
+ * Get the channel with the given index in a channel layout.
+ *
+ * @param channel_layout input channel layout
+ * @param idx index of the channel
+ * @return channel with the index idx in channel_layout on success or
+ *         AV_CHAN_NONE on failure (if idx is not valid or the channel order is
+ *         unspecified)
+ */
+enum AVChannel
+av_channel_layout_channel_from_index(const AVChannelLayout *channel_layout, unsigned int idx);
+
+/**
+ * Get the index of a given channel in a channel layout. In case multiple
+ * channels are found, only the first match will be returned.
+ *
+ * @param channel_layout input channel layout
+ * @param channel the channel whose index to obtain
+ * @return index of channel in channel_layout on success or a negative number if
+ *         channel is not present in channel_layout.
+ */
+int av_channel_layout_index_from_channel(const AVChannelLayout *channel_layout,
+                                         enum AVChannel channel);
+
+/**
+ * Get the index in a channel layout of a channel described by the given string.
+ * In case multiple channels are found, only the first match will be returned.
+ *
+ * This function accepts channel names in the same format as
+ * @ref av_channel_from_string().
+ *
+ * @param channel_layout input channel layout
+ * @param name string describing the channel whose index to obtain
+ * @return a channel index described by the given string, or a negative AVERROR
+ *         value.
+ */
+int av_channel_layout_index_from_string(const AVChannelLayout *channel_layout,
+                                        const char *name);
+
+/**
+ * Get a channel described by the given string.
+ *
+ * This function accepts channel names in the same format as
+ * @ref av_channel_from_string().
+ *
+ * @param channel_layout input channel layout
+ * @param name string describing the channel to obtain
+ * @return a channel described by the given string in channel_layout on success
+ *         or AV_CHAN_NONE on failure (if the string is not valid or the channel
+ *         order is unspecified)
+ */
+enum AVChannel
+av_channel_layout_channel_from_string(const AVChannelLayout *channel_layout,
+                                      const char *name);
+
+/**
+ * Find out what channels from a given set are present in a channel layout,
+ * without regard for their positions.
+ *
+ * @param channel_layout input channel layout
+ * @param mask a combination of AV_CH_* representing a set of channels
+ * @return a bitfield representing all the channels from mask that are present
+ *         in channel_layout
+ */
+uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout,
+                                  uint64_t mask);
+
+/**
+ * Check whether a channel layout is valid, i.e. can possibly describe audio
+ * data.
+ *
+ * @param channel_layout input channel layout
+ * @return 1 if channel_layout is valid, 0 otherwise.
+ */
+int av_channel_layout_check(const AVChannelLayout *channel_layout);
+
+/**
+ * Check whether two channel layouts are semantically the same, i.e. the same
+ * channels are present on the same positions in both.
+ *
+ * If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is
+ * not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC,
+ * they are considered equal iff the channel counts are the same in both.
+ *
+ * @param chl input channel layout
+ * @param chl1 input channel layout
+ * @return 0 if chl and chl1 are equal, 1 if they are not equal. A negative
+ *         AVERROR code if one or both are invalid.
+ */
+int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1);
+
+/**
  * @}
  */
 
diff -Naur a/media/ffvpx/libavutil/color_utils.c b/media/ffvpx/libavutil/color_utils.c
--- a/media/ffvpx/libavutil/color_utils.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/color_utils.c	2023-04-06 12:49:40.259395132 +0200
@@ -21,7 +21,6 @@
 #include <stddef.h>
 #include <math.h>
 
-#include "common.h"
 #include "libavutil/color_utils.h"
 #include "libavutil/pixfmt.h"
 
diff -Naur a/media/ffvpx/libavutil/common.h b/media/ffvpx/libavutil/common.h
--- a/media/ffvpx/libavutil/common.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/common.h	2023-04-06 12:49:40.259395132 +0200
@@ -41,14 +41,6 @@
 
 #include "attributes.h"
 #include "macros.h"
-#include "version.h"
-#include "libavutil/avconfig.h"
-
-#if AV_HAVE_BIGENDIAN
-#   define AV_NE(be, le) (be)
-#else
-#   define AV_NE(be, le) (le)
-#endif
 
 //rounded division & shift
 #define RSHIFT(a,b) ((a) > 0 ? ((a) + ((1<<(b))>>1))>>(b) : ((a) + ((1<<(b))>>1)-1)>>(b))
@@ -89,25 +81,6 @@
 #define FFABSU(a) ((a) <= 0 ? -(unsigned)(a) : (unsigned)(a))
 #define FFABS64U(a) ((a) <= 0 ? -(uint64_t)(a) : (uint64_t)(a))
 
-/**
- * Comparator.
- * For two numerical expressions x and y, gives 1 if x > y, -1 if x < y, and 0
- * if x == y. This is useful for instance in a qsort comparator callback.
- * Furthermore, compilers are able to optimize this to branchless code, and
- * there is no risk of overflow with signed types.
- * As with many macros, this evaluates its argument multiple times, it thus
- * must not have a side-effect.
- */
-#define FFDIFFSIGN(x,y) (((x)>(y)) - ((x)<(y)))
-
-#define FFMAX(a,b) ((a) > (b) ? (a) : (b))
-#define FFMAX3(a,b,c) FFMAX(FFMAX(a,b),c)
-#define FFMIN(a,b) ((a) > (b) ? (b) : (a))
-#define FFMIN3(a,b,c) FFMIN(FFMIN(a,b),c)
-
-#define FFSWAP(type,a,b) do{type SWAP_tmp= b; b= a; a= SWAP_tmp;}while(0)
-#define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
-
 /* misc math functions */
 
 #ifdef HAVE_AV_CONFIG_H
@@ -405,6 +378,8 @@
 
 /**
  * Clip a float value into the amin-amax range.
+ * If a is nan or -inf amin will be returned.
+ * If a is +inf amax will be returned.
  * @param a value to clip
  * @param amin minimum value of the clip range
  * @param amax maximum value of the clip range
@@ -415,13 +390,13 @@
 #if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
     if (amin > amax) abort();
 #endif
-    if      (a < amin) return amin;
-    else if (a > amax) return amax;
-    else               return a;
+    return FFMIN(FFMAX(a, amin), amax);
 }
 
 /**
  * Clip a double value into the amin-amax range.
+ * If a is nan or -inf amin will be returned.
+ * If a is +inf amax will be returned.
  * @param a value to clip
  * @param amin minimum value of the clip range
  * @param amax maximum value of the clip range
@@ -432,9 +407,7 @@
 #if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
     if (amin > amax) abort();
 #endif
-    if      (a < amin) return amin;
-    else if (a > amax) return amax;
-    else               return a;
+    return FFMIN(FFMAX(a, amin), amax);
 }
 
 /** Compute ceil(log2(x)).
@@ -475,9 +448,6 @@
     return av_popcount(v) & 1;
 }
 
-#define MKTAG(a,b,c,d) ((a) | ((b) << 8) | ((c) << 16) | ((unsigned)(d) << 24))
-#define MKBETAG(a,b,c,d) ((d) | ((c) << 8) | ((b) << 16) | ((unsigned)(a) << 24))
-
 /**
  * Convert a UTF-8 character (up to 4 bytes) to its 32-bit UCS-4 encoded form.
  *
diff -Naur a/media/ffvpx/libavutil/cpu.c b/media/ffvpx/libavutil/cpu.c
--- a/media/ffvpx/libavutil/cpu.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/cpu.c	2023-04-06 12:50:06.975471215 +0200
@@ -16,6 +16,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "config.h"
+
+#if HAVE_SCHED_GETAFFINITY
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE
+#endif
+#include <sched.h>
+#endif
+
 #include <stddef.h>
 #include <stdint.h>
 #include <stdatomic.h>
@@ -23,16 +32,9 @@
 #include "attributes.h"
 #include "cpu.h"
 #include "cpu_internal.h"
-#include "config.h"
 #include "opt.h"
 #include "common.h"
 
-#if HAVE_SCHED_GETAFFINITY
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE
-#endif
-#include <sched.h>
-#endif
 #if HAVE_GETPROCESSAFFINITYMASK || HAVE_WINRT
 #include <windows.h>
 #endif
@@ -48,19 +50,25 @@
 #endif
 
 static atomic_int cpu_flags = ATOMIC_VAR_INIT(-1);
+static atomic_int cpu_count = ATOMIC_VAR_INIT(-1);
 
 static int get_cpu_flags(void)
 {
-    if (ARCH_MIPS)
-        return ff_get_cpu_flags_mips();
-    if (ARCH_AARCH64)
-        return ff_get_cpu_flags_aarch64();
-    if (ARCH_ARM)
-        return ff_get_cpu_flags_arm();
-    if (ARCH_PPC)
-        return ff_get_cpu_flags_ppc();
-    if (ARCH_X86)
-        return ff_get_cpu_flags_x86();
+#if ARCH_MIPS
+    return ff_get_cpu_flags_mips();
+#elif ARCH_AARCH64
+    return ff_get_cpu_flags_aarch64();
+#elif ARCH_ARM
+    return ff_get_cpu_flags_arm();
+#elif ARCH_PPC
+    return ff_get_cpu_flags_ppc();
+#elif ARCH_RISCV
+    return ff_get_cpu_flags_riscv();
+#elif ARCH_X86
+    return ff_get_cpu_flags_x86();
+#elif ARCH_LOONGARCH
+    return ff_get_cpu_flags_loongarch();
+#endif
     return 0;
 }
 
@@ -102,97 +110,6 @@
     return flags;
 }
 
-void av_set_cpu_flags_mask(int mask)
-{
-    atomic_store_explicit(&cpu_flags, get_cpu_flags() & mask,
-                          memory_order_relaxed);
-}
-
-int av_parse_cpu_flags(const char *s)
-{
-#define CPUFLAG_MMXEXT   (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMXEXT | AV_CPU_FLAG_CMOV)
-#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)
-#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)
-#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMXEXT)
-#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)
-#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)
-#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)
-#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)
-#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)
-#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)
-#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)
-#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)
-#define CPUFLAG_AVXSLOW  (AV_CPU_FLAG_AVXSLOW  | CPUFLAG_AVX)
-#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)
-#define CPUFLAG_FMA3     (AV_CPU_FLAG_FMA3     | CPUFLAG_AVX)
-#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)
-#define CPUFLAG_AVX2     (AV_CPU_FLAG_AVX2     | CPUFLAG_AVX)
-#define CPUFLAG_BMI2     (AV_CPU_FLAG_BMI2     | AV_CPU_FLAG_BMI1)
-#define CPUFLAG_AESNI    (AV_CPU_FLAG_AESNI    | CPUFLAG_SSE42)
-#define CPUFLAG_AVX512   (AV_CPU_FLAG_AVX512   | CPUFLAG_AVX2)
-    static const AVOption cpuflags_opts[] = {
-        { "flags"   , NULL, 0, AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT64_MIN, INT64_MAX, .unit = "flags" },
-#if   ARCH_PPC
-        { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_ALTIVEC  },    .unit = "flags" },
-#elif ARCH_X86
-        { "mmx"     , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_MMX      },    .unit = "flags" },
-        { "mmxext"  , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_MMXEXT       },    .unit = "flags" },
-        { "sse"     , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE          },    .unit = "flags" },
-        { "sse2"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE2         },    .unit = "flags" },
-        { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE2SLOW     },    .unit = "flags" },
-        { "sse3"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE3         },    .unit = "flags" },
-        { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE3SLOW     },    .unit = "flags" },
-        { "ssse3"   , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSSE3        },    .unit = "flags" },
-        { "atom"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_ATOM     },    .unit = "flags" },
-        { "sse4.1"  , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE4         },    .unit = "flags" },
-        { "sse4.2"  , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_SSE42        },    .unit = "flags" },
-        { "avx"     , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AVX          },    .unit = "flags" },
-        { "avxslow" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AVXSLOW      },    .unit = "flags" },
-        { "xop"     , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_XOP          },    .unit = "flags" },
-        { "fma3"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_FMA3         },    .unit = "flags" },
-        { "fma4"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_FMA4         },    .unit = "flags" },
-        { "avx2"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AVX2         },    .unit = "flags" },
-        { "bmi1"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_BMI1     },    .unit = "flags" },
-        { "bmi2"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_BMI2         },    .unit = "flags" },
-        { "3dnow"   , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_3DNOW        },    .unit = "flags" },
-        { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_3DNOWEXT     },    .unit = "flags" },
-        { "cmov",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_CMOV     },    .unit = "flags" },
-        { "aesni"   , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AESNI        },    .unit = "flags" },
-        { "avx512"  , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = CPUFLAG_AVX512       },    .unit = "flags" },
-#elif ARCH_ARM
-        { "armv5te",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_ARMV5TE  },    .unit = "flags" },
-        { "armv6",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_ARMV6    },    .unit = "flags" },
-        { "armv6t2",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_ARMV6T2  },    .unit = "flags" },
-        { "vfp",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_VFP      },    .unit = "flags" },
-        { "vfp_vm",   NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_VFP_VM   },    .unit = "flags" },
-        { "vfpv3",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_VFPV3    },    .unit = "flags" },
-        { "neon",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_NEON     },    .unit = "flags" },
-#elif ARCH_AARCH64
-        { "armv8",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_ARMV8    },    .unit = "flags" },
-        { "neon",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_NEON     },    .unit = "flags" },
-        { "vfp",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_VFP      },    .unit = "flags" },
-#elif ARCH_MIPS
-        { "mmi",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_MMI      },    .unit = "flags" },
-        { "msa",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_MSA      },    .unit = "flags" },
-#endif
-        { NULL },
-    };
-    static const AVClass class = {
-        .class_name = "cpuflags",
-        .item_name  = av_default_item_name,
-        .option     = cpuflags_opts,
-        .version    = LIBAVUTIL_VERSION_INT,
-    };
-
-    int flags = 0, ret;
-    const AVClass *pclass = &class;
-
-    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], s, &flags)) < 0)
-        return ret;
-
-    return flags & INT_MAX;
-}
-
 int av_parse_cpu_caps(unsigned *flags, const char *s)
 {
         static const AVOption cpuflags_opts[] = {
@@ -225,6 +142,8 @@
         { "cmov",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_CMOV     },    .unit = "flags" },
         { "aesni",    NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_AESNI    },    .unit = "flags" },
         { "avx512"  , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_AVX512   },    .unit = "flags" },
+        { "avx512icl",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_AVX512ICL   }, .unit = "flags" },
+        { "slowgather", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_SLOW_GATHER }, .unit = "flags" },
 
 #define CPU_FLAG_P2 AV_CPU_FLAG_CMOV | AV_CPU_FLAG_MMX
 #define CPU_FLAG_P3 CPU_FLAG_P2 | AV_CPU_FLAG_MMX2 | AV_CPU_FLAG_SSE
@@ -258,6 +177,18 @@
 #elif ARCH_MIPS
         { "mmi",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_MMI      },    .unit = "flags" },
         { "msa",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_MSA      },    .unit = "flags" },
+#elif ARCH_LOONGARCH
+        { "lsx",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_LSX      },    .unit = "flags" },
+        { "lasx",     NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_LASX     },    .unit = "flags" },
+#elif ARCH_RISCV
+        { "rvi",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVI      },    .unit = "flags" },
+        { "rvf",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVF      },    .unit = "flags" },
+        { "rvd",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVD      },    .unit = "flags" },
+        { "rvv-i32",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_I32 },     .unit = "flags" },
+        { "rvv-f32",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_F32 },     .unit = "flags" },
+        { "rvv-i64",  NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_I64 },     .unit = "flags" },
+        { "rvv",      NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVV_F64 },     .unit = "flags" },
+        { "rvb-basic",NULL, 0, AV_OPT_TYPE_CONST, { .i64 = AV_CPU_FLAG_RVB_BASIC },   .unit = "flags" },
 #endif
         { NULL },
     };
@@ -274,9 +205,10 @@
 
 int av_cpu_count(void)
 {
-    static volatile int printed;
+    static atomic_int printed = ATOMIC_VAR_INIT(0);
 
     int nb_cpus = 1;
+    int count   = 0;
 #if HAVE_WINRT
     SYSTEM_INFO sysinfo;
 #endif
@@ -312,26 +244,39 @@
     nb_cpus = sysinfo.dwNumberOfProcessors;
 #endif
 
-    if (!printed) {
+    if (!atomic_exchange_explicit(&printed, 1, memory_order_relaxed))
         av_log(NULL, AV_LOG_DEBUG, "detected %d logical cores\n", nb_cpus);
-        printed = 1;
+
+    count = atomic_load_explicit(&cpu_count, memory_order_relaxed);
+
+    if (count > 0) {
+        nb_cpus = count;
+        av_log(NULL, AV_LOG_DEBUG, "overriding to %d logical cores\n", nb_cpus);
     }
 
     return nb_cpus;
 }
 
+void av_cpu_force_count(int count)
+{
+    atomic_store_explicit(&cpu_count, count, memory_order_relaxed);
+}
+
 size_t av_cpu_max_align(void)
 {
-    if (ARCH_MIPS)
-        return ff_get_cpu_max_align_mips();
-    if (ARCH_AARCH64)
-        return ff_get_cpu_max_align_aarch64();
-    if (ARCH_ARM)
-        return ff_get_cpu_max_align_arm();
-    if (ARCH_PPC)
-        return ff_get_cpu_max_align_ppc();
-    if (ARCH_X86)
-        return ff_get_cpu_max_align_x86();
+#if ARCH_MIPS
+    return ff_get_cpu_max_align_mips();
+#elif ARCH_AARCH64
+    return ff_get_cpu_max_align_aarch64();
+#elif ARCH_ARM
+    return ff_get_cpu_max_align_arm();
+#elif ARCH_PPC
+    return ff_get_cpu_max_align_ppc();
+#elif ARCH_X86
+    return ff_get_cpu_max_align_x86();
+#elif ARCH_LOONGARCH
+    return ff_get_cpu_max_align_loongarch();
+#endif
 
     return 8;
 }
diff -Naur a/media/ffvpx/libavutil/cpu.h b/media/ffvpx/libavutil/cpu.h
--- a/media/ffvpx/libavutil/cpu.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/cpu.h	2023-04-06 12:50:06.975471215 +0200
@@ -23,8 +23,6 @@
 
 #include <stddef.h>
 
-#include "attributes.h"
-
 #define AV_CPU_FLAG_FORCE    0x80000000 /* force usage of selected flags (OR) */
 
     /* lower 16 bits - CPU features */
@@ -56,6 +54,8 @@
 #define AV_CPU_FLAG_BMI1        0x20000 ///< Bit Manipulation Instruction Set 1
 #define AV_CPU_FLAG_BMI2        0x40000 ///< Bit Manipulation Instruction Set 2
 #define AV_CPU_FLAG_AVX512     0x100000 ///< AVX-512 functions: requires OS support even if YMM/ZMM registers aren't used
+#define AV_CPU_FLAG_AVX512ICL  0x200000 ///< F/CD/BW/DQ/VL/VNNI/IFMA/VBMI/VBMI2/VPOPCNTDQ/BITALG/GFNI/VAES/VPCLMULQDQ
+#define AV_CPU_FLAG_SLOW_GATHER  0x2000000 ///< CPU has slow gathers.
 
 #define AV_CPU_FLAG_ALTIVEC      0x0001 ///< standard
 #define AV_CPU_FLAG_VSX          0x0002 ///< ISA 2.06
@@ -74,6 +74,20 @@
 #define AV_CPU_FLAG_MMI          (1 << 0)
 #define AV_CPU_FLAG_MSA          (1 << 1)
 
+//Loongarch SIMD extension.
+#define AV_CPU_FLAG_LSX          (1 << 0)
+#define AV_CPU_FLAG_LASX         (1 << 1)
+
+// RISC-V extensions
+#define AV_CPU_FLAG_RVI          (1 << 0) ///< I (full GPR bank)
+#define AV_CPU_FLAG_RVF          (1 << 1) ///< F (single precision FP)
+#define AV_CPU_FLAG_RVD          (1 << 2) ///< D (double precision FP)
+#define AV_CPU_FLAG_RVV_I32      (1 << 3) ///< Vectors of 8/16/32-bit int's */
+#define AV_CPU_FLAG_RVV_F32      (1 << 4) ///< Vectors of float's */
+#define AV_CPU_FLAG_RVV_I64      (1 << 5) ///< Vectors of 64-bit int's */
+#define AV_CPU_FLAG_RVV_F64      (1 << 6) ///< Vectors of double's
+#define AV_CPU_FLAG_RVB_BASIC    (1 << 7) ///< Basic bit-manipulations
+
 /**
  * Return the flags which specify extensions supported by the CPU.
  * The returned value is affected by av_force_cpu_flags() if that was used
@@ -89,25 +103,6 @@
 void av_force_cpu_flags(int flags);
 
 /**
- * Set a mask on flags returned by av_get_cpu_flags().
- * This function is mainly useful for testing.
- * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible
- */
-attribute_deprecated void av_set_cpu_flags_mask(int mask);
-
-/**
- * Parse CPU flags from a string.
- *
- * The returned flags contain the specified flags as well as related unspecified flags.
- *
- * This function exists only for compatibility with libav.
- * Please use av_parse_cpu_caps() when possible.
- * @return a combination of AV_CPU_* flags, negative on error.
- */
-attribute_deprecated
-int av_parse_cpu_flags(const char *s);
-
-/**
  * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
  *
  * @return negative on error.
@@ -120,6 +115,12 @@
 int av_cpu_count(void);
 
 /**
+ * Overrides cpu count detection and forces the specified count.
+ * Count < 1 disables forcing of specific count.
+ */
+void av_cpu_force_count(int count);
+
+/**
  * Get the maximum data alignment that may be required by FFmpeg.
  *
  * Note that this is affected by the build configuration and the CPU flags mask,
diff -Naur a/media/ffvpx/libavutil/cpu_internal.h b/media/ffvpx/libavutil/cpu_internal.h
--- a/media/ffvpx/libavutil/cpu_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/cpu_internal.h	2023-04-06 12:50:06.975471215 +0200
@@ -30,12 +30,15 @@
     (HAVE_ ## cpuext ## suffix && ((flags) & AV_CPU_FLAG_ ## cpuext) && \
      !((flags) & AV_CPU_FLAG_ ## slow_cpuext ## SLOW))
 
+#define CPUEXT_SUFFIX_SLOW(flags, suffix, cpuext)                       \
+    (HAVE_ ## cpuext ## suffix &&                                       \
+     ((flags) & (AV_CPU_FLAG_ ## cpuext | AV_CPU_FLAG_ ## cpuext ## SLOW)))
+
 #define CPUEXT_SUFFIX_SLOW2(flags, suffix, cpuext, slow_cpuext)         \
     (HAVE_ ## cpuext ## suffix && ((flags) & AV_CPU_FLAG_ ## cpuext) && \
-     ((flags) & AV_CPU_FLAG_ ## slow_cpuext ## SLOW))
+     ((flags) & (AV_CPU_FLAG_ ## slow_cpuext | AV_CPU_FLAG_ ## slow_cpuext ## SLOW)))
 
 #define CPUEXT_SUFFIX_FAST(flags, suffix, cpuext) CPUEXT_SUFFIX_FAST2(flags, suffix, cpuext, cpuext)
-#define CPUEXT_SUFFIX_SLOW(flags, suffix, cpuext) CPUEXT_SUFFIX_SLOW2(flags, suffix, cpuext, cpuext)
 
 #define CPUEXT(flags, cpuext) CPUEXT_SUFFIX(flags, , cpuext)
 #define CPUEXT_FAST(flags, cpuext) CPUEXT_SUFFIX_FAST(flags, , cpuext)
@@ -45,12 +48,15 @@
 int ff_get_cpu_flags_aarch64(void);
 int ff_get_cpu_flags_arm(void);
 int ff_get_cpu_flags_ppc(void);
+int ff_get_cpu_flags_riscv(void);
 int ff_get_cpu_flags_x86(void);
+int ff_get_cpu_flags_loongarch(void);
 
 size_t ff_get_cpu_max_align_mips(void);
 size_t ff_get_cpu_max_align_aarch64(void);
 size_t ff_get_cpu_max_align_arm(void);
 size_t ff_get_cpu_max_align_ppc(void);
 size_t ff_get_cpu_max_align_x86(void);
+size_t ff_get_cpu_max_align_loongarch(void);
 
 #endif /* AVUTIL_CPU_INTERNAL_H */
diff -Naur a/media/ffvpx/libavutil/crc.c b/media/ffvpx/libavutil/crc.c
--- a/media/ffvpx/libavutil/crc.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/crc.c	2023-04-06 12:49:40.260395172 +0200
@@ -23,8 +23,8 @@
 #include "thread.h"
 #include "avassert.h"
 #include "bswap.h"
-#include "common.h"
 #include "crc.h"
+#include "error.h"
 
 #if CONFIG_HARDCODED_TABLES
 static const AVCRC av_crc_table[AV_CRC_MAX][257] = {
diff -Naur a/media/ffvpx/libavutil/crc.h b/media/ffvpx/libavutil/crc.h
--- a/media/ffvpx/libavutil/crc.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/crc.h	2023-04-06 12:50:06.975471215 +0200
@@ -30,7 +30,6 @@
 #include <stdint.h>
 #include <stddef.h>
 #include "attributes.h"
-#include "version.h"
 
 /**
  * @defgroup lavu_crc32 CRC
@@ -85,7 +84,10 @@
 
 /**
  * Calculate the CRC of a block.
+ * @param ctx initialized AVCRC array (see av_crc_init())
  * @param crc CRC of previous blocks if any or initial value for CRC
+ * @param buffer buffer whose CRC to calculate
+ * @param length length of the buffer
  * @return CRC updated with the data from the given block
  *
  * @see av_crc_init() "le" parameter
diff -Naur a/media/ffvpx/libavutil/dict.c b/media/ffvpx/libavutil/dict.c
--- a/media/ffvpx/libavutil/dict.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/dict.c	2023-04-06 12:50:24.493176583 +0200
@@ -20,8 +20,10 @@
 
 #include <string.h>
 
+#include "avassert.h"
 #include "avstring.h"
 #include "dict.h"
+#include "dict_internal.h"
 #include "internal.h"
 #include "mem.h"
 #include "time_internal.h"
@@ -37,21 +39,35 @@
     return m ? m->count : 0;
 }
 
-AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key,
-                               const AVDictionaryEntry *prev, int flags)
+const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m,
+                                         const AVDictionaryEntry *prev)
 {
-    unsigned int i, j;
+    int i = 0;
 
     if (!m)
         return NULL;
 
     if (prev)
         i = prev - m->elems + 1;
-    else
-        i = 0;
 
-    for (; i < m->count; i++) {
-        const char *s = m->elems[i].key;
+    av_assert2(i >= 0);
+    if (i >= m->count)
+        return NULL;
+
+    return &m->elems[i];
+}
+
+AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key,
+                               const AVDictionaryEntry *prev, int flags)
+{
+    const AVDictionaryEntry *entry = prev;
+    unsigned int j;
+
+    if (!key)
+        return NULL;
+
+    while ((entry = av_dict_iterate(m, entry))) {
+        const char *s = entry->key;
         if (flags & AV_DICT_MATCH_CASE)
             for (j = 0; s[j] == key[j] && key[j]; j++)
                 ;
@@ -62,7 +78,7 @@
             continue;
         if (s[j] && !(flags & AV_DICT_IGNORE_SUFFIX))
             continue;
-        return &m->elems[i];
+        return (AVDictionaryEntry *)entry;
     }
     return NULL;
 }
@@ -72,8 +88,17 @@
 {
     AVDictionary *m = *pm;
     AVDictionaryEntry *tag = NULL;
-    char *oldval = NULL, *copy_key = NULL, *copy_value = NULL;
+    char *copy_key = NULL, *copy_value = NULL;
+    int err;
 
+    if (flags & AV_DICT_DONT_STRDUP_VAL)
+        copy_value = (void *)value;
+    else if (value)
+        copy_value = av_strdup(value);
+    if (!key) {
+        err = AVERROR(EINVAL);
+        goto err_out;
+    }
     if (!(flags & AV_DICT_MULTIKEY)) {
         tag = av_dict_get(m, key, NULL, flags);
     }
@@ -81,14 +106,10 @@
         copy_key = (void *)key;
     else
         copy_key = av_strdup(key);
-    if (flags & AV_DICT_DONT_STRDUP_VAL)
-        copy_value = (void *)value;
-    else if (copy_key)
-        copy_value = av_strdup(value);
     if (!m)
         m = *pm = av_mallocz(sizeof(*m));
-    if (!m || (key && !copy_key) || (value && !copy_value))
-        goto err_out;
+    if (!m || !copy_key || (value && !copy_value))
+        goto enomem;
 
     if (tag) {
         if (flags & AV_DICT_DONT_OVERWRITE) {
@@ -96,9 +117,17 @@
             av_free(copy_value);
             return 0;
         }
-        if (flags & AV_DICT_APPEND)
-            oldval = tag->value;
-        else
+        if (copy_value && flags & AV_DICT_APPEND) {
+            size_t oldlen = strlen(tag->value);
+            size_t new_part_len = strlen(copy_value);
+            size_t len = oldlen + new_part_len + 1;
+            char *newval = av_realloc(tag->value, len);
+            if (!newval)
+                goto enomem;
+            memcpy(newval + oldlen, copy_value, new_part_len + 1);
+            av_freep(&copy_value);
+            copy_value = newval;
+        } else
             av_free(tag->value);
         av_free(tag->key);
         *tag = m->elems[--m->count];
@@ -106,34 +135,25 @@
         AVDictionaryEntry *tmp = av_realloc_array(m->elems,
                                                   m->count + 1, sizeof(*m->elems));
         if (!tmp)
-            goto err_out;
+            goto enomem;
         m->elems = tmp;
     }
     if (copy_value) {
         m->elems[m->count].key = copy_key;
         m->elems[m->count].value = copy_value;
-        if (oldval && flags & AV_DICT_APPEND) {
-            size_t len = strlen(oldval) + strlen(copy_value) + 1;
-            char *newval = av_mallocz(len);
-            if (!newval)
-                goto err_out;
-            av_strlcat(newval, oldval, len);
-            av_freep(&oldval);
-            av_strlcat(newval, copy_value, len);
-            m->elems[m->count].value = newval;
-            av_freep(&copy_value);
-        }
         m->count++;
     } else {
+        if (!m->count) {
+            av_freep(&m->elems);
+            av_freep(pm);
+        }
         av_freep(&copy_key);
     }
-    if (!m->count) {
-        av_freep(&m->elems);
-        av_freep(pm);
-    }
 
     return 0;
 
+enomem:
+    err = AVERROR(ENOMEM);
 err_out:
     if (m && !m->count) {
         av_freep(&m->elems);
@@ -141,7 +161,7 @@
     }
     av_free(copy_key);
     av_free(copy_value);
-    return AVERROR(ENOMEM);
+    return err;
 }
 
 int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value,
@@ -216,9 +236,9 @@
 
 int av_dict_copy(AVDictionary **dst, const AVDictionary *src, int flags)
 {
-    AVDictionaryEntry *t = NULL;
+    const AVDictionaryEntry *t = NULL;
 
-    while ((t = av_dict_get(src, "", t, AV_DICT_IGNORE_SUFFIX))) {
+    while ((t = av_dict_iterate(src, t))) {
         int ret = av_dict_set(dst, t->key, t->value, flags);
         if (ret < 0)
             return ret;
@@ -230,7 +250,7 @@
 int av_dict_get_string(const AVDictionary *m, char **buffer,
                        const char key_val_sep, const char pairs_sep)
 {
-    AVDictionaryEntry *t = NULL;
+    const AVDictionaryEntry *t = NULL;
     AVBPrint bprint;
     int cnt = 0;
     char special_chars[] = {pairs_sep, key_val_sep, '\0'};
@@ -245,7 +265,7 @@
     }
 
     av_bprint_init(&bprint, 64, AV_BPRINT_SIZE_UNLIMITED);
-    while ((t = av_dict_get(m, "", t, AV_DICT_IGNORE_SUFFIX))) {
+    while ((t = av_dict_iterate(m, t))) {
         if (cnt++)
             av_bprint_append_data(&bprint, &pairs_sep, 1);
         av_bprint_escape(&bprint, t->key, special_chars, AV_ESCAPE_MODE_BACKSLASH, 0);
diff -Naur a/media/ffvpx/libavutil/dict.h b/media/ffvpx/libavutil/dict.h
--- a/media/ffvpx/libavutil/dict.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/dict.h	2023-04-06 12:50:24.493176583 +0200
@@ -32,8 +32,6 @@
 
 #include <stdint.h>
 
-#include "version.h"
-
 /**
  * @addtogroup lavu_dict AVDictionary
  * @ingroup lavu_data
@@ -41,13 +39,15 @@
  * @brief Simple key:value store
  *
  * @{
- * Dictionaries are used for storing key:value pairs. To create
- * an AVDictionary, simply pass an address of a NULL pointer to
- * av_dict_set(). NULL can be used as an empty dictionary wherever
- * a pointer to an AVDictionary is required.
- * Use av_dict_get() to retrieve an entry or iterate over all
- * entries and finally av_dict_free() to free the dictionary
- * and all its contents.
+ * Dictionaries are used for storing key-value pairs.
+ *
+ * - To **create an AVDictionary**, simply pass an address of a NULL
+ *   pointer to av_dict_set(). NULL can be used as an empty dictionary
+ *   wherever a pointer to an AVDictionary is required.
+ * - To **insert an entry**, use av_dict_set().
+ * - Use av_dict_get() to **retrieve an entry**.
+ * - To **iterate over all entries**, use av_dict_iterate().
+ * - In order to **free the dictionary and all its contents**, use av_dict_free().
  *
  @code
    AVDictionary *d = NULL;           // "create" an empty dictionary
@@ -59,13 +59,18 @@
    char *v = av_strdup("value");     // you can avoid copying them like this
    av_dict_set(&d, k, v, AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);
 
-   while (t = av_dict_get(d, "", t, AV_DICT_IGNORE_SUFFIX)) {
-       <....>                             // iterate over all entries in d
+   while ((t = av_dict_iterate(d, t))) {
+       <....>                        // iterate over all entries in d
    }
    av_dict_free(&d);
  @endcode
  */
 
+/**
+ * @name AVDictionary Flags
+ * Flags that influence behavior of the matching of keys or insertion to the dictionary.
+ * @{
+ */
 #define AV_DICT_MATCH_CASE      1   /**< Only get an entry with exact-case key match. Only relevant in av_dict_get(). */
 #define AV_DICT_IGNORE_SUFFIX   2   /**< Return first entry in a dictionary whose first part corresponds to the search key,
                                          ignoring the suffix of the found key string. Only relevant in av_dict_get(). */
@@ -73,10 +78,13 @@
                                          allocated with av_malloc() or another memory allocation function. */
 #define AV_DICT_DONT_STRDUP_VAL 8   /**< Take ownership of a value that's been
                                          allocated with av_malloc() or another memory allocation function. */
-#define AV_DICT_DONT_OVERWRITE 16   ///< Don't overwrite existing entries.
+#define AV_DICT_DONT_OVERWRITE 16   /**< Don't overwrite existing entries. */
 #define AV_DICT_APPEND         32   /**< If the entry already exists, append to it.  Note that no
-                                      delimiter is added, the strings are simply concatenated. */
+                                         delimiter is added, the strings are simply concatenated. */
 #define AV_DICT_MULTIKEY       64   /**< Allow to store several equal keys in the dictionary */
+/**
+ * @}
+ */
 
 typedef struct AVDictionaryEntry {
     char *key;
@@ -91,19 +99,45 @@
  * The returned entry key or value must not be changed, or it will
  * cause undefined behavior.
  *
- * To iterate through all the dictionary entries, you can set the matching key
- * to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.
+ * @param prev  Set to the previous matching element to find the next.
+ *              If set to NULL the first matching element is returned.
+ * @param key   Matching key
+ * @param flags A collection of AV_DICT_* flags controlling how the
+ *              entry is retrieved
  *
- * @param prev Set to the previous matching element to find the next.
- *             If set to NULL the first matching element is returned.
- * @param key matching key
- * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved
- * @return found entry or NULL in case no matching entry was found in the dictionary
+ * @return      Found entry or NULL in case no matching entry was found in the dictionary
  */
 AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key,
                                const AVDictionaryEntry *prev, int flags);
 
 /**
+ * Iterate over a dictionary
+ *
+ * Iterates through all entries in the dictionary.
+ *
+ * @warning The returned AVDictionaryEntry key/value must not be changed.
+ *
+ * @warning As av_dict_set() invalidates all previous entries returned
+ * by this function, it must not be called while iterating over the dict.
+ *
+ * Typical usage:
+ * @code
+ * const AVDictionaryEntry *e = NULL;
+ * while ((e = av_dict_iterate(m, e))) {
+ *     // ...
+ * }
+ * @endcode
+ *
+ * @param m     The dictionary to iterate over
+ * @param prev  Pointer to the previous AVDictionaryEntry, NULL initially
+ *
+ * @retval AVDictionaryEntry* The next element in the dictionary
+ * @retval NULL               No more elements in the dictionary
+ */
+const AVDictionaryEntry *av_dict_iterate(const AVDictionary *m,
+                                         const AVDictionaryEntry *prev);
+
+/**
  * Get number of entries in dictionary.
  *
  * @param m dictionary
@@ -117,23 +151,24 @@
  * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
  * these arguments will be freed on error.
  *
- * Warning: Adding a new entry to a dictionary invalidates all existing entries
- * previously returned with av_dict_get.
+ * @warning Adding a new entry to a dictionary invalidates all existing entries
+ * previously returned with av_dict_get() or av_dict_iterate().
  *
- * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL
- * a dictionary struct is allocated and put in *pm.
- * @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
- * @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
- *        Passing a NULL value will cause an existing entry to be deleted.
- * @return >= 0 on success otherwise an error code <0
+ * @param pm        Pointer to a pointer to a dictionary struct. If *pm is NULL
+ *                  a dictionary struct is allocated and put in *pm.
+ * @param key       Entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
+ * @param value     Entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
+ *                  Passing a NULL value will cause an existing entry to be deleted.
+ *
+ * @return          >= 0 on success otherwise an error code <0
  */
 int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags);
 
 /**
- * Convenience wrapper for av_dict_set that converts the value to a string
+ * Convenience wrapper for av_dict_set() that converts the value to a string
  * and stores it.
  *
- * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
+ * Note: If ::AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
  */
 int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags);
 
@@ -143,14 +178,15 @@
  * In case of failure, all the successfully set entries are stored in
  * *pm. You may need to manually free the created dictionary.
  *
- * @param key_val_sep  a 0-terminated list of characters used to separate
+ * @param key_val_sep  A 0-terminated list of characters used to separate
  *                     key from value
- * @param pairs_sep    a 0-terminated list of characters used to separate
+ * @param pairs_sep    A 0-terminated list of characters used to separate
  *                     two pairs from each other
- * @param flags        flags to use when adding to dictionary.
- *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL
+ * @param flags        Flags to use when adding to the dictionary.
+ *                     ::AV_DICT_DONT_STRDUP_KEY and ::AV_DICT_DONT_STRDUP_VAL
  *                     are ignored since the key/value tokens will always
  *                     be duplicated.
+ *
  * @return             0 on success, negative AVERROR code on failure
  */
 int av_dict_parse_string(AVDictionary **pm, const char *str,
@@ -159,11 +195,14 @@
 
 /**
  * Copy entries from one AVDictionary struct into another.
- * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,
- *            this function will allocate a struct for you and put it in *dst
- * @param src pointer to source AVDictionary struct
- * @param flags flags to use when setting entries in *dst
- * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag
+ *
+ * @note Metadata is read using the ::AV_DICT_IGNORE_SUFFIX flag
+ *
+ * @param dst   Pointer to a pointer to a AVDictionary struct to copy into. If *dst is NULL,
+ *              this function will allocate a struct for you and put it in *dst
+ * @param src   Pointer to the source AVDictionary struct to copy items from.
+ * @param flags Flags to use when setting entries in *dst
+ *
  * @return 0 on success, negative AVERROR code on failure. If dst was allocated
  *           by this function, callers should free the associated memory.
  */
@@ -182,13 +221,15 @@
  * Such string may be passed back to av_dict_parse_string().
  * @note String is escaped with backslashes ('\').
  *
- * @param[in]  m             dictionary
+ * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
+ *
+ * @param[in]  m             The dictionary
  * @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.
  *                           Buffer must be freed by the caller when is no longer needed.
- * @param[in]  key_val_sep   character used to separate key from value
- * @param[in]  pairs_sep     character used to separate two pairs from each other
+ * @param[in]  key_val_sep   Character used to separate key from value
+ * @param[in]  pairs_sep     Character used to separate two pairs from each other
+ *
  * @return                   >= 0 on success, negative on error
- * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
  */
 int av_dict_get_string(const AVDictionary *m, char **buffer,
                        const char key_val_sep, const char pairs_sep);
diff -Naur a/media/ffvpx/libavutil/dict_internal.h b/media/ffvpx/libavutil/dict_internal.h
--- a/media/ffvpx/libavutil/dict_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavutil/dict_internal.h	2023-04-06 12:50:06.975471215 +0200
@@ -0,0 +1,37 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_DICT_INTERNAL_H
+#define AVUTIL_DICT_INTERNAL_H
+
+#include <stdint.h>
+
+#include "dict.h"
+
+/**
+ * Set a dictionary value to an ISO-8601 compliant timestamp string.
+ *
+ * @param dict pointer to a pointer to a dictionary struct. If *dict is NULL
+ *             a dictionary struct is allocated and put in *dict.
+ * @param key metadata key
+ * @param timestamp unix timestamp in microseconds
+ * @return <0 on error
+ */
+int avpriv_dict_set_timestamp(AVDictionary **dict, const char *key, int64_t timestamp);
+
+#endif /* AVUTIL_DICT_INTERNAL_H */
diff -Naur a/media/ffvpx/libavutil/error.c b/media/ffvpx/libavutil/error.c
--- a/media/ffvpx/libavutil/error.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/error.c	2023-04-06 12:49:40.260395172 +0200
@@ -18,9 +18,12 @@
 
 #undef _GNU_SOURCE
 #define _XOPEN_SOURCE 600 /* XSI-compliant version of strerror_r */
-#include "avutil.h"
+#include <stdio.h>
+#include <string.h>
+#include "config.h"
 #include "avstring.h"
-#include "common.h"
+#include "error.h"
+#include "macros.h"
 
 struct error_entry {
     int num;
diff -Naur a/media/ffvpx/libavutil/error.h b/media/ffvpx/libavutil/error.h
--- a/media/ffvpx/libavutil/error.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/error.h	2023-04-06 12:49:40.260395172 +0200
@@ -27,6 +27,8 @@
 #include <errno.h>
 #include <stddef.h>
 
+#include "macros.h"
+
 /**
  * @addtogroup lavu_error
  *
diff -Naur a/media/ffvpx/libavutil/eval.h b/media/ffvpx/libavutil/eval.h
--- a/media/ffvpx/libavutil/eval.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/eval.h	2023-04-06 12:50:06.975471215 +0200
@@ -26,8 +26,6 @@
 #ifndef AVUTIL_EVAL_H
 #define AVUTIL_EVAL_H
 
-#include "avutil.h"
-
 typedef struct AVExpr AVExpr;
 
 /**
@@ -44,6 +42,7 @@
  * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
  * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
+ * @param log_offset log level offset, can be used to silence error messages
  * @param log_ctx parent logging context
  * @return >= 0 in case of success, a negative value corresponding to an
  * AVERROR code otherwise
@@ -67,6 +66,7 @@
  * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
  * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
+ * @param log_offset log level offset, can be used to silence error messages
  * @param log_ctx parent logging context
  * @return >= 0 in case of success, a negative value corresponding to an
  * AVERROR code otherwise
@@ -80,6 +80,7 @@
 /**
  * Evaluate a previously parsed expression.
  *
+ * @param e the AVExpr to evaluate
  * @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names
  * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
  * @return the value of the expression
@@ -89,6 +90,7 @@
 /**
  * Track the presence of variables and their number of occurrences in a parsed expression
  *
+ * @param e the AVExpr to track variables in
  * @param counter a zero-initialized array where the count of each variable will be stored
  * @param size size of array
  * @return 0 on success, a negative value indicates that no expression or array was passed
@@ -100,6 +102,7 @@
  * Track the presence of user provided functions and their number of occurrences
  * in a parsed expression.
  *
+ * @param e the AVExpr to track user provided functions in
  * @param counter a zero-initialized array where the count of each function will be stored
  *                if you passed 5 functions with 2 arguments to av_expr_parse()
  *                then for arg=2 this will use upto 5 entries.
diff -Naur a/media/ffvpx/libavutil/ffversion.h b/media/ffvpx/libavutil/ffversion.h
--- a/media/ffvpx/libavutil/ffversion.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/ffversion.h	2023-04-06 12:50:24.493176583 +0200
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "n4.0.2-6-g2be51cbeea"
+#define FFMPEG_VERSION "N-109117-g6a3e174ad1"
 #endif /* AVUTIL_FFVERSION_H */
diff -Naur a/media/ffvpx/libavutil/fifo.c b/media/ffvpx/libavutil/fifo.c
--- a/media/ffvpx/libavutil/fifo.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/fifo.c	2023-04-06 12:49:40.260395172 +0200
@@ -20,13 +20,291 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stdint.h>
+#include <string.h>
+
 #include "avassert.h"
-#include "common.h"
+#include "error.h"
 #include "fifo.h"
+#include "macros.h"
+#include "mem.h"
+
+// by default the FIFO can be auto-grown to 1MB
+#define AUTO_GROW_DEFAULT_BYTES (1024 * 1024)
+
+struct AVFifo {
+    uint8_t *buffer;
+
+    size_t elem_size, nb_elems;
+    size_t offset_r, offset_w;
+    // distinguishes the ambiguous situation offset_r == offset_w
+    int    is_empty;
+
+    unsigned int flags;
+    size_t       auto_grow_limit;
+};
+
+AVFifo *av_fifo_alloc2(size_t nb_elems, size_t elem_size,
+                       unsigned int flags)
+{
+    AVFifo *f;
+    void *buffer = NULL;
+
+    if (!elem_size)
+        return NULL;
+
+    if (nb_elems) {
+        buffer = av_realloc_array(NULL, nb_elems, elem_size);
+        if (!buffer)
+            return NULL;
+    }
+    f = av_mallocz(sizeof(*f));
+    if (!f) {
+        av_free(buffer);
+        return NULL;
+    }
+    f->buffer    = buffer;
+    f->nb_elems  = nb_elems;
+    f->elem_size = elem_size;
+    f->is_empty  = 1;
+
+    f->flags           = flags;
+    f->auto_grow_limit = FFMAX(AUTO_GROW_DEFAULT_BYTES / elem_size, 1);
+
+    return f;
+}
+
+void av_fifo_auto_grow_limit(AVFifo *f, size_t max_elems)
+{
+    f->auto_grow_limit = max_elems;
+}
+
+size_t av_fifo_elem_size(const AVFifo *f)
+{
+    return f->elem_size;
+}
+
+size_t av_fifo_can_read(const AVFifo *f)
+{
+    if (f->offset_w <= f->offset_r && !f->is_empty)
+        return f->nb_elems - f->offset_r + f->offset_w;
+    return f->offset_w - f->offset_r;
+}
+
+size_t av_fifo_can_write(const AVFifo *f)
+{
+    return f->nb_elems - av_fifo_can_read(f);
+}
+
+int av_fifo_grow2(AVFifo *f, size_t inc)
+{
+    uint8_t *tmp;
+
+    if (inc > SIZE_MAX - f->nb_elems)
+        return AVERROR(EINVAL);
+
+    tmp = av_realloc_array(f->buffer, f->nb_elems + inc, f->elem_size);
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    f->buffer = tmp;
+
+    // move the data from the beginning of the ring buffer
+    // to the newly allocated space
+    if (f->offset_w <= f->offset_r && !f->is_empty) {
+        const size_t copy = FFMIN(inc, f->offset_w);
+        memcpy(tmp + f->nb_elems * f->elem_size, tmp, copy * f->elem_size);
+        if (copy < f->offset_w) {
+            memmove(tmp, tmp + copy * f->elem_size,
+                    (f->offset_w - copy) * f->elem_size);
+            f->offset_w -= copy;
+        } else
+            f->offset_w = copy == inc ? 0 : f->nb_elems + copy;
+    }
+
+    f->nb_elems += inc;
+
+    return 0;
+}
+
+static int fifo_check_space(AVFifo *f, size_t to_write)
+{
+    const size_t can_write = av_fifo_can_write(f);
+    const size_t need_grow = to_write > can_write ? to_write - can_write : 0;
+    size_t can_grow;
+
+    if (!need_grow)
+        return 0;
+
+    can_grow = f->auto_grow_limit > f->nb_elems ?
+               f->auto_grow_limit - f->nb_elems : 0;
+    if ((f->flags & AV_FIFO_FLAG_AUTO_GROW) && need_grow <= can_grow) {
+        // allocate a bit more than necessary, if we can
+        const size_t inc = (need_grow < can_grow / 2 ) ? need_grow * 2 : can_grow;
+        return av_fifo_grow2(f, inc);
+    }
+
+    return AVERROR(ENOSPC);
+}
+
+static int fifo_write_common(AVFifo *f, const uint8_t *buf, size_t *nb_elems,
+                             AVFifoCB read_cb, void *opaque)
+{
+    size_t to_write = *nb_elems;
+    size_t offset_w;
+    int         ret = 0;
+
+    ret = fifo_check_space(f, to_write);
+    if (ret < 0)
+        return ret;
+
+    offset_w = f->offset_w;
+
+    while (to_write > 0) {
+        size_t    len = FFMIN(f->nb_elems - offset_w, to_write);
+        uint8_t *wptr = f->buffer + offset_w * f->elem_size;
+
+        if (read_cb) {
+            ret = read_cb(opaque, wptr, &len);
+            if (ret < 0 || len == 0)
+                break;
+        } else {
+            memcpy(wptr, buf, len * f->elem_size);
+            buf += len * f->elem_size;
+        }
+        offset_w += len;
+        if (offset_w >= f->nb_elems)
+            offset_w = 0;
+        to_write -= len;
+    }
+    f->offset_w = offset_w;
+
+    if (*nb_elems != to_write)
+        f->is_empty = 0;
+    *nb_elems -= to_write;
+
+    return ret;
+}
+
+int av_fifo_write(AVFifo *f, const void *buf, size_t nb_elems)
+{
+    return fifo_write_common(f, buf, &nb_elems, NULL, NULL);
+}
+
+int av_fifo_write_from_cb(AVFifo *f, AVFifoCB read_cb,
+                          void *opaque, size_t *nb_elems)
+{
+    return fifo_write_common(f, NULL, nb_elems, read_cb, opaque);
+}
+
+static int fifo_peek_common(const AVFifo *f, uint8_t *buf, size_t *nb_elems,
+                            size_t offset, AVFifoCB write_cb, void *opaque)
+{
+    size_t  to_read = *nb_elems;
+    size_t offset_r = f->offset_r;
+    size_t can_read = av_fifo_can_read(f);
+    int         ret = 0;
+
+    if (offset > can_read || to_read > can_read - offset) {
+        *nb_elems = 0;
+        return AVERROR(EINVAL);
+    }
 
-static AVFifoBuffer *fifo_alloc_common(void *buffer, size_t size)
+    if (offset_r >= f->nb_elems - offset)
+        offset_r -= f->nb_elems - offset;
+    else
+        offset_r += offset;
+
+    while (to_read > 0) {
+        size_t    len = FFMIN(f->nb_elems - offset_r, to_read);
+        uint8_t *rptr = f->buffer + offset_r * f->elem_size;
+
+        if (write_cb) {
+            ret = write_cb(opaque, rptr, &len);
+            if (ret < 0 || len == 0)
+                break;
+        } else {
+            memcpy(buf, rptr, len * f->elem_size);
+            buf += len * f->elem_size;
+        }
+        offset_r += len;
+        if (offset_r >= f->nb_elems)
+            offset_r = 0;
+        to_read -= len;
+    }
+
+    *nb_elems -= to_read;
+
+    return ret;
+}
+
+int av_fifo_read(AVFifo *f, void *buf, size_t nb_elems)
+{
+    int ret = fifo_peek_common(f, buf, &nb_elems, 0, NULL, NULL);
+    av_fifo_drain2(f, nb_elems);
+    return ret;
+}
+
+int av_fifo_read_to_cb(AVFifo *f, AVFifoCB write_cb,
+                       void *opaque, size_t *nb_elems)
+{
+    int ret = fifo_peek_common(f, NULL, nb_elems, 0, write_cb, opaque);
+    av_fifo_drain2(f, *nb_elems);
+    return ret;
+}
+
+int av_fifo_peek(AVFifo *f, void *buf, size_t nb_elems, size_t offset)
+{
+    return fifo_peek_common(f, buf, &nb_elems, offset, NULL, NULL);
+}
+
+int av_fifo_peek_to_cb(AVFifo *f, AVFifoCB write_cb, void *opaque,
+                       size_t *nb_elems, size_t offset)
+{
+    return fifo_peek_common(f, NULL, nb_elems, offset, write_cb, opaque);
+}
+
+void av_fifo_drain2(AVFifo *f, size_t size)
+{
+    const size_t cur_size = av_fifo_can_read(f);
+
+    av_assert0(cur_size >= size);
+    if (cur_size == size)
+        f->is_empty = 1;
+
+    if (f->offset_r >= f->nb_elems - size)
+        f->offset_r -= f->nb_elems - size;
+    else
+        f->offset_r += size;
+}
+
+void av_fifo_reset2(AVFifo *f)
+{
+    f->offset_r = f->offset_w = 0;
+    f->is_empty = 1;
+}
+
+void av_fifo_freep2(AVFifo **f)
+{
+    if (*f) {
+        av_freep(&(*f)->buffer);
+        av_freep(f);
+    }
+}
+
+
+#if FF_API_FIFO_OLD_API
+FF_DISABLE_DEPRECATION_WARNINGS
+#define OLD_FIFO_SIZE_MAX (size_t)FFMIN3(INT_MAX, UINT32_MAX, SIZE_MAX)
+
+AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size)
 {
     AVFifoBuffer *f;
+    void *buffer;
+
+    if (nmemb > OLD_FIFO_SIZE_MAX / size)
+        return NULL;
+
+    buffer = av_realloc_array(NULL, nmemb, size);
     if (!buffer)
         return NULL;
     f = av_mallocz(sizeof(AVFifoBuffer));
@@ -35,21 +313,14 @@
         return NULL;
     }
     f->buffer = buffer;
-    f->end    = f->buffer + size;
+    f->end    = f->buffer + nmemb * size;
     av_fifo_reset(f);
     return f;
 }
 
 AVFifoBuffer *av_fifo_alloc(unsigned int size)
 {
-    void *buffer = av_malloc(size);
-    return fifo_alloc_common(buffer, size);
-}
-
-AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size)
-{
-    void *buffer = av_malloc_array(nmemb, size);
-    return fifo_alloc_common(buffer, nmemb * size);
+    return av_fifo_alloc_array(size, 1);
 }
 
 void av_fifo_free(AVFifoBuffer *f)
@@ -88,18 +359,35 @@
 {
     unsigned int old_size = f->end - f->buffer;
 
+    if (new_size > OLD_FIFO_SIZE_MAX)
+        return AVERROR(EINVAL);
+
     if (old_size < new_size) {
-        int len          = av_fifo_size(f);
-        AVFifoBuffer *f2 = av_fifo_alloc(new_size);
+        size_t offset_r = f->rptr - f->buffer;
+        size_t offset_w = f->wptr - f->buffer;
+        uint8_t *tmp;
 
-        if (!f2)
+        tmp = av_realloc(f->buffer, new_size);
+        if (!tmp)
             return AVERROR(ENOMEM);
-        av_fifo_generic_read(f, f2->buffer, len, NULL);
-        f2->wptr += len;
-        f2->wndx += len;
-        av_free(f->buffer);
-        *f = *f2;
-        av_free(f2);
+
+        // move the data from the beginning of the ring buffer
+        // to the newly allocated space
+        // the second condition distinguishes full vs empty fifo
+        if (offset_w <= offset_r && av_fifo_size(f)) {
+            const size_t copy = FFMIN(new_size - old_size, offset_w);
+            memcpy(tmp + old_size, tmp, copy);
+            if (copy < offset_w) {
+                memmove(tmp, tmp + copy , offset_w - copy);
+                offset_w -= copy;
+            } else
+                offset_w = old_size + copy;
+        }
+
+        f->buffer = tmp;
+        f->end    = f->buffer + new_size;
+        f->rptr   = f->buffer + offset_r;
+        f->wptr   = f->buffer + offset_w;
     }
     return 0;
 }
@@ -126,6 +414,9 @@
     uint32_t wndx= f->wndx;
     uint8_t *wptr= f->wptr;
 
+    if (size > av_fifo_space(f))
+        return AVERROR(ENOSPC);
+
     do {
         int len = FFMIN(f->end - wptr, size);
         if (func) {
@@ -136,7 +427,6 @@
             memcpy(wptr, src, len);
             src = (uint8_t *)src + len;
         }
-// Write memory barrier needed for SMP here in theory
         wptr += len;
         if (wptr >= f->end)
             wptr = f->buffer;
@@ -152,13 +442,8 @@
 {
     uint8_t *rptr = f->rptr;
 
-    av_assert2(offset >= 0);
-
-    /*
-     * *ndx are indexes modulo 2^32, they are intended to overflow,
-     * to handle *ndx greater than 4gb.
-     */
-    av_assert2(buf_size + (unsigned)offset <= f->wndx - f->rndx);
+    if (offset < 0 || buf_size > av_fifo_size(f) - offset)
+        return AVERROR(EINVAL);
 
     if (offset >= f->end - rptr)
         rptr += offset - (f->end - f->buffer);
@@ -189,31 +474,15 @@
 int av_fifo_generic_peek(AVFifoBuffer *f, void *dest, int buf_size,
                          void (*func)(void *, void *, int))
 {
-// Read memory barrier needed for SMP here in theory
-    uint8_t *rptr = f->rptr;
-
-    do {
-        int len = FFMIN(f->end - rptr, buf_size);
-        if (func)
-            func(dest, rptr, len);
-        else {
-            memcpy(dest, rptr, len);
-            dest = (uint8_t *)dest + len;
-        }
-// memory barrier needed for SMP here in theory
-        rptr += len;
-        if (rptr >= f->end)
-            rptr -= f->end - f->buffer;
-        buf_size -= len;
-    } while (buf_size > 0);
-
-    return 0;
+    return av_fifo_generic_peek_at(f, dest, 0, buf_size, func);
 }
 
 int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size,
                          void (*func)(void *, void *, int))
 {
-// Read memory barrier needed for SMP here in theory
+    if (buf_size > av_fifo_size(f))
+        return AVERROR(EINVAL);
+
     do {
         int len = FFMIN(f->end - f->rptr, buf_size);
         if (func)
@@ -222,7 +491,6 @@
             memcpy(dest, f->rptr, len);
             dest = (uint8_t *)dest + len;
         }
-// memory barrier needed for SMP here in theory
         av_fifo_drain(f, len);
         buf_size -= len;
     } while (buf_size > 0);
@@ -238,3 +506,5 @@
         f->rptr -= f->end - f->buffer;
     f->rndx += size;
 }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
diff -Naur a/media/ffvpx/libavutil/fifo.h b/media/ffvpx/libavutil/fifo.h
--- a/media/ffvpx/libavutil/fifo.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/fifo.h	2023-04-06 12:50:06.976471255 +0200
@@ -18,16 +18,229 @@
 
 /**
  * @file
- * a very simple circular buffer FIFO implementation
+ * @ingroup lavu_fifo
+ * A generic FIFO API
  */
 
 #ifndef AVUTIL_FIFO_H
 #define AVUTIL_FIFO_H
 
+#include <stddef.h>
 #include <stdint.h>
-#include "avutil.h"
+
 #include "attributes.h"
+#include "version.h"
+
+/**
+ * @defgroup lavu_fifo AVFifo
+ * @ingroup lavu_data
+ *
+ * @{
+ * A generic FIFO API
+ */
+
+typedef struct AVFifo AVFifo;
+
+/**
+ * Callback for writing or reading from a FIFO, passed to (and invoked from) the
+ * av_fifo_*_cb() functions. It may be invoked multiple times from a single
+ * av_fifo_*_cb() call and may process less data than the maximum size indicated
+ * by nb_elems.
+ *
+ * @param opaque the opaque pointer provided to the av_fifo_*_cb() function
+ * @param buf the buffer for reading or writing the data, depending on which
+ *            av_fifo_*_cb function is called
+ * @param nb_elems On entry contains the maximum number of elements that can be
+ *                 read from / written into buf. On success, the callback should
+ *                 update it to contain the number of elements actually written.
+ *
+ * @return 0 on success, a negative error code on failure (will be returned from
+ *         the invoking av_fifo_*_cb() function)
+ */
+typedef int AVFifoCB(void *opaque, void *buf, size_t *nb_elems);
+
+/**
+ * Automatically resize the FIFO on writes, so that the data fits. This
+ * automatic resizing happens up to a limit that can be modified with
+ * av_fifo_auto_grow_limit().
+ */
+#define AV_FIFO_FLAG_AUTO_GROW      (1 << 0)
+
+/**
+ * Allocate and initialize an AVFifo with a given element size.
+ *
+ * @param elems     initial number of elements that can be stored in the FIFO
+ * @param elem_size Size in bytes of a single element. Further operations on
+ *                  the returned FIFO will implicitly use this element size.
+ * @param flags a combination of AV_FIFO_FLAG_*
+ *
+ * @return newly-allocated AVFifo on success, a negative error code on failure
+ */
+AVFifo *av_fifo_alloc2(size_t elems, size_t elem_size,
+                       unsigned int flags);
+
+/**
+ * @return Element size for FIFO operations. This element size is set at
+ *         FIFO allocation and remains constant during its lifetime
+ */
+size_t av_fifo_elem_size(const AVFifo *f);
 
+/**
+ * Set the maximum size (in elements) to which the FIFO can be resized
+ * automatically. Has no effect unless AV_FIFO_FLAG_AUTO_GROW is used.
+ */
+void av_fifo_auto_grow_limit(AVFifo *f, size_t max_elems);
+
+/**
+ * @return number of elements available for reading from the given FIFO.
+ */
+size_t av_fifo_can_read(const AVFifo *f);
+
+/**
+ * @return Number of elements that can be written into the given FIFO without
+ *         growing it.
+ *
+ *         In other words, this number of elements or less is guaranteed to fit
+ *         into the FIFO. More data may be written when the
+ *         AV_FIFO_FLAG_AUTO_GROW flag was specified at FIFO creation, but this
+ *         may involve memory allocation, which can fail.
+ */
+size_t av_fifo_can_write(const AVFifo *f);
+
+/**
+ * Enlarge an AVFifo.
+ *
+ * On success, the FIFO will be large enough to hold exactly
+ * inc + av_fifo_can_read() + av_fifo_can_write()
+ * elements. In case of failure, the old FIFO is kept unchanged.
+ *
+ * @param f AVFifo to resize
+ * @param inc number of elements to allocate for, in addition to the current
+ *            allocated size
+ * @return a non-negative number on success, a negative error code on failure
+ */
+int av_fifo_grow2(AVFifo *f, size_t inc);
+
+/**
+ * Write data into a FIFO.
+ *
+ * In case nb_elems > av_fifo_can_write(f) and the AV_FIFO_FLAG_AUTO_GROW flag
+ * was not specified at FIFO creation, nothing is written and an error
+ * is returned.
+ *
+ * Calling function is guaranteed to succeed if nb_elems <= av_fifo_can_write(f).
+ *
+ * @param f the FIFO buffer
+ * @param buf Data to be written. nb_elems * av_fifo_elem_size(f) bytes will be
+ *            read from buf on success.
+ * @param nb_elems number of elements to write into FIFO
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ */
+int av_fifo_write(AVFifo *f, const void *buf, size_t nb_elems);
+
+/**
+ * Write data from a user-provided callback into a FIFO.
+ *
+ * @param f the FIFO buffer
+ * @param read_cb Callback supplying the data to the FIFO. May be called
+ *                multiple times.
+ * @param opaque opaque user data to be provided to read_cb
+ * @param nb_elems Should point to the maximum number of elements that can be
+ *                 written. Will be updated to contain the number of elements
+ *                 actually written.
+ *
+ * @return non-negative number on success, a negative error code on failure
+ */
+int av_fifo_write_from_cb(AVFifo *f, AVFifoCB read_cb,
+                          void *opaque, size_t *nb_elems);
+
+/**
+ * Read data from a FIFO.
+ *
+ * In case nb_elems > av_fifo_can_read(f), nothing is read and an error
+ * is returned.
+ *
+ * @param f the FIFO buffer
+ * @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes
+ *            will be written into buf on success.
+ * @param nb_elems number of elements to read from FIFO
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ */
+int av_fifo_read(AVFifo *f, void *buf, size_t nb_elems);
+
+/**
+ * Feed data from a FIFO into a user-provided callback.
+ *
+ * @param f the FIFO buffer
+ * @param write_cb Callback the data will be supplied to. May be called
+ *                 multiple times.
+ * @param opaque opaque user data to be provided to write_cb
+ * @param nb_elems Should point to the maximum number of elements that can be
+ *                 read. Will be updated to contain the total number of elements
+ *                 actually sent to the callback.
+ *
+ * @return non-negative number on success, a negative error code on failure
+ */
+int av_fifo_read_to_cb(AVFifo *f, AVFifoCB write_cb,
+                       void *opaque, size_t *nb_elems);
+
+/**
+ * Read data from a FIFO without modifying FIFO state.
+ *
+ * Returns an error if an attempt is made to peek to nonexistent elements
+ * (i.e. if offset + nb_elems is larger than av_fifo_can_read(f)).
+ *
+ * @param f the FIFO buffer
+ * @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes
+ *            will be written into buf.
+ * @param nb_elems number of elements to read from FIFO
+ * @param offset number of initial elements to skip.
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ */
+int av_fifo_peek(AVFifo *f, void *buf, size_t nb_elems, size_t offset);
+
+/**
+ * Feed data from a FIFO into a user-provided callback.
+ *
+ * @param f the FIFO buffer
+ * @param write_cb Callback the data will be supplied to. May be called
+ *                 multiple times.
+ * @param opaque opaque user data to be provided to write_cb
+ * @param nb_elems Should point to the maximum number of elements that can be
+ *                 read. Will be updated to contain the total number of elements
+ *                 actually sent to the callback.
+ * @param offset number of initial elements to skip; offset + *nb_elems must not
+ *               be larger than av_fifo_can_read(f).
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ */
+int av_fifo_peek_to_cb(AVFifo *f, AVFifoCB write_cb, void *opaque,
+                       size_t *nb_elems, size_t offset);
+
+/**
+ * Discard the specified amount of data from an AVFifo.
+ * @param size number of elements to discard, MUST NOT be larger than
+ *             av_fifo_can_read(f)
+ */
+void av_fifo_drain2(AVFifo *f, size_t size);
+
+/*
+ * Empty the AVFifo.
+ * @param f AVFifo to reset
+ */
+void av_fifo_reset2(AVFifo *f);
+
+/**
+ * Free an AVFifo and reset pointer to NULL.
+ * @param f Pointer to an AVFifo to free. *f == NULL is allowed.
+ */
+void av_fifo_freep2(AVFifo **f);
+
+
+#if FF_API_FIFO_OLD_API
 typedef struct AVFifoBuffer {
     uint8_t *buffer;
     uint8_t *rptr, *wptr, *end;
@@ -38,7 +251,9 @@
  * Initialize an AVFifoBuffer.
  * @param size of FIFO
  * @return AVFifoBuffer or NULL in case of memory allocation failure
+ * @deprecated use av_fifo_alloc2()
  */
+attribute_deprecated
 AVFifoBuffer *av_fifo_alloc(unsigned int size);
 
 /**
@@ -46,25 +261,33 @@
  * @param nmemb number of elements
  * @param size  size of the single element
  * @return AVFifoBuffer or NULL in case of memory allocation failure
+ * @deprecated use av_fifo_alloc2()
  */
+attribute_deprecated
 AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size);
 
 /**
  * Free an AVFifoBuffer.
  * @param f AVFifoBuffer to free
+ * @deprecated use the AVFifo API with av_fifo_freep2()
  */
+attribute_deprecated
 void av_fifo_free(AVFifoBuffer *f);
 
 /**
  * Free an AVFifoBuffer and reset pointer to NULL.
  * @param f AVFifoBuffer to free
+ * @deprecated use the AVFifo API with av_fifo_freep2()
  */
+attribute_deprecated
 void av_fifo_freep(AVFifoBuffer **f);
 
 /**
  * Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.
  * @param f AVFifoBuffer to reset
+ * @deprecated use av_fifo_reset2() with the new AVFifo-API
  */
+attribute_deprecated
 void av_fifo_reset(AVFifoBuffer *f);
 
 /**
@@ -72,7 +295,9 @@
  * amount of data you can read from it.
  * @param f AVFifoBuffer to read from
  * @return size
+ * @deprecated use av_fifo_can_read() with the new AVFifo-API
  */
+attribute_deprecated
 int av_fifo_size(const AVFifoBuffer *f);
 
 /**
@@ -80,7 +305,9 @@
  * amount of data you can write into it.
  * @param f AVFifoBuffer to write into
  * @return size
+ * @deprecated use av_fifo_can_write() with the new AVFifo-API
  */
+attribute_deprecated
 int av_fifo_space(const AVFifoBuffer *f);
 
 /**
@@ -91,7 +318,13 @@
  * @param buf_size number of bytes to read
  * @param func generic read function
  * @param dest data destination
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,
+ *             av_fifo_peek_to_cb() otherwise
  */
+attribute_deprecated
 int av_fifo_generic_peek_at(AVFifoBuffer *f, void *dest, int offset, int buf_size, void (*func)(void*, void*, int));
 
 /**
@@ -101,7 +334,13 @@
  * @param buf_size number of bytes to read
  * @param func generic read function
  * @param dest data destination
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,
+ *             av_fifo_peek_to_cb() otherwise
  */
+attribute_deprecated
 int av_fifo_generic_peek(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int));
 
 /**
@@ -110,7 +349,13 @@
  * @param buf_size number of bytes to read
  * @param func generic read function
  * @param dest data destination
+ *
+ * @return a non-negative number on success, a negative error code on failure
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_read() when func == NULL,
+ *             av_fifo_read_to_cb() otherwise
  */
+attribute_deprecated
 int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int));
 
 /**
@@ -124,8 +369,12 @@
  * func must return the number of bytes written to dest_buf, or <= 0 to
  * indicate no more data available to write.
  * If func is NULL, src is interpreted as a simple byte array for source data.
- * @return the number of bytes written to the FIFO
+ * @return the number of bytes written to the FIFO or a negative error code on failure
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_write() when func == NULL,
+ *             av_fifo_write_from_cb() otherwise
  */
+attribute_deprecated
 int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int));
 
 /**
@@ -135,7 +384,11 @@
  * @param f AVFifoBuffer to resize
  * @param size new AVFifoBuffer size in bytes
  * @return <0 for failure, >=0 otherwise
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_grow2() to increase FIFO size,
+ *             decreasing FIFO size is not supported
  */
+attribute_deprecated
 int av_fifo_realloc2(AVFifoBuffer *f, unsigned int size);
 
 /**
@@ -146,16 +399,24 @@
  * @param f AVFifoBuffer to resize
  * @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()
  * @return <0 for failure, >=0 otherwise
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_grow2(); note that unlike
+ * this function it adds to the allocated size, rather than to the used size
  */
+attribute_deprecated
 int av_fifo_grow(AVFifoBuffer *f, unsigned int additional_space);
 
 /**
  * Read and discard the specified amount of data from an AVFifoBuffer.
  * @param f AVFifoBuffer to read from
  * @param size amount of data to read in bytes
+ *
+ * @deprecated use the new AVFifo-API with av_fifo_drain2()
  */
+attribute_deprecated
 void av_fifo_drain(AVFifoBuffer *f, int size);
 
+#if FF_API_FIFO_PEEK2
 /**
  * Return a pointer to the data stored in a FIFO buffer at a certain offset.
  * The FIFO buffer is not modified.
@@ -165,7 +426,9 @@
  *             than the used buffer size or the returned pointer will
  *             point outside to the buffer data.
  *             The used buffer size can be checked with av_fifo_size().
+ * @deprecated use the new AVFifo-API with av_fifo_peek() or av_fifo_peek_to_cb()
  */
+attribute_deprecated
 static inline uint8_t *av_fifo_peek2(const AVFifoBuffer *f, int offs)
 {
     uint8_t *ptr = f->rptr + offs;
@@ -175,5 +438,11 @@
         ptr = f->end - (f->buffer - ptr);
     return ptr;
 }
+#endif
+#endif
+
+/**
+ * @}
+ */
 
 #endif /* AVUTIL_FIFO_H */
diff -Naur a/media/ffvpx/libavutil/film_grain_params.h b/media/ffvpx/libavutil/film_grain_params.h
--- a/media/ffvpx/libavutil/film_grain_params.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/film_grain_params.h	2023-04-06 12:49:40.260395172 +0200
@@ -28,6 +28,11 @@
      * The union is valid when interpreted as AVFilmGrainAOMParams (codec.aom)
      */
     AV_FILM_GRAIN_PARAMS_AV1,
+
+    /**
+     * The union is valid when interpreted as AVFilmGrainH274Params (codec.h274)
+     */
+    AV_FILM_GRAIN_PARAMS_H274,
 };
 
 /**
@@ -118,6 +123,89 @@
 } AVFilmGrainAOMParams;
 
 /**
+ * This structure describes how to handle film grain synthesis for codecs using
+ * the ITU-T H.274 Versatile suplemental enhancement information message.
+ *
+ * @note The struct must be allocated as part of AVFilmGrainParams using
+ *       av_film_grain_params_alloc(). Its size is not a part of the public ABI.
+ */
+typedef struct AVFilmGrainH274Params {
+    /**
+     * Specifies the film grain simulation mode.
+     * 0 = Frequency filtering, 1 = Auto-regression
+     */
+    int model_id;
+
+    /**
+     * Specifies the bit depth used for the luma component.
+     */
+    int bit_depth_luma;
+
+    /**
+     * Specifies the bit depth used for the chroma components.
+     */
+    int bit_depth_chroma;
+
+    enum AVColorRange                  color_range;
+    enum AVColorPrimaries              color_primaries;
+    enum AVColorTransferCharacteristic color_trc;
+    enum AVColorSpace                  color_space;
+
+    /**
+     * Specifies the blending mode used to blend the simulated film grain
+     * with the decoded images.
+     *
+     * 0 = Additive, 1 = Multiplicative
+     */
+    int blending_mode_id;
+
+    /**
+     * Specifies a scale factor used in the film grain characterization equations.
+     */
+    int log2_scale_factor;
+
+    /**
+     * Indicates if the modelling of film grain for a given component is present.
+     */
+    int component_model_present[3 /* y, cb, cr */];
+
+    /**
+     * Specifies the number of intensity intervals for which a specific set of
+     * model values has been estimated, with a range of [1, 256].
+     */
+    uint16_t num_intensity_intervals[3 /* y, cb, cr */];
+
+    /**
+     * Specifies the number of model values present for each intensity interval
+     * in which the film grain has been modelled, with a range of [1, 6].
+     */
+    uint8_t num_model_values[3 /* y, cb, cr */];
+
+    /**
+     * Specifies the lower ounds of each intensity interval for whichthe set of
+     * model values applies for the component.
+     */
+    uint8_t intensity_interval_lower_bound[3 /* y, cb, cr */][256 /* intensity interval */];
+
+    /**
+     * Specifies the upper bound of each intensity interval for which the set of
+     * model values applies for the component.
+     */
+    uint8_t intensity_interval_upper_bound[3 /* y, cb, cr */][256 /* intensity interval */];
+
+    /**
+     * Specifies the model values for the component for each intensity interval.
+     * - When model_id == 0, the following applies:
+     *     For comp_model_value[y], the range of values is [0, 2^bit_depth_luma - 1]
+     *     For comp_model_value[cb..cr], the range of values is [0, 2^bit_depth_chroma - 1]
+     * - Otherwise, the following applies:
+     *     For comp_model_value[y], the range of values is [-2^(bit_depth_luma - 1), 2^(bit_depth_luma - 1) - 1]
+     *     For comp_model_value[cb..cr], the range of values is [-2^(bit_depth_chroma - 1), 2^(bit_depth_chroma - 1) - 1]
+     */
+    int16_t comp_model_value[3 /* y, cb, cr */][256 /* intensity interval */][6 /* model value */];
+} AVFilmGrainH274Params;
+
+/**
  * This structure describes how to handle film grain synthesis in video
  * for specific codecs. Must be present on every frame where film grain is
  * meant to be synthesised for correct presentation.
@@ -133,6 +221,9 @@
 
     /**
      * Seed to use for the synthesis process, if the codec allows for it.
+     *
+     * @note For H.264, this refers to `pic_offset` as defined in
+     *       SMPTE RDD 5-2006.
      */
     uint64_t seed;
 
@@ -143,6 +234,7 @@
      */
     union {
         AVFilmGrainAOMParams aom;
+        AVFilmGrainH274Params h274;
     } codec;
 } AVFilmGrainParams;
 
diff -Naur a/media/ffvpx/libavutil/fixed_dsp.c b/media/ffvpx/libavutil/fixed_dsp.c
--- a/media/ffvpx/libavutil/fixed_dsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/fixed_dsp.c	2023-04-06 12:50:06.976471255 +0200
@@ -45,6 +45,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "common.h"
 #include "fixed_dsp.h"
 
 static void vector_fmul_add_c(int *dst, const int *src0, const int *src1, const int *src2, int len){
@@ -134,7 +135,7 @@
     return (int)(p >> 31);
 }
 
-static void butterflies_fixed_c(int *v1s, int *v2, int len)
+static void butterflies_fixed_c(int *av_restrict v1s, int *av_restrict v2, int len)
 {
     int i;
     unsigned int *v1 = v1s;
@@ -161,8 +162,11 @@
     fdsp->butterflies_fixed = butterflies_fixed_c;
     fdsp->scalarproduct_fixed = scalarproduct_fixed_c;
 
-    if (ARCH_X86)
-        ff_fixed_dsp_init_x86(fdsp);
+#if ARCH_RISCV
+    ff_fixed_dsp_init_riscv(fdsp);
+#elif ARCH_X86
+    ff_fixed_dsp_init_x86(fdsp);
+#endif
 
     return fdsp;
 }
diff -Naur a/media/ffvpx/libavutil/fixed_dsp.h b/media/ffvpx/libavutil/fixed_dsp.h
--- a/media/ffvpx/libavutil/fixed_dsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/fixed_dsp.h	2023-04-06 12:50:06.976471255 +0200
@@ -49,8 +49,8 @@
 #define AVUTIL_FIXED_DSP_H
 
 #include <stdint.h>
+#include "config.h"
 #include "attributes.h"
-#include "common.h"
 #include "libavcodec/mathops.h"
 
 typedef struct AVFixedDSPContext {
@@ -161,6 +161,7 @@
  */
 AVFixedDSPContext * avpriv_alloc_fixed_dsp(int strict);
 
+void ff_fixed_dsp_init_riscv(AVFixedDSPContext *fdsp);
 void ff_fixed_dsp_init_x86(AVFixedDSPContext *fdsp);
 
 /**
diff -Naur a/media/ffvpx/libavutil/float_dsp.c b/media/ffvpx/libavutil/float_dsp.c
--- a/media/ffvpx/libavutil/float_dsp.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/float_dsp.c	2023-04-06 12:50:06.976471255 +0200
@@ -150,15 +150,18 @@
     fdsp->butterflies_float = butterflies_float_c;
     fdsp->scalarproduct_float = avpriv_scalarproduct_float_c;
 
-    if (ARCH_AARCH64)
-        ff_float_dsp_init_aarch64(fdsp);
-    if (ARCH_ARM)
-        ff_float_dsp_init_arm(fdsp);
-    if (ARCH_PPC)
-        ff_float_dsp_init_ppc(fdsp, bit_exact);
-    if (ARCH_X86)
-        ff_float_dsp_init_x86(fdsp);
-    if (ARCH_MIPS)
-        ff_float_dsp_init_mips(fdsp);
+#if ARCH_AARCH64
+    ff_float_dsp_init_aarch64(fdsp);
+#elif ARCH_ARM
+    ff_float_dsp_init_arm(fdsp);
+#elif ARCH_PPC
+    ff_float_dsp_init_ppc(fdsp, bit_exact);
+#elif ARCH_RISCV
+    ff_float_dsp_init_riscv(fdsp);
+#elif ARCH_X86
+    ff_float_dsp_init_x86(fdsp);
+#elif ARCH_MIPS
+    ff_float_dsp_init_mips(fdsp);
+#endif
     return fdsp;
 }
diff -Naur a/media/ffvpx/libavutil/float_dsp.h b/media/ffvpx/libavutil/float_dsp.h
--- a/media/ffvpx/libavutil/float_dsp.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/float_dsp.h	2023-04-06 12:50:06.976471255 +0200
@@ -205,6 +205,7 @@
 void ff_float_dsp_init_aarch64(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_arm(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int strict);
+void ff_float_dsp_init_riscv(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp);
 void ff_float_dsp_init_mips(AVFloatDSPContext *fdsp);
 
diff -Naur a/media/ffvpx/libavutil/frame.c b/media/ffvpx/libavutil/frame.c
--- a/media/ffvpx/libavutil/frame.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/frame.c	2023-04-06 12:50:24.493176583 +0200
@@ -20,6 +20,7 @@
 #include "avassert.h"
 #include "buffer.h"
 #include "common.h"
+#include "cpu.h"
 #include "dict.h"
 #include "frame.h"
 #include "imgutils.h"
@@ -27,133 +28,29 @@
 #include "samplefmt.h"
 #include "hwcontext.h"
 
-#if FF_API_FRAME_GET_SET
-MAKE_ACCESSORS(AVFrame, frame, int64_t, best_effort_timestamp)
-MAKE_ACCESSORS(AVFrame, frame, int64_t, pkt_duration)
-MAKE_ACCESSORS(AVFrame, frame, int64_t, pkt_pos)
-MAKE_ACCESSORS(AVFrame, frame, int64_t, channel_layout)
-MAKE_ACCESSORS(AVFrame, frame, int,     channels)
-MAKE_ACCESSORS(AVFrame, frame, int,     sample_rate)
-MAKE_ACCESSORS(AVFrame, frame, AVDictionary *, metadata)
-MAKE_ACCESSORS(AVFrame, frame, int,     decode_error_flags)
-MAKE_ACCESSORS(AVFrame, frame, int,     pkt_size)
-MAKE_ACCESSORS(AVFrame, frame, enum AVColorSpace, colorspace)
-MAKE_ACCESSORS(AVFrame, frame, enum AVColorRange, color_range)
-#endif
-
+#if FF_API_OLD_CHANNEL_LAYOUT
 #define CHECK_CHANNELS_CONSISTENCY(frame) \
     av_assert2(!(frame)->channel_layout || \
                (frame)->channels == \
                av_get_channel_layout_nb_channels((frame)->channel_layout))
-
-#if FF_API_FRAME_QP
-struct qp_properties {
-    int stride;
-    int type;
-};
-
-int av_frame_set_qp_table(AVFrame *f, AVBufferRef *buf, int stride, int qp_type)
-{
-    struct qp_properties *p;
-    AVFrameSideData *sd;
-    AVBufferRef *ref;
-
-FF_DISABLE_DEPRECATION_WARNINGS
-    av_buffer_unref(&f->qp_table_buf);
-
-    f->qp_table_buf = buf;
-    f->qscale_table = buf->data;
-    f->qstride      = stride;
-    f->qscale_type  = qp_type;
-FF_ENABLE_DEPRECATION_WARNINGS
-
-    av_frame_remove_side_data(f, AV_FRAME_DATA_QP_TABLE_PROPERTIES);
-    av_frame_remove_side_data(f, AV_FRAME_DATA_QP_TABLE_DATA);
-
-    ref = av_buffer_ref(buf);
-    if (!av_frame_new_side_data_from_buf(f, AV_FRAME_DATA_QP_TABLE_DATA, ref)) {
-        av_buffer_unref(&ref);
-        return AVERROR(ENOMEM);
-    }
-
-    sd = av_frame_new_side_data(f, AV_FRAME_DATA_QP_TABLE_PROPERTIES,
-                                sizeof(struct qp_properties));
-    if (!sd)
-        return AVERROR(ENOMEM);
-
-    p = (struct qp_properties *)sd->data;
-    p->stride = stride;
-    p->type = qp_type;
-
-    return 0;
-}
-
-int8_t *av_frame_get_qp_table(AVFrame *f, int *stride, int *type)
-{
-    AVBufferRef *buf = NULL;
-
-    *stride = 0;
-    *type   = 0;
-
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (f->qp_table_buf) {
-        *stride = f->qstride;
-        *type   = f->qscale_type;
-        buf     = f->qp_table_buf;
-FF_ENABLE_DEPRECATION_WARNINGS
-    } else {
-        AVFrameSideData *sd;
-        struct qp_properties *p;
-        sd = av_frame_get_side_data(f, AV_FRAME_DATA_QP_TABLE_PROPERTIES);
-        if (!sd)
-            return NULL;
-        p = (struct qp_properties *)sd->data;
-        sd = av_frame_get_side_data(f, AV_FRAME_DATA_QP_TABLE_DATA);
-        if (!sd)
-            return NULL;
-        *stride = p->stride;
-        *type   = p->type;
-        buf     = sd->buf;
-    }
-
-    return buf ? buf->data : NULL;
-}
 #endif
 
-const char *av_get_colorspace_name(enum AVColorSpace val)
-{
-    static const char * const name[] = {
-        [AVCOL_SPC_RGB]       = "GBR",
-        [AVCOL_SPC_BT709]     = "bt709",
-        [AVCOL_SPC_FCC]       = "fcc",
-        [AVCOL_SPC_BT470BG]   = "bt470bg",
-        [AVCOL_SPC_SMPTE170M] = "smpte170m",
-        [AVCOL_SPC_SMPTE240M] = "smpte240m",
-        [AVCOL_SPC_YCOCG]     = "YCgCo",
-    };
-    if ((unsigned)val >= FF_ARRAY_ELEMS(name))
-        return NULL;
-    return name[val];
-}
-
 static void get_frame_defaults(AVFrame *frame)
 {
-    if (frame->extended_data != frame->data)
-        av_freep(&frame->extended_data);
-
     memset(frame, 0, sizeof(*frame));
 
     frame->pts                   =
     frame->pkt_dts               = AV_NOPTS_VALUE;
-#if FF_API_PKT_PTS
+    frame->best_effort_timestamp = AV_NOPTS_VALUE;
+    frame->duration            = 0;
+#if FF_API_PKT_DURATION
 FF_DISABLE_DEPRECATION_WARNINGS
-    frame->pkt_pts               = AV_NOPTS_VALUE;
+    frame->pkt_duration        = 0;
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
-    frame->best_effort_timestamp = AV_NOPTS_VALUE;
-    frame->pkt_duration        = 0;
     frame->pkt_pos             = -1;
     frame->pkt_size            = -1;
+    frame->time_base           = (AVRational){ 0, 1 };
     frame->key_frame           = 1;
     frame->sample_aspect_ratio = (AVRational){ 0, 1 };
     frame->format              = -1; /* unknown */
@@ -189,12 +86,11 @@
 
 AVFrame *av_frame_alloc(void)
 {
-    AVFrame *frame = av_mallocz(sizeof(*frame));
+    AVFrame *frame = av_malloc(sizeof(*frame));
 
     if (!frame)
         return NULL;
 
-    frame->extended_data = NULL;
     get_frame_defaults(frame);
 
     return frame;
@@ -280,18 +176,27 @@
 
 static int get_audio_buffer(AVFrame *frame, int align)
 {
-    int channels;
     int planar   = av_sample_fmt_is_planar(frame->format);
-    int planes;
+    int channels, planes;
     int ret, i;
 
-    if (!frame->channels)
-        frame->channels = av_get_channel_layout_nb_channels(frame->channel_layout);
-
-    channels = frame->channels;
-    planes = planar ? channels : 1;
-
-    CHECK_CHANNELS_CONSISTENCY(frame);
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (!frame->ch_layout.nb_channels) {
+        if (frame->channel_layout) {
+            av_channel_layout_from_mask(&frame->ch_layout, frame->channel_layout);
+        } else {
+            frame->ch_layout.nb_channels = frame->channels;
+            frame->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+        }
+    }
+    frame->channels = frame->ch_layout.nb_channels;
+    frame->channel_layout = frame->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
+                            frame->ch_layout.u.mask : 0;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    channels = frame->ch_layout.nb_channels;
+    planes   = planar ? channels : 1;
     if (!frame->linesize[0]) {
         ret = av_samples_get_buffer_size(&frame->linesize[0], channels,
                                          frame->nb_samples, frame->format,
@@ -301,9 +206,9 @@
     }
 
     if (planes > AV_NUM_DATA_POINTERS) {
-        frame->extended_data = av_mallocz_array(planes,
+        frame->extended_data = av_calloc(planes,
                                           sizeof(*frame->extended_data));
-        frame->extended_buf  = av_mallocz_array((planes - AV_NUM_DATA_POINTERS),
+        frame->extended_buf  = av_calloc(planes - AV_NUM_DATA_POINTERS,
                                           sizeof(*frame->extended_buf));
         if (!frame->extended_data || !frame->extended_buf) {
             av_freep(&frame->extended_data);
@@ -339,10 +244,17 @@
     if (frame->format < 0)
         return AVERROR(EINVAL);
 
+FF_DISABLE_DEPRECATION_WARNINGS
     if (frame->width > 0 && frame->height > 0)
         return get_video_buffer(frame, align);
-    else if (frame->nb_samples > 0 && (frame->channel_layout || frame->channels > 0))
+    else if (frame->nb_samples > 0 &&
+             (av_channel_layout_check(&frame->ch_layout)
+#if FF_API_OLD_CHANNEL_LAYOUT
+              || frame->channel_layout || frame->channels > 0
+#endif
+             ))
         return get_audio_buffer(frame, align);
+FF_ENABLE_DEPRECATION_WARNINGS
 
     return AVERROR(EINVAL);
 }
@@ -359,26 +271,35 @@
     dst->crop_left              = src->crop_left;
     dst->crop_right             = src->crop_right;
     dst->pts                    = src->pts;
+    dst->duration               = src->duration;
     dst->repeat_pict            = src->repeat_pict;
     dst->interlaced_frame       = src->interlaced_frame;
     dst->top_field_first        = src->top_field_first;
     dst->palette_has_changed    = src->palette_has_changed;
     dst->sample_rate            = src->sample_rate;
     dst->opaque                 = src->opaque;
-#if FF_API_PKT_PTS
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->pkt_pts                = src->pkt_pts;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     dst->pkt_dts                = src->pkt_dts;
     dst->pkt_pos                = src->pkt_pos;
     dst->pkt_size               = src->pkt_size;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
     dst->pkt_duration           = src->pkt_duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    dst->time_base              = src->time_base;
+#if FF_API_REORDERED_OPAQUE
+FF_DISABLE_DEPRECATION_WARNINGS
     dst->reordered_opaque       = src->reordered_opaque;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     dst->quality                = src->quality;
     dst->best_effort_timestamp  = src->best_effort_timestamp;
+#if FF_API_FRAME_PICTURE_NUMBER
+FF_DISABLE_DEPRECATION_WARNINGS
     dst->coded_picture_number   = src->coded_picture_number;
     dst->display_picture_number = src->display_picture_number;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     dst->flags                  = src->flags;
     dst->decode_error_flags     = src->decode_error_flags;
     dst->color_primaries        = src->color_primaries;
@@ -389,12 +310,6 @@
 
     av_dict_copy(&dst->metadata, src->metadata, 0);
 
-#if FF_API_ERROR_FRAME
-FF_DISABLE_DEPRECATION_WARNINGS
-    memcpy(dst->error, src->error, sizeof(dst->error));
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     for (i = 0; i < src->nb_side_data; i++) {
         const AVFrameSideData *sd_src = src->side_data[i];
         AVFrameSideData *sd_dst;
@@ -421,20 +336,6 @@
         av_dict_copy(&sd_dst->metadata, sd_src->metadata, 0);
     }
 
-#if FF_API_FRAME_QP
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->qscale_table = NULL;
-    dst->qstride      = 0;
-    dst->qscale_type  = 0;
-    av_buffer_replace(&dst->qp_table_buf, src->qp_table_buf);
-    if (dst->qp_table_buf) {
-        dst->qscale_table = dst->qp_table_buf->data;
-        dst->qstride      = src->qstride;
-        dst->qscale_type  = src->qscale_type;
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     ret = av_buffer_replace(&dst->opaque_ref, src->opaque_ref);
     ret |= av_buffer_replace(&dst->private_ref, src->private_ref);
     return ret;
@@ -445,19 +346,44 @@
     int i, ret = 0;
 
     av_assert1(dst->width == 0 && dst->height == 0);
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     av_assert1(dst->channels == 0);
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    av_assert1(dst->ch_layout.nb_channels == 0 &&
+               dst->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);
 
     dst->format         = src->format;
     dst->width          = src->width;
     dst->height         = src->height;
+    dst->nb_samples     = src->nb_samples;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     dst->channels       = src->channels;
     dst->channel_layout = src->channel_layout;
-    dst->nb_samples     = src->nb_samples;
+    if (!av_channel_layout_check(&src->ch_layout)) {
+        if (src->channel_layout)
+            av_channel_layout_from_mask(&dst->ch_layout, src->channel_layout);
+        else {
+            dst->ch_layout.nb_channels = src->channels;
+            dst->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+        }
+    }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
 
     ret = frame_copy_props(dst, src, 0);
     if (ret < 0)
         goto fail;
 
+    // this check is needed only until FF_API_OLD_CHANNEL_LAYOUT is out
+    if (av_channel_layout_check(&src->ch_layout)) {
+        ret = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
+        if (ret < 0)
+            goto fail;
+    }
+
     /* duplicate the frame data if it's not refcounted */
     if (!src->buf[0]) {
         ret = av_frame_get_buffer(dst, 0);
@@ -468,7 +394,7 @@
         if (ret < 0)
             goto fail;
 
-        return ret;
+        return 0;
     }
 
     /* ref the buffers */
@@ -483,8 +409,8 @@
     }
 
     if (src->extended_buf) {
-        dst->extended_buf = av_mallocz_array(sizeof(*dst->extended_buf),
-                                       src->nb_extended_buf);
+        dst->extended_buf = av_calloc(src->nb_extended_buf,
+                                      sizeof(*dst->extended_buf));
         if (!dst->extended_buf) {
             ret = AVERROR(ENOMEM);
             goto fail;
@@ -510,13 +436,12 @@
 
     /* duplicate extended data */
     if (src->extended_data != src->data) {
-        int ch = src->channels;
+        int ch = dst->ch_layout.nb_channels;
 
         if (!ch) {
             ret = AVERROR(EINVAL);
             goto fail;
         }
-        CHECK_CHANNELS_CONSISTENCY(src);
 
         dst->extended_data = av_malloc_array(sizeof(*dst->extended_data), ch);
         if (!dst->extended_data) {
@@ -565,29 +490,34 @@
         av_buffer_unref(&frame->extended_buf[i]);
     av_freep(&frame->extended_buf);
     av_dict_free(&frame->metadata);
-#if FF_API_FRAME_QP
-FF_DISABLE_DEPRECATION_WARNINGS
-    av_buffer_unref(&frame->qp_table_buf);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     av_buffer_unref(&frame->hw_frames_ctx);
 
     av_buffer_unref(&frame->opaque_ref);
     av_buffer_unref(&frame->private_ref);
 
+    if (frame->extended_data != frame->data)
+        av_freep(&frame->extended_data);
+
+    av_channel_layout_uninit(&frame->ch_layout);
+
     get_frame_defaults(frame);
 }
 
 void av_frame_move_ref(AVFrame *dst, AVFrame *src)
 {
     av_assert1(dst->width == 0 && dst->height == 0);
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     av_assert1(dst->channels == 0);
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    av_assert1(dst->ch_layout.nb_channels == 0 &&
+               dst->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);
 
     *dst = *src;
     if (src->extended_data == src->data)
         dst->extended_data = dst->data;
-    memset(src, 0, sizeof(*src));
     get_frame_defaults(src);
 }
 
@@ -613,9 +543,6 @@
     AVFrame tmp;
     int ret;
 
-    if (!frame->buf[0])
-        return AVERROR(EINVAL);
-
     if (av_frame_is_writable(frame))
         return 0;
 
@@ -623,9 +550,18 @@
     tmp.format         = frame->format;
     tmp.width          = frame->width;
     tmp.height         = frame->height;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     tmp.channels       = frame->channels;
     tmp.channel_layout = frame->channel_layout;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     tmp.nb_samples     = frame->nb_samples;
+    ret = av_channel_layout_copy(&tmp.ch_layout, &frame->ch_layout);
+    if (ret < 0) {
+        av_frame_unref(&tmp);
+        return ret;
+    }
 
     if (frame->hw_frames_ctx)
         ret = av_hwframe_get_buffer(frame->hw_frames_ctx, &tmp, 0);
@@ -666,10 +602,18 @@
     int planes, i;
 
     if (frame->nb_samples) {
-        int channels = frame->channels;
+        int channels = frame->ch_layout.nb_channels;
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+        if (!channels) {
+            channels = frame->channels;
+            CHECK_CHANNELS_CONSISTENCY(frame);
+        }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
         if (!channels)
             return NULL;
-        CHECK_CHANNELS_CONSISTENCY(frame);
         planes = av_sample_fmt_is_planar(frame->format) ? channels : 1;
     } else
         planes = 4;
@@ -725,7 +669,7 @@
 
 AVFrameSideData *av_frame_new_side_data(AVFrame *frame,
                                         enum AVFrameSideDataType type,
-                                        buffer_size_t size)
+                                        size_t size)
 {
     AVFrameSideData *ret;
     AVBufferRef *buf = av_buffer_alloc(size);
@@ -775,16 +719,35 @@
 static int frame_copy_audio(AVFrame *dst, const AVFrame *src)
 {
     int planar   = av_sample_fmt_is_planar(dst->format);
-    int channels = dst->channels;
+    int channels = dst->ch_layout.nb_channels;
     int planes   = planar ? channels : 1;
     int i;
 
-    if (dst->nb_samples     != src->nb_samples ||
-        dst->channels       != src->channels ||
-        dst->channel_layout != src->channel_layout)
-        return AVERROR(EINVAL);
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (!channels || !src->ch_layout.nb_channels) {
+        if (dst->channels       != src->channels ||
+            dst->channel_layout != src->channel_layout)
+            return AVERROR(EINVAL);
+        CHECK_CHANNELS_CONSISTENCY(src);
+    }
+    if (!channels) {
+        channels = dst->channels;
+        planes = planar ? channels : 1;
+    }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
 
-    CHECK_CHANNELS_CONSISTENCY(src);
+    if (dst->nb_samples != src->nb_samples ||
+#if FF_API_OLD_CHANNEL_LAYOUT
+        (av_channel_layout_check(&dst->ch_layout) &&
+         av_channel_layout_check(&src->ch_layout) &&
+#endif
+        av_channel_layout_compare(&dst->ch_layout, &src->ch_layout))
+#if FF_API_OLD_CHANNEL_LAYOUT
+        )
+#endif
+        return AVERROR(EINVAL);
 
     for (i = 0; i < planes; i++)
         if (!dst->extended_data[i] || !src->extended_data[i])
@@ -801,10 +764,17 @@
     if (dst->format != src->format || dst->format < 0)
         return AVERROR(EINVAL);
 
+FF_DISABLE_DEPRECATION_WARNINGS
     if (dst->width > 0 && dst->height > 0)
         return frame_copy_video(dst, src);
-    else if (dst->nb_samples > 0 && dst->channels > 0)
+    else if (dst->nb_samples > 0 &&
+             (av_channel_layout_check(&dst->ch_layout)
+#if FF_API_OLD_CHANNEL_LAYOUT
+              || dst->channels > 0
+#endif
+            ))
         return frame_copy_audio(dst, src);
+FF_ENABLE_DEPRECATION_WARNINGS
 
     return AVERROR(EINVAL);
 }
@@ -843,15 +813,16 @@
     case AV_FRAME_DATA_S12M_TIMECODE:               return "SMPTE 12-1 timecode";
     case AV_FRAME_DATA_SPHERICAL:                   return "Spherical Mapping";
     case AV_FRAME_DATA_ICC_PROFILE:                 return "ICC profile";
-#if FF_API_FRAME_QP
-    case AV_FRAME_DATA_QP_TABLE_PROPERTIES:         return "QP table properties";
-    case AV_FRAME_DATA_QP_TABLE_DATA:               return "QP table data";
-#endif
     case AV_FRAME_DATA_DYNAMIC_HDR_PLUS: return "HDR Dynamic Metadata SMPTE2094-40 (HDR10+)";
+    case AV_FRAME_DATA_DYNAMIC_HDR_VIVID: return "HDR Dynamic Metadata CUVA 005.1 2021 (Vivid)";
     case AV_FRAME_DATA_REGIONS_OF_INTEREST: return "Regions Of Interest";
     case AV_FRAME_DATA_VIDEO_ENC_PARAMS:            return "Video encoding parameters";
     case AV_FRAME_DATA_SEI_UNREGISTERED:            return "H.26[45] User Data Unregistered SEI message";
     case AV_FRAME_DATA_FILM_GRAIN_PARAMS:           return "Film grain parameters";
+    case AV_FRAME_DATA_DETECTION_BBOXES:            return "Bounding boxes for object detection and classification";
+    case AV_FRAME_DATA_DOVI_RPU_BUFFER:             return "Dolby Vision RPU Data";
+    case AV_FRAME_DATA_DOVI_METADATA:               return "Dolby Vision Metadata";
+    case AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT: return "Ambient viewing environment";
     }
     return NULL;
 }
@@ -866,7 +837,7 @@
         int shift_x = (i == 1 || i == 2) ? desc->log2_chroma_w : 0;
         int shift_y = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;
 
-        if (desc->flags & (AV_PIX_FMT_FLAG_PAL | FF_PSEUDOPAL) && i == 1) {
+        if (desc->flags & AV_PIX_FMT_FLAG_PAL && i == 1) {
             offsets[i] = 0;
             break;
         }
diff -Naur a/media/ffvpx/libavutil/frame.h b/media/ffvpx/libavutil/frame.h
--- a/media/ffvpx/libavutil/frame.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/frame.h	2023-04-06 12:50:24.493176583 +0200
@@ -30,6 +30,7 @@
 
 #include "avutil.h"
 #include "buffer.h"
+#include "channel_layout.h"
 #include "dict.h"
 #include "rational.h"
 #include "samplefmt.h"
@@ -142,23 +143,6 @@
      */
     AV_FRAME_DATA_ICC_PROFILE,
 
-#if FF_API_FRAME_QP
-    /**
-     * Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA.
-     * The contents of this side data are undocumented and internal; use
-     * av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a
-     * meaningful way instead.
-     */
-    AV_FRAME_DATA_QP_TABLE_PROPERTIES,
-
-    /**
-     * Raw QP table data. Its format is described by
-     * AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and
-     * av_frame_get_qp_table() to access this instead.
-     */
-    AV_FRAME_DATA_QP_TABLE_DATA,
-#endif
-
     /**
      * Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t
      * where the first uint32_t describes how many (1-3) of the other timecodes are used.
@@ -198,6 +182,38 @@
      * Must be present for every frame which should have film grain applied.
      */
     AV_FRAME_DATA_FILM_GRAIN_PARAMS,
+
+    /**
+     * Bounding boxes for object detection and classification,
+     * as described by AVDetectionBBoxHeader.
+     */
+    AV_FRAME_DATA_DETECTION_BBOXES,
+
+    /**
+     * Dolby Vision RPU raw data, suitable for passing to x265
+     * or other libraries. Array of uint8_t, with NAL emulation
+     * bytes intact.
+     */
+    AV_FRAME_DATA_DOVI_RPU_BUFFER,
+
+    /**
+     * Parsed Dolby Vision metadata, suitable for passing to a software
+     * implementation. The payload is the AVDOVIMetadata struct defined in
+     * libavutil/dovi_meta.h.
+     */
+    AV_FRAME_DATA_DOVI_METADATA,
+
+    /**
+     * HDR Vivid dynamic metadata associated with a video frame. The payload is
+     * an AVDynamicHDRVivid type and contains information for color
+     * volume transform - CUVA 005.1-2021.
+     */
+    AV_FRAME_DATA_DYNAMIC_HDR_VIVID,
+
+    /**
+     * Ambient viewing environment metadata, as defined by H.274.
+     */
+    AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT,
 };
 
 enum AVActiveFormatDescription {
@@ -220,11 +236,7 @@
 typedef struct AVFrameSideData {
     enum AVFrameSideDataType type;
     uint8_t *data;
-#if FF_API_BUFFER_SIZE_T
-    int      size;
-#else
     size_t   size;
-#endif
     AVDictionary *metadata;
     AVBufferRef *buf;
 } AVFrameSideData;
@@ -319,21 +331,32 @@
 #define AV_NUM_DATA_POINTERS 8
     /**
      * pointer to the picture/channel planes.
-     * This might be different from the first allocated byte
+     * This might be different from the first allocated byte. For video,
+     * it could even point to the end of the image data.
+     *
+     * All pointers in data and extended_data must point into one of the
+     * AVBufferRef in buf or extended_buf.
      *
      * Some decoders access areas outside 0,0 - width,height, please
      * see avcodec_align_dimensions2(). Some filters and swscale can read
      * up to 16 bytes beyond the planes, if these filters are to be used,
      * then 16 extra bytes must be allocated.
      *
-     * NOTE: Except for hwaccel formats, pointers not needed by the format
-     * MUST be set to NULL.
+     * NOTE: Pointers not needed by the format MUST be set to NULL.
+     *
+     * @attention In case of video, the data[] pointers can point to the
+     * end of image data in order to reverse line order, when used in
+     * combination with negative values in the linesize[] array.
      */
     uint8_t *data[AV_NUM_DATA_POINTERS];
 
     /**
-     * For video, size in bytes of each picture line.
-     * For audio, size in bytes of each plane.
+     * For video, a positive or negative value, which is typically indicating
+     * the size in bytes of each picture line, but it can also be:
+     * - the negative byte size of lines for vertical flipping
+     *   (with data[n] pointing to the end of the data
+     * - a positive or negative multiple of the byte size as for accessing
+     *   even and odd fields of a frame (possibly flipped)
      *
      * For audio, only linesize[0] may be set. For planar audio, each channel
      * plane must be the same size.
@@ -345,6 +368,9 @@
      *
      * @note The linesize may be larger than the size of usable data -- there
      * may be extra padding present for performance reasons.
+     *
+     * @attention In case of video, line size values can be negative to achieve
+     * a vertically inverted iteration over image lines.
      */
     int linesize[AV_NUM_DATA_POINTERS];
 
@@ -410,15 +436,6 @@
      */
     int64_t pts;
 
-#if FF_API_PKT_PTS
-    /**
-     * PTS copied from the AVPacket that was decoded to produce this frame.
-     * @deprecated use the pts field instead
-     */
-    attribute_deprecated
-    int64_t pkt_pts;
-#endif
-
     /**
      * DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
      * This is also the Presentation time of this AVFrame calculated from
@@ -427,13 +444,25 @@
     int64_t pkt_dts;
 
     /**
+     * Time base for the timestamps in this frame.
+     * In the future, this field may be set on frames output by decoders or
+     * filters, but its value will be by default ignored on input to encoders
+     * or filters.
+     */
+    AVRational time_base;
+
+#if FF_API_FRAME_PICTURE_NUMBER
+    /**
      * picture number in bitstream order
      */
+    attribute_deprecated
     int coded_picture_number;
     /**
      * picture number in display order
      */
+    attribute_deprecated
     int display_picture_number;
+#endif
 
     /**
      * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
@@ -445,14 +474,6 @@
      */
     void *opaque;
 
-#if FF_API_ERROR_FRAME
-    /**
-     * @deprecated unused
-     */
-    attribute_deprecated
-    uint64_t error[AV_NUM_DATA_POINTERS];
-#endif
-
     /**
      * When decoding, this signals how much the picture must be delayed.
      * extra_delay = repeat_pict / (2*fps)
@@ -474,6 +495,7 @@
      */
     int palette_has_changed;
 
+#if FF_API_REORDERED_OPAQUE
     /**
      * reordered opaque 64 bits (generally an integer or a double precision float
      * PTS but can be anything).
@@ -481,24 +503,32 @@
      * that time,
      * the decoder reorders values as needed and sets AVFrame.reordered_opaque
      * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
+     *
+     * @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead
      */
+    attribute_deprecated
     int64_t reordered_opaque;
+#endif
 
     /**
      * Sample rate of the audio data.
      */
     int sample_rate;
 
+#if FF_API_OLD_CHANNEL_LAYOUT
     /**
      * Channel layout of the audio data.
+     * @deprecated use ch_layout instead
      */
+    attribute_deprecated
     uint64_t channel_layout;
+#endif
 
     /**
-     * AVBuffer references backing the data for this frame. If all elements of
-     * this array are NULL, then this frame is not reference counted. This array
-     * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
-     * also be non-NULL for all j < i.
+     * AVBuffer references backing the data for this frame. All the pointers in
+     * data and extended_data must point inside one of the buffers in buf or
+     * extended_buf. This array must be filled contiguously -- if buf[i] is
+     * non-NULL then buf[j] must also be non-NULL for all j < i.
      *
      * There may be at most one AVBuffer per data plane, so for video this array
      * always contains all the references. For planar audio with more than
@@ -588,13 +618,18 @@
      */
     int64_t pkt_pos;
 
+#if FF_API_PKT_DURATION
     /**
      * duration of the corresponding packet, expressed in
      * AVStream->time_base units, 0 if unknown.
      * - encoding: unused
      * - decoding: Read by user.
+     *
+     * @deprecated use duration instead
      */
+    attribute_deprecated
     int64_t pkt_duration;
+#endif
 
     /**
      * metadata.
@@ -616,12 +651,16 @@
 #define FF_DECODE_ERROR_CONCEALMENT_ACTIVE  4
 #define FF_DECODE_ERROR_DECODE_SLICES       8
 
+#if FF_API_OLD_CHANNEL_LAYOUT
     /**
      * number of audio channels, only used for audio.
      * - encoding: unused
      * - decoding: Read by user.
+     * @deprecated use ch_layout instead
      */
+    attribute_deprecated
     int channels;
+#endif
 
     /**
      * size of the corresponding packet containing the compressed
@@ -632,24 +671,6 @@
      */
     int pkt_size;
 
-#if FF_API_FRAME_QP
-    /**
-     * QP table
-     */
-    attribute_deprecated
-    int8_t *qscale_table;
-    /**
-     * QP store stride
-     */
-    attribute_deprecated
-    int qstride;
-
-    attribute_deprecated
-    int qscale_type;
-
-    attribute_deprecated
-    AVBufferRef *qp_table_buf;
-#endif
     /**
      * For hwaccel-format frames, this should be a reference to the
      * AVHWFramesContext describing the frame.
@@ -695,70 +716,18 @@
      * for the target frame's private_ref field.
      */
     AVBufferRef *private_ref;
-} AVFrame;
 
-#if FF_API_FRAME_GET_SET
-/**
- * Accessors for some AVFrame fields. These used to be provided for ABI
- * compatibility, and do not need to be used anymore.
- */
-attribute_deprecated
-int64_t av_frame_get_best_effort_timestamp(const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_best_effort_timestamp(AVFrame *frame, int64_t val);
-attribute_deprecated
-int64_t av_frame_get_pkt_duration         (const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_pkt_duration         (AVFrame *frame, int64_t val);
-attribute_deprecated
-int64_t av_frame_get_pkt_pos              (const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_pkt_pos              (AVFrame *frame, int64_t val);
-attribute_deprecated
-int64_t av_frame_get_channel_layout       (const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_channel_layout       (AVFrame *frame, int64_t val);
-attribute_deprecated
-int     av_frame_get_channels             (const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_channels             (AVFrame *frame, int     val);
-attribute_deprecated
-int     av_frame_get_sample_rate          (const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_sample_rate          (AVFrame *frame, int     val);
-attribute_deprecated
-AVDictionary *av_frame_get_metadata       (const AVFrame *frame);
-attribute_deprecated
-void          av_frame_set_metadata       (AVFrame *frame, AVDictionary *val);
-attribute_deprecated
-int     av_frame_get_decode_error_flags   (const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_decode_error_flags   (AVFrame *frame, int     val);
-attribute_deprecated
-int     av_frame_get_pkt_size(const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_pkt_size(AVFrame *frame, int val);
-#if FF_API_FRAME_QP
-attribute_deprecated
-int8_t *av_frame_get_qp_table(AVFrame *f, int *stride, int *type);
-attribute_deprecated
-int av_frame_set_qp_table(AVFrame *f, AVBufferRef *buf, int stride, int type);
-#endif
-attribute_deprecated
-enum AVColorSpace av_frame_get_colorspace(const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_colorspace(AVFrame *frame, enum AVColorSpace val);
-attribute_deprecated
-enum AVColorRange av_frame_get_color_range(const AVFrame *frame);
-attribute_deprecated
-void    av_frame_set_color_range(AVFrame *frame, enum AVColorRange val);
-#endif
+    /**
+     * Channel layout of the audio data.
+     */
+    AVChannelLayout ch_layout;
+
+    /**
+     * Duration of the frame, in the same units as pts. 0 if unknown.
+     */
+    int64_t duration;
+} AVFrame;
 
-/**
- * Get the name of a colorspace.
- * @return a static string identifying the colorspace; can be NULL.
- */
-const char *av_get_colorspace_name(enum AVColorSpace val);
 
 /**
  * Allocate an AVFrame and set its fields to default values.  The resulting
@@ -827,7 +796,7 @@
  * The following fields must be set on frame before calling this function:
  * - format (pixel format for video, sample format for audio)
  * - width and height for video
- * - nb_samples and channel_layout for audio
+ * - nb_samples and ch_layout for audio
  *
  * This function will fill AVFrame.data and AVFrame.buf arrays and, if
  * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
@@ -864,7 +833,8 @@
  * Ensure that the frame data is writable, avoiding data copy if possible.
  *
  * Do nothing if the frame is writable, allocate new buffers and copy the data
- * if it is not.
+ * if it is not. Non-refcounted frames behave as non-writable, i.e. a copy
+ * is always made.
  *
  * @return 0 on success, a negative AVERROR on error.
  *
@@ -899,6 +869,7 @@
 /**
  * Get the buffer reference a given data plane is stored in.
  *
+ * @param frame the frame to get the plane's buffer from
  * @param plane index of the data plane of interest in frame->extended_data.
  *
  * @return the buffer reference that contains the plane or NULL if the input
@@ -917,11 +888,7 @@
  */
 AVFrameSideData *av_frame_new_side_data(AVFrame *frame,
                                         enum AVFrameSideDataType type,
-#if FF_API_BUFFER_SIZE_T
-                                        int size);
-#else
                                         size_t size);
-#endif
 
 /**
  * Add a new side data to a frame from an existing AVBufferRef
diff -Naur a/media/ffvpx/libavutil/hwcontext.c b/media/ffvpx/libavutil/hwcontext.c
--- a/media/ffvpx/libavutil/hwcontext.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/hwcontext.c	2023-04-06 12:50:24.493176583 +0200
@@ -18,6 +18,7 @@
 
 #include "config.h"
 
+#include "avassert.h"
 #include "buffer.h"
 #include "common.h"
 #include "hwcontext.h"
@@ -308,7 +309,7 @@
     AVFrame **frames;
     int i, ret = 0;
 
-    frames = av_mallocz_array(ctx->initial_pool_size, sizeof(*frames));
+    frames = av_calloc(ctx->initial_pool_size, sizeof(*frames));
     if (!frames)
         return AVERROR(ENOMEM);
 
@@ -396,10 +397,14 @@
 
 static int transfer_data_alloc(AVFrame *dst, const AVFrame *src, int flags)
 {
-    AVHWFramesContext *ctx = (AVHWFramesContext*)src->hw_frames_ctx->data;
+    AVHWFramesContext *ctx;
     AVFrame *frame_tmp;
     int ret = 0;
 
+    if (!src->hw_frames_ctx)
+        return AVERROR(EINVAL);
+    ctx = (AVHWFramesContext*)src->hw_frames_ctx->data;
+
     frame_tmp = av_frame_alloc();
     if (!frame_tmp)
         return AVERROR(ENOMEM);
@@ -788,6 +793,8 @@
 
 int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
 {
+    AVBufferRef    *orig_dst_frames = dst->hw_frames_ctx;
+    enum AVPixelFormat orig_dst_fmt = dst->format;
     AVHWFramesContext *src_frames, *dst_frames;
     HWMapDescriptor *hwmap;
     int ret;
@@ -824,8 +831,10 @@
             src_frames->internal->hw_type->map_from) {
             ret = src_frames->internal->hw_type->map_from(src_frames,
                                                           dst, src, flags);
-            if (ret != AVERROR(ENOSYS))
+            if (ret >= 0)
                 return ret;
+            else if (ret != AVERROR(ENOSYS))
+                goto fail;
         }
     }
 
@@ -836,12 +845,30 @@
             dst_frames->internal->hw_type->map_to) {
             ret = dst_frames->internal->hw_type->map_to(dst_frames,
                                                         dst, src, flags);
-            if (ret != AVERROR(ENOSYS))
+            if (ret >= 0)
                 return ret;
+            else if (ret != AVERROR(ENOSYS))
+                goto fail;
         }
     }
 
     return AVERROR(ENOSYS);
+
+fail:
+    // if the caller provided dst frames context, it should be preserved
+    // by this function
+    av_assert0(orig_dst_frames == NULL ||
+               orig_dst_frames == dst->hw_frames_ctx);
+
+    // preserve user-provided dst frame fields, but clean
+    // anything we might have set
+    dst->hw_frames_ctx = NULL;
+    av_frame_unref(dst);
+
+    dst->hw_frames_ctx = orig_dst_frames;
+    dst->format        = orig_dst_fmt;
+
+    return ret;
 }
 
 int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx,
diff -Naur a/media/ffvpx/libavutil/hwcontext_drm.h b/media/ffvpx/libavutil/hwcontext_drm.h
--- a/media/ffvpx/libavutil/hwcontext_drm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/media/ffvpx/libavutil/hwcontext_drm.h	2023-04-06 12:49:40.260395172 +0200
@@ -0,0 +1,169 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_HWCONTEXT_DRM_H
+#define AVUTIL_HWCONTEXT_DRM_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+/**
+ * @file
+ * API-specific header for AV_HWDEVICE_TYPE_DRM.
+ *
+ * Internal frame allocation is not currently supported - all frames
+ * must be allocated by the user.  Thus AVHWFramesContext is always
+ * NULL, though this may change if support for frame allocation is
+ * added in future.
+ */
+
+enum {
+    /**
+     * The maximum number of layers/planes in a DRM frame.
+     */
+    AV_DRM_MAX_PLANES = 4
+};
+
+/**
+ * DRM object descriptor.
+ *
+ * Describes a single DRM object, addressing it as a PRIME file
+ * descriptor.
+ */
+typedef struct AVDRMObjectDescriptor {
+    /**
+     * DRM PRIME fd for the object.
+     */
+    int fd;
+    /**
+     * Total size of the object.
+     *
+     * (This includes any parts not which do not contain image data.)
+     */
+    size_t size;
+    /**
+     * Format modifier applied to the object (DRM_FORMAT_MOD_*).
+     *
+     * If the format modifier is unknown then this should be set to
+     * DRM_FORMAT_MOD_INVALID.
+     */
+    uint64_t format_modifier;
+} AVDRMObjectDescriptor;
+
+/**
+ * DRM plane descriptor.
+ *
+ * Describes a single plane of a layer, which is contained within
+ * a single object.
+ */
+typedef struct AVDRMPlaneDescriptor {
+    /**
+     * Index of the object containing this plane in the objects
+     * array of the enclosing frame descriptor.
+     */
+    int object_index;
+    /**
+     * Offset within that object of this plane.
+     */
+    ptrdiff_t offset;
+    /**
+     * Pitch (linesize) of this plane.
+     */
+    ptrdiff_t pitch;
+} AVDRMPlaneDescriptor;
+
+/**
+ * DRM layer descriptor.
+ *
+ * Describes a single layer within a frame.  This has the structure
+ * defined by its format, and will contain one or more planes.
+ */
+typedef struct AVDRMLayerDescriptor {
+    /**
+     * Format of the layer (DRM_FORMAT_*).
+     */
+    uint32_t format;
+    /**
+     * Number of planes in the layer.
+     *
+     * This must match the number of planes required by format.
+     */
+    int nb_planes;
+    /**
+     * Array of planes in this layer.
+     */
+    AVDRMPlaneDescriptor planes[AV_DRM_MAX_PLANES];
+} AVDRMLayerDescriptor;
+
+/**
+ * DRM frame descriptor.
+ *
+ * This is used as the data pointer for AV_PIX_FMT_DRM_PRIME frames.
+ * It is also used by user-allocated frame pools - allocating in
+ * AVHWFramesContext.pool must return AVBufferRefs which contain
+ * an object of this type.
+ *
+ * The fields of this structure should be set such it can be
+ * imported directly by EGL using the EGL_EXT_image_dma_buf_import
+ * and EGL_EXT_image_dma_buf_import_modifiers extensions.
+ * (Note that the exact layout of a particular format may vary between
+ * platforms - we only specify that the same platform should be able
+ * to import it.)
+ *
+ * The total number of planes must not exceed AV_DRM_MAX_PLANES, and
+ * the order of the planes by increasing layer index followed by
+ * increasing plane index must be the same as the order which would
+ * be used for the data pointers in the equivalent software format.
+ */
+typedef struct AVDRMFrameDescriptor {
+    /**
+     * Number of DRM objects making up this frame.
+     */
+    int nb_objects;
+    /**
+     * Array of objects making up the frame.
+     */
+    AVDRMObjectDescriptor objects[AV_DRM_MAX_PLANES];
+    /**
+     * Number of layers in the frame.
+     */
+    int nb_layers;
+    /**
+     * Array of layers in the frame.
+     */
+    AVDRMLayerDescriptor layers[AV_DRM_MAX_PLANES];
+} AVDRMFrameDescriptor;
+
+/**
+ * DRM device.
+ *
+ * Allocated as AVHWDeviceContext.hwctx.
+ */
+typedef struct AVDRMDeviceContext {
+    /**
+     * File descriptor of DRM device.
+     *
+     * This is used as the device to create frames on, and may also be
+     * used in some derivation and mapping operations.
+     *
+     * If no device is required, set to -1.
+     */
+    int fd;
+} AVDRMDeviceContext;
+
+#endif /* AVUTIL_HWCONTEXT_DRM_H */
diff -Naur a/media/ffvpx/libavutil/hwcontext.h b/media/ffvpx/libavutil/hwcontext.h
--- a/media/ffvpx/libavutil/hwcontext.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/hwcontext.h	2023-04-06 12:50:06.976471255 +0200
@@ -249,7 +249,7 @@
 /**
  * Iterate over supported device types.
  *
- * @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type
+ * @param prev AV_HWDEVICE_TYPE_NONE initially, then the previous type
  *             returned by this function in subsequent iterations.
  * @return The next usable device type from enum AVHWDeviceType, or
  *         AV_HWDEVICE_TYPE_NONE if there are no more.
@@ -571,6 +571,10 @@
  * possible with the given arguments and hwframe setup, while other return
  * values indicate that it failed somehow.
  *
+ * On failure, the destination frame will be left blank, except for the
+ * hw_frames_ctx/format fields thay may have been set by the caller - those will
+ * be preserved as they were.
+ *
  * @param dst Destination frame, to contain the mapping.
  * @param src Source frame, to be mapped.
  * @param flags Some combination of AV_HWFRAME_MAP_* flags.
@@ -587,6 +591,7 @@
  *
  * @param derived_frame_ctx  On success, a reference to the newly created
  *                           AVHWFramesContext.
+ * @param format             The AVPixelFormat for the derived context.
  * @param derived_device_ctx A reference to the device to create the new
  *                           AVHWFramesContext on.
  * @param source_frame_ctx   A reference to an existing AVHWFramesContext
diff -Naur a/media/ffvpx/libavutil/hwcontext_vaapi.c b/media/ffvpx/libavutil/hwcontext_vaapi.c
--- a/media/ffvpx/libavutil/hwcontext_vaapi.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/hwcontext_vaapi.c	2023-04-06 12:50:24.493176583 +0200
@@ -81,6 +81,9 @@
     unsigned int rt_format;
     // Whether vaDeriveImage works.
     int derive_works;
+    // Caches whether VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2 is unsupported for
+    // surface imports.
+    int prime_2_import_unsupported;
 } VAAPIFramesContext;
 
 typedef struct VAAPIMapping {
@@ -121,13 +124,22 @@
 #ifdef VA_FOURCC_Y210
     MAP(Y210, YUV422_10,  Y210, 0),
 #endif
+#ifdef VA_FOURCC_Y212
+    MAP(Y212, YUV422_12,  Y212, 0),
+#endif
     MAP(411P, YUV411,  YUV411P, 0),
     MAP(422V, YUV422,  YUV440P, 0),
     MAP(444P, YUV444,  YUV444P, 0),
+#ifdef VA_FOURCC_XYUV
+    MAP(XYUV, YUV444,  VUYX,    0),
+#endif
     MAP(Y800, YUV400,  GRAY8,   0),
 #ifdef VA_FOURCC_P010
     MAP(P010, YUV420_10BPP, P010, 0),
 #endif
+#ifdef VA_FOURCC_P012
+    MAP(P012, YUV420_12, P012, 0),
+#endif
     MAP(BGRA, RGB32,   BGRA, 0),
     MAP(BGRX, RGB32,   BGR0, 0),
     MAP(RGBA, RGB32,   RGBA, 0),
@@ -141,6 +153,16 @@
 #ifdef VA_FOURCC_X2R10G10B10
     MAP(X2R10G10B10, RGB32_10, X2RGB10, 0),
 #endif
+#ifdef VA_FOURCC_Y410
+    // libva doesn't include a fourcc for XV30 and the driver only declares
+    // support for Y410, so we must fudge the mapping here.
+    MAP(Y410, YUV444_10,  XV30, 0),
+#endif
+#ifdef VA_FOURCC_Y412
+    // libva doesn't include a fourcc for XV36 and the driver only declares
+    // support for Y412, so we must fudge the mapping here.
+    MAP(Y412, YUV444_12,  XV36, 0),
+#endif
 };
 #undef MAP
 
@@ -466,7 +488,7 @@
     }
 }
 
-static AVBufferRef *vaapi_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *vaapi_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext     *hwfc = opaque;
     VAAPIFramesContext     *ctx = hwfc->internal->priv;
@@ -991,11 +1013,15 @@
 } vaapi_drm_format_map[] = {
 #ifdef DRM_FORMAT_R8
     DRM_MAP(NV12, 2, DRM_FORMAT_R8,  DRM_FORMAT_RG88),
+    DRM_MAP(NV12, 2, DRM_FORMAT_R8,  DRM_FORMAT_GR88),
 #endif
     DRM_MAP(NV12, 1, DRM_FORMAT_NV12),
 #if defined(VA_FOURCC_P010) && defined(DRM_FORMAT_R16)
     DRM_MAP(P010, 2, DRM_FORMAT_R16, DRM_FORMAT_RG1616),
 #endif
+#if defined(VA_FOURCC_P012) && defined(DRM_FORMAT_R16)
+    DRM_MAP(P012, 2, DRM_FORMAT_R16, DRM_FORMAT_RG1616),
+#endif
     DRM_MAP(BGRA, 1, DRM_FORMAT_ARGB8888),
     DRM_MAP(BGRX, 1, DRM_FORMAT_XRGB8888),
     DRM_MAP(RGBA, 1, DRM_FORMAT_ABGR8888),
@@ -1006,6 +1032,15 @@
 #endif
     DRM_MAP(ARGB, 1, DRM_FORMAT_BGRA8888),
     DRM_MAP(XRGB, 1, DRM_FORMAT_BGRX8888),
+#if defined(VA_FOURCC_XYUV) && defined(DRM_FORMAT_XYUV8888)
+    DRM_MAP(XYUV, 1, DRM_FORMAT_XYUV8888),
+#endif
+#if defined(VA_FOURCC_Y412) && defined(DRM_FORMAT_XVYU2101010)
+    DRM_MAP(Y410, 1, DRM_FORMAT_XVYU2101010),
+#endif
+#if defined(VA_FOURCC_Y412) && defined(DRM_FORMAT_XVYU12_16161616)
+    DRM_MAP(Y412, 1, DRM_FORMAT_XVYU12_16161616),
+#endif
 };
 #undef DRM_MAP
 
@@ -1024,16 +1059,23 @@
 static int vaapi_map_from_drm(AVHWFramesContext *src_fc, AVFrame *dst,
                               const AVFrame *src, int flags)
 {
+#if VA_CHECK_VERSION(1, 1, 0)
+    VAAPIFramesContext     *src_vafc = src_fc->internal->priv;
+    int use_prime2;
+#else
+    int k;
+#endif
     AVHWFramesContext      *dst_fc =
         (AVHWFramesContext*)dst->hw_frames_ctx->data;
     AVVAAPIDeviceContext  *dst_dev = dst_fc->device_ctx->hwctx;
     const AVDRMFrameDescriptor *desc;
     const VAAPIFormatDescriptor *format_desc;
     VASurfaceID surface_id;
-    VAStatus vas;
+    VAStatus vas = VA_STATUS_SUCCESS;
     uint32_t va_fourcc;
-    int err, i, j, k;
+    int err, i, j;
 
+#if !VA_CHECK_VERSION(1, 1, 0)
     unsigned long buffer_handle;
     VASurfaceAttribExternalBuffers buffer_desc;
     VASurfaceAttrib attrs[2] = {
@@ -1050,6 +1092,7 @@
             .value.value.p = &buffer_desc,
         }
     };
+#endif
 
     desc = (AVDRMFrameDescriptor*)src->data[0];
 
@@ -1085,6 +1128,119 @@
     format_desc = vaapi_format_from_fourcc(va_fourcc);
     av_assert0(format_desc);
 
+#if VA_CHECK_VERSION(1, 1, 0)
+    use_prime2 = !src_vafc->prime_2_import_unsupported &&
+                 desc->objects[0].format_modifier != DRM_FORMAT_MOD_INVALID;
+    if (use_prime2) {
+        VADRMPRIMESurfaceDescriptor prime_desc;
+        VASurfaceAttrib prime_attrs[2] = {
+            {
+                .type  = VASurfaceAttribMemoryType,
+                .flags = VA_SURFACE_ATTRIB_SETTABLE,
+                .value.type    = VAGenericValueTypeInteger,
+                .value.value.i = VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2,
+            },
+            {
+                .type  = VASurfaceAttribExternalBufferDescriptor,
+                .flags = VA_SURFACE_ATTRIB_SETTABLE,
+                .value.type    = VAGenericValueTypePointer,
+                .value.value.p = &prime_desc,
+            }
+        };
+        prime_desc.fourcc = va_fourcc;
+        prime_desc.width = src_fc->width;
+        prime_desc.height = src_fc->height;
+        prime_desc.num_objects = desc->nb_objects;
+        for (i = 0; i < desc->nb_objects; ++i) {
+            prime_desc.objects[i].fd = desc->objects[i].fd;
+            prime_desc.objects[i].size = desc->objects[i].size;
+            prime_desc.objects[i].drm_format_modifier =
+                    desc->objects[i].format_modifier;
+        }
+
+        prime_desc.num_layers = desc->nb_layers;
+        for (i = 0; i < desc->nb_layers; ++i) {
+            prime_desc.layers[i].drm_format = desc->layers[i].format;
+            prime_desc.layers[i].num_planes = desc->layers[i].nb_planes;
+            for (j = 0; j < desc->layers[i].nb_planes; ++j) {
+                prime_desc.layers[i].object_index[j] =
+                        desc->layers[i].planes[j].object_index;
+                prime_desc.layers[i].offset[j] = desc->layers[i].planes[j].offset;
+                prime_desc.layers[i].pitch[j] = desc->layers[i].planes[j].pitch;
+            }
+
+            if (format_desc->chroma_planes_swapped &&
+                desc->layers[i].nb_planes == 3) {
+                FFSWAP(uint32_t, prime_desc.layers[i].pitch[1],
+                    prime_desc.layers[i].pitch[2]);
+                FFSWAP(uint32_t, prime_desc.layers[i].offset[1],
+                    prime_desc.layers[i].offset[2]);
+            }
+        }
+
+        /*
+         * We can query for PRIME_2 support with vaQuerySurfaceAttributes, but that
+         * that needs the config_id which we don't have here . Both Intel and
+         * Gallium seem to do the correct error checks, so lets just try the
+         * PRIME_2 import first.
+         */
+        vas = vaCreateSurfaces(dst_dev->display, format_desc->rt_format,
+                               src->width, src->height, &surface_id, 1,
+                               prime_attrs, FF_ARRAY_ELEMS(prime_attrs));
+        if (vas != VA_STATUS_SUCCESS)
+            src_vafc->prime_2_import_unsupported = 1;
+    }
+
+    if (!use_prime2 || vas != VA_STATUS_SUCCESS) {
+        int k;
+        unsigned long buffer_handle;
+        VASurfaceAttribExternalBuffers buffer_desc;
+        VASurfaceAttrib buffer_attrs[2] = {
+            {
+                .type  = VASurfaceAttribMemoryType,
+                .flags = VA_SURFACE_ATTRIB_SETTABLE,
+                .value.type    = VAGenericValueTypeInteger,
+                .value.value.i = VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME,
+            },
+            {
+                .type  = VASurfaceAttribExternalBufferDescriptor,
+                .flags = VA_SURFACE_ATTRIB_SETTABLE,
+                .value.type    = VAGenericValueTypePointer,
+                .value.value.p = &buffer_desc,
+            }
+        };
+
+        buffer_handle = desc->objects[0].fd;
+        buffer_desc.pixel_format = va_fourcc;
+        buffer_desc.width        = src_fc->width;
+        buffer_desc.height       = src_fc->height;
+        buffer_desc.data_size    = desc->objects[0].size;
+        buffer_desc.buffers      = &buffer_handle;
+        buffer_desc.num_buffers  = 1;
+        buffer_desc.flags        = 0;
+
+        k = 0;
+        for (i = 0; i < desc->nb_layers; i++) {
+            for (j = 0; j < desc->layers[i].nb_planes; j++) {
+                buffer_desc.pitches[k] = desc->layers[i].planes[j].pitch;
+                buffer_desc.offsets[k] = desc->layers[i].planes[j].offset;
+                ++k;
+            }
+        }
+        buffer_desc.num_planes = k;
+
+        if (format_desc->chroma_planes_swapped &&
+            buffer_desc.num_planes == 3) {
+            FFSWAP(uint32_t, buffer_desc.pitches[1], buffer_desc.pitches[2]);
+            FFSWAP(uint32_t, buffer_desc.offsets[1], buffer_desc.offsets[2]);
+        }
+
+        vas = vaCreateSurfaces(dst_dev->display, format_desc->rt_format,
+                               src->width, src->height,
+                               &surface_id, 1,
+                               buffer_attrs, FF_ARRAY_ELEMS(buffer_attrs));
+    }
+#else
     buffer_handle = desc->objects[0].fd;
     buffer_desc.pixel_format = va_fourcc;
     buffer_desc.width        = src_fc->width;
@@ -1114,6 +1270,7 @@
                            src->width, src->height,
                            &surface_id, 1,
                            attrs, FF_ARRAY_ELEMS(attrs));
+#endif
     if (vas != VA_STATUS_SUCCESS) {
         av_log(dst_fc, AV_LOG_ERROR, "Failed to create surface from DRM "
                "object: %d (%s).\n", vas, vaErrorStr(vas));
@@ -1164,8 +1321,17 @@
     surface_id = (VASurfaceID)(uintptr_t)src->data[3];
 
     export_flags = VA_EXPORT_SURFACE_SEPARATE_LAYERS;
-    if (flags & AV_HWFRAME_MAP_READ)
+    if (flags & AV_HWFRAME_MAP_READ) {
         export_flags |= VA_EXPORT_SURFACE_READ_ONLY;
+
+        vas = vaSyncSurface(hwctx->display, surface_id);
+        if (vas != VA_STATUS_SUCCESS) {
+            av_log(hwfc, AV_LOG_ERROR, "Failed to sync surface "
+                   "%#x: %d (%s).\n", surface_id, vas, vaErrorStr(vas));
+            return AVERROR(EIO);
+        }
+    }
+
     if (flags & AV_HWFRAME_MAP_WRITE)
         export_flags |= VA_EXPORT_SURFACE_WRITE_ONLY;
 
@@ -1356,7 +1522,7 @@
         goto fail_derived;
     }
 
-    av_log(hwfc, AV_LOG_DEBUG, "DRM PRIME fd is %ld.\n",
+    av_log(hwfc, AV_LOG_DEBUG, "DRM PRIME fd is %"PRIdPTR".\n",
            mapping->buffer_info.handle);
 
     mapping->drm_desc.nb_objects = 1;
@@ -1545,6 +1711,7 @@
             char path[64];
             int n, max_devices = 8;
 #if CONFIG_LIBDRM
+            drmVersion *info;
             const AVDictionaryEntry *kernel_driver;
             kernel_driver = av_dict_get(opts, "kernel_driver", NULL, 0);
 #endif
@@ -1558,9 +1725,15 @@
                     break;
                 }
 #if CONFIG_LIBDRM
+                info = drmGetVersion(priv->drm_fd);
+                if (!info) {
+                    av_log(ctx, AV_LOG_VERBOSE,
+                           "Failed to get DRM version for device %d.\n", n);
+                    close(priv->drm_fd);
+                    priv->drm_fd = -1;
+                    continue;
+                }
                 if (kernel_driver) {
-                    drmVersion *info;
-                    info = drmGetVersion(priv->drm_fd);
                     if (strcmp(kernel_driver->value, info->name)) {
                         av_log(ctx, AV_LOG_VERBOSE, "Ignoring device %d "
                                "with non-matching kernel driver (%s).\n",
@@ -1575,12 +1748,20 @@
                            "with matching kernel driver (%s).\n",
                            n, info->name);
                     drmFreeVersion(info);
-                } else
-#endif
-                {
-                    av_log(ctx, AV_LOG_VERBOSE, "Trying to use "
-                           "DRM render node for device %d.\n", n);
+                    break;
+                // drmGetVersion() ensures |info->name| is 0-terminated.
+                } else if (!strcmp(info->name, "vgem")) {
+                    av_log(ctx, AV_LOG_VERBOSE,
+                           "Skipping vgem node for device %d.\n", n);
+                    drmFreeVersion(info);
+                    close(priv->drm_fd);
+                    priv->drm_fd = -1;
+                    continue;
                 }
+                drmFreeVersion(info);
+#endif
+                av_log(ctx, AV_LOG_VERBOSE, "Trying to use "
+                       "DRM render node for device %d.\n", n);
                 break;
             }
             if (n >= max_devices)
diff -Naur a/media/ffvpx/libavutil/imgutils.c b/media/ffvpx/libavutil/imgutils.c
--- a/media/ffvpx/libavutil/imgutils.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/imgutils.c	2023-04-06 12:49:40.260395172 +0200
@@ -123,8 +123,7 @@
         return AVERROR(EINVAL);
     sizes[0] = linesizes[0] * (size_t)height;
 
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL ||
-        desc->flags & FF_PSEUDOPAL) {
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         sizes[1] = 256 * 4; /* palette is stored here as 256 32 bits words */
         return 0;
     }
@@ -166,6 +165,9 @@
         ret += sizes[i];
     }
 
+    if (!ptr)
+        return ret;
+
     data[0] = ptr;
     for (i = 1; i < 4 && sizes[i]; i++)
         data[i] = data[i - 1] + sizes[i - 1];
@@ -250,7 +252,7 @@
         av_free(buf);
         return ret;
     }
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL || (desc->flags & FF_PSEUDOPAL && pointers[1])) {
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         avpriv_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
         if (align < 4) {
             av_log(NULL, AV_LOG_ERROR, "Formats with a palette require a minimum alignment of 4\n");
@@ -259,8 +261,7 @@
         }
     }
 
-    if ((desc->flags & AV_PIX_FMT_FLAG_PAL ||
-         desc->flags & FF_PSEUDOPAL) && pointers[1] &&
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL && pointers[1] &&
         pointers[1] - pointers[0] > linesizes[0] * h) {
         /* zero-initialize the padding before the palette */
         memset(pointers[0] + linesizes[0] * h, 0,
@@ -355,9 +356,9 @@
     }
 }
 
-static void image_copy_plane_uc_from(uint8_t       *dst, ptrdiff_t dst_linesize,
-                                     const uint8_t *src, ptrdiff_t src_linesize,
-                                     ptrdiff_t bytewidth, int height)
+void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize,
+                                 const uint8_t *src, ptrdiff_t src_linesize,
+                                 ptrdiff_t bytewidth, int height)
 {
     int ret = -1;
 
@@ -388,8 +389,7 @@
     if (!desc || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)
         return;
 
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL ||
-        desc->flags & FF_PSEUDOPAL) {
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         copy_plane(dst_data[0], dst_linesizes[0],
                    src_data[0], src_linesizes[0],
                    width, height);
@@ -440,7 +440,7 @@
                            enum AVPixelFormat pix_fmt, int width, int height)
 {
     image_copy(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt,
-               width, height, image_copy_plane_uc_from);
+               width, height, av_image_copy_plane_uc_from);
 }
 
 int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],
@@ -478,10 +478,6 @@
     if (ret < 0)
         return ret;
 
-    // do not include palette for these pseudo-paletted formats
-    if (desc->flags & FF_PSEUDOPAL)
-        return FFALIGN(width, align) * height;
-
     ret = av_image_fill_linesizes(linesize, pix_fmt, width);
     if (ret < 0)
         return ret;
diff -Naur a/media/ffvpx/libavutil/imgutils.h b/media/ffvpx/libavutil/imgutils.h
--- a/media/ffvpx/libavutil/imgutils.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/imgutils.h	2023-04-06 12:50:06.976471255 +0200
@@ -27,8 +27,10 @@
  * @{
  */
 
-#include "avutil.h"
+#include <stddef.h>
+#include <stdint.h>
 #include "pixdesc.h"
+#include "pixfmt.h"
 #include "rational.h"
 
 /**
@@ -46,6 +48,7 @@
  * component in the plane with the max pixel step.
  * @param max_pixstep_comps an array which is filled with the component
  * for each plane which has the max pixel step. May be NULL.
+ * @param pixdesc the AVPixFmtDescriptor for the image, describing its format
  */
 void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4],
                                 const AVPixFmtDescriptor *pixdesc);
@@ -63,6 +66,8 @@
  * width width.
  *
  * @param linesizes array to be filled with the linesize for each plane
+ * @param pix_fmt the AVPixelFormat of the image
+ * @param width width of the image in pixels
  * @return >= 0 in case of success, a negative error code otherwise
  */
 int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width);
@@ -71,6 +76,8 @@
  * Fill plane sizes for an image with pixel format pix_fmt and height height.
  *
  * @param size the array to be filled with the size of each image plane
+ * @param pix_fmt the AVPixelFormat of the image
+ * @param height height of the image in pixels
  * @param linesizes the array containing the linesize for each
  *        plane, should be filled by av_image_fill_linesizes()
  * @return >= 0 in case of success, a negative error code otherwise
@@ -86,6 +93,8 @@
  * height height.
  *
  * @param data pointers array to be filled with the pointer for each image plane
+ * @param pix_fmt the AVPixelFormat of the image
+ * @param height height of the image in pixels
  * @param ptr the pointer to a buffer which will contain the image
  * @param linesizes the array containing the linesize for each
  * plane, should be filled by av_image_fill_linesizes()
@@ -101,6 +110,11 @@
  * The allocated image buffer has to be freed by using
  * av_freep(&pointers[0]).
  *
+ * @param pointers array to be filled with the pointer for each image plane
+ * @param linesizes the array filled with the linesize for each plane
+ * @param w width of the image in pixels
+ * @param h height of the image in pixels
+ * @param pix_fmt the AVPixelFormat of the image
  * @param align the value to use for buffer size alignment
  * @return the size in bytes required for the image buffer, a negative
  * error code in case of failure
@@ -117,18 +131,44 @@
  * bytewidth must be contained by both absolute values of dst_linesize
  * and src_linesize, otherwise the function behavior is undefined.
  *
+ * @param dst          destination plane to copy to
  * @param dst_linesize linesize for the image plane in dst
+ * @param src          source plane to copy from
  * @param src_linesize linesize for the image plane in src
+ * @param height       height (number of lines) of the plane
  */
 void av_image_copy_plane(uint8_t       *dst, int dst_linesize,
                          const uint8_t *src, int src_linesize,
                          int bytewidth, int height);
 
 /**
+ * Copy image data located in uncacheable (e.g. GPU mapped) memory. Where
+ * available, this function will use special functionality for reading from such
+ * memory, which may result in greatly improved performance compared to plain
+ * av_image_copy_plane().
+ *
+ * bytewidth must be contained by both absolute values of dst_linesize
+ * and src_linesize, otherwise the function behavior is undefined.
+ *
+ * @note The linesize parameters have the type ptrdiff_t here, while they are
+ *       int for av_image_copy_plane().
+ * @note On x86, the linesizes currently need to be aligned to the cacheline
+ *       size (i.e. 64) to get improved performance.
+ */
+void av_image_copy_plane_uc_from(uint8_t       *dst, ptrdiff_t dst_linesize,
+                                 const uint8_t *src, ptrdiff_t src_linesize,
+                                 ptrdiff_t bytewidth, int height);
+
+/**
  * Copy image in src_data to dst_data.
  *
+ * @param dst_data      destination image data buffer to copy to
  * @param dst_linesizes linesizes for the image in dst_data
+ * @param src_data      source image data buffer to copy from
  * @param src_linesizes linesizes for the image in src_data
+ * @param pix_fmt       the AVPixelFormat of the image
+ * @param width         width of the image in pixels
+ * @param height        height of the image in pixels
  */
 void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4],
                    const uint8_t *src_data[4], const int src_linesizes[4],
diff -Naur a/media/ffvpx/libavutil/integer.c b/media/ffvpx/libavutil/integer.c
--- a/media/ffvpx/libavutil/integer.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/integer.c	2023-04-06 12:50:06.976471255 +0200
@@ -25,9 +25,11 @@
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
-#include "common.h"
+#include <string.h>
+
 #include "integer.h"
 #include "avassert.h"
+#include "intmath.h"
 
 static const AVInteger zero_i;
 
@@ -101,8 +103,8 @@
     for(i=0; i<AV_INTEGER_SIZE; i++){
         unsigned int index= i + (s>>4);
         unsigned int v=0;
-        if(index+1<AV_INTEGER_SIZE) v = a.v[index+1]<<16;
-        if(index  <AV_INTEGER_SIZE) v+= a.v[index  ];
+        if (index + 1 < AV_INTEGER_SIZE) v  = a.v[index + 1] * (1U << 16);
+        if (index     < AV_INTEGER_SIZE) v |= a.v[index];
         out.v[i]= v >> (s&15);
     }
     return out;
@@ -156,11 +158,9 @@
 }
 
 int64_t av_i2int(AVInteger a){
-    int i;
-    int64_t out=(int8_t)a.v[AV_INTEGER_SIZE-1];
+    uint64_t out = a.v[3];
 
-    for(i= AV_INTEGER_SIZE-2; i>=0; i--){
-        out = (out<<16) + a.v[i];
-    }
+    for (int i = 2; i >= 0; i--)
+        out = (out << 16) | a.v[i];
     return out;
 }
diff -Naur a/media/ffvpx/libavutil/integer.h b/media/ffvpx/libavutil/integer.h
--- a/media/ffvpx/libavutil/integer.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/integer.h	2023-04-06 12:49:40.261395212 +0200
@@ -29,7 +29,7 @@
 #define AVUTIL_INTEGER_H
 
 #include <stdint.h>
-#include "common.h"
+#include "attributes.h"
 
 #define AV_INTEGER_SIZE 8
 
diff -Naur a/media/ffvpx/libavutil/internal.h b/media/ffvpx/libavutil/internal.h
--- a/media/ffvpx/libavutil/internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/internal.h	2023-04-06 12:50:06.976471255 +0200
@@ -37,14 +37,12 @@
 #include <stdint.h>
 #include <stddef.h>
 #include <assert.h>
+#include <stdio.h>
 #include "config.h"
 #include "attributes.h"
 #include "timer.h"
-#include "cpu.h"
-#include "dict.h"
 #include "macros.h"
 #include "pixfmt.h"
-#include "version.h"
 
 #if ARCH_X86
 #   include "x86/emms.h"
@@ -87,10 +85,6 @@
 
 #define FF_MEMORY_POISON 0x2a
 
-#define MAKE_ACCESSORS(str, name, type, field) \
-    type av_##name##_get_##field(const str *s) { return s->field; } \
-    void av_##name##_set_##field(str *s, type v) { s->field = v; }
-
 /* Check if the hard coded offset of a struct member still matches reality.
  * Induce a compilation failure if not.
  */
@@ -100,16 +94,20 @@
 
 
 #define FF_ALLOC_TYPED_ARRAY(p, nelem)  (p = av_malloc_array(nelem, sizeof(*p)))
-#define FF_ALLOCZ_TYPED_ARRAY(p, nelem) (p = av_mallocz_array(nelem, sizeof(*p)))
+#define FF_ALLOCZ_TYPED_ARRAY(p, nelem) (p = av_calloc(nelem, sizeof(*p)))
 
 #define FF_PTR_ADD(ptr, off) ((off) ? (ptr) + (off) : (ptr))
 
+/**
+ * Access a field in a structure by its offset.
+ */
+#define FF_FIELD_AT(type, off, obj) (*(type *)((char *)&(obj) + (off)))
+
 #include "libm.h"
 
 /**
  * Return NULL if CONFIG_SMALL is true, otherwise the argument
- * without modification. Used to disable the definition of strings
- * (for example AVCodec long_names).
+ * without modification. Used to disable the definition of strings.
  */
 #if CONFIG_SMALL
 #   define NULL_IF_CONFIG_SMALL(x) NULL
@@ -118,45 +116,6 @@
 #endif
 
 /**
- * Define a function with only the non-default version specified.
- *
- * On systems with ELF shared libraries, all symbols exported from
- * FFmpeg libraries are tagged with the name and major version of the
- * library to which they belong.  If a function is moved from one
- * library to another, a wrapper must be retained in the original
- * location to preserve binary compatibility.
- *
- * Functions defined with this macro will never be used to resolve
- * symbols by the build-time linker.
- *
- * @param type return type of function
- * @param name name of function
- * @param args argument list of function
- * @param ver  version tag to assign function
- */
-#if HAVE_SYMVER_ASM_LABEL
-#   define FF_SYMVER(type, name, args, ver)                     \
-    type ff_##name args __asm__ (EXTERN_PREFIX #name "@" ver);  \
-    type ff_##name args
-#elif HAVE_SYMVER_GNU_ASM
-#   define FF_SYMVER(type, name, args, ver)                             \
-    __asm__ (".symver ff_" #name "," EXTERN_PREFIX #name "@" ver);      \
-    type ff_##name args;                                                \
-    type ff_##name args
-#endif
-
-/**
- * Return NULL if a threading library has not been enabled.
- * Used to disable threading functions in AVCodec definitions
- * when not needed.
- */
-#if HAVE_THREADS
-#   define ONLY_IF_THREADS_ENABLED(x) x
-#else
-#   define ONLY_IF_THREADS_ENABLED(x) NULL
-#endif
-
-/**
  * Log a generic warning message about a missing feature.
  *
  * @param[in] avc a pointer to an arbitrary struct of which the first
@@ -184,8 +143,6 @@
 #pragma comment(linker, "/include:" EXTERN_PREFIX "avpriv_snprintf")
 #endif
 
-#define avpriv_open ff_open
-#define avpriv_tempfile ff_tempfile
 #define PTRDIFF_SPECIFIER "Id"
 #define SIZE_SPECIFIER "Iu"
 #else
@@ -199,6 +156,12 @@
 #   define ff_dlog(ctx, ...) do { if (0) av_log(ctx, AV_LOG_DEBUG, __VA_ARGS__); } while (0)
 #endif
 
+#ifdef TRACE
+#   define ff_tlog(ctx, ...) av_log(ctx, AV_LOG_TRACE, __VA_ARGS__)
+#else
+#   define ff_tlog(ctx, ...) do { } while(0)
+#endif
+
 // For debuging we use signed operations so overflows can be detected (by ubsan)
 // For production we use unsigned so there are no undefined operations
 #ifdef CHECKED
@@ -209,61 +172,6 @@
 #define SUINT32 uint32_t
 #endif
 
-/**
- * Clip and convert a double value into the long long amin-amax range.
- * This function is needed because conversion of floating point to integers when
- * it does not fit in the integer's representation does not necessarily saturate
- * correctly (usually converted to a cvttsd2si on x86) which saturates numbers
- * > INT64_MAX to INT64_MIN. The standard marks such conversions as undefined
- * behavior, allowing this sort of mathematically bogus conversions. This provides
- * a safe alternative that is slower obviously but assures safety and better
- * mathematical behavior.
- * @param a value to clip
- * @param amin minimum value of the clip range
- * @param amax maximum value of the clip range
- * @return clipped value
- */
-static av_always_inline av_const int64_t ff_rint64_clip(double a, int64_t amin, int64_t amax)
-{
-    int64_t res;
-#if defined(HAVE_AV_CONFIG_H) && defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
-    if (amin > amax) abort();
-#endif
-    // INT64_MAX+1,INT64_MIN are exactly representable as IEEE doubles
-    // do range checks first
-    if (a >=  9223372036854775808.0)
-        return amax;
-    if (a <= -9223372036854775808.0)
-        return amin;
-
-    // safe to call llrint and clip accordingly
-    res = llrint(a);
-    if (res > amax)
-        return amax;
-    if (res < amin)
-        return amin;
-    return res;
-}
-
-/**
- * A wrapper for open() setting O_CLOEXEC.
- */
-av_warn_unused_result
-int avpriv_open(const char *filename, int flags, ...);
-
-/**
- * Wrapper to work around the lack of mkstemp() on mingw.
- * Also, tries to create file in /tmp first, if possible.
- * *prefix can be a character constant; *filename will be allocated internally.
- * @return file descriptor of opened file (or negative value corresponding to an
- * AVERROR code on error)
- * and opened file name in **filename.
- * @note On very old libcs it is necessary to set a secure umask before
- *       calling this, av_tempfile() can't call umask itself as it is used in
- *       libraries and could interfere with the calling application.
- */
-int avpriv_tempfile(const char *prefix, char **filename, int log_offset, void *log_ctx);
-
 int avpriv_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt);
 
 static av_always_inline av_const int avpriv_mirror(int x, int w)
@@ -279,33 +187,4 @@
     return x;
 }
 
-void ff_check_pixfmt_descriptors(void);
-
-/**
- * Set a dictionary value to an ISO-8601 compliant timestamp string.
- *
- * @param dict pointer to a pointer to a dictionary struct. If *dict is NULL
- *             a dictionary struct is allocated and put in *dict.
- * @param key metadata key
- * @param timestamp unix timestamp in microseconds
- * @return <0 on error
- */
-int avpriv_dict_set_timestamp(AVDictionary **dict, const char *key, int64_t timestamp);
-
-// Helper macro for AV_PIX_FMT_FLAG_PSEUDOPAL deprecation. Code inside FFmpeg
-// should always use FF_PSEUDOPAL. Once the public API flag gets removed, all
-// code using it is dead code.
-#if FF_API_PSEUDOPAL
-#define FF_PSEUDOPAL AV_PIX_FMT_FLAG_PSEUDOPAL
-#else
-#define FF_PSEUDOPAL 0
-#endif
-
-// Temporary typedef to simplify porting all AVBufferRef users to size_t
-#if FF_API_BUFFER_SIZE_T
-typedef int buffer_size_t;
-#else
-typedef size_t buffer_size_t;
-#endif
-
 #endif /* AVUTIL_INTERNAL_H */
diff -Naur a/media/ffvpx/libavutil/intmath.h b/media/ffvpx/libavutil/intmath.h
--- a/media/ffvpx/libavutil/intmath.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/intmath.h	2023-04-06 12:50:06.976471255 +0200
@@ -28,8 +28,9 @@
 
 #if ARCH_ARM
 #   include "arm/intmath.h"
-#endif
-#if ARCH_X86
+#elif ARCH_RISCV
+#   include "riscv/intmath.h"
+#elif ARCH_X86
 #   include "x86/intmath.h"
 #endif
 
diff -Naur a/media/ffvpx/libavutil/lls.c b/media/ffvpx/libavutil/lls.c
--- a/media/ffvpx/libavutil/lls.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/lls.c	2023-04-06 12:49:40.261395212 +0200
@@ -28,9 +28,8 @@
 #include <math.h>
 #include <string.h>
 
+#include "config.h"
 #include "attributes.h"
-#include "internal.h"
-#include "version.h"
 #include "lls.h"
 
 static void update_lls(LLSModel *m, const double *var)
@@ -118,6 +117,7 @@
     m->indep_count = indep_count;
     m->update_lls = update_lls;
     m->evaluate_lls = evaluate_lls;
-    if (ARCH_X86)
-        ff_init_lls_x86(m);
+#if ARCH_X86
+    ff_init_lls_x86(m);
+#endif
 }
diff -Naur a/media/ffvpx/libavutil/lls.h b/media/ffvpx/libavutil/lls.h
--- a/media/ffvpx/libavutil/lls.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/lls.h	2023-04-06 12:49:40.261395212 +0200
@@ -25,7 +25,6 @@
 
 #include "macros.h"
 #include "mem_internal.h"
-#include "version.h"
 
 #define MAX_VARS 32
 #define MAX_VARS_ALIGN FFALIGN(MAX_VARS+1,4)
diff -Naur a/media/ffvpx/libavutil/log.c b/media/ffvpx/libavutil/log.c
--- a/media/ffvpx/libavutil/log.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/log.c	2023-04-06 12:49:40.261395212 +0200
@@ -32,9 +32,11 @@
 #if HAVE_IO_H
 #include <io.h>
 #endif
+#include <inttypes.h>
 #include <stdarg.h>
+#include <stdio.h>
 #include <stdlib.h>
-#include "avutil.h"
+#include <string.h>
 #include "bprint.h"
 #include "common.h"
 #include "internal.h"
diff -Naur a/media/ffvpx/libavutil/log.h b/media/ffvpx/libavutil/log.h
--- a/media/ffvpx/libavutil/log.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/log.h	2023-04-06 12:49:40.261395212 +0200
@@ -22,7 +22,6 @@
 #define AVUTIL_LOG_H
 
 #include <stdarg.h>
-#include "avutil.h"
 #include "attributes.h"
 #include "version.h"
 
@@ -108,24 +107,6 @@
     int parent_log_context_offset;
 
     /**
-     * Return next AVOptions-enabled child or NULL
-     */
-    void* (*child_next)(void *obj, void *prev);
-
-#if FF_API_CHILD_CLASS_NEXT
-    /**
-     * Return an AVClass corresponding to the next potential
-     * AVOptions-enabled child.
-     *
-     * The difference between child_next and this is that
-     * child_next iterates over _already existing_ objects, while
-     * child_class_next iterates over _all possible_ children.
-     */
-    attribute_deprecated
-    const struct AVClass* (*child_class_next)(const struct AVClass *prev);
-#endif
-
-    /**
      * Category used for visualization (like color)
      * This is only set if the category is equal for all objects using this class.
      * available since version (51 << 16 | 56 << 8 | 100)
@@ -145,6 +126,11 @@
     int (*query_ranges)(struct AVOptionRanges **, void *obj, const char *key, int flags);
 
     /**
+     * Return next AVOptions-enabled child or NULL
+     */
+    void* (*child_next)(void *obj, void *prev);
+
+    /**
      * Iterate over the AVClasses corresponding to potential AVOptions-enabled
      * children.
      *
diff -Naur a/media/ffvpx/libavutil/macros.h b/media/ffvpx/libavutil/macros.h
--- a/media/ffvpx/libavutil/macros.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/macros.h	2023-04-06 12:49:40.261395212 +0200
@@ -25,6 +25,36 @@
 #ifndef AVUTIL_MACROS_H
 #define AVUTIL_MACROS_H
 
+#include "libavutil/avconfig.h"
+
+#if AV_HAVE_BIGENDIAN
+#   define AV_NE(be, le) (be)
+#else
+#   define AV_NE(be, le) (le)
+#endif
+
+/**
+ * Comparator.
+ * For two numerical expressions x and y, gives 1 if x > y, -1 if x < y, and 0
+ * if x == y. This is useful for instance in a qsort comparator callback.
+ * Furthermore, compilers are able to optimize this to branchless code, and
+ * there is no risk of overflow with signed types.
+ * As with many macros, this evaluates its argument multiple times, it thus
+ * must not have a side-effect.
+ */
+#define FFDIFFSIGN(x,y) (((x)>(y)) - ((x)<(y)))
+
+#define FFMAX(a,b) ((a) > (b) ? (a) : (b))
+#define FFMAX3(a,b,c) FFMAX(FFMAX(a,b),c)
+#define FFMIN(a,b) ((a) > (b) ? (b) : (a))
+#define FFMIN3(a,b,c) FFMIN(FFMIN(a,b),c)
+
+#define FFSWAP(type,a,b) do{type SWAP_tmp= b; b= a; a= SWAP_tmp;}while(0)
+#define FF_ARRAY_ELEMS(a) (sizeof(a) / sizeof((a)[0]))
+
+#define MKTAG(a,b,c,d)   ((a) | ((b) << 8) | ((c) << 16) | ((unsigned)(d) << 24))
+#define MKBETAG(a,b,c,d) ((d) | ((c) << 8) | ((b) << 16) | ((unsigned)(a) << 24))
+
 /**
  * @addtogroup preproc_misc Preprocessor String Macros
  *
diff -Naur a/media/ffvpx/libavutil/mathematics.c b/media/ffvpx/libavutil/mathematics.c
--- a/media/ffvpx/libavutil/mathematics.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/mathematics.c	2023-04-06 12:49:40.261395212 +0200
@@ -26,11 +26,11 @@
 #include <stdint.h>
 #include <limits.h>
 
+#include "avutil.h"
 #include "mathematics.h"
 #include "libavutil/intmath.h"
 #include "libavutil/common.h"
 #include "avassert.h"
-#include "version.h"
 
 /* Stein's binary GCD algorithm:
  * https://en.wikipedia.org/wiki/Binary_GCD_algorithm */
diff -Naur a/media/ffvpx/libavutil/mathematics.h b/media/ffvpx/libavutil/mathematics.h
--- a/media/ffvpx/libavutil/mathematics.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/mathematics.h	2023-04-06 12:50:06.976471255 +0200
@@ -111,7 +111,8 @@
 /**
  * Compute the greatest common divisor of two integer operands.
  *
- * @param a,b Operands
+ * @param a Operand
+ * @param b Operand
  * @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
  * if a == 0 and b == 0, returns 0.
  */
@@ -186,7 +187,8 @@
  * av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
  * @endcode
  *
- * @param a,b Operands
+ * @param a Operand
+ * @param b Operand
  * @param mod Divisor; must be a power of 2
  * @return
  *         - a negative value if `a % mod < b % mod`
diff -Naur a/media/ffvpx/libavutil/mem.c b/media/ffvpx/libavutil/mem.c
--- a/media/ffvpx/libavutil/mem.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/mem.c	2023-04-06 12:50:24.494176623 +0200
@@ -31,16 +31,19 @@
 #include <limits.h>
 #include <stdint.h>
 #include <stdlib.h>
+#include <stdatomic.h>
 #include <string.h>
 #if HAVE_MALLOC_H
 #include <malloc.h>
 #endif
 
+#include "attributes.h"
 #include "avassert.h"
-#include "avutil.h"
-#include "common.h"
 #include "dynarray.h"
+#include "error.h"
+#include "internal.h"
 #include "intreadwrite.h"
+#include "macros.h"
 #include "mem.h"
 
 #ifdef MALLOC_PREFIX
@@ -59,8 +62,6 @@
 
 #endif /* MALLOC_PREFIX */
 
-#include "mem_internal.h"
-
 #define ALIGN (HAVE_AVX512 ? 64 : (HAVE_AVX ? 32 : 16))
 
 /* NOTE: if you want to override these functions with your own
@@ -68,17 +69,35 @@
  * dynamic libraries and remove -Wl,-Bsymbolic from the linker flags.
  * Note that this will cost performance. */
 
-static size_t max_alloc_size= INT_MAX;
+static atomic_size_t max_alloc_size = ATOMIC_VAR_INIT(INT_MAX);
 
 void av_max_alloc(size_t max){
-    max_alloc_size = max;
+    atomic_store_explicit(&max_alloc_size, max, memory_order_relaxed);
+}
+
+static int size_mult(size_t a, size_t b, size_t *r)
+{
+    size_t t;
+
+#if (!defined(__INTEL_COMPILER) && AV_GCC_VERSION_AT_LEAST(5,1)) || AV_HAS_BUILTIN(__builtin_mul_overflow)
+    if (__builtin_mul_overflow(a, b, &t))
+        return AVERROR(EINVAL);
+#else
+    t = a * b;
+    /* Hack inspired from glibc: don't try the division if nelem and elsize
+     * are both less than sqrt(SIZE_MAX). */
+    if ((a | b) >= ((size_t)1 << (sizeof(size_t) * 4)) && a && t / a != b)
+        return AVERROR(EINVAL);
+#endif
+    *r = t;
+    return 0;
 }
 
 void *av_malloc(size_t size)
 {
     void *ptr = NULL;
 
-    if (size > max_alloc_size)
+    if (size > atomic_load_explicit(&max_alloc_size, memory_order_relaxed))
         return NULL;
 
 #if HAVE_POSIX_MEMALIGN
@@ -133,14 +152,20 @@
 
 void *av_realloc(void *ptr, size_t size)
 {
-    if (size > max_alloc_size)
+    void *ret;
+    if (size > atomic_load_explicit(&max_alloc_size, memory_order_relaxed))
         return NULL;
 
 #if HAVE_ALIGNED_MALLOC
-    return _aligned_realloc(ptr, size + !size, ALIGN);
+    ret = _aligned_realloc(ptr, size + !size, ALIGN);
 #else
-    return realloc(ptr, size + !size);
+    ret = realloc(ptr, size + !size);
+#endif
+#if CONFIG_MEMORY_POISONING
+    if (ret && !ptr)
+        memset(ret, FF_MEMORY_POISON, size);
 #endif
+    return ret;
 }
 
 void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
@@ -148,7 +173,7 @@
     size_t size;
     void *r;
 
-    if (av_size_mult(elsize, nelem, &size)) {
+    if (size_mult(elsize, nelem, &size)) {
         av_free(ptr);
         return NULL;
     }
@@ -182,23 +207,15 @@
 void *av_malloc_array(size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_malloc(result);
 }
 
-void *av_mallocz_array(size_t nmemb, size_t size)
-{
-    size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
-        return NULL;
-    return av_mallocz(result);
-}
-
 void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_realloc(ptr, result);
 }
@@ -245,7 +262,7 @@
 void *av_calloc(size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_mallocz(result);
 }
@@ -477,15 +494,21 @@
 
 void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
 {
+    size_t max_size;
+
     if (min_size <= *size)
         return ptr;
 
-    if (min_size > max_alloc_size) {
+    max_size = atomic_load_explicit(&max_alloc_size, memory_order_relaxed);
+    /* *size is an unsigned, so the real maximum is <= UINT_MAX. */
+    max_size = FFMIN(max_size, UINT_MAX);
+
+    if (min_size > max_size) {
         *size = 0;
         return NULL;
     }
 
-    min_size = FFMIN(max_alloc_size, FFMAX(min_size + min_size / 16 + 32, min_size));
+    min_size = FFMIN(max_size, FFMAX(min_size + min_size / 16 + 32, min_size));
 
     ptr = av_realloc(ptr, min_size);
     /* we could set this to the unmodified min_size but this is safer
@@ -499,12 +522,47 @@
     return ptr;
 }
 
+static inline void fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)
+{
+    size_t max_size;
+    void *val;
+
+    memcpy(&val, ptr, sizeof(val));
+    if (min_size <= *size) {
+        av_assert0(val || !min_size);
+        return;
+    }
+
+    max_size = atomic_load_explicit(&max_alloc_size, memory_order_relaxed);
+    /* *size is an unsigned, so the real maximum is <= UINT_MAX. */
+    max_size = FFMIN(max_size, UINT_MAX);
+
+    if (min_size > max_size) {
+        av_freep(ptr);
+        *size = 0;
+        return;
+    }
+    min_size = FFMIN(max_size, FFMAX(min_size + min_size / 16 + 32, min_size));
+    av_freep(ptr);
+    val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);
+    memcpy(ptr, &val, sizeof(val));
+    if (!val)
+        min_size = 0;
+    *size = min_size;
+    return;
+}
+
 void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
 {
-    ff_fast_malloc(ptr, size, min_size, 0);
+    fast_malloc(ptr, size, min_size, 0);
 }
 
 void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
 {
-    ff_fast_malloc(ptr, size, min_size, 1);
+    fast_malloc(ptr, size, min_size, 1);
+}
+
+int av_size_mult(size_t a, size_t b, size_t *r)
+{
+    return size_mult(a, b, r);
 }
diff -Naur a/media/ffvpx/libavutil/mem.h b/media/ffvpx/libavutil/mem.h
--- a/media/ffvpx/libavutil/mem.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/mem.h	2023-04-06 12:50:24.494176623 +0200
@@ -31,7 +31,6 @@
 #include <stdint.h>
 
 #include "attributes.h"
-#include "error.h"
 #include "avutil.h"
 #include "version.h"
 
@@ -52,86 +51,6 @@
  * @{
  */
 
-#if FF_API_DECLARE_ALIGNED
-/**
- *
- * @defgroup lavu_mem_macros Alignment Macros
- * Helper macros for declaring aligned variables.
- * @{
- */
-
-/**
- * @def DECLARE_ALIGNED(n,t,v)
- * Declare a variable that is aligned in memory.
- *
- * @code{.c}
- * DECLARE_ALIGNED(16, uint16_t, aligned_int) = 42;
- * DECLARE_ALIGNED(32, uint8_t, aligned_array)[128];
- *
- * // The default-alignment equivalent would be
- * uint16_t aligned_int = 42;
- * uint8_t aligned_array[128];
- * @endcode
- *
- * @param n Minimum alignment in bytes
- * @param t Type of the variable (or array element)
- * @param v Name of the variable
- */
-
-/**
- * @def DECLARE_ASM_ALIGNED(n,t,v)
- * Declare an aligned variable appropriate for use in inline assembly code.
- *
- * @code{.c}
- * DECLARE_ASM_ALIGNED(16, uint64_t, pw_08) = UINT64_C(0x0008000800080008);
- * @endcode
- *
- * @param n Minimum alignment in bytes
- * @param t Type of the variable (or array element)
- * @param v Name of the variable
- */
-
-/**
- * @def DECLARE_ASM_CONST(n,t,v)
- * Declare a static constant aligned variable appropriate for use in inline
- * assembly code.
- *
- * @code{.c}
- * DECLARE_ASM_CONST(16, uint64_t, pw_08) = UINT64_C(0x0008000800080008);
- * @endcode
- *
- * @param n Minimum alignment in bytes
- * @param t Type of the variable (or array element)
- * @param v Name of the variable
- */
-
-#if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 1110 || defined(__SUNPRO_C)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
-    #define DECLARE_ASM_ALIGNED(n,t,v)  t __attribute__ ((aligned (n))) v
-    #define DECLARE_ASM_CONST(n,t,v)    const t __attribute__ ((aligned (n))) v
-#elif defined(__DJGPP__)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (FFMIN(n, 16)))) v
-    #define DECLARE_ASM_ALIGNED(n,t,v)  t av_used __attribute__ ((aligned (FFMIN(n, 16)))) v
-    #define DECLARE_ASM_CONST(n,t,v)    static const t av_used __attribute__ ((aligned (FFMIN(n, 16)))) v
-#elif defined(__GNUC__) || defined(__clang__)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
-    #define DECLARE_ASM_ALIGNED(n,t,v)  t av_used __attribute__ ((aligned (n))) v
-    #define DECLARE_ASM_CONST(n,t,v)    static const t av_used __attribute__ ((aligned (n))) v
-#elif defined(_MSC_VER)
-    #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
-    #define DECLARE_ASM_ALIGNED(n,t,v)  __declspec(align(n)) t v
-    #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
-#else
-    #define DECLARE_ALIGNED(n,t,v)      t v
-    #define DECLARE_ASM_ALIGNED(n,t,v)  t v
-    #define DECLARE_ASM_CONST(n,t,v)    static const t v
-#endif
-
-/**
- * @}
- */
-#endif
-
 /**
  * @defgroup lavu_mem_attrs Function Attributes
  * Function attributes applicable to memory handling functions.
@@ -238,20 +157,12 @@
  * @see av_mallocz()
  * @see av_malloc_array()
  */
-av_alloc_size(1, 2) void *av_mallocz_array(size_t nmemb, size_t size);
-
-/**
- * Non-inlined equivalent of av_mallocz_array().
- *
- * Created for symmetry with the calloc() C function.
- */
-void *av_calloc(size_t nmemb, size_t size) av_malloc_attrib;
+void *av_calloc(size_t nmemb, size_t size) av_malloc_attrib av_alloc_size(1, 2);
 
 /**
  * Allocate, reallocate, or free a block of memory.
  *
- * If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
- * zero, free the memory block pointed to by `ptr`. Otherwise, expand or
+ * If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or
  * shrink that block of memory according to `size`.
  *
  * @param ptr  Pointer to a memory block already allocated with
@@ -260,10 +171,11 @@
  *             reallocated
  *
  * @return Pointer to a newly-reallocated block or `NULL` if the block
- *         cannot be reallocated or the function is used to free the memory block
+ *         cannot be reallocated
  *
  * @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
- *          correctly aligned.
+ *          correctly aligned. The returned pointer must be freed after even
+ *          if size is zero.
  * @see av_fast_realloc()
  * @see av_reallocp()
  */
@@ -311,8 +223,7 @@
 /**
  * Allocate, reallocate, or free an array.
  *
- * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If
- * `nmemb` is zero, free the memory block pointed to by `ptr`.
+ * If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.
  *
  * @param ptr   Pointer to a memory block already allocated with
  *              av_realloc() or `NULL`
@@ -320,19 +231,19 @@
  * @param size  Size of the single element of the array
  *
  * @return Pointer to a newly-reallocated block or NULL if the block
- *         cannot be reallocated or the function is used to free the memory block
+ *         cannot be reallocated
  *
  * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
- *          correctly aligned.
+ *          correctly aligned. The returned pointer must be freed after even if
+ *          nmemb is zero.
  * @see av_reallocp_array()
  */
 av_alloc_size(2, 3) void *av_realloc_array(void *ptr, size_t nmemb, size_t size);
 
 /**
- * Allocate, reallocate, or free an array through a pointer to a pointer.
+ * Allocate, reallocate an array through a pointer to a pointer.
  *
- * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is
- * zero, free the memory block pointed to by `*ptr`.
+ * If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.
  *
  * @param[in,out] ptr   Pointer to a pointer to a memory block already
  *                      allocated with av_realloc(), or a pointer to `NULL`.
@@ -343,7 +254,7 @@
  * @return Zero on success, an AVERROR error code on failure
  *
  * @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
- *          correctly aligned.
+ *          correctly aligned. *ptr must be freed after even if nmemb is zero.
  */
 int av_reallocp_array(void *ptr, size_t nmemb, size_t size);
 
@@ -668,20 +579,12 @@
 /**
  * Multiply two `size_t` values checking for overflow.
  *
- * @param[in]  a,b Operands of multiplication
+ * @param[in]  a   Operand of multiplication
+ * @param[in]  b   Operand of multiplication
  * @param[out] r   Pointer to the result of the operation
  * @return 0 on success, AVERROR(EINVAL) on overflow
  */
-static inline int av_size_mult(size_t a, size_t b, size_t *r)
-{
-    size_t t = a * b;
-    /* Hack inspired from glibc: don't try the division if nelem and elsize
-     * are both less than sqrt(SIZE_MAX). */
-    if ((a | b) >= ((size_t)1 << (sizeof(size_t) * 4)) && a && t / a != b)
-        return AVERROR(EINVAL);
-    *r = t;
-    return 0;
-}
+int av_size_mult(size_t a, size_t b, size_t *r);
 
 /**
  * Set the maximum size that may be allocated in one block.
diff -Naur a/media/ffvpx/libavutil/mem_internal.h b/media/ffvpx/libavutil/mem_internal.h
--- a/media/ffvpx/libavutil/mem_internal.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/mem_internal.h	2023-04-06 12:50:24.494176623 +0200
@@ -25,11 +25,11 @@
 
 #include <stdint.h>
 
-#include "avassert.h"
+#include "attributes.h"
+#include "macros.h"
 #include "mem.h"
 #include "version.h"
 
-#if !FF_API_DECLARE_ALIGNED
 /**
  * @def DECLARE_ALIGNED(n,t,v)
  * Declare a variable that is aligned in memory.
@@ -96,7 +96,6 @@
     #define DECLARE_ASM_ALIGNED(n,t,v)  t v
     #define DECLARE_ASM_CONST(n,t,v)    static const t v
 #endif
-#endif
 
 // Some broken preprocessors need a second expansion
 // to be forced to tokenize __VA_ARGS__
@@ -136,22 +135,4 @@
 #   define LOCAL_ALIGNED_32(t, v, ...) E1(LOCAL_ALIGNED_A(32, t, v, __VA_ARGS__,,))
 #endif
 
-static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)
-{
-    void *val;
-
-    memcpy(&val, ptr, sizeof(val));
-    if (min_size <= *size) {
-        av_assert0(val || !min_size);
-        return 0;
-    }
-    min_size = FFMAX(min_size + min_size / 16 + 32, min_size);
-    av_freep(ptr);
-    val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);
-    memcpy(ptr, &val, sizeof(val));
-    if (!val)
-        min_size = 0;
-    *size = min_size;
-    return 1;
-}
 #endif /* AVUTIL_MEM_INTERNAL_H */
diff -Naur a/media/ffvpx/libavutil/moz.build b/media/ffvpx/libavutil/moz.build
--- a/media/ffvpx/libavutil/moz.build	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/moz.build	2023-04-06 12:49:40.261395212 +0200
@@ -11,11 +11,13 @@
         DIRS += ['x86']
     elif CONFIG['CPU_ARCH'] == 'arm':
         DIRS += ['arm']
-    elif CONFIG['CPU_ARCH'] == 'aarch64':
-        DIRS += ['aarch64']
+
+if CONFIG['CPU_ARCH'] == 'aarch64':
+    DIRS += ['aarch64']
 
 SharedLibrary('mozavutil')
 SOURCES += [
+    'avsscanf.c',
     'avstring.c',
     'bprint.c',
     'buffer.c',
@@ -45,6 +47,7 @@
     'time.c',
     'utils.c'
 ]
+
 if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
     SOURCES += [
         'adler32.c',
@@ -54,6 +57,7 @@
         'integer.c',
         'intmath.c',
         'lls.c',
+        'mastering_display_metadata.c',
         'pixelutils.c',
         'threadmessage.c',
         'timecode.c',
@@ -63,7 +67,6 @@
         LOCAL_INCLUDES += ['/media/mozva']
         SOURCES += [
             'hwcontext_vaapi.c',
-            'mastering_display_metadata.c',
         ]
         USE_LIBS += ['mozva']
 
diff -Naur a/media/ffvpx/libavutil/opt.c b/media/ffvpx/libavutil/opt.c
--- a/media/ffvpx/libavutil/opt.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/opt.c	2023-04-06 12:50:24.494176623 +0200
@@ -39,6 +39,7 @@
 #include "opt.h"
 #include "samplefmt.h"
 #include "bprint.h"
+#include "version.h"
 
 #include <float.h>
 
@@ -71,7 +72,11 @@
     case AV_OPT_TYPE_INT:
         *intnum = *(int *)dst;
         return 0;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     case AV_OPT_TYPE_DURATION:
     case AV_OPT_TYPE_INT64:
     case AV_OPT_TYPE_UINT64:
@@ -126,7 +131,11 @@
         *(int *)dst = llrint(num / den) * intnum;
         break;
     case AV_OPT_TYPE_DURATION:
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     case AV_OPT_TYPE_INT64:{
         double d = num / den;
         if (intnum == 1 && d == (double)INT64_MAX) {
@@ -262,9 +271,12 @@
             const char * const_names[64];
             int search_flags = (o->flags & AV_OPT_FLAG_CHILD_CONSTS) ? AV_OPT_SEARCH_CHILDREN : 0;
             const AVOption *o_named = av_opt_find(target_obj, i ? buf : val, o->unit, 0, search_flags);
-            if (o_named && o_named->type == AV_OPT_TYPE_CONST)
+            if (o_named && o_named->type == AV_OPT_TYPE_CONST) {
                 d = DEFAULT_NUMVAL(o_named);
-            else {
+                if (o_named->flags & AV_OPT_FLAG_DEPRECATED)
+                    av_log(obj, AV_LOG_WARNING, "The \"%s\" option is deprecated: %s\n",
+                           o_named->name, o_named->help);
+            } else {
                 if (o->unit) {
                     for (o_named = NULL; o_named = av_opt_next(target_obj, o_named); ) {
                         if (o_named->type == AV_OPT_TYPE_CONST &&
@@ -462,6 +474,16 @@
     return 0;
 }
 
+static int set_string_channel_layout(void *obj, const AVOption *o,
+                                     const char *val, void *dst)
+{
+    AVChannelLayout *channel_layout = dst;
+    av_channel_layout_uninit(channel_layout);
+    if (!val)
+        return 0;
+    return av_channel_layout_from_string(channel_layout, val);
+}
+
 int av_opt_set(void *obj, const char *name, const char *val, int search_flags)
 {
     int ret = 0;
@@ -469,12 +491,17 @@
     const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
     if (!o || !target_obj)
         return AVERROR_OPTION_NOT_FOUND;
+FF_DISABLE_DEPRECATION_WARNINGS
     if (!val && (o->type != AV_OPT_TYPE_STRING &&
                  o->type != AV_OPT_TYPE_PIXEL_FMT && o->type != AV_OPT_TYPE_SAMPLE_FMT &&
                  o->type != AV_OPT_TYPE_IMAGE_SIZE &&
                  o->type != AV_OPT_TYPE_DURATION && o->type != AV_OPT_TYPE_COLOR &&
-                 o->type != AV_OPT_TYPE_CHANNEL_LAYOUT && o->type != AV_OPT_TYPE_BOOL))
+#if FF_API_OLD_CHANNEL_LAYOUT
+                 o->type != AV_OPT_TYPE_CHANNEL_LAYOUT &&
+#endif
+                 o->type != AV_OPT_TYPE_BOOL))
         return AVERROR(EINVAL);
+FF_ENABLE_DEPRECATION_WARNINGS
 
     if (o->flags & AV_OPT_FLAG_READONLY)
         return AVERROR(EINVAL);
@@ -530,6 +557,8 @@
         }
     case AV_OPT_TYPE_COLOR:
         return set_string_color(obj, o, val, dst);
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
         if (!val || !strcmp(val, "none")) {
             *(int64_t *)dst = 0;
@@ -543,6 +572,15 @@
             return ret;
         }
         break;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    case AV_OPT_TYPE_CHLAYOUT:
+        ret = set_string_channel_layout(obj, o, val, dst);
+        if (ret < 0) {
+            av_log(obj, AV_LOG_ERROR, "Unable to parse option value \"%s\" as channel layout\n", val);
+            ret = AVERROR(EINVAL);
+        }
+        return ret;
     case AV_OPT_TYPE_DICT:
         return set_string_dict(obj, o, val, dst);
     }
@@ -706,6 +744,8 @@
     return set_format(obj, name, fmt, search_flags, AV_OPT_TYPE_SAMPLE_FMT, "sample", AV_SAMPLE_FMT_NB);
 }
 
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
 int av_opt_set_channel_layout(void *obj, const char *name, int64_t cl, int search_flags)
 {
     void *target_obj;
@@ -721,6 +761,8 @@
     *(int64_t *)(((uint8_t *)target_obj) + o->offset) = cl;
     return 0;
 }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
 
 int av_opt_set_dict_val(void *obj, const char *name, const AVDictionary *val,
                         int search_flags)
@@ -741,6 +783,22 @@
     return 0;
 }
 
+int av_opt_set_chlayout(void *obj, const char *name,
+                        const AVChannelLayout *channel_layout,
+                        int search_flags)
+{
+    void *target_obj;
+    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
+    AVChannelLayout *dst;
+
+    if (!o || !target_obj)
+        return AVERROR_OPTION_NOT_FOUND;
+
+    dst = (AVChannelLayout*)((uint8_t*)target_obj + o->offset);
+
+    return av_channel_layout_copy(dst, channel_layout);
+}
+
 static void format_duration(char *buf, size_t size, int64_t d)
 {
     char *e;
@@ -869,10 +927,18 @@
                        (int)((uint8_t *)dst)[0], (int)((uint8_t *)dst)[1],
                        (int)((uint8_t *)dst)[2], (int)((uint8_t *)dst)[3]);
         break;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
+
         i64 = *(int64_t *)dst;
         ret = snprintf(buf, sizeof(buf), "0x%"PRIx64, i64);
         break;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    case AV_OPT_TYPE_CHLAYOUT:
+        ret = av_channel_layout_describe(dst, buf, sizeof(buf));
+        break;
     case AV_OPT_TYPE_DICT:
         if (!*(AVDictionary **)dst && (search_flags & AV_OPT_ALLOW_NULL)) {
             *out_val = NULL;
@@ -917,7 +983,10 @@
 
     if ((ret = get_number(obj, name, NULL, &num, &den, &intnum, search_flags)) < 0)
         return ret;
-    *out_val = num * intnum / den;
+    if (num == den)
+        *out_val = intnum;
+    else
+        *out_val = num * intnum / den;
     return 0;
 }
 
@@ -1011,6 +1080,8 @@
     return get_format(obj, name, search_flags, out_fmt, AV_OPT_TYPE_SAMPLE_FMT, "sample");
 }
 
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
 int av_opt_get_channel_layout(void *obj, const char *name, int search_flags, int64_t *cl)
 {
     void *dst, *target_obj;
@@ -1027,6 +1098,24 @@
     *cl = *(int64_t *)dst;
     return 0;
 }
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+int av_opt_get_chlayout(void *obj, const char *name, int search_flags, AVChannelLayout *cl)
+{
+    void *dst, *target_obj;
+    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
+    if (!o || !target_obj)
+        return AVERROR_OPTION_NOT_FOUND;
+    if (o->type != AV_OPT_TYPE_CHLAYOUT) {
+        av_log(obj, AV_LOG_ERROR,
+               "The value for option '%s' is not a channel layout.\n", name);
+        return AVERROR(EINVAL);
+    }
+
+    dst = ((uint8_t*)target_obj) + o->offset;
+    return av_channel_layout_copy(cl, dst);
+}
 
 int av_opt_get_dict_val(void *obj, const char *name, int search_flags, AVDictionary **out_val)
 {
@@ -1167,7 +1256,7 @@
             av_log(av_log_obj, AV_LOG_INFO, "     %-15s ", opt->name);
         else
             av_log(av_log_obj, AV_LOG_INFO, "  %s%-17s ",
-                   (opt->flags & AV_OPT_FLAG_FILTERING_PARAM) ? "" : "-",
+                   (opt->flags & AV_OPT_FLAG_FILTERING_PARAM) ? " " : "-",
                    opt->name);
 
         switch (opt->type) {
@@ -1219,7 +1308,12 @@
             case AV_OPT_TYPE_COLOR:
                 av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<color>");
                 break;
+            case AV_OPT_TYPE_CHLAYOUT:
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
             case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
                 av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<channel_layout>");
                 break;
             case AV_OPT_TYPE_BOOL:
@@ -1235,17 +1329,18 @@
                 av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "");
                 break;
         }
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_ENCODING_PARAM) ? 'E' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_DECODING_PARAM) ? 'D' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_FILTERING_PARAM)? 'F' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_VIDEO_PARAM   ) ? 'V' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_AUDIO_PARAM   ) ? 'A' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_SUBTITLE_PARAM) ? 'S' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_EXPORT)         ? 'X' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_READONLY)       ? 'R' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_BSF_PARAM)      ? 'B' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_RUNTIME_PARAM)  ? 'T' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_DEPRECATED)     ? 'P' : '.');
+        av_log(av_log_obj, AV_LOG_INFO, "%c%c%c%c%c%c%c%c%c%c%c",
+               (opt->flags & AV_OPT_FLAG_ENCODING_PARAM)  ? 'E' : '.',
+               (opt->flags & AV_OPT_FLAG_DECODING_PARAM)  ? 'D' : '.',
+               (opt->flags & AV_OPT_FLAG_FILTERING_PARAM) ? 'F' : '.',
+               (opt->flags & AV_OPT_FLAG_VIDEO_PARAM)     ? 'V' : '.',
+               (opt->flags & AV_OPT_FLAG_AUDIO_PARAM)     ? 'A' : '.',
+               (opt->flags & AV_OPT_FLAG_SUBTITLE_PARAM)  ? 'S' : '.',
+               (opt->flags & AV_OPT_FLAG_EXPORT)          ? 'X' : '.',
+               (opt->flags & AV_OPT_FLAG_READONLY)        ? 'R' : '.',
+               (opt->flags & AV_OPT_FLAG_BSF_PARAM)       ? 'B' : '.',
+               (opt->flags & AV_OPT_FLAG_RUNTIME_PARAM)   ? 'T' : '.',
+               (opt->flags & AV_OPT_FLAG_DEPRECATED)      ? 'P' : '.');
 
         if (opt->help)
             av_log(av_log_obj, AV_LOG_INFO, " %s", opt->help);
@@ -1276,6 +1371,7 @@
                    opt->type == AV_OPT_TYPE_IMAGE_SIZE ||
                    opt->type == AV_OPT_TYPE_STRING     ||
                    opt->type == AV_OPT_TYPE_DICT       ||
+                   opt->type == AV_OPT_TYPE_CHLAYOUT   ||
                    opt->type == AV_OPT_TYPE_VIDEO_RATE) &&
                   !opt->default_val.str)) {
             av_log(av_log_obj, AV_LOG_INFO, " (default ");
@@ -1328,11 +1424,16 @@
             case AV_OPT_TYPE_STRING:
             case AV_OPT_TYPE_DICT:
             case AV_OPT_TYPE_VIDEO_RATE:
+            case AV_OPT_TYPE_CHLAYOUT:
                 av_log(av_log_obj, AV_LOG_INFO, "\"%s\"", opt->default_val.str);
                 break;
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
             case AV_OPT_TYPE_CHANNEL_LAYOUT:
                 av_log(av_log_obj, AV_LOG_INFO, "0x%"PRIx64, opt->default_val.i64);
                 break;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
             }
             av_log(av_log_obj, AV_LOG_INFO, ")");
         }
@@ -1382,7 +1483,11 @@
             case AV_OPT_TYPE_INT64:
             case AV_OPT_TYPE_UINT64:
             case AV_OPT_TYPE_DURATION:
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
             case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
             case AV_OPT_TYPE_PIXEL_FMT:
             case AV_OPT_TYPE_SAMPLE_FMT:
                 write_number(s, opt, dst, 1, 1, opt->default_val.i64);
@@ -1415,6 +1520,9 @@
             case AV_OPT_TYPE_BINARY:
                 set_string_binary(s, opt, opt->default_val.str, dst);
                 break;
+            case AV_OPT_TYPE_CHLAYOUT:
+                set_string_channel_layout(s, opt, opt->default_val.str, dst);
+                break;
             case AV_OPT_TYPE_DICT:
                 set_string_dict(s, opt, opt->default_val.str, dst);
                 break;
@@ -1622,6 +1730,10 @@
             av_dict_free((AVDictionary **)(((uint8_t *)obj) + o->offset));
             break;
 
+        case AV_OPT_TYPE_CHLAYOUT:
+            av_channel_layout_uninit((AVChannelLayout *)(((uint8_t *)obj) + o->offset));
+            break;
+
         default:
             break;
         }
@@ -1630,27 +1742,26 @@
 
 int av_opt_set_dict2(void *obj, AVDictionary **options, int search_flags)
 {
-    AVDictionaryEntry *t = NULL;
+    const AVDictionaryEntry *t = NULL;
     AVDictionary    *tmp = NULL;
-    int ret = 0;
+    int ret;
 
     if (!options)
         return 0;
 
-    while ((t = av_dict_get(*options, "", t, AV_DICT_IGNORE_SUFFIX))) {
+    while ((t = av_dict_iterate(*options, t))) {
         ret = av_opt_set(obj, t->key, t->value, search_flags);
         if (ret == AVERROR_OPTION_NOT_FOUND)
-            ret = av_dict_set(&tmp, t->key, t->value, 0);
+            ret = av_dict_set(&tmp, t->key, t->value, AV_DICT_MULTIKEY);
         if (ret < 0) {
             av_log(obj, AV_LOG_ERROR, "Error setting option %s to value %s.\n", t->key, t->value);
             av_dict_free(&tmp);
             return ret;
         }
-        ret = 0;
     }
     av_dict_free(options);
     *options = tmp;
-    return ret;
+    return 0;
 }
 
 int av_opt_set_dict(void *obj, AVDictionary **options)
@@ -1717,29 +1828,10 @@
     return NULL;
 }
 
-#if FF_API_CHILD_CLASS_NEXT
-FF_DISABLE_DEPRECATION_WARNINGS
-const AVClass *av_opt_child_class_next(const AVClass *parent, const AVClass *prev)
-{
-    if (parent->child_class_next)
-        return parent->child_class_next(prev);
-    return NULL;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 const AVClass *av_opt_child_class_iterate(const AVClass *parent, void **iter)
 {
     if (parent->child_class_iterate)
         return parent->child_class_iterate(iter);
-#if FF_API_CHILD_CLASS_NEXT
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (parent->child_class_next) {
-        *iter = parent->child_class_next(*iter);
-        return *iter;
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     return NULL;
 }
 
@@ -1759,7 +1851,11 @@
     case AV_OPT_TYPE_FLAGS:
         return sizeof(int);
     case AV_OPT_TYPE_DURATION:
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     case AV_OPT_TYPE_INT64:
     case AV_OPT_TYPE_UINT64:
         return sizeof(int64_t);
@@ -1826,12 +1922,16 @@
         } else if (o->type == AV_OPT_TYPE_DICT) {
             AVDictionary **sdict = (AVDictionary **) field_src;
             AVDictionary **ddict = (AVDictionary **) field_dst;
+            int ret2;
             if (*sdict != *ddict)
                 av_dict_free(ddict);
             *ddict = NULL;
-            av_dict_copy(ddict, *sdict, 0);
-            if (av_dict_count(*sdict) != av_dict_count(*ddict))
-                ret = AVERROR(ENOMEM);
+            ret2 = av_dict_copy(ddict, *sdict, 0);
+            if (ret2 < 0)
+                ret = ret2;
+        } else if (o->type == AV_OPT_TYPE_CHLAYOUT) {
+            if (field_dst != field_src)
+                ret = av_channel_layout_copy(field_dst, field_src);
         } else {
             int size = opt_size(o->type);
             if (size < 0)
@@ -1847,10 +1947,7 @@
 {
     int ret;
     const AVClass *c = *(AVClass**)obj;
-    int (*callback)(AVOptionRanges **, void *obj, const char *key, int flags) = NULL;
-
-    if (c->version > (52 << 16 | 11 << 8))
-        callback = c->query_ranges;
+    int (*callback)(AVOptionRanges **, void *obj, const char *key, int flags) = c->query_ranges;
 
     if (!callback)
         callback = av_opt_query_ranges_default;
@@ -1898,7 +1995,11 @@
     case AV_OPT_TYPE_DOUBLE:
     case AV_OPT_TYPE_DURATION:
     case AV_OPT_TYPE_COLOR:
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
         break;
     case AV_OPT_TYPE_STRING:
         range->component_min = 0;
@@ -1978,12 +2079,24 @@
     case AV_OPT_TYPE_PIXEL_FMT:
     case AV_OPT_TYPE_SAMPLE_FMT:
     case AV_OPT_TYPE_INT:
+#if FF_API_OLD_CHANNEL_LAYOUT
+FF_DISABLE_DEPRECATION_WARNINGS
     case AV_OPT_TYPE_CHANNEL_LAYOUT:
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     case AV_OPT_TYPE_DURATION:
     case AV_OPT_TYPE_INT64:
     case AV_OPT_TYPE_UINT64:
         read_number(o, dst, NULL, NULL, &i64);
         return o->default_val.i64 == i64;
+    case AV_OPT_TYPE_CHLAYOUT: {
+        AVChannelLayout ch_layout = { 0 };
+        if (o->default_val.str) {
+            if ((ret = av_channel_layout_from_string(&ch_layout, o->default_val.str)) < 0)
+                return ret;
+        }
+        return !av_channel_layout_compare((AVChannelLayout *)dst, &ch_layout);
+    }
     case AV_OPT_TYPE_STRING:
         str = *(char **)dst;
         if (str == o->default_val.str) //2 NULLs
@@ -2024,16 +2137,16 @@
     case AV_OPT_TYPE_DICT: {
         AVDictionary *dict1 = NULL;
         AVDictionary *dict2 = *(AVDictionary **)dst;
-        AVDictionaryEntry *en1 = NULL;
-        AVDictionaryEntry *en2 = NULL;
+        const AVDictionaryEntry *en1 = NULL;
+        const AVDictionaryEntry *en2 = NULL;
         ret = av_dict_parse_string(&dict1, o->default_val.str, "=", ":", 0);
         if (ret < 0) {
             av_dict_free(&dict1);
             return ret;
         }
         do {
-            en1 = av_dict_get(dict1, "", en1, AV_DICT_IGNORE_SUFFIX);
-            en2 = av_dict_get(dict2, "", en2, AV_DICT_IGNORE_SUFFIX);
+            en1 = av_dict_iterate(dict1, en1);
+            en2 = av_dict_iterate(dict2, en2);
         } while (en1 && en2 && !strcmp(en1->key, en2->key) && !strcmp(en1->value, en2->value));
         av_dict_free(&dict1);
         return (!en1 && !en2);
diff -Naur a/media/ffvpx/libavutil/opt.h b/media/ffvpx/libavutil/opt.h
--- a/media/ffvpx/libavutil/opt.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/opt.h	2023-04-06 12:49:40.261395212 +0200
@@ -29,11 +29,11 @@
 
 #include "rational.h"
 #include "avutil.h"
+#include "channel_layout.h"
 #include "dict.h"
 #include "log.h"
 #include "pixfmt.h"
 #include "samplefmt.h"
-#include "version.h"
 
 /**
  * @defgroup avoptions AVOptions
@@ -238,8 +238,11 @@
     AV_OPT_TYPE_VIDEO_RATE, ///< offset must point to AVRational
     AV_OPT_TYPE_DURATION,
     AV_OPT_TYPE_COLOR,
+#if FF_API_OLD_CHANNEL_LAYOUT
     AV_OPT_TYPE_CHANNEL_LAYOUT,
+#endif
     AV_OPT_TYPE_BOOL,
+    AV_OPT_TYPE_CHLAYOUT,
 };
 
 /**
@@ -648,19 +651,6 @@
  */
 void *av_opt_child_next(void *obj, void *prev);
 
-#if FF_API_CHILD_CLASS_NEXT
-/**
- * Iterate over potential AVOptions-enabled children of parent.
- *
- * @param prev result of a previous call to this function or NULL
- * @return AVClass corresponding to next potential child or NULL
- *
- * @deprecated use av_opt_child_class_iterate
- */
-attribute_deprecated
-const AVClass *av_opt_child_class_next(const AVClass *parent, const AVClass *prev);
-#endif
-
 /**
  * Iterate over potential AVOptions-enabled children of parent.
  *
@@ -707,7 +697,11 @@
 int av_opt_set_pixel_fmt (void *obj, const char *name, enum AVPixelFormat fmt, int search_flags);
 int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags);
 int av_opt_set_video_rate(void *obj, const char *name, AVRational val, int search_flags);
+#if FF_API_OLD_CHANNEL_LAYOUT
+attribute_deprecated
 int av_opt_set_channel_layout(void *obj, const char *name, int64_t ch_layout, int search_flags);
+#endif
+int av_opt_set_chlayout(void *obj, const char *name, const AVChannelLayout *layout, int search_flags);
 /**
  * @note Any old dictionary present is discarded and replaced with a copy of the new one. The
  * caller still owns val is and responsible for freeing it.
@@ -762,7 +756,11 @@
 int av_opt_get_pixel_fmt (void *obj, const char *name, int search_flags, enum AVPixelFormat *out_fmt);
 int av_opt_get_sample_fmt(void *obj, const char *name, int search_flags, enum AVSampleFormat *out_fmt);
 int av_opt_get_video_rate(void *obj, const char *name, int search_flags, AVRational *out_val);
+#if FF_API_OLD_CHANNEL_LAYOUT
+attribute_deprecated
 int av_opt_get_channel_layout(void *obj, const char *name, int search_flags, int64_t *ch_layout);
+#endif
+int av_opt_get_chlayout(void *obj, const char *name, int search_flags, AVChannelLayout *layout);
 /**
  * @param[out] out_val The returned dictionary is a copy of the actual value and must
  * be freed with av_dict_free() by the caller
@@ -804,9 +802,16 @@
 /**
  * Copy options from src object into dest object.
  *
+ * The underlying AVClass of both src and dest must coincide. The guarantee
+ * below does not apply if this is not fulfilled.
+ *
  * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
  * Original memory allocated for such options is freed unless both src and dest options points to the same memory.
  *
+ * Even on error it is guaranteed that allocated options from src and dest
+ * no longer alias each other afterwards; in particular calling av_opt_free()
+ * on both src and dest is safe afterwards if dest has been memdup'ed from src.
+ *
  * @param dest Object to copy from
  * @param src  Object to copy into
  * @return 0 on success, negative on error
diff -Naur a/media/ffvpx/libavutil/parseutils.c b/media/ffvpx/libavutil/parseutils.c
--- a/media/ffvpx/libavutil/parseutils.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/parseutils.c	2023-04-06 12:50:20.234005184 +0200
@@ -28,7 +28,7 @@
 #include "common.h"
 #include "eval.h"
 #include "log.h"
-//#include "random_seed.h"
+/* #include "random_seed.h" */
 #include "time_internal.h"
 #include "parseutils.h"
 #include "fftime.h"
@@ -102,6 +102,7 @@
     { "wsxga",    1600,1024 },
     { "wuxga",    1920,1200 },
     { "woxga",    2560,1600 },
+    { "wqhd",     2560,1440 },
     { "wqsxga",   3200,2048 },
     { "wquxga",   3840,2400 },
     { "whsxga",   6400,4096 },
@@ -111,6 +112,7 @@
     { "hd480",     852, 480 },
     { "hd720",    1280, 720 },
     { "hd1080",   1920,1080 },
+    { "quadhd",   2560,1440 },
     { "2k",       2048,1080 }, /* Digital Cinema System Specification */
     { "2kdci",    2048,1080 },
     { "2kflat",   1998,1080 },
diff -Naur a/media/ffvpx/libavutil/parseutils.h b/media/ffvpx/libavutil/parseutils.h
--- a/media/ffvpx/libavutil/parseutils.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/parseutils.h	2023-04-06 12:50:06.976471255 +0200
@@ -79,6 +79,8 @@
 /**
  * Put the RGBA values that correspond to color_string in rgba_color.
  *
+ * @param rgba_color 4-elements array of uint8_t values, where the respective
+ * red, green, blue and alpha component values are written.
  * @param color_string a string specifying a color. It can be the name of
  * a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,
  * possibly followed by "@" and a string representing the alpha
@@ -92,6 +94,8 @@
  * @param slen length of the initial part of color_string containing the
  * color. It can be set to -1 if color_string is a null terminated string
  * containing nothing else than the color.
+ * @param log_ctx a pointer to an arbitrary struct of which the first field
+ * is a pointer to an AVClass struct (used for av_log()). Can be NULL.
  * @return >= 0 in case of success, a negative value in case of
  * failure (for example if color_string cannot be parsed).
  */
@@ -106,7 +110,7 @@
  * av_parse_color().
  *
  * @param color_idx index of the requested color, starting from 0
- * @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB
+ * @param rgb      if not NULL, will point to a 3-elements array with the color value in RGB
  * @return the color name string or NULL if color_idx is not in the array
  */
 const char *av_get_known_color_name(int color_idx, const uint8_t **rgb);
@@ -162,19 +166,19 @@
  * by the standard strptime().
  *
  * The supported input field descriptors are listed below.
- * - %H: the hour as a decimal number, using a 24-hour clock, in the
+ * - `%%H`: the hour as a decimal number, using a 24-hour clock, in the
  *   range '00' through '23'
- * - %J: hours as a decimal number, in the range '0' through INT_MAX
- * - %M: the minute as a decimal number, using a 24-hour clock, in the
+ * - `%%J`: hours as a decimal number, in the range '0' through INT_MAX
+ * - `%%M`: the minute as a decimal number, using a 24-hour clock, in the
  *   range '00' through '59'
- * - %S: the second as a decimal number, using a 24-hour clock, in the
+ * - `%%S`: the second as a decimal number, using a 24-hour clock, in the
  *   range '00' through '59'
- * - %Y: the year as a decimal number, using the Gregorian calendar
- * - %m: the month as a decimal number, in the range '1' through '12'
- * - %d: the day of the month as a decimal number, in the range '1'
+ * - `%%Y`: the year as a decimal number, using the Gregorian calendar
+ * - `%%m`: the month as a decimal number, in the range '1' through '12'
+ * - `%%d`: the day of the month as a decimal number, in the range '1'
  *   through '31'
- * - %T: alias for '%H:%M:%S'
- * - %%: a literal '%'
+ * - `%%T`: alias for `%%H:%%M:%%S`
+ * - `%%`: a literal `%`
  *
  * @return a pointer to the first character not processed in this function
  *         call. In case the input string contains more characters than
diff -Naur a/media/ffvpx/libavutil/pixdesc.c b/media/ffvpx/libavutil/pixdesc.c
--- a/media/ffvpx/libavutil/pixdesc.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/pixdesc.c	2023-04-06 12:50:24.494176623 +0200
@@ -22,14 +22,11 @@
 #include <stdio.h>
 #include <string.h>
 
-#include "avassert.h"
 #include "avstring.h"
 #include "common.h"
 #include "pixfmt.h"
 #include "pixdesc.h"
-#include "internal.h"
 #include "intreadwrite.h"
-#include "version.h"
 
 void av_read_image_line2(void *dst,
                         const uint8_t *data[4], const int linesize[4],
@@ -49,19 +46,35 @@
     uint32_t *dst32 = dst;
 
     if (flags & AV_PIX_FMT_FLAG_BITSTREAM) {
-        int skip = x * step + comp.offset;
-        const uint8_t *p = data[plane] + y * linesize[plane] + (skip >> 3);
-        int shift = 8 - depth - (skip & 7);
+        if (depth == 10) {
+            // Assume all channels are packed into a 32bit value
+            const uint8_t *byte_p = data[plane] + y * linesize[plane];
+            const uint32_t *p = (uint32_t *)byte_p;
 
-        while (w--) {
-            int val = (*p >> shift) & mask;
-            if (read_pal_component)
-                val = data[1][4*val + c];
-            shift -= step;
-            p -= shift >> 3;
-            shift &= 7;
-            if (dst_element_size == 4) *dst32++ = val;
-            else                       *dst16++ = val;
+            while (w--) {
+                int val = AV_RB32(p);
+                val = (val >> comp.offset) & mask;
+                if (read_pal_component)
+                    val = data[1][4*val + c];
+                if (dst_element_size == 4) *dst32++ = val;
+                else                       *dst16++ = val;
+                p++;
+            }
+        } else {
+            int skip = x * step + comp.offset;
+            const uint8_t *p = data[plane] + y * linesize[plane] + (skip >> 3);
+            int shift = 8 - depth - (skip & 7);
+
+            while (w--) {
+                int val = (*p >> shift) & mask;
+                if (read_pal_component)
+                    val = data[1][4*val + c];
+                shift -= step;
+                p -= shift >> 3;
+                shift &= 7;
+                if (dst_element_size == 4) *dst32++ = val;
+                else                       *dst16++ = val;
+            }
         }
     } else {
         const uint8_t *p = data[plane] + y * linesize[plane] +
@@ -112,15 +125,29 @@
     const uint16_t *src16 = src;
 
     if (flags & AV_PIX_FMT_FLAG_BITSTREAM) {
-        int skip = x * step + comp.offset;
-        uint8_t *p = data[plane] + y * linesize[plane] + (skip >> 3);
-        int shift = 8 - depth - (skip & 7);
+        if (depth == 10) {
+            // Assume all channels are packed into a 32bit value
+            const uint8_t *byte_p = data[plane] + y * linesize[plane];
+            uint32_t *p = (uint32_t *)byte_p;
+            int offset = comp.offset;
+            uint32_t mask  = ((1ULL << depth) - 1) << offset;
 
-        while (w--) {
-            *p |= (src_element_size == 4 ? *src32++ : *src16++) << shift;
-            shift -= step;
-            p -= shift >> 3;
-            shift &= 7;
+            while (w--) {
+                uint16_t val = src_element_size == 4 ? *src32++ : *src16++;
+                AV_WB32(p, (AV_RB32(p) & ~mask) | (val << offset));
+                p++;
+            }
+        } else {
+            int skip = x * step + comp.offset;
+            uint8_t *p = data[plane] + y * linesize[plane] + (skip >> 3);
+            int shift = 8 - depth - (skip & 7);
+
+            while (w--) {
+                *p |= (src_element_size == 4 ? *src32++ : *src16++) << shift;
+                shift -= step;
+                p -= shift >> 3;
+                shift &= 7;
+            }
         }
     } else {
         int shift = comp.shift;
@@ -167,9 +194,6 @@
     av_write_image_line2(src, data, linesize, desc, x, y, c, w, 2);
 }
 
-#if FF_API_PLUS1_MINUS1
-FF_DISABLE_DEPRECATION_WARNINGS
-#endif
 static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
     [AV_PIX_FMT_YUV420P] = {
         .name = "yuv420p",
@@ -177,9 +201,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -189,9 +213,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 8, 1, 7, 1 },        /* Y */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* U */
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* V */
+            { 0, 2, 0, 0, 8 },        /* Y */
+            { 0, 4, 1, 0, 8 },        /* U */
+            { 0, 4, 3, 0, 8 },        /* V */
         },
     },
     [AV_PIX_FMT_YVYU422] = {
@@ -200,9 +224,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 8, 1, 7, 1 },        /* Y */
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* U */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* V */
+            { 0, 2, 0, 0, 8 },        /* Y */
+            { 0, 4, 3, 0, 8 },        /* U */
+            { 0, 4, 1, 0, 8 },        /* V */
         },
     },
     [AV_PIX_FMT_Y210LE] = {
@@ -211,9 +235,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 0, 6, 10, 3, 9, 1 },        /* Y */
-            { 0, 8, 2, 6, 10, 7, 9, 3 },        /* U */
-            { 0, 8, 6, 6, 10, 7, 9, 7 },        /* V */
+            { 0, 4, 0, 6, 10 },        /* Y */
+            { 0, 8, 2, 6, 10 },        /* U */
+            { 0, 8, 6, 6, 10 },        /* V */
         },
     },
     [AV_PIX_FMT_Y210BE] = {
@@ -222,9 +246,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 0, 6, 10, 3, 9, 1 },        /* Y */
-            { 0, 8, 2, 6, 10, 7, 9, 3 },        /* U */
-            { 0, 8, 6, 6, 10, 7, 9, 7 },        /* V */
+            { 0, 4, 0, 6, 10 },        /* Y */
+            { 0, 8, 2, 6, 10 },        /* U */
+            { 0, 8, 6, 6, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE,
     },
@@ -234,9 +258,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 3, 0, 0, 8, 2, 7, 1 },        /* R */
-            { 0, 3, 1, 0, 8, 2, 7, 2 },        /* G */
-            { 0, 3, 2, 0, 8, 2, 7, 3 },        /* B */
+            { 0, 3, 0, 0, 8 },        /* R */
+            { 0, 3, 1, 0, 8 },        /* G */
+            { 0, 3, 2, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -246,9 +270,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 3, 2, 0, 8, 2, 7, 3 },        /* R */
-            { 0, 3, 1, 0, 8, 2, 7, 2 },        /* G */
-            { 0, 3, 0, 0, 8, 2, 7, 1 },        /* B */
+            { 0, 3, 2, 0, 8 },        /* R */
+            { 0, 3, 1, 0, 8 },        /* G */
+            { 0, 3, 0, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -258,9 +282,9 @@
         .log2_chroma_w= 0,
         .log2_chroma_h= 0,
         .comp = {
-            { 0, 4, 2, 4, 10, 3, 9, 2 },       /* R */
-            { 0, 4, 1, 2, 10, 3, 9, 3 },       /* G */
-            { 0, 4, 0, 0, 10, 3, 9, 4 },       /* B */
+            { 0, 4, 2, 4, 10 },       /* R */
+            { 0, 4, 1, 2, 10 },       /* G */
+            { 0, 4, 0, 0, 10 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -270,9 +294,33 @@
         .log2_chroma_w= 0,
         .log2_chroma_h= 0,
         .comp = {
-            { 0, 4, 0, 4, 10, 3, 9, 2 },       /* R */
-            { 0, 4, 1, 2, 10, 3, 9, 3 },       /* G */
-            { 0, 4, 2, 0, 10, 3, 9, 4 },       /* B */
+            { 0, 4, 0, 4, 10 },       /* R */
+            { 0, 4, 1, 2, 10 },       /* G */
+            { 0, 4, 2, 0, 10 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_X2BGR10LE] = {
+        .name = "x2bgr10le",
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            { 0, 4, 0, 0, 10 },       /* R */
+            { 0, 4, 1, 2, 10 },       /* G */
+            { 0, 4, 2, 4, 10 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB,
+    },
+    [AV_PIX_FMT_X2BGR10BE] = {
+        .name = "x2bgr10be",
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            { 0, 4, 2, 0, 10 },       /* R */
+            { 0, 4, 1, 2, 10 },       /* G */
+            { 0, 4, 0, 4, 10 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_BE,
     },
@@ -282,9 +330,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -294,9 +342,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -306,9 +354,9 @@
         .log2_chroma_w = 2,
         .log2_chroma_h = 2,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -318,9 +366,9 @@
         .log2_chroma_w = 2,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -330,9 +378,9 @@
         .log2_chroma_w = 2,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -342,9 +390,8 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
+            { 0, 1, 0, 0, 8 },        /* Y */
         },
-        .flags = FF_PSEUDOPAL,
         .alias = "gray8,y8",
     },
     [AV_PIX_FMT_MONOWHITE] = {
@@ -353,7 +400,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 1, 0, 0, 1 },        /* Y */
+            { 0, 1, 0, 0, 1 },        /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BITSTREAM,
     },
@@ -363,7 +410,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 7, 1, 0, 0, 1 },        /* Y */
+            { 0, 1, 0, 7, 1 },        /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BITSTREAM,
     },
@@ -373,7 +420,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },
+            { 0, 1, 0, 0, 8 },
         },
         .flags = AV_PIX_FMT_FLAG_PAL | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -383,9 +430,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -395,9 +442,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -407,25 +454,27 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
+#if FF_API_XVMC
     [AV_PIX_FMT_XVMC] = {
         .name = "xvmc",
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
+#endif
     [AV_PIX_FMT_UYVY422] = {
         .name = "uyvy422",
         .nb_components = 3,
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 1, 0, 8, 1, 7, 2 },        /* Y */
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* U */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* V */
+            { 0, 2, 1, 0, 8 },        /* Y */
+            { 0, 4, 0, 0, 8 },        /* U */
+            { 0, 4, 2, 0, 8 },        /* V */
         },
     },
     [AV_PIX_FMT_UYYVYY411] = {
@@ -434,9 +483,9 @@
         .log2_chroma_w = 2,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* Y */
-            { 0, 6, 0, 0, 8, 5, 7, 1 },        /* U */
-            { 0, 6, 3, 0, 8, 5, 7, 4 },        /* V */
+            { 0, 4, 1, 0, 8 },        /* Y */
+            { 0, 6, 0, 0, 8 },        /* U */
+            { 0, 6, 3, 0, 8 },        /* V */
         },
     },
     [AV_PIX_FMT_BGR8] = {
@@ -445,11 +494,11 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 3, 0, 2, 1 },        /* R */
-            { 0, 1, 0, 3, 3, 0, 2, 1 },        /* G */
-            { 0, 1, 0, 6, 2, 0, 1, 1 },        /* B */
+            { 0, 1, 0, 0, 3 },        /* R */
+            { 0, 1, 0, 3, 3 },        /* G */
+            { 0, 1, 0, 6, 2 },        /* B */
         },
-        .flags = AV_PIX_FMT_FLAG_RGB | FF_PSEUDOPAL,
+        .flags = AV_PIX_FMT_FLAG_RGB,
     },
     [AV_PIX_FMT_BGR4] = {
         .name = "bgr4",
@@ -457,9 +506,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 3, 0, 1, 3, 0, 4 },        /* R */
-            { 0, 4, 1, 0, 2, 3, 1, 2 },        /* G */
-            { 0, 4, 0, 0, 1, 3, 0, 1 },        /* B */
+            { 0, 4, 3, 0, 1 },        /* R */
+            { 0, 4, 1, 0, 2 },        /* G */
+            { 0, 4, 0, 0, 1 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BITSTREAM | AV_PIX_FMT_FLAG_RGB,
     },
@@ -469,11 +518,11 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 1, 0, 0, 1 },        /* R */
-            { 0, 1, 0, 1, 2, 0, 1, 1 },        /* G */
-            { 0, 1, 0, 3, 1, 0, 0, 1 },        /* B */
+            { 0, 1, 0, 0, 1 },        /* R */
+            { 0, 1, 0, 1, 2 },        /* G */
+            { 0, 1, 0, 3, 1 },        /* B */
         },
-        .flags = AV_PIX_FMT_FLAG_RGB | FF_PSEUDOPAL,
+        .flags = AV_PIX_FMT_FLAG_RGB,
     },
     [AV_PIX_FMT_RGB8] = {
         .name = "rgb8",
@@ -481,11 +530,11 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 6, 2, 0, 1, 1 },        /* R */
-            { 0, 1, 0, 3, 3, 0, 2, 1 },        /* G */
-            { 0, 1, 0, 0, 3, 0, 2, 1 },        /* B */
+            { 0, 1, 0, 6, 2 },        /* R */
+            { 0, 1, 0, 3, 3 },        /* G */
+            { 0, 1, 0, 0, 3 },        /* B */
         },
-        .flags = AV_PIX_FMT_FLAG_RGB | FF_PSEUDOPAL,
+        .flags = AV_PIX_FMT_FLAG_RGB,
     },
     [AV_PIX_FMT_RGB4] = {
         .name = "rgb4",
@@ -493,9 +542,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 0, 0, 1, 3, 0, 1 },        /* R */
-            { 0, 4, 1, 0, 2, 3, 1, 2 },        /* G */
-            { 0, 4, 3, 0, 1, 3, 0, 4 },        /* B */
+            { 0, 4, 0, 0, 1 },        /* R */
+            { 0, 4, 1, 0, 2 },        /* G */
+            { 0, 4, 3, 0, 1 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BITSTREAM | AV_PIX_FMT_FLAG_RGB,
     },
@@ -505,11 +554,11 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 3, 1, 0, 0, 1 },        /* R */
-            { 0, 1, 0, 1, 2, 0, 1, 1 },        /* G */
-            { 0, 1, 0, 0, 1, 0, 0, 1 },        /* B */
+            { 0, 1, 0, 3, 1 },        /* R */
+            { 0, 1, 0, 1, 2 },        /* G */
+            { 0, 1, 0, 0, 1 },        /* B */
         },
-        .flags = AV_PIX_FMT_FLAG_RGB | FF_PSEUDOPAL,
+        .flags = AV_PIX_FMT_FLAG_RGB,
     },
     [AV_PIX_FMT_NV12] = {
         .name = "nv12",
@@ -517,9 +566,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 2, 0, 0, 8, 1, 7, 1 },        /* U */
-            { 1, 2, 1, 0, 8, 1, 7, 2 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 2, 0, 0, 8 },        /* U */
+            { 1, 2, 1, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -529,9 +578,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 2, 1, 0, 8, 1, 7, 2 },        /* U */
-            { 1, 2, 0, 0, 8, 1, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 2, 1, 0, 8 },        /* U */
+            { 1, 2, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -541,10 +590,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* R */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* G */
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* B */
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* A */
+            { 0, 4, 1, 0, 8 },        /* R */
+            { 0, 4, 2, 0, 8 },        /* G */
+            { 0, 4, 3, 0, 8 },        /* B */
+            { 0, 4, 0, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -554,10 +603,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* R */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* G */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* B */
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* A */
+            { 0, 4, 0, 0, 8 },        /* R */
+            { 0, 4, 1, 0, 8 },        /* G */
+            { 0, 4, 2, 0, 8 },        /* B */
+            { 0, 4, 3, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -567,10 +616,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* R */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* G */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* B */
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* A */
+            { 0, 4, 3, 0, 8 },        /* R */
+            { 0, 4, 2, 0, 8 },        /* G */
+            { 0, 4, 1, 0, 8 },        /* B */
+            { 0, 4, 0, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -580,10 +629,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* R */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* G */
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* B */
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* A */
+            { 0, 4, 2, 0, 8 },        /* R */
+            { 0, 4, 1, 0, 8 },        /* G */
+            { 0, 4, 0, 0, 8 },        /* B */
+            { 0, 4, 3, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -593,9 +642,9 @@
         .log2_chroma_w= 0,
         .log2_chroma_h= 0,
         .comp = {
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* R */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* G */
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* B */
+            { 0, 4, 1, 0, 8 },        /* R */
+            { 0, 4, 2, 0, 8 },        /* G */
+            { 0, 4, 3, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -605,9 +654,9 @@
         .log2_chroma_w= 0,
         .log2_chroma_h= 0,
         .comp = {
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* R */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* G */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* B */
+            { 0, 4, 0, 0, 8 },        /* R */
+            { 0, 4, 1, 0, 8 },        /* G */
+            { 0, 4, 2, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -617,9 +666,9 @@
         .log2_chroma_w= 0,
         .log2_chroma_h= 0,
         .comp = {
-            { 0, 4, 3, 0, 8, 3, 7, 4 },        /* R */
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* G */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* B */
+            { 0, 4, 3, 0, 8 },        /* R */
+            { 0, 4, 2, 0, 8 },        /* G */
+            { 0, 4, 1, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -629,9 +678,9 @@
         .log2_chroma_w= 0,
         .log2_chroma_h= 0,
         .comp = {
-            { 0, 4, 2, 0, 8, 3, 7, 3 },        /* R */
-            { 0, 4, 1, 0, 8, 3, 7, 2 },        /* G */
-            { 0, 4, 0, 0, 8, 3, 7, 1 },        /* B */
+            { 0, 4, 2, 0, 8 },        /* R */
+            { 0, 4, 1, 0, 8 },        /* G */
+            { 0, 4, 0, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -641,7 +690,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },       /* Y */
+            { 0, 2, 0, 0, 9 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BE,
         .alias = "y9be",
@@ -652,7 +701,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },       /* Y */
+            { 0, 2, 0, 0, 9 },       /* Y */
         },
         .alias = "y9le",
     },
@@ -662,7 +711,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },       /* Y */
+            { 0, 2, 0, 0, 10 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BE,
         .alias = "y10be",
@@ -673,7 +722,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },       /* Y */
+            { 0, 2, 0, 0, 10 },       /* Y */
         },
         .alias = "y10le",
     },
@@ -683,7 +732,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },       /* Y */
+            { 0, 2, 0, 0, 12 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BE,
         .alias = "y12be",
@@ -694,7 +743,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },       /* Y */
+            { 0, 2, 0, 0, 12 },       /* Y */
         },
         .alias = "y12le",
     },
@@ -704,7 +753,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },       /* Y */
+            { 0, 2, 0, 0, 14 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BE,
         .alias = "y14be",
@@ -715,7 +764,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },       /* Y */
+            { 0, 2, 0, 0, 14 },       /* Y */
         },
         .alias = "y14le",
     },
@@ -725,7 +774,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* Y */
+            { 0, 2, 0, 0, 16 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BE,
         .alias = "y16be",
@@ -736,7 +785,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* Y */
+            { 0, 2, 0, 0, 16 },       /* Y */
         },
         .alias = "y16le",
     },
@@ -746,9 +795,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -758,9 +807,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -770,9 +819,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -782,9 +831,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -794,9 +843,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -806,9 +855,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -818,10 +867,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
-            { 3, 1, 0, 0, 8, 0, 7, 1 },        /* A */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
+            { 3, 1, 0, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -831,10 +880,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
-            { 3, 1, 0, 0, 8, 0, 7, 1 },        /* A */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
+            { 3, 1, 0, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -844,10 +893,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* U */
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* V */
-            { 3, 1, 0, 0, 8, 0, 7, 1 },        /* A */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 1, 0, 0, 8 },        /* U */
+            { 2, 1, 0, 0, 8 },        /* V */
+            { 3, 1, 0, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -857,10 +906,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
-            { 3, 2, 0, 0, 9, 1, 8, 1 },        /* A */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
+            { 3, 2, 0, 0, 9 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -870,10 +919,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
-            { 3, 2, 0, 0, 9, 1, 8, 1 },        /* A */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
+            { 3, 2, 0, 0, 9 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -883,10 +932,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
-            { 3, 2, 0, 0, 9, 1, 8, 1 },        /* A */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
+            { 3, 2, 0, 0, 9 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -896,10 +945,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
-            { 3, 2, 0, 0, 9, 1, 8, 1 },        /* A */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
+            { 3, 2, 0, 0, 9 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -909,10 +958,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
-            { 3, 2, 0, 0, 9, 1, 8, 1 },        /* A */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
+            { 3, 2, 0, 0, 9 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -922,10 +971,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
-            { 3, 2, 0, 0, 9, 1, 8, 1 },        /* A */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
+            { 3, 2, 0, 0, 9 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -935,10 +984,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },        /* A */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
+            { 3, 2, 0, 0, 10 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -948,10 +997,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },        /* A */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
+            { 3, 2, 0, 0, 10 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -961,10 +1010,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },        /* A */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
+            { 3, 2, 0, 0, 10 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -974,10 +1023,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },        /* A */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
+            { 3, 2, 0, 0, 10 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -987,10 +1036,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },        /* A */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
+            { 3, 2, 0, 0, 10 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1000,10 +1049,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },        /* A */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
+            { 3, 2, 0, 0, 10 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1013,10 +1062,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },        /* A */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
+            { 3, 2, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1026,10 +1075,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },        /* A */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
+            { 3, 2, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1039,10 +1088,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },        /* A */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
+            { 3, 2, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1052,10 +1101,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },        /* A */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
+            { 3, 2, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1065,10 +1114,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },        /* A */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
+            { 3, 2, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1078,10 +1127,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },        /* A */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
+            { 3, 2, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1091,9 +1140,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 6, 0, 0, 16, 5, 15, 1 },       /* R */
-            { 0, 6, 2, 0, 16, 5, 15, 3 },       /* G */
-            { 0, 6, 4, 0, 16, 5, 15, 5 },       /* B */
+            { 0, 6, 0, 0, 16 },       /* R */
+            { 0, 6, 2, 0, 16 },       /* G */
+            { 0, 6, 4, 0, 16 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_BE,
     },
@@ -1103,9 +1152,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 6, 0, 0, 16, 5, 15, 1 },       /* R */
-            { 0, 6, 2, 0, 16, 5, 15, 3 },       /* G */
-            { 0, 6, 4, 0, 16, 5, 15, 5 },       /* B */
+            { 0, 6, 0, 0, 16 },       /* R */
+            { 0, 6, 2, 0, 16 },       /* G */
+            { 0, 6, 4, 0, 16 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1115,10 +1164,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 8, 0, 0, 16, 7, 15, 1 },       /* R */
-            { 0, 8, 2, 0, 16, 7, 15, 3 },       /* G */
-            { 0, 8, 4, 0, 16, 7, 15, 5 },       /* B */
-            { 0, 8, 6, 0, 16, 7, 15, 7 },       /* A */
+            { 0, 8, 0, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 4, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1128,10 +1177,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 8, 0, 0, 16, 7, 15, 1 },       /* R */
-            { 0, 8, 2, 0, 16, 7, 15, 3 },       /* G */
-            { 0, 8, 4, 0, 16, 7, 15, 5 },       /* B */
-            { 0, 8, 6, 0, 16, 7, 15, 7 },       /* A */
+            { 0, 8, 0, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 4, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1141,9 +1190,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, -1, 3, 5, 1, 4, 0 },        /* R */
-            { 0, 2,  0, 5, 6, 1, 5, 1 },        /* G */
-            { 0, 2,  0, 0, 5, 1, 4, 1 },        /* B */
+            { 0, 2, -1, 3, 5 },        /* R */
+            { 0, 2,  0, 5, 6 },        /* G */
+            { 0, 2,  0, 0, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1153,9 +1202,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 1, 3, 5, 1, 4, 2 },        /* R */
-            { 0, 2, 0, 5, 6, 1, 5, 1 },        /* G */
-            { 0, 2, 0, 0, 5, 1, 4, 1 },        /* B */
+            { 0, 2, 1, 3, 5 },        /* R */
+            { 0, 2, 0, 5, 6 },        /* G */
+            { 0, 2, 0, 0, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1165,9 +1214,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, -1, 2, 5, 1, 4, 0 },        /* R */
-            { 0, 2,  0, 5, 5, 1, 4, 1 },        /* G */
-            { 0, 2,  0, 0, 5, 1, 4, 1 },        /* B */
+            { 0, 2, -1, 2, 5 },        /* R */
+            { 0, 2,  0, 5, 5 },        /* G */
+            { 0, 2,  0, 0, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1177,9 +1226,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 1, 2, 5, 1, 4, 2 },        /* R */
-            { 0, 2, 0, 5, 5, 1, 4, 1 },        /* G */
-            { 0, 2, 0, 0, 5, 1, 4, 1 },        /* B */
+            { 0, 2, 1, 2, 5 },        /* R */
+            { 0, 2, 0, 5, 5 },        /* G */
+            { 0, 2, 0, 0, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1189,9 +1238,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, -1, 0, 4, 1, 3, 0 },        /* R */
-            { 0, 2,  0, 4, 4, 1, 3, 1 },        /* G */
-            { 0, 2,  0, 0, 4, 1, 3, 1 },        /* B */
+            { 0, 2, -1, 0, 4 },        /* R */
+            { 0, 2,  0, 4, 4 },        /* G */
+            { 0, 2,  0, 0, 4 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1201,9 +1250,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 1, 0, 4, 1, 3, 2 },        /* R */
-            { 0, 2, 0, 4, 4, 1, 3, 1 },        /* G */
-            { 0, 2, 0, 0, 4, 1, 3, 1 },        /* B */
+            { 0, 2, 1, 0, 4 },        /* R */
+            { 0, 2, 0, 4, 4 },        /* G */
+            { 0, 2, 0, 0, 4 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1213,9 +1262,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 6, 4, 0, 16, 5, 15, 5 },       /* R */
-            { 0, 6, 2, 0, 16, 5, 15, 3 },       /* G */
-            { 0, 6, 0, 0, 16, 5, 15, 1 },       /* B */
+            { 0, 6, 4, 0, 16 },       /* R */
+            { 0, 6, 2, 0, 16 },       /* G */
+            { 0, 6, 0, 0, 16 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1225,9 +1274,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 6, 4, 0, 16, 5, 15, 5 },       /* R */
-            { 0, 6, 2, 0, 16, 5, 15, 3 },       /* G */
-            { 0, 6, 0, 0, 16, 5, 15, 1 },       /* B */
+            { 0, 6, 4, 0, 16 },       /* R */
+            { 0, 6, 2, 0, 16 },       /* G */
+            { 0, 6, 0, 0, 16 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1237,10 +1286,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 8, 4, 0, 16, 7, 15, 5 },       /* R */
-            { 0, 8, 2, 0, 16, 7, 15, 3 },       /* G */
-            { 0, 8, 0, 0, 16, 7, 15, 1 },       /* B */
-            { 0, 8, 6, 0, 16, 7, 15, 7 },       /* A */
+            { 0, 8, 4, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 0, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1250,10 +1299,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 8, 4, 0, 16, 7, 15, 5 },       /* R */
-            { 0, 8, 2, 0, 16, 7, 15, 3 },       /* G */
-            { 0, 8, 0, 0, 16, 7, 15, 1 },       /* B */
-            { 0, 8, 6, 0, 16, 7, 15, 7 },       /* A */
+            { 0, 8, 4, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 0, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1263,9 +1312,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2,  0, 0, 5, 1, 4, 1 },        /* R */
-            { 0, 2,  0, 5, 6, 1, 5, 1 },        /* G */
-            { 0, 2, -1, 3, 5, 1, 4, 0 },        /* B */
+            { 0, 2,  0, 0, 5 },        /* R */
+            { 0, 2,  0, 5, 6 },        /* G */
+            { 0, 2, -1, 3, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1275,9 +1324,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 5, 1, 4, 1 },        /* R */
-            { 0, 2, 0, 5, 6, 1, 5, 1 },        /* G */
-            { 0, 2, 1, 3, 5, 1, 4, 2 },        /* B */
+            { 0, 2, 0, 0, 5 },        /* R */
+            { 0, 2, 0, 5, 6 },        /* G */
+            { 0, 2, 1, 3, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1287,9 +1336,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2,  0, 0, 5, 1, 4, 1 },       /* R */
-            { 0, 2,  0, 5, 5, 1, 4, 1 },       /* G */
-            { 0, 2, -1, 2, 5, 1, 4, 0 },       /* B */
+            { 0, 2,  0, 0, 5 },       /* R */
+            { 0, 2,  0, 5, 5 },       /* G */
+            { 0, 2, -1, 2, 5 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
      },
@@ -1299,9 +1348,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 5, 1, 4, 1 },        /* R */
-            { 0, 2, 0, 5, 5, 1, 4, 1 },        /* G */
-            { 0, 2, 1, 2, 5, 1, 4, 2 },        /* B */
+            { 0, 2, 0, 0, 5 },        /* R */
+            { 0, 2, 0, 5, 5 },        /* G */
+            { 0, 2, 1, 2, 5 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
@@ -1311,9 +1360,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2,  0, 0, 4, 1, 3, 1 },       /* R */
-            { 0, 2,  0, 4, 4, 1, 3, 1 },       /* G */
-            { 0, 2, -1, 0, 4, 1, 3, 0 },       /* B */
+            { 0, 2,  0, 0, 4 },       /* R */
+            { 0, 2,  0, 4, 4 },       /* G */
+            { 0, 2, -1, 0, 4 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB,
      },
@@ -1323,48 +1372,27 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 4, 1, 3, 1 },        /* R */
-            { 0, 2, 0, 4, 4, 1, 3, 1 },        /* G */
-            { 0, 2, 1, 0, 4, 1, 3, 2 },        /* B */
+            { 0, 2, 0, 0, 4 },        /* R */
+            { 0, 2, 0, 4, 4 },        /* G */
+            { 0, 2, 1, 0, 4 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_RGB,
     },
-#if FF_API_VAAPI
-    [AV_PIX_FMT_VAAPI_MOCO] = {
-        .name = "vaapi_moco",
-        .log2_chroma_w = 1,
-        .log2_chroma_h = 1,
-        .flags = AV_PIX_FMT_FLAG_HWACCEL,
-    },
-    [AV_PIX_FMT_VAAPI_IDCT] = {
-        .name = "vaapi_idct",
-        .log2_chroma_w = 1,
-        .log2_chroma_h = 1,
-        .flags = AV_PIX_FMT_FLAG_HWACCEL,
-    },
-    [AV_PIX_FMT_VAAPI_VLD] = {
-        .name = "vaapi_vld",
-        .log2_chroma_w = 1,
-        .log2_chroma_h = 1,
-        .flags = AV_PIX_FMT_FLAG_HWACCEL,
-    },
-#else
     [AV_PIX_FMT_VAAPI] = {
         .name = "vaapi",
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
-#endif
     [AV_PIX_FMT_YUV420P9LE] = {
         .name = "yuv420p9le",
         .nb_components = 3,
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1374,9 +1402,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1386,9 +1414,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1398,9 +1426,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1410,9 +1438,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1422,9 +1450,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1434,9 +1462,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* Y */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* U */
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* V */
+            { 0, 2, 0, 0, 14 },        /* Y */
+            { 1, 2, 0, 0, 14 },        /* U */
+            { 2, 2, 0, 0, 14 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1446,9 +1474,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* Y */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* U */
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* V */
+            { 0, 2, 0, 0, 14 },        /* Y */
+            { 1, 2, 0, 0, 14 },        /* U */
+            { 2, 2, 0, 0, 14 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1458,9 +1486,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1470,9 +1498,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1482,9 +1510,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1494,9 +1522,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1506,9 +1534,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1518,9 +1546,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1530,9 +1558,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1542,9 +1570,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1554,9 +1582,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* Y */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* U */
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* V */
+            { 0, 2, 0, 0, 14 },        /* Y */
+            { 1, 2, 0, 0, 14 },        /* U */
+            { 2, 2, 0, 0, 14 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1566,9 +1594,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* Y */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* U */
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* V */
+            { 0, 2, 0, 0, 14 },        /* Y */
+            { 1, 2, 0, 0, 14 },        /* U */
+            { 2, 2, 0, 0, 14 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1578,9 +1606,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1590,9 +1618,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1602,9 +1630,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1614,9 +1642,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },        /* Y */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },        /* U */
-            { 2, 2, 0, 0, 16, 1, 15, 1 },        /* V */
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 2, 0, 0, 16 },        /* U */
+            { 2, 2, 0, 0, 16 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1626,9 +1654,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1638,9 +1666,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* U */
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 2, 0, 0, 10 },        /* U */
+            { 2, 2, 0, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1650,9 +1678,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1662,9 +1690,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* Y */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* U */
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* V */
+            { 0, 2, 0, 0, 9 },        /* Y */
+            { 1, 2, 0, 0, 9 },        /* U */
+            { 2, 2, 0, 0, 9 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1674,9 +1702,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1686,9 +1714,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1698,9 +1726,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* Y */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* U */
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* V */
+            { 0, 2, 0, 0, 14 },        /* Y */
+            { 1, 2, 0, 0, 14 },        /* U */
+            { 2, 2, 0, 0, 14 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1710,9 +1738,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* Y */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* U */
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* V */
+            { 0, 2, 0, 0, 14 },        /* Y */
+            { 1, 2, 0, 0, 14 },        /* U */
+            { 2, 2, 0, 0, 14 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -1732,8 +1760,8 @@
         .name = "ya8",
         .nb_components = 2,
         .comp = {
-            { 0, 2, 0, 0, 8, 1, 7, 1 },        /* Y */
-            { 0, 2, 1, 0, 8, 1, 7, 2 },        /* A */
+            { 0, 2, 0, 0, 8 },        /* Y */
+            { 0, 2, 1, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_ALPHA,
         .alias = "gray8a",
@@ -1742,8 +1770,8 @@
         .name = "ya16le",
         .nb_components = 2,
         .comp = {
-            { 0, 4, 0, 0, 16, 3, 15, 1 },        /* Y */
-            { 0, 4, 2, 0, 16, 3, 15, 3 },        /* A */
+            { 0, 4, 0, 0, 16 },        /* Y */
+            { 0, 4, 2, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1751,8 +1779,8 @@
         .name = "ya16be",
         .nb_components = 2,
         .comp = {
-            { 0, 4, 0, 0, 16, 3, 15, 1 },        /* Y */
-            { 0, 4, 2, 0, 16, 3, 15, 3 },        /* A */
+            { 0, 4, 0, 0, 16 },        /* Y */
+            { 0, 4, 2, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -1766,9 +1794,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* R */
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* G */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* B */
+            { 2, 1, 0, 0, 8 },        /* R */
+            { 0, 1, 0, 0, 8 },        /* G */
+            { 1, 1, 0, 0, 8 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1778,9 +1806,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* R */
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* G */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* B */
+            { 2, 2, 0, 0, 9 },        /* R */
+            { 0, 2, 0, 0, 9 },        /* G */
+            { 1, 2, 0, 0, 9 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1790,9 +1818,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 9, 1, 8, 1 },        /* R */
-            { 0, 2, 0, 0, 9, 1, 8, 1 },        /* G */
-            { 1, 2, 0, 0, 9, 1, 8, 1 },        /* B */
+            { 2, 2, 0, 0, 9 },        /* R */
+            { 0, 2, 0, 0, 9 },        /* G */
+            { 1, 2, 0, 0, 9 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1802,9 +1830,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* R */
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* G */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* B */
+            { 2, 2, 0, 0, 10 },        /* R */
+            { 0, 2, 0, 0, 10 },        /* G */
+            { 1, 2, 0, 0, 10 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1814,9 +1842,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 10, 1, 9, 1 },        /* R */
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* G */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },        /* B */
+            { 2, 2, 0, 0, 10 },        /* R */
+            { 0, 2, 0, 0, 10 },        /* G */
+            { 1, 2, 0, 0, 10 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1826,9 +1854,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* R */
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* G */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* B */
+            { 2, 2, 0, 0, 12 },        /* R */
+            { 0, 2, 0, 0, 12 },        /* G */
+            { 1, 2, 0, 0, 12 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1838,9 +1866,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* R */
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* G */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* B */
+            { 2, 2, 0, 0, 12 },        /* R */
+            { 0, 2, 0, 0, 12 },        /* G */
+            { 1, 2, 0, 0, 12 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1850,9 +1878,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* R */
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* G */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* B */
+            { 2, 2, 0, 0, 14 },        /* R */
+            { 0, 2, 0, 0, 14 },        /* G */
+            { 1, 2, 0, 0, 14 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1862,9 +1890,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 14, 1, 13, 1 },        /* R */
-            { 0, 2, 0, 0, 14, 1, 13, 1 },        /* G */
-            { 1, 2, 0, 0, 14, 1, 13, 1 },        /* B */
+            { 2, 2, 0, 0, 14 },        /* R */
+            { 0, 2, 0, 0, 14 },        /* G */
+            { 1, 2, 0, 0, 14 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1874,9 +1902,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 16, 1, 15, 1 },       /* R */
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* G */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },       /* B */
+            { 2, 2, 0, 0, 16 },       /* R */
+            { 0, 2, 0, 0, 16 },       /* G */
+            { 1, 2, 0, 0, 16 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1886,9 +1914,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 16, 1, 15, 1 },       /* R */
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* G */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },       /* B */
+            { 2, 2, 0, 0, 16 },       /* R */
+            { 0, 2, 0, 0, 16 },       /* G */
+            { 1, 2, 0, 0, 16 },       /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
     },
@@ -1898,10 +1926,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 1, 0, 0, 8, 0, 7, 1 },        /* R */
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* G */
-            { 1, 1, 0, 0, 8, 0, 7, 1 },        /* B */
-            { 3, 1, 0, 0, 8, 0, 7, 1 },        /* A */
+            { 2, 1, 0, 0, 8 },        /* R */
+            { 0, 1, 0, 0, 8 },        /* G */
+            { 1, 1, 0, 0, 8 },        /* B */
+            { 3, 1, 0, 0, 8 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB |
                  AV_PIX_FMT_FLAG_ALPHA,
@@ -1912,10 +1940,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 16, 1, 15, 1 },       /* R */
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* G */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },       /* B */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },       /* A */
+            { 2, 2, 0, 0, 16 },       /* R */
+            { 0, 2, 0, 0, 16 },       /* G */
+            { 1, 2, 0, 0, 16 },       /* B */
+            { 3, 2, 0, 0, 16 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB |
                  AV_PIX_FMT_FLAG_ALPHA,
@@ -1926,10 +1954,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 16, 1, 15, 1 },       /* R */
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* G */
-            { 1, 2, 0, 0, 16, 1, 15, 1 },       /* B */
-            { 3, 2, 0, 0, 16, 1, 15, 1 },       /* A */
+            { 2, 2, 0, 0, 16 },       /* R */
+            { 0, 2, 0, 0, 16 },       /* G */
+            { 1, 2, 0, 0, 16 },       /* B */
+            { 3, 2, 0, 0, 16 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR |
                  AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
@@ -1946,9 +1974,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 6, 0, 4, 12, 5, 11, 1 },       /* X */
-            { 0, 6, 2, 4, 12, 5, 11, 3 },       /* Y */
-            { 0, 6, 4, 4, 12, 5, 11, 5 },       /* Z */
+            { 0, 6, 0, 4, 12 },       /* X */
+            { 0, 6, 2, 4, 12 },       /* Y */
+            { 0, 6, 4, 4, 12 },       /* Z */
       },
       /*.flags = -- not used*/
     },
@@ -1958,9 +1986,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 6, 0, 4, 12, 5, 11, 1 },       /* X */
-            { 0, 6, 2, 4, 12, 5, 11, 3 },       /* Y */
-            { 0, 6, 4, 4, 12, 5, 11, 5 },       /* Z */
+            { 0, 6, 0, 4, 12 },       /* X */
+            { 0, 6, 2, 4, 12 },       /* Y */
+            { 0, 6, 4, 4, 12 },       /* Z */
        },
         .flags = AV_PIX_FMT_FLAG_BE,
     },
@@ -1970,9 +1998,9 @@
         .log2_chroma_w= 0, \
         .log2_chroma_h= 0, \
         .comp = {          \
-            {0,1,0,0,2,0,1,1},\
-            {0,1,0,0,4,0,3,1},\
-            {0,1,0,0,2,0,1,1},\
+            { 0, 1, 0, 0, 2 }, \
+            { 0, 1, 0, 0, 4 }, \
+            { 0, 1, 0, 0, 2 }, \
         },                 \
 
 #define BAYER16_DESC_COMMON \
@@ -1980,9 +2008,9 @@
         .log2_chroma_w= 0, \
         .log2_chroma_h= 0, \
         .comp = {          \
-            {0,2,0,0,4,1,3,1},\
-            {0,2,0,0,8,1,7,1},\
-            {0,2,0,0,4,1,3,1},\
+            { 0, 2, 0, 0, 4 }, \
+            { 0, 2, 0, 0, 8 }, \
+            { 0, 2, 0, 0, 4 }, \
         },                 \
 
     [AV_PIX_FMT_BAYER_BGGR8] = {
@@ -2051,9 +2079,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 2, 0, 0, 8, 1, 7, 1 },        /* U */
-            { 1, 2, 1, 0, 8, 1, 7, 2 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 2, 0, 0, 8 },        /* U */
+            { 1, 2, 1, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -2063,9 +2091,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 4, 0, 0, 10, 3, 9, 1 },        /* U */
-            { 1, 4, 2, 0, 10, 3, 9, 3 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 4, 0, 0, 10 },        /* U */
+            { 1, 4, 2, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -2075,9 +2103,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 10, 1, 9, 1 },        /* Y */
-            { 1, 4, 0, 0, 10, 3, 9, 1 },        /* U */
-            { 1, 4, 2, 0, 10, 3, 9, 3 },        /* V */
+            { 0, 2, 0, 0, 10 },        /* Y */
+            { 1, 4, 0, 0, 10 },        /* U */
+            { 1, 4, 2, 0, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
     },
@@ -2103,10 +2131,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 8, 2, 0, 16, 7, 15, 3 },        /* Y */
-            { 0, 8, 4, 0, 16, 7, 15, 5 },        /* U */
-            { 0, 8, 6, 0, 16, 7, 15, 7 },        /* V */
-            { 0, 8, 0, 0, 16, 7, 15, 1 },        /* A */
+            { 0, 8, 2, 0, 16 },        /* Y */
+            { 0, 8, 4, 0, 16 },        /* U */
+            { 0, 8, 6, 0, 16 },        /* V */
+            { 0, 8, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -2116,10 +2144,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 8, 2, 0, 16, 7, 15, 3 },        /* Y */
-            { 0, 8, 4, 0, 16, 7, 15, 5 },        /* U */
-            { 0, 8, 6, 0, 16, 7, 15, 7 },        /* V */
-            { 0, 8, 0, 0, 16, 7, 15, 1 },        /* A */
+            { 0, 8, 2, 0, 16 },        /* Y */
+            { 0, 8, 4, 0, 16 },        /* U */
+            { 0, 8, 6, 0, 16 },        /* V */
+            { 0, 8, 0, 0, 16 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -2129,9 +2157,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 6, 10, 1, 9, 1 },        /* Y */
-            { 1, 4, 0, 6, 10, 3, 9, 1 },        /* U */
-            { 1, 4, 2, 6, 10, 3, 9, 3 },        /* V */
+            { 0, 2, 0, 6, 10 },        /* Y */
+            { 1, 4, 0, 6, 10 },        /* U */
+            { 1, 4, 2, 6, 10 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -2141,9 +2169,33 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 6, 10, 1, 9, 1 },        /* Y */
-            { 1, 4, 0, 6, 10, 3, 9, 1 },        /* U */
-            { 1, 4, 2, 6, 10, 3, 9, 3 },        /* V */
+            { 0, 2, 0, 6, 10 },        /* Y */
+            { 1, 4, 0, 6, 10 },        /* U */
+            { 1, 4, 2, 6, 10 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_P012LE] = {
+        .name = "p012le",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .comp = {
+            { 0, 2, 0, 4, 12 },        /* Y */
+            { 1, 4, 0, 4, 12 },        /* U */
+            { 1, 4, 2, 4, 12 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR,
+    },
+    [AV_PIX_FMT_P012BE] = {
+        .name = "p012be",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .comp = {
+            { 0, 2, 0, 4, 12 },        /* Y */
+            { 1, 4, 0, 4, 12 },        /* U */
+            { 1, 4, 2, 4, 12 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
     },
@@ -2153,9 +2205,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* Y */
-            { 1, 4, 0, 0, 16, 3, 15, 1 },       /* U */
-            { 1, 4, 2, 0, 16, 3, 15, 3 },       /* V */
+            { 0, 2, 0, 0, 16 },       /* Y */
+            { 1, 4, 0, 0, 16 },       /* U */
+            { 1, 4, 2, 0, 16 },       /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -2165,9 +2217,9 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 1,
         .comp = {
-            { 0, 2, 0, 0, 16, 1, 15, 1 },       /* Y */
-            { 1, 4, 0, 0, 16, 3, 15, 1 },       /* U */
-            { 1, 4, 2, 0, 16, 3, 15, 3 },       /* V */
+            { 0, 2, 0, 0, 16 },       /* Y */
+            { 1, 4, 0, 0, 16 },       /* U */
+            { 1, 4, 2, 0, 16 },       /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
     },
@@ -2177,10 +2229,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 12, 1, 11, 1 },       /* R */
-            { 0, 2, 0, 0, 12, 1, 11, 1 },       /* G */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },       /* B */
-            { 3, 2, 0, 0, 12, 1, 11, 1 },       /* A */
+            { 2, 2, 0, 0, 12 },       /* R */
+            { 0, 2, 0, 0, 12 },       /* G */
+            { 1, 2, 0, 0, 12 },       /* B */
+            { 3, 2, 0, 0, 12 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB |
                  AV_PIX_FMT_FLAG_ALPHA,
@@ -2191,10 +2243,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 12, 1, 11, 1 },       /* R */
-            { 0, 2, 0, 0, 12, 1, 11, 1 },       /* G */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },       /* B */
-            { 3, 2, 0, 0, 12, 1, 11, 1 },       /* A */
+            { 2, 2, 0, 0, 12 },       /* R */
+            { 0, 2, 0, 0, 12 },       /* G */
+            { 1, 2, 0, 0, 12 },       /* B */
+            { 3, 2, 0, 0, 12 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR |
                  AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
@@ -2205,10 +2257,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 10, 1, 9, 1 },       /* R */
-            { 0, 2, 0, 0, 10, 1, 9, 1 },       /* G */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },       /* B */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },       /* A */
+            { 2, 2, 0, 0, 10 },       /* R */
+            { 0, 2, 0, 0, 10 },       /* G */
+            { 1, 2, 0, 0, 10 },       /* B */
+            { 3, 2, 0, 0, 10 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB |
                  AV_PIX_FMT_FLAG_ALPHA,
@@ -2219,10 +2271,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 2, 0, 0, 10, 1, 9, 1 },       /* R */
-            { 0, 2, 0, 0, 10, 1, 9, 1 },       /* G */
-            { 1, 2, 0, 0, 10, 1, 9, 1 },       /* B */
-            { 3, 2, 0, 0, 10, 1, 9, 1 },       /* A */
+            { 2, 2, 0, 0, 10 },       /* R */
+            { 0, 2, 0, 0, 10 },       /* G */
+            { 1, 2, 0, 0, 10 },       /* B */
+            { 3, 2, 0, 0, 10 },       /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR |
                  AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA,
@@ -2237,9 +2289,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 4, 0, 0, 32, 3, 31, 1 },        /* R */
-            { 0, 4, 0, 0, 32, 3, 31, 1 },        /* G */
-            { 1, 4, 0, 0, 32, 3, 31, 1 },        /* B */
+            { 2, 4, 0, 0, 32 },        /* R */
+            { 0, 4, 0, 0, 32 },        /* G */
+            { 1, 4, 0, 0, 32 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR |
                  AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
@@ -2250,9 +2302,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 4, 0, 0, 32, 3, 31, 1 },        /* R */
-            { 0, 4, 0, 0, 32, 3, 31, 1 },        /* G */
-            { 1, 4, 0, 0, 32, 3, 31, 1 },        /* B */
+            { 2, 4, 0, 0, 32 },        /* R */
+            { 0, 4, 0, 0, 32 },        /* G */
+            { 1, 4, 0, 0, 32 },        /* B */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_FLOAT | AV_PIX_FMT_FLAG_RGB,
     },
@@ -2262,10 +2314,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 4, 0, 0, 32, 3, 31, 1 },        /* R */
-            { 0, 4, 0, 0, 32, 3, 31, 1 },        /* G */
-            { 1, 4, 0, 0, 32, 3, 31, 1 },        /* B */
-            { 3, 4, 0, 0, 32, 3, 31, 1 },        /* A */
+            { 2, 4, 0, 0, 32 },        /* R */
+            { 0, 4, 0, 0, 32 },        /* G */
+            { 1, 4, 0, 0, 32 },        /* B */
+            { 3, 4, 0, 0, 32 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR |
                  AV_PIX_FMT_FLAG_ALPHA | AV_PIX_FMT_FLAG_RGB |
@@ -2277,10 +2329,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 2, 4, 0, 0, 32, 3, 31, 1 },        /* R */
-            { 0, 4, 0, 0, 32, 3, 31, 1 },        /* G */
-            { 1, 4, 0, 0, 32, 3, 31, 1 },        /* B */
-            { 3, 4, 0, 0, 32, 3, 31, 1 },        /* A */
+            { 2, 4, 0, 0, 32 },        /* R */
+            { 0, 4, 0, 0, 32 },        /* G */
+            { 1, 4, 0, 0, 32 },        /* B */
+            { 3, 4, 0, 0, 32 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA |
                  AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
@@ -2299,7 +2351,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 0, 0, 32, 3, 31, 1 },       /* Y */
+            { 0, 4, 0, 0, 32 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_FLOAT,
         .alias = "yf32be",
@@ -2310,7 +2362,7 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 4, 0, 0, 32, 3, 31, 1 },       /* Y */
+            { 0, 4, 0, 0, 32 },       /* Y */
         },
         .flags = AV_PIX_FMT_FLAG_FLOAT,
         .alias = "yf32le",
@@ -2321,10 +2373,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
-            { 3, 2, 0, 0, 12, 1, 11, 1 },        /* A */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
+            { 3, 2, 0, 0, 12 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -2334,10 +2386,10 @@
         .log2_chroma_w = 1,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
-            { 3, 2, 0, 0, 12, 1, 11, 1 },        /* A */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
+            { 3, 2, 0, 0, 12 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -2347,10 +2399,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
-            { 3, 2, 0, 0, 12, 1, 11, 1 },        /* A */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
+            { 3, 2, 0, 0, 12 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -2360,10 +2412,10 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 2, 0, 0, 12, 1, 11, 1 },        /* Y */
-            { 1, 2, 0, 0, 12, 1, 11, 1 },        /* U */
-            { 2, 2, 0, 0, 12, 1, 11, 1 },        /* V */
-            { 3, 2, 0, 0, 12, 1, 11, 1 },        /* A */
+            { 0, 2, 0, 0, 12 },        /* Y */
+            { 1, 2, 0, 0, 12 },        /* U */
+            { 2, 2, 0, 0, 12 },        /* V */
+            { 3, 2, 0, 0, 12 },        /* A */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_ALPHA,
     },
@@ -2373,9 +2425,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 2, 0, 0, 8, 1, 7, 1 },        /* U */
-            { 1, 2, 1, 0, 8, 1, 7, 2 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 2, 0, 0, 8 },        /* U */
+            { 1, 2, 1, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -2385,9 +2437,9 @@
         .log2_chroma_w = 0,
         .log2_chroma_h = 0,
         .comp = {
-            { 0, 1, 0, 0, 8, 0, 7, 1 },        /* Y */
-            { 1, 2, 1, 0, 8, 1, 7, 2 },        /* U */
-            { 1, 2, 0, 0, 8, 1, 7, 1 },        /* V */
+            { 0, 1, 0, 0, 8 },        /* Y */
+            { 1, 2, 1, 0, 8 },        /* U */
+            { 1, 2, 0, 0, 8 },        /* V */
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
@@ -2395,10 +2447,277 @@
         .name = "vulkan",
         .flags = AV_PIX_FMT_FLAG_HWACCEL,
     },
+    [AV_PIX_FMT_P210BE] = {
+        .name = "p210be",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 6, 10 },        /* Y */
+            { 1, 4, 0, 6, 10 },        /* U */
+            { 1, 4, 2, 6, 10 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_P210LE] = {
+        .name = "p210le",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 6, 10 },        /* Y */
+            { 1, 4, 0, 6, 10 },        /* U */
+            { 1, 4, 2, 6, 10 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR,
+    },
+    [AV_PIX_FMT_P410BE] = {
+        .name = "p410be",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 6, 10 },        /* Y */
+            { 1, 4, 0, 6, 10 },        /* U */
+            { 1, 4, 2, 6, 10 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_P410LE] = {
+        .name = "p410le",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 6, 10 },        /* Y */
+            { 1, 4, 0, 6, 10 },        /* U */
+            { 1, 4, 2, 6, 10 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR,
+    },
+    [AV_PIX_FMT_P216BE] = {
+        .name = "p216be",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 4, 0, 0, 16 },        /* U */
+            { 1, 4, 2, 0, 16 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_P216LE] = {
+        .name = "p216le",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 4, 0, 0, 16 },        /* U */
+            { 1, 4, 2, 0, 16 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR,
+    },
+    [AV_PIX_FMT_P416BE] = {
+        .name = "p416be",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 4, 0, 0, 16 },        /* U */
+            { 1, 4, 2, 0, 16 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_P416LE] = {
+        .name = "p416le",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 2, 0, 0, 16 },        /* Y */
+            { 1, 4, 0, 0, 16 },        /* U */
+            { 1, 4, 2, 0, 16 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR,
+    },
+    [AV_PIX_FMT_VUYA] = {
+        .name = "vuya",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 4, 2, 0, 8 },        /* Y */
+            { 0, 4, 1, 0, 8 },        /* U */
+            { 0, 4, 0, 0, 8 },        /* V */
+            { 0, 4, 3, 0, 8 },        /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_ALPHA,
+    },
+    [AV_PIX_FMT_VUYX] = {
+        .name = "vuyx",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 4, 2, 0, 8 },        /* Y */
+            { 0, 4, 1, 0, 8 },        /* U */
+            { 0, 4, 0, 0, 8 },        /* V */
+        },
+    },
+    [AV_PIX_FMT_RGBAF16BE] = {
+        .name = "rgbaf16be",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 8, 0, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 4, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB |
+                 AV_PIX_FMT_FLAG_ALPHA | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_RGBAF16LE] = {
+        .name = "rgbaf16le",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 8, 0, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 4, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA |
+                 AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_Y212LE] = {
+        .name = "y212le",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 4, 0, 4, 12 },        /* Y */
+            { 0, 8, 2, 4, 12 },        /* U */
+            { 0, 8, 6, 4, 12 },        /* V */
+        },
+    },
+    [AV_PIX_FMT_Y212BE] = {
+        .name = "y212be",
+        .nb_components = 3,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 4, 0, 4, 12 },        /* Y */
+            { 0, 8, 2, 4, 12 },        /* U */
+            { 0, 8, 6, 4, 12 },        /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_XV30LE] = {
+        .name = "xv30le",
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            { 0, 4, 1, 2, 10 },       /* Y */
+            { 0, 4, 0, 0, 10 },       /* U */
+            { 0, 4, 2, 4, 10 },       /* V */
+        },
+    },
+    [AV_PIX_FMT_XV30BE] = {
+        .name = "xv30be",
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            { 0, 32, 10, 0, 10 },       /* Y */
+            { 0, 32,  0, 0, 10 },       /* U */
+            { 0, 32, 20, 0, 10 },       /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_BITSTREAM,
+    },
+    [AV_PIX_FMT_XV36LE] = {
+        .name = "xv36le",
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            { 0, 8, 2, 4, 12 },       /* Y */
+            { 0, 8, 0, 4, 12 },       /* U */
+            { 0, 8, 4, 4, 12 },       /* V */
+        },
+    },
+    [AV_PIX_FMT_XV36BE] = {
+        .name = "xv36be",
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            { 0, 8, 2, 4, 12 },       /* Y */
+            { 0, 8, 0, 4, 12 },       /* U */
+            { 0, 8, 4, 4, 12 },       /* V */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE,
+    },
+    [AV_PIX_FMT_RGBF32BE] = {
+        .name = "rgbf32be",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 12, 0, 0, 32 },       /* R */
+            { 0, 12, 4, 0, 32 },       /* G */
+            { 0, 12, 8, 0, 32 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB |
+                 AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_RGBF32LE] = {
+        .name = "rgbf32le",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 12, 0, 0, 32 },       /* R */
+            { 0, 12, 4, 0, 32 },       /* G */
+            { 0, 12, 8, 0, 32 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_RGBAF32BE] = {
+        .name = "rgbaf32be",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 16,  0, 0, 32 },      /* R */
+            { 0, 16,  4, 0, 32 },      /* G */
+            { 0, 16,  8, 0, 32 },      /* B */
+            { 0, 16, 12, 0, 32 },      /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB |
+                 AV_PIX_FMT_FLAG_FLOAT | AV_PIX_FMT_FLAG_ALPHA,
+    },
+    [AV_PIX_FMT_RGBAF32LE] = {
+        .name = "rgbaf32le",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 16,  0, 0, 32 },      /* R */
+            { 0, 16,  4, 0, 32 },      /* G */
+            { 0, 16,  8, 0, 32 },      /* B */
+            { 0, 16, 12, 0, 32 },      /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT |
+                 AV_PIX_FMT_FLAG_ALPHA,
+    },
 };
-#if FF_API_PLUS1_MINUS1
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
 static const char * const color_range_names[] = {
     [AVCOL_RANGE_UNSPECIFIED] = "unknown",
@@ -2515,10 +2834,6 @@
         pix_fmt = get_pix_fmt_internal(name2);
     }
 
-#if FF_API_VAAPI
-    if (pix_fmt == AV_PIX_FMT_NONE && !strcmp(name, "vaapi"))
-        pix_fmt = AV_PIX_FMT_VAAPI;
-#endif
     return pix_fmt;
 }
 
@@ -2625,47 +2940,6 @@
     return ret;
 }
 
-void ff_check_pixfmt_descriptors(void){
-    int i, j;
-
-    for (i=0; i<FF_ARRAY_ELEMS(av_pix_fmt_descriptors); i++) {
-        const AVPixFmtDescriptor *d = &av_pix_fmt_descriptors[i];
-        uint8_t fill[4][8+6+3] = {{0}};
-        uint8_t *data[4] = {fill[0], fill[1], fill[2], fill[3]};
-        int linesize[4] = {0,0,0,0};
-        uint16_t tmp[2];
-
-        if (!d->name && !d->nb_components && !d->log2_chroma_w && !d->log2_chroma_h && !d->flags)
-            continue;
-//         av_log(NULL, AV_LOG_DEBUG, "Checking: %s\n", d->name);
-        av_assert0(d->log2_chroma_w <= 3);
-        av_assert0(d->log2_chroma_h <= 3);
-        av_assert0(d->nb_components <= 4);
-        av_assert0(d->name && d->name[0]);
-        av_assert2(av_get_pix_fmt(d->name) == i);
-
-        for (j=0; j<FF_ARRAY_ELEMS(d->comp); j++) {
-            const AVComponentDescriptor *c = &d->comp[j];
-            if(j>=d->nb_components) {
-                av_assert0(!c->plane && !c->step && !c->offset && !c->shift && !c->depth);
-                continue;
-            }
-            if (d->flags & AV_PIX_FMT_FLAG_BITSTREAM) {
-                av_assert0(c->step >= c->depth);
-            } else {
-                av_assert0(8*c->step >= c->depth);
-            }
-            if (d->flags & AV_PIX_FMT_FLAG_BAYER)
-                continue;
-            av_read_image_line(tmp, (void*)data, linesize, d, 0, 0, j, 2, 0);
-            av_assert0(tmp[0] == 0 && tmp[1] == 0);
-            tmp[0] = tmp[1] = (1ULL << c->depth) - 1;
-            av_write_image_line(tmp, data, linesize, d, 0, 0, j, 2);
-        }
-    }
-}
-
-
 enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
@@ -2779,9 +3053,16 @@
 
     for (i = 0; i < nb_components; i++) {
         int depth_minus1 = (dst_pix_fmt == AV_PIX_FMT_PAL8) ? 7/nb_components : (dst_desc->comp[i].depth - 1);
-        if (src_desc->comp[i].depth - 1 > depth_minus1 && (consider & FF_LOSS_DEPTH)) {
+        int depth_delta = src_desc->comp[i].depth - 1 - depth_minus1;
+        if (depth_delta > 0 && (consider & FF_LOSS_DEPTH)) {
             loss |= FF_LOSS_DEPTH;
             score -= 65536 >> depth_minus1;
+        } else if (depth_delta < 0 && (consider & FF_LOSS_EXCESS_DEPTH)) {
+            // Favour formats where bit depth exactly matches. If all other
+            // scoring is equal, we'd rather use the bit depth that most closely
+            // matches the source.
+            loss |= FF_LOSS_EXCESS_DEPTH;
+            score += depth_delta;
         }
     }
 
@@ -2801,6 +3082,28 @@
         }
     }
 
+    if (consider & FF_LOSS_EXCESS_RESOLUTION) {
+        // Favour formats where chroma subsampling exactly matches. If all other
+        // scoring is equal, we'd rather use the subsampling that most closely
+        // matches the source.
+        if (dst_desc->log2_chroma_w < src_desc->log2_chroma_w) {
+            loss |= FF_LOSS_EXCESS_RESOLUTION;
+            score -= 1 << (src_desc->log2_chroma_w - dst_desc->log2_chroma_w);
+        }
+
+        if (dst_desc->log2_chroma_h < src_desc->log2_chroma_h) {
+            loss |= FF_LOSS_EXCESS_RESOLUTION;
+            score -= 1 << (src_desc->log2_chroma_h - dst_desc->log2_chroma_h);
+        }
+
+        // don't favour 411 over 420, because 420 has much better support on the
+        // decoder side.
+        if (dst_desc->log2_chroma_w == 1 && src_desc->log2_chroma_w == 2 &&
+            dst_desc->log2_chroma_h == 1 && src_desc->log2_chroma_h == 2) {
+                score += 4;
+            }
+    }
+
     if(consider & FF_LOSS_COLORSPACE)
     switch(dst_color) {
     case FF_COLOR_RGB:
@@ -2999,3 +3302,26 @@
 
     return AVERROR(EINVAL);
 }
+
+int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
+{
+    if (pos <= AVCHROMA_LOC_UNSPECIFIED || pos >= AVCHROMA_LOC_NB)
+        return AVERROR(EINVAL);
+    pos--;
+
+    *xpos = (pos&1) * 128;
+    *ypos = ((pos>>1)^(pos<4)) * 128;
+
+    return 0;
+}
+
+enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos)
+{
+    int pos, xout, yout;
+
+    for (pos = AVCHROMA_LOC_UNSPECIFIED + 1; pos < AVCHROMA_LOC_NB; pos++) {
+        if (av_chroma_location_enum_to_pos(&xout, &yout, pos) == 0 && xout == xpos && yout == ypos)
+            return pos;
+    }
+    return AVCHROMA_LOC_UNSPECIFIED;
+}
diff -Naur a/media/ffvpx/libavutil/pixdesc.h b/media/ffvpx/libavutil/pixdesc.h
--- a/media/ffvpx/libavutil/pixdesc.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/pixdesc.h	2023-04-06 12:50:06.977471295 +0200
@@ -26,7 +26,6 @@
 
 #include "attributes.h"
 #include "pixfmt.h"
-#include "version.h"
 
 typedef struct AVComponentDescriptor {
     /**
@@ -56,17 +55,6 @@
      * Number of bits in the component.
      */
     int depth;
-
-#if FF_API_PLUS1_MINUS1
-    /** deprecated, use step instead */
-    attribute_deprecated int step_minus1;
-
-    /** deprecated, use depth instead */
-    attribute_deprecated int depth_minus1;
-
-    /** deprecated, use offset instead */
-    attribute_deprecated int offset_plus1;
-#endif
 } AVComponentDescriptor;
 
 /**
@@ -147,26 +135,6 @@
  */
 #define AV_PIX_FMT_FLAG_RGB          (1 << 5)
 
-#if FF_API_PSEUDOPAL
-/**
- * The pixel format is "pseudo-paletted". This means that it contains a
- * fixed palette in the 2nd plane but the palette is fixed/constant for each
- * PIX_FMT. This allows interpreting the data as if it was PAL8, which can
- * in some cases be simpler. Or the data can be interpreted purely based on
- * the pixel format without using the palette.
- * An example of a pseudo-paletted format is AV_PIX_FMT_GRAY8
- *
- * @deprecated This flag is deprecated, and will be removed. When it is removed,
- * the extra palette allocation in AVFrame.data[1] is removed as well. Only
- * actual paletted formats (as indicated by AV_PIX_FMT_FLAG_PAL) will have a
- * palette. Starting with FFmpeg versions which have this flag deprecated, the
- * extra "pseudo" palette is already ignored, and API users are not required to
- * allocate a palette for AV_PIX_FMT_FLAG_PSEUDOPAL formats (it was required
- * before the deprecation, though).
- */
-#define AV_PIX_FMT_FLAG_PSEUDOPAL    (1 << 6)
-#endif
-
 /**
  * The pixel format has an alpha channel. This is set on all formats that
  * support alpha in some way, including AV_PIX_FMT_PAL8. The alpha is always
@@ -297,6 +265,28 @@
 int av_chroma_location_from_name(const char *name);
 
 /**
+ * Converts AVChromaLocation to swscale x/y chroma position.
+ *
+ * The positions represent the chroma (0,0) position in a coordinates system
+ * with luma (0,0) representing the origin and luma(1,1) representing 256,256
+ *
+ * @param xpos  horizontal chroma sample position
+ * @param ypos  vertical   chroma sample position
+ */
+int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
+
+/**
+ * Converts swscale x/y chroma position to AVChromaLocation.
+ *
+ * The positions represent the chroma (0,0) position in a coordinates system
+ * with luma (0,0) representing the origin and luma(1,1) representing 256,256
+ *
+ * @param xpos  horizontal chroma sample position
+ * @param ypos  vertical   chroma sample position
+ */
+enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos);
+
+/**
  * Return the pixel format corresponding to name.
  *
  * If there is no pixel format with name name, then looks for a
@@ -389,12 +379,15 @@
  */
 enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt);
 
-#define FF_LOSS_RESOLUTION  0x0001 /**< loss due to resolution change */
-#define FF_LOSS_DEPTH       0x0002 /**< loss due to color depth change */
-#define FF_LOSS_COLORSPACE  0x0004 /**< loss due to color space conversion */
-#define FF_LOSS_ALPHA       0x0008 /**< loss of alpha bits */
-#define FF_LOSS_COLORQUANT  0x0010 /**< loss due to color quantization */
-#define FF_LOSS_CHROMA      0x0020 /**< loss of chroma (e.g. RGB to gray conversion) */
+#define FF_LOSS_RESOLUTION        0x0001 /**< loss due to resolution change */
+#define FF_LOSS_DEPTH             0x0002 /**< loss due to color depth change */
+#define FF_LOSS_COLORSPACE        0x0004 /**< loss due to color space conversion */
+#define FF_LOSS_ALPHA             0x0008 /**< loss of alpha bits */
+#define FF_LOSS_COLORQUANT        0x0010 /**< loss due to color quantization */
+#define FF_LOSS_CHROMA            0x0020 /**< loss of chroma (e.g. RGB to gray conversion) */
+#define FF_LOSS_EXCESS_RESOLUTION 0x0040 /**< loss due to unneeded extra resolution */
+#define FF_LOSS_EXCESS_DEPTH      0x0080 /**< loss due to unneeded extra color depth */
+
 
 /**
  * Compute what kind of losses will occur when converting from one specific
diff -Naur a/media/ffvpx/libavutil/pixelutils.c b/media/ffvpx/libavutil/pixelutils.c
--- a/media/ffvpx/libavutil/pixelutils.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/pixelutils.c	2023-04-06 12:49:40.262395253 +0200
@@ -16,12 +16,17 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stddef.h>
+
 #include "config.h"
-#include "common.h"
 #include "pixelutils.h"
-#include "internal.h"
 
 #if CONFIG_PIXELUTILS
+#include <stdlib.h>
+#include <string.h>
+
+#include "attributes.h"
+#include "macros.h"
 
 #include "x86/pixelutils.h"
 
@@ -60,7 +65,8 @@
     block_sad_16x16_c,
     block_sad_32x32_c,
 };
-
+#else
+#include "log.h"
 #endif /* CONFIG_PIXELUTILS */
 
 av_pixelutils_sad_fn av_pixelutils_get_sad_fn(int w_bits, int h_bits, int aligned, void *log_ctx)
diff -Naur a/media/ffvpx/libavutil/pixelutils.h b/media/ffvpx/libavutil/pixelutils.h
--- a/media/ffvpx/libavutil/pixelutils.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/pixelutils.h	2023-04-06 12:49:40.262395253 +0200
@@ -21,7 +21,6 @@
 
 #include <stddef.h>
 #include <stdint.h>
-#include "common.h"
 
 /**
  * Sum of abs(src1[x] - src2[x])
diff -Naur a/media/ffvpx/libavutil/pixfmt.h b/media/ffvpx/libavutil/pixfmt.h
--- a/media/ffvpx/libavutil/pixfmt.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/pixfmt.h	2023-04-06 12:50:24.494176623 +0200
@@ -112,21 +112,11 @@
     AV_PIX_FMT_BGR555BE,  ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined
     AV_PIX_FMT_BGR555LE,  ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined
 
-#if FF_API_VAAPI
-    /** @name Deprecated pixel formats */
-    /**@{*/
-    AV_PIX_FMT_VAAPI_MOCO, ///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
-    AV_PIX_FMT_VAAPI_IDCT, ///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
-    AV_PIX_FMT_VAAPI_VLD,  ///< HW decoding through VA API, Picture.data[3] contains a VASurfaceID
-    /**@}*/
-    AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,
-#else
     /**
      *  Hardware acceleration through VA-API, data[3] contains a
      *  VASurfaceID.
      */
     AV_PIX_FMT_VAAPI,
-#endif
 
     AV_PIX_FMT_YUV420P16LE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
     AV_PIX_FMT_YUV420P16BE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
@@ -216,8 +206,36 @@
     AV_PIX_FMT_GBRAP16BE,    ///< planar GBRA 4:4:4:4 64bpp, big-endian
     AV_PIX_FMT_GBRAP16LE,    ///< planar GBRA 4:4:4:4 64bpp, little-endian
     /**
-     *  HW acceleration through QSV, data[3] contains a pointer to the
-     *  mfxFrameSurface1 structure.
+     * HW acceleration through QSV, data[3] contains a pointer to the
+     * mfxFrameSurface1 structure.
+     *
+     * Before FFmpeg 5.0:
+     * mfxFrameSurface1.Data.MemId contains a pointer when importing
+     * the following frames as QSV frames:
+     *
+     * VAAPI:
+     * mfxFrameSurface1.Data.MemId contains a pointer to VASurfaceID
+     *
+     * DXVA2:
+     * mfxFrameSurface1.Data.MemId contains a pointer to IDirect3DSurface9
+     *
+     * FFmpeg 5.0 and above:
+     * mfxFrameSurface1.Data.MemId contains a pointer to the mfxHDLPair
+     * structure when importing the following frames as QSV frames:
+     *
+     * VAAPI:
+     * mfxHDLPair.first contains a VASurfaceID pointer.
+     * mfxHDLPair.second is always MFX_INFINITE.
+     *
+     * DXVA2:
+     * mfxHDLPair.first contains IDirect3DSurface9 pointer.
+     * mfxHDLPair.second is always MFX_INFINITE.
+     *
+     * D3D11:
+     * mfxHDLPair.first contains a ID3D11Texture2D pointer.
+     * mfxHDLPair.second contains the texture array index of the frame if the
+     * ID3D11Texture2D is an array texture, or always MFX_INFINITE if it is a
+     * normal texture.
      */
     AV_PIX_FMT_QSV,
     /**
@@ -270,7 +288,9 @@
     AV_PIX_FMT_BAYER_GRBG16LE, ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian
     AV_PIX_FMT_BAYER_GRBG16BE, ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian
 
+#if FF_API_XVMC
     AV_PIX_FMT_XVMC,///< XVideo Motion Acceleration via common packet passing
+#endif
 
     AV_PIX_FMT_YUV440P10LE, ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
     AV_PIX_FMT_YUV440P10BE, ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
@@ -360,6 +380,46 @@
 
     AV_PIX_FMT_X2RGB10LE, ///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined
     AV_PIX_FMT_X2RGB10BE, ///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined
+    AV_PIX_FMT_X2BGR10LE, ///< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), little-endian, X=unused/undefined
+    AV_PIX_FMT_X2BGR10BE, ///< packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), big-endian, X=unused/undefined
+
+    AV_PIX_FMT_P210BE,      ///< interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, big-endian
+    AV_PIX_FMT_P210LE,      ///< interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, little-endian
+
+    AV_PIX_FMT_P410BE,      ///< interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, big-endian
+    AV_PIX_FMT_P410LE,      ///< interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, little-endian
+
+    AV_PIX_FMT_P216BE,      ///< interleaved chroma YUV 4:2:2, 32bpp, big-endian
+    AV_PIX_FMT_P216LE,      ///< interleaved chroma YUV 4:2:2, 32bpp, little-endian
+
+    AV_PIX_FMT_P416BE,      ///< interleaved chroma YUV 4:4:4, 48bpp, big-endian
+    AV_PIX_FMT_P416LE,      ///< interleaved chroma YUV 4:4:4, 48bpp, little-endian
+
+    AV_PIX_FMT_VUYA,        ///< packed VUYA 4:4:4, 32bpp, VUYAVUYA...
+
+    AV_PIX_FMT_RGBAF16BE,   ///< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., big-endian
+    AV_PIX_FMT_RGBAF16LE,   ///< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., little-endian
+
+    AV_PIX_FMT_VUYX,        ///< packed VUYX 4:4:4, 32bpp, Variant of VUYA where alpha channel is left undefined
+
+    AV_PIX_FMT_P012LE,      ///< like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, little-endian
+    AV_PIX_FMT_P012BE,      ///< like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, big-endian
+
+    AV_PIX_FMT_Y212BE,      ///< packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, big-endian
+    AV_PIX_FMT_Y212LE,      ///< packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, little-endian
+
+    AV_PIX_FMT_XV30BE,      ///< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), big-endian, variant of Y410 where alpha channel is left undefined
+    AV_PIX_FMT_XV30LE,      ///< packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), little-endian, variant of Y410 where alpha channel is left undefined
+
+    AV_PIX_FMT_XV36BE,      ///< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, big-endian, variant of Y412 where alpha channel is left undefined
+    AV_PIX_FMT_XV36LE,      ///< packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, little-endian, variant of Y412 where alpha channel is left undefined
+
+    AV_PIX_FMT_RGBF32BE,    ///< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., big-endian
+    AV_PIX_FMT_RGBF32LE,    ///< IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., little-endian
+
+    AV_PIX_FMT_RGBAF32BE,   ///< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., big-endian
+    AV_PIX_FMT_RGBAF32LE,   ///< IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., little-endian
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
@@ -446,39 +506,54 @@
 #define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
 #define AV_PIX_FMT_AYUV64     AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
 #define AV_PIX_FMT_P010       AV_PIX_FMT_NE(P010BE,  P010LE)
+#define AV_PIX_FMT_P012       AV_PIX_FMT_NE(P012BE,  P012LE)
 #define AV_PIX_FMT_P016       AV_PIX_FMT_NE(P016BE,  P016LE)
 
 #define AV_PIX_FMT_Y210       AV_PIX_FMT_NE(Y210BE,  Y210LE)
+#define AV_PIX_FMT_Y212       AV_PIX_FMT_NE(Y212BE,  Y212LE)
+#define AV_PIX_FMT_XV30       AV_PIX_FMT_NE(XV30BE,  XV30LE)
+#define AV_PIX_FMT_XV36       AV_PIX_FMT_NE(XV36BE,  XV36LE)
 #define AV_PIX_FMT_X2RGB10    AV_PIX_FMT_NE(X2RGB10BE, X2RGB10LE)
+#define AV_PIX_FMT_X2BGR10    AV_PIX_FMT_NE(X2BGR10BE, X2BGR10LE)
+
+#define AV_PIX_FMT_P210       AV_PIX_FMT_NE(P210BE, P210LE)
+#define AV_PIX_FMT_P410       AV_PIX_FMT_NE(P410BE, P410LE)
+#define AV_PIX_FMT_P216       AV_PIX_FMT_NE(P216BE, P216LE)
+#define AV_PIX_FMT_P416       AV_PIX_FMT_NE(P416BE, P416LE)
+
+#define AV_PIX_FMT_RGBAF16    AV_PIX_FMT_NE(RGBAF16BE, RGBAF16LE)
+
+#define AV_PIX_FMT_RGBF32     AV_PIX_FMT_NE(RGBF32BE, RGBF32LE)
+#define AV_PIX_FMT_RGBAF32    AV_PIX_FMT_NE(RGBAF32BE, RGBAF32LE)
 
 /**
   * Chromaticity coordinates of the source primaries.
-  * These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1.
+  * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273.
   */
 enum AVColorPrimaries {
     AVCOL_PRI_RESERVED0   = 0,
-    AVCOL_PRI_BT709       = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B
+    AVCOL_PRI_BT709       = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B
     AVCOL_PRI_UNSPECIFIED = 2,
     AVCOL_PRI_RESERVED    = 3,
     AVCOL_PRI_BT470M      = 4,  ///< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
 
     AVCOL_PRI_BT470BG     = 5,  ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
     AVCOL_PRI_SMPTE170M   = 6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
-    AVCOL_PRI_SMPTE240M   = 7,  ///< functionally identical to above
+    AVCOL_PRI_SMPTE240M   = 7,  ///< identical to above, also called "SMPTE C" even though it uses D65
     AVCOL_PRI_FILM        = 8,  ///< colour filters using Illuminant C
     AVCOL_PRI_BT2020      = 9,  ///< ITU-R BT2020
     AVCOL_PRI_SMPTE428    = 10, ///< SMPTE ST 428-1 (CIE 1931 XYZ)
     AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
     AVCOL_PRI_SMPTE431    = 11, ///< SMPTE ST 431-2 (2011) / DCI P3
     AVCOL_PRI_SMPTE432    = 12, ///< SMPTE ST 432-1 (2010) / P3 D65 / Display P3
-    AVCOL_PRI_EBU3213     = 22, ///< EBU Tech. 3213-E / JEDEC P22 phosphors
+    AVCOL_PRI_EBU3213     = 22, ///< EBU Tech. 3213-E (nothing there) / one of JEDEC P22 group phosphors
     AVCOL_PRI_JEDEC_P22   = AVCOL_PRI_EBU3213,
     AVCOL_PRI_NB                ///< Not part of ABI
 };
 
 /**
  * Color Transfer Characteristic.
- * These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2.
+ * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2.
  */
 enum AVColorTransferCharacteristic {
     AVCOL_TRC_RESERVED0    = 0,
@@ -507,18 +582,18 @@
 
 /**
  * YUV colorspace type.
- * These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3.
+ * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3.
  */
 enum AVColorSpace {
-    AVCOL_SPC_RGB         = 0,  ///< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)
-    AVCOL_SPC_BT709       = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B
+    AVCOL_SPC_RGB         = 0,  ///< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB), YZX and ST 428-1
+    AVCOL_SPC_BT709       = 1,  ///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / derived in SMPTE RP 177 Annex B
     AVCOL_SPC_UNSPECIFIED = 2,
-    AVCOL_SPC_RESERVED    = 3,
+    AVCOL_SPC_RESERVED    = 3,  ///< reserved for future use by ITU-T and ISO/IEC just like 15-255 are
     AVCOL_SPC_FCC         = 4,  ///< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
     AVCOL_SPC_BT470BG     = 5,  ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
-    AVCOL_SPC_SMPTE170M   = 6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
-    AVCOL_SPC_SMPTE240M   = 7,  ///< functionally identical to above
-    AVCOL_SPC_YCGCO       = 8,  ///< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
+    AVCOL_SPC_SMPTE170M   = 6,  ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above
+    AVCOL_SPC_SMPTE240M   = 7,  ///< derived from 170M primaries and D65 white point, 170M is derived from BT470 System M's primaries
+    AVCOL_SPC_YCGCO       = 8,  ///< used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
     AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,
     AVCOL_SPC_BT2020_NCL  = 9,  ///< ITU-R BT2020 non-constant luminance system
     AVCOL_SPC_BT2020_CL   = 10, ///< ITU-R BT2020 constant luminance system
@@ -540,9 +615,9 @@
  * recommended, as it also defines the full range representation.
  *
  * Common definitions:
- *   - For RGB and luminance planes such as Y in YCbCr and I in ICtCp,
+ *   - For RGB and luma planes such as Y in YCbCr and I in ICtCp,
  *     'E' is the original value in range of 0.0 to 1.0.
- *   - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original
+ *   - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original
  *     value in range of -0.5 to 0.5.
  *   - 'n' is the output bit depth.
  *   - For additional definitions such as rounding and clipping to valid n
@@ -554,13 +629,13 @@
     /**
      * Narrow or limited range content.
      *
-     * - For luminance planes:
+     * - For luma planes:
      *
      *       (219 * E + 16) * 2^(n-8)
      *
      *   F.ex. the range of 16-235 for 8 bits
      *
-     * - For chrominance planes:
+     * - For chroma planes:
      *
      *       (224 * E + 128) * 2^(n-8)
      *
@@ -571,13 +646,13 @@
     /**
      * Full range content.
      *
-     * - For RGB and luminance planes:
+     * - For RGB and luma planes:
      *
      *       (2^n - 1) * E
      *
      *   F.ex. the range of 0-255 for 8 bits
      *
-     * - For chrominance planes:
+     * - For chroma planes:
      *
      *       (2^n - 1) * E + 2^(n - 1)
      *
diff -Naur a/media/ffvpx/libavutil/qsort.h b/media/ffvpx/libavutil/qsort.h
--- a/media/ffvpx/libavutil/qsort.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/qsort.h	2023-04-06 12:49:40.262395253 +0200
@@ -21,7 +21,7 @@
 #ifndef AVUTIL_QSORT_H
 #define AVUTIL_QSORT_H
 
-#include "common.h"
+#include "macros.h"
 
 
 /**
diff -Naur a/media/ffvpx/libavutil/rational.h b/media/ffvpx/libavutil/rational.h
--- a/media/ffvpx/libavutil/rational.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/rational.h	2023-04-06 12:50:06.977471295 +0200
@@ -179,7 +179,8 @@
  * Find which of the two rationals is closer to another rational.
  *
  * @param q     Rational to be compared against
- * @param q1,q2 Rationals to be tested
+ * @param q1    Rational to be tested
+ * @param q2    Rational to be tested
  * @return One of the following values:
  *         - 1 if `q1` is nearer to `q` than `q2`
  *         - -1 if `q2` is nearer to `q` than `q1`
diff -Naur a/media/ffvpx/libavutil/samplefmt.c b/media/ffvpx/libavutil/samplefmt.c
--- a/media/ffvpx/libavutil/samplefmt.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/samplefmt.c	2023-04-06 12:49:40.262395253 +0200
@@ -16,11 +16,13 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "common.h"
+#include "error.h"
+#include "macros.h"
+#include "mem.h"
 #include "samplefmt.h"
 
+#include <limits.h>
 #include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 
 typedef struct SampleFmtInfo {
@@ -160,13 +162,20 @@
     if (buf_size < 0)
         return buf_size;
 
+    if (linesize)
+        *linesize = line_size;
+
+    memset(audio_data, 0, planar
+                          ? sizeof(*audio_data) * nb_channels
+                          : sizeof(*audio_data));
+
+    if (!buf)
+        return buf_size;
+
     audio_data[0] = (uint8_t *)buf;
     for (ch = 1; planar && ch < nb_channels; ch++)
         audio_data[ch] = audio_data[ch-1] + line_size;
 
-    if (linesize)
-        *linesize = line_size;
-
     return buf_size;
 }
 
diff -Naur a/media/ffvpx/libavutil/samplefmt.h b/media/ffvpx/libavutil/samplefmt.h
--- a/media/ffvpx/libavutil/samplefmt.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/samplefmt.h	2023-04-06 12:50:06.977471295 +0200
@@ -21,9 +21,6 @@
 
 #include <stdint.h>
 
-#include "avutil.h"
-#include "attributes.h"
-
 /**
  * @addtogroup lavu_audio
  * @{
@@ -195,9 +192,8 @@
  * @param nb_samples       the number of samples in a single channel
  * @param sample_fmt       the sample format
  * @param align            buffer size alignment (0 = default, 1 = no alignment)
- * @return                 >=0 on success or a negative error code on failure
- * @todo return minimum size in bytes required for the buffer in case
- * of success at the next bump
+ * @return                 minimum size in bytes required for the buffer on success,
+ *                         or a negative error code on failure
  */
 int av_samples_fill_arrays(uint8_t **audio_data, int *linesize,
                            const uint8_t *buf,
@@ -217,6 +213,7 @@
  * @param[out] linesize    aligned size for audio buffer(s), may be NULL
  * @param nb_channels      number of audio channels
  * @param nb_samples       number of samples per channel
+ * @param sample_fmt       the sample format
  * @param align            buffer size alignment (0 = default, 1 = no alignment)
  * @return                 >=0 on success or a negative error code on failure
  * @todo return the size of the allocated buffer in case of success at the next bump
diff -Naur a/media/ffvpx/libavutil/slicethread.c b/media/ffvpx/libavutil/slicethread.c
--- a/media/ffvpx/libavutil/slicethread.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/slicethread.c	2023-04-06 12:50:06.977471295 +0200
@@ -17,11 +17,15 @@
  */
 
 #include <stdatomic.h>
+#include "cpu.h"
+#include "internal.h"
 #include "slicethread.h"
 #include "mem.h"
 #include "thread.h"
 #include "avassert.h"
 
+#define MAX_AUTO_THREADS 16
+
 #if HAVE_PTHREADS || HAVE_W32THREADS || HAVE_OS2THREADS
 
 typedef struct WorkerContext {
@@ -103,7 +107,7 @@
     if (!nb_threads) {
         int nb_cpus = av_cpu_count();
         if (nb_cpus > 1)
-            nb_threads = nb_cpus + 1;
+            nb_threads = FFMIN(nb_cpus + 1, MAX_AUTO_THREADS);
         else
             nb_threads = 1;
     }
@@ -239,7 +243,7 @@
                               int nb_threads)
 {
     *pctx = NULL;
-    return AVERROR(EINVAL);
+    return AVERROR(ENOSYS);
 }
 
 void avpriv_slicethread_execute(AVSliceThread *ctx, int nb_jobs, int execute_main)
diff -Naur a/media/ffvpx/libavutil/thread.h b/media/ffvpx/libavutil/thread.h
--- a/media/ffvpx/libavutil/thread.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/thread.h	2023-04-06 12:50:06.977471295 +0200
@@ -24,6 +24,12 @@
 
 #include "config.h"
 
+#if HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
+
+#include "error.h"
+
 #if HAVE_PTHREADS || HAVE_W32THREADS || HAVE_OS2THREADS
 
 #if HAVE_PTHREADS
@@ -31,7 +37,10 @@
 
 #if defined(ASSERT_LEVEL) && ASSERT_LEVEL > 1
 
+#include <stdlib.h>
+
 #include "log.h"
+#include "macros.h"
 
 #define ASSERT_PTHREAD_ABORT(func, ret) do {                            \
     char errbuf[AV_ERROR_MAX_STRING_SIZE] = "";                         \
@@ -183,4 +192,13 @@
 
 #endif
 
+static inline int ff_thread_setname(const char *name)
+{
+#if HAVE_PRCTL
+    return AVERROR(prctl(PR_SET_NAME, name));
+#endif
+
+    return AVERROR(ENOSYS);
+}
+
 #endif /* AVUTIL_THREAD_H */
diff -Naur a/media/ffvpx/libavutil/threadmessage.c b/media/ffvpx/libavutil/threadmessage.c
--- a/media/ffvpx/libavutil/threadmessage.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/threadmessage.c	2023-04-06 12:49:40.262395253 +0200
@@ -18,13 +18,15 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <limits.h>
 #include "fifo.h"
+#include "mem.h"
 #include "threadmessage.h"
 #include "thread.h"
 
 struct AVThreadMessageQueue {
 #if HAVE_THREADS
-    AVFifoBuffer *fifo;
+    AVFifo *fifo;
     pthread_mutex_t lock;
     pthread_cond_t cond_recv;
     pthread_cond_t cond_send;
@@ -64,7 +66,7 @@
         av_free(rmq);
         return AVERROR(ret);
     }
-    if (!(rmq->fifo = av_fifo_alloc(elsize * nelem))) {
+    if (!(rmq->fifo = av_fifo_alloc2(nelem, elsize, 0))) {
         pthread_cond_destroy(&rmq->cond_send);
         pthread_cond_destroy(&rmq->cond_recv);
         pthread_mutex_destroy(&rmq->lock);
@@ -93,7 +95,7 @@
 #if HAVE_THREADS
     if (*mq) {
         av_thread_message_flush(*mq);
-        av_fifo_freep(&(*mq)->fifo);
+        av_fifo_freep2(&(*mq)->fifo);
         pthread_cond_destroy(&(*mq)->cond_send);
         pthread_cond_destroy(&(*mq)->cond_recv);
         pthread_mutex_destroy(&(*mq)->lock);
@@ -107,9 +109,9 @@
 #if HAVE_THREADS
     int ret;
     pthread_mutex_lock(&mq->lock);
-    ret = av_fifo_size(mq->fifo);
+    ret = av_fifo_can_read(mq->fifo);
     pthread_mutex_unlock(&mq->lock);
-    return ret / mq->elsize;
+    return ret;
 #else
     return AVERROR(ENOSYS);
 #endif
@@ -121,14 +123,14 @@
                                                void *msg,
                                                unsigned flags)
 {
-    while (!mq->err_send && av_fifo_space(mq->fifo) < mq->elsize) {
+    while (!mq->err_send && !av_fifo_can_write(mq->fifo)) {
         if ((flags & AV_THREAD_MESSAGE_NONBLOCK))
             return AVERROR(EAGAIN);
         pthread_cond_wait(&mq->cond_send, &mq->lock);
     }
     if (mq->err_send)
         return mq->err_send;
-    av_fifo_generic_write(mq->fifo, msg, mq->elsize, NULL);
+    av_fifo_write(mq->fifo, msg, 1);
     /* one message is sent, signal one receiver */
     pthread_cond_signal(&mq->cond_recv);
     return 0;
@@ -138,14 +140,14 @@
                                                void *msg,
                                                unsigned flags)
 {
-    while (!mq->err_recv && av_fifo_size(mq->fifo) < mq->elsize) {
+    while (!mq->err_recv && !av_fifo_can_read(mq->fifo)) {
         if ((flags & AV_THREAD_MESSAGE_NONBLOCK))
             return AVERROR(EAGAIN);
         pthread_cond_wait(&mq->cond_recv, &mq->lock);
     }
-    if (av_fifo_size(mq->fifo) < mq->elsize)
+    if (!av_fifo_can_read(mq->fifo))
         return mq->err_recv;
-    av_fifo_generic_read(mq->fifo, msg, mq->elsize, NULL);
+    av_fifo_read(mq->fifo, msg, 1);
     /* one message space appeared, signal one sender */
     pthread_cond_signal(&mq->cond_send);
     return 0;
@@ -208,25 +210,25 @@
 }
 
 #if HAVE_THREADS
-static void free_func_wrap(void *arg, void *msg, int size)
+static int free_func_wrap(void *arg, void *buf, size_t *nb_elems)
 {
     AVThreadMessageQueue *mq = arg;
-    mq->free_func(msg);
+    uint8_t *msg = buf;
+    for (size_t i = 0; i < *nb_elems; i++)
+        mq->free_func(msg + i * mq->elsize);
+    return 0;
 }
 #endif
 
 void av_thread_message_flush(AVThreadMessageQueue *mq)
 {
 #if HAVE_THREADS
-    int used, off;
-    void *free_func = mq->free_func;
+    size_t used;
 
     pthread_mutex_lock(&mq->lock);
-    used = av_fifo_size(mq->fifo);
-    if (free_func)
-        for (off = 0; off < used; off += mq->elsize)
-            av_fifo_generic_peek_at(mq->fifo, mq, off, mq->elsize, free_func_wrap);
-    av_fifo_drain(mq->fifo, used);
+    used = av_fifo_can_read(mq->fifo);
+    if (mq->free_func)
+        av_fifo_read_to_cb(mq->fifo, free_func_wrap, mq, &used);
     /* only the senders need to be notified since the queue is empty and there
      * is nothing to read */
     pthread_cond_broadcast(&mq->cond_send);
diff -Naur a/media/ffvpx/libavutil/time.c b/media/ffvpx/libavutil/time.c
--- a/media/ffvpx/libavutil/time.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/time.c	2023-04-06 12:50:20.234005184 +0200
@@ -33,7 +33,7 @@
 #include <windows.h>
 #endif
 
-#include "time.h"
+#include "fftime.h"
 #include "error.h"
 
 int64_t av_gettime(void)
diff -Naur a/media/ffvpx/libavutil/timecode.c b/media/ffvpx/libavutil/timecode.c
--- a/media/ffvpx/libavutil/timecode.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/timecode.c	2023-04-06 12:49:40.262395253 +0200
@@ -27,6 +27,7 @@
  */
 
 #include <stdio.h>
+#include "common.h"
 #include "timecode.h"
 #include "log.h"
 #include "error.h"
@@ -103,7 +104,7 @@
 {
     int fps = tc->fps;
     int drop = tc->flags & AV_TIMECODE_FLAG_DROPFRAME;
-    int hh, mm, ss, ff, neg = 0;
+    int hh, mm, ss, ff, ff_len, neg = 0;
 
     framenum += tc->start;
     if (drop)
@@ -118,9 +119,10 @@
     hh = framenum / (fps*3600LL);
     if (tc->flags & AV_TIMECODE_FLAG_24HOURSMAX)
         hh = hh % 24;
-    snprintf(buf, AV_TIMECODE_STR_SIZE, "%s%02d:%02d:%02d%c%02d",
+    ff_len = fps > 10000 ? 5 : fps > 1000 ? 4 : fps > 100 ? 3 : fps > 10 ? 2 : 1;
+    snprintf(buf, AV_TIMECODE_STR_SIZE, "%s%02d:%02d:%02d%c%0*d",
              neg ? "-" : "",
-             hh, mm, ss, drop ? ';' : ':', ff);
+             hh, mm, ss, drop ? ';' : ':', ff_len, ff);
     return buf;
 }
 
diff -Naur a/media/ffvpx/libavutil/timer.h b/media/ffvpx/libavutil/timer.h
--- a/media/ffvpx/libavutil/timer.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/timer.h	2023-04-06 12:50:06.977471295 +0200
@@ -42,10 +42,13 @@
 #include <stdint.h>
 #include <inttypes.h>
 
-#if HAVE_MACH_ABSOLUTE_TIME
+#if CONFIG_MACOS_KPERF
+#include "macos_kperf.h"
+#elif HAVE_MACH_ABSOLUTE_TIME
 #include <mach/mach_time.h>
 #endif
 
+#include "common.h"
 #include "log.h"
 
 #if   ARCH_AARCH64
@@ -54,6 +57,8 @@
 #   include "arm/timer.h"
 #elif ARCH_PPC
 #   include "ppc/timer.h"
+#elif ARCH_RISCV
+#   include "riscv/timer.h"
 #elif ARCH_X86
 #   include "x86/timer.h"
 #endif
@@ -125,6 +130,16 @@
     read(linux_perf_fd, &tperf, sizeof(tperf));                             \
     TIMER_REPORT(id, tperf)
 
+#elif CONFIG_MACOS_KPERF
+
+#define START_TIMER                                                         \
+    uint64_t tperf;                                                         \
+    ff_kperf_init();                                                        \
+    tperf = ff_kperf_cycles();
+
+#define STOP_TIMER(id)                                                      \
+    TIMER_REPORT(id, ff_kperf_cycles() - tperf);
+
 #elif defined(AV_READ_TIME)
 #define START_TIMER                             \
     uint64_t tend;                              \
diff -Naur a/media/ffvpx/libavutil/utils.c b/media/ffvpx/libavutil/utils.c
--- a/media/ffvpx/libavutil/utils.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/utils.c	2023-04-06 12:49:40.262395253 +0200
@@ -19,60 +19,12 @@
 #include "config.h"
 #include "avutil.h"
 #include "avassert.h"
-#include "samplefmt.h"
-#include "internal.h"
 
 /**
  * @file
  * various utility functions
  */
 
-#include "libavutil/ffversion.h"
-const char av_util_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
-
-const char *av_version_info(void)
-{
-    return FFMPEG_VERSION;
-}
-
-unsigned avutil_version(void)
-{
-    static int checks_done;
-    if (checks_done)
-        return LIBAVUTIL_VERSION_INT;
-
-    av_assert0(AV_SAMPLE_FMT_DBLP == 9);
-    av_assert0(AVMEDIA_TYPE_ATTACHMENT == 4);
-    av_assert0(AV_PICTURE_TYPE_BI == 7);
-    av_assert0(LIBAVUTIL_VERSION_MICRO >= 100);
-    av_assert0(HAVE_MMX2 == HAVE_MMXEXT);
-
-    av_assert0(((size_t)-1) > 0); // C guarantees this but if false on a platform we care about revert at least b284e1ffe343d6697fb950d1ee517bafda8a9844
-
-    if (av_sat_dadd32(1, 2) != 5) {
-        av_log(NULL, AV_LOG_FATAL, "Libavutil has been built with a broken binutils, please upgrade binutils and rebuild\n");
-        abort();
-    }
-
-    if (llrint(1LL<<60) != 1LL<<60) {
-        av_log(NULL, AV_LOG_ERROR, "Libavutil has been linked to a broken llrint()\n");
-    }
-
-    checks_done = 1;
-    return LIBAVUTIL_VERSION_INT;
-}
-
-const char *avutil_configuration(void)
-{
-    return FFMPEG_CONFIGURATION;
-}
-
-const char *avutil_license(void)
-{
-#define LICENSE_PREFIX "libavutil license: "
-    return &LICENSE_PREFIX FFMPEG_LICENSE[sizeof(LICENSE_PREFIX) - 1];
-}
-
 const char *av_get_media_type_string(enum AVMediaType media_type)
 {
     switch (media_type) {
diff -Naur a/media/ffvpx/libavutil/version.h b/media/ffvpx/libavutil/version.h
--- a/media/ffvpx/libavutil/version.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/version.h	2023-04-06 12:50:24.494176623 +0200
@@ -78,8 +78,8 @@
  * @{
  */
 
-#define LIBAVUTIL_VERSION_MAJOR  56
-#define LIBAVUTIL_VERSION_MINOR  70
+#define LIBAVUTIL_VERSION_MAJOR  58
+#define LIBAVUTIL_VERSION_MINOR   3
 #define LIBAVUTIL_VERSION_MICRO 100
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
@@ -105,42 +105,14 @@
  * @{
  */
 
-#ifndef FF_API_VAAPI
-#define FF_API_VAAPI                    (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_FRAME_QP
-#define FF_API_FRAME_QP                 (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_PLUS1_MINUS1
-#define FF_API_PLUS1_MINUS1             (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_ERROR_FRAME
-#define FF_API_ERROR_FRAME              (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_PKT_PTS
-#define FF_API_PKT_PTS                  (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_CRYPTO_SIZE_T
-#define FF_API_CRYPTO_SIZE_T            (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_FRAME_GET_SET
-#define FF_API_FRAME_GET_SET            (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_PSEUDOPAL
-#define FF_API_PSEUDOPAL                (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_CHILD_CLASS_NEXT
-#define FF_API_CHILD_CLASS_NEXT         (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_BUFFER_SIZE_T
-#define FF_API_BUFFER_SIZE_T            (LIBAVUTIL_VERSION_MAJOR < 57)
-#endif
-#ifndef FF_API_D2STR
-#define FF_API_D2STR                    (LIBAVUTIL_VERSION_MAJOR < 58)
-#endif
-#ifndef FF_API_DECLARE_ALIGNED
-#define FF_API_DECLARE_ALIGNED          (LIBAVUTIL_VERSION_MAJOR < 58)
-#endif
+#define FF_API_FIFO_PEEK2               (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_FIFO_OLD_API             (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_XVMC                     (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_OLD_CHANNEL_LAYOUT       (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_AV_FOPEN_UTF8            (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_PKT_DURATION             (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_REORDERED_OPAQUE         (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_FRAME_PICTURE_NUMBER     (LIBAVUTIL_VERSION_MAJOR < 59)
 
 /**
  * @}
diff -Naur a/media/ffvpx/libavutil/video_enc_params.c b/media/ffvpx/libavutil/video_enc_params.c
--- a/media/ffvpx/libavutil/video_enc_params.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/video_enc_params.c	2023-04-06 12:50:24.494176623 +0200
@@ -16,12 +16,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <limits.h>
 #include <stddef.h>
 #include <stdint.h>
 
 #include "buffer.h"
-#include "common.h"
 #include "frame.h"
 #include "mem.h"
 #include "video_enc_params.h"
@@ -29,10 +27,14 @@
 AVVideoEncParams *av_video_enc_params_alloc(enum AVVideoEncParamsType type,
                                             unsigned int nb_blocks, size_t *out_size)
 {
+    struct TestStruct {
+        AVVideoEncParams   p;
+        AVVideoBlockParams b;
+    };
+    const size_t blocks_offset = offsetof(struct TestStruct, b);
+    size_t size = blocks_offset;
     AVVideoEncParams *par;
-    size_t size;
 
-    size = sizeof(*par);
     if (nb_blocks > (SIZE_MAX - size) / sizeof(AVVideoBlockParams))
         return NULL;
     size += sizeof(AVVideoBlockParams) * nb_blocks;
@@ -44,7 +46,7 @@
     par->type          = type;
     par->nb_blocks     = nb_blocks;
     par->block_size    = sizeof(AVVideoBlockParams);
-    par->blocks_offset = sizeof(*par);
+    par->blocks_offset = blocks_offset;
 
     if (out_size)
         *out_size = size;
@@ -63,10 +65,6 @@
     par = av_video_enc_params_alloc(type, nb_blocks, &size);
     if (!par)
         return NULL;
-    if (size > INT_MAX) {
-        av_free(par);
-        return NULL;
-    }
     buf = av_buffer_create((uint8_t *)par, size, NULL, NULL, 0);
     if (!buf) {
         av_freep(&par);
diff -Naur a/media/ffvpx/libavutil/x86/cpu.c b/media/ffvpx/libavutil/x86/cpu.c
--- a/media/ffvpx/libavutil/x86/cpu.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/cpu.c	2023-04-06 12:49:40.262395253 +0200
@@ -150,9 +150,13 @@
             rval |= AV_CPU_FLAG_AVX2;
 #if HAVE_AVX512 /* F, CD, BW, DQ, VL */
         if ((xcr0_lo & 0xe0) == 0xe0) { /* OPMASK/ZMM state */
-            if ((rval & AV_CPU_FLAG_AVX2) && (ebx & 0xd0030000) == 0xd0030000)
+            if ((rval & AV_CPU_FLAG_AVX2) && (ebx & 0xd0030000) == 0xd0030000) {
                 rval |= AV_CPU_FLAG_AVX512;
-
+#if HAVE_AVX512ICL
+                if ((ebx & 0xd0200000) == 0xd0200000 && (ecx & 0x5f42) == 0x5f42)
+                    rval |= AV_CPU_FLAG_AVX512ICL;
+#endif /* HAVE_AVX512ICL */
+            }
         }
 #endif /* HAVE_AVX512 */
 #endif /* HAVE_AVX2 */
@@ -196,6 +200,10 @@
            used unless explicitly disabled by checking AV_CPU_FLAG_AVXSLOW. */
             if ((family == 0x15 || family == 0x16) && (rval & AV_CPU_FLAG_AVX))
                 rval |= AV_CPU_FLAG_AVXSLOW;
+
+        /* Zen 3 and earlier have slow gather */
+            if ((family <= 0x19) && (rval & AV_CPU_FLAG_AVX2))
+                rval |= AV_CPU_FLAG_SLOW_GATHER;
         }
 
         /* XOP and FMA4 use the AVX instruction coding scheme, so they can't be
@@ -235,6 +243,10 @@
         if ((rval & AV_CPU_FLAG_SSSE3) && !(rval & AV_CPU_FLAG_SSE4) &&
             family == 6 && model < 23)
             rval |= AV_CPU_FLAG_SSSE3SLOW;
+
+        /* Haswell has slow gather */
+        if ((rval & AV_CPU_FLAG_AVX2) && family == 6 && model < 70)
+            rval |= AV_CPU_FLAG_SLOW_GATHER;
     }
 
 #endif /* cpuid */
diff -Naur a/media/ffvpx/libavutil/x86/cpu.h b/media/ffvpx/libavutil/x86/cpu.h
--- a/media/ffvpx/libavutil/x86/cpu.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/cpu.h	2023-04-06 12:49:40.262395253 +0200
@@ -80,6 +80,7 @@
 #define EXTERNAL_AVX2_SLOW(flags)   CPUEXT_SUFFIX_SLOW2(flags, _EXTERNAL, AVX2, AVX)
 #define EXTERNAL_AESNI(flags)       CPUEXT_SUFFIX(flags, _EXTERNAL, AESNI)
 #define EXTERNAL_AVX512(flags)      CPUEXT_SUFFIX(flags, _EXTERNAL, AVX512)
+#define EXTERNAL_AVX512ICL(flags)   CPUEXT_SUFFIX(flags, _EXTERNAL, AVX512ICL)
 
 #define INLINE_AMD3DNOW(flags)      CPUEXT_SUFFIX(flags, _INLINE, AMD3DNOW)
 #define INLINE_AMD3DNOWEXT(flags)   CPUEXT_SUFFIX(flags, _INLINE, AMD3DNOWEXT)
diff -Naur a/media/ffvpx/libavutil/x86/cpuid.asm b/media/ffvpx/libavutil/x86/cpuid.asm
--- a/media/ffvpx/libavutil/x86/cpuid.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/cpuid.asm	2023-04-06 12:49:40.262395253 +0200
@@ -21,7 +21,7 @@
 ;* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 ;******************************************************************************
 
-%include "x86util.asm"
+%include "libavutil/x86/x86util.asm"
 
 SECTION .text
 
diff -Naur a/media/ffvpx/libavutil/x86/emms.asm b/media/ffvpx/libavutil/x86/emms.asm
--- a/media/ffvpx/libavutil/x86/emms.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/emms.asm	2023-04-06 12:49:40.262395253 +0200
@@ -18,7 +18,7 @@
 ;* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 ;******************************************************************************
 
-%include "x86util.asm"
+%include "libavutil/x86/x86util.asm"
 
 SECTION .text
 
diff -Naur a/media/ffvpx/libavutil/x86/emms.h b/media/ffvpx/libavutil/x86/emms.h
--- a/media/ffvpx/libavutil/x86/emms.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/emms.h	2023-04-06 12:49:40.262395253 +0200
@@ -21,11 +21,14 @@
 
 #include "config.h"
 #include "libavutil/attributes.h"
-#include "libavutil/cpu.h"
 
 void avpriv_emms_asm(void);
 
 #if HAVE_MMX_INLINE
+#ifndef __MMX__
+#include "libavutil/cpu.h"
+#endif
+
 #   define emms_c emms_c
 /**
  * Empty mmx state.
diff -Naur a/media/ffvpx/libavutil/x86/fixed_dsp.asm b/media/ffvpx/libavutil/x86/fixed_dsp.asm
--- a/media/ffvpx/libavutil/x86/fixed_dsp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/fixed_dsp.asm	2023-04-06 12:49:40.262395253 +0200
@@ -20,7 +20,7 @@
 ;* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 ;******************************************************************************
 
-%include "x86util.asm"
+%include "libavutil/x86/x86util.asm"
 
 SECTION .text
 
diff -Naur a/media/ffvpx/libavutil/x86/fixed_dsp_init.c b/media/ffvpx/libavutil/x86/fixed_dsp_init.c
--- a/media/ffvpx/libavutil/x86/fixed_dsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/fixed_dsp_init.c	2023-04-06 12:50:06.977471295 +0200
@@ -23,7 +23,7 @@
 #include "libavutil/fixed_dsp.h"
 #include "cpu.h"
 
-void ff_butterflies_fixed_sse2(int *src0, int *src1, int len);
+void ff_butterflies_fixed_sse2(int *av_restrict src0, int *av_restrict src1, int len);
 
 av_cold void ff_fixed_dsp_init_x86(AVFixedDSPContext *fdsp)
 {
diff -Naur a/media/ffvpx/libavutil/x86/float_dsp.asm b/media/ffvpx/libavutil/x86/float_dsp.asm
--- a/media/ffvpx/libavutil/x86/float_dsp.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/float_dsp.asm	2023-04-06 12:50:24.494176623 +0200
@@ -20,7 +20,7 @@
 ;* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 ;******************************************************************************
 
-%include "x86util.asm"
+%include "libavutil/x86/x86util.asm"
 
 SECTION_RODATA 32
 pd_reverse: dd 7, 6, 5, 4, 3, 2, 1, 0
@@ -48,7 +48,7 @@
 
     sub       lenq, 64
     jge       .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse
@@ -141,7 +141,7 @@
 %endif ; mmsize
     sub    lenq, 64
     jge .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse
@@ -178,7 +178,7 @@
     mova  [dstq+lenq], m1
     sub    lenq, mmsize
     jge .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse
@@ -233,7 +233,7 @@
     movaps [dstq+lenq+3*mmsize], m4
     sub    lenq, mmsize*4
     jge .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse2
@@ -280,7 +280,7 @@
     movaps [dstq+lenq+mmsize], m2
     sub          lenq, 2*mmsize
     jge .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse2
@@ -294,7 +294,7 @@
 ; vector_fmul_window(float *dst, const float *src0,
 ;                    const float *src1, const float *win, int len);
 ;-----------------------------------------------------------------------------
-%macro VECTOR_FMUL_WINDOW 0
+INIT_XMM sse
 cglobal vector_fmul_window, 5, 6, 6, dst, src0, src1, win, len, len1
     shl     lend, 2
     lea    len1q, [lenq - mmsize]
@@ -305,7 +305,6 @@
 .loop:
     mova      m0, [winq  + lenq]
     mova      m4, [src0q + lenq]
-%if cpuflag(sse)
     mova      m1, [winq  + len1q]
     mova      m5, [src1q + len1q]
     shufps    m1, m1, 0x1b
@@ -319,34 +318,12 @@
     addps     m2, m3
     subps     m1, m0
     shufps    m2, m2, 0x1b
-%else
-    pswapd    m1, [winq  + len1q]
-    pswapd    m5, [src1q + len1q]
-    mova      m2, m0
-    mova      m3, m1
-    pfmul     m2, m4
-    pfmul     m3, m5
-    pfmul     m1, m4
-    pfmul     m0, m5
-    pfadd     m2, m3
-    pfsub     m1, m0
-    pswapd    m2, m2
-%endif
     mova      [dstq + lenq], m1
     mova      [dstq + len1q], m2
     sub       len1q, mmsize
     add       lenq,  mmsize
     jl .loop
-%if mmsize == 8
-    femms
-%endif
-    REP_RET
-%endmacro
-
-INIT_MMX 3dnowext
-VECTOR_FMUL_WINDOW
-INIT_XMM sse
-VECTOR_FMUL_WINDOW
+    RET
 
 ;-----------------------------------------------------------------------------
 ; vector_fmul_add(float *dst, const float *src0, const float *src1,
@@ -375,7 +352,7 @@
 
     sub     lenq,   2*mmsize
     jge     .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse
@@ -424,7 +401,7 @@
     add     src1q, 2*mmsize
     sub     lenq,  2*mmsize
     jge     .loop
-    REP_RET
+    RET
 %endmacro
 
 INIT_XMM sse
@@ -463,6 +440,133 @@
 %endif
     RET
 
+INIT_YMM fma3
+cglobal scalarproduct_float, 3,5,8, v1, v2, size, len, offset
+    xor   offsetq, offsetq
+    xorps      m0, m0, m0
+    shl     sized, 2
+    mov      lenq, sizeq
+    cmp      lenq, 32
+    jl   .l16
+    cmp      lenq, 64
+    jl   .l32
+    xorps    m1, m1, m1
+    cmp      lenq, 128
+    jl   .l64
+    and    lenq, ~127
+    xorps    m2, m2, m2
+    xorps    m3, m3, m3
+.loop128:
+    movups   m4, [v1q+offsetq]
+    movups   m5, [v1q+offsetq + 32]
+    movups   m6, [v1q+offsetq + 64]
+    movups   m7, [v1q+offsetq + 96]
+    fmaddps  m0, m4, [v2q+offsetq     ], m0
+    fmaddps  m1, m5, [v2q+offsetq + 32], m1
+    fmaddps  m2, m6, [v2q+offsetq + 64], m2
+    fmaddps  m3, m7, [v2q+offsetq + 96], m3
+    add   offsetq, 128
+    cmp   offsetq, lenq
+    jl .loop128
+    addps    m0, m0, m2
+    addps    m1, m1, m3
+    mov      lenq, sizeq
+    and      lenq, 127
+    cmp      lenq, 64
+    jge .l64
+    addps    m0, m0, m1
+    cmp      lenq, 32
+    jge .l32
+    vextractf128 xmm2, m0, 1
+    addps    xmm0, xmm2
+    cmp      lenq, 16
+    jge .l16
+    movhlps  xmm1, xmm0
+    addps    xmm0, xmm1
+    movss    xmm1, xmm0
+    shufps   xmm0, xmm0, 1
+    addss    xmm0, xmm1
+%if ARCH_X86_64 == 0
+    movss r0m, xm0
+    fld dword r0m
+%endif
+    RET
+.l64:
+    and    lenq, ~63
+    add    lenq, offsetq
+.loop64:
+    movups   m4, [v1q+offsetq]
+    movups   m5, [v1q+offsetq + 32]
+    fmaddps  m0, m4, [v2q+offsetq], m0
+    fmaddps  m1, m5, [v2q+offsetq + 32], m1
+    add   offsetq, 64
+    cmp   offsetq, lenq
+    jl .loop64
+    addps    m0, m0, m1
+    mov      lenq, sizeq
+    and      lenq, 63
+    cmp      lenq, 32
+    jge .l32
+    vextractf128 xmm2, m0, 1
+    addps    xmm0, xmm2
+    cmp      lenq, 16
+    jge .l16
+    movhlps  xmm1, xmm0
+    addps    xmm0, xmm1
+    movss    xmm1, xmm0
+    shufps   xmm0, xmm0, 1
+    addss    xmm0, xmm1
+%if ARCH_X86_64 == 0
+    movss r0m, xm0
+    fld dword r0m
+%endif
+    RET
+.l32:
+    and    lenq, ~31
+    add    lenq, offsetq
+.loop32:
+    movups   m4, [v1q+offsetq]
+    fmaddps  m0, m4, [v2q+offsetq], m0
+    add   offsetq, 32
+    cmp   offsetq, lenq
+    jl .loop32
+    vextractf128 xmm2, m0, 1
+    addps    xmm0, xmm2
+    mov      lenq, sizeq
+    and      lenq, 31
+    cmp      lenq, 16
+    jge .l16
+    movhlps  xmm1, xmm0
+    addps    xmm0, xmm1
+    movss    xmm1, xmm0
+    shufps   xmm0, xmm0, 1
+    addss    xmm0, xmm1
+%if ARCH_X86_64 == 0
+    movss r0m, xm0
+    fld dword r0m
+%endif
+    RET
+.l16:
+    and    lenq, ~15
+    add    lenq, offsetq
+.loop16:
+    movaps   xmm1, [v1q+offsetq]
+    mulps    xmm1, [v2q+offsetq]
+    addps    xmm0, xmm1
+    add   offsetq, 16
+    cmp   offsetq, lenq
+    jl .loop16
+    movhlps  xmm1, xmm0
+    addps    xmm0, xmm1
+    movss    xmm1, xmm0
+    shufps   xmm0, xmm0, 1
+    addss    xmm0, xmm1
+%if ARCH_X86_64 == 0
+    movss r0m, xm0
+    fld dword r0m
+%endif
+    RET
+
 ;-----------------------------------------------------------------------------
 ; void ff_butterflies_float(float *src0, float *src1, int len);
 ;-----------------------------------------------------------------------------
@@ -481,4 +585,4 @@
     mova        [src0q + lenq], m0
     add       lenq, mmsize
     jl .loop
-    REP_RET
+    RET
diff -Naur a/media/ffvpx/libavutil/x86/float_dsp_init.c b/media/ffvpx/libavutil/x86/float_dsp_init.c
--- a/media/ffvpx/libavutil/x86/float_dsp_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/float_dsp_init.c	2023-04-06 12:50:06.977471295 +0200
@@ -56,8 +56,6 @@
 void ff_vector_dmul_scalar_avx(double *dst, const double *src,
                                double mul, int len);
 
-void ff_vector_fmul_window_3dnowext(float *dst, const float *src0,
-                                    const float *src1, const float *win, int len);
 void ff_vector_fmul_window_sse(float *dst, const float *src0,
                                const float *src1, const float *win, int len);
 
@@ -76,6 +74,7 @@
                                  const float *src1, int len);
 
 float ff_scalarproduct_float_sse(const float *v1, const float *v2, int order);
+float ff_scalarproduct_float_fma3(const float *v1, const float *v2, int order);
 
 void ff_butterflies_float_sse(float *av_restrict src0, float *av_restrict src1, int len);
 
@@ -83,9 +82,6 @@
 {
     int cpu_flags = av_get_cpu_flags();
 
-    if (EXTERNAL_AMD3DNOWEXT(cpu_flags)) {
-        fdsp->vector_fmul_window = ff_vector_fmul_window_3dnowext;
-    }
     if (EXTERNAL_SSE(cpu_flags)) {
         fdsp->vector_fmul = ff_vector_fmul_sse;
         fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;
@@ -117,5 +113,6 @@
         fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_fma3;
         fdsp->vector_fmul_add    = ff_vector_fmul_add_fma3;
         fdsp->vector_dmac_scalar = ff_vector_dmac_scalar_fma3;
+        fdsp->scalarproduct_float = ff_scalarproduct_float_fma3;
     }
 }
diff -Naur a/media/ffvpx/libavutil/x86/imgutils_init.c b/media/ffvpx/libavutil/x86/imgutils_init.c
--- a/media/ffvpx/libavutil/x86/imgutils_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/imgutils_init.c	2023-04-06 12:49:40.262395253 +0200
@@ -21,9 +21,8 @@
 
 #include "libavutil/cpu.h"
 #include "libavutil/error.h"
-#include "libavutil/imgutils.h"
 #include "libavutil/imgutils_internal.h"
-#include "libavutil/internal.h"
+#include "libavutil/macros.h"
 
 #include "cpu.h"
 
diff -Naur a/media/ffvpx/libavutil/x86/intmath.h b/media/ffvpx/libavutil/x86/intmath.h
--- a/media/ffvpx/libavutil/x86/intmath.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/intmath.h	2023-04-06 12:49:40.263395293 +0200
@@ -110,8 +110,8 @@
 #if defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
     if (amin > amax) abort();
 #endif
-    __asm__ ("minsd %2, %0 \n\t"
-             "maxsd %1, %0 \n\t"
+    __asm__ ("maxsd %1, %0 \n\t"
+             "minsd %2, %0 \n\t"
              : "+&x"(a) : "xm"(amin), "xm"(amax));
     return a;
 }
@@ -126,14 +126,44 @@
 #if defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
     if (amin > amax) abort();
 #endif
-    __asm__ ("minss %2, %0 \n\t"
-             "maxss %1, %0 \n\t"
+    __asm__ ("maxss %1, %0 \n\t"
+             "minss %2, %0 \n\t"
              : "+&x"(a) : "xm"(amin), "xm"(amax));
     return a;
 }
 
 #endif /* __SSE__ */
 
+#if defined(__AVX__) && !defined(__INTEL_COMPILER)
+
+#undef av_clipd
+#define av_clipd av_clipd_avx
+static av_always_inline av_const double av_clipd_avx(double a, double amin, double amax)
+{
+#if defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
+    if (amin > amax) abort();
+#endif
+    __asm__ ("vmaxsd %1, %0, %0 \n\t"
+             "vminsd %2, %0, %0 \n\t"
+             : "+&x"(a) : "xm"(amin), "xm"(amax));
+    return a;
+}
+
+#undef av_clipf
+#define av_clipf av_clipf_avx
+static av_always_inline av_const float av_clipf_avx(float a, float amin, float amax)
+{
+#if defined(ASSERT_LEVEL) && ASSERT_LEVEL >= 2
+    if (amin > amax) abort();
+#endif
+    __asm__ ("vmaxss %1, %0, %0 \n\t"
+             "vminss %2, %0, %0 \n\t"
+             : "+&x"(a) : "xm"(amin), "xm"(amax));
+    return a;
+}
+
+#endif /* __AVX__ */
+
 #endif /* __GNUC__ */
 
 #endif /* AVUTIL_X86_INTMATH_H */
diff -Naur a/media/ffvpx/libavutil/x86/intreadwrite.h b/media/ffvpx/libavutil/x86/intreadwrite.h
--- a/media/ffvpx/libavutil/x86/intreadwrite.h	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/intreadwrite.h	2023-04-06 12:50:06.977471295 +0200
@@ -29,6 +29,8 @@
 
 #if !HAVE_FAST_64BIT && defined(__MMX__)
 
+#define FF_COPY_SWAP_ZERO_USES_MMX
+
 #define AV_COPY64 AV_COPY64
 static av_always_inline void AV_COPY64(void *d, const void *s)
 {
diff -Naur a/media/ffvpx/libavutil/x86/lls.asm b/media/ffvpx/libavutil/x86/lls.asm
--- a/media/ffvpx/libavutil/x86/lls.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/lls.asm	2023-04-06 12:50:24.494176623 +0200
@@ -20,7 +20,7 @@
 ;* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 ;******************************************************************************
 
-%include "x86util.asm"
+%include "libavutil/x86/x86util.asm"
 
 SECTION .text
 
@@ -123,7 +123,7 @@
     test    id, id
     jle .loop2x1
 .ret:
-    REP_RET
+    RET
 
 %macro UPDATE_LLS 0
 cglobal update_lls, 3,6,8, ctx, var, count, i, j, count2
@@ -240,7 +240,7 @@
     cmp     id, countd
     jle .loop2x1
 .ret:
-    REP_RET
+    RET
 %endmacro ; UPDATE_LLS
 
 %if HAVE_AVX_EXTERNAL
diff -Naur a/media/ffvpx/libavutil/x86/lls_init.c b/media/ffvpx/libavutil/x86/lls_init.c
--- a/media/ffvpx/libavutil/x86/lls_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/lls_init.c	2023-04-06 12:49:40.263395293 +0200
@@ -20,6 +20,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "libavutil/attributes.h"
 #include "libavutil/lls.h"
 #include "libavutil/x86/cpu.h"
 
diff -Naur a/media/ffvpx/libavutil/x86/pixelutils.asm b/media/ffvpx/libavutil/x86/pixelutils.asm
--- a/media/ffvpx/libavutil/x86/pixelutils.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/pixelutils.asm	2023-04-06 12:49:40.263395293 +0200
@@ -21,49 +21,11 @@
 ;* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 ;******************************************************************************
 
-%include "x86util.asm"
+%include "libavutil/x86/x86util.asm"
 
 SECTION .text
 
 ;-------------------------------------------------------------------------------
-; int ff_pixelutils_sad_8x8_mmx(const uint8_t *src1, ptrdiff_t stride1,
-;                               const uint8_t *src2, ptrdiff_t stride2);
-;-------------------------------------------------------------------------------
-INIT_MMX mmx
-cglobal pixelutils_sad_8x8, 4,4,0, src1, stride1, src2, stride2
-    pxor        m7, m7
-    pxor        m6, m6
-%rep 4
-    mova        m0, [src1q]
-    mova        m2, [src1q + stride1q]
-    mova        m1, [src2q]
-    mova        m3, [src2q + stride2q]
-    psubusb     m4, m0, m1
-    psubusb     m5, m2, m3
-    psubusb     m1, m0
-    psubusb     m3, m2
-    por         m1, m4
-    por         m3, m5
-    punpcklbw   m0, m1, m7
-    punpcklbw   m2, m3, m7
-    punpckhbw   m1, m7
-    punpckhbw   m3, m7
-    paddw       m0, m1
-    paddw       m2, m3
-    paddw       m0, m2
-    paddw       m6, m0
-    lea         src1q, [src1q + 2*stride1q]
-    lea         src2q, [src2q + 2*stride2q]
-%endrep
-    psrlq       m0, m6, 32
-    paddw       m6, m0
-    psrlq       m0, m6, 16
-    paddw       m6, m0
-    movd        eax, m6
-    movzx       eax, ax
-    RET
-
-;-------------------------------------------------------------------------------
 ; int ff_pixelutils_sad_8x8_mmxext(const uint8_t *src1, ptrdiff_t stride1,
 ;                                  const uint8_t *src2, ptrdiff_t stride2);
 ;-------------------------------------------------------------------------------
@@ -82,26 +44,6 @@
 %endrep
     movd        eax, m2
     RET
-
-;-------------------------------------------------------------------------------
-; int ff_pixelutils_sad_16x16_mmxext(const uint8_t *src1, ptrdiff_t stride1,
-;                                    const uint8_t *src2, ptrdiff_t stride2);
-;-------------------------------------------------------------------------------
-INIT_MMX mmxext
-cglobal pixelutils_sad_16x16, 4,4,0, src1, stride1, src2, stride2
-    pxor        m2, m2
-%rep 16
-    mova        m0, [src1q]
-    mova        m1, [src1q + 8]
-    psadbw      m0, [src2q]
-    psadbw      m1, [src2q + 8]
-    paddw       m2, m0
-    paddw       m2, m1
-    add         src1q, stride1q
-    add         src2q, stride2q
-%endrep
-    movd        eax, m2
-    RET
 
 ;-------------------------------------------------------------------------------
 ; int ff_pixelutils_sad_16x16_sse2(const uint8_t *src1, ptrdiff_t stride1,
diff -Naur a/media/ffvpx/libavutil/x86/pixelutils_init.c b/media/ffvpx/libavutil/x86/pixelutils_init.c
--- a/media/ffvpx/libavutil/x86/pixelutils_init.c	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/pixelutils_init.c	2023-04-06 12:49:40.263395293 +0200
@@ -21,13 +21,9 @@
 #include "pixelutils.h"
 #include "cpu.h"
 
-int ff_pixelutils_sad_8x8_mmx(const uint8_t *src1, ptrdiff_t stride1,
-                              const uint8_t *src2, ptrdiff_t stride2);
 int ff_pixelutils_sad_8x8_mmxext(const uint8_t *src1, ptrdiff_t stride1,
                                  const uint8_t *src2, ptrdiff_t stride2);
 
-int ff_pixelutils_sad_16x16_mmxext(const uint8_t *src1, ptrdiff_t stride1,
-                                   const uint8_t *src2, ptrdiff_t stride2);
 int ff_pixelutils_sad_16x16_sse2(const uint8_t *src1, ptrdiff_t stride1,
                                  const uint8_t *src2, ptrdiff_t stride2);
 int ff_pixelutils_sad_a_16x16_sse2(const uint8_t *src1, ptrdiff_t stride1,
@@ -53,10 +49,6 @@
 {
     int cpu_flags = av_get_cpu_flags();
 
-    if (EXTERNAL_MMX(cpu_flags)) {
-        sad[2] = ff_pixelutils_sad_8x8_mmx;
-    }
-
     // The best way to use SSE2 would be to do 2 SADs in parallel,
     // but we'd have to modify the pixelutils API to return SIMD functions.
 
@@ -65,7 +57,6 @@
     // so just use the MMX 8x8 version even when SSE2 is available.
     if (EXTERNAL_MMXEXT(cpu_flags)) {
         sad[2] = ff_pixelutils_sad_8x8_mmxext;
-        sad[3] = ff_pixelutils_sad_16x16_mmxext;
     }
 
     if (EXTERNAL_SSE2(cpu_flags)) {
diff -Naur a/media/ffvpx/libavutil/x86/x86inc.asm b/media/ffvpx/libavutil/x86/x86inc.asm
--- a/media/ffvpx/libavutil/x86/x86inc.asm	2023-03-10 00:59:37.000000000 +0100
+++ b/media/ffvpx/libavutil/x86/x86inc.asm	2023-04-06 12:49:40.263395293 +0200
@@ -817,32 +817,33 @@
 
 ; cpuflags
 
-%assign cpuflags_mmx      (1<<0)
-%assign cpuflags_mmx2     (1<<1) | cpuflags_mmx
-%assign cpuflags_3dnow    (1<<2) | cpuflags_mmx
-%assign cpuflags_3dnowext (1<<3) | cpuflags_3dnow
-%assign cpuflags_sse      (1<<4) | cpuflags_mmx2
-%assign cpuflags_sse2     (1<<5) | cpuflags_sse
-%assign cpuflags_sse2slow (1<<6) | cpuflags_sse2
-%assign cpuflags_lzcnt    (1<<7) | cpuflags_sse2
-%assign cpuflags_sse3     (1<<8) | cpuflags_sse2
-%assign cpuflags_ssse3    (1<<9) | cpuflags_sse3
-%assign cpuflags_sse4     (1<<10)| cpuflags_ssse3
-%assign cpuflags_sse42    (1<<11)| cpuflags_sse4
-%assign cpuflags_aesni    (1<<12)| cpuflags_sse42
-%assign cpuflags_avx      (1<<13)| cpuflags_sse42
-%assign cpuflags_xop      (1<<14)| cpuflags_avx
-%assign cpuflags_fma4     (1<<15)| cpuflags_avx
-%assign cpuflags_fma3     (1<<16)| cpuflags_avx
-%assign cpuflags_bmi1     (1<<17)| cpuflags_avx|cpuflags_lzcnt
-%assign cpuflags_bmi2     (1<<18)| cpuflags_bmi1
-%assign cpuflags_avx2     (1<<19)| cpuflags_fma3|cpuflags_bmi2
-%assign cpuflags_avx512   (1<<20)| cpuflags_avx2 ; F, CD, BW, DQ, VL
+%assign cpuflags_mmx       (1<<0)
+%assign cpuflags_mmx2      (1<<1) | cpuflags_mmx
+%assign cpuflags_3dnow     (1<<2) | cpuflags_mmx
+%assign cpuflags_3dnowext  (1<<3) | cpuflags_3dnow
+%assign cpuflags_sse       (1<<4) | cpuflags_mmx2
+%assign cpuflags_sse2      (1<<5) | cpuflags_sse
+%assign cpuflags_sse2slow  (1<<6) | cpuflags_sse2
+%assign cpuflags_lzcnt     (1<<7) | cpuflags_sse2
+%assign cpuflags_sse3      (1<<8) | cpuflags_sse2
+%assign cpuflags_ssse3     (1<<9) | cpuflags_sse3
+%assign cpuflags_sse4      (1<<10)| cpuflags_ssse3
+%assign cpuflags_sse42     (1<<11)| cpuflags_sse4
+%assign cpuflags_aesni     (1<<12)| cpuflags_sse42
+%assign cpuflags_avx       (1<<13)| cpuflags_sse42
+%assign cpuflags_xop       (1<<14)| cpuflags_avx
+%assign cpuflags_fma4      (1<<15)| cpuflags_avx
+%assign cpuflags_fma3      (1<<16)| cpuflags_avx
+%assign cpuflags_bmi1      (1<<17)| cpuflags_avx|cpuflags_lzcnt
+%assign cpuflags_bmi2      (1<<18)| cpuflags_bmi1
+%assign cpuflags_avx2      (1<<19)| cpuflags_fma3|cpuflags_bmi2
+%assign cpuflags_avx512    (1<<20)| cpuflags_avx2 ; F, CD, BW, DQ, VL
+%assign cpuflags_avx512icl (1<<25)| cpuflags_avx512
 
-%assign cpuflags_cache32  (1<<21)
-%assign cpuflags_cache64  (1<<22)
-%assign cpuflags_aligned  (1<<23) ; not a cpu feature, but a function variant
-%assign cpuflags_atom     (1<<24)
+%assign cpuflags_cache32   (1<<21)
+%assign cpuflags_cache64   (1<<22)
+%assign cpuflags_aligned   (1<<23) ; not a cpu feature, but a function variant
+%assign cpuflags_atom      (1<<24)
 
 ; Returns a boolean value expressing whether or not the specified cpuflag is enabled.
 %define    cpuflag(x) (((((cpuflags & (cpuflags_ %+ x)) ^ (cpuflags_ %+ x)) - 1) >> 31) & 1)
diff -Naur a/toolkit/moz.configure b/toolkit/moz.configure
--- a/toolkit/moz.configure	2023-03-10 00:59:39.000000000 +0100
+++ b/toolkit/moz.configure	2023-04-06 12:49:19.193546510 +0200
@@ -2142,7 +2142,7 @@
 
     @depends(target)
     def libav_fft(target):
-        return target.kernel == "WINNT" or target.cpu == "x86_64"
+        return target.kernel in ("WINNT", "Darwin") or target.cpu == "x86_64"
 
     set_config("MOZ_LIBAV_FFT", depends(when=libav_fft)(lambda: True))
     set_define("MOZ_LIBAV_FFT", depends(when=libav_fft)(lambda: True))
@@ -2173,18 +2173,20 @@
                 flags = ["-DPIC", "-DWIN64"]
                 use_nasm = False
         elif target.kernel == "Darwin":
+            # 32/64-bit macosx assemblers need to prefix symbols with an
+            # underscore.
+            flags = [
+                "-DPIC",
+                "-DMACHO",
+                "-DPREFIX"
+            ]
             if target.cpu == "x86_64":
-                # 32/64-bit macosx asemblers need to prefix symbols with an
-                # underscore.
-                flags = [
+                flags += [
                     "-D__x86_64__",
-                    "-DPIC",
-                    "-DMACHO",
-                    "-DPREFIX",
                     "-Pconfig_darwin64.asm",
                 ]
-            else:
-                flac_only = True
+            elif target.cpu == "aarch64":
+                use_nasm = False
         elif target.cpu == "x86_64":
             flags = ["-D__x86_64__", "-DPIC", "-DELF", "-Pconfig_unix64.asm"]
         elif target.cpu in ("x86", "arm", "aarch64"):
@@ -2195,10 +2197,6 @@
         if flac_only or not enable:
             use_nasm = False
 
-        if use_nasm:
-            # default disabled components
-            flags.append("-Pdefaults_disabled.asm")
-
         return namespace(
             enable=enable,
             use_nasm=use_nasm,
diff -Naur a/tools/rewriting/ThirdPartyPaths.txt b/tools/rewriting/ThirdPartyPaths.txt
--- a/tools/rewriting/ThirdPartyPaths.txt	2023-03-10 00:59:39.000000000 +0100
+++ b/tools/rewriting/ThirdPartyPaths.txt	2023-04-06 12:58:33.700797413 +0200
@@ -32,6 +32,7 @@
 dom/media/platforms/ffmpeg/ffmpeg57/
 dom/media/platforms/ffmpeg/ffmpeg58/
 dom/media/platforms/ffmpeg/ffmpeg59/
+dom/media/platforms/ffmpeg/ffmpeg60/
 dom/media/platforms/ffmpeg/libav53/
 dom/media/platforms/ffmpeg/libav54/
 dom/media/platforms/ffmpeg/libav55/
